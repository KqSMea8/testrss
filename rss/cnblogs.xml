<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 的 WebGL 自定义 3D 摄像头监控模型 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/9466110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/9466110.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。&lt;/p&gt;
&lt;p&gt;在监控摄像机数量的不断庞大的同时，在监控系统中面临着严峻的现状问题：海量视频分散、孤立、视角不完整、位置不明确等问题，始终围绕着使用者。因此，如何更直观、更明确的管理摄像机和掌控视频动态，已成为提升视频应用价值的重要话题。所以当前项目正是从解决此现状问题的角度，应运而生。围绕如何提高、管理和有效利用前端设备采集的海量信息为公共安全服务，特别是在技术融合大趋势下，如何结合当前先进的视频融合，虚实融合、三维动态等技术，实现三维场景实时动态可视化监控，更有效的识别、分析、挖掘海量数据的有效信息服务公共应用，已成为视频监控平台可视化发展的趋势和方向。目前，在监控行业中，海康、大华等做监控行业领导者可基于这样的方式规划公共场所园区等的摄像头规划安放布局，可以通过海康、大华等摄像头品牌的摄像头参数，调整系统中摄像头模型的可视范围，监控方向等，更方便的让人们直观的了解摄像头的监控区域，监控角度等。&lt;/p&gt;
&lt;p&gt;以下是项目地址：&lt;a href=&quot;http://www.hightopo.com/demo/Camera/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;基于 HTML5 的 WebGL 自定义 3D 摄像头监控模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;效果预览&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;整体场景-摄像头效果图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074129353-858216626.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;局部场景-摄像头效果图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074159610-98573873.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码生成&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;摄像头模型及场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;项目中使用的摄像头模型是通过 3dMax 建模生成的，该建模工具可以导出 obj 与 mtl 文件，在 HT 中可以通过解析 obj 与 mtl 文件来生成 3d 场景中的摄像头模型。&lt;/p&gt;
&lt;p&gt;项目中场景通过 HT 的 3d 编辑器进行搭建，场景中的模型有些是通过 HT 建模，有些通过 3dMax 建模，之后导入 HT 中，场景中的地面白色的灯光，是通过 HT 的 3d 编辑器进行地面贴图呈现出来的效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;锥体建模&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3D 模型是由最基础的三角形面拼接合成，例如 1 个矩形可以由 2 个三角形构成，1 个立方体由 6 个面即 12 个三角形构成， 以此类推更复杂的模型可以由许多的小三角形组合合成。因此 3D 模型定义即为对构造模型的所有三角形的描述， 而每个三角形由三个顶点 vertex 构成， 每个顶点 vertex 由 x, y, z 三维空间坐标决定，HT 采用右手螺旋定则来确定三个顶点构造三角形面的正面。&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt; 函数，可注册自定义 3D 模型，摄像头前方生成的锥体便是通过该方法生成。可以将该锥体看成由 5 个顶点，6 个三角形组成，具体图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074221681-1867969782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;name&lt;/strong&gt; 为模型名称，如果名称与预定义的一样，则会替换预定义的模型&lt;br/&gt;2. &lt;strong&gt;model&lt;/strong&gt; 为JSON类型对象，其中 &lt;em&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;/em&gt; 表示顶点坐标数组，&lt;em&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/em&gt; 表示索引数组，&lt;em&gt;&lt;strong&gt;uv&lt;/strong&gt;&lt;/em&gt; 表示贴图坐标数组，如果想要单独定义某个面，可以通过 &lt;em&gt;&lt;strong&gt;bottom_vs，bottom_is，bottom_uv，top_vs，top_is， top_uv&lt;/strong&gt;&lt;/em&gt; 等来定义，之后便可以通过 &lt;em&gt;&lt;strong&gt;shape3d.top.*， shape3d.bottom.*&lt;/strong&gt;&lt;/em&gt;  等单独控制某个面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是我定义模型的代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; camera 是当前的摄像头图元&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; fovy 为摄像头的张角的一半的 tan 值&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; setRangeModel = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(camera, fovy) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fovyVal = 0.5 *&lt;span&gt; fovy;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pointArr = [0, 0, 0, -fovyVal, fovyVal, 0.5, fovyVal, fovyVal, 0.5, fovyVal, -fovyVal, 0.5, -fovyVal, -fovyVal, 0.5&lt;span&gt;];
    ht.Default.setShape3dModel(camera.getTag(), [{
        vs: pointArr,
        is: [&lt;/span&gt;2, 1, 0, 4, 1, 0, 4, 3, 0, 3, 2, 0&lt;span&gt;],
        from_vs: pointArr.slice(&lt;/span&gt;3, 15&lt;span&gt;),
        from_is: [&lt;/span&gt;3, 1, 0, 3, 2, 1&lt;span&gt;],
        from_uv: [&lt;/span&gt;0, 0, 1, 0, 1, 1, 0, 1&lt;span&gt;]
    }]);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我将当前摄像头的 tag 标签值作为模型的名称，tag 标签在 HT 中用于唯一标识一个图元，用户可以自定义 tag 的值。通过 pointArr 记录当前五面体的五个顶点坐标信息，代码中通过 from_vs, from_is, from_uv 单独构建五面体底面，底面用于显示当前摄像头呈现的图像。&lt;/p&gt;
&lt;p&gt;代码中设置了锥体 style 对象的 &lt;strong&gt;wf.geometry&lt;/strong&gt; 属性，通过该属性可以为锥体添加模型的线框，增强模型的立体效果，并且通过 &lt;strong&gt;wf.color，wf.width&lt;/strong&gt; 等参数调节线框的颜色，粗细等。&lt;/p&gt;
&lt;p&gt;相关模型 style 属性的设置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;rangeNode.s({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     'shape3d'&lt;span&gt;: cameraName,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摄像头模型名称&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     'shape3d.color': 'rgba(52, 148, 252, 0.3)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锥体模型颜色&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     'shape3d.reverse.flip': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锥体模型的反面是否显示正面的内容&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     'shape3d.light': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锥体模型是否受光线影响&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     'shape3d.transparent': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锥体模型是否透明&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     '3d.movable': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锥体模型是否可移动&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     'wf.geometry': &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示锥体模型线框&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;摄像头图像生成原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;透视投影&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。 透视使得远的对象变小，近的对象变大，平行线会出现先交等更更接近人眼观察的视觉效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074233279-699657637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，透视投影最终显示到屏幕上的内容只有截头锥体( View Frustum )部分的内容， 因此 Graph3dView 提供了 eye, center, up, far，near，fovy 和 aspect 参数来控制截头锥体的具体范围。具体的透视投影可以参考 &lt;strong&gt;HT for Web&lt;/strong&gt; 的 &lt;a href=&quot;https://hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;3D&lt;/a&gt; 手册。&lt;/p&gt;
&lt;p&gt;根据上图的描述，在本项目中可以在摄像头初始化之后，缓存当前 3d 场景 eyes 眼睛的位置，以及 center 中心的位置，之后将 3d 场景 eyes 眼睛和 center 中心设置成摄像头中心点的位置，然后在这个时刻获取当前 3d 场景的截图，该截图即为当前摄像头的监控图像，之后再将 3d 场景的 center 与 eyes 设置成开始时缓存的 eyes 与 center 位置，通过该方法即可实现 3d 场景中任意位置的快照，从而实现摄像头监控图像实时生成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getFrontImg(camera, rangeNode) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; oldEye =&lt;span&gt; g3d.getEye();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; oldCenter =&lt;span&gt; g3d.getCenter();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; oldFovy =&lt;span&gt; g3d.getFovy();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    g3d.setEye(摄像头位置);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    g3d.setCenter(摄像头朝向);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    g3d.setFovy(摄像头张角);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    g3d.setAspect(摄像头宽高比);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    g3d.validateImp();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    g3d.toDataURL();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    g3d.setEye(oldEye);;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    g3d.setCenter(oldCenter);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    g3d.setFovy(oldFovy);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    g3d.setAspect(undefined);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    g3d.validateImp();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过测试之后，通过该方法进行图像的获取会导致页面有所卡顿，因为是获取当前 3d 场景的整体截图，由于当前3d场景是比较大的，所以 toDataURL 获取图像信息是非常慢的，因此我采取了离屏的方式来获取图像，具体方式如下：&lt;br/&gt;   1. 创建一个新的 3d 场景，将当前场景的宽度与高度都设置为 200px 的大小，并且当前 3d 场景的内容与主屏的场景是一样的，HT中通过 new ht.graph3d.Graph3dView(dataModel) 来新建场景，其中的 dataModel 为当前场景的所有图元，所以主屏与离屏的 3d 场景都共用同一个 dataModel，保证了场景的一致。&lt;br/&gt;   2. 将新创建的场景位置设置成屏幕看不到的地方，并且添加进 dom 中。&lt;br/&gt;   3. 将之前对主屏获取图像的操作变成对离屏获取图像的操作，此时离屏图像的大小相对之前主屏获取图像的大小小很多，并且离屏获取不需要保存原来的眼睛 eyes 的位置以及 center 中心的位置，因为我们没有改变主屏的 eyes 与 center 的位置， 所以也减少的切换带来的开销，大大提高了摄像头获取图像的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是该方法实现的代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getFrontImg(camera, rangeNode) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 截取当前图像时将该摄像头所属的五面体隐藏&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     rangeNode.s('shape3d.from.visible', &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     rangeNode.s('shape3d.visible', &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     rangeNode.s('wf.geometry', &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; cameraP3 =&lt;span&gt; camera.p3();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; cameraR3 =&lt;span&gt; camera.r3();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; cameraS3 =&lt;span&gt; camera.s3();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; updateScreen = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        demoUtil.Canvas2dRender(camera, outScreenG3d.getCanvas());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        rangeNode.s({
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             'shape3d.from.image': camera.a('canvas'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         rangeNode.s('shape3d.from.visible', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         rangeNode.s('shape3d.visible', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         rangeNode.s('wf.geometry', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前锥体起始位置&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; realP3 = [cameraP3[0], cameraP3[1] + cameraS3[1] / 2, cameraP3[2] + cameraS3[2] / 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前眼睛位置绕着摄像头起始位置旋转得到正确眼睛位置&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; realEye =&lt;span&gt; demoUtil.getCenter(cameraP3, realP3, cameraR3);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    outScreenG3d.setEye(realEye);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     outScreenG3d.setCenter(demoUtil.getCenter(realEye, [realEye[0], realEye[1], realEye[2] + 5&lt;span&gt;], cameraR3));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     outScreenG3d.setFovy(camera.a('fovy'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    outScreenG3d.validate();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    updateScreen();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中有一个 getCenter 方法是用于获取 3d 场景中点 A 绕着点 B 旋转 angle 角度之后得到的点 A 在 3d 场景中的位置，方法中采用了 HT 封装的 ht.Math 下面的方法，以下为代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pointA 为 pointB 围绕的旋转点&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pointB 为需要旋转的点&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; r3 为旋转的角度数组 [xAngle, yAngle, zAngle] 为绕着 x, y, z 轴分别旋转的角度 &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; getCenter = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(pointA, pointB, r3) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; mtrx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Math.Matrix4();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; euler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Math.Euler();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; v1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Math.Vector3();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; v2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Math.Vector3();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    v1.fromArray(pointB).sub(v2.fromArray(pointA));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    v2.copy(v1).applyMatrix4(mtrx);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    v2.sub(v1);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] +&lt;span&gt; v2.z];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里应用到向量的部分知识，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OA + OB = OC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074251110-1058475078.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法分为以下几个步骤求解：&lt;/p&gt;
&lt;p&gt;   1.  &lt;strong&gt;var mtrx = new ht.Math.Matrix4()&lt;/strong&gt; 创建一个转换矩阵，通过 &lt;strong&gt;mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2]))&lt;/strong&gt; 获取绕着 r3[0]，r3[1]，r3[2] 即 x 轴，y 轴，z 轴旋转的旋转矩阵。&lt;br/&gt;   2. 通过 &lt;strong&gt;new ht.Math.Vector3()&lt;/strong&gt; 创建 v1，v2 两个向量。&lt;br/&gt;   3. &lt;strong&gt;v1.fromArray(pointB)&lt;/strong&gt; 为建立一个从原点到 pointB 的一个向量。&lt;br/&gt;   4. &lt;strong&gt;v2.fromArray(pointA)&lt;/strong&gt; 为建立一个从原点到 pointA 的一个向量。&lt;br/&gt;   5. &lt;strong&gt;v1.fromArray(pointB).sub(v2.fromArray(pointA))&lt;/strong&gt; 即向量 OB - OA 此时得到的向量为 AB，此时 v1 变为向量 AB。&lt;br/&gt;   6. &lt;strong&gt;v2.copy(v1)&lt;/strong&gt; v2 向量拷贝 v1 向量，之后通过 &lt;strong&gt;v2.copy(v1).applyMatrix4(mtrx)&lt;/strong&gt; 对 v2 向量应用旋转矩阵，变换之后即为 v1向量绕着 pointA 旋转之后的的向量 v2。&lt;br/&gt;   7. 此时通过 &lt;strong&gt;v2.sub(v1)&lt;/strong&gt; 就获取了起始点为 pointB，终点为 pointB 旋转之后点构成的向量，该向量此时即为 v2。&lt;br/&gt;   8. 通过向量公式得到旋转之后的点为 [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] + v2.z]。&lt;/p&gt;
&lt;p&gt;项目中的 3D 场景例子其实是 &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;Hightopo&lt;/a&gt; 最近贵州数博会，HT 上工业互联网展台的 VR 示例，大众对 VR/AR 的期待很高，但路还是得一步步走，即使融资了 23 亿美金的 Magic Leap 的第一款产品也只能是 &lt;a href=&quot;https://mp.weixin.qq.com/s/Z-gcPasf6E4OdNbqBwBhFA&quot; target=&quot;_blank&quot;&gt;Full of Shit&lt;/a&gt;，这话题以后再展开，这里就上段当时现场的视频照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074306832-325606716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2d 图像贴到 3d 模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过上一步的介绍我们可以获取当前摄像机位置的截屏图像，那么如何将当前图像贴到前面所构建的五面体底部呢？前面通过 from_vs, from_is 来构建底部的长方形，所以在 HT 中可以通过将五面体的 style 中 shape3d.from.image 属性设置成当前图像，其中 from_uv 数组用来定义贴图的位置，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074323039-360588324.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;以下为定义贴图位置 from_uv 的代码：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; from_uv: [0, 0, 1, 0, 1, 1, 0, 1]&lt;/span&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;from_uv 就是定义贴图的位置数组，根据上图的解释，可以将 2d 图像贴到 3d 模型的 from 面。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;控制面板&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;new ht.widget.Panel()&lt;/strong&gt; 来生成如下图的面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074334164-1462206036.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面板中每个摄像头都有一个模块来呈现当前监控图像，其实这个地方也是一个 canvas，该 canvas 与场景中锥体前面的监控图像是同一个 canvas，每一个摄像头都有一个自己的 canvas 用来保存当前摄像头的实时监控画面，这样就可以将该 canvas 贴到任何地方，将该 canvas 添加进面板的代码如下：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;formPane.addRow([{&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; element: camera.a('canvas'&lt;span&gt;)&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; }], 240, 240);&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;代码中将 canvas 节点存储在摄像头图元的 attr 属性下面，之后便可以通过 &lt;strong&gt;camera.a('canvas')&lt;/strong&gt; 来获取当前摄像头的画面。&lt;/p&gt;
&lt;p&gt;在面板中的每一个控制节点都是通过 &lt;strong&gt;formPane.addRow&lt;/strong&gt; 来进行添加，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;表单手册&lt;/a&gt;。之后通过 ht.widget.Panel 将表单面板 formPane 添加进 panel 面板中，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/panel/ht-panel-guide.html&quot; target=&quot;_blank&quot;&gt;面板手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分控制代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; formPane.addRow(['rotateY'&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    slider: {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         min: -&lt;span&gt;Math.PI,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        max: Math.PI,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         value: r3[1&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         onValueChanged: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cameraR3 =&lt;span&gt; camera.r3();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             camera.r3([cameraR3[0], &lt;span&gt;this&lt;/span&gt;.getValue(), cameraR3[2&lt;span&gt;]]);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             rangeNode.r3([cameraR3[0], &lt;span&gt;this&lt;/span&gt;.getValue(), cameraR3[2&lt;span&gt;]]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            getFrontImg(camera, rangeNode);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }], [0.1, 0.15]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制面板通过 &lt;strong&gt;addRow&lt;/strong&gt; 来添加控制元素，以上代码为添加摄像头绕着 y 轴进行旋转的控制，&lt;strong&gt;onValueChanged&lt;/strong&gt; 在 slider 的数值改变的时候调用，此时通过 &lt;strong&gt;camera.r3()&lt;/strong&gt; 获取当前摄像头的旋转参数， 由于是绕着 y 轴旋转所以 x 轴与 z 轴的角度是不变的，变的是 y 轴的旋转角度，所以通过 &lt;strong&gt;camera.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来调整摄像头的旋转角度以及通过 &lt;strong&gt;rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来设置摄像头前方锥体的旋转角度，然后调用之前封装好的 &lt;strong&gt;getFrontImg&lt;/strong&gt; 函数来获取此时旋转角度下面的实时图像信息。&lt;/p&gt;
&lt;p&gt;项目中通过 Panel 面板的配置参数 &lt;strong&gt;titleBackground: rgba(230, 230, 230, 0.4) &lt;/strong&gt;即可将标题背景设置为具有透明度的背景，其它类似的 titleColor, titleHeight 等标题参数都可以配置，通过 separatorColor,separatorWidth 等分割参数可以设置内部面板之间分割线的颜色，宽度等。最后面板通过 &lt;strong&gt;panel.setPositionRelativeTo('rightTop')&lt;/strong&gt; 将面板的位置设置成右上角，并且通过 &lt;strong&gt;document.body.appendChild(panel.getView())&lt;/strong&gt; 将面板最外层的 div 添加进页面中， &lt;strong&gt;panel.getView()&lt;/strong&gt; 用来获取面板的最外层 dom 节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体初始化面板代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initPanel() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; panel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.Panel();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; config =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         title: &quot;摄像头控制面板&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         titleBackground: 'rgba(230, 230, 230, 0.4)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         titleColor: 'rgb(0, 0, 0)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         titleHeight: 30&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         separatorColor: 'rgb(67, 175, 241)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         separatorWidth: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         exclusive: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        items: []
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     cameraArr.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data, num) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; camera = data['camera'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; rangeNode = data['rangeNode'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; formPane = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.FormPane();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        initFormPane(formPane, camera, rangeNode);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        config.items.push({
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             title: &quot;摄像头&quot; + (num + 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             titleBackground: 'rgba(230, 230, 230, 0.4)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             titleColor: 'rgb(0, 0, 0)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             titleHeight: 30&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             separatorColor: 'rgb(67, 175, 241)'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             separatorWidth: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            content: formPane,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             flowLayout: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             contentHeight: 400&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             width: 250&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             expanded: num === 0
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    panel.setConfig(config);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     panel.setPositionRelativeTo('rightTop'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    document.body.appendChild(panel.getView());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     window.addEventListener(&quot;resize&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        panel.invalidate();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在控制面板中可以调整摄像头的方向，摄像头监控的辐射范围，摄像头前方锥体的长度等等，并且摄像头的图像是实时生成，以下为运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074359161-1813880965.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是本项目采用的 3D 场景结合 VR 技术实现的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074423850-451548743.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 23:47:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。 在监控摄像机数量的不断庞大的同时，在监控系统中面临着严峻的现状问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/9466110.html</dc:identifier>
</item>
<item>
<title>极简入门：什么是区块链？ - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/9410874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/9410874.html</guid>
<description>&lt;p&gt;前阵子在油管看到了一个介绍区块链的短视频，把区块链讲得很清楚，于是我把它翻译一下分享给大家。相信大家看了这篇文章，基本上能够理解什么是区块链了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链，顾名思义，它是由一组包含信息的区块组成的信息链。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/what_is_block_chain_01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;区块链由一个有趣的属性：一旦某些数据被记录到一条区块链中后，那么数据就很难再被改变。那区块链到底是如何工作的呢？&lt;/p&gt;
&lt;h2 id=&quot;区块链的组成&quot;&gt;区块链的组成&lt;/h2&gt;
&lt;p&gt;区块链由区块和链组成。每一个区块包含三个元素：&lt;strong&gt;数据、哈希值、前一区块的哈希值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/what_is_block_chain_02.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块的第一个元素是数据。&lt;/strong&gt;区块中所保存的数据与区块链的类型有关。例如，比特币区块链中的区块保存了相关的交易信息，包括卖家，买家，以及交易比特币的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块的第二个元素是哈希值。&lt;/strong&gt;每个区块包含了一个哈希值，这个哈希值是唯一的，它用来标识一个区块和它所包含的所有内容。一旦某个区块被创建，它的哈希值就相对应的被计算出来了。改变区块中的某些内容会使得哈希值改变。所以换句话说：当你想要检测区块中内容的改变时，哈希值对你就很有帮助。如果一个区块的指纹改变了，那它就再也不是之前的区块了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块的第三个元素是前一个区块的哈希值。&lt;/strong&gt;这个元素使得区块之间可以形成链接，并且能够使得区块链十分的安全。&lt;/p&gt;
&lt;p&gt;举个例子假设我们有一条区块链包含3个区块。如图所示，每个区块包含了一个自己的哈希值以及前一个区块的哈希值。3 号区块指向 2 号区块，2 号区块又指向 1 号区块。但是 1 号区块有点特殊，它不能指向前一个区块，因为它是第一个区块。我们把1号区块叫做创世区块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/what_is_block_chain_03.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，现在我们假设你篡改了第二个区块。这将导致第二个区块的哈希值改变，那么 3 号区块存储的数据就是错误的、非法的。而 3 号区块存储的数据一旦是非法的，后面的区块也一定是非法的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/what_is_block_chain_04.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以如果一个人想要篡改区块链中任何一个区块，它必须修改这个区块以及这个区块之后的所有区块。这将是一个很繁重的任务。&lt;/p&gt;
&lt;h2 id=&quot;区块链的工作量证明&quot;&gt;区块链的工作量证明&lt;/h2&gt;
&lt;p&gt;但是，仅仅使用哈希值的方法不足以防止用户篡改区块。因为现在的计算机运算速度已经足够强大，并且能够每秒计算成千上万的哈希值。你完全可以篡改一个区块并且重新计算其他的区块的哈希值，这样就使得你的区块再次变得合法。&lt;/p&gt;
&lt;p&gt;所以为了减少这种风险，区块链还采用了一种技术叫做工作量证明。这是一种减缓新区块创建过程的机制。&lt;/p&gt;
&lt;p&gt;在比特币区块链中，大概需要花费10分钟来完成所要求的工作量证明，并且添加一个新的区块到区块链中。这个机制使得区块链的篡改更加困难，因为一旦你篡改了一个区块，你需要重新计算所有后续的区块的工作量证明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以区块链技术的安全性主要来自于哈希值以及工作量证明机制。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;区块链的分布式特性&quot;&gt;区块链的分布式特性&lt;/h2&gt;
&lt;p&gt;但是，区块链还有一种机制来保护自身的安全性，那就是分布式。相对于用一个中心化的实体来管理区块链网络，区块链采用的是一种peer-to-peer网络，并且所有人都可以加入。当有人加入这个网络时，他就会得到整个区块链的复制。这个人就可以以此来验证是否所有的区块还是合法未篡改的。&lt;/p&gt;
&lt;p&gt;那么接下来我们就来看看，当某人创建了一个新的区块时，会发生哪些改变这个新的区块会被发送给网络上的所有人。每个人再验证这个区块以确保这个区块没有被篡改过。如果所有的东西都被检验正确之后，那么每个人就都会把这块新的区块加到自己的区块链上。&lt;/p&gt;
&lt;p&gt;我们可以称之为，网络上的所有人达成了「共识」。他们认同网络中那些区块是合法的，哪些是不合法的。那些被篡改过的区块将会被网络上的其他用户拒绝。所以，&lt;strong&gt;要成功篡改一个区块链，你需要篡改区块链上的所有区块，重新完成每个区块的工作量证明，并且控制区块链网络中超过50%的用户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有这样，你篡改的区块才会被所有人承认。但实际上，这基本上是不可能做得到的！&lt;/p&gt;
&lt;h2 id=&quot;树义有话说&quot;&gt;树义有话说&lt;/h2&gt;
&lt;p&gt;看到这里，你可以尝试着回答下面几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是区块链？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;区块链由区块和链组成，每个区块由数据、哈希值、前一个区块的哈希值三个部分组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区块链为什么需要挖矿（工作量证明）？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过挖矿（工作量证明）可以避免坏人的恶意破解，增加其破解的时间成本和经济成本。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区块链为什么很安全？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;区块链安全是因为其不可更改特性和分布式特性。&lt;/strong&gt;即如果要修改区块链中的数据，你需要完成下面两件事情：第一，你需要计算出修改区块之后的所有区块的哈希值，这需要非常庞大的计算能力。第二，你需要让超过50%的区块链用户同意你的修改。同时完成上面两件事情基本上是不可能的，所以区块链很安全。&lt;/p&gt;
&lt;p&gt;如果你能回答上面三个问题，那么你就算是理解区块链了。但是区块链技术本身也在不断地发展。最近的一个技术改进，叫做智能合约。&lt;/p&gt;
&lt;p&gt;智能合约的诞生使得我们可以做很多事情，例如网购的信任问题。我们将在后面的文章中讲解智能合约的概念。&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 16:17:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<og:description>前阵子在油管看到了一个介绍区块链的短视频，把区块链讲得很清楚，于是我把它翻译一下分享给大家。相信大家看了这篇文章，基本上能够理解什么是区块链了。 区块链，顾名思义，它是由一组包含信息的区块组成的信息链</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanshuyi/p/9410874.html</dc:identifier>
</item>
<item>
<title>七夕节快到了，做个图钉画以及学习下Pillow吧 - 再见紫罗兰</title>
<link>http://www.cnblogs.com/linxiyue/p/9465612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linxiyue/p/9465612.html</guid>
<description>&lt;p&gt;又有时间写东西了，最近深感世事并不以人的美好愿望而改变，还是要以积极地心态来适应新变化，多多关心身边的人。&lt;/p&gt;
&lt;p&gt;图钉画中一个图钉代表一个像素，所以关键在于像素渣化，降低分辨率，图钉的色彩有限，还需要降低图片的色彩数量，统计各种色彩的数量及位置。&lt;/p&gt;
&lt;p&gt;以上都可以用Pillow完成，Pillow是Python中用来兼容或者代替PIL的图像处理库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip install pillow
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下图为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/601033/201808/601033-20180812233231016-1482330361.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先降分辨率，大概1万个图钉可以达到较好的外观效果，以此可以确定图片的长宽：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; from PIL import Image
&amp;gt;&amp;gt;&amp;gt; img = Image.open('20180707.jpg')
&amp;gt;&amp;gt;&amp;gt; print img.size
(512, 512)
&amp;gt;&amp;gt;&amp;gt; img = img.resize((img.width/5, img.height/5))
&amp;gt;&amp;gt;&amp;gt; img.save('target.jpg')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/601033/201808/601033-20180812234322075-1192996241.jpg&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;514&quot;/&gt;&lt;/p&gt;
&lt;p&gt;渣化很明显了，放大后可以看到一个个的像素格子。&lt;/p&gt;
&lt;p&gt;转成32色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; img = Image.open('e:/target.jpg')
&amp;gt;&amp;gt;&amp;gt; img = img.convert('P', colors=32, palette=1)
&amp;gt;&amp;gt;&amp;gt; img.save('e:/32_target.jpg')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;统计色彩数量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;98&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; img = Image.open('e:/32_target.png')
&amp;gt;&amp;gt;&amp;gt; print img.getcolors()
[(332, 0), (416, 1), (253, 2), (359, 3), (292, 4), (335, 5), (435, 6), (231, 7), (404, 8), (218, 9), (377, 10), (268, 11), (467, 12), (303, 13), (256, 14), (255, 15), (455, 16), (391, 17), (241, 18), (368, 19), (244, 20), (470, 21), (266, 22), (215, 23), (397, 24), (276, 25), (285, 26), (308, 27), (352, 28), (400, 29), (295, 30), (240, 31)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到从0号-31号色的数量，&lt;/p&gt;
&lt;p&gt;不清楚颜色的话，可以转化成RGB模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; img = img.convert('RGB')
&amp;gt;&amp;gt;&amp;gt; print img.getcolors()
[(253, (240, 173, 157)), (292, (236, 151, 129))...]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以根据RGB去对比颜色买图钉了。&lt;/p&gt;
&lt;p&gt;确定每个位置的颜色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; px = img.load()
&amp;gt;&amp;gt;&amp;gt; for x in xrange(102):
            for y in xrange(102):
                    print px[x, y]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就要对比颜色买图钉，买相框，买纸板，买图纸，标记位置，打印等等。&lt;/p&gt;
&lt;p&gt;考虑到以上一切，我还是决定某宝了。学以致用难啊。&lt;/p&gt;
&lt;p&gt;一万多个图钉，断断续续做了大概一个月，做完的感想是绝对不要做第二次，所以要做的同志请慎重。&lt;/p&gt;
&lt;p&gt;当然做完成品还是不错的。&lt;/p&gt;

</description>
<pubDate>Sun, 12 Aug 2018 16:09:00 +0000</pubDate>
<dc:creator>再见紫罗兰</dc:creator>
<og:description>又有时间写东西了，最近深感世事并不以人的美好愿望而改变，还是要以积极地心态来适应新变化，多多关心身边的人。 图钉画中一个图钉代表一个像素，所以关键在于像素渣化，降低分辨率，图钉的色彩有限，还需要降低图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linxiyue/p/9465612.html</dc:identifier>
</item>
<item>
<title>Django contenttypes 框架详解 - 天王盖地虎宝塔镇河妖</title>
<link>http://www.cnblogs.com/ManyQian/p/9463796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/9463796.html</guid>
<description>&lt;h2&gt;一、什么是Django ContentTypes？&lt;/h2&gt;
&lt;p&gt;Django ContentTypes是由Django框架提供的一个核心功能，它对当前项目中所有基于Django驱动的model提供了更高层次的抽象接口。 &lt;strong&gt;当然我们不是说的是http中的content-type！完全没有任何关系！&lt;/strong&gt;&lt;br/&gt;下面将一步一步解释Django ContentTypes在Django框架中做了什么，以及如何使用Django ContentTypes。 &lt;br/&gt;当然，如果对于ContentTypes有了初步了解而只是不了解它的应用场景，可以直接查阅一下原文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.10/ref/contrib/contenttypes/&quot; target=&quot;_blank&quot;&gt;https://docs.djangoproject.com/en/1.10/ref/contrib/contenttypes/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;二、Django ContentTypes做了什么？&lt;/h2&gt;
&lt;p&gt;当使用django-admin初始化一个django项目的时候，可以看到在默认的INSTALL_APPS已经包含了django.contrib.contenttypes:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.contenttypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.staticfiles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且注意django.contrib.contenttypes是在django.contrib.auth之后，这是因为auth中的permission系统是根据contenttypes来实现的。&lt;/p&gt;
&lt;p&gt;我们来查询查阅了一下django.contrib.contenttypes.models文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ContentType(models.Model):
    app_label &lt;/span&gt;= models.CharField(max_length=100&lt;span&gt;)
    model &lt;/span&gt;= models.CharField(_(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python model class name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), max_length=100&lt;span&gt;)
    objects &lt;/span&gt;=&lt;span&gt; ContentTypeManager()

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        verbose_name_plural &lt;/span&gt;= _(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content types&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        db_table &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django_content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        unique_together &lt;/span&gt;= ((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app_label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;model&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家可以看到ContentType就是一个简单的django model，而且它在数据库中的表的名字为django_content_type。 &lt;/p&gt;
&lt;p&gt;这个表的名字一般都不会陌生，在第一次对Django的model进行migrate之后，就可以发现在数据库中出现了一张默认生成的名为django_content_type的表。 &lt;br/&gt;如果没有建立任何的model，默认django_content_type是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1274477/201808/1274477-20180811113026502-881216759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，django_content_type记录了当前的Django项目中所有model所属的app（即app_label属性）以及model的名字（即model属性）。 &lt;br/&gt;当然，django_content_type并不只是记录属性这么简单，contenttypes是对model的一次封装，&lt;/p&gt;
&lt;p&gt;因此可以通过contenttypes动态的访问model类型，而不需要每次import具体的model类型。&lt;/p&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;ContentType实例提供的接口 &lt;br/&gt;&lt;ul&gt;&lt;li&gt;ContentType.model_class() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;获取当前ContentType类型所代表的模型类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ContentType.get_object_for_this_type() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;使用当前ContentType类型所代表的模型类做一次get查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ContentType管理器（manager）提供的接口 &lt;br/&gt;&lt;ul&gt;&lt;li&gt;ContentType.objects.get_for_id() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;通过id寻找ContentType类型，这个跟传统的get方法的区别就是它跟get_for_model共享一个缓存，因此更为推荐。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ContentType.objects.get_for_model() &lt;br/&gt;&lt;ul&gt;&lt;li&gt;通过model或者model的实例来寻找ContentType类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2&gt;三、Django ContentTypes的使用场景&lt;/h2&gt;
&lt;p&gt;在我们这个项目中各种商品的优惠卷就运用到了这个知识点：&lt;/p&gt;
&lt;p&gt;假使我们models下有这几张表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Electrics(models.Model):  #电器类
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price&lt;/span&gt;= models.IntegerField(default=100&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foods(models.Model):     #食物类
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price &lt;/span&gt;= models.IntegerField(default=100&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clothes(models.Model):   #衣服类
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price&lt;/span&gt;= models.IntegerField(default=100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coupon(models.Model):    #优惠券
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先来考虑一个问题，如何把这些商品和优惠卷相关联？&lt;/p&gt;
&lt;p&gt;一种商品一个优惠卷，那我们就在表中加入一种商品的优惠券，就是一个一对多的ForeignKey,那么多个商品就有各种优惠卷，&lt;/p&gt;
&lt;p&gt;但是一种商品的特定优惠卷在表结构中，就那个字段有值，别的不相关的记录为null,而且每增加一个商品，又要手动的去添加外键，&lt;/p&gt;
&lt;p&gt;这是繁琐的！&lt;/p&gt;
&lt;p&gt;所以我们就使用contenttypes 应用中提供的特殊字段GenericForeignKey，我们可以解决上面的问题：&lt;/p&gt;
&lt;p&gt;只需要以下三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在model中定义ForeignKey字段，并关联到ContentType表。通常这个字段命名为“content_type”&lt;/li&gt;
&lt;li&gt;在model中定义PositiveIntegerField字段，用来存储关联表中的主键。通常这个字段命名为“object_id”&lt;/li&gt;
&lt;li&gt;在model中定义GenericForeignKey字段，传入上述两个字段的名字。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体实例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coupon(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)

    content_type &lt;/span&gt;= models.ForeignKey(to=ContentType) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 1&lt;/span&gt;
    object_id = models.PositiveIntegerField() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 2&lt;/span&gt;
    content_object = GenericForeignKey(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; step 3&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话不管表的数据都可以查询出来，而且添加新的商品的商品，也不需要动优惠券的源码。&lt;/p&gt;
&lt;p&gt;但我们在查询的过程中，用ORM实在太繁琐了，所以还有一个反向查询的方法：&lt;/p&gt;
&lt;p&gt;就是在每个商品中关联 绑定一个关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
coupons = GenericRelation(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Coupon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于反向查询，不会生成表字段&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以直接ORM的.coupons找相应的字段！&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 15:11:00 +0000</pubDate>
<dc:creator>天王盖地虎宝塔镇河妖</dc:creator>
<og:description>一、什么是Django ContentTypes？ Django ContentTypes是由Django框架提供的一个核心功能，它对当前项目中所有基于Django驱动的model提供了更高层次的抽象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/9463796.html</dc:identifier>
</item>
<item>
<title>python3中的真值测试 - 翻书</title>
<link>http://www.cnblogs.com/sword03/p/9465296.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sword03/p/9465296.html</guid>
<description>&lt;h2 id=&quot;真值测试&quot;&gt;1. 真值测试&lt;/h2&gt;
&lt;p&gt;所谓真值测试，是指当一种类型对象出现在if或者while条件语句中时，对象值表现为True或者False。弄清楚各种情况下的真值对我们编写程序有重要的意义。&lt;/p&gt;
&lt;p&gt;对于一个对象a，其真值定义为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;True ： 如果函数truth_test(a)返回True。&lt;/li&gt;
&lt;li&gt;False：如果函数truth_test(a)返回False。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以if为例（while是等价的，不做赘述），定义函数truth_test(x)为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def truth_test(x):
    if x:
        return True
    else:
        return False&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象的真值测试&quot;&gt;2.对象的真值测试&lt;/h2&gt;
&lt;p&gt;一般而言，对于一个对象，在满足以下条件之一时，真值测试为False；否则真值测试为True。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其内置函数__bool__()返回False&lt;/li&gt;
&lt;li&gt;其内置函数__len__()返回0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）以下类型对象真值测试为真：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class X:
     pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）以下真值测试为假：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Y:
     def __bool__(self):
         return False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）以下真值测试为假：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Z:
     def __len__(self):
         return 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入python3脚本环境，测试过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class X:
...      pass
... 
&amp;gt;&amp;gt;&amp;gt; class Y:
...      def __bool__(self):
...          return False
... 
&amp;gt;&amp;gt;&amp;gt; class Z:
...      def __len__(self):
...          return 0
... 
&amp;gt;&amp;gt;&amp;gt; def truth_test(x):
...     if x:
...         return True
...     else:
...         return False
... 
&amp;gt;&amp;gt;&amp;gt; x = X()
&amp;gt;&amp;gt;&amp;gt; y = Y()
&amp;gt;&amp;gt;&amp;gt; z = Z()
&amp;gt;&amp;gt;&amp;gt; truth_test(x)
True
&amp;gt;&amp;gt;&amp;gt; truth_test(y)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(z)
False
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常见对象的真值&quot;&gt;3. 常见对象的真值&lt;/h2&gt;
&lt;p&gt;下面是常见的真值为False的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常量：None and False.&lt;/li&gt;
&lt;li&gt;数值0值: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)&lt;/li&gt;
&lt;li&gt;序列或者集合为空：'', (), [], {}, set(), range(0)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进入python3脚本环境，测试过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; truth_test(None)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(False)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(0)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(0.0)
False
&amp;gt;&amp;gt;&amp;gt; truth_test(0j)   #复数
False
&amp;gt;&amp;gt;&amp;gt; truth_test(Decimal(0))  #十进制浮点数
False
&amp;gt;&amp;gt;&amp;gt; truth_test(Fraction(0,1))  #分数
False
&amp;gt;&amp;gt;&amp;gt; truth_test(Fraction(0,2)) #分数
False
&amp;gt;&amp;gt;&amp;gt; truth_test('')
False
&amp;gt;&amp;gt;&amp;gt; truth_test(())
False
&amp;gt;&amp;gt;&amp;gt; truth_test({})
False
&amp;gt;&amp;gt;&amp;gt; truth_test(set())
False
&amp;gt;&amp;gt;&amp;gt; truth_test(range(0))  #序列
False
&amp;gt;&amp;gt;&amp;gt; truth_test(range(2,2)) #序列
False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外的其它取值，真值测试应当为True。&lt;/p&gt;
&lt;h2 id=&quot;一些有意思的例子&quot;&gt;4.一些有意思的例子&lt;/h2&gt;
&lt;p&gt;下面是一些有意思的例子，原理不超出前面的解释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; if 1 and Fraction(0,1):
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1 and ():
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1 and range(0):
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1 and None:
...     print(True)
... else:
...     print(False)
... 
False
&amp;gt;&amp;gt;&amp;gt; if 1+2j and None:
...     print(True)
... else:
...     print(False)
... 
False
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引用&quot;&gt;5.引用&lt;/h2&gt;
</description>
<pubDate>Sun, 12 Aug 2018 14:32:00 +0000</pubDate>
<dc:creator>翻书</dc:creator>
<og:description>1. 真值测试 所谓真值测试，是指当一种类型对象出现在if或者while条件语句中时，对象值表现为True或者False。弄清楚各种情况下的真值对我们编写程序有重要的意义。 对于一个对象a，其真值定义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sword03/p/9465296.html</dc:identifier>
</item>
<item>
<title>《ServerSuperIO Designer IDE使用教程》-2.与硬件网关数据交互，并进行数据级联转发，直到云端。发布：v4.2.1版本 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/9465050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/9465050.html</guid>
<description>&lt;blockquote readability=&quot;9.6511627906977&quot;&gt;
&lt;p class=&quot;a&quot;&gt;&lt;strong&gt;&lt;span&gt;v4.2.1 更新内容：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;1.重新定义数据转发文本协议，使网关与ServerSuperIO以及之间能够相关交互数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.扩展ServerSuperIO动态数据类的方法，更灵活。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.修复Designer增加转发任务的一个BUG。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.修改数据转发客户端和服务端。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.增加硬件网关驱动。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;&lt;span&gt;&lt;strong&gt;v4.2.1 下载地址：&lt;a href=&quot;http://www.bmpj.net/article-12-1.html&quot; target=&quot;_blank&quot;&gt;官方下载&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p class=&quot;a&quot;&gt; &lt;span&gt;目       录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 与硬件网关数据交互，以及进行数据转发... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1           概述... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2           演示的框架结构... 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3           Modbus Slave模拟传感器数据... 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.4           硬件网关SuperLink采集和转发数据... 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.5           ServerSuperIO Designer采集数据... 5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.6           ServerSuperIO Designer转发数据... 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.7           实现的全景效果... 8&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.1    概述&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       工业现场（物联网）使用硬件网关（SuperLink）的场景比较广泛，主要考虑多区域场景和网络条件限制情况下的应用和部署，具体根据现场的应用场景。网关两大基本职能：数据采集和数据转发，在项目体系建设中起到承上启下的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       ServerSuperIO现在集成了硬件网关（SuperLink）,完成了在项目建设过程中任何节点的数据采集与转发，并且形成级连部署。可以方便的与工业互联网平台或工业大数据平台对接；或者承建自己的云端平台，整合行业资源，形成以公司产品为主的生态建设。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.2    演示的框架结构&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;      演示大体包括3部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （1）传感器层，使用Modbus Slave进行模拟，相然可以是任何PLC、传感器等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （2）硬件网关（SuperLink）实时采集传感器层的数据信息，并且进行数据转发、汇聚；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   （3）ServerSuperIO实时接收网关层的数据信息，相当于数据交互中心，ServerSuperIO同样具备转发能力，可以进一步转发给上一层数据中心的ServerSuperIO，形成级连数据传递。结构如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212650511-1103790907.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.3    Modbus Slave模拟传感器数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;        为了方便起见，现在模拟2个数据点，相当可以更多。操作过程不具体介绍，请参见《&lt;a href=&quot;https://www.cnblogs.com/lsjwq/p/9225566.html&quot;&gt;标准Modbus和非标准协议的使用、测试以及驱动开发&lt;/a&gt;》。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212712956-938454766.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.4    硬件网关SuperLink采集和转发数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       网关支持100多种协议，包括国际标准协议和国内行业标准协议，涉及到：电力、煤矿、钢铁、智能楼宇、环保等。硬件外观如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212737103-1712575234.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          网关通过C/S结构的软件进行配置，方便、易用。数据采集配置可以单点配置和批量导入。采集Modbus Slave数据的配置，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212845438-1230366822.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          网关采集上来的数据，可以实时通过有线网络或3G/4G进行数据转发，具体配置信息和自定义转发的数据点，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212907035-633000541.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812212956946-2023143424.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.5    ServerSuperIO Designer采集数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       Designer是在ServerSuperIO的基础上开发的，是一个配置和调试环境，正式生产环境的运行可以使用Host控制台程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      增加运行的服务实例，相当于运行设备驱动的容器，因为网关是按统一标准协议主动上传数据。在配置参数的时候选择DeviceCode数据分发模式，与网关配置的“站点编号”相对应；另外选择Self（自控模式）控制模式，在代码二次开发层面可以选择主动发送请求数据或被动接收数据，没有实现主动发送请求数据，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213016382-950105141.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;          增加设备驱动的时候，“设备编码”对应的是“站点编号”，选择NET通讯类型，选择SuperLink网关通讯驱动，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213039327-572807952.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          数据采集之后，通过设备驱动保存到mysql数据库中，实际运行效果，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213056720-987090282.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.6    ServerSuperIO Designer转发数据&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;       ServerSuperIO同样支持客户端和服务端模式的数据转发功能，支持SuperLink与ServerSuperIO之间数据传递的协议，也就是ServerSuperIO与ServerSuperIO之间可以无限级的对接数据，在项目建设中进行灵活部署。数据转发配置，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213144153-1415667886.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;&lt;span&gt;2.7    实现的全景效果&lt;/span&gt;&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;        按演示的框架结构最终实现的效果，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180812213218331-278213837.png&quot; alt=&quot;&quot; width=&quot;1000&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;v4.2.1 下载地址：&lt;a href=&quot;http://www.bmpj.net/article-12-1.html&quot; target=&quot;_blank&quot;&gt;官方下载&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1.&lt;a id=&quot;post_title_link_4978884&quot; href=&quot;http://www.cnblogs.com/lsjwq/p/4978884.html&quot;&gt;[连载]《C#通讯（串口和网络）框架的设计与实现》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.[&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5316577.html&quot; target=&quot;_blank&quot;&gt;开源]C#跨平台物联网通讯框架ServerSuperIO（SSIO）介绍&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5359907.html&quot; target=&quot;_blank&quot;&gt;应用SuperIO（SIO）和开源跨平台物联网框架ServerSuperIO（SSIO）构建系统的整体方案&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5122612.html&quot;&gt;C#工业物联网和集成系统解决方案的技术路线（数据源、数据采集、数据上传与接收、ActiveMQ、Mongodb、WebApi、手机App）&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5.github地址：&lt;a href=&quot;https://github.com/wxzz/ServerSuperIO&quot; target=&quot;_blank&quot;&gt;https://github.com/wxzz/ServerSuperIO&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/8531046.html&quot; target=&quot;_blank&quot;&gt;6.助力中小企业级连云端，促进工业互联网平台蓬勃发展，全套解决方案。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物联网&amp;amp;集成技术 QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 13:36:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<og:description>v4.2.1 更新内容：1.重新定义数据转发文本协议，使网关与ServerSuperIO以及之间能够相关交互数据。2.扩展ServerSuperIO动态数据类的方法，更灵活。3.修复Designer增</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsjwq/p/9465050.html</dc:identifier>
</item>
<item>
<title>java泛型理解。代码更明了。 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9465040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9465040.html</guid>
<description>&lt;p&gt;泛型数据java基础，但真正理解需要悉心品尝。毕竟在工作中用到的是在是太多了。&lt;/p&gt;
&lt;p&gt;不要以为new ArrayList&amp;lt;&amp;gt;这就是泛型，这只能属于会使用。&lt;/p&gt;
&lt;p&gt;在工作中，相对于现有的项目源码的数据库操作层，无论是mybatis，hibernate或者是自己封装的baseModel层，都会使用到泛型。&lt;/p&gt;
&lt;p&gt;以及&lt;span&gt;&amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T&amp;gt;&lt;/span&gt;这个屌东西。&lt;/p&gt;
&lt;p&gt;泛型使用情况分为三类&lt;/p&gt;
&lt;p&gt;　　1. 泛型类。 &lt;br/&gt;　　2. 泛型方法。 &lt;br/&gt;　　3. 泛型接口。&lt;/p&gt;
&lt;p&gt;出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如： &lt;br/&gt;　　1. &lt;span&gt;T 代表一般的任何类&lt;/span&gt;。 &lt;br/&gt;　　2. E 代表 Element 的意思，或者 Exception 异常的意思。 &lt;br/&gt;　　3. K 代表 Key 的意思。 &lt;br/&gt;　　4. V 代表 Value 的意思，通常与 K 一起配合使用。 &lt;br/&gt;　　5. S 代表 Subtype 的意思，文章后面部分会讲解示意。&lt;/p&gt;
&lt;p&gt;最直接的一段代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
List&amp;lt;String&amp;gt; l1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; l2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        System.out.println(l1.getClass() &lt;/span&gt;== l2.getClass());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 打印的判断为TRUE，因为&lt;span&gt;&lt;span&gt;泛型信息被擦除&lt;/span&gt;了&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;泛型擦除实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
List&amp;lt;String&amp;gt; listErasure = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接初始化，这也是一种方式。直接传入一个collection。&lt;/span&gt;
            {add(&quot;aaa&quot;);add(&quot;bbb&quot;&lt;span&gt;);}
        };
        listErasure.add(&lt;/span&gt;&quot;ccc&quot;&lt;span&gt;);
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; List&amp;gt; class1 =&lt;span&gt; listErasure.getClass();
        Method method &lt;/span&gt;= class1.getMethod(&quot;add&quot;,Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        method.invoke(listErasure, &lt;/span&gt;123&lt;span&gt;);
        System.out.println(listErasure)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果　　[aaa, bbb, ccc, 123]&lt;/p&gt;
&lt;p&gt;明明是接收String类型，但是却可以通过反射对其进行Integer类型的操作。 &lt;/p&gt;
&lt;p&gt;可见&lt;span&gt;泛型只是在编译期间有效&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 代表着类型未知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T&amp;gt;这个东西经常见到，但是并没有字面意义那么简单。&lt;/p&gt;
&lt;p&gt;通配符有 3 种形式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 被称作无限定的通配符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt; 被称作有上限的通配符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt; 被称作有下限的通配符。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C &lt;span&gt;extends&lt;/span&gt; B{}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt; listExtends = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new A()); 全部编译错误。因为使用的是extends，丧失了写的操作能力。跟f3方法一样，是未知类型，只是确定了里面对象的范围。是B的子类。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new C());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 能进行对B以及B的子类操作。这是super的神奇之处。&lt;/span&gt;
        List&amp;lt;? &lt;span&gt;super&lt;/span&gt; B&amp;gt; listSuper = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listSuper.add(new A());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会编译错误。&lt;/span&gt;
        listSuper.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B());
        listSuper.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; C());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及方法泛型的返回&lt;/p&gt;
&lt;p&gt;泛型作为参数的传递。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;TTT&amp;gt;&lt;span&gt;TTT f1(TTT t) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传递指定的A类型，对应的list可以进行对应的list应有的方法。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f2(List&amp;lt;A&amp;gt;&lt;span&gt; list) {
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; A());
        System.out.println(list.size());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f3(List&amp;lt;?&amp;gt;&lt;span&gt; list) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        list.add(new A()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当传入的是?通配符的话表示只能进行跟?无关的操作，类似于size方法，增加代码的可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(list.size());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f4(List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt;&lt;span&gt; listExtends) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能进行写做操，因为是?,增加了可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(listExtends.size());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;借鉴文章：&lt;a href=&quot;https://blog.csdn.net/briblue/article/details/76736356&quot; target=&quot;_blank&quot;&gt;泛型，一个孤独的守门者。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试代码，很全面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.javaSE.fanxing;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A{}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; B{}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Demo&amp;lt;T,TT&amp;gt;&lt;span&gt; {
    T value; 
    TT value2;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TT getValue2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value2;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue2(TT value2) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value2 =&lt;span&gt; value2;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(T value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;TTT&amp;gt;&lt;span&gt;TTT f1(TTT t) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传递指定的A类型，对应的list可以进行对应的list应有的方法。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f2(List&amp;lt;A&amp;gt;&lt;span&gt; list) {
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; A());
        System.out.println(list.size());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f3(List&amp;lt;?&amp;gt;&lt;span&gt; list) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        list.add(new A()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当传入的是?通配符的话表示只能进行跟?无关的操作，类似于size方法，增加代码的可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(list.size());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; f4(List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt;&lt;span&gt; listExtends) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能进行写做操，因为是?,增加了可读性。&lt;/span&gt;
&lt;span&gt;        System.out.println(listExtends.size());
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印的判断为TRUE，因为泛型信息被擦除了。&lt;/span&gt;
        List&amp;lt;String&amp;gt; l1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; l2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        System.out.println(l1.getClass() &lt;/span&gt;==&lt;span&gt; l2.getClass());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 泛型擦除实例。&lt;/span&gt;
        List&amp;lt;String&amp;gt; listErasure = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接初始化，这也是一种方式。直接传入一个collection。&lt;/span&gt;
            {add(&quot;aaa&quot;);add(&quot;bbb&quot;&lt;span&gt;);}
        };
        listErasure.add(&lt;/span&gt;&quot;ccc&quot;&lt;span&gt;);
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; List&amp;gt; class1 =&lt;span&gt; listErasure.getClass();
        Method method &lt;/span&gt;= class1.getMethod(&quot;add&quot;,Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        method.invoke(listErasure, &lt;/span&gt;123&lt;span&gt;);
        System.out.println(listErasure);&lt;p&gt;Demo&lt;/p&gt;&lt;/span&gt;&amp;lt;String,Integer&amp;gt; demo = &lt;span&gt;new&lt;/span&gt; Demo&amp;lt;String,Integer&amp;gt;&lt;span&gt;();
        demo.setValue(&lt;/span&gt;&quot;string&quot;&lt;span&gt;);
        System.out.println(demo.getValue());
        
        
        Demo&lt;/span&gt;&amp;lt;Integer,String&amp;gt; demo2 = &lt;span&gt;new&lt;/span&gt; Demo&amp;lt;Integer,String&amp;gt;&lt;span&gt;();
        demo2.setValue(&lt;/span&gt;100&lt;span&gt;);
        System.out.println(demo2.getValue());
        
        
        System.out.println(f1(&lt;/span&gt;123&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;A&amp;gt; listA = new ArrayList&amp;lt;A&amp;gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        List&amp;lt;B&amp;gt; listB = listA;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new ArrayList&amp;lt;B&amp;gt;();虽然B是A的子类，并不代表泛型之间也具备继承关系。&lt;/span&gt;
&lt;span&gt;        
        
        ArrayList&lt;/span&gt;&amp;lt;A&amp;gt; listA = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;A&amp;gt;&lt;span&gt;();
        listA.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; A());
        f3(listA); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不对f3方法进行任何操作，是1.&lt;/span&gt;
        f2(listA); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2对应的方法实现还进行了一次插入操作。&lt;/span&gt;
        f3(listA); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; static ，对应的listA的集合数量是引用值。&lt;/span&gt;
&lt;span&gt;        
        
        ArrayList&lt;/span&gt;&amp;lt;B&amp;gt; listB = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
        listB.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B()); 
        f3(listB); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; f3方法传递的是通配符?，不能进行add操作。
        
         
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;? extends T&amp;gt; 和 &amp;lt;? super T&amp;gt;&lt;/span&gt;
        List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; B&amp;gt; listExtends = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new A()); 全部编译错误。因为使用的是extends，丧失了写的操作能力。跟f3方法一样，是未知类型，只是确定了里面对象的范围。是B的子类。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new B());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listExtends.add(new C());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 能进行对B以及B的子类操作。这是super的神奇之处。&lt;/span&gt;
        List&amp;lt;? &lt;span&gt;super&lt;/span&gt; B&amp;gt; listSuper = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listSuper.add(new A());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会编译错误。&lt;/span&gt;
        listSuper.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B());
        listSuper.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; C());
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没毛病。&lt;/span&gt;
        List&amp;lt;B&amp;gt; listBS = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;B&amp;gt;&lt;span&gt;(); 
        listBS.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; B());
        f4(listBS);   
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 12 Aug 2018 13:34:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<og:description>泛型数据java基础，但真正理解需要悉心品尝。毕竟在工作中用到的是在是太多了。 不要以为new ArrayList&lt;&gt;这就是泛型，这只能属于会使用。 在工作中，相对于现有的项目源码的数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9465040.html</dc:identifier>
</item>
<item>
<title>Angular6封装http请求 - _marven</title>
<link>http://www.cnblogs.com/zhouyangla/p/9465008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouyangla/p/9465008.html</guid>
<description>&lt;p&gt;最近抽空学习了一下Angular6，之前主要使用的是vue，所以免不了的也想对Angular6提供的工具进行一些封装，今天主要就跟大家讲一下这个http模块。&lt;br/&gt;之前使用的ajax库是axios，可以设置baseurl，公共头部；集中捕捉错误等，由于Angular6的依赖注入机制，是不能通过直接修改http模块暴露的变量来封装的，但是通过官方文档我们知道可以通过拦截器（HttpInterceptor）来实现这一功能。&lt;/p&gt;
&lt;p&gt;拦截器可以拦截请求，也可以拦截响应，那么通过拦截请求就可以实现 设置baseurl，公共头部；而通过拦截响应就可以实现 集中捕获错误 。废话不多说，上代码吧。&lt;/p&gt;
&lt;h3 id=&quot;第一步准备工作导入-httpclientmodule&quot;&gt;第一步：准备工作，导入 HttpClientModule&lt;/h3&gt;
&lt;p&gt;在app.module.ts中导入 HttpClientModule，然后在imports数组中将 HttpClientModule 加入到 BrowserModule 之后，具体代码为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [
    BrowserModule,
    // import HttpClientModule after BrowserModule.
    HttpClientModule,
  ],
  declarations: [
    AppComponent,
  ],
  bootstrap: [ AppComponent ]
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步新建有关拦截器的文件&quot;&gt;第二步：新建有关拦截器的文件&lt;/h3&gt;
&lt;p&gt;在app文件夹下新建http-interceptors文件夹，在其内新建base-interceptor.ts，index.ts两个文件。其中，base-interceptor.ts是用于设置拦截器的注入器文件，index.ts则为扩展拦截器的提供商。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;### base-interceptor.ts

import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest,
  HttpErrorResponse
} from '@angular/common/http';
import { throwError } from 'rxjs'
import { catchError, retry } from 'rxjs/operators';

/*设置请求的基地址，方便替换*/
const baseurl = 'http://localhost:8360';

@Injectable()
export class BaseInterceptor implements HttpInterceptor {

  constructor() {}

  intercept(req, next: HttpHandler) {

    let newReq = req.clone({
      url: req.hadBaseurl ? `${req.url}` : `${baseurl}${req.url}`,
    });
    /*此处设置额外的头部，token常用于登陆令牌*/
    if(!req.cancelToken) {
      /*token数据来源自己设置，我常用localStorage存取相关数据*/
      newReq.headers =
      newReq.headers.set('token', 'my-new-auth-token')
    }

    // send cloned request with header to the next handler.
    return next.handle(newReq)
      .pipe(
        /*失败时重试2次，可自由设置*/
        retry(2),
        /*捕获响应错误，可根据需要自行改写，我偷懒了，直接用的官方的*/
        catchError(this.handleError)
      )
  }
  
  private handleError(error: HttpErrorResponse) {
    if (error.error instanceof ErrorEvent) {
      // A client-side or network error occurred. Handle it accordingly.
      console.error('An error occurred:', error.error.message);
    } else {
      // The backend returned an unsuccessful response code.
      // The response body may contain clues as to what went wrong,
      console.error(
        `Backend returned code ${error.status}, ` +
        `body was: ${error.error}`);
    }
    // return an observable with a user-facing error message
    return throwError(
      'Something bad happened; please try again later.');
  };
}


### index.ts

import { HTTP_INTERCEPTORS } from '@angular/common/http';

import { BaseInterceptor } from './base-interceptor';

/** Http interceptor providers in outside-in order */
export const httpInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: BaseInterceptor, multi: true },

];

/*
Copyright 2017-2018 Google Inc. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过克隆修改 req 对象即可拦截请求，而操作 &lt;strong&gt;next.handle(newReq)&lt;/strong&gt;的结果即可拦截响应。如果需要修改，可直接扩展 base-interceptor.ts或 参考 base-interceptor.ts 文件新建其他文件，然后在 index.ts 中正确引入该拦截器，并将其添加到 httpInterceptorProviders 数组中即可。&lt;/p&gt;
&lt;h3 id=&quot;第三步注册提供商&quot;&gt;第三步：注册提供商&lt;/h3&gt;
&lt;p&gt;在app.module.ts中加入以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { httpInterceptorProviders } from './http-interceptors/index'

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [
    httpInterceptorProviders
  ],
  bootstrap: [AppComponent]
})

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第四步提取baseurl&quot;&gt;第四步，提取baseurl&lt;/h3&gt;
&lt;p&gt;为了方便后台修改baseurl，我们可以将baseurl提取为全局变量，在index.html中进行设置，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# index.html 增加
&amp;lt;script&amp;gt;
  window.baseurl = &quot;http://localhost:8360&quot;
&amp;lt;/script&amp;gt;

# base-interceptor.ts 修改
const baseurl = window.baseurl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来，如果后台要修改的话，只需修改index.html中的变量即可，无需再次编译。还有，像这些后期可能更改的变量，建议是直接放在index.html中，因为缓存的原因，如果放在js文件中再引入的话，文件并不能及时更新或是每次都需要更改文件名，会导致不必要的麻烦。&lt;/p&gt;
&lt;p&gt;至此，Angular6的http模块封装已经基本完成，如果有需要可以自行扩展，可参考第二步。如果看完以后不明白或者我有写的不对的地方，欢迎大家在下方进行评论。&lt;/p&gt;
&lt;p&gt;文章参考：&lt;a href=&quot;https://juejin.im/post/5b59c89de51d45190a4336d8#comment&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5b59c89de51d45190a4336d8#comment&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 13:29:00 +0000</pubDate>
<dc:creator>_marven</dc:creator>
<og:description>最近抽空学习了一下Angular6，之前主要使用的是vue，所以免不了的也想对Angular6提供的工具进行一些封装，今天主要就跟大家讲一下这个http模块。 之前使用的ajax库是axios，可以设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouyangla/p/9465008.html</dc:identifier>
</item>
<item>
<title>mysql及python交互 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/9464988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/9464988.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;mysql在之前写过一次，那时是我刚刚进入博客，今天介绍一下mysql的python交互，当然前面会把mysql基本概述一下。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:as3;gutter:false;&quot;&gt;
&lt;span&gt;　　&lt;span&gt;目录：&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;一、命令脚本（mysql）
    1、基本命令
    2、数据库操作命令
    3、表操作命令
    4、数据操作命令
    5、查
    6、关联
二、python交互
    1、数据库连接
    2、创建数据库表
    3、插入数据
    4、更新数据库
    5、删除数据
    6、数据库查询
三、mysql封装（方便使用）
    1、python封装的my_sql类
    2、案例（调用my_sql类）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;1、基本命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）启动服务&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以管理员身份运行cmd&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;net start 服务名称&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（2）停止服务&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以管理员身份运行cmd&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;net stop 服务名称&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（3）连接数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;格式：mysql - u root - p -&amp;gt;输入密码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（4）退出登录（断开连接）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;exit或quit&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（5）查看版本（连接后可以执行）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;select version()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（6）显示当前时间（连接后可以执行）&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;select now()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（7）远程连接&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;mysql - h ip地址 - u 用户名 - p ---&amp;gt;输入对方mysql密码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2、数据库操作命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）创建数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;create database 数据库名 charset = utf8&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（2）删除数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;drop database 数据库名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（3）切换数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;use 数据库名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（4）查看当前选择的数据库&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;select database()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3、表操作命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）查看数据库中所有表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;show tables&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（2）创建表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;create table 表名（列及类型）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　eg：create table student(id int auto_increment primary key,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　　　　name varchar(20) not null)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　注：auto_increment 自增长      primary key 主键     not null 非空&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（3）删除表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;drop table 表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（4）查看表结构&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;desc 表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（5）查看建表语句&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;show create table 表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（6）重命名表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;rename table 原表名 to 新表名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;　　（7）修改表&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;alter table 表名 add | change | drop 列名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4、数据操作命令&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）增&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　a、全列插入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into 表名 values(...)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　eg:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into student values(0, &quot;tom&quot;, &quot;北京&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　主键列是自动增长，但是在全列插入时需要占位，通常使用0，插入成功以后以实际数据为准&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、缺省插入&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into 表名(列1，列2..) values(值1，值2..)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、同时插入多条数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　insert into 表名 values(...), (...), ...&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　&lt;span&gt;（2）删&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　delete from 表名 where 条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　不写条件则全删&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　&lt;span&gt;（3）改&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　update 表名 set 列1 = 值1, 列2 = 值2, ... where 条件&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（4）查&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　查询表中的全部数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　select * from 表名&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5、查&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;　　（1）基本语法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　select * from 表名&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;from关键字后面是表名，表示数据来源于这张表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;select后面写表中的列名，如果是 * 表示在结果集中显示表中额所有列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在select后面的列名部分，可以使用as为列名起别名，这个别名显示在结果集中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果要查询多个列，之间使用逗号分隔&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　# eg：select name as a,age from student;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（2）消除重复行&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　在select后面列前面使用distinct可以消除重复的行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　eg：select distinct gender from student&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（3）条件查询&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　a、语法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　select * from 表名 where 条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、比较运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　等于（=） 大于（&amp;gt;） 小于（&amp;lt;） 大于等于（&amp;gt;=） 小于等于（&amp;lt;=） 不等于（!= 或 &amp;lt;&amp;gt;）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、逻辑运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　and or not&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d、模糊查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　like&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　% 表示任意多个任意字符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　_ 表示一个任意字符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　e、范围查询&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　in 表示在一个非连续的范围内&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　between。。。and。。。 表示在一个连续的范围内&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　eg：where id in (8, 10, 13)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　f、空判断&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　注意：null与&quot;&quot;是不同的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　判断空：is null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　判断非空：is not null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　g、优先级&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　小括号，not，比较运算符，逻辑运算符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　and比or优先级高，同时出现并希望先选or，需要结合括号来使用&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（4）聚合&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　为了快速得到统计数，提供了5个聚合函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a、count(*) 表示计算总行数，括号中可以写 * 或列名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、max(列) 表示求此列的最大值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、min(列) 表示求此列的最小值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d、sum(列) 表示求此列的和&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　e、avg(列) 表示求此列的平均值&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（5）分组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　按照字段分组，表示此字段相同的数据会被放到一个集合中。&lt;/span&gt;&lt;span&gt;分组后，只能查询出相同的数据列，对于有差异的数据列无法显示在结果集中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　可以对分组后的数据进行统计，做聚合运算&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　select 列1, 列2, 聚合... from 表名 group by 列1, 列2 having 列1, 列2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　eg:  &lt;/span&gt;&lt;span&gt;查询男女生总数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　select gender, count(*) from student group by gender&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　where与having的区别：where是对from后面指定的表进行筛选，属于对原始数据的筛选；having是对group by的结果进行筛选。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;（6）排序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　select * from 表名 order by 列1 asc | desc, 列2 asc | desc, ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　a、将数据按照列1进行排序，如果某些列1的值相同则按照列2排序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　b、默认按照从小到大的顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　c、asc升序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　d、desc降序&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（7）分页&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　select * from 表名 limit start, count&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　从start开始，看count条&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6、关联&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;建表语句&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　（1）create table class(id int auto_increment primary key, name varchar(20) not null, stuNum int not null)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）create table students(id int auto_increment primary key, name varchar(20) not null, gender bit default 1, classid int not bull, foreign key(classid) references class(id))&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;插入一些数据：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　（1）insert into class values(0, &quot;python1&quot;, 50), (0, &quot;python2&quot;, 60), (0, &quot;python3&quot;, 70)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（2）insert into students values(0, &quot;tom&quot;, 1, 1)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;关联查询：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　（1）select students.name, class.name from class inner join students on class.id = students.classid&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（1）表A inner join 表B&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　表A与表B匹配的行会出现在结果集中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（2）表A left join 表B&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　表A与表B匹配的行会出现在结果集中，外加表A中独有的数据，未对应的数据使用null填充&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　（3）表A right join 表B&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　表A与表B匹配的行会出现在结果集中，外加表B中独有的数据，未对应的数据使用null填充&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1、连接数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接数据库&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数一：mysql服务所在主机的IP&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数二：用户名&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数三：密码&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数四：要连接的数据库名&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; db = pymysql.connect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个cursor对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; cursor =&lt;span&gt; db.cursor()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; -----------------------------------------------------------------------------------------
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 要执行的sql语句&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select version()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行sql语句&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取返回的信息&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; data =&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; ----------------------------------------------------------------------------------------
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断开&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;cursor.close()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; db.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这里我选择的是pymysql，其实这个和MySQLdb相差无几，命令也很像。连接时，主机IP如果是在本机，直接使用localhost即可，也可以写IP地址，这样可以实现远程的连接。虚线中间部分是要进行不同操作时需要更改的部分。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2、创建数据库表&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;上面给出了连接数据库的代码，其实后面的操作就简单多了，外部框架不变，只需要改内部的sql语句，以及个别的一些操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查表是否存在，如果有则删除&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; cursor.execute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;drop table if exists bancard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 建表&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create table bandcard(id int auto_increment primary key, money int not null)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; cursor.execute(sql)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、插入数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert into bandcard values(0, 300)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     db.commit() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行这条语句才插入&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、更新数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update bandcard set money=1000 where id=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    db.commit()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;可以看到，后面的操作基本上以及回归mysql本身，大家记住这样一个流程就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5、删除数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete from bandcard where money=200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    db.commit()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     db.rollback()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6、数据库查询操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;fetchone()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　功能：获取下一个查询结果集，结果集是一个对象&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;fetchall()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　功能：接收全部的返回的行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　是一个只读属性，返回execute()方法影响的行数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from bandcard where money&amp;gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回查询结果&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     reslist =&lt;span&gt; cursor.fetchall()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reslist:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d--%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (row[0], row[1&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果提交失败，回滚到上一次数据&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; my_sql():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, user, passwd, dbName):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.host =&lt;span&gt; host
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.user =&lt;span&gt; user
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.passwd =&lt;span&gt; passwd
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.dbName =&lt;span&gt; dbName
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; connect(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.db =&lt;span&gt; pymysql.connect(
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            self.host, self.user, self.passwd, self.dbName)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         self.cursor =&lt;span&gt; self.db.cursor()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        self.cursor.close()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        self.db.close()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_one(self, sql):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         res =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            self.connect()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            self.cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             res =&lt;span&gt; self.cursor.fetchone()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            self.close()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_all(self, sql):
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         res =&lt;span&gt; ()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            self.connect()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            self.cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             res =&lt;span&gt; self.cursor.fetchall()
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            self.close()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert(self, sql):
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; update(self, sql):
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delete(self, sql):
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(sql)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__edit&lt;/span&gt;&lt;span&gt;(self, sql):
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            self.connect()
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             count =&lt;span&gt; self.cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            self.db.commit()
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            self.close()
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;事务提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             self.db.rollback()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面的类中封装了用python封装了对mysql的连接，增，删，改，查等功能，在今后使用的时候，完全可以直接调用其中的方法，避免重复造轮子嘛。下面给一个使用的案例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; my_sql &lt;span&gt;import&lt;/span&gt;&lt;span&gt; my_sql
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个是连接mysql的参数，前面有解释到，使用时候连接上自己的数据库就好&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; s = my_sql(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx.xxx.xx.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; res = s.get_all(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from bandcard where money&amp;gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; res:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d--%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (row[0], row[1]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;当然在你使用的时候要写完整调用的类的路径，我这里是在同一个目录下写的。新建一个自己的文件，引入my_sql中的my_sql类，然后就可以使用了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 Aug 2018 13:25:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<og:description>mysql在之前写过一次，那时是我刚刚进入博客，今天介绍一下mysql的python交互，当然前面会把mysql基本概述一下。 一、命令脚本 1、基本命令 （1）启动服务 以管理员身份运行cmd ne</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/9464988.html</dc:identifier>
</item>
<item>
<title>Java并发编程-看懂AQS的前世今生 - lingjiango</title>
<link>http://www.cnblogs.com/iou123lg/p/9464385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iou123lg/p/9464385.html</guid>
<description>&lt;p&gt;　　在具备了&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9280639.html&quot; target=&quot;_blank&quot;&gt;volatile&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9314826.html&quot; target=&quot;_blank&quot;&gt;CAS&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9350108.html&quot; target=&quot;_blank&quot;&gt;模板方法设计模式&lt;/a&gt;的知识之后，我们可以来深入学习下AbstractQueuedSynchronizer（AQS），本文主要想从AQS的产生背景、设计和结构、源代码实现及AQS应用这4个方面来学习下AQS，文章耗时一个月，所以篇幅有点长，需要一点耐心。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、AQS产生背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过JCP的JSR166规范，Jdk1.5开始引入了j.u.c包，这个包提供了一系列支持并发的组件。这些组件是一系列的同步器，这些同步器主要维护着以下几个功能：内部同步状态的管理(例如表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。可以看下&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9280639.html&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;的4.2的图便能理解j.u.c包的组件构成。&lt;/p&gt;
&lt;p&gt;　　几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性、开销及不灵活使j.u.c最多只能是一个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。因此，JSR166基于AQS类建立了一个小框架，这个框架为构造同步器提供一种通用的机制，并且被j.u.c包中大部分类使用，同时很多用户也可以用它来定义自己的同步器。这个就是j.u.c的作者Doug Lea大神的初衷，通过提供AQS这个基础组件来构建j.u.c的各种工具类，至此就可以理解AQS的产生背景了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&lt;/strong&gt;&lt;strong&gt;、AQS的设计和结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1&lt;/strong&gt; &lt;strong&gt;设计思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。acquire操作是这样的：&lt;/p&gt;
&lt;p&gt;　　while (&lt;strong&gt;当前同步器的状态&lt;/strong&gt;不允许获取操作) {&lt;/p&gt;
&lt;p&gt;        　　如果当前&lt;strong&gt;线程&lt;/strong&gt;不在&lt;strong&gt;队列&lt;/strong&gt;中，则将其插入队列&lt;/p&gt;
&lt;p&gt;        　　&lt;strong&gt;阻塞&lt;/strong&gt;当前线程&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　如果线程位于队列中，则将其移出队列&lt;/p&gt;

&lt;p&gt;　　release操作是这样的：&lt;/p&gt;
&lt;p&gt;　　更新&lt;strong&gt;同步器的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　if (新的状态允许某个被阻塞的线程获取成功)&lt;/p&gt;
&lt;p&gt;         　　&lt;strong&gt;解除队列&lt;/strong&gt;中一个或多个&lt;strong&gt;线程&lt;/strong&gt;的&lt;strong&gt;阻塞&lt;/strong&gt;状态&lt;/p&gt;
&lt;p&gt;　　从这两个操作中的思想中我们可以提取出三大关键操作：&lt;strong&gt;同步器的状态变更、线程阻塞和释放、插入和移出队列&lt;/strong&gt;。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;·同步器状态的原子性管理；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　·线程阻塞与解除阻塞；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　·队列的管理；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由这三个基本组件，我们来看j.u.c是怎么设计的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.1&lt;/strong&gt; &lt;strong&gt;同步状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。&lt;/p&gt;
&lt;p&gt; 　　基于AQS的具体实现类（如锁、信号量等）必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.2&lt;/strong&gt; &lt;strong&gt;阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　直到JSR166，阻塞线程和解除线程阻塞都是基于Java的内置管程，没有其它非基于Java内置管程的API可以用来达到阻塞线程和解除线程阻塞。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用，目前该方法基本已被抛弃。具体不能用的原因可以&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot; target=&quot;_blank&quot;&gt;官方给出的答复&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　j.u.c.locks包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合 ，可通过中断来unpark一个线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.3&lt;/strong&gt; &lt;strong&gt;队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。&lt;/p&gt;
&lt;p&gt;　　CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head（头节点）和tail（尾节点）来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812201948093-418701167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　入队操作：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202051742-1948605021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　出队操作：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点的引用即可。出队操作示意图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202637706-938220186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这一小节只是简单的描述了队列的大概，目的是为了表达清楚队列的设计框架，实际上CLH队列已经和初始的CLH队列已经发生了一些变化，具体的可以看查看资料中Doug Lea的那篇论文中的3.3 Queues。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.1.4&lt;/strong&gt; &lt;strong&gt;条件队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上一节的队列其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。&lt;/p&gt;
&lt;p&gt;　　ConditionObject类实现了Condition接口，Condition接口提供了类似Object管程式的方法，如await、signal和signalAll操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程（通过Object.wait等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。&lt;/p&gt;
&lt;p&gt;　　ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202850477-387948953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　await操作就是当前线程节点从同步队列进入条件队列进行等待，大致示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812202959032-1029783103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.2&lt;/strong&gt; &lt;strong&gt;方法结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果我们理解了上一节的设计思路，我们大致就能知道AQS的主要数据结构了。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;组件&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;volatile int state&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;阻塞&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;LockSupport类&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;队列&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;条件队列&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;ConditionObject&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　进而再来看下AQS的主要方法及其作用。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;61.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;属性、方法&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;描述、作用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;int getState()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;获取当前同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void setState(int newState)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;设置当前同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;boolean compareAndSetState(int expect, int update)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;通过CAS设置当前状态，此方法保证状态设置的原子性&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean tryAcquire(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;钩子方法，独占式获取同步状态，AQS没有具体实现，具体实现都在子类中，实现此方法需要查询当前同步状态并判断同步状态是否符合预期，然后再CAS设置同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean tryRelease(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;钩子方法，独占式释放同步状态，AQS没有具体实现，具体实现都在子类中，等待获取同步状态的线程将有机会获取同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;int tryAcquireShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;钩子方法，共享式获取同步状态，AQS没有具体实现，具体实现都在子类中，返回大于等于0的值表示获取成功，反之失败&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean tryReleaseShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;钩子方法，共享式释放同步状态，AQS没有具体实现，具体实现都在子类中&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean isHeldExclusively()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;钩子方法，AQS没有具体实现，具体实现都在子类中，当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void acquire(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;模板方法，独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则会进入同步队列等待，此方法会调用子类重写的tryAcquire方法&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void acquireInterruptibly(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法，与acquire相同，但是此方法可以响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，此方法会抛出InterruptedException并返回&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;boolean tryAcquireNanos(int arg, long nanosTimeout)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法，在acquireInterruptibly基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，则会返回false,如果获取到了则会返回true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;boolean release(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;模板方法，独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中的第一个节点包含的线程唤醒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void acquireShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;模板方法，共享式的获取同步状态，如果当前系统未获取到同步状态，将会进入同步队列等待，与acquire的主要区别在于同一时刻可以有多个线程获取到同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void acquireSharedInterruptibly(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，与acquireShared一致，但是可以响应中断&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;boolean tryAcquireSharedNanos(int arg, long nanosTimeout)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，在acquireSharedInterruptibly基础上增加了超时限制&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean releaseShared(int arg)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，共享式的释放同步状态&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Collection&amp;lt;Thread&amp;gt; getQueuedThreads()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;模板方法，获取等待在同步队列上的线程集合&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node int waitStatus&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;等待状态&lt;/p&gt;
&lt;p&gt;1、 CANCELLED，值为1，在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态后将不会变化；&lt;/p&gt;
&lt;p&gt;2、 SIGNAL，值为-1，后续节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后续节点，使后续节点的线程得以运行；&lt;/p&gt;
&lt;p&gt;3、 CONDITION，值为-2，节点在条件队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从条件队列中转移到同步队列中，加入到对同步状态的获取中；&lt;/p&gt;
&lt;p&gt;4、 PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地传播下去&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node prev&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;前驱节点，当节点加入同步队列时被设置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node next&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;后续节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Thread thread&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取同步状态的线程&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Node nextWaiter&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;条件队列中的后续节点，如果当前节点是共享的，那么这个字段将是一个SHARED变量，也就是说节点类型（独占和共享）和条件队列中的后续节点共用同一个字段&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;LockSupport void park()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;阻塞当前线程，如果调用unpark方法或者当前线程被中断，才能从park方法返回&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;LockSupport void unpark(Thread thread)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;唤醒处于阻塞状态的线程&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;ConditionObject Node firstWaiter&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;条件队列首节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;ConditionObject Node lastWaiter&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;条件队列尾节点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void await()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;当前线程进入等待状态直到signal或中断，当前线程将进入运行状态且从await方法返回的情况，包括：&lt;/p&gt;
&lt;p&gt;其他线程调用该Condition的signal或者signalAll方法，且当前线程被选中唤醒；&lt;/p&gt;
&lt;p&gt;其他线程调用interrupt方法中断当前线程；&lt;/p&gt;
&lt;p&gt;如果当前线程从await方法返回表明该线程已经获取了Condition对象对应的锁&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;void awaitUninterruptibly()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;和await方法类似，但是对中断不敏感&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;long awaitNanos(long nanosTimeout)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当前线程进入等待状态直到被signal、中断或者超时。返回值表示剩余的时间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;boolean awaitUntil(Date deadline)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当前线程进入等待状态直到被signal、中断或者某个时间。如果没有到指定时间就被通知，方法返回true，否则表示到了指定时间，返回false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void signal()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;void signalAll()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　看到这，我们对AQS的数据结构应该基本上有一个大致的认识，有了这个基本面的认识，我们就可以来看下AQS的源代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3&lt;/strong&gt;&lt;strong&gt;、AQS的源代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　主要通过独占式同步状态的获取和释放、共享式同步状态的获取和释放来看下AQS是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.1&lt;/strong&gt; &lt;strong&gt;独占式同步状态的获取和释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　独占式同步状态调用的方法是acquire，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用子类实现的tryAcquire方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造独占式同步节点（同一时刻只能有一个线程成功获取同步状态）并通过addWaiter方法将该节点加入到同步队列的尾部，最后调用acquireQueued方法，使得该节点以自旋的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。&lt;/p&gt;
&lt;p&gt;　　下面来首先来看下节点构造和加入同步队列是如何实现的。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程构造成Node节点&lt;/span&gt;
        Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try the fast path of enq; backup to full enq on failure
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试快速在尾节点后新增节点 提升算法效率 先将尾节点指向pred&lt;/span&gt;
        Node pred =&lt;span&gt; tail;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点不为空  当前线程节点的前驱节点指向尾节点&lt;/span&gt;
            node.prev =&lt;span&gt; pred;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并发处理 尾节点有可能已经不是之前的节点 所以需要CAS更新&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点&lt;/span&gt;
                pred.next =&lt;span&gt; node;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个入队的节点或者是尾节点后续节点新增失败时进入enq&lt;/span&gt;
&lt;span&gt;        enq(node);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node t &lt;/span&gt;=&lt;span&gt; tail;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must initialize
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点为空  第一次入队  设置头尾节点一致 同步队列的初始化&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node()))
                    tail &lt;/span&gt;=&lt;span&gt; head;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的线程节点在构造完成第一个节点后 依次加入到同步队列中&lt;/span&gt;
                node.prev =&lt;span&gt; t;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
                    t.next &lt;/span&gt;=&lt;span&gt; node;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　节点进入同步队列之后，就进入了一个自旋的过程，每个线程节点都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中并会阻塞节点的线程，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程节点的前驱节点&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点为头节点且成功获取同步状态&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置当前节点为头节点&lt;/span&gt;
&lt;span&gt;                    setHead(node);
                    p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                    failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interrupted;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否阻塞&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                    interrupted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
                cancelAcquire(node);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再来看看shouldParkAfterFailedAcquire和parkAndCheckInterrupt是怎么来阻塞当前线程的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点的状态决定后续节点的行为&lt;/span&gt;
　　　　 &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; pred.waitStatus;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL)
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;前驱节点为-1 后续节点可以被阻塞
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                node.prev &lt;/span&gt;= pred =&lt;span&gt; pred.prev;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
            pred.next &lt;/span&gt;=&lt;span&gt; node;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;前驱节点是初始或者共享状态就设置为-1 使后续节点阻塞
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; parkAndCheckInterrupt() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞线程&lt;/span&gt;
        LockSupport.park(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　节点自旋的过程大致示意图如下，其实就是对图二、图三的补充。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812203804425-1737346642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　图六  节点自旋获取队列同步状态&lt;/p&gt;
&lt;p&gt;　　整个独占式获取同步状态的流程图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201808/289599-20180812203910106-196358265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　图七  独占式获取同步状态&lt;/p&gt;
&lt;p&gt;　　当同步状态获取成功之后，当前线程从acquire方法返回，对于锁这种并发组件而言，就意味着当前线程获取了锁。有获取同步状态的方法，就存在其对应的释放方法，该方法为release，现在来看下这个方法的实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步状态释放成功&lt;/span&gt;
            Node h =&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接释放头节点&lt;/span&gt;
&lt;span&gt;                unparkSuccessor(h);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; node.waitStatus;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;)
            compareAndSetWaitStatus(node, ws, &lt;/span&gt;0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;寻找符合条件的后续节点
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Node s &lt;/span&gt;=&lt;span&gt; node.next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
            s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;)
                    s &lt;/span&gt;=&lt;span&gt; t;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续节点&lt;/span&gt;
&lt;span&gt;            LockSupport.unpark(s.thread);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　独占式释放是非常简单而且明确的。&lt;/p&gt;
&lt;p&gt;　　总结下独占式同步状态的获取和释放：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后唤醒头节点的后继节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.2&lt;/strong&gt; &lt;strong&gt;共享式同步状态的获取和释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　共享式同步状态调用的方法是acquireShared，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取同步状态的返回值大于等于0时表示可以获取同步状态
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小于0时表示可以获取不到同步状态  需要进入队列等待&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0&lt;span&gt;)
            doAcquireShared(arg);
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;和独占式一样的入队操作&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.SHARED);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自旋&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱结点为头节点且成功获取同步状态 可退出自旋&lt;/span&gt;
&lt;span&gt;                        setHeadAndPropagate(node, r);
                        p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interrupted)
                            selfInterrupt();
                        failed &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                    interrupted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
                cancelAcquire(node);
        }
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
        Node h &lt;/span&gt;= head; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record old head for check below
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出自旋的节点变成首节点&lt;/span&gt;
&lt;span&gt;        setHead(node);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Try to signal next queued node if:
         *   Propagation was indicated by caller,
         *     or was recorded (as h.waitStatus either before
         *     or after setHead) by a previous operation
         *     (note: this uses sign-check of waitStatus because
         *      PROPAGATE status may transition to SIGNAL.)
         * and
         *   The next node is waiting in shared mode,
         *     or we don't know, because it appears null
         *
         * The conservatism in both of these checks may cause
         * unnecessary wake-ups, but only when there are multiple
         * racing acquires/releases, so most need signals now or soon
         * anyway.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; 0 || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0 ||&lt;span&gt;
            (h &lt;/span&gt;= head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0&lt;span&gt;) {
            Node s &lt;/span&gt;=&lt;span&gt; node.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
                doReleaseShared();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared方法可以释放同步状态，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放同步状态&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续等待的节点&lt;/span&gt;
&lt;span&gt;            doReleaseShared();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自旋&lt;/span&gt;
　　　　&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node h &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续节点&lt;/span&gt;
　　　　　　　　　　　　&lt;span&gt;unparkSuccessor(h);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == 0 &amp;amp;&amp;amp;
                         !compareAndSetWaitStatus(h, 0&lt;span&gt;, Node.PROPAGATE))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　unparkSuccessor方法和独占式是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4&lt;/strong&gt;&lt;strong&gt;、AQS应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AQS被大量的应用在了同步工具上。&lt;/p&gt;
&lt;p&gt;　　ReentrantLock：ReentrantLock类使用AQS同步状态来保存锁重复持有的次数。当锁被一个线程获取时，ReentrantLock也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。ReentrantLock也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。&lt;/p&gt;
&lt;p&gt;　　ReentrantReadWriteLock：ReentrantReadWriteLock类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。WriteLock的构建方式同ReentrantLock。ReadLock则通过使用acquireShared方法来支持同时允许多个读线程。&lt;/p&gt;
&lt;p&gt;　　Semaphore：Semaphore类（信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；tryRelease方法会增加计数，在计数为正值时还要解除线程的阻塞。&lt;/p&gt;
&lt;p&gt;　　CountDownLatch：CountDownLatch类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（对应到CountDownLatch中就是await方法）才能通过。&lt;/p&gt;
&lt;p&gt;　　FutureTask：FutureTask类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（FutureTask的set方法）或取消（FutureTask的cancel方法）一个FutureTask时会调用AQS的release操作，等待计算结果的线程的阻塞解除是通过AQS的acquire操作实现的。&lt;/p&gt;
&lt;p&gt;　　SynchronousQueues：SynchronousQueues类使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。&lt;/p&gt;
&lt;p&gt;       除了这些j.u.c提供的工具，还可以基于AQS自定义符合自己需求的同步器。&lt;/p&gt;

&lt;p&gt;       AQS就学习到这，如果有描述不当的地方，还请留言交流。了解了AQS后下一步准备详细学习基于AQS的工具类。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lingjiango/ConcurrentProgramPractice&quot;&gt;https://github.com/lingjiango/ConcurrentProgramPractice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot;&gt;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Java并发编程的艺术》&lt;/p&gt;
</description>
<pubDate>Sun, 12 Aug 2018 13:03:00 +0000</pubDate>
<dc:creator>lingjiango</dc:creator>
<og:description>在具备了volatile、CAS和模板方法设计模式的知识之后，我们可以来深入学习下AbstractQueuedSynchronizer（AQS），本文主要想从AQS的产生背景、设计和结构、源代码实现及</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iou123lg/p/9464385.html</dc:identifier>
</item>
</channel>
</rss>