<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发编程实战（chapter_2）（对象发布、不变性、设计线程安全类） - 少年天团</title>
<link>http://www.cnblogs.com/1024Community/p/8685396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1024Community/p/8685396.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;又是三星期的生活。感觉自从有了这个分享之后，会无形多了一份动力，逼着自己不能落后，必须要去不停的学习，这其实是我想要的，各位少年团中的成员也都是有共鸣的，在此很感动，省去一万字。。。。。这一次会总结对象的安全发布、不变性，这几点，在我们工程实践中，同样也是非常具有参考与思考价值的基础知识点。看书枯燥，理解生涩，可是当你看过，理解一点，再平时业务代码中就会比别人多思考一分，就会比别人在更“恶劣”的网络环境中，更稳定一分。这几天想起《三傻》中，那句很经典的话：追求卓越，成功将会悄悄的靠近你。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一发布与溢出&quot;&gt;一、发布与溢出&lt;/h2&gt;
&lt;p&gt;“发布（Publish）”一个对象的意思是指，使对象能够在当前作用于之外的代码中使用。这个“之外”，尤为关键，各种出问题的地方，都是因为这个“之外”所引起的。例如，如果在对象构造完成之前就发布该对象，就会破坏线程安全性。当某个不应该发布的对象被发布时，这种情况就被称为“溢出”。下面使用简单的例子进行说明：&lt;/p&gt;
&lt;h3 id=&quot;日常非常不注意的行为&quot;&gt;1. 日常非常不注意的行为&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Status {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String[] states = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[]{&lt;span class=&quot;st&quot;&gt;&quot;AA&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;BB&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;CC&quot;&lt;/span&gt;};

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String[] &lt;span class=&quot;fu&quot;&gt;getStates&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; states;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;思考：很多人会不服的来争吵：这特么哪里有问题，跑了这么久的线上了，一直没出问题啊！好，那么问题了来：是不是线上一直没问题的代码，就是好代码？就是正确的代码？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类似的代码还有：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Cache {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt; cache = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getCacheValue&lt;/span&gt;(String key){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; cache.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt; &lt;span class=&quot;fu&quot;&gt;getCache&lt;/span&gt;(String key){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; cache;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addCache&lt;/span&gt;(String key, Object object){
        cache.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(key, object);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;P.S.:以上代码是我去年年底，再项目工程中看到的代码，而且在线上运行着，千真万确！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分析问题所在&quot;&gt;2. 分析问题所在&lt;/h3&gt;
&lt;p&gt;你问我：这错在哪？如果我要回答，我会说：没错，你都没错。个人原因，我不喜欢程序员当面怼，因为我知道，大家都不容易，并且还知道：真的有问题那天，你知道痛了，你会主动改的，根本不用我说啥。当然，更严重的是，代码中（恩，线上代码），有人将states命名成了s，cache命名成了c，这我也说不了啥，什么叫做“追求卓越”，可能每人心中都会有自己的诠释吧。如果是下面代码出现在一个神不知鬼不觉的地方，请看：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Controller {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;cache&lt;/span&gt;(){&lt;span class=&quot;co&quot;&gt;//1&lt;/span&gt;
        Status status = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Status&lt;/span&gt;();
        String[] allStatus = status.&lt;span class=&quot;fu&quot;&gt;getStates&lt;/span&gt;();
        Cache.&lt;span class=&quot;fu&quot;&gt;addCache&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ALL_STATUS&quot;&lt;/span&gt;,allStatus);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;modify&lt;/span&gt;(){&lt;span class=&quot;co&quot;&gt;//2&lt;/span&gt;
        String[] allStatus = (String[])Cache.&lt;span class=&quot;fu&quot;&gt;getCacheValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ALL_STATUS&quot;&lt;/span&gt;);
        allStatus[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;// 也许变成了其他值，null是一种比较极端的情况&lt;/span&gt;
    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getFirstUpcaseStatus&lt;/span&gt;(){&lt;span class=&quot;co&quot;&gt;//3&lt;/span&gt;
        String[] allStatus = (String[])Cache.&lt;span class=&quot;fu&quot;&gt;getCacheValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ALL_STATUS&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; allStatus[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].&lt;span class=&quot;fu&quot;&gt;toUpperCase&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;// oh no! NPE!&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(){&lt;span class=&quot;co&quot;&gt;//4&lt;/span&gt;
        Cache.&lt;span class=&quot;fu&quot;&gt;getCache&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ALL_STATUS&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;1、2、3、4四个方法我们并不知道是什么时候触发的&lt;/li&gt;
&lt;li&gt;就是说时间顺序上，有可能是4号方法首先被触发，那1、2、3都将有问题&lt;/li&gt;
&lt;li&gt;即使4不被触发，先1、2，后3，也是出问题的&lt;/li&gt;
&lt;li&gt;也许我们代码写的很复杂，例如在2号程序中调用了非常多的service，用了非常多的设计模式，最终我们将修改数组中的值&lt;/li&gt;
&lt;li&gt;也许我们知道问题所在不去修改数组中的状态值，可是你能保证你能维护这个代码一辈子吗？&lt;/li&gt;
&lt;li&gt;以后交给两个人维护，两个人由于没啥子追求，别人代码不看，一个人在一边修改了数组，而另一个人在另一边使用了数组中的状态值，后果不堪设想&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;更加隐蔽式的危险发布&quot;&gt;3. 更加隐蔽式的危险发布&lt;/h3&gt;
&lt;p&gt;下面这种，新学到的一种危险性行为发布：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ThisEscape{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ThisEscape&lt;/span&gt;(EventSource source){
        source.&lt;span class=&quot;fu&quot;&gt;registerListener&lt;/span&gt;(e-&amp;gt;&lt;span class=&quot;fu&quot;&gt;doSomething&lt;/span&gt;(e));
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;心得：请大家尽量使用Java8语法，整洁、大方、可撸（这是什么鬼！）&lt;br/&gt;思考：注意doSomething方法，会有什么问题呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;构造器与构造者&quot;&gt;4. 构造器与构造者&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;作为构造者不要在构造器里面添加过多的逻辑，出错之后，这个锅你背不起！&lt;/li&gt;
&lt;li&gt;即使在一个构造器的最后一行，这个对象也是没有没初始化完成的！&lt;/li&gt;
&lt;li&gt;this指针被发布出去，后果不堪设想，对象没初始化完成，而使用this指针。&lt;/li&gt;
&lt;li&gt;上面代码，可以在doSomething方法内部使用&lt;code&gt;ThisEscape.this&lt;/code&gt;来访问父类&lt;/li&gt;
&lt;li&gt;如果父类没有初始化完，而访问父类，那将报错，这就是问题所在&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;针对这种隐蔽式的情况我们怎么做&quot;&gt;5.针对这种隐蔽式的情况，我们怎么做&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SafeListener {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; EventListener listener;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SafeListener&lt;/span&gt;() {
        listener = e-&amp;gt;&lt;span class=&quot;fu&quot;&gt;doSomething&lt;/span&gt;(e);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; SafeListener &lt;span class=&quot;fu&quot;&gt;newInstance&lt;/span&gt;(EventSource source){
        SafeListener safe = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SafeListener&lt;/span&gt;();
        source.&lt;span class=&quot;fu&quot;&gt;registerListener&lt;/span&gt;(safe.&lt;span class=&quot;fu&quot;&gt;listener&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; source;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;再举例一些不安全发布的例子&quot;&gt;5. 再举例一些不安全发布的例子&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Holder{
    &lt;span class=&quot;co&quot;&gt;// 曝露类属性，大忌~&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Holder holder;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;initialize&lt;/span&gt;(){
        holder = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Holder();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//由于未被正确发布，因此这个类可能出现故障&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Holder{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Holder(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n){
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;n&lt;/span&gt; = n;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;assertSanity&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(n != n){
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception(&lt;span class=&quot;st&quot;&gt;&quot;initial erroe&quot;&lt;/span&gt;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说明：抛出异常这个类是很玄乎的，因为线程可见性的原因，线程初次读取n的时候是老的值，可是这之后n值被其他线程更新，这个线程再次读取的时候，读取到一个失效的值，这就是抛出异常的原因。可以见得普普通通的自身与自身的比较，在多线程的环境下，都是很有问题的！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线程封闭&quot;&gt;6. 线程封闭&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;常见的封闭模式：栈封闭。就是在局部方法中使用一个变量，而不把他暴露出去。另外我自己的理解，每次方法返回一个新对象，也是一种使用方式。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; loadThe &lt;span class=&quot;fu&quot;&gt;Ark&lt;/span&gt;(Collection&amp;lt;Animal&amp;gt; candidates){
    &lt;span class=&quot;co&quot;&gt;// 将animals封闭在方法内部&lt;/span&gt;
    SortedSet&amp;lt;Animal&amp;gt; animals;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numberParies = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    Animal candidate = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;//针对animals容器进行各种统计&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; numberParise;

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Status {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String[] &lt;span class=&quot;fu&quot;&gt;getStates&lt;/span&gt;(){
        &lt;span class=&quot;co&quot;&gt;//每次都返回新的对象数组&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[]{&lt;span class=&quot;st&quot;&gt;&quot;AA&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;BB&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;CC&quot;&lt;/span&gt;};
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;另一种封闭模式：ThreadLocal模式。这种模式也比较常用，每次在web项目中保存session的时候，常常使用这种模式，来标记当前访问线程的登陆情况。不过这个要注意的是，再web中使用TreadLocal容易导致溢出，具体的分析，请期待到springMVC系列。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt; connectionHolder = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt;(){
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;initialValue&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(DB_URL);
    }
};
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(){
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; connectionHolder.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;给出写安全发布的模式&quot;&gt;7. 给出写安全发布的模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在静态初始化函数中初始化一个对象引用&lt;/li&gt;
&lt;li&gt;将对象的引用保存到volatile类型的域或者AtomicReferance对象中&lt;/li&gt;
&lt;li&gt;将对象的引用保存到某个正确构造对象的final类型域中&lt;/li&gt;
&lt;li&gt;将对象的引用保存到一个由锁保护的域中&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二不变性&quot;&gt;二、不变性&lt;/h2&gt;
&lt;p&gt;满足线程安全的另外一种方式，就是使用不可变对象。如果想要创建不可变对象的话，要满足以下条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象创建以后其状态就不能修改&lt;/li&gt;
&lt;li&gt;对象的所有域都是final类型&lt;/li&gt;
&lt;li&gt;对象是正确创建的（在对象的创建期间，this引用没有溢出）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基础的不可能变模型&quot;&gt;1. 基础的不可能变模型&lt;/h3&gt;
&lt;p&gt;这种方式，有点像我在《CC》观后感那篇文章中，讲到的一个观点：尽量对原始工具包中的类进行封装，有节制的使用其中的功能。下面代码就展示了，再可变对象的基础上构建不可变类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ThreeStooges{
    &lt;span class=&quot;co&quot;&gt;//注意，这个stooges变量是可变的！&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Set&amp;lt;String&amp;gt; stooges = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ThreeStooges&lt;/span&gt;(){
        stooges.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;);
        stooges.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2&quot;&lt;/span&gt;);
        stooges.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;3&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isStooges&lt;/span&gt;(String name){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; stooges.&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(name);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;有点高端的货使用不可变对象与volatile保证线程同步&quot;&gt;2. 有点高端的货：使用不可变对象与volatile保证线程同步&lt;/h3&gt;
&lt;p&gt;这里使用了三个内在的基本功点：对象不可变、对象读写分离、对象可见性。上代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Value{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; BigInteger lastNumber;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; BigInteger[] lastFactors;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Value&lt;/span&gt;(BigInteger lastNumber, BigInteger[] factors){
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lastNumber&lt;/span&gt; = lastNumber;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lastFactors&lt;/span&gt; = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(factors,factors.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//这里进行写复制&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BigInteger[] &lt;span class=&quot;fu&quot;&gt;getFactors&lt;/span&gt;(BigInteger i){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(lastNumber = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || !lastNumber.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(i))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(lastFactors,lastFactors.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//这里进行读复制&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说明：由于每次初始化时候都进行类属性的初始化，并与外界分离，因为factors数组每次都是复制一个副本进行初始化的！并且每次读的时候，也是讲数组对象进行复制分离。这样，只要一初始化对象之后，实际上，类对象里面的两个类属性都是不可变的了，因为全部与外界隔离了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们看看怎么使用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; VolatileCacheFactorizer &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Servlet{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Value cache = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Value&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; BigInteger[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;service&lt;/span&gt;(ServletRequest req, ServletResponse resp){
        BigInteger i = &lt;span class=&quot;fu&quot;&gt;extractFromRequest&lt;/span&gt;(req);
        BigInteger[] factors = cache.&lt;span class=&quot;fu&quot;&gt;getFactors&lt;/span&gt;(i);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(factors == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
            factors = &lt;span class=&quot;fu&quot;&gt;factor&lt;/span&gt;(i);
            cache = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Value&lt;/span&gt;(i,factors);
        }
        &lt;span class=&quot;fu&quot;&gt;encodeIntoResponse&lt;/span&gt;(resp,factors);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：这里cache类属性使用volatile，保证多线程写入的时候，都能够同步到主内存中，在这种情况下，多线程即是可见的，而通过Value对象的不变性又保证了对cache对象访问的安全性，那这样，整个service就是线程安全的了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三设计线程安全的类&quot;&gt;三、设计线程安全的类&lt;/h2&gt;
&lt;p&gt;这一部分，我看书中涉及到很多名词，需要上网搜搜资料看看解释，否则读这一部分会很懵逼。我下面从一些名词解释入手来说说这一章。&lt;/p&gt;
&lt;h3 id=&quot;什么叫做监视器模式&quot;&gt;1. 什么叫做监视器模式&lt;/h3&gt;
&lt;p&gt;乍看之下还以为这是一种设计模式，的确是一种设计模式！不过还想不起来是什么样子的。我一google才发现是非常简单的，其实就是一段互斥访问的代码段（管程）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SynClass{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; value = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; value;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;increment&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(value == Long.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;counter overflow&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ++value;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;说明：加了synchronized关键字的代码段，就相当一个屋子，每次只允许一个线程访问，如果访问有需求了，还可能进行挂起工作，那监视器是谁能？监视器就是对象本身，synchronized是加锁操作，这个锁也是这个对象持有的一个内部锁，如果要挂起代码，可是使用对象本身就天然继承自Object的wait方法，这就是监视器的作用。我看网上解释说：监视器（其实就是每个对象自己，因为每个对象都继承了Object）就像一个屋子的管理者，然后把对象这个“屋子”分成了三个地方：互斥访问区域、准备访问的区域和等待区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么叫做先验条件和后验条件&quot;&gt;2. 什么叫做先验条件和后验条件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;先验条件(precondition):针对方法（method），它规定了在调用该方法之前必须为真的条件。&lt;/li&gt;
&lt;li&gt;后验条件(postcondition):也是针对方法，它规定了方法顺利执行完毕之后必须为真的条件。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;设计线程安全的类的三要素&quot;&gt;3. 设计线程安全的类的三要素&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;找出构成对象状态的所有变量&lt;/li&gt;
&lt;li&gt;找出约束状态变量的不变性条件&lt;/li&gt;
&lt;li&gt;建立对象状态的并发访问管理策略&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么叫做不变性条件&quot;&gt;4. 什么叫做不变性条件&lt;/h3&gt;
&lt;p&gt;这个也是要做一定解释：程序在一系列的操作之后，还能够满足自己的先验条件和后验条件的，就叫做不变性条件（这个理解有点困难，大致我自己的想法是这样）&lt;/p&gt;
&lt;h3 id=&quot;收集同步的需求&quot;&gt;5. 收集同步的需求&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SafeClass{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; value = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;increment&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(value == Long.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;counter overflow&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ++value;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;我们要做的，确定本类中的那些状态，会再多线程的操作下影响对象的不变性&lt;/li&gt;
&lt;li&gt;如果一个状态转变是依赖于前一个状态的话，那就会复合操作，需要同步机制&lt;/li&gt;
&lt;li&gt;当然，有些状态转变不依赖之前，例如温度&lt;/li&gt;
&lt;li&gt;上例中increment加上了synchronized就是一种保护程序不变性与后验条件的机制&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;注意状态的所有权&quot;&gt;6. 注意状态的所有权&lt;/h3&gt;
&lt;p&gt;举个简单的例子&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Owner{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SunChild sub;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实这个sub对象就是Owner所拥有的一个子对象，所有权归Owner。但是如果加上如下代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Owner{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; SunChild sub;

    SubChild &lt;span class=&quot;fu&quot;&gt;getSub&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sub;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下，所有权就被发布了出去，这样的情况就要考虑同步机制进行保护。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：交出所有权的时候一定要多加思考程序的运行情景，以防不备！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实例封闭&quot;&gt;7. 实例封闭&lt;/h3&gt;
&lt;p&gt;如果某个对象不是线程安全的，我们可以将其进行封装，或者通过单一锁进行保护。下面是使用实例封闭模式进行的一种样例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PersonSet{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Set&amp;lt;Person&amp;gt; mySet = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;span class=&quot;co&quot;&gt;//mySet本身并非线程安全&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addPerson&lt;/span&gt;(Person p){
        mySet.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(p)
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(Person p){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; mySet.&lt;span class=&quot;fu&quot;&gt;contain&lt;/span&gt;(p);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程再访问数据时总能持有正确的锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线程安全的又一方式委托&quot;&gt;8. 线程安全的又一方式：委托&lt;/h3&gt;
&lt;p&gt;委托，其实就是将对象的涉及到的影响可变性条件的状态，放到JDK提供的一些线程安全的容器中去，进行统一管理。同样也是一个简单的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Tracher{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;String,Object&amp;gt; localMap;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Tracher&lt;/span&gt;(){
        localMap = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; &lt;span class=&quot;fu&quot;&gt;getLocations&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; localMap;
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getLocation&lt;/span&gt;(String key){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; lcoalMap.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面讲统一使用ConcurrentMap进行管理。如果想要获取一个不变的状态的话，可以进行读复制：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; &lt;span class=&quot;fu&quot;&gt;getLocations&lt;/span&gt;(){
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(localMap);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;委托不是万能的&quot;&gt;9. 委托不是万能的&lt;/h3&gt;
&lt;p&gt;过分依赖原子类所造成的“残局”：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; NumberRange {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AtomicInteger lower = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AtomicInteger upper = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setLower&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(i&amp;gt;upper.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;()){&lt;span class=&quot;co&quot;&gt;//注意这里&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception(&lt;span class=&quot;st&quot;&gt;&quot;error&quot;&lt;/span&gt;);
        }
        lower.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(i)
     }

     &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; AtomicInteger &lt;span class=&quot;fu&quot;&gt;getUpper&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; upper;
     }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：由于upper被暴露了出去，可是setLower方法内部进行了“先检查后执行”的步骤，依赖于upper值，这样，lower属性的值就出现了不可预估性，原子操作没达成，原子类失效了。可以使用加锁来修改上述代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;特别需要注意的由委托引起的非线程安全&quot;&gt;10. 特别需要注意的由委托引起的非线程安全&lt;/h3&gt;
&lt;p&gt;这种模式属于一种叫做“客户端加锁”，其实就是写程序中很不注意的，将内置锁和属性对象的锁混淆所致，下面是问题代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ListHelper&amp;lt;E&amp;gt;{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;E&amp;gt; list = Collections.&lt;span class=&quot;fu&quot;&gt;synchronizedList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;E&amp;gt;());

    ...

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;putIfAbsent&lt;/span&gt;(E e){
    &lt;span class=&quot;co&quot;&gt;//注意这里synchronized使用的是内置锁&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; absent = !list.&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(e);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(absent){
            &lt;span class=&quot;co&quot;&gt;//这里add使用的是list对象里面的同步锁&lt;/span&gt;
            list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(e);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; absent;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两种锁并不一样，导致并没有对“先判断再执行”进行同步操作，还是会存在不安全性问题。下面是解决的方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ListHelper&amp;lt;E&amp;gt;{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;E&amp;gt; list = Collections.&lt;span class=&quot;fu&quot;&gt;synchronizedList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;E&amp;gt;());

    ...

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;putIfAbsent&lt;/span&gt;(E e){
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (list){&lt;span class=&quot;co&quot;&gt;//统一使用属性对象的锁&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; absent = !list.&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(e);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(absent){
                list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(e);
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; absent;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;本次主要讲了三个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象的发布&lt;/li&gt;
&lt;li&gt;不变性&lt;/li&gt;
&lt;li&gt;设计线程安全的类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相对来说比较枯燥，尽量都是用简洁明了的例子来混合讲解了，望给位看官多多包涵~哈哈哈。接下来要分享的东西，就会实用很多，涉及到JDK线程工具的良好实用（如闭锁、FutureTask等），并且我在接下来的线程分享文章中，会每次安排一个大章节，逐步进行生活必备品之一的java.util.concurrent.ThreadPoolExecutor源码分析，敬请期待！&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 19:32:00 +0000</pubDate>
<dc:creator>少年天团</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1024Community/p/8685396.html</dc:identifier>
</item>
<item>
<title>SpringMVC之处理流程 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8683971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8683971.html</guid>
<description>&lt;p&gt; 之前在学servlet时写过&lt;a href=&quot;http://www.cnblogs.com/5ishare/p/6534407.html&quot; target=&quot;_blank&quot;&gt;JavaWeb与Asp.net工作原理比较分析&lt;/a&gt;，那篇主要是大致描述了下servlet的工作流程,今天在家了解了下springmvc的工作原理,与asp.net中的mvc进行了一下比较&lt;a href=&quot;http://www.cnblogs.com/5ishare/p/4515850.html&quot; target=&quot;_blank&quot;&gt;asp.net MVC 的处理流程&lt;/a&gt;，思想都是差不多，都是通过一个url怎么映射到类中做完处理返回浏览器的过程，首先要解决三大问题,一是url映射转换成request和response对象的问题二是浏览器与服务端的数据交互问题三是服务端的request、response怎么响应给客户端。今天了解了下它的运行流畅,其实网上也有好多教程。&lt;/p&gt;
&lt;p&gt;一图顶千言万语，用数据、用图说话,下图是springmvc的工作原理图。 &lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401021502228-788157259.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringMVC工作流程&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一、  用户发送请求至前端控制器DispatcherServlet。　&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　    &lt;span&gt;1.DispatcherServlet它也是servlet,load-on-startup=1,tomcat启动时它也会初始化,初始化参数是contextConfigLocation上下文配置文件位置,参数值就是&lt;a href=&quot;http://www.cnblogs.com/5ishare/p/7703513.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JavaWeb之Eclipse中使用Maven构建SpringMVC项目&lt;/span&gt;&lt;/a&gt;  配置的spring-mvc。在spring-mvc中可以配置自动扫描包名、默认注解映射支持、视图解释类、拦截器、对静态资源文件的访问等信息，通过自动扫描包名、注解映射支持、静态资源访问这些配置的信息在就会实例化HandlerMapping对象。这些对象是在tomcat进行参数初始化的时候也会实例化完成。在DispatcherServlet中维护着一个表,类似C#MVC中的RouteTable 路由表,存放的是HandlerMapping对象list.下面截图是DispatcherServlet中的部分代码,在DispatcherServlet中维护着handerMappings、handerAdapters等对象列表。在initStrategies中对上面的一些属性进行初始化。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401000506924-312070040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_42c2145f-47b9-461b-84ec-9100654de1ac&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_42c2145f-47b9-461b-84ec-9100654de1ac&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_42c2145f-47b9-461b-84ec-9100654de1ac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initStrategies(ApplicationContext context) {
        initMultipartResolver(context);
        initLocaleResolver(context);
        initThemeResolver(context);
        initHandlerMappings(context);
        initHandlerAdapters(context);
        initHandlerExceptionResolvers(context);
        initRequestToViewNameTranslator(context);
        initViewResolvers(context);
        initFlashMapManager(context);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml 中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;二、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;span&gt;请求到达DispatcherServlet中之后，就是get、post这些请求，这些请求是DispatcherServlet的父类FrameworkServlet中定义着的，而在这些方法中又调用了processRequest，processRequest中调用了doService，DispatcherServlet重写了doService方法，doService中主要设置了一些属性和调用doDispatch方法,doDispatch用来做分发请求。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_c51de5ca-adfb-4382-8cdd-fc63234250ea&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c51de5ca-adfb-4382-8cdd-fc63234250ea&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c51de5ca-adfb-4382-8cdd-fc63234250ea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doDispatch(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        HttpServletRequest processedRequest &lt;/span&gt;=&lt;span&gt; request;
        HandlerExecutionChain mappedHandler &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; multipartRequestParsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        WebAsyncManager asyncManager &lt;/span&gt;=&lt;span&gt; WebAsyncUtils.getAsyncManager(request);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ModelAndView mv &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            Exception dispatchException &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                processedRequest &lt;/span&gt;=&lt;span&gt; checkMultipart(request);
                multipartRequestParsed &lt;/span&gt;= (processedRequest !=&lt;span&gt; request);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine handler for the current request.&lt;/span&gt;
                mappedHandler =&lt;span&gt; getHandler(processedRequest);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    noHandlerFound(processedRequest, response);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine handler adapter for the current request.&lt;/span&gt;
                HandlerAdapter ha =&lt;span&gt; getHandlerAdapter(mappedHandler.getHandler());

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process last-modified header, if supported by the handler.&lt;/span&gt;
                String method =&lt;span&gt; request.getMethod();
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isGet = &quot;GET&quot;&lt;span&gt;.equals(method);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isGet || &quot;HEAD&quot;&lt;span&gt;.equals(method)) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lastModified =&lt;span&gt; ha.getLastModified(request, mappedHandler.getHandler());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; +&lt;span&gt; lastModified);
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp;&lt;span&gt; isGet) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mappedHandler.applyPreHandle(processedRequest, response)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Actually invoke the handler.&lt;/span&gt;
                mv =&lt;span&gt; ha.handle(processedRequest, response, mappedHandler.getHandler());

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (asyncManager.isConcurrentHandlingStarted()) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                applyDefaultViewName(processedRequest, mv);
                mappedHandler.applyPostHandle(processedRequest, response, mv);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
                dispatchException &lt;/span&gt;=&lt;span&gt; ex;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable err) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; As of 4.3, we're processing Errors thrown from handler methods as well,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; making them available for @ExceptionHandler methods and other scenarios.&lt;/span&gt;
                dispatchException = &lt;span&gt;new&lt;/span&gt; NestedServletException(&quot;Handler dispatch failed&quot;&lt;span&gt;, err);
            }
            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable err) {
            triggerAfterCompletion(processedRequest, response, mappedHandler,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NestedServletException(&quot;Handler processing failed&quot;&lt;span&gt;, err));
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (asyncManager.isConcurrentHandlingStarted()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instead of postHandle and afterCompletion&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (mappedHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Clean up any resources used by a multipart request.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (multipartRequestParsed) {
                    cleanupMultipart(processedRequest);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面的代码是核心代码，其实下面的几项其实就是代码的说明.　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
processedRequest =&lt;span&gt; checkMultipart(request);
multipartRequestParsed &lt;/span&gt;= (processedRequest != request);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面这两句是判断请求是不是上传文件的请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mappedHandler =&lt;span&gt; getHandler(processedRequest);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    noHandlerFound(processedRequest, response);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401003856440-1497378997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401005210447-1162924460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getHander返回的是一个HandlerExecutionChain,这个HandlerExecutionChain中包含一个handler和多个HandlerInterceptor(拦截器),这个和asp.net中的管道模型有点类似，一个httphandler和多个httpmodule,httpmodule也是用来做拦截操作的。同时要留意HandlerExecutionChain是通过HandlerMapping对象的getHandler获取的.其实这里还可以扩展比如拦截器的使用、HandlerMapping的介绍等,由于篇幅有限，会在以后的博客中一个一个的介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;四、  DispatcherServlet调用HandlerAdapter处理器适配器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f7a7bdcc-0051-4ca8-bc48-e911de255b34&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f7a7bdcc-0051-4ca8-bc48-e911de255b34&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f7a7bdcc-0051-4ca8-bc48-e911de255b34&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; HandlerAdapter getHandlerAdapter(Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.handlerAdapters != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (HandlerAdapter ha : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlerAdapters) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                    logger.trace(&lt;/span&gt;&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ha.supports(handler)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ha;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;No adapter for handler [&quot; + handler +
                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;获取适配器是通过遍历handlerAdapters列表找的,HandlerAdapter包含了3个方法.boolean supports(Object handler);ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;long getLastModified(HttpServletRequest request, Object handler);&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_79303388-652a-4008-9528-0330fe5c8c48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_79303388-652a-4008-9528-0330fe5c8c48&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_79303388-652a-4008-9528-0330fe5c8c48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2002-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.lang.Nullable;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * MVC framework SPI, allowing parameterization of the core MVC workflow.
 *
 * &amp;lt;p&amp;gt;Interface that must be implemented for each handler type to handle a request.
 * This interface is used to allow the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; DispatcherServlet} to be indefinitely
 * extensible. The {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; DispatcherServlet} accesses all installed handlers through
 * this interface, meaning that it does not contain code specific to any handler type.
 *
 * &amp;lt;p&amp;gt;Note that a handler can be of type {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Object}. This is to enable
 * handlers from other frameworks to be integrated with this framework without
 * custom coding, as well as to allow for annotation-driven handler objects that
 * do not obey any specific Java interface.
 *
 * &amp;lt;p&amp;gt;This interface is not intended for application developers. It is available
 * to handlers who want to develop their own web workflow.
 *
 * &amp;lt;p&amp;gt;Note: {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HandlerAdapter} implementors may implement the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt;
 * org.springframework.core.Ordered} interface to be able to specify a sorting
 * order (and thus a priority) for getting applied by the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; DispatcherServlet}.
 * Non-Ordered instances get treated as lowest priority.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Rod Johnson
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Juergen Hoeller
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.SimpleServletHandlerAdapter
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HandlerAdapter {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Given a handler instance, return whether or not this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HandlerAdapter}
     * can support it. Typical HandlerAdapters will base the decision on the handler
     * type. HandlerAdapters will usually only support one handler type each.
     * &amp;lt;p&amp;gt;A typical implementation:
     * &amp;lt;p&amp;gt;{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt;
     * return (handler instanceof MyHandler);
     * }
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler handler object to check
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; whether or not this object can use the given handler
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supports(Object handler);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Use the given handler to handle this request.
     * The workflow that is required may vary widely.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response current HTTP response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler handler to use. This object must have previously been passed
     * to the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; supports} method of this interface, which must have
     * returned {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true}.
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception in case of errors
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; ModelAndView object with the name of the view and the required
     * model data, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if the request has been handled directly
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Nullable
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Same contract as for HttpServlet's {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; getLastModified} method.
     * Can simply return -1 if there's no support in the handler class.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler handler to use
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the lastModified value for the given handler
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServlet#getLastModified
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.LastModified#getLastModified
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getLastModified(HttpServletRequest request, Object handler);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;五、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。&lt;/p&gt;
&lt;p&gt;六、  Controller执行完成返回ModelAndView。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;七、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1075c2bb-89bc-482e-9e93-d6e3ad22a219&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1075c2bb-89bc-482e-9e93-d6e3ad22a219&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1075c2bb-89bc-482e-9e93-d6e3ad22a219&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process last-modified header, if supported by the handler.&lt;/span&gt;
                String method =&lt;span&gt; request.getMethod();
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isGet = &quot;GET&quot;&lt;span&gt;.equals(method);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isGet || &quot;HEAD&quot;&lt;span&gt;.equals(method)) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lastModified =&lt;span&gt; ha.getLastModified(request, mappedHandler.getHandler());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; +&lt;span&gt; lastModified);
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp;&lt;span&gt; isGet) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mappedHandler.applyPreHandle(processedRequest, response)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Actually invoke the handler.&lt;/span&gt;
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 上面的几行代码先判断如果是get请求更新下lastModified请求头,然后执行HandlerExecutionChain中的applyPreHandle这个方法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_35148a87-656d-4b19-95b1-bdac7f074e16&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35148a87-656d-4b19-95b1-bdac7f074e16&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35148a87-656d-4b19-95b1-bdac7f074e16&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;boolean&lt;/span&gt; applyPreHandle(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        HandlerInterceptor[] interceptors &lt;/span&gt;=&lt;span&gt; getInterceptors();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ObjectUtils.isEmpty(interceptors)) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; interceptors.length; i++&lt;span&gt;) {
                HandlerInterceptor interceptor &lt;/span&gt;=&lt;span&gt; interceptors[i];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!interceptor.preHandle(request, response, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handler)) {
                    triggerAfterCompletion(request, response, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptorIndex =&lt;span&gt; i;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_966e5abb-12ee-4e48-98e9-8460695c6f4e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_966e5abb-12ee-4e48-98e9-8460695c6f4e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_966e5abb-12ee-4e48-98e9-8460695c6f4e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        HandlerInterceptor[] interceptors &lt;/span&gt;=&lt;span&gt; getInterceptors();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ObjectUtils.isEmpty(interceptors)) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;.interceptorIndex; i &amp;gt;= 0; i--&lt;span&gt;) {
                HandlerInterceptor interceptor &lt;/span&gt;=&lt;span&gt; interceptors[i];
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    interceptor.afterCompletion(request, response, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handler, ex);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex2) {
                    logger.error(&lt;/span&gt;&quot;HandlerInterceptor.afterCompletion threw exception&quot;&lt;span&gt;, ex2);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在applyPreHandle中它会遍历该HandlerExecutionChain中所有的拦截器,然后使用拦截器通过preHandle对handler进行预处理，如果所有的拦截器都能处理那就会继续往下执行，如果一旦有一个拦截器不能处理，就没必要往下走了，那就会触发triggerAfterCompletion方法，在triggerAfterCompletion中它是倒序遍历的拦截器的，执行完triggerAfterCompletion返回false之后doDispatch这个方法就执行结束了，下面的八、九、十、十一就不再执行。从第五步括号里的备注也能猜出来HandlerExecutionChain.handler是什么,它可以是Controller。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;八、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 九、  ViewReslover解析后返回具体View。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
applyDefaultViewName(processedRequest, mv);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ab186f58-e894-4ad0-a26f-cbac279d9c33&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ab186f58-e894-4ad0-a26f-cbac279d9c33&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab186f58-e894-4ad0-a26f-cbac279d9c33&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mv != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;mv.hasView()) {
            String defaultViewName &lt;/span&gt;=&lt;span&gt; getDefaultViewName(request);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultViewName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                mv.setViewName(defaultViewName);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce3ffef9-e4f6-46ab-97fa-92cd3146abe2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce3ffef9-e4f6-46ab-97fa-92cd3146abe2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce3ffef9-e4f6-46ab-97fa-92cd3146abe2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; String getDefaultViewName(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.viewNameTranslator != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;.viewNameTranslator.getViewName(request) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;找到ModelAndView对应的viewname，设置成它的属性值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mappedHandler.applyPostHandle(processedRequest, response, mv);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;applyPostHandle与applyPreHandle是对应着的，遍历handler的拦截器，执行postHandle方法。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_22230f62-2a2c-411f-b3be-e4592ef804f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_22230f62-2a2c-411f-b3be-e4592ef804f8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_22230f62-2a2c-411f-b3be-e4592ef804f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processDispatchResult(HttpServletRequest request, HttpServletResponse response,
            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
            @Nullable Exception exception) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; errorView = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ModelAndViewDefiningException) {
                logger.debug(&lt;/span&gt;&quot;ModelAndViewDefiningException encountered&quot;&lt;span&gt;, exception);
                mv &lt;/span&gt;=&lt;span&gt; ((ModelAndViewDefiningException) exception).getModelAndView();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                Object handler &lt;/span&gt;= (mappedHandler != &lt;span&gt;null&lt;/span&gt; ? mappedHandler.getHandler() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                mv &lt;/span&gt;=&lt;span&gt; processHandlerException(request, response, handler, exception);
                errorView &lt;/span&gt;= (mv != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did the handler return a view to render?&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (mv != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;mv.wasCleared()) {
            render(mv, request, response);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (errorView) {
                WebUtils.clearErrorRequestAttributes(request);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(&lt;/span&gt;&quot;Null ModelAndView returned to DispatcherServlet with name '&quot; + getServletName() +
                        &quot;': assuming HandlerAdapter completed request handling&quot;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Concurrent handling started during a forward&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mappedHandler.triggerAfterCompletion(request, response, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_d80b83d6-3d58-4985-adfc-361f7c026ec0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d80b83d6-3d58-4985-adfc-361f7c026ec0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d80b83d6-3d58-4985-adfc-361f7c026ec0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine locale for request and apply it to the response.&lt;/span&gt;
        Locale locale =&lt;span&gt;
                (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.localeResolver != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.localeResolver.resolveLocale(request) : request.getLocale());
        response.setLocale(locale);

        View view;
        String viewName &lt;/span&gt;=&lt;span&gt; mv.getViewName();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (viewName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need to resolve the view name.&lt;/span&gt;
            view =&lt;span&gt; resolveViewName(viewName, mv.getModelInternal(), locale, request);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;Could not resolve view with name '&quot; + mv.getViewName() +
                        &quot;' in servlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No need to lookup: the ModelAndView object contains the actual View object.&lt;/span&gt;
            view =&lt;span&gt; mv.getView();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
                        &quot;View object in servlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Delegate to the View object for rendering.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mv.getStatus() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                response.setStatus(mv.getStatus().value());
            }
            view.render(mv.getModelInternal(), request, response);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(&lt;/span&gt;&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name '&quot; +&lt;span&gt;
                        getServletName() &lt;/span&gt;+ &quot;'&quot;&lt;span&gt;, ex);
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在processDispatchResult方法中有一句render(mv, request, response),在render中先是获取View对象然后调用view.render(mv.getModelInternal(), request, response);将view和model绑定来进行渲染试图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十一、 DispatcherServlet响应用户。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;响应用户其实是在父类FrameworkServlet的processRequest方法中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401021314722-1672082247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十二、小结&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上面黑字部分是参考其他博客的，红色的是通过读源码找的，现在基本清楚springmvc大致的流程，其实如果继续深入的话，还有好多知识点，这篇博客就写到这，以后再慢慢补充。好久没熬夜学习了，今天算是毕业之后最用功的一天了,哈哈...(今天四月一,愚人节!!!)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;参考:https://www.cnblogs.com/xiaoxi/p/6164383.html&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 18:35:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8683971.html</dc:identifier>
</item>
<item>
<title>论文阅读——Visual inertial odometry using coupled nonlinear optimization - 跃行者</title>
<link>http://www.cnblogs.com/yuely/p/8684369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuely/p/8684369.html</guid>
<description>&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;论文提出一种新的视觉里程计算法，其直接利用带噪声的IMU数据和视觉特征位置来优化相机位姿。不同于对IMU和视觉数据运行分离的滤波器，这种算法将它们纳入联合的非线性优化框架中。视觉特征的透视重投影代价函数以及从IMU和位姿轨迹得到的加速度和角速度运动代价函数被联合优化。&lt;/p&gt;
&lt;h2&gt;一、算法的整体框架&lt;/h2&gt;
&lt;p&gt;　　文中提出的在线VIO算法，其限制优化窗口只包括最近的观测和参数。随着窗口尺寸的变化，估计精度和计算成本之间的权衡就会出现。这种算法属于利用优化框架的基于关键帧的方法，与之前方法相反的是，不边缘化之前的状态并优化局部窗口内的所有位姿。其主要的贡献是设计了局部优化代价函数，它不仅高效，而且尽可能的保证精度。算法的主要流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331214437583-2007808559.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传统的视觉里程计系统包括特征捕捉、位姿估计和滤波或优化步骤。特征点的检测与跟踪贯穿于所有输入帧，然后帧（或者关键帧）之间的相机运动从特征运动计算出来。可视的特征被保留为3D路标，并且它们被用于计算或提高相机轨迹。文中提出的算法遵循了视觉里程计的基本步骤，并且融合了来自IMU的加速度和角速度测量值。&lt;/p&gt;
&lt;h2&gt;二、算法细节&lt;/h2&gt;
&lt;p&gt;　　利用IMU数据存在几个问题，首先是IMU数据的获取频率与视频帧率不一致，并且远高于视频帧率。我们利用相机帧数k表示设备运动的参考时间索引。由于IMU测量频率远高于帧率，假设加入的IMU测量值(&lt;em&gt;t&lt;sub&gt;k&lt;/sub&gt;+∆t&lt;/em&gt;)紧接着帧&lt;em&gt;k&lt;/em&gt;。独立的加速度和角速度Kalman滤波器被用来减轻传感器读数中的噪声，并且我们用样条内插法来计算在相机帧处的同步的IMU估计值（如下图）。IMU读数带有偏差并且必须对它们精准的建模和估计以避免偏移。不同于在滤波框架中对偏差进行建模，在优化中，偏差参数和相机位姿以及路标位置一起通过完整地利用视觉特征观测进行估计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331215344087-2078417223.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单目视觉里程计只能估计相机运动到尺度，在视觉惯性里程计中，来自IMU的加速度数据可以被用来确定度量尺度。然而IMU只提供带噪声的设备的加速度测量值，恢复移动的距离必须被双重积分。并且，原始的IMU加速度数据包括重力，其必须被消除以正确计算运动，这需要精确的垂直方向估计。&lt;/p&gt;
&lt;h3&gt;A、数学公式&lt;/h3&gt;
&lt;p&gt;　　相机在&lt;em&gt;t&lt;/em&gt;时刻的六自由度位姿&lt;strong&gt;p&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;/em&gt;表示成旋转和位移矢量(&lt;strong&gt;r&lt;/strong&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;em&gt;&lt;sup&gt;T&lt;/sup&gt;&lt;/em&gt;, &lt;strong&gt;t&lt;/strong&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;em&gt;&lt;sup&gt;T&lt;/sup&gt;&lt;/em&gt;)&lt;em&gt;&lt;sup&gt;T&lt;/sup&gt;&lt;/em&gt; 。3×3旋转矩阵&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;可以和&lt;strong&gt;r&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;相互转换：&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt; = R(&lt;strong&gt;r&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;)并且&lt;strong&gt;r&lt;/strong&gt;&lt;em&gt;t &lt;/em&gt;= rot(&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;)。相机位姿和路标位置在大地坐标系其&lt;em&gt;z&lt;/em&gt;轴平行于重力方向。 IMU测量的加速度$\mathbf{\hat{a}}_t$包含重力和偏差。其在载体坐标系中。为了计算在大地坐标系下的加速度&lt;strong&gt;a&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;/em&gt;，加速度偏差$\mathbf{\hat{b}}_t$ 和重力&lt;strong&gt;g&lt;/strong&gt;必须被适当的减掉:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331220559763-573914042.png&quot; alt=&quot;&quot; width=&quot;193&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从三个利用视觉特征计算出的相机位姿，我们也可以计算加速度$\mathbf{\bar{a}}_t$ 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331220837355-1534735561.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，Δt是两连续帧之间的时间。在我们的优化框架中的加速度误差即为从视觉特征得到的加速度和从IMU得到的加速度之间的差别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331220959996-1993379725.png&quot; alt=&quot;&quot; width=&quot;134&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;角速度$\mathbf{\hat{ω}}_t$也通过IMU测量出来，并且角速度在大地坐标系下为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331222434064-709519397.png&quot; alt=&quot;&quot; width=&quot;225&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，$\mathbf{\hat{b}}_t$是陀螺仪偏差。来自视觉特征的角速度$\mathbf{\bar{ω}}_t$ 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331222641519-1543484511.png&quot; alt=&quot;&quot; width=&quot;188&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因而角速度误差$\mathbf{e}^ω_t$可以被定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331222826185-1303478097.png&quot; alt=&quot;&quot; width=&quot;129&quot; height=&quot;33&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，重投影误差$\mathbf{e}^{proj}_{i,j}$通过利用相机位姿&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt;和路标&lt;strong&gt;x&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;位置计算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331223211956-472693728.png&quot; alt=&quot;&quot; width=&quot;230&quot; height=&quot;40&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，proj(&lt;strong&gt;x&lt;/strong&gt;;&lt;strong&gt;p&lt;/strong&gt;)是3D点在相机位姿&lt;strong&gt;p&lt;/strong&gt;的投影图像坐标，并且f&lt;sub&gt;&lt;em&gt;i,j&lt;/em&gt;&lt;/sub&gt;是图像&lt;em&gt;j&lt;/em&gt;中路标&lt;em&gt;i&lt;/em&gt;的特征位置。&lt;/p&gt;
&lt;h3&gt;B、批量优化（用来做对比）&lt;/h3&gt;
&lt;p&gt;　　当视频帧和IMU测量值已知时，我们可以计算使得以上误差最小的相机轨迹。对于IMU读数$\{\mathbf{\hat{a}}_t, \mathbf{\hat{ω}}_t\}_T$以及跟踪的特征集合F = {&lt;strong&gt;f&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;i,j&lt;/sub&gt;&lt;/em&gt;}，批量优化的代价函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331224211521-1651272463.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;68&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在相机位姿&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt;, …, &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;T&lt;/sub&gt;，路标&lt;strong&gt;x&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt;, …, &lt;strong&gt;x&lt;/strong&gt;&lt;sub&gt;T&lt;/sub&gt;，和偏差&lt;strong&gt;b&lt;/strong&gt;&lt;sub&gt;a&lt;/sub&gt;, &lt;strong&gt;b&lt;/strong&gt;&lt;sub&gt;ω&lt;/sub&gt;处优化。||·||Σ是Mahalanobis距离，协方差为Σ。在论文中，协方差设为固定的方差$\mathbf{σ}_f^2, \mathbf{σ}_a^2, \mathbf{σ}_ω^2$的对角协方差矩阵。批量优化算法的结果显著地优于任何在线算法。批量优化可以生成最准确的结果，但是其要求所有的数据在处理之前就准备好，并且其需要长时间来收敛。&lt;/p&gt;
&lt;h3&gt;C、在线优化（滑动窗口法）&lt;/h3&gt;
&lt;p&gt;　　考虑应用目的，VIO必须能够实时地输出当前的相机位姿。为达到此目的，论文提出了简化的批量优化版本。在大多数视觉里程计系统中，当运动或视觉内容存在存在显著的改变时，选为关键帧。重投影误差项仅仅建立在关键帧和路标上。我们采取用了惯例，并利用关键帧来生成路标和位姿优化。在每一帧，相机位姿利用3维路标的图像位置计算出来，并且当相机移动较为明显时，帧被初始化为关键帧。建立在关键帧上的特征轨迹在优化中提供了足够多的相机位姿和路标位置上的约束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331224647942-209342180.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而如果IMU测量值在关键帧之间平均可能就成问题，因为关键帧比帧更加稀疏。最近的一些关键帧之间的帧被包含在优化中以约束连续帧之间的运动。这些活动的VIO帧用惯性约束连接了关键帧。这些帧的特征位置没有在优化中利用，因为这样会增加计算成本，并且连续帧之间的特征运动并不明显。当关键帧添加后，在线优化在活动的VO关键帧K&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;和活动的路标L&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;以及活动的VIO帧T&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331225006252-2087289299.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中K&lt;em&gt;&lt;sub&gt;f&lt;/sub&gt;&lt;/em&gt;是固定VO关键帧，它被用来强制路标位置与局部优化窗口之外的观测保持一致。VIO在线优化过程概括如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331225122735-1171975724.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;D、实施细节&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;前端：&lt;/strong&gt;对于VO或VIO系统，通常要么采用快速二进制描述子比如BRIEF或ORB，或者特征跟踪器比如KLT。论文采用Harris角点检测子和KLT用于特征跟踪。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化：&lt;/strong&gt;绝对尺度可以从IMU数据恢复，但是在初始化期间只存在有限数量的带噪声的IMU数据。论文选择的初始化策略是：首先利用可得到的数据（视觉信息）大致正确地初始化模型，然后在在线优化过程中利用即将到来的测量值更新模型。为了确定初始尺度因子&lt;em&gt;s&lt;/em&gt;首先通过积分IMU数据计算出最开始的两个关键帧之间的实际移动距离d&lt;em&gt;&lt;sub&gt;IMU&lt;/sub&gt;&lt;/em&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331225346471-936710800.png&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;170&quot;/&gt;　　　 计算出的尺度&lt;em&gt;s&lt;/em&gt;乘以相机和路标的位置，然后在两个关键帧以及关键帧之间的所有帧上执行在线优化以得到更加准确的初始化。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 16:19:00 +0000</pubDate>
<dc:creator>跃行者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuely/p/8684369.html</dc:identifier>
</item>
<item>
<title>Java日志框架：logback详解 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/8628945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/8628945.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么使用logback&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记得前几年工作的时候，公司使用的日志框架还是log4j，大约从16年中到现在，不管是我参与的别人已经搭建好的项目还是我自己主导的项目，日志框架基本都换成了logback，总结一下，logback大约有以下的一些优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内核重写、测试充分、初始化内存加载更小，这一切让logback性能和log4j相比有诸多倍的提升&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;logback非常自然地直接实现了slf4j，这个严格来说算不上优点，只是这样，再理解slf4j的前提下会很容易理解logback，也同时很容易用其他日志框架替换logback&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;logback有比较齐全的200多页的文档&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;logback当配置文件修改了，支持自动重新加载配置文件，扫描过程快且&lt;span&gt;安全&lt;/span&gt;，它并不需要另外创建一个扫描线程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持自动去除旧的日志文件，可以控制已经产生日志文件的最大数量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总而言之，如果大家的项目里面需要选择一个日志框架，那么我个人非常建议使用logback。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;logback加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们简单分析一下logback加载过程，当我们使用logback-classic.jar时，应用启动，那么logback会按照如下顺序进行扫描：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在系统配置文件System Properties中寻找是否有logback.configurationFile对应的value&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在classpath下寻找是否有logback.groovy（即logback支持groovy与xml两种配置方式）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在classpath下寻找是否有logback-test.xml&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在classpath下寻找是否有logback.xml&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以上任何一项找到了，就不进行后续扫描，按照对应的配置进行logback的初始化，具体代码实现可见ch.qos.logback.classic.util.ContextInitializer类的findURLOfDefaultConfigurationFile方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当所有以上四项都找不到的情况下，logback会调用ch.qos.logback.classic.BasicConfigurator的configure方法，构造一个ConsoleAppender用于向控制台输出日志，默认日志输出格式为&quot;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;logback的configuration&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;logback的重点应当是Appender、Logger、Pattern，在这之前先简单了解一下logback的&amp;lt;configuration&amp;gt;，&amp;lt;configuration&amp;gt;只有三个属性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;scan：当scan被设置为true时，当配置文件发生改变，将会被重新加载，默认为true&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;scanPeriod：检测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认为毫秒，当scan=true时这个值生效，默认时间间隔为1分钟&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;debug：当被设置为true时，将打印出logback内部日志信息，实时查看logback运行信息，默认为false&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;logger&amp;gt;与&amp;lt;root&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先从最基本的&amp;lt;logger&amp;gt;与&amp;lt;root&amp;gt;开始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;logger&amp;gt;用来设置某一个包或者具体某一个类的日志打印级别、以及指定&amp;lt;appender&amp;gt;&lt;/strong&gt;&lt;/span&gt;。&amp;lt;logger&amp;gt;可以包含零个或者多个&amp;lt;appender-ref&amp;gt;元素，标识这个appender将会添加到这个logger。&amp;lt;logger&amp;gt;仅有一个name属性、一个可选的level属性和一个可选的additivity属性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;name：用来指定受此logger约束的某一个包或者具体的某一个类&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;level：用来设置打印级别，五个常用打印级别从低至高依次为TRACE、DEBUG、INFO、WARN、ERROR，如果未设置此级别，那么当前logger会继承上级的级别&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;additivity：是否向上级logger传递打印信息，默认为true&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&amp;lt;root&amp;gt;也是&amp;lt;logger&amp;gt;元素，但是它是根logger，只有一个level属性，因为它的name就是root。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着写一段代码来测试一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Slf4jTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSlf4j() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Logger logger = LoggerFactory.getLogger(Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         logger.trace(&quot;=====trace=====&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         logger.debug(&quot;=====debug=====&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         logger.info(&quot;=====info=====&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         logger.warn(&quot;=====warn=====&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         logger.error(&quot;=====error=====&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;logback.xml的配置为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; scanPeriod&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;layout &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.PatternLayout&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;layout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;root将打印级别设置为&quot;info&quot;级别，&amp;lt;appender&amp;gt;暂时不管，控制台的输出为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018-03-26 22:57:48.779 [main] INFO  java.lang.Object - =====info=====
2018-03-26 22:57:48.782 [main] WARN  java.lang.Object - =====warn=====
2018-03-26 22:57:48.782 [main] ERROR java.lang.Object - =====error=====&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logback.xml的意思是，当Test方法运行时，root节点将日志级别大于等于info的交给已经配置好的名为&quot;STDOUT&quot;的&amp;lt;appender&amp;gt;进行处理，&quot;STDOUT&quot;将信息打印到控制台上。&lt;/p&gt;
&lt;p&gt;接着理解一下&amp;lt;logger&amp;gt;节点的作用，logback.xml修改一下，加入一个只有name属性的&amp;lt;logger&amp;gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; scanPeriod&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;layout &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.PatternLayout&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;layout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       
&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;debug&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;       
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意这个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;name表示的是LoggerFactory.getLogger(XXX.class)，XXX的包路径，包路径越少越是父级&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，我们测试代码里面是Object.class，即name=&quot;java&quot;是name=&quot;java.lang&quot;的父级，root是所有&amp;lt;logger&amp;gt;的父级。看一下输出为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018-03-27 23:02:02.963 [main] DEBUG java.lang.Object - =====debug=====
2018-03-27 23:02:02.965 [main] INFO  java.lang.Object - =====info=====
2018-03-27 23:02:02.966 [main] WARN  java.lang.Object - =====warn=====
2018-03-27 23:02:02.966 [main] ERROR java.lang.Object - =====error=====&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;出现这样的结果是因为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;lt;logger&amp;gt;中没有配置level，即继承父级的level，&amp;lt;logger&amp;gt;的父级为&amp;lt;root&amp;gt;，那么level=debug&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;没有配置additivity，那么additivity=true，表示此&amp;lt;logger&amp;gt;的打印信息向父级&amp;lt;root&amp;gt;传递&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;没有配置&amp;lt;appender-ref&amp;gt;，表示此&amp;lt;logger&amp;gt;不会打印出任何信息&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;由此可知，&amp;lt;logger&amp;gt;的打印信息向&amp;lt;root&amp;gt;传递，&amp;lt;root&amp;gt;使用&quot;STDOUT&quot;这个&amp;lt;appender&amp;gt;打印出所有大于等于debug级别的日志。举一反三，我们将&amp;lt;logger&amp;gt;的additivity配置为false，那么控制台应该不会打印出任何日志，因为&amp;lt;logger&amp;gt;的打印信息不会向父级&amp;lt;root&amp;gt;传递且&amp;lt;logger&amp;gt;没有配置任何&amp;lt;appender&amp;gt;，大家可以自己试验一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着，我们再配置一个&amp;lt;logger&amp;gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; scanPeriod&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;layout &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.PatternLayout&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;layout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java.lang&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;warn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;debug&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;      
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果读懂了上面的例子，那么这个例子应当很好理解：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;LoggerFactory.getLogger(Object.class)，首先找到name=&quot;java.lang&quot;这个&amp;lt;logger&amp;gt;，将日志级别大于等于warn的使用&quot;STDOUT&quot;这个&amp;lt;appender&amp;gt;打印出来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;name=&quot;java.lang&quot;这个&amp;lt;logger&amp;gt;没有配置additivity，那么additivity=true，打印信息向上传递，传递给父级name=&quot;java&quot;这个&amp;lt;logger&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;name=&quot;java&quot;这个&amp;lt;logger&amp;gt;的additivity=false且不关联任何&amp;lt;appender&amp;gt;，那么name=&quot;java&quot;这个&amp;lt;appender&amp;gt;不会打印任何信息&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;由此分析，得出最终的打印结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018-03-27 23:12:16.147 [main] WARN  java.lang.Object - =====warn=====
2018-03-27 23:12:16.150 [main] ERROR java.lang.Object - =====error=====&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;举一反三，上面的name=&quot;java&quot;这个&amp;lt;appender&amp;gt;可以把additivity设置为true试试看是什么结果，如果对前面的分析理解的朋友应该很容易想到，有两部分日志输出，一部分是日志级别大于等于warn的、一部分是日志级别大于等于debug的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;appender&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着看一下&amp;lt;appender&amp;gt;，&amp;lt;appender&amp;gt;是&amp;lt;configuration&amp;gt;的子节点，是负责写日志的组件。&amp;lt;appender&amp;gt;有两个必要属性name和class：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;name指定&amp;lt;appender&amp;gt;的名称&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;class指定&amp;lt;appender&amp;gt;的全限定名&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&amp;lt;appender&amp;gt;有好几种，上面我们演示过的是ConsoleAppender，&lt;span&gt;&lt;strong&gt;ConsoleAppender的作用是将日志输出到控制台&lt;/strong&gt;&lt;/span&gt;，配置示例为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中，encoder表示对参数进行格式化。我们和上一部分的例子对比一下，发现这里是有所区别的，上面使用了&amp;lt;layout&amp;gt;定义&amp;lt;pattern&amp;gt;，这里使用了&amp;lt;encoder&amp;gt;定义&amp;lt;pattern&amp;gt;，简单说一下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;lt;encoder&amp;gt;是0.9.19版本之后引进的，以前的版本使用&amp;lt;layout&amp;gt;，logback极力推荐的是使用&amp;lt;encoder&amp;gt;而不是&amp;lt;layout&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最常用的FileAppender和它的子类的期望是使用&amp;lt;encoder&amp;gt;而不再使用&amp;lt;layout&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;关于&amp;lt;encoder&amp;gt;中的格式下一部分再说。接着我们看一下FileAppender，&lt;span&gt;&lt;strong&gt;FileAppender的作用是将日志写到文件中&lt;/strong&gt;&lt;/span&gt;，配置示例为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;FILE&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.FileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;D:/123.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;它的几个节点为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;lt;file&amp;gt;表示写入的文件名，可以使相对目录也可以是绝对目录，如果上级目录不存在则自动创建&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;appender&amp;gt;如果为true表示日志被追加到文件结尾，如果是false表示清空文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;encoder&amp;gt;表示输出格式，后面说&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;prudent&amp;gt;如果为true表示日志会被安全地写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认为false&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;接着来看一下RollingFileAppender，&lt;span&gt;&lt;strong&gt;RollingFileAppender的作用是滚动记录文件，先将日志记录到指定文件，当符合某个条件时再将日志记录到其他文件&lt;/strong&gt;&lt;/span&gt;，RollingFileAppender配置比较灵活，因此使用得更多，示例为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ROLLING-FILE-1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rolling-file-%d{yyyy-MM-dd}.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这种是仅仅指定了&amp;lt;rollingPolicy&amp;gt;的写法，&amp;lt;rollingPolicy&amp;gt;的作用是当发生滚动时，定义RollingFileAppender的行为，其中上面的TimeBasedRollingPolicy是最常用的滚动策略，它根据时间指定滚动策略，既负责滚动也负责触发滚动，有以下节点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&amp;lt;fileNamePattern&amp;gt;，必要节点，包含文件名及&quot;%d&quot;转换符，&quot;%d&quot;可以包含一个Java.text.SimpleDateFormat指定的时间格式，如%d{yyyy-MM}，如果直接使用%d那么格式为yyyy-MM-dd。RollingFileAppender的file子节点可有可无，通过设置file可以为活动文件和归档文件指定不同的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&amp;lt;maxHistory&amp;gt;，可选节点，控制保留的归档文件的最大数量，如果超出数量就删除旧文件，假设设置每个月滚动且&amp;lt;maxHistory&amp;gt;是6，则只保存最近6个月的文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;向其他还有SizeBasedTriggeringPolicy，用于按照文件大小进行滚动，可以自己查阅一下资料。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;异步写日志&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;日志通常来说都以文件形式记录到磁盘，例如使用&amp;lt;RollingFileAppender&amp;gt;，这样的话一次写日志就会发生一次磁盘IO，这对于性能是一种损耗，因此更多的，对于每次请求必打的日志（例如请求日志，记录请求API、参数、请求时间），我们会&lt;span&gt;&lt;strong&gt;采取异步写日志的方式而不让此次写日志发生磁盘IO，阻塞线程从而造成不必要的性能损耗&lt;/strong&gt;&lt;/span&gt;。（不要小看这个点，可以网上查一下服务端性能优化的文章，只是因为将日志改为异步写，整个QPS就有了大幅的提高）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着我们看下如何使用logback进行异步写日志配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; scanPeriod&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ROLLING-FILE-1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rollingPolicy &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;12&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;D:/rolling-file-%d{yyyy-MM-dd}.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fileNamePattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;13&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maxHistory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rollingPolicy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%-4relative [%thread] %-5level %lo{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 异步输出 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;=&quot;ASYNC&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;= &quot;ch.qos.logback.classic.AsyncAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;  
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;discardingThreshold&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;discardingThreshold&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 更改默认的队列的深度,该值会影响性能.默认值为256 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;  
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;queueSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;256&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;queueSize&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加附加的appender,最多只能添加一个 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;  
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;=&quot;ROLLING-FILE-1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;  
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java.lang&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;DEBUG&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;ASYNC&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;INFO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;即，我们引入了一个AsyncAppender，先说一下AsyncAppender的原理，再说一下几个参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;span readability=&quot;13&quot;&gt;当我们配置了AsyncAppender，系统启动时会初始化一条名为&quot;AsyncAppender-Worker-ASYNC&quot;的线程&lt;p&gt;当Logging Event进入AsyncAppender后，AsyncAppender会调用appender方法，appender方法中再将event填入Buffer（使用的Buffer为BlockingQueue，具体实现为ArrayBlockingQueye）前，会先判断当前Buffer的容量以及丢弃日志特性是否开启，当消费能力不如生产能力时，AsyncAppender会将超出Buffer容量的Logging Event的级别进行丢弃，作为消费速度一旦跟不上生产速度导致Buffer溢出处理的一种方式。&lt;/p&gt;&lt;p&gt;上面的线程的作用，就是从Buffer中取出Event，交给对应的appender进行后面的日志推送&lt;/p&gt;&lt;p&gt;从上面的描述我们可以看出，AsyncAppender并不处理日志，只是将日志缓冲到一个BlockingQueue里面去，并在内部创建一个工作线程从队列头部获取日志，之后将获取的日志循环记录到附加的其他appender上去，从而达到不阻塞主线程的效果。因此AsyncAppender仅仅充当的是事件转发器，必须引用另外一个appender来做事。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上述原理，我们就能比较清晰地理解几个参数的作用了：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;discardingThreshold，假如等于20则表示，表示当还剩20%容量时，将丢弃TRACE、DEBUG、INFO级别的Event，只保留WARN与ERROR级别的Event，为了保留所有的events，可以将这个值设置为0，默认值为queueSize/5&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;queueSize比较好理解，BlockingQueue的最大容量，默认为256&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;includeCallerData表示是否提取调用者数据，这个值被设置为true的代价是相当昂贵的，为了提升性能，默认当event被加入BlockingQueue时，event关联的调用者数据不会被提取，只有线程名这些比较简单的数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;appender-ref表示AsyncAppender使用哪个具体的&amp;lt;appender&amp;gt;进行日志输出&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;encoder&amp;gt;节点负责两件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把日志信息转换为字节数组&lt;/li&gt;
&lt;li&gt;把字节数组写到输出流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前PatternLayoutEncoder是唯一有用的且默认的encoder，有一个&amp;lt;pattern&amp;gt;节点，就像上面演示的，用来设置日志的输入格式，使用“%+转换符&quot;的方式，如果要输出&quot;%&quot;则必须使用&quot;\%&quot;对&quot;%&quot;进行转义。&lt;/p&gt;
&lt;p&gt;&amp;lt;encoder&amp;gt;的一些可用参数用表格表示一下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;转换符&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;作  用&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;是否避免使用&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;c{length}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lo{length}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;logger{length}&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;输出日志的logger名称，可有一个整型参数来缩短&amp;lt;logger&amp;gt;名称，有几种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、不输入表示输出完整的&amp;lt;logger&amp;gt;名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、输入0表示只输出&amp;lt;logger&amp;gt;最右边点号之后的字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、输入其他数字表示输出小数点最后边点号之前的字符数量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;否&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;C{length}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;class{length}&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出指定记录的请求的调用者的全限定名，length同上&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;d{pattern}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;date{pattern}&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出时间格式，模式语法同java.text.SimpleDateFormat兼容&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;caller{depth}&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出生成日志的调用者的位置信息，整数选项表示输出信息深度&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;L&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出执行日志的请求行号&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;m&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;msg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;message&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出应用程序提供的信息&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;m&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输入执行日志请求的方法名&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;n&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出平台相关的分行符&quot;\n&quot;或者&quot;\r\n&quot;，即换行&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;p&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;le&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;level&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出日志级别&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;r&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;relative&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出从程序启动到创建日志记录的时间，单位为毫秒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;t&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;thread&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;输出产生日志的线程名称&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;看到最后一列是&quot;是否避免使用&quot;，这是因为这些信息是无法直接拿到的（比如请求行号、调用方法名），logback必须通过一些特殊手段去获取这些数据（比如在日志打印出产生一个堆栈信息），这种操作会比较影响效率，因此除非必要，否则不建议打印这些数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后来看一下&amp;lt;filter&amp;gt;，&amp;lt;filter&amp;gt;是&amp;lt;appender&amp;gt;的一个子节点，表示在当前给到的日志级别下再进行一次过滤，最基本的Filter有ch.qos.logback.classic.filter.LevelFilter和ch.qos.logback.classic.filter.ThresholdFilter，首先看一下LevelFilter：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; scanPeriod&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;WARN&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ACCEPT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;onMatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DENY&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;onMismatch&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java.lang&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;DEBUG&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;INFO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看一下输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018-03-31 22:22:58.843 [main] WARN  java.lang.Object - =====warn=====&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到尽管&amp;lt;logger&amp;gt;配置的是DEBUG，但是输出的只有warn，因为在&amp;lt;filter&amp;gt;中对匹配到WARN级别时做了ACCEPT（接受），对未匹配到WARN级别时做了DENY（拒绝），当然只能打印出WARN级别的日志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看一下ThresholdFilter，配置为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration &lt;/span&gt;&lt;span&gt;scan&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; scanPeriod&lt;/span&gt;&lt;span&gt;=&quot;60000&quot;&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;encoder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;INFO&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appender&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; additivity&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;java.lang&quot;&lt;/span&gt;&lt;span&gt; level&lt;/span&gt;&lt;span&gt;=&quot;DEBUG&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;logger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;root &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;INFO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appender-ref &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;STDOUT&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看一下输出为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018-03-31 22:41:32.353 [main] INFO  java.lang.Object - =====info=====
&lt;/span&gt;&lt;span&gt;2018-03-31 22:41:32.358 [main] WARN  java.lang.Object - =====warn=====
&lt;/span&gt;&lt;span&gt;2018-03-31 22:41:32.359 [main] ERROR java.lang.Object - =====error=====&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为ThresholdFilter的策略是，会将日志级别小于&amp;lt;level&amp;gt;的全部进行过滤，因此虽然指定了DEBUG级别，但是只有INFO及以上级别的才能被打印出来。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 16:02:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/8628945.html</dc:identifier>
</item>
<item>
<title>浅谈element-ui中的BEM范式实践 - baby格鲁特</title>
<link>http://www.cnblogs.com/ChengWuyi/p/8684776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChengWuyi/p/8684776.html</guid>
<description>&lt;p&gt;日常的工作中，我们无时无刻不在和样式打交道。没有样式的页面就如同一部电影，被人随意地在不同地方做了截取。&lt;/p&gt;
&lt;p&gt;BEM规范应该是对于我们现在前端组件开发中我觉得是最合适的一套范式了。所以，我在自己的日常工作中也是十分的推崇这样的一套CSS范式。&lt;/p&gt;
&lt;p&gt;而自己最近也在看各种ui框架的源码，觉得ele对于这块还是处理的蛮好的，所以拿出来说说。&lt;/p&gt;
&lt;h2&gt;1.BEM&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/ChengWuyi/p/5667945.html&quot; target=&quot;_blank&quot;&gt;BEM是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BEM范式我在以前自己的文章中简单的说过，就不再赘述了。&lt;/p&gt;
&lt;p&gt;而我们来看看饿了么在BEM这块有着怎样的实践。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//element-ui
//config.scss
$namespace: 'el';
$element-separator: '__';
$modifier-separator: '--';
$state-prefix: 'is-';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;element在config.scss里面定义了一些基础的配置项目，主要包括四个部分：&lt;/p&gt;
&lt;p&gt;1.整套样式的命名空间，命名空间可以带来不用系统样式的隔离，当然缺点就是我们的样式一定是带有一个namespace的前缀出现&lt;/p&gt;
&lt;p&gt;2.B和E之间的连接符&lt;/p&gt;
&lt;p&gt;3.E和M之间的连接符&lt;/p&gt;
&lt;p&gt;4.状态的前缀 ，因为有很多的用户行为而带来的激活这样的效果。在js中我们会说到is和as。一个是类型的判定，一个是类型的模糊，这是多态的特性体现。所以，同理的话，is在css中代表的就是当前元素状态的判定，例如:is-checked（是否被选中）之类等等&lt;/p&gt;
&lt;h2&gt;2.“B”的定义&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@mixin b($block) &lt;/span&gt;{&lt;span&gt;
  $B&lt;/span&gt;:&lt;span&gt; $namespace+'-'+$block !global&lt;/span&gt;;&lt;span&gt;

  .#{$B&lt;/span&gt;} {&lt;span&gt;
    @content;
  &lt;/span&gt;}&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ele通过宏b来实现的BEM中B的定义&lt;/p&gt;
&lt;p&gt;这里的话,我通过radio来作为假设。最后我们在b中通过!global提升了一个$B:el-radio。这也是我以前提到过的改良后的BEM。通过插值语句#{ }生成了 “.el-radio”。然后通过@content向生成的B中导入内容。&lt;/p&gt;
&lt;p&gt;导入的内容就是通过调用宏b生成的所有的样式。&lt;/p&gt;
&lt;p&gt;下面是所有通过mixin b可以生成的样式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('732f63f5-e2b0-4950-8848-a178400d6e8e')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_732f63f5-e2b0-4950-8848-a178400d6e8e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_732f63f5-e2b0-4950-8848-a178400d6e8e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('732f63f5-e2b0-4950-8848-a178400d6e8e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_732f63f5-e2b0-4950-8848-a178400d6e8e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//通过宏b生成的所有样式
@include b(radio) &lt;/span&gt;{&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; $--radio-color&lt;/span&gt;;&lt;span&gt;
  font-weight&lt;/span&gt;:&lt;span&gt; $--radio-font-weight&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;&lt;span&gt;
  display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;&lt;span&gt;
  white-space&lt;/span&gt;:&lt;span&gt; nowrap&lt;/span&gt;;&lt;span&gt;
  outline&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; $--font-size-base&lt;/span&gt;;&lt;span&gt;
  @include utils-user-select(none);

  @include when(bordered) {
    padding&lt;/span&gt;:&lt;span&gt; $--radio-bordered-padding&lt;/span&gt;;&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt; $--border-radius-base&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; $--border-base&lt;/span&gt;;&lt;span&gt;
    box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-height&lt;/span&gt;;&lt;span&gt;

    &amp;amp;.is-checked {
      border-color&lt;/span&gt;:&lt;span&gt; $--color-primary&lt;/span&gt;;
    }&lt;span&gt;

    &amp;amp;.is-disabled &lt;/span&gt;{&lt;span&gt;
      cursor&lt;/span&gt;:&lt;span&gt; not-allowed&lt;/span&gt;;&lt;span&gt;
      border-color&lt;/span&gt;:&lt;span&gt; $--border-color-lighter&lt;/span&gt;;
    }&lt;span&gt;

    &amp;amp; + .el-radio.is-bordered &lt;/span&gt;{&lt;span&gt;
      margin-left&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
    }&lt;span&gt;
  }

  @include m(medium) &lt;/span&gt;{&lt;span&gt;
    &amp;amp;.is-bordered {
      padding&lt;/span&gt;:&lt;span&gt; $--radio-bordered-medium-padding&lt;/span&gt;;&lt;span&gt;
      border-radius&lt;/span&gt;:&lt;span&gt; $--button-medium-border-radius&lt;/span&gt;;&lt;span&gt;
      height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-medium-height&lt;/span&gt;;&lt;span&gt;
      .el-radio__label {
        font-size&lt;/span&gt;:&lt;span&gt; $--button-medium-font-size&lt;/span&gt;;
      }&lt;span&gt;
      .el-radio__inner &lt;/span&gt;{&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-medium-input-height&lt;/span&gt;;&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; $--radio-bordered-medium-input-width&lt;/span&gt;;
      }&lt;span&gt;
    }
  }
  @include m(small) &lt;/span&gt;{&lt;span&gt;
    &amp;amp;.is-bordered {
      padding&lt;/span&gt;:&lt;span&gt; $--radio-bordered-small-padding&lt;/span&gt;;&lt;span&gt;
      border-radius&lt;/span&gt;:&lt;span&gt; $--button-small-border-radius&lt;/span&gt;;&lt;span&gt;
      height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-small-height&lt;/span&gt;;&lt;span&gt;
      .el-radio__label {
        font-size&lt;/span&gt;:&lt;span&gt; $--button-small-font-size&lt;/span&gt;;
      }&lt;span&gt;
      .el-radio__inner &lt;/span&gt;{&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-small-input-height&lt;/span&gt;;&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; $--radio-bordered-small-input-width&lt;/span&gt;;
      }&lt;span&gt;
    }
  }
  @include m(mini) &lt;/span&gt;{&lt;span&gt;
    &amp;amp;.is-bordered {
      padding&lt;/span&gt;:&lt;span&gt; $--radio-bordered-mini-padding&lt;/span&gt;;&lt;span&gt;
      border-radius&lt;/span&gt;:&lt;span&gt; $--button-mini-border-radius&lt;/span&gt;;&lt;span&gt;
      height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-mini-height&lt;/span&gt;;&lt;span&gt;
      .el-radio__label {
        font-size&lt;/span&gt;:&lt;span&gt; $--button-mini-font-size&lt;/span&gt;;
      }&lt;span&gt;
      .el-radio__inner &lt;/span&gt;{&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; $--radio-bordered-mini-input-height&lt;/span&gt;;&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; $--radio-bordered-mini-input-width&lt;/span&gt;;
      }&lt;span&gt;
    }
  }

  &amp;amp; + .el-radio &lt;/span&gt;{&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;
  }&lt;span&gt;

  @include e(input) &lt;/span&gt;{&lt;span&gt;
    white-space&lt;/span&gt;:&lt;span&gt; nowrap&lt;/span&gt;;&lt;span&gt;
    cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;&lt;span&gt;
    outline&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
    vertical-align&lt;/span&gt;:&lt;span&gt; middle&lt;/span&gt;;&lt;span&gt;

    @include when(disabled) {
      .el-radio__inner {
        background-color&lt;/span&gt;:&lt;span&gt; $--radio-disabled-input-fill&lt;/span&gt;;&lt;span&gt;
        border-color&lt;/span&gt;:&lt;span&gt; $--radio-disabled-input-border-color&lt;/span&gt;;&lt;span&gt;
        cursor&lt;/span&gt;:&lt;span&gt; not-allowed&lt;/span&gt;;&lt;span&gt;

        &amp;amp;&lt;/span&gt;:&lt;span&gt;:after {
          cursor: not-allowed&lt;/span&gt;;&lt;span&gt;
          background-color&lt;/span&gt;:&lt;span&gt; $--radio-disabled-icon-color&lt;/span&gt;;
        }&lt;span&gt;

        &amp;amp; + .el-radio__label &lt;/span&gt;{&lt;span&gt;
          cursor&lt;/span&gt;:&lt;span&gt; not-allowed&lt;/span&gt;;
        }&lt;span&gt;
      }
      &amp;amp;.is-checked &lt;/span&gt;{&lt;span&gt;
        .el-radio__inner {
          background-color&lt;/span&gt;:&lt;span&gt; $--radio-disabled-checked-input-fill&lt;/span&gt;;&lt;span&gt;
          border-color&lt;/span&gt;:&lt;span&gt; $--radio-disabled-checked-input-border-color&lt;/span&gt;;&lt;span&gt;

          &amp;amp;&lt;/span&gt;:&lt;span&gt;:after {
            background-color: $--radio-disabled-checked-icon-color&lt;/span&gt;;
          }&lt;span&gt;
        }
      }
      &amp;amp; + span.el-radio__label &lt;/span&gt;{&lt;span&gt;
        color&lt;/span&gt;:&lt;span&gt; $--color-text-placeholder&lt;/span&gt;;&lt;span&gt;
        cursor&lt;/span&gt;:&lt;span&gt; not-allowed&lt;/span&gt;;
      }&lt;span&gt;
    }

    @include when(checked) &lt;/span&gt;{&lt;span&gt;
      .el-radio__inner {
        border-color&lt;/span&gt;:&lt;span&gt; $--radio-checked-input-border-color&lt;/span&gt;;&lt;span&gt;
        background&lt;/span&gt;:&lt;span&gt; $--radio-checked-icon-color&lt;/span&gt;;&lt;span&gt;

        &amp;amp;&lt;/span&gt;:&lt;span&gt;:after {
          transform: translate(-50%, -50%) scale(1)&lt;/span&gt;;
        }&lt;span&gt;
      }

      &amp;amp; + .el-radio__label &lt;/span&gt;{&lt;span&gt;
        color&lt;/span&gt;:&lt;span&gt; $--radio-checked-text-color&lt;/span&gt;;
      }&lt;span&gt;
    }

    @include when(focus) &lt;/span&gt;{&lt;span&gt;
      .el-radio__inner {
        border-color&lt;/span&gt;:&lt;span&gt; $--radio-input-border-color-hover&lt;/span&gt;;
      }&lt;span&gt;
    }
  }
  @include e(inner) &lt;/span&gt;{&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; $--radio-input-border&lt;/span&gt;;&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt; $--radio-input-border-radius&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; $--radio-input-width&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; $--radio-input-height&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; $--radio-input-fill&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
    cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;&lt;span&gt;
    box-sizing&lt;/span&gt;:&lt;span&gt; border-box&lt;/span&gt;;&lt;span&gt;

    &amp;amp;&lt;/span&gt;:&lt;span&gt;hover {
      border-color: $--radio-input-border-color-hover&lt;/span&gt;;
    }&lt;span&gt;

    &amp;amp;::after &lt;/span&gt;{&lt;span&gt;
      width&lt;/span&gt;:&lt;span&gt; 4px&lt;/span&gt;;&lt;span&gt;
      height&lt;/span&gt;:&lt;span&gt; 4px&lt;/span&gt;;&lt;span&gt;
      border-radius&lt;/span&gt;:&lt;span&gt; $--radio-input-border-radius&lt;/span&gt;;&lt;span&gt;
      background-color&lt;/span&gt;:&lt;span&gt; $--color-white&lt;/span&gt;;&lt;span&gt;
      content&lt;/span&gt;:&lt;span&gt; &quot;&quot;&lt;/span&gt;;&lt;span&gt;
      position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
      left&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
      top&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
      transform&lt;/span&gt;:&lt;span&gt; translate(-50%, -50%) scale(0)&lt;/span&gt;;&lt;span&gt;
      transition&lt;/span&gt;:&lt;span&gt; transform .15s cubic-bezier(.71,-.46,.88,.6)&lt;/span&gt;;
    }&lt;span&gt;
  }

  @include e(original) &lt;/span&gt;{&lt;span&gt;
    opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    outline&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    z-index&lt;/span&gt;:&lt;span&gt; -1&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
  }&lt;span&gt;

  &amp;amp;:focus:not(.is-focus):not(:active)&lt;/span&gt;{ &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获得焦点时 样式提醒&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    .el-radio__inner {
      box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 2px 2px $--radio-input-border-color-hover&lt;/span&gt;;
    }&lt;span&gt;
  }

  @include e(label) &lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; $--radio-font-size&lt;/span&gt;;&lt;span&gt;
    padding-left&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
  }&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; 3.“E”的定义&lt;/h2&gt;
&lt;p&gt;完成了B以后的话，就要处理E了。不过在e中多做了两件事&lt;/p&gt;
&lt;p&gt;1.通过each完成了&quot;BE&quot;的样式的生成，例如是input，那么$currentSelector就是&quot;.el-radio + __ +  input&quot;&lt;/p&gt;
&lt;p&gt;2.通过函数处理@return containsModifier($selector) or containWhenFlag($selector) or containPseudoClass($selector) 三种情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@mixin e($element) &lt;/span&gt;{&lt;span&gt;
  $E&lt;/span&gt;:&lt;span&gt; $element !global&lt;/span&gt;;&lt;span&gt;
  $selector&lt;/span&gt;:&lt;span&gt; &amp;amp;&lt;/span&gt;;&lt;span&gt;
  $currentSelector&lt;/span&gt;:&lt;span&gt; &quot;&quot;&lt;/span&gt;;&lt;span&gt;
  @each $unit in $element {
    $currentSelector&lt;/span&gt;:&lt;span&gt; #{$currentSelector + &quot;.&quot; + $B + $element-separator + $unit + &quot;,&quot;&lt;/span&gt;}&lt;span&gt;;
  }

  @if hitAllSpecialNestRule($selector) &lt;/span&gt;{&lt;span&gt;
    @at-root {
      #{$selector&lt;/span&gt;} {&lt;span&gt;
        #{$currentSelector&lt;/span&gt;} {&lt;span&gt;
          @content;
        &lt;/span&gt;}&lt;span&gt;
      }
    }
  } @else &lt;/span&gt;{&lt;span&gt;
    @at-root {
      #{$currentSelector&lt;/span&gt;} {&lt;span&gt;
        @content;
      &lt;/span&gt;}&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 4.“M”的定义&lt;/h2&gt;
&lt;p&gt;最后是m的生成，基本上原理都和前面说到的是一样的了。&lt;/p&gt;
&lt;p&gt;例如:el-radio--medium。用来描述radio的size属性。那么$currentSelector就是&quot;.el-radio + -- +  medium&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@mixin m($modifier) &lt;/span&gt;{&lt;span&gt;
  $selector&lt;/span&gt;:&lt;span&gt; &amp;amp;&lt;/span&gt;;&lt;span&gt;
  $currentSelector&lt;/span&gt;:&lt;span&gt; &quot;&quot;&lt;/span&gt;;&lt;span&gt;
  @each $unit in $modifier {
    $currentSelector&lt;/span&gt;:&lt;span&gt; #{$currentSelector + &amp;amp; + $modifier-separator + $unit + &quot;,&quot;&lt;/span&gt;}&lt;span&gt;;
  }

  @at-root &lt;/span&gt;{&lt;span&gt;
    #{$currentSelector&lt;/span&gt;} {&lt;span&gt;
      @content;
    &lt;/span&gt;}&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 5.小结&lt;/h2&gt;
&lt;p&gt;我在这也就是抛砖引玉的说下，精彩的内容还是要大家自己去源码里看，或者自己去试着写一下那就是最好了。&lt;/p&gt;
&lt;p&gt;试着写一个vue或者react的组件用上BEM范式去管理类名，肯定也会和我一样，觉得在基于组件化开发的前端项目中，BEM范式绝对是我们管理css的一把利器。&lt;/p&gt;
&lt;p&gt;当然，在以后的文章中我也会来说说OO和SMA范式。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 16:00:00 +0000</pubDate>
<dc:creator>baby格鲁特</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChengWuyi/p/8684776.html</dc:identifier>
</item>
<item>
<title>drbd(三)：drbd的状态说明 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8684648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8684648.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog1&quot;&gt;&lt;span&gt;1.drbd配置文件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2&quot;&gt;&lt;span&gt;2.状态&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.1&quot;&gt;&lt;span&gt;2.1 连接状态(connect state,cs)和复制状态&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.2&quot;&gt;&lt;span&gt;2.2 角色状态(roles,ro)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.3&quot;&gt;&lt;span&gt;2.3 磁盘状态(disk state,ds)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.4&quot;&gt;&lt;span&gt;2.4 IO状态标记&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.5&quot;&gt;&lt;span&gt;2.5 性能指标&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;drbd有很多获取信息的方式。在drbd84和之前的版本，大多都使用&lt;code&gt;cat /proc/drbd&lt;/code&gt;来获取信息，多数情况下，这个文件展示的信息对于管理和维护drbd来说已经足够。&lt;/p&gt;
&lt;p&gt;例如以下是drbd84上两个volume的节点状态信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3441&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4957732&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76324&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4883249&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但从drbd9开始，/proc/drbd文件已经废弃了(其实从drbd84就已经废弃了，只不过仍然能获取信息)，因为drbd9中添加了几个新状态信息，也修改了一些信息的显示名称，而这个文件并没有&quot;跟上脚步&quot;。以下是drbd9中该文件展示的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd91&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;.9-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;112&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: f7b979e7af01813e031aac579140237640c94569 build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;
Transports (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;): tcp (&lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;.9-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在drbd9中，更多的是使用&lt;code&gt;drbdadm&lt;/code&gt;或&lt;code&gt;drbdsetup&lt;/code&gt;来获取节点的状态信息。当然，在drbd84中也可以使用它们来获取详细的信息，只不过使用/proc/drbd既方便，又简洁，多数人都直接更愿意使用/proc/drbd。&lt;/p&gt;
&lt;p&gt;例如，使用drbdadm获取节点的基本信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

[root@drbd90 ~]
rs0 role:Primary
  volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; disk:UpToDate
  volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; disk:UpToDate
  drbd91.longshuai.com role:Secondary
    volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0.43&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23.72&lt;/span&gt;

[root@drbd90 ~]
drbdsetup status rs0 
rs0 role:Primary
  volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; disk:UpToDate
  volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; disk:UpToDate
  drbd91.longshuai.com role:Secondary
    volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;7.04&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;48.44&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用drbdsetup获取更详细的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;######### drbdsetup status [

[root@drbd90 ~]# drbdsetup status rs0 
rs0 node-id:0 role:Primary suspended:no
    write-ordering:&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;flush&lt;/span&gt;
  volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; minor:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; disk:UpToDate
      &lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4882432&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;537552&lt;/span&gt; written:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; bm-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;upper&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lower&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt; blocked:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
  volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; minor:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; disk:UpToDate
      &lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4882432&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2811712&lt;/span&gt; written:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; bm-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;upper&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lower&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt; blocked:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
  drbd91.longshuai.com node-id:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;connection&lt;/span&gt;:Connected role:Secondary congested:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent done:&lt;span class=&quot;hljs-number&quot;&gt;11.00&lt;/span&gt; resync-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
        received:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; sent:&lt;span class=&quot;hljs-number&quot;&gt;537096&lt;/span&gt; out-&lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt;-sync:&lt;span class=&quot;hljs-number&quot;&gt;4345336&lt;/span&gt; pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; unacked:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent done:&lt;span class=&quot;hljs-number&quot;&gt;57.58&lt;/span&gt; resync-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
        received:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; sent:&lt;span class=&quot;hljs-number&quot;&gt;2811256&lt;/span&gt; out-&lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt;-sync:&lt;span class=&quot;hljs-number&quot;&gt;2071176&lt;/span&gt; pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; unacked:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，还可以使用&lt;code&gt;drbd-overview&lt;/code&gt;获取一些简单的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd91&lt;/span&gt; ~]
&lt;span class=&quot;hljs-constant&quot;&gt;NOTE&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt; drbd-overview will be deprecated soon.
&lt;span class=&quot;hljs-constant&quot;&gt;Please&lt;/span&gt; consider using drbdtop.

 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:rs0/&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;Connected&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*) &lt;span class=&quot;hljs-constant&quot;&gt;Second&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;Primar&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt; 
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:rs0/&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;Connected&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*) &lt;span class=&quot;hljs-constant&quot;&gt;Second&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;Primar&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;/proc/drbd文件中的状态信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3441&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第三行中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;是drbd的次设备号(minor)，表示该行是/dev/drbd0资源的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cs&lt;/code&gt;是connect state，即节点的连接状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ro&lt;/code&gt;是roles，即节点的角色状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ds&lt;/code&gt;是disk state，即磁盘的状态，也即drbd底层设备的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;是drbd的复制协议，即A、B、C协议。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r-----&lt;/code&gt;是IO标记，反应的是该资源的IO状态信息。共有6种IO状态标记符号。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第四行是drbd同步过程中的状态，总体概括为&quot;性能指标&quot;。&lt;/p&gt;
&lt;p&gt;以下翻译自官方手册： &lt;span&gt;&lt;a href=&quot;https://docs.linbit.com/docs/users-guide-8.4/#s-check-status&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;users-guide-8.4&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;a href=&quot;https://docs.linbit.com/docs/users-guide-9.0/#s-check-status&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;users-guide-9.0&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 。如果有疑问，可从官方手册自行查找答案。&lt;/p&gt;

&lt;h2 id=&quot;2-1-connect-state-cs-&quot;&gt;2.1 连接状态(connect state,cs)和复制状态&lt;/h2&gt;
&lt;p&gt;节点间通过TCP连接进行通信，在建立连接、断开连接、特殊情况下有很多种连接状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;建立TCP连接后，还有称为&quot;DRBD&quot;的连接&lt;/span&gt;。&lt;/strong&gt;DRBD连接建立完成，表示元数据区、数据区等一切都已准备好，可以进行任何数据同步的操作。&lt;/p&gt;
&lt;p&gt;节点间的连接状态既可以从/proc/drbd文件中获取，也可以使用下面的命令来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd91&lt;/span&gt; ~]
Connected
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;drbd84中，将连接状态和复制状态全部都归类为连接状态。但在drbd9中，由于可以通过net指令定义多个drbd节点，它更网络对端和volume的概念。因此它将和连接关系不大的状态独立划分为&quot;复制状态(replication)&quot;中，例如同步、验证相关的状态。本文就懒得去区分它们了，都放在一起解释吧。&lt;/p&gt;
&lt;p&gt;有以下几种连接状态，其中最常捕获到的状态已经加粗显示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WFConnection&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;当前节点正在等待对端节点出现。例如对方节点&lt;code&gt;drbdadm down&lt;/code&gt;后，本节点将处于本状态。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandAlone&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;无连接。出现这种状态可能是因为：未连接过、使用&lt;code&gt;drbdadm disconnect&lt;/code&gt;断开连接、节点由于身份验证的原因未成功加入drbd集群使得连接被删除、脑裂后断开连接。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Disconnecting&lt;/code&gt;：断开连接的一个临时过渡状态。它很快就会切入下一状态就是StandAlone。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unconnected&lt;/code&gt;：尝试再次发起TCP连接时的一个临时连接状态(是连接超时后再次发送连接请求产生的状态)，它的下一个状态可能是WFConnection，也可能是WFReportParams。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timeout&lt;/code&gt;：和对端通信超时时的临时状态。下一个状态就是Unconnection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BrokenPipe&lt;/code&gt;：和对端连接丢失时的临时状态。下一个状态是Unconnection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NetworkFailure&lt;/code&gt;：和对端连接丢失时的临时状态。下一个状态是Unconnection。(没错，和上面的一样)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProtocolError&lt;/code&gt;：和对端连接丢失时的临时状态。下一个状态是Unconnection。(没错，还是和上面的一样)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TearDown&lt;/code&gt;：对端关闭TCP连接时的临时状态。下一个状态是Unconnection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connected&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;DRBD连接已经建立完成，数据镜像已经激活成功。这个状态是drbd正常运行时的状态。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFReportParams&lt;/code&gt;：TCP连接已经建立完成，该节点正在等待对端的第一个数据包。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartingSyncS&lt;/code&gt;：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：SyncSource或PauseSyncS。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartingSyncT&lt;/code&gt;：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：WFSyncUUID。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFBitMapS&lt;/code&gt;：部分数据正在同步。下一个状态是：SyncSource或PauseSyncS。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFBitMapT&lt;/code&gt;：部分数据正在同步。下一个状态是：WFSyncUUID。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFSyncUUID&lt;/code&gt;：同步马上就要开始了。下一个状态：SyncTarget或PauseSyncT。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SyncSource&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;正在同步，且本节点是数据同步的源端。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SyncTartget&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;正在同步，且本节点是数据同步的目标端。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PauseSyncS&lt;/code&gt;：本节点是同步的源端节点，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用&lt;code&gt;drbdadm pause-sync&lt;/code&gt;手动中断了同步操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PauseSyncT&lt;/code&gt;：本节点是同步的目标端，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用&lt;code&gt;drbdadm pause-sync&lt;/code&gt;手动中断了同步操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VerifyS&lt;/code&gt;：正在进行在线设备验证，且本节点将成为验证的源端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VerifyT&lt;/code&gt;：正在进行在线设备验证，且本节点将成为验证的目标端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在drbd9中，WFConnection状态改为connecting状态。删除了WFReportParams状态。添加了以下几个同步相关的状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Off&lt;/code&gt;：该卷组还未同步，因为连接未建立。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Established&lt;/code&gt;：&lt;strong&gt;&lt;span&gt;所有对该卷组的写操作已经在线完成同步。这是drbd正常运行时的状态。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ahead&lt;/code&gt;：数据同步操作被挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要配置&quot;on-congestion&quot;选项来启用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Behind&lt;/code&gt;：对端将数据同步操作挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要在对端节点上配置&quot;on-congestion&quot;选项来启用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-roles-ro-&quot;&gt;2.2 角色状态(roles,ro)&lt;/h2&gt;
&lt;p&gt;资源的角色状态既可以从/proc/drbd文件中获取，也可以使用下面的命令来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
Primary/Unknown
Primary/Unknown
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在角色状态信息中，本地节点总是标记在第一位，远程节点标记在结尾。&lt;/p&gt;
&lt;p&gt;可能的节点角色状态有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Primary&lt;/code&gt;：资源的primary角色，该角色状态下的drbd设备可以进行挂载、读、写等。在没有启用多主复制模型(dual-primary mode)，只能有一个primary节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Secondary&lt;/code&gt;：资源的secondary角色。该角色状态下的drbd设备会接收来自primary端的数据更新(除非和对端不是primary)。且该角色的drbd设备不可挂载、不可读、不可写。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unknown&lt;/code&gt;：资源的角色未知。本地节点的角色状态绝对不可能会是这种状态。只有对端节点断开连接时对端节点才处于Unknown状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-disk-state-ds-&quot;&gt;2.3 磁盘状态(disk state,ds)&lt;/h2&gt;
&lt;p&gt;磁盘的状态既可以从/proc/drbd文件中获取，也可以使用下面的命令来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;# drbdadm dstate &lt;span class=&quot;hljs-title&quot;&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;&lt;/span&gt;
UpToDate/UpToDate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在磁盘状态信息中，本地节点的磁盘状态总是标记在第一位，远程节点标记在结尾。这两端节点的状态信息都可能为以下值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Diskless&lt;/code&gt;：没有为DRBD驱动分配底层块设备。这意味着资源可能从没有和它的底层块设备进行关联绑定(attach)，也可能是手动detach解除了关联，还可能是出现了底层IO错误时自动detach。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Attaching&lt;/code&gt;：读取元数据时的一个短暂的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failed&lt;/code&gt;：本地块设备故障时的一个短暂的状态，下一个状态是:Diskless。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Negotiating&lt;/code&gt;：在已连接的DRBD设备上还要进行Attach时的一个短暂的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inconsistent&lt;/code&gt;：数据不一致。在双方节点(还未进行全盘同步之前)刚创建新的资源时会立即进入此状态。在某一端(目标段)正接收同步数据时，也会进入不一致状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Outdated&lt;/code&gt;：资源的数据是一致的，但是数据过期了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DUnknown&lt;/code&gt;：用于标识对端节点没有连接时的磁盘状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Consistent&lt;/code&gt;：连接断开时的数据处于一致性状态，当连接建立后，将决定数据是UpToDate还是Outdated状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UpToDate&lt;/code&gt;：资源的数据是一致的，且数据是最新的。这是drbd数据正常时的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-io-&quot;&gt;2.4 IO状态标记&lt;/h2&gt;
&lt;p&gt;IO状态标记表示的是当前资源的IO操作状态。共有6种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IO挂起&lt;/code&gt;：r或s都可能表示IO挂起，一般是r。r=running，s=suspended。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;串行重新同步&lt;/code&gt;：资源正在等待进行重新同步，但被&lt;code&gt;resync-after&lt;/code&gt;选项延迟了同步进度。该状态标记为&quot;a&quot;，通常该状态栏应该处于&quot;-&quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;对端初始化同步挂起&lt;/code&gt;：资源正在等待进行重新同步，但对端节点因为某些原因而IO挂起。该状态标记为&quot;p&quot;，通常该状态栏应该处于&quot;-&quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;本地初始化同步挂起&lt;/code&gt;：资源正在等待进行重新同步，但本节点因为某些原因而IO挂起。该状态标记为&quot;u&quot;，通常该状态栏应该处于&quot;-&quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;本地IO阻塞&lt;/code&gt;：通常该状态栏应该处于&quot;-&quot;。可能有以下几种标记：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;d&lt;/code&gt;：因为DRBD内部原因导致的IO阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;：后端设备正处于IO阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;：网络套接字阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;：网络套接字和后端块设备同时处于阻塞状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Activity Log更新挂起&lt;/code&gt;：当al更新被挂起时，处于该状态，标记为&quot;s&quot;，通常该状态栏应该处于&quot;-&quot;。(如果不知道什么是Active Log，请无视本标记)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要是一些计数器和计量器的值。&lt;/p&gt;
&lt;p&gt;请结合drbd原理图进行理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180329153010222-1008430710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;drbd84中使用缩写符号来标记性能指标，而drbd9中使用全称来表示。例如drbd84中的ns和drbd9中的send是同一个意思。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ns/send (network send)&lt;/code&gt;：通过网络连接发送给对端的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nr/receive (network receive)&lt;/code&gt;：通过网络连接接收到对端发送来的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw/written (disk write)&lt;/code&gt;：该卷(volume)写入本地磁盘的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dr/read (disk read)&lt;/code&gt;：该卷(volume)从本地磁盘读取的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;al/al-writes (activity log)&lt;/code&gt;：元数据区中al更新的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bm/bm-writes (bit map)&lt;/code&gt;：元数据区中bitmap更新的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lo/lower-pending (local count)&lt;/code&gt;：DRBD发起的打开本地IO子系统的请求次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pe/pending (pending)&lt;/code&gt;：本地发送给对端但却没有回复的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ua/unacked (unacknowledged)&lt;/code&gt;：接收到对端发送的请求但却没有给予回复的请求数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ap/upper-pending (application pending)&lt;/code&gt;：转发给DRBD的IO块的请求，但DRBD还没给予回复的请求数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ep (epochs)&lt;/code&gt;:epoch对象的数量。通常为1。drbd9中没有该指标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wo/write-ordering (write order)&lt;/code&gt;:当前正在使用的write order方法：b(barrier), f(flush), d(drain)或n(none)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oos/out-of-sync (out of sync)&lt;/code&gt;:当前不同步的数据量，单位为Kb。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面所有&quot;未给予回复&quot;的指标数量都表示动作还未完成，需要回复后才表示操作完成。这些未回复数值不能太大。&lt;/p&gt;
&lt;p&gt;此外，drbd9中添加了以下几个指标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;resync-suspended&lt;/code&gt;：重新同步操作当前是否被挂起。可能的值为no/user/peer/dependency。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blocked&lt;/code&gt;：本地IO的拥挤情况。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no&lt;/code&gt;：本地IO不拥挤。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;upper&lt;/code&gt;：DRBD层之上的IO被阻塞。例如到文件系统上的IO阻塞。可能有以下几种原因：
&lt;ul&gt;&lt;li&gt;管理员使用&lt;code&gt;drbdadm suspend-io&lt;/code&gt;命令挂起了IO操作。&lt;/li&gt;
&lt;li&gt;短暂的IO阻塞，例如attach/detach导致的。&lt;/li&gt;
&lt;li&gt;删除了缓冲区。&lt;/li&gt;
&lt;li&gt;bitmap的IO等待。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lower&lt;/code&gt;：底层设备处于拥挤状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8684648.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 15:00:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8684648.html</dc:identifier>
</item>
<item>
<title>fcode-页面九宫格自动锁屏jquery插件 - 修德己</title>
<link>http://www.cnblogs.com/lovefc/p/fcode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovefc/p/fcode.html</guid>
<description>&lt;h3&gt;fcode.js 自动锁屏插件&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZQfs.png&quot; rel=&quot;data-fancybox-gallery&quot;&gt;&lt;img src=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZQfs.png&quot; alt=&quot;fcode-index&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZ3Ue.jpg&quot; rel=&quot;data-fancybox-gallery&quot;&gt;&lt;img src=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZ3Ue.jpg&quot; alt=&quot;fcode&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;fcode.js是什么？&lt;/h4&gt;
&lt;p&gt;fcode.js是一款web页面九宫格自动锁屏js插件，依赖于jquery，&lt;/p&gt;
&lt;p&gt;会在设置的范围里，判断用户有无操作，然后执行锁屏的功能。&lt;/p&gt;
&lt;p&gt;就一个js文件，配置简单，操作方便，可以锁住任何页面，还支持在手机端的锁屏。&lt;/p&gt;
&lt;p&gt;此外，还支持更新密码，或者用来登录，都有相关的说明，特别简单，相信您看一下，就会明白！&lt;/p&gt;
&lt;p&gt;演示地址：&lt;a href=&quot;http://fcphp.cn/fcode&quot;&gt;http://fcphp.cn/fcode&lt;/a&gt;   demo请在http方式下访问&lt;/p&gt;
&lt;p&gt;码云地址：&lt;a title=&quot;https://gitee.com/lovefc/fcode&quot; href=&quot;https://gitee.com/lovefc/fcode&quot; target=&quot;_blank&quot;&gt;https://gitee.com/lovefc/fcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GITHUB  : &lt;a title=&quot;https://github.com/lovefc/fcode&quot; href=&quot;https://github.com/lovefc/fcode&quot; target=&quot;_blank&quot;&gt;https://github.com/lovefc/fcode&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;如何使用fcode？&lt;/h4&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
  &amp;lt;script src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  
  &amp;lt;script src=&quot;js/fcode.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
         fcode.Start(123); 
  &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;因为是使用的九宫格，所以密码就是对应着数字123456789，最上面一排从左到右代表1，2，3，中间代表4，5，6，最后一排代表7，8，9 所以相应的密码也要如此设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;fcode的基本配置&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;fcode.js的基本配置非常简单，一看便知，便不多做介绍&lt;span class=&quot;hljs-tag&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;&lt;span class=&quot;hljs-value&quot;&gt;&lt;span class=&quot;http&quot;&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;        
       fcode.bgColor &lt;/span&gt;= '#FFF'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景颜色&lt;/span&gt;
&lt;span&gt;
        fcode.fontColor &lt;/span&gt;= '#666';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆环颜色&lt;/span&gt;
&lt;span&gt;
        fcode.lineColor &lt;/span&gt;= &quot;#333&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线的颜色&lt;/span&gt;
&lt;span&gt;
        fcode.lineErrorColor &lt;/span&gt;= &quot;#00a254&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线错误颜色&lt;/span&gt;
&lt;span&gt;
        fcode.lineSuceessColor &lt;/span&gt;= &quot;#cc1c21&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连续正确颜色&lt;/span&gt;
&lt;span&gt;
        fcode.Time &lt;/span&gt;= 10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;锁屏的时间,单位s&lt;/span&gt;
&lt;span&gt;
        fcode.bgImage &lt;/span&gt;= 'images/time.jpg'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置背景图片，优先于背景颜色&lt;/span&gt;
&lt;span&gt;
        fcode.customHtml &lt;/span&gt;= 'lovefc';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义九宫格解锁上方的html内容&lt;/span&gt;
&lt;span&gt;        
        fcode.Start(&lt;/span&gt;'123');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动运行&lt;/span&gt;
    &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里重点介绍一下fcode.Start这个函数的设置，这个函数是启动功能的，参数可以是密码，md5加密的密码，或者是一个api接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.普通密码形式。&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   fcode.Start('123');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种方式，就是代表第一排滑动解锁，简单方便，缺点是能看到源码（虽然我已经屏蔽了源码查看，f12，右键查看的功能）&lt;/p&gt;
&lt;p&gt;2.md5加密形式，其实就是把上面的123md5加密一下，是小写的md5 32位加密方式，可以随便找个工具加密一下就行了，比如用这个，&lt;a href=&quot;http://tool.chinaz.com/tools/md5.aspx&quot;&gt;http://tool.chinaz.com/tools/md5.aspx&lt;/a&gt; 这种方式安全多了，而且可以免去配置api接口，不需要额外的脚本就能运行&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   fcode.Start('202cb962ac59075b964b07152d234b70');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.第三种方式就是api接口形式的了，目前只提供了php的接口参考（本人做php的），地址一定要填写完整的接口地址，例如 &lt;a href=&quot;http://127.0.0.1/status.php&quot;&gt;http://127.0.0.1/status.php&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   fcode.Start('http://127.0.0.1/status.php');
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接口设计也是非常简单，没有什么复杂的地方，一看便知&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &amp;lt;?&lt;span&gt;php
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    * 用来验证锁屏密码 
    * author:lovefc
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
   &lt;span&gt;$pwd&lt;/span&gt; = &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['pwd']) ? &lt;span&gt;$_POST&lt;/span&gt;['pwd']:&lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取传过来的密码&lt;/span&gt;

   &lt;span&gt;$time&lt;/span&gt; = &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['time']) ? (int) &lt;span&gt;$_POST&lt;/span&gt;['time'] : 60;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取传过来的时间&lt;/span&gt;

  &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$pwd&lt;/span&gt;)){      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比对密码,看看是否相等&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$pwd&lt;/span&gt;==1235789){          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置cookies,加上时间&lt;/span&gt;
          &lt;span&gt;setcookie&lt;/span&gt;(&quot;fcode_status&quot;,'lovefc', &lt;span&gt;time&lt;/span&gt;()+&lt;span&gt;$time&lt;/span&gt;);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返会并输出ok&lt;/span&gt;
          &lt;span&gt;die&lt;/span&gt;('ok'&lt;span&gt;);
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4.兼容性说明,测试支持ie10,ie11，火狐,谷歌!&lt;/p&gt;

&lt;p&gt;ps：本人原创的一款jquery插件！&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 14:24:00 +0000</pubDate>
<dc:creator>修德己</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovefc/p/fcode.html</dc:identifier>
</item>
<item>
<title>KS检验统计量的扩展应用（CMap） - dedication</title>
<link>http://www.cnblogs.com/datamining-bio/p/8684420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datamining-bio/p/8684420.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;KS检验统计量的扩展应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　KS（Kolmogorov-Smirnov）检验是比较两个经验分布之间是否存在差异。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们设&lt;em&gt;X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;…, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,…, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;为两个独立随机样本，分别满足假设&lt;em&gt;A&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;和&lt;em&gt;A&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;，分布函数分别为&lt;em&gt;F&lt;/em&gt;, &lt;em&gt;G&lt;/em&gt;。现在我们想知道的是&lt;em&gt;X&lt;/em&gt;和&lt;em&gt;Y&lt;/em&gt;的概率分布之间是否存在差异，我们建立以下假设&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;H&lt;sub&gt;0&lt;/sub&gt;：&lt;em&gt;F(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;em&gt; &lt;/em&gt;=&lt;em&gt; G(t)&lt;/em&gt;,  for every &lt;em&gt;t&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;H&lt;sub&gt;1&lt;/sub&gt;：&lt;em&gt;F(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;em&gt; &lt;/em&gt;≠&lt;em&gt; G(t)&lt;/em&gt;,  for at least one &lt;em&gt;t&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们要计算&lt;strong&gt;双边双样本统计量&lt;em&gt;J&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先我们需要获得&lt;em&gt;X&lt;/em&gt;,&lt;em&gt;Y&lt;/em&gt;样本的经验分布函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于任意一个实数&lt;em&gt;t&lt;/em&gt;, 有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214307527-1487439135.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214347056-463719264.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;称&lt;em&gt;F&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;和&lt;em&gt;G&lt;/em&gt;&lt;em&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(t)&lt;/em&gt;分别为样本&lt;em&gt;X&lt;/em&gt;和&lt;em&gt;Y&lt;/em&gt;的经验分布函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;d = greatest common divisor of &lt;em&gt;m&lt;/em&gt; and &lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则统计量&lt;em&gt;J&lt;/em&gt;为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214416257-1771140976.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了对于给定的样本X和Y精确地计算统计量J，我们将&lt;em&gt;X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;…, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,…, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; 共N=(m+n)个样本观察值从小到大排序，得到Z&lt;sub&gt;(&lt;/sub&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;)&lt;/sub&gt; ≤ … ≤ Z&lt;sub&gt;(N)&lt;/sub&gt;，则统计量J的计算公式可以改写为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214447674-420288129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设显著性水平为α，则当J≥j&lt;sub&gt;α&lt;/sub&gt;时拒绝H&lt;sub&gt;0&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们举一个简单的例子，如下图1有两组数据，分别为有反馈和无反馈的观察值（不用弄清楚具体什么含义），两组样本量均为10.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214532346-2104917014.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有&lt;em&gt;m&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt; = 10,&lt;em&gt; N&lt;/em&gt; = (10 + 10) = 20，&lt;em&gt;d&lt;/em&gt; = 10，如下图2我们将这20个样本值排序，计算&lt;em&gt;F&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;, &lt;em&gt;G&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(t)&lt;/em&gt;，以及差异的绝对值|&lt;em&gt;F&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(i)&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;-&lt;em&gt;G&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(i)&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;|&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214547818-1917270776.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现样本差异最大的点在&lt;em&gt;Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;12&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;)&lt;/sub&gt;&lt;/em&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214640341-300224684.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;em&gt;Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;12&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;)&lt;/sub&gt;&lt;/em&gt;处，观测值为2.69，在有反馈的那组，小于等于2.69的有3个观察值，无反馈的那组小于等于2.69的有9个观察值，它们之间的差异为6/10。统计量&lt;em&gt;J&lt;/em&gt;=6.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们发现KS检验是计算两个样本之间每个观察值的排序差异，即为一种排序相似性，CMap（生物信息常用的一种数据库）基于KS检验这样的一种性质，设计了一种基于排序的模式匹配算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们通过一个例子说明这种匹配算法。现在我们有两种数据，一种是药物作用下基因的表达值，一种是疾病状态下基因的表达值，表达值都是一些实数，基因在疾病状态下，某些基因表达量增加，而某些基因可能减少表达。我们的目的是通过这两种数据来看这种药物对这种疾病有没有潜在的治疗可能，我们判断的依据：疾病状态下如果使某些基因（或某个基因）的表达值增加，即不在正常状态下，而这些基因在药物作用下，表达值在正常水平以下，即该药物会抑制这些基因的表达，那么我们可以推断，如果得这种疾病，这些基因表达值高于正常水平，我们再使用那些可以抑制这些基因表达的药物，可能就会使这些基因的表达量降下来，从而达到治病的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214719364-1054794144.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来计算药物A对疾病D是否有治疗作用。如图3所示，我们将药物A作用下的表达值从小到大排序，疾病D状态下的基因表达值从大到小排序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214750512-1335400033.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图4所示，我们接下来从疾病D的数据中选出前/后S个，然后再与药物A所有基因求交集，得到Num个共同基因（记该集合为B），我们再根据这些基因在药物A下的表达值从小到大排序。接下来，我们用基于ks统计量的方法，计算Num个共同基因在药物和疾病之间的排序相似性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214839006-1908739860.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　if  a &amp;gt; b   KS&lt;sub&gt;Top/Bottom&lt;/sub&gt; = a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　else       KS&lt;sub&gt;Top/Bottom&lt;/sub&gt; = -b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　if  KS&lt;sub&gt;Top&lt;/sub&gt; * KS&lt;sub&gt;Bottom&lt;/sub&gt; &amp;lt; 0,   score = KS&lt;sub&gt;Top&lt;/sub&gt; – KS&lt;sub&gt;Bottom&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　else  score = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中i表示集合B中的第i个基因，Num表示集合B中基因个数，i_position表示基因i在药物A数据中的排序，geneNum表示药物A的基因总数，即M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先来看看图5所示top的情况。如果想让a取值大，那么i_position就应该尽可能的小，也就是说，存在一个基因G，该基因在疾病数据中为top，同时在药物数据中也在top的位置，我们称这种模式为top-top模式。如果希望b值较大，则i_position应该尽可能的大，这就说明，存在一个基因G`，它在疾病数据中为top，但在药物数据中为bottom，称这种情况为bottom-top模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们看看图6的bottom情况。同样的，如果想让a取值较大，那么i_position就应该尽可能的小，也就是说，存在一个基因G，该基因在疾病数据中为bottom，但是在药物数据中处于top的位置，我们称这种模式为top-bottom模式。如果希望b值较大，则i_position应该尽可能的大，这就说明，存在一个基因G`，它在疾病数据中为bottom，同时在药物数据中也为bottom，称这种情况为bottom-bottom模式。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214928962-340823708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214945266-2003119409.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据上面解析，有四种模式，组合后也有四种模式，如下图7所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215010815-1199662299.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215031449-504801259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215044925-1392225108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215102891-1875919668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中第二和第三中模式匹配是没有意义的，比如第二种，top-bottom，bottom-bottom模式匹配，它说明有些基因在疾病状态下表达值增加，但是在药物作用下有些也会增加，有些减少，那么我们对该疾病作用该种药物，则会引起一些基因表达恢复正常，但是会使另一些基因表达量继续增加，可能会导致某些症状更严重。第一种匹配，top-top，bottom-bottom，则说明在疾病状态下表达值增加或减少的基因，在药物作用下刚好相反，那么这种药物就有治疗该疾病的潜在可能。第四种匹配：top-bottom，bottom-top，说明，在疾病状态下表达值增加或减少的基因，在该药物作用下也增加或减少，说明该药物的作用和疾病类似，即该药物绝对不能用于治疗该疾病。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们要选出第一和第四种匹配，这就要“-b”起作用了，第一种情况下，我们的KS&lt;sub&gt;Top&lt;/sub&gt; = a, KS&lt;sub&gt;Bottom&lt;/sub&gt; = -b，第四种情况刚好相反，它们刚好满足异号的条件，所以上面“-b”的作用是为了找出这两种匹配模式。那么我们如何知道药物A是可以治疗疾病D呢，还是加剧病情的呢？因为score=KS&lt;sub&gt;Top&lt;/sub&gt;-KS&lt;sub&gt;Bottom&lt;/sub&gt;，所以第一种情况，即治疗疾病，score是正数，而第四种情况，加剧病情，score为负数。并且score的绝对值越大，说明作用效果越明显（明显改善或明显加剧）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们再来看看计算b的公式，它将i减了1，即将集合B中的基因位置向前推了一位，这是为什么呢？我们看下图8的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215135026-1073998294.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当基因Q刚好在疾病中位于第N个，在药物数据中位于第M个，也就是说，该基因在疾病状态下被抑制，表达量非常少，而在药物作用下产生促进表达作用，表达量增加很多，很明显，该药物对该疾病的治疗效果应该很好，称为该疾病的特效药的可能性也很高，如果我们在计算b的时候，不减1，那么b=0，后面的异号条件也不满足，那么我们就漏掉了很好的这种情况，为了避免，就将集合B的基因位置向前推一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;M. Hollander, D. Wolfe, &lt;em&gt;Nonparametric Statistical Methods&lt;/em&gt; (Wiley, ed. 2,1999), pp. 178-185.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Lamb J, Crawford E D, Peck D, et al. The Connectivity Map: Using Gene-Expression Signatures to Connect Small Molecules, Genes, and Disease[J]. Science, 2006, 313(5795):1929-1935.&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 13:57:00 +0000</pubDate>
<dc:creator>dedication</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/datamining-bio/p/8684420.html</dc:identifier>
</item>
<item>
<title>ReentrantLock 与 AQS 源码分析 - lwen</title>
<link>http://www.cnblogs.com/lwen/p/8684307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwen/p/8684307.html</guid>
<description>&lt;h2 id=&quot;基本结构&quot;&gt;1. 基本结构&lt;/h2&gt;
&lt;p&gt;   重入锁 ReetrantLock，JDK 1.5新增的类，作用与synchronized关键字相当，但比synchronized更加灵活。ReetrantLock本身也是一种支持重进入的锁，即该锁可以支持一个线程对资源重复加锁，但是加锁多少次，就必须解锁多少次，这样才可以成功释放锁。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;1. 继承&lt;/h3&gt;
&lt;p&gt;没有继承任何类，因为很多操作都使用了组合完成。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;2. 实现&lt;/h3&gt;
&lt;p&gt;Lock, java.io.Serializable&lt;br/&gt;  这里着重介绍一下 Lock 接口，接口定义了几个必要的方法，也是在 ReentrantLock 中的重点需要分析的方法。&lt;br/&gt;   三类方法：获取锁、释放锁、获取条件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Lock {
    &lt;span class=&quot;co&quot;&gt;// 阻塞获取锁，如果获取不到锁就一直等待&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 可中断获取锁，在获取锁的过程可以被中断，但是 Synchronized 是不可以&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lockInterruptibly&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException;
    &lt;span class=&quot;co&quot;&gt;// 非阻塞获取锁，没有获取到锁立即返回&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 超时获取锁，没获取到锁等待一段时间&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException;
    &lt;span class=&quot;co&quot;&gt;// 解锁&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 等待唤醒机制的条件&lt;/span&gt;
    Condition &lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到 Synchronized 和 Lock 的一些重要区别：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Lock 的获取锁的过程是可以中断的，Synchronized 不可以，Synchronized 只能在 wait或同步代码块执行过程中才可以被中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于 Lock 显示的加锁，锁可以横跨几个方法，也就是临界区的位置可以更加自由。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Lock 支持超时获取锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后面会看到 Lock 还支持公平及非公平锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;绑定多个 Condition 条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;主要字段&quot;&gt;3. 主要字段&lt;/h3&gt;
&lt;p&gt;  很好，这个类的字段非常的少，真正起作用的字段只有一个 “锁” 字段。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 同步锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Sync sync;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   这个锁（Sync）是一个继承自 AQS 的抽象内部类，说明一下 AQS (AbstractQueuedSynchronizer) 一般被称为队列同步器，他是并发包中的核心组件，绝大多数锁机制都是采用的这个类来实现的。虽然看到他是一个抽象类，但是你会发现里面没有一个方法是抽象方法，他实现了锁机制中的必要的通用的方法，待会会专门讲这个类。不然 ReentrantLock 没办法说，ReentrantLock 里面的锁操作都是依赖于 AQS。&lt;/p&gt;
&lt;p&gt;   然后这个锁是有两个子类，分别是 &lt;code&gt;NonfairSync&lt;/code&gt; 和 &lt;code&gt;FairSync&lt;/code&gt; 从名字上也可以看出这两个类分别代表了 &lt;code&gt;公平锁&lt;/code&gt; 和 &lt;code&gt;非公平锁&lt;/code&gt; 。何为锁的公平性？ 实际上就是新来的线程需要征用锁必须要要等到先于他到达的线程获取并释放锁。也就是获取锁的过程是按照下来后到的顺序进行的，反之就称为非公平锁。后面我们会看到其实这两种锁不同就在于非公平锁在新线程创建后首先会直接进行锁的获取，如果没有获取到会进行一段时间的自旋，始终没获取到锁才进行等待状态。&lt;/p&gt;
&lt;p&gt;   一般而言，公平锁开销比非公平锁大，这也是比较符合我们的直观感受。公平锁是需要进行排队的，但在某些场景下，可能更注重时间先后顺序，那么公平锁自然是很好的选择。&lt;/p&gt;
&lt;p&gt;   好总结一下，在 ReentrantLock 中只维护了一个 “锁” 变量，这个锁是继承了 AQS 同步器，然后这个锁又有两种派生的锁：公平锁，非公平锁。那么 ReentrantLock 实现其实就有两种方式：公平锁，非公平锁。&lt;/p&gt;
&lt;h3 id=&quot;主要方法概览&quot;&gt;4. 主要方法概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;ctor-2&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;li&gt;lockInterruptibly&lt;/li&gt;
&lt;li&gt;tryLock&lt;/li&gt;
&lt;li&gt;tryLock(time)&lt;/li&gt;
&lt;li&gt;unlock&lt;/li&gt;
&lt;li&gt;newCondition&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;基础并发组件-aqs&quot;&gt;2. 基础并发组件 AQS&lt;/h2&gt;
&lt;h3 id=&quot;基本字段&quot;&gt;1. 基本字段&lt;/h3&gt;
&lt;h4 id=&quot;重要字段&quot;&gt;1. 重要字段&lt;/h4&gt;
&lt;p&gt;   AQS 是维护了一个同步队列（双向链表），这个队列里面线程都是需要竞争锁的，没有竞争到的就在同步队列中等待。&lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 就指向队列的首尾。&lt;code&gt;state&lt;/code&gt; 是一个标志字段，表示当前有多少线程在临界区。一般来说 &lt;code&gt;state&lt;/code&gt; 只能是 0 或 1 但是由于锁是可重入的，所以也有大于 1 的情况。&lt;/p&gt;
&lt;p&gt;   除了一个同步队列还有 0~n 个等待队列，等待队列就是调用了 &lt;code&gt;await&lt;/code&gt; 方法的线程，会被挂到调用了 &lt;code&gt;await&lt;/code&gt; 的 &lt;code&gt;condition&lt;/code&gt; 上面的等待队列，所以有多少个 &lt;code&gt;condition&lt;/code&gt; 就有多少等待队列。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;//同步队列头指针&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node head;
    &lt;span class=&quot;co&quot;&gt;// 同步队列尾指针&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node tail;
    &lt;span class=&quot;co&quot;&gt;// 状态标志，0 则没有线程在临界区，非零表示有 state 个线程在临界区（由于锁可重入）&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; state;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;node-节点&quot;&gt;2. Node 节点&lt;/h4&gt;
&lt;p&gt;  Node 节点也就是上文所提到的 &lt;code&gt;同步队列&lt;/code&gt; 和 &lt;code&gt;等待队列&lt;/code&gt; 中的元素，注意两个队列之间的元素类型是一样的因为他们之间会有相互移动转换的动作，这两个队列中的元素自然是线程，为了方便查找和表示 AQS 将线程封装到了 Node 节点中，构成双向队列。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Node {
        &lt;span class=&quot;co&quot;&gt;// 共享非 null/独占为 null  &lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node SHARED = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node();
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 线程状态&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CANCELLED =  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SIGNAL    = -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CONDITION = -&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PROPAGATE = -&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; waitStatus;
       &lt;span class=&quot;co&quot;&gt;// 双向链表  这两个指针用于同步队列构建链表使用的   下面还有一个 nextWaiter 是用来构建等待单链表队列&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node prev;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node next;
        &lt;span class=&quot;co&quot;&gt;// 线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Thread thread;
        &lt;span class=&quot;co&quot;&gt;// 等待队列单链表&lt;/span&gt;
        Node nextWaiter;

        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * Returns true if node is waiting in shared mode.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isShared&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; nextWaiter == SHARED;
        }

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   可以看到上面有一个 &lt;code&gt;waitStatus&lt;/code&gt; 属性，代表了线程当前的状态，状态标识就是那些常量。具体如下：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SIGNAL: 正在执行的线程结束释放锁或者被取消执行，他必须唤醒后续的状态为 SIGNAL 节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CANCELLED: 在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点， 其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CONDITION: 该标识的结点处于等待队列中（不是同步队列），结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PROPAGATE:在共享模式中，该状态标识结点的线程处于可运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;0:代表初始化状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;   可以看到，Node 里面的主要字段就是一个状态标志位、一个线程的引用、用于构建链表的指针。注意，有三个指针，其中前两个 &lt;code&gt;next&lt;/code&gt; 和 &lt;code&gt;pre&lt;/code&gt; 是用来构建同步队列的（双向链表），后面 &lt;code&gt;nextWaiter&lt;/code&gt; 是用来构建等待队列。所以说虽然同步队列和等待队列使用的同一个数据类型，数据结构是不同的，并且在后面我们会看到等待队列中的节点只有两种状态 &lt;code&gt;Condition&lt;/code&gt; 和 &lt;code&gt;CANCELLED&lt;/code&gt; 前者表示线程已结束需要从等待队列中移除，后者表示条件结点等待被唤醒。&lt;/p&gt;
&lt;p&gt;  下面画图说明一下同步队列和等待队列的情况。&lt;br/&gt;等待队列&lt;br/&gt;&lt;img src=&quot;http://ojrw3x8j2.bkt.clouddn.com/18-3-30/81487339.jpg&quot;/&gt;&lt;br/&gt;同步队列&lt;br/&gt;&lt;img src=&quot;http://ojrw3x8j2.bkt.clouddn.com/18-3-30/91260714.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;conditionobject&quot;&gt;3. ConditionObject&lt;/h4&gt;
&lt;p&gt;   这个内部类是等待唤醒机制的核心，在他上面绑定了一个等待队列。在这个类中使用了两个指针（ &lt;code&gt;firstWaiter/lastWaiter&lt;/code&gt; ）指向队列的首尾。这里主要看一下 &lt;code&gt;await&lt;/code&gt; 、&lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;signalAll&lt;/code&gt; 方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;await&lt;br/&gt;   当一个线程调用了await()相关的方法，那么首先构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，并释放锁直到被唤醒（移动到同步队列）、中断、超时才被队列中移出。被唤醒后的第一件事是抢锁和检查是否被中断，然后才是移除队列。被唤醒时候的状态应该为 SIGNAL ，而在方法中执行的移除队列的操作就是移除状态非 Condition 的节点。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException {
            &lt;span class=&quot;co&quot;&gt;// 等待可中断&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;interrupted&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InterruptedException();
            &lt;span class=&quot;co&quot;&gt;// 加入等待队列， new 新的 Node 做一个尾插入&lt;/span&gt;
            Node node = &lt;span class=&quot;fu&quot;&gt;addConditionWaiter&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 释放当前线程的锁，失败则将当前线程设置为取消状态&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; savedState = &lt;span class=&quot;fu&quot;&gt;fullyRelease&lt;/span&gt;(node);

            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; interruptMode = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 如果没在同步队列就让线程等待也就是看是否被唤醒&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 如果有中断或者被唤醒那么退出循环&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isOnSyncQueue&lt;/span&gt;(node)) {
                LockSupport.&lt;span class=&quot;fu&quot;&gt;park&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((interruptMode = &lt;span class=&quot;fu&quot;&gt;checkInterruptWhileWaiting&lt;/span&gt;(node)) != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;// 运行到此处说明已经被唤醒了，因为结束了循环&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 唤醒后，首先自旋一下获取锁，同时判断是否中断&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;acquireQueued&lt;/span&gt;(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            &lt;span class=&quot;co&quot;&gt;// 清理队列中状态不是 Condition 的的任务，包括被唤醒的 SIGNAL 和 被取消的 CANCELLED&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node.&lt;span class=&quot;fu&quot;&gt;nextWaiter&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;unlinkCancelledWaiters&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;//被中断 抛异常&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (interruptMode != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;reportInterruptAfterWait&lt;/span&gt;(interruptMode);
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;signal/doSignal/signalAll&lt;br/&gt;   执行 signal 首先进行锁的判断，如果没有获取到独占锁就直接抛出异常。这也就是为什么只有拥有锁的线程才能执行 signal ，然后获取等待队列中的第一个节点执行 doSignal。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;signal&lt;/span&gt;() {
            &lt;span class=&quot;co&quot;&gt;// 获取独占锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isHeldExclusively&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
            &lt;span class=&quot;co&quot;&gt;// 唤醒等待队里中的第一个线程&lt;/span&gt;
            Node first = firstWaiter;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;doSignal&lt;/span&gt;(first);
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   doSignal 方法主要就干了三个事 ：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将被唤醒的节点从等待队列中移除（while 循环体），如果被唤醒的节点被取消了就继续唤醒后面的节点（transferForSignal 返回 false）&lt;/li&gt;
&lt;li&gt;否则把这个节点加入到同步队列 （ enq 方法 ）&lt;/li&gt;
&lt;li&gt;当同步队列中当前节点的前驱被取消或者没办法唤醒时则唤醒这个线程 （ unpark ），这时候调用了 unpark 正好和 await 中的 park 相对应使得 await 的线程被唤醒，接着执行循环体判断自己已经被移入到同步队列了，接着就可以执行后面的获取锁的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doSignal&lt;/span&gt;(Node first) {
            &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 头指针指向唤醒节点的下一个节点，并顺便判断等待队列是否空&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( (firstWaiter = first.&lt;span class=&quot;fu&quot;&gt;nextWaiter&lt;/span&gt;) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    lastWaiter = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                &lt;span class=&quot;co&quot;&gt;// 解除引用&lt;/span&gt;
                first.&lt;span class=&quot;fu&quot;&gt;nextWaiter&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;transferForSignal&lt;/span&gt;(first) &amp;amp;&amp;amp; (first = firstWaiter) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//移入同步队列失败则继续唤醒下一个线程，否则唤醒成功&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 唤醒成功的线程不一定马上能开始执行，只有在前驱节点被取消或者没办法被唤醒时&lt;/span&gt;
   }
   
   
   &lt;span class=&quot;co&quot;&gt;//  将节点从等待队列移动到同步队列   成功返回 true 失败 false&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;transferForSignal&lt;/span&gt;(Node node) {
        &lt;span class=&quot;co&quot;&gt;// 在等待队列中的节点只有 condition 和 cancelled 两种状态，如果状态更新失败说明任务被取消&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 否则更新为初始状态   直接返回的话上面的 doSignal 就会继续唤醒后面的线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;compareAndSetWaitStatus&lt;/span&gt;(node, Node.&lt;span class=&quot;fu&quot;&gt;CONDITION&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 把当前节点加入同步队列&lt;/span&gt;
        Node p = &lt;span class=&quot;fu&quot;&gt;enq&lt;/span&gt;(node);
        &lt;span class=&quot;co&quot;&gt;// 获取同步队列中倒数第二个节点的状态，当前节点的前驱&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ws = p.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 如果前驱节点被取消或者在设置前驱节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ws &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || !&lt;span class=&quot;fu&quot;&gt;compareAndSetWaitStatus&lt;/span&gt;(p, ws, Node.&lt;span class=&quot;fu&quot;&gt;SIGNAL&lt;/span&gt;))
            LockSupport.&lt;span class=&quot;fu&quot;&gt;unpark&lt;/span&gt;(node.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
    
    
    &lt;span class=&quot;co&quot;&gt;// 插入一个节点到同步队列，如果同步队列是空的则加入一个空节点做为头结点&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 死循环保证肯定能插入    返回插入节点的前驱&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;enq&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node node) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
            Node t = tail;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) { &lt;span class=&quot;co&quot;&gt;// Must initialize&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetHead&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node()))
                    tail = head;
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 这一步不需要 cas 是因为并发没关系，只是指向链表结尾，不会多线程更新问题&lt;/span&gt;
                node.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = t;
                &lt;span class=&quot;co&quot;&gt;// 可能有多个线程抢&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetTail&lt;/span&gt;(t, node)) {
                    t.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = node;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; t;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   有一个小问题,就是在某个线程中执行了别人的 signal 不会导致当前线程立即放弃锁，之所以会这样正是由于 &lt;code&gt;ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)&lt;/code&gt; 这个判断，即前驱线程都结束了。比如下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package util.AQSTest;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.Condition;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.Lock;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.ReentrantLock;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// test signal 执行后不会导致当前线程立即释放锁&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AQSTest {
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Lock lock = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ReentrantLock();
   &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Condition run1Cond = lock.&lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Condition run2Cond = lock.&lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Runner1 &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
            lock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 1 start&quot;&lt;/span&gt;);
                run1Cond.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;);
                run2Cond.&lt;span class=&quot;fu&quot;&gt;signal&lt;/span&gt;();
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 1 exit&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                lock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
            }

        }
    }

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Runner2 &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
            lock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 2 start&quot;&lt;/span&gt;);
                run2Cond.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;();
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 2 exit&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }&lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                lock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
            }

        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Runner1&lt;/span&gt;(),&lt;span class=&quot;st&quot;&gt;&quot;runner1&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Runner2&lt;/span&gt;(),&lt;span class=&quot;st&quot;&gt;&quot;runner2&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的结果始终是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;runner 1 start
runner 2 start
runner 1 exit
runner 2 exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;   我使用了工具对上面的代码进行了调试，大致说一下流程，顺便用来捋一捋等待唤醒机制。&lt;/p&gt;
&lt;p&gt;   首先 runner1 启动，获取到锁，打印出 “runner1 start” ，然后调用了 await 方法，此时 runner1 线程就执行了 AQS 中的 ConditionObject 中的 await 方法，该方法首先 new 了一个新的节点，把 runner1 封装到这个节点里面。挂在了 run1Con 的等待队列上，然后执行了释放锁并判断中断。紧接着 runner1 线程执行循环体判断是否被唤醒也就是是否在同步队列，显然这时候不在，就直接调用了 park 方法，执行休眠 1 秒钟操作， park 方法是 native 方法由操作系统实现。在上面线程释放锁的时候执行的操作是 &lt;code&gt;fullyRelease&lt;/code&gt; 这个方法调用了 &lt;code&gt;release&lt;/code&gt; 方法，而 &lt;code&gt;release&lt;/code&gt; 方法中释放了锁之后，会检查同步队列中是否还有以前因为没抢到锁而等待的线程，如果有执行 &lt;code&gt;unparkSuccessor&lt;/code&gt; 也就是唤醒同步队列中的后继线程。那么此时 runner2 会被唤醒，唤醒后就去抢锁，获取到 lock 锁后输出了 “runner2 start” ，然后 runner2 线程又会因为调用 &lt;code&gt;await&lt;/code&gt; 处于和 runner1 同样的境地，也就是被放入 run2Con 的等待队列。好！此时 runner1 的超时时间到了，就会被 unpark 这个 unpark 是被操作系统调用的，之后继续执行循环体发现超时时间小于等于 0 ，则调用 &lt;code&gt;transferAfterCancelledWait&lt;/code&gt; 里面调用了 &lt;code&gt;enq&lt;/code&gt; 就是加入同步队列，接着开始竞争锁，开始执行 run2Con 上的 signal 此时 signal 调用 doSignal 先执行 do while 中的循环体，runner2 从 run2Con 的等待队列上移除，然后执行 &lt;code&gt;transferForSignal&lt;/code&gt; 里面又调用了 &lt;code&gt;enq&lt;/code&gt; 将他加入同步队列，并返回同步队列中的前驱，前驱节点状态不是 Cancelled 或者 可以被置为 SIGNAL 则 signal 方法结束。接着打印了 “runner1 exit” 。接着需要执行 finally 里面的释放锁的操作了，显然 unlock 肯定调用了 release ，而 release 会唤醒同步队列中的后继的线程，那么位于同步队列中的 runner2 之前的 park 状态就会被打断，从而跳出 while 循环，执行获取锁的操作。打印出 “runner2 exit” ，最后释放锁整个程序结束。&lt;/p&gt;
&lt;p&gt;   现在总算是吧 Condition 的等待唤醒机制弄清楚了。也把 AQS 中的两个内部类的功能都解释完了。接下来就看 AQS 中的方法。&lt;/p&gt;
&lt;h3 id=&quot;重要方法&quot;&gt;2. 重要方法&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;get/setState&lt;/li&gt;
&lt;li&gt;release/tryRelease/unparkSuccessor/fullyRelease&lt;/li&gt;
&lt;li&gt;acquire/tryAcquire/addWaiter/tryQueued&lt;/li&gt;
&lt;li&gt;acquireShared&lt;/li&gt;
&lt;li&gt;releaseShared&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;   这些属于 AQS 中常用的方法，但是里面的核心方法都是模板方法，也就是说由继承他的子类来实现，所以只能看个大概的逻辑。一会等到讲 ReentrantLock 时再详细说这里面的方法。&lt;/p&gt;
&lt;h2 id=&quot;reentrantlock-内部类-syncfairsyncnofairsync&quot;&gt;3. ReentrantLock 内部类 Sync/fairSync/noFairSync&lt;/h2&gt;
&lt;h3 id=&quot;sync&quot;&gt;1. Sync&lt;/h3&gt;
&lt;p&gt;   这三个内部类实际上是继承自 AQS ，也就是说 ReentrantLock 是采用了 AQS 作为自己的核心并发控制组件完成的一系列的锁操作，及等待唤醒机制。&lt;/p&gt;
&lt;p&gt;   首先看一下 Sync 他是后面两个的父类，他直接继承自 AQS 。AQS 中留了几个比较重要的模板方法 tryAcquire 、tryRelease 。这个方法直接实现了一些在公平锁和非公平锁中的通用操作，也就是释放锁的操作 tryRelease 。&lt;/p&gt;
&lt;p&gt;   tryRelease 的实现很简单，主要就是依赖于 AQS 中的 state 属性，如果state 值减去要释放的信号量为 0 则释放成功，否则失败。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;co&quot;&gt;// 释放锁的公共操作&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryRelease&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; releases) {
            &lt;span class=&quot;co&quot;&gt;// 释放锁首先就是使用 AQS 中的 state 的值减去信号量 判断是否为0&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 如果是 0 则表明成功释放锁，独占线程设为 null，否则说明还占用锁&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() - releases;
            &lt;span class=&quot;co&quot;&gt;// 必须获取到锁才能解锁，否则抛异常&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;() != &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; free = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                free = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            }
            &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(c);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; free;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;fairsync&quot;&gt;2. fairSync&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;emsp;&amp;amp;emsp;  公平锁执行 lock 操作就是执行了 AQS 中的 acquire(1) 也就是请求一个锁资源。但是注意，在 AQS 中的 acquire 中的 tryAcquire 方法没有实现，所以必须由当前类实现。

&amp;amp;emsp;&amp;amp;emsp;  在 tryAcquire 中做的事情就是看是否有代码在临界区。没有则还要看同步队列中是否有线程等待，当只有这一个线程在获取锁的时候才能正常的获取锁，其他情况都失败。&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 公平锁&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FairSync &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Sync {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;() {
            &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        }

        &lt;span class=&quot;co&quot;&gt;// 没有代码在临界区或者是当前线程的重入 则获取成功，否则失败&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread current = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 如果当前线程在获取锁的过程没有其他线程在临界区&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;// 如果同步队列中没有等待的线程，就设置 state ，并且当前线程设为独占线程&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;hasQueuedPredecessors&lt;/span&gt;() &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, acquires)) {
                    &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(current);
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                }
            }
            &lt;span class=&quot;co&quot;&gt;// 有程序在临界区，如果是当前线程可重入，加上请求的资源数&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (current == &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;()) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nextc = c + acquires;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);
                &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(nextc);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;// 竞争锁失败，因为他是公平的锁竞争&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;nofairsync&quot;&gt;3. noFairSync&lt;/h3&gt;
&lt;p&gt;同理，这个方法也需要实现 lock 和 tryAcquire 操作。在 lock 中直接判断是否有代码在临界区，没有则直接获取到锁，与公平锁不同的是：公平锁还判断了等待队列中是否有等待的线程。有在临界区的情况时执行 acquire 操作。同样的，首先要执行 tryAcquire 如果失败，加入同步队列并自旋获取锁。还是 tryAcquire 的实现，这里又调用了 nonfairTryAcquire。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 非公平锁&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; NonfairSync &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Sync {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;() {
            &lt;span class=&quot;co&quot;&gt;// 如果没有代码在临界区 直接获取锁，独占&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
                &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 有代码在临界区则执行尝试获取锁&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        }

        &lt;span class=&quot;co&quot;&gt;// 和公平锁中的 tryAcquire 一模一样只是少了关于同步队列中是否有等待线程的判断&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nonfairTryAcquire&lt;/span&gt;(acquires);
        }
    }
    
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nonfairTryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread current = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 没有线程获取锁 直接获取到锁  和公平锁中的 tryAcquire 一模一样只是少了关于同步队列的判断&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, acquires)) {
                    &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(current);
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                }
            }
            &lt;span class=&quot;co&quot;&gt;// 重入锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (current == &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;()) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nextc = c + acquires;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// overflow&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);
                &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(nextc);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   好了，现在我们 AQS 中的空的核心方法也被子类实现了，那么现在 fairSync 和 noFairSync 就算是一个完整的 AQS 了。此时看一下加解锁的流程。&lt;/p&gt;
&lt;p&gt;只说公平锁，因为非公平锁就只是少了一个判断。&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先 sync 调用 lock 方法，让后 lock 调用了 AQS 的 acquire(1) 也就是获取一个锁资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;acquire 就先调用 tryAcquire(1) 尝试获取锁，这时候代码又回调到 sync 中的实现的 tryAcquire 方法，这个方法先判断锁是否已经被别的线程使用，然后需要确定没有更早的线程在同步队列等待获取锁，才把当前线程设置为独占线程，并设置 state 值获取锁。但是如果有代码在临界区需要判断是否为当前线程，因为锁是可重入的。如果是当前线程则 state 加上请求锁的个数，返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这时候又回到 AQS 中，如果上面尝试获取锁的过程失败，就需要调用 addWaiter 将当前线程封装成一个独占节点，等待状态默认为 0，并且返回当前节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;加入同步队列后，再调用 acquireQueued 方法，当此线程是同步队列中等待的第一个线程则自旋尝试获取锁，毕竟很可能正在执行的线程马上就会释放锁了，再进行休眠不合适。如果自旋获取锁失败则判断节点状态是否为 SIGNAL 然后执行等待操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;锁获取成功则把当前节点设置为头结点，把 thread = null&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至此，Acquire 方法执行结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后调用 unlock 方法解锁操作。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解锁操作就没那么麻烦，首先还是调用到了 AQS 中的 release 方法，这个方法首先尝试解锁当前线程，又回调到了 sync 中的 tryRelease 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;tryRelease 逻辑比较简单，使用 AQS 中的 state 减去释放的资源数，等于 0 代表完全释放，否则释放失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果 tryRelease 成功执行就要去唤醒同步队列中的后继节点，继续执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至此，release 方法执行完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;aqs-中的要方法&quot;&gt;4. AQS 中的要方法&lt;/h2&gt;
&lt;h3 id=&quot;getsetstate&quot;&gt;1. get/setState&lt;/h3&gt;
&lt;p&gt;  这两个方法主要是对 state 变量的 volatile 的读写，其实里面就就是普通的 get/set 方法。但是注意的一点就是 state 是 volatile 的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 对状态变量的 volatile 读写&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; state;
    }
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newState) {
        state = newState;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;releasetryreleaseunparksuccessorfullyrelease&quot;&gt;2. release/tryRelease/unparkSuccessor/fullyRelease&lt;/h3&gt;
&lt;p&gt;   这几个方法在一起说主要是因为他们之间存在调用链，首先来看 release 这个方法我们在上面也分析了，里面调用了 tryRelease 、unparkSuccessor。 也就是首先调用 tryRelease 来释放当前线程的锁，如果释放成功就调用 unparkSuccessor 来唤醒同步队列中后继节点。其中 tryRelease 是由子类来实现，里面的主要逻辑就是看当前的 state 变量的值在修改过后是否为0 。这里还有一个 fullRelease 主要是在 ConditionObject 中调用的，当执行 await 的操作的时会执行此方法释放锁。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; &lt;span class=&quot;co&quot;&gt;//  尝试释放锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg) {
        &lt;span class=&quot;co&quot;&gt;// 如果释放锁成功 唤醒同步队列中的后继节点&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;tryRelease&lt;/span&gt;(arg)) {
            Node h = head;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (h != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;unparkSuccessor&lt;/span&gt;(h);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }
    
    &lt;span class=&quot;co&quot;&gt;// 唤醒同步队列中的后继节点&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unparkSuccessor&lt;/span&gt;(Node node) {
        &lt;span class=&quot;co&quot;&gt;// node 一般就是当前正在运行的线程&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ws = node.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 当前线程置为初始状态   可以失败&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;fu&quot;&gt;compareAndSetWaitStatus&lt;/span&gt;(node, ws, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 找到同步队列中的下一个节点&lt;/span&gt;
        Node s = node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || s.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {  &lt;span class=&quot;co&quot;&gt;//没有下一个节点或者被取消&lt;/span&gt;
            s = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 从后往前找第一个没有被取消的线程&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt;)
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                    s = t;
        }
        &lt;span class=&quot;co&quot;&gt;// 唤醒那个线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            LockSupport.&lt;span class=&quot;fu&quot;&gt;unpark&lt;/span&gt;(s.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt;);
    }
    
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fullyRelease&lt;/span&gt;(Node node) {
        &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; failed = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; savedState = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(savedState)) {
                failed = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; savedState;
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
            }
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (failed)
                node.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; = Node.&lt;span class=&quot;fu&quot;&gt;CANCELLED&lt;/span&gt;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;acquiretryacquireaddwaiteracquirequeued&quot;&gt;3. acquire/tryAcquire/addWaiter/acquireQueued&lt;/h3&gt;
&lt;p&gt;这个和上面的一样，在执行了 acquire 后，会去调用子类复写的 tryAcquire 方法，这个方法就是看有否有代码块在临界区，没有的话直接获取锁（非公平锁），设置 state，有的话要判断是不是当前线程能否进行重入操作，否则就获取失败。失败后会调用 addWaiter ，new 一个新的节点加入到同步队列，接着调用了 acquireQueued 如果这个节点是同步队列中的第一个等待的线程（但不是第一个节点，因为第一个节点是 thread=null 的运行中的线程）就自旋一段时间看能否获取到锁。不能则 park 等待。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 获取锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg) {
        &lt;span class=&quot;co&quot;&gt;// 尝试获取锁 失败则加入同步队列 如果是同步队列中的第一个线程就自旋获取锁&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 上面的步骤的自旋获取锁阶段，返回的是是否需要中断，所以下面就进行 selfInterrupt&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// tryAcquire 是模板方法，因为对于公平锁和非公平锁获取锁方式不同&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(arg) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;acquireQueued&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;addWaiter&lt;/span&gt;(Node.&lt;span class=&quot;fu&quot;&gt;EXCLUSIVE&lt;/span&gt;), arg))
            &lt;span class=&quot;fu&quot;&gt;selfInterrupt&lt;/span&gt;();
    }
    
    
    &lt;span class=&quot;co&quot;&gt;// 创建一个节点放入到同步对列中   可传入是否为独占锁   返回当前节点&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;addWaiter&lt;/span&gt;(Node mode) {
        &lt;span class=&quot;co&quot;&gt;// 默认的 status 是 0&lt;/span&gt;
        Node node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;(), mode);
        &lt;span class=&quot;co&quot;&gt;// Try the fast path of enq; backup to full enq on failure&lt;/span&gt;
        Node pred = tail;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pred != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            node.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = pred;
            &lt;span class=&quot;co&quot;&gt;// 把 tail 设置为 node 成功说明没有竞争&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetTail&lt;/span&gt;(pred, node)) {
                pred.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = node;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; node;
            }
        }
        &lt;span class=&quot;co&quot;&gt;// 失败则就说明空队列   创建头结点&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;enq&lt;/span&gt;(node);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; node;
    }
    
     &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;acquireQueued&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node node, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg) {
        &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; failed = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; interrupted = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 自旋获取锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
                &lt;span class=&quot;co&quot;&gt;// 获取前驱节点&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node p = node.&lt;span class=&quot;fu&quot;&gt;predecessor&lt;/span&gt;();
                &lt;span class=&quot;co&quot;&gt;// 如果前驱是空的头结点，那么也就是说当前线程就是队列中的第一个线程 并尝试获取锁  成功的话方法返回中断情况&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(arg)) {
                    &lt;span class=&quot;co&quot;&gt;// 把当前节点设置为头结点  thread=null 也就可以看做当前线程在运行，所以就不在同步队列&lt;/span&gt;
                    &lt;span class=&quot;fu&quot;&gt;setHead&lt;/span&gt;(node);
                    &lt;span class=&quot;co&quot;&gt;// gc&lt;/span&gt;
                    p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// help GC&lt;/span&gt;
                    failed = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; interrupted;
                }
                &lt;span class=&quot;co&quot;&gt;// 如果获取锁失败，检测为 SIGNAL 或者设置为 SIGNAL 然后让此线程等待 等待操作在 parkAndCheckInterrupt 中完成&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;shouldParkAfterFailedAcquire&lt;/span&gt;(p, node) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;parkAndCheckInterrupt&lt;/span&gt;())
                    interrupted = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 失败 取消&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (failed)
                &lt;span class=&quot;fu&quot;&gt;cancelAcquire&lt;/span&gt;(node);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;   其实到这里 ReentrantLock 已经讲完了，因为他底层全部调用的是 Sync 中的方法，也就是全都是调用了 AQS 中的方法。而 AQS 中的大部分重要的方法都已经看过了。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 13:29:00 +0000</pubDate>
<dc:creator>lwen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwen/p/8684307.html</dc:identifier>
</item>
<item>
<title>New UWP Community Toolkit - Carousel - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/8678625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/8678625.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;New UWP Community Toolkit  V2.2.0 的版本发布日志中提到了 Carousel 的调整，本篇我们结合代码详细讲解  Carousel 的实现。&lt;/p&gt;
&lt;p&gt;Carousel 是一种传送带形态的控件，在图片展示类的应用中有非常多的应用，它拥有很好的流畅度，可以做很多的自定义，并集成了鼠标，触摸板，键盘等的操作。我们来看一下官方的介绍和官网示例中的展示：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;The &lt;code&gt;Carousel&lt;/code&gt; control provides a new control, inherited from the &lt;code&gt;ItemsControl&lt;/code&gt;, representing a nice and smooth carousel.&lt;br/&gt;This control lets you specify a lot of properties for a flexible layouting.&lt;br/&gt;The &lt;code&gt;Carousel&lt;/code&gt; control works fine with mouse, touch, mouse and keyboard as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331151522768-562134355.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/Microsoft/UWPCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/Carousel&quot; target=&quot;_blank&quot;&gt;https://github.com/Microsoft/UWPCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/Carousel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Doc: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/uwpcommunitytoolkit/controls/carousel&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/windows/uwpcommunitytoolkit/controls/carousel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Namespace: &lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/em&gt;; Nuget: &lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先来看看 Carousel 的类结构组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Carousel.cs - Carousel 控件类，继承自 ItemsControl&lt;/li&gt;
&lt;li&gt;Carousel.xaml - Carousel 的样式文件，包含了 Carousel，CarouselItem，CarouselPanel 的样式&lt;/li&gt;
&lt;li&gt;CarouselItem.cs - CarouselItem 是 Carousel 控件的列表中的选择器 ItemTemplate&lt;/li&gt;
&lt;li&gt;CarouselPanel.cs - CarouselPanel 是 Carousel 控件的 ItemPanelTemplate&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331153359461-1864216607.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来看一下几个主要类中的主要代码实现，因为篇幅关系，我们只摘录部分关键代码实现：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Carousel.cs &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在具体分析代码前，我们先看看 Carousel 类的组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331162516738-433380038.jpg&quot; alt=&quot;&quot; width=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，作为一个集合类控件，Carousel 也注册了 SelectedItem 和 SelectedIndex 依赖属性，并且因为控件可以控制元素的深度，旋转角度，动画时长和类型，列表方向等，注册了 TransitionDuration，ItemDepth，EasingFunction，ItemMargin，ItemRotationX，Orientation 等依赖属性。而部分依赖属性的 PropertyChanged 事件由 OnCarouselPropertyChanged(d, e) 来实现；&lt;/p&gt;
&lt;p&gt;下面来看一下 Carousel 类的构造方法：&lt;/p&gt;
&lt;p&gt;构造方法中，首先设置了样式，Tab 导航模式；定义了鼠标滚轮，鼠标点击和键盘事件，并注册了数据源变化事件来得到正确的 SelectedItem 和 SelectedIndex。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Carousel()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set style&lt;/span&gt;
    DefaultStyleKey = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Carousel);
    SetValue(AutomationProperties.NameProperty, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Carousel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    IsHitTestVisible &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    IsTabStop &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    TabNavigation &lt;/span&gt;=&lt;span&gt; KeyboardNavigationMode.Once;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Events registered&lt;/span&gt;
    PointerWheelChanged +=&lt;span&gt; OnPointerWheelChanged;
    PointerReleased &lt;/span&gt;+=&lt;span&gt; CarouselControl_PointerReleased;
    KeyDown &lt;/span&gt;+=&lt;span&gt; Keyboard_KeyUp;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register ItemSource changed to get correct SelectedItem and SelectedIndex&lt;/span&gt;
    RegisterPropertyChangedCallback(ItemsSourceProperty, (d, dp) =&amp;gt;&lt;span&gt; { ... });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在键盘按键抬起的事件处理中，分别对应 Down，Up，Right 和 Left 做了处理，我们只截取了 Down 的处理过程；可以看到，如果列表方向为纵向，则 Down 按键会触发 SelectedIndex++，也就是当前选择项下移一位；对应其他三个按键也是类似的操作；OnPointerWheelChanged 的实现方式类似，这里不赘述；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Keyboard_KeyUp(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, KeyRoutedEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e.Key)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Windows.System.VirtualKey.Down:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Windows.System.VirtualKey.GamepadDPadDown:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Windows.System.VirtualKey.GamepadLeftThumbstickDown:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Orientation ==&lt;span&gt; Orientation.Vertical)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SelectedIndex &amp;lt; Items.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    SelectedIndex&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e.OriginalKey !=&lt;span&gt; Windows.System.VirtualKey.Down)
                {
                    FocusManager.TryMoveFocus(FocusNavigationDirection.Down);
                }

                e.Handled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看一下 PrepareContainerForItemOverride(element, item) 方法，它为 Item 设置了初始的 3D 旋转的中心点，Item 变换的中心点；并根据当前选择项确定 Item 是否被选中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrepareContainerForItemOverride(DependencyObject element, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; item)
{
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.PrepareContainerForItemOverride(element, item);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; carouselItem =&lt;span&gt; (CarouselItem)element;
    carouselItem.Selected &lt;/span&gt;+=&lt;span&gt; OnCarouselItemSelected;

    carouselItem.RenderTransformOrigin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);

    carouselItem.IsTabStop &lt;/span&gt;= Items.IndexOf(item) ==&lt;span&gt; SelectedIndex;
    carouselItem.UseSystemFocusVisuals &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    PlaneProjection planeProjection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlaneProjection();
    planeProjection.CenterOfRotationX &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    planeProjection.CenterOfRotationY &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    planeProjection.CenterOfRotationZ &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; compositeTransform = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeTransform();
    compositeTransform.CenterX &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    compositeTransform.CenterY &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    compositeTransform.CenterZ &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;

    carouselItem.Projection &lt;/span&gt;=&lt;span&gt; planeProjection;
    carouselItem.RenderTransform &lt;/span&gt;=&lt;span&gt; compositeTransform;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item ==&lt;span&gt; SelectedItem)
    {
        carouselItem.IsSelected &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. Carousel.xaml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如上面类结构介绍时所说，Carousel.xaml 是 Carousel 控件的样式文件；下面代码中我把非关键部分用 ‘...’ 代替了，可以看到，主要是两个部分的样式：CarouselItem 和 Carousel，CarouselPanel 作为 Carousel 的 ItemsPanelTemplate；Carousel 控件的 easing mode 是 'EaseOut'。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ResourceDictionary &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
                    xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
                    xmlns:local&lt;/span&gt;&lt;span&gt;=&quot;using:Microsoft.Toolkit.Uwp.UI.Controls&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:CarouselItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:CarouselItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderThickness}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Background}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            ...
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContentPresenter &lt;/span&gt;&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:Carousel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ItemsPanel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;local:CarouselPanel &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;EasingFunction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ExponentialEase &lt;/span&gt;&lt;span&gt;EasingMode&lt;/span&gt;&lt;span&gt;=&quot;EaseOut&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:Carousel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt; &lt;br/&gt;...&lt;/span&gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ResourceDictionary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. CarouselItem.cs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在前面 Carousel.xaml 中我们看到了 CarouselItem 的样式，有针对 VisualStateManager 的样式状态，而 CarouselItem 类则定义了这些状态变化事件对应的处理方法。分别有 OnIsSelectedChanged，OnPointerEntered，OnPointerExited 和 OnPointerPressed，在触发这些状态时，CarouselItem 会对应切换到那个状态时的样式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CarouselItem()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set style&lt;/span&gt;
    DefaultStyleKey = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(CarouselItem);
    RegisterPropertyChangedCallback(SelectorItem.IsSelectedProperty, OnIsSelectedChanged);
}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerEntered(PointerRoutedEventArgs e) {...}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerExited(PointerRoutedEventArgs e) {...}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerPressed(PointerRoutedEventArgs e) {...}

&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Selected;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnIsSelectedChanged(DependencyObject sender, DependencyProperty dp)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; (CarouselItem)sender;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (item.IsSelected)
    {
        Selected&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, EventArgs.Empty);
        VisualStateManager.GoToState(item, SelectedState, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        VisualStateManager.GoToState(item, NormalState, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. CarouselPanel.cs &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样在具体分析代码前，我们先看看 CarouselPanel 类的组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331165019279-668884720.jpg&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt; &lt;/p&gt;
&lt;p&gt;CarouselPanel 类继承自 Panel 类，可以看到它接收的事件响应，有 OnTapped，OnManipulationDelta 和 OnManipulationCompleted，分别对应点按，触摸移动和移动结束的处理。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OnTapped 的处理主要是根据当前控件的可视化范围和尺寸，判断点击的点对应哪个元素被选中；&lt;/li&gt;
&lt;li&gt;OnManipulationDelta 则是根据触控操作的方向和量度等，决定 Item 的动画幅度，动画速度和每个元素变换状态，以及选中元素的变化；&lt;/li&gt;
&lt;li&gt;OnManipulationCompleted 则是在触控结束后，确定结束动画，以及结束时应该选中那个元素；&lt;/li&gt;
&lt;li&gt;UpdatePosition() 方法则是在 OnManipulationDelta 方法触发到 first 或 last 元素时，需要重新设置动画；&lt;/li&gt;
&lt;li&gt;GetProjectionFromManipulation(sender, e) 则是在 OnManipulationDelta 方法中，根据当前触控的手势，决定当前 Item 的 Projection；&lt;/li&gt;
&lt;li&gt;GetProjectionFromSelectedIndex(i) 是根据当前选中的索引，来取得 Item 的 Projection；&lt;/li&gt;
&lt;li&gt;ApplyProjection(element, proj, storyboard) 是应用获取到的 Projection，包括旋转，变换等动画；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而因为 CarouselPanel 类继承自 Panel 类，所以它也重写了 MeasureOverride(availableSize) 和 ArrangeOverride(finalSize) 方法：&lt;/p&gt;
&lt;p&gt;MeasureOverride(availableSize) 方法的实现中，主要是根据宽度和高度是否设置为无限值，如果是，且方向和元素排列顺序一致，则尺寸为当前方向三个元素的宽度，然后把计算后的尺寸传出去；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Size MeasureOverride(Size availableSize)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; containerWidth =&lt;span&gt; 0d;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; containerHeight =&lt;span&gt; 0d;

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (FrameworkElement container &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Children)
    {
        container.Measure(availableSize);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get containerWidth and containerHeight for max&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width =&lt;span&gt; 0d;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; height =&lt;span&gt; 0d;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's a Auto size, so we define the size should be 3 items&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsInfinity(availableSize.Width))
    {
        width &lt;/span&gt;= Carousel.Orientation == Orientation.Horizontal ? containerWidth * (Children.Count &amp;gt; &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;3&lt;/span&gt;&lt;span&gt; : Children.Count) : containerWidth;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        width &lt;/span&gt;=&lt;span&gt; availableSize.Width;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's a Auto size, so we define the size should be 3 items&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsInfinity(availableSize.Height))
    {
        height &lt;/span&gt;= Carousel.Orientation == Orientation.Vertical ? containerHeight * (Children.Count &amp;gt; &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;3&lt;/span&gt;&lt;span&gt; : Children.Count) : containerHeight;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        height &lt;/span&gt;=&lt;span&gt; availableSize.Height;
    }

    Clip &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RectangleGeometry { Rect = &lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, width, height) };

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(width, height);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrangeOverride(finalSize) 方法则是排列元素的处理，因为 Carousel 控件有动画处理，所以在排列时需要考虑到元素排列的动画，以及 Zindex；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Size ArrangeOverride(Size finalSize)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; centerLeft = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; centerTop = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    Clip &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RectangleGeometry { Rect = &lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, finalSize.Width, finalSize.Height) };

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Children.Count; i++&lt;span&gt;)
    {
        FrameworkElement container &lt;/span&gt;= Children[i] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; FrameworkElement;
        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get the good center and top position
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get rect position
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Placing the rect in the center of screen&lt;/span&gt;
&lt;span&gt;        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the initial projection (without move)&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; proj =&lt;span&gt; GetProjectionFromSelectedIndex(i);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; apply the projection to the current object&lt;/span&gt;
&lt;span&gt;        ApplyProjection(container, proj);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; calculate zindex and opacity&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; zindex = (Children.Count * &lt;span&gt;100&lt;/span&gt;) -&lt;span&gt; deltaFromSelectedIndex;
        Canvas.SetZIndex(container, zindex);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; finalSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;调用示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例中我们实现了横向的 Carousel 控件，作为一个图片列表，可以看到当前选中的 Item 的 ZIndex 是最高的，向两侧依次降低，而在滑动过程中，伴随着 3D 和变换的动画，ZIndex 也会一起变化，而滑动结束时，选中项重新计算，每一项的 Project 也会重新计算。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;    &amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:Carousel &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;CarouselControl&quot;&lt;/span&gt;&lt;span&gt;
            InvertPositive&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;
            ItemDepth&lt;/span&gt;&lt;span&gt;=&quot;238&quot;&lt;/span&gt;&lt;span&gt;
            ItemMargin&lt;/span&gt;&lt;span&gt;=&quot;-79&quot;&lt;/span&gt;&lt;span&gt;
            ItemRotationX&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;
            ItemRotationY&lt;/span&gt;&lt;span&gt;=&quot;9&quot;&lt;/span&gt;&lt;span&gt;
            ItemRotationZ &lt;/span&gt;&lt;span&gt;=&quot;-3&quot;&lt;/span&gt;&lt;span&gt;
            Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;
            SelectedIndex&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:Carousel.EasingFunction&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CubicEase &lt;/span&gt;&lt;span&gt;EasingMode&lt;/span&gt;&lt;span&gt;=&quot;EaseOut&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:Carousel.EasingFunction&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:Carousel.ItemTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
                        Height&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
                        VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Bottom&quot;&lt;/span&gt;&lt;span&gt;
                        Source&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Thumbnail}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                        Stretch&lt;/span&gt;&lt;span&gt;=&quot;Uniform&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:Carousel.ItemTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:Carousel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331172015205-1667140444.jpg&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331172023042-2126072544.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里我们就把 UWP Community Toolkit 中的 Carousel 控件的源代码实现过程和简单的调用示例讲解完成了，希望能对大家更好的理解和使用这个控件有所帮助，让你的图片列表控件更加炫酷灵动。欢迎大家多多交流，谢谢！&lt;/p&gt;
&lt;p&gt;最后，再跟大家安利一下 UWPCommunityToolkit 的官方微博：&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://weibo.com/u/6506046490&quot; target=&quot;_blank&quot;&gt;https://weibo.com/u/6506046490&lt;/a&gt;, &lt;/strong&gt;&lt;/em&gt;大家可以通过微博关注最新动态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衷心感谢 UWPCommunityToolkit 的作者们杰出的工作，Thank you so much, UWPCommunityToolkit authors!!!&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 13:23:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/8678625.html</dc:identifier>
</item>
</channel>
</rss>