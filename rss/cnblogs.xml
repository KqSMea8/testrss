<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>springboot+mybatis实现动态切换数据源 - 撸码识途</title>
<link>http://www.cnblogs.com/tinyj/p/9864128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyj/p/9864128.html</guid>
<description>&lt;p&gt;前几天有个需求，需要使用不同的数据源，例如某业务要用A数据源，另一个业务要用B数据源。我上网收集了一些资料整合了一下，虽然最后这个需求不了了之了，但是多数据源动态切换还是蛮好用的，所以记录一下，或许以后有用呢？或者自己感兴趣又想玩呢！&lt;/p&gt;
&lt;p&gt;1.加个依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;&lt;br/&gt;　　　　　　　&amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.application.properties配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#主从数据库
master.db.driverClassName&lt;/span&gt;=&lt;span&gt;com.mysql.jdbc.Driver
master.db.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/cbd?characterEncoding=UTF-8&amp;amp;useUnicode=true&amp;amp;useSSL=false&lt;/span&gt;
master.db.username=&lt;span&gt;root
master.db.password&lt;/span&gt;=&lt;span&gt;admin
slave.db.driverClassName&lt;/span&gt;=&lt;span&gt;com.mysql.jdbc.Driver
slave.db.url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/cbd_test?characterEncoding=UTF-8&amp;amp;useUnicode=true&amp;amp;useSSL=false&lt;/span&gt;
slave.db.username=&lt;span&gt;root
slave.db.password&lt;/span&gt;=&lt;span&gt;admin

mybatis.config&lt;/span&gt;-location= classpath:config/mybatis-&lt;span&gt;config.xml
mybatis.mapper&lt;/span&gt;-locations=classpath:mapper&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;/*.xml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.禁用springboot默认加载数据源配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SpringApplication.run(Application.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.数据源配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 主数据源
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@ConfigurationProperties(prefix &lt;/span&gt;= &quot;master.db&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MasterDataSourceConfig {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String url;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String driverClassName;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 从数据源配置
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@ConfigurationProperties(prefix &lt;/span&gt;= &quot;slave.db&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SlaveDataSourceConfig {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String url;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String driverClassName;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 数据源配置类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSourceComponent {

    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MasterDataSourceConfig masterDataSourceConfig;

    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SlaveDataSourceConfig slaveDataSourceConfig;

&lt;/span&gt;&lt;span&gt;
     @Bean(name &lt;/span&gt;= &quot;master&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource masterDataSource() {
        DataSource dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSource();
        dataSource.setUrl(masterDataSourceConfig.getUrl());
        dataSource.setUsername(masterDataSourceConfig.getUsername());
        dataSource.setPassword(masterDataSourceConfig.getPassword());
        dataSource.setDriverClassName(masterDataSourceConfig.getDriverClassName());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource;
    }
&lt;/span&gt;&lt;span&gt;
    @Bean(name &lt;/span&gt;= &quot;slave&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource slaveDataSource() {
        DataSource dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSource();
        dataSource.setUrl(slaveDataSourceConfig.getUrl());
        dataSource.setUsername(slaveDataSourceConfig.getUsername());
        dataSource.setPassword(slaveDataSourceConfig.getPassword());
        dataSource.setDriverClassName(slaveDataSourceConfig.getDriverClassName());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource;
    }

    @Primary//不加这个会报错。
    @Bean(name &lt;/span&gt;= &quot;multiDataSource&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MultiRouteDataSource exampleRouteDataSource() {
        MultiRouteDataSource multiDataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MultiRouteDataSource();
        Map&lt;/span&gt;&amp;lt;Object, Object&amp;gt; targetDataSources = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        targetDataSources.put(&lt;/span&gt;&quot;master&quot;&lt;span&gt;, masterDataSource());
        targetDataSources.put(&lt;/span&gt;&quot;slave&quot;&lt;span&gt;, slaveDataSource());
        multiDataSource.setTargetDataSources(targetDataSources);
        multiDataSource.setDefaultTargetDataSource(masterDataSource());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; multiDataSource;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.数据源上下文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 数据源上下文
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSourceContext {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; contextHolder = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDataSource(String value) {
        contextHolder.set(value);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getDataSource() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contextHolder.get();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clearDataSource() {
        contextHolder.remove();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.DataSource路由类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
*    重写的函数决定了最后选择的DataSource
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MultiRouteDataSource &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractRoutingDataSource {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object determineCurrentLookupKey() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过绑定线程的数据源上下文实现多数据源的动态切换,有兴趣的可以去查阅资料或源码&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; DataSourceContext.getDataSource();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7.使用，修改上下文中的数据源就可以切换自己想要使用的数据源了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserVO findUser(String username) {
        DataSourceContext.setDataSource(&lt;/span&gt;&quot;slave&quot;&lt;span&gt;);
        UserVO userVO &lt;/span&gt;=&lt;span&gt; userMapper.findByVO(username);
        System.out.println(userVO.getName()&lt;/span&gt;+&quot;=====================&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种是在业务中使用代码设置数据源的方式，也可以使用AOP+注解的方式实现控制，方法多多！&lt;/p&gt;

</description>
<pubDate>Sat, 27 Oct 2018 17:15:00 +0000</pubDate>
<dc:creator>撸码识途</dc:creator>
<og:description>前几天有个需求，需要使用不同的数据源，例如某业务要用A数据源，另一个业务要用B数据源。我上网收集了一些资料整合了一下，虽然最后这个需求不了了之了，但是多数据源动态切换还是蛮好用的，所以记录一下，或许以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyj/p/9864128.html</dc:identifier>
</item>
<item>
<title>《软件管理沉思录》读书笔记 - pokid</title>
<link>http://www.cnblogs.com/pokid/p/9864101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pokid/p/9864101.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         作为一名在校大学生，阅读软件管理方面的书籍确实感受不是太深，因为没有经历过管理这个过程，谈何感同身受。所幸以前在一些公司实习过，见证过不少管理者，结合被管理的经历，倒是能有一些同理心。下面是我整理的该书读书笔记。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;      管理你的项目&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;         软件质量的挑战：软件质量改造的需求是巨大的，并且这种改进已经不能单纯的靠延续过去的那种基于测试的方法实现。为了保证质量，必须遵循：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  确立质量控制的策略丶目标和计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  正确训练丶指导和支持开发人员和团队&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  确立和维护软件需求的质量管理过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  审查丶检查并评估所有的产品制品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  确立和维护软件工程过程的统计控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  评估所有的缺陷，加以更正并用以识别丶纠正和预估其他类似问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  确立和维护配置管理和变更控制系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  持续改进开发过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是缺陷：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;削弱弱程序性能，使其不能有效并完全的满足用户需求的所有因素，是一种客观存在的事物，是可以识别描述统计的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         需要认识到的是缺陷并非漏洞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         质量是永无终点的旅程。应当聚焦于持续不断的质量改进，并且帮助你的团队成员真正的相信并遵循这些质量管理原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         质量旅程包含（循序渐进）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  测试更正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  检查&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  局部测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  质量到人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  个人测评&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  缺陷预防&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  基于用户的测评&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目标很重要，他们提供了努力的焦点，而且建立了一种优先次序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要为高质量项目制定计划&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最难以制定计划的时候，也是最需要制定计划的时候：当项目团队面临巨大的交付压力时，一定不能让步，需要坚持制定一份计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         计划分为基于时间段的计划和基于行动的计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;制定计划的关键是实践，因此想要得到最佳实践，从现在开始制定计划，并且在今后的所有项目实践中都得制定计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一份合格的产品计划包括：将要生产的产品规格和重要性能指标丶估算工作所需时间丶进度预测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计划的五条基本要求：易于理解丶清晰明白丶详细具体丶精确缜密丶准确无误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若不能是计划准确无误，那就常做计划，可以制定动态计划防止需求蔓延，同时计划必须得到维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;管理你的团队&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;         团队：一只团队至少两名队员；所有成员为共同目标而工作；每位成员至少扮演一个特定角色；完成任务要求成员相互依赖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         有了共同目标及成员之间紧密的相互依赖，凝胶型团队所需的信任感和凝聚力就产生了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         迪马克对凝胶型团队定义：紧密间隙在一起工作的一个群体，其密切程度使他们作为一个整体时迸发出的力量远超其组成部分之和。这种团队的效率要比人员构成相同但没有形成凝胶型团队的群体大得多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         通常团队会面临以下七个问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  无效的指导&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  缺乏妥协或合作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  缺少参与&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  拖延和缺乏信心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  低劣的质量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  功能蔓延&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  无效的对等评估&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而团队失败的四条原因可以总结为：资源不足丶领导问题丶不可能的目标丶士气问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高效团队必备的四个条件：凝聚力丶目标丶反馈丶共同的工作架构，前三者对于团队至关重要，最后一者规定了哪些任务必须完成，什么时间完成，由谁完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         毋庸置疑，团队中的交流很重要。交流的三要素：透明丶倾听丶协商。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         最杰出的交流者实际上是最优秀的倾听者。最优秀的倾听方式是“共鸣性倾听”，即“恩，你的意思是…...”,“换句话说，你认为……”，以这种方式不断的重复对方的发言。这一点本人深有感触，实习时如果直属领导以这样的方式与我交流，我会感受到被尊重以及自己的发言真的被关注了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         团队的生命周期：组件-动荡-规范-执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         群体类型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  工作型群体：成员集中精力在完成工作以及相关的各种活动上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  过程型群体：关心的是团队内部的结构和行为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  对抗型群体：与外部威胁作斗争&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自主指导型团队典型特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  具有团队感和归属感&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  共同对团队目标作出承诺&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  对过程和计划的主人翁意识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  具有制定计划的技巧和执行计划的纪律&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  追去卓越&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最基本的特征是凝聚力，最重要的是具备有效的领导&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;做一名高效的团队成员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优秀的团队会做任何需要做的事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;承诺是一项必须要学习的道德规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;增效现象：一个观点会产生大量的问题，在回答这些问题时，会引发新问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;团队创建的义务：作为团队的一员接受责任，并尽你最大的能力扮演好你的角色；参与确定团队目标和计划，并努力实现这些目标和计划；建立并维护一支高效和合作的团队。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         原则时谈判的基础是认识到立场只是满足利益的一种方式，把注意力集中在利益而不是立场上，这样就摆脱了争论，同时还得到了做出正确而有效的决定所必须的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         歌德说过一句话我觉得很有启发，“按一个人是怎样的便怎样对待他，他便还是那样的人，按一个人能怎样过或应该怎样去练他，他便会成为那样的人”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;strong&gt;领导和指导你的团队&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;        &lt;/strong&gt; 我丝毫不怀疑领导力的重要性，以前在找实习的时候对于没有没有领导魅力的面试官给的offer绝不会去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         领导力决定成败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         对于工作团队，有三条最重要的激励因素：恐惧丶贪婪和承诺。前面两条只有在不得已的情况才会使用，最应该使用的是承诺。团队承诺比个人的单独承诺产生的激励作用更大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         让团队所有人参与的技巧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  提问，先别主动说&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  装聋作哑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  频繁的检查约定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  感受没有说出口的疑虑或不同意见&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  管理专家&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  不要让某个人完全控制讨论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  指导团队领导者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  关注事实和数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  不允许有旁观者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于管理者们，本书也指出需构建管理团队。这点与《人件》中的观点截然相反。《人件》认为管理者从来不能形成一个团队，因为涉及的利益关系太多。个人比较支持《人件》里的观点，相信本书所提的“管理团队”只是形式上的团队。为此需做到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  当某个决定会影响到他们所在部门时，各部门管理者应当从一开始就参与其中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  需主动的投入，并且外部环境必须鼓励争论和竞争&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  鼓励管理团队共同工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理性管理四要素：确定目标；计划和审查；评估和追踪；预测和纠正。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;管理你的领导&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;         当管理者说交付日期是9个月，实际上他是报出了一个价格，而你必须“讨价还价”，你必须首先让管理者知道项目会花费多长时间，方法就是制定一份计划。优先级最高的事就是当前的工作任务。在位计划争取过程中，重点强调：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  根据您所提要求，这是我们制定的最好计划了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  如果实在想要更改需求或其他前提条件，那么我们需要重新检查计划来看看他们对日程进度有什么影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  这是一份费用最小的计划。如果您最关心的是进度，那么我们可以缩短一点时间，但是费用会增加……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个项目注定要失败时要做什么，有三个选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  继续埋头工作希望情况会好转&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  寻找另一份工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  试图解决问题：考虑下管理者面临的问题再决定你能做些什么：管理者已经怀疑项目有了麻烦；他们香想得到的是解决办法而不是问题；管理者不想有竞争对手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“你可以因为某事得到赞誉，也可以实际完成它，但别想两者兼得”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;集体做出的决策通常比个人决定要好的多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要让决策取得各个层级管理者的支持需要考虑：你为什么想要改变；你需要从哪些管理者得到支持；那些管理者为什么要支持你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;过程改进做法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  清晰的阐明你的提议是什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  理解当前的业务状况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  找出高层管理者当前关注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  对改进合理性做初步检查&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  以两三个原型为起点制定计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  估算前期一次性的引入成本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  测定后期的可能成本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  记录下可用的收益数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  估算预期的节约数额&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  确定衡量实际收益&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  评估改进对高层管理者最关心的问题可能带来的影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  找出提议的改进给组织可能带来的其他益处&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  准备一个清晰丶简短的陈述&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;管理你自己&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;做你自己的管理者，而不要像一个受害者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成功者赢得胜利，他们绝不抱怨。正是那些永远失败的人才会抱怨人生的不公以及别人该如何为自己的失败负责。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你需要做到：真正掌控你自己的工作；说服管理者同意你管理你自己&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何提高工作质量：衡量；改变本身&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改变工作方式步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  确定质量目标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  衡量产品质量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  理解过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  调查过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  应用调查后的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  衡量结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  把结果与目标进行比较&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  循环并不断改进&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件项目失败的主要原因通常是团队合作问题而不是技术问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;压力的真正根源是我们自己，它来自于我们渴望实现管理者丶辅导员或同伴对我们的期望的天性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成的工作量主要取决于：任务需耗费的时间；你能用来完成这些任务的总时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了管理你的工作，你必须知道自己的时间花费在了什么地方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;时间管理的逻辑基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  你在本周利用时间的方式很有可能与上周一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  要想制定切实可行的计划，你必须追踪自己利用时间的方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  要制定更加精细的计划，需要找出先前计划哪些地方出错及怎样改进&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  要管理好时间，就要计划你的时间并遵守这个计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  把主要活动分类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  记录每项主要活动所用时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  以一种标准方式记录时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  把时间数据放在一个便利的地方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对人生的思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负责任是对待人生的一种方式，我们可以迎接挑战，积极寻找我们能做什么并把它完成。要么我们控制我们自己生活的环境，要么环境控制我们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对自己做出承诺，保证你的承诺是负责任的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  在同意承诺前要分析工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  用计划来支持承诺&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  用书面形式记录下约定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  如果出现不能履行承诺的情况，马上告诉对方并努力最小化影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l  执著追求卓越，你才可能臻于卓越&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;学会领导&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一节是给管理者看的，对于我们学生来说其实没有太多体会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于领导，你的做事方式，你的感觉，甚至你的个人观点都会影响你的团队。领导要为团队树立榜样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 16:48:00 +0000</pubDate>
<dc:creator>pokid</dc:creator>
<og:description>《软件管理沉思录》读书笔记 作为一名在校大学生，阅读软件管理方面的书籍确实感受不是太深，因为没有经历过管理这个过程，谈何感同身受。所幸以前在一些公司实习过，见证过不少管理者，结合被管理的经历，倒是能有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pokid/p/9864101.html</dc:identifier>
</item>
<item>
<title>python进阶之关键字和运算符触发魔法方法 - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/9856065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/9856065.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;python有众多的魔法方法，它们会在满足某种条件下触发执行，掌握好魔法方法的使用，可以加快程序的运行效率，同时减少逻辑调用。&lt;/p&gt;
&lt;h2 id=&quot;关键字与魔法方法&quot;&gt;关键字与魔法方法&lt;/h2&gt;
&lt;p&gt;python的一些魔法方法是关键字触发的，即python解释器遇到某个关键字就会去执行相应的魔法方法。&lt;/p&gt;
&lt;h3 id=&quot;del与__del__&quot;&gt;del与__del__&lt;/h3&gt;
&lt;p&gt;如果一个对象定义了__del__魔法方法，那么解释器会调用del关键字后对象的__del__魔法方法,然后在上下文中删除该对象。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Dog(object):
    def __init__(self):
        pass
    def __del__(self):
        print('delete the dog object')

dog = Dog()
del dog&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;with与__enter____exit__&quot;&gt;with与__enter__、__exit__&lt;/h3&gt;
&lt;p&gt;如果一个类实现了_&lt;em&gt;enter_&lt;/em&gt;、__exit__魔法方法，我们就说这个类实现了一个上下文管理器，它使用with关键字触发，更多的用法参考：&lt;a href=&quot;https://www.cnblogs.com/cwp-bg/p/8601087.html&quot;&gt;python之上下文管理器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;if与__bool__&quot;&gt;if与__bool__&lt;/h3&gt;
&lt;p&gt;一个对象定义了__bool__魔法方法后，if关键字会触发该魔法方法，如果没有定义就会使用解释器预置的处理算法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class List(list):
    def __bool__(self):
        print('list bool')
        return True
if __name__ == &quot;__main__&quot;:
ls = List([])
if ls: # 为真
    print('mmm')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;innot-in与__contains__&quot;&gt;in\not in与__contains__&lt;/h3&gt;
&lt;p&gt;当使用in或not in关键字判断一个容器里的元素时，触发该容器的_&lt;em&gt;contains_&lt;/em&gt;,如果没有定义，Python就会迭代整个序列.&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyList(list):
    def __contains__(self, item):
        print('__contains__')
        return super().__contains__(item)

if __name__ == &quot;__main__&quot;:
    my = MyList([1,2,3])
    if 1 in my:
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运算符与魔法方法&quot;&gt;运算符与魔法方法&lt;/h2&gt;
&lt;p&gt;python像大多数编程语言一样有那么多的运算符，为什么哪些运算符有着相应的功能呢？答案就在于运算符会触发相应的魔法方法。&lt;/p&gt;
&lt;p&gt;python的运算符有算术运算符、逻辑运算符、比较运算符等：&lt;/p&gt;
&lt;h3 id=&quot;算术运算符与魔法方法&quot;&gt;算术运算符与魔法方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;+：数值相加，会调用相加对象的__add__或__radd__方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Int(int):
    def __add__(self, other):
        print('diao yong le add')
        return super().__add__(other)

    def __radd__(self, other):
        print('diao yong le radd')
        return super().__radd__(other)
if __name__ == &quot;__main__&quot;:
    a = Int(3)
    b = Int(5)
    c = a + b # 发现__add__方法被调用了
    c = 3 + a # 方法__radd__方法被调用了，只有当操作符左边的参数没有定义__add__方法，__radd__方法才会被调用。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过重写相关的方法重新定义“+”符号的功能。&lt;/p&gt;
&lt;p&gt;同理算术运算符的魔法方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a+b:数值相加，会调用对象的\__add\__或\__radd__方法。
a-b:数值相减，会调用对象的__rsub__或__sub__方法
a*b:数值相乘，调用__mul__和__rmul__方法
a/b:数值相除，调用__rtruediv__和__truediv__方法
a//b:整除，调用__floordiv__和__rfloordiv__方法。
a%b:求余，调用__mod__和__rmod__方法
a**b:求幂，调用__pow__和__rpow__方法；
-a:求负数,调用__neg__方法；
+a:调用__pos__方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;赋值运算符与魔法方法&quot;&gt;赋值运算符与魔法方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;a=b:
a+=b:a与b相加赋值给a，调用__iadd__方法；
a-=b:a与b相减赋值给a，调用__isub__方法；
a*=b：a与b相乘赋值给a，调用__imul__方法；
a/=b:a与b相除赋值给a，调用__itruediv__方法；
a%=b:a与求余赋值给a，调用__imod__方法；
a//=b：a与b整除赋值给a，调用__ifloordiv__方法；
a**=b:a与b求幂赋值给a，调用__ipow__方法；
a&amp;amp;=b:a与b位与运算赋值给a，调用__iand__方法；
a|=b:a与b位或运算赋值给a，调用__ior__方法；
a^=b:a与b位异或运算赋值给a，调用__ixor__方法；&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较运算符与魔法方法&quot;&gt;比较运算符与魔法方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;\&amp;gt;:大于，比较大小返回布尔值，调用比较参数的\__gt__方法
&amp;gt;=:大于等于,调用比较参数的\__ge__方法
&amp;lt;:小于，调用比较参数的\__lt__方法
&amp;lt;=:小于等于，调用比较参数的\__le__方法
==:等于，调用比较参数的__eq__方法
!=:不等于，调用比较参数的__ne__方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;位运算符与魔法方法&quot;&gt;位运算符与魔法方法&lt;/h3&gt;
&lt;p&gt;位运算符是将数字当做位来运算.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 10 # 位 a = 0000 1010
b = 15 # b = 0000 1111
c = a&amp;amp;b # c = 0000 1010
print(c) # 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相应的魔法方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;|:或,调用比较参数的__or__和__ror__方法
&amp;amp;:与,调用比较参数的__and__和__rand__方法
~:取反，调用比较参数的__invert__方法
&amp;lt;&amp;lt;:左移位运算，调用比较参数的__lshift__和__rlshift__方法
&amp;gt;&amp;gt;:右移动运算符,调用比较参数的__rrshift__和__rshift__方法
^:异或运算，调用比较参数的__rxor__和__xor__方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Sat, 27 Oct 2018 16:39:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<og:description>前言 python有众多的魔法方法，它们会在满足某种条件下触发执行，掌握好魔法方法的使用，可以加快程序的运行效率，同时减少逻辑调用。 关键字与魔法方法 python的一些魔法方法是关键字触发的，即py</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/9856065.html</dc:identifier>
</item>
<item>
<title>一份详细的 Matplotlib入门指导 - Jin_liang</title>
<link>http://www.cnblogs.com/jin-liang/p/9863987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jin-liang/p/9863987.html</guid>
<description>&lt;p&gt;hMatplotlib是最受欢迎的二维图形库，但有时我们很难做到得心应手的去使用。&lt;/p&gt;
&lt;p&gt;如何更改图例上的标签名称？ 如何设置刻度线？ 如何将比例更改为对数？ 如何在我的情节中添加注释和箭头？ 如何在我的图中添加网格线？&lt;/p&gt;
&lt;p&gt;本文汇集了有关如何自定义Matplotlib图的常见问题和答案。 这可以作为快速Matplotlib绘图的一个很好的备忘单，而不是Matplotlib库的介绍。 &lt;/p&gt;
&lt;p&gt;首先我们导入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; matplotlib.pyplot as plt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Jupyter Notebook中，您可以在下面包含这一行，这样您就不必在每次想要制作绘图时调用plt.show（）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
%matplotlib inline
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;c6a0&quot; class=&quot;graf graf--h3 graf-after--figure&quot;&gt;图与子图（PLOTS AND SUBPLOTS）&lt;/h3&gt;
&lt;p&gt;Q1:怎样定义图形的尺寸？&lt;/p&gt;
&lt;p&gt;许多情况下，默认的画布都太小，我们需要自己定义一个合适的画布。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
plt.figure(figsize=(20,10))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Q2:什么是子图（subplots）？怎样去创建子图？&lt;/p&gt;
&lt;p&gt;子图是一组较小的轴，它们在一个图中一起存在。 下面是2 x 2形式的四个子图的示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027233453275-580972306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些子图是使用下面的代码创建的。 我们调用plt.subplot并指定三个数字。 它们指的是要创建子图的的行数，列数和子图号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range (1, 5&lt;span&gt;):
    plt.subplot(&lt;/span&gt;2, 2&lt;span&gt;, i)
    plt.text(&lt;/span&gt;0.5,0.5, str((2, 2, i)), ha=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize = 10&lt;span&gt;)
    plt.tight_layout()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的子图中，图中的文本是对这三个数字的引用。 子图编号的顺序是从左上角开始的行，从数字1开始。例如，左上图是子图编号1，右上图是子图编号2，左下图是子图编号3， 右下图是4号子图。&lt;/p&gt;
&lt;p&gt;请注意，必须专门调用plt.subplot（2,2,1）来创建该子图。&lt;/p&gt;
&lt;p&gt;Q3：如果子图布局不是很精致，怎样来调整呢？&lt;/p&gt;
&lt;p&gt;如果子图排列过于紧凑。 我们可以通过调用plt.tight_layout（）来修复它。它清理子图之间的填充以获得更清晰的外观。&lt;/p&gt;
&lt;p&gt;调整前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027233908673-451163408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;调整后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027233834825-1416968344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Q4：怎么样天加网格线？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
plt.grid(True)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 风格和属性&lt;/p&gt;
&lt;p&gt;Q5：怎样调整线的颜色\粗细\形状？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
plt.plot(x, y, color = ‘green’ , linewidth = 2, linestyle = “-”)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 常见的形状：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027234345637-105259218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q6：怎样更改标记（marker）的颜色和样式？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
plt.scatter(x, y, marker = ‘o’, color = ‘red’)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 常见的选择：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027234614065-1497314116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q7：如何更改线条的透明度？&lt;/p&gt;
&lt;p&gt;将alpha参数传递给你的绘图。 Alpha可以设置为0到1，其中0表示完全透明，1表示不透明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
plt.plot(x, y, alpha = 0.1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 下图说明了透明度在0.9,0.5和0.1的alpha水平下的表现.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027234827146-368740443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Oct 2018 15:58:00 +0000</pubDate>
<dc:creator>Jin_liang</dc:creator>
<og:description>hMatplotlib是最受欢迎的二维图形库，但有时我们很难做到得心应手的去使用。 如何更改图例上的标签名称？ 如何设置刻度线？ 如何将比例更改为对数？ 如何在我的情节中添加注释和箭头？ 如何在我的图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jin-liang/p/9863987.html</dc:identifier>
</item>
<item>
<title>六边形架构设计 - whthomas</title>
<link>http://www.cnblogs.com/whthomas/p/9863943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whthomas/p/9863943.html</guid>
<description>&lt;p&gt;分层架构是运用最为广泛的架构模式，把一个软件系统进行分层，是我们目前做工程项目的一个共识，我们最初学习的分层架构就是经典的三层架构了。它自顶向下分成三层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户界面层（User Interface Layer）&lt;/li&gt;
&lt;li&gt;业务逻辑层（Business Logic Layer）&lt;/li&gt;
&lt;li&gt;数据访问层（Data Access Layer）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201810/475531-20181027233900628-771809099.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统的单体应用中，因为业务不算复杂，这种分层并没有什么问题，把数据的渲染交给用户界面层，把核心业务逻辑放到业务逻辑层，然后将数据库的访问交给数据访问层。&lt;/p&gt;
&lt;p&gt;但是随着业务越来越复杂，问题也随之而来：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要依赖的基础设施也不仅仅只有数据库这样单一了&lt;/li&gt;
&lt;li&gt;很多参数的校验，我们开始纠结是放到用户界面层还是业务层。&lt;/li&gt;
&lt;li&gt;缓存是放到哪里去控制&lt;br/&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码开始变得复杂，很快只有上帝能看懂了，然后写代码往往就是牵一发而动全身。&lt;/p&gt;
&lt;p&gt;我们都知道在设计模式中有一个很重要的原则就是&lt;strong&gt;依赖倒置&lt;/strong&gt;，他包含了三层含义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高层模块不应该依赖低层模块，两者都应该依赖其抽象&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节&lt;/li&gt;
&lt;li&gt;细节应该依赖抽象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以设计模式中产生了一个模式——&lt;strong&gt;适配器模式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在中间件软件爆发的今天，同一种功能的中间件可能会有非常多的选择。比如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MQ: RabbitMQ, Kafka, ActiveMQ, RocketMQ......&lt;/li&gt;
&lt;li&gt;SQL: MySQL, PostgreSQL......&lt;/li&gt;
&lt;li&gt;NoSQL: Redis,MongoDB, ElasticSearch......&lt;/li&gt;
&lt;li&gt;Job: Elastic-Job, XXL-JOB.....&lt;br/&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外还有各种供应商的需要有备用通道：短信，邮件，推送，业务供应商......&lt;/p&gt;
&lt;p&gt;如果我们在业务逻辑中去关注这些东西，毫无疑问，我们的业务逻辑就会很繁琐：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if ( config == 'A' ) {
    // statement 1
} else if ( config == 'B' ) {
    // statement 2
} else if ( config == 'C' ) {
    // statement 3
} else if ( config == 'D' ) {
    // statement 4
} else {
    // default statement
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别是业务中去选择供应商的时候，我们通常是要有好几个备用通道的，但是我们的业务逻辑本身只是关心：这件事做了没，而不是到底用哪种方式去做。&lt;/p&gt;
&lt;p&gt;所以六边形架构被提出了。六边形架构提倡用一种新的视角来看待整个系统，该架构中存在两个区域，分别是“外部区域”和“内部区域”。在外部区域中，不同的客户均可以提交输入；而内部的系统则用于获取持久化数据，并对程序输出进行存储（比如数据库），或者在中途将输出转发到另外的地方（比如消息）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201810/475531-20181027234104758-1025752101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在设计系统的时候，往往过于关注数据库，Http接口等基础设施的设计，而忽略了我们需要关注的业务。在复杂系统中，最容易变化的也是业务形态，产品经常会要求改来改去，因为业务本身就在不断地演进，如果我们一开始就基于数据库作所有的设计，那么势必一旦遇上业务的修改，库表肯定也需要对应先进行变化。假如我们融入六边形架构，将数据库和暴露的Controller都视为是基础设施，先去关注业务的模型和代码，Class的修改比要数据库改起来要简单的多。另外一方面，也大大提高了程序的可测试性：在没有准备一堆基础设施(数据库，接口，异步通知等等)情况下，可以先测试逻辑的完整性。&lt;/p&gt;
&lt;p&gt;另外，有时候随着业务增长有的基础设施是会需要进行替换的，采用六边形架构之后，这种更换的成本就会降低。另外如果出现需要使用Web Service的客户，我们也不必纠结于之前的HTTP接口，直接开出一套新的协议代码供客户使用，而不会纠结领域部分代码有逻辑上的缺失。&lt;/p&gt;
&lt;p&gt;采用六边形架构之后，我们的领域模型也会更加独立，更精简，在适应新的需求时修改也会更容易。&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:41:00 +0000</pubDate>
<dc:creator>whthomas</dc:creator>
<og:description>分层架构是运用最为广泛的架构模式，把一个软件系统进行分层，是我们目前做工程项目的一个共识，我们最初学习的分层架构就是经典的三层架构了。它自顶向下分成三层： 用户界面层（User Interface L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whthomas/p/9863943.html</dc:identifier>
</item>
<item>
<title>毕业这五年 - 帅帅的鱼</title>
<link>http://www.cnblogs.com/appleyk/p/9863822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/appleyk/p/9863822.html</guid>
<description>&lt;p&gt;&lt;span&gt;       一晃高考快十年了，毕业已五年有余，不禁在这个点感慨起来 -- 人生啊，你慢点吧，生活啊，容我缓一缓可好？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       09年，人生第一次参加高考【差点就有第二次了】，考场做题那叫一个自信和潇洒啊；你还别说，博主我从小学到高中，虽说不是尖子中的尖子，好歹班级名次没有下过前十，至于年级里的排名，那就呵呵了好吧【其次没那么惨】；你问我哪来的自信？因为聪明啊！没错，我就这一点自信了；别人在学习的时候，我也在学，别人还在学习的时候，我不；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 整个高中，除了学习这第一爱好之外【内向的外表幽默的嘴脸】；&lt;/span&gt;&lt;span&gt;我的第二爱好就是篮球，不是打球、看球就是练球【容我多扯点，待会再扯回来，原谅我在记流水账】，一周唯一的两节体育课有时候可能还要被其他老师给占用，理由很简单，你们是学生，要以学习为重【啊呸】；只要有体育课，篮球必玩，那时候只玩半场，3V3的那种，不是我吹，那时候我打球还是很奈斯的，基本防不住，模板就是韦德【哈哈，我喜欢科比】，还特么能跳，虽说个子不高，但总喜欢打内线，和中锋抢板；因为喜欢跳，导致我经常崴脚，崴着崴着就习惯了，以至于现在我的两只脚脚脖处骨头都有点变形了，可怕；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后来上了大学我就只看NBA很少打球，工作后，不打球了也很少看NBA了，回想一下，这就是成长吧，那时候单纯的少年，眼里只有耍帅，现在为了生活，必须努力工作；原来年轻，可以肆无忌惮，现在不行；以前是一个人怎么过都好，现在不行；以前不用担心没钱花，现在不行，这，就叫做成长吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　扯回来，说到09年高考，博主那叫一个自信啊，不说考个一本，至少二本应该是没问题的，但是查成绩的时候，那真叫一个打脸啊，三本？What？怎么办？我还记那是一个夏天的深夜，十一点多，我一个人揣着身份证跑去离家两公里的网吧，网吧叫什么名字，我忘了【哈哈，莫嫌我啰嗦】，打了一把CF，默默的等着零点的到来，等来的确是一句&quot;卧槽！&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缓了几天后，博主想复读了，家人没有表态，他们让我自己决定！再后来，又缓了几天，博主我反悔了，因为我的人生不能因为一次失败就否定了自己，况且复读对我来说，还是很抵触的，三本就三本吧！于是乎，抱着厚厚的一本大学院校的书就选了起来，因为分数的缘故，不敢乱来，只能考虑本省的三本院校，至于专业，那时候真的是年幼无知啊，根本不知道什么是计算机科学与技术，不知道.net方向是什么，那时候09年，我才有了自己的QQ，对开关机这么简单的操作都得反复练习的人，没错，那时候就是一电脑小白，但我却误打误撞，报了一个计算机专业，就像待出嫁的大姑娘一样，恨不得赶快把自己嫁出去；之说以说我年幼无知，是因为当初报的是软件开发.Net方向，要是那时候报的是Java专业，现在就不一样了，后话了，我们继续。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　录取很顺利，入学后，被分在了211寝室，而我们院校是挂在本省的一个出名的一本院校下的一个三本计算机学院，巧了，这个学校是211大学，更巧的是，校门口的公交站，就有211路的公交，以至于后来大学毕业，我对211这三个数字特别有好感，只要注册XXX账号，211成了我最喜欢的名称后缀；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　寝室加我九个人，每个人都很有个性，以至于毕业这么多年了，我都记忆犹新，不是我吹【哈哈，有没有想就此弃看的童鞋】，当时我们寝室可谓是年纪里的风云宿舍，我用最简单的语言形容下九个人包括我自己：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       头号人物，小胖【还记得你大学宿舍的那个小胖吗，甭管是男是女，是不是都有一个】：高中就接触计算机，大学四年在专业上他说第二，没人敢说第一，各科大作业上简直是我们系里的活雷锋，且为人单纯善良耿直，看不惯的就说出来，很有头脑很有主见很有想法的一个人，缺点就是，太执拗，不喜欢溜须拍马，有话藏不住，因为这，在系里&quot;官场仕途&quot;早早宣布over，但是，不妨碍我们全寝室人都爱他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       二号人物，昊哥，一本正经，一身正气，大义凛然...总之就是，看上去让人很敬畏，其实，内心很骚动，性格豪爽，寝室最高的，也是最豪爽的人之一，这个人简直就是一个bug，放着那么有前景的专业不学不学，偏偏大学四年却在自学法律，很有毅力很能吃苦，后来成了人民的律师，缺点就是，太有想法，以至于常常把自己给想进去，活得太认真却不够洒脱，但是，不妨碍我们寝室哥几个佩服他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       三号人物，宿色长，一张本分的脸下，却暗藏一颗不安的心，哈哈，人非常good，脾气好，人好，说话的态度好，总之就是除了他能当211寝室长以外，谁都胜任不了；寝室的秩序和脏活都离不开他，大学四年，色长无偿贡献了他的床，因为下铺方便的原因，寝室八个人轮着睡，以至于色长的床看起来总是最脏的，哈哈，缺点就是，喜欢玩游戏看小说，对专业技能不上心，让人很是操心，但是，不妨碍我们八个人都很尊重他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;/span&gt;&lt;span&gt;四号人物，fuck，说起这个名字的由来也是好笑，因为总喜欢说fuck，几乎成了大学四年的口头禅，干脆寝室人就给他起了一个这样的外号，为人特别干练精明，非常清楚自己想要什么，在年级和系里工作非常努力，经常回来的很晚，以至于差点和寝室脱钩了，缺点就是，为人太随性，不太顾忌身边亲近人的感受，有一套自己的为人处世手册，但是，不妨碍大家对他在工作上的高度认可！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   五号人物，小茗，这个人简直就是神一样的存在，空有聪明的脑袋，却不拿来干正事，单纯里掺和着可爱；喜欢吃泡面喝碳酸饮料；喜欢看动漫打游戏；喜欢熬夜和睡懒觉，总之你能想象到的正常人的生活他都不沾边；最佩服他的就是他认真起来，真的很认真，一个学期专业课几乎不学，但是考前的一周却可以补回来，以前熬夜是为了打游戏，考前一周熬夜居然是为了复习，缺点呢，嗯...想了半天，这是个bug，如果非要说一个的话，那就是太自我，活在自己的世界里像个长不大的孩子，但是，不妨碍我们喜欢和他一起玩！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   六号人物，红星，如红星二锅头一般，这个人很烈，个子不高却蕴藏着大能量，特别特别努力，在专业知识上，很有天赋很出众，学科上，成绩也是系列名列前茅，是我们寝室里唯一拿过奖学金的人，而且还是连拿的那种；喜欢泡自习室，人缘和口碑特好，缺点就是，情商太低，情商太低，情商太低！但是，不妨碍我们大家都很欣赏他，叫他小星星，一闪一闪亮晶晶！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      七号人物，小丕，寝室活得最洒脱的一个人，性格外向，真性情，寝室气氛的活跃和推动者，喜欢自由自在的生活，喜欢旅游，喜欢黑科技；名字的由来，是因为我们玩澄海3C的时候，小丕是他的ID，而且我们当时我们玩浩方，是他带的；点子特别多，很能说，但是很难捉摸透这个人的内心，缺点呢，就是缺心眼，不服就干，哈哈，但是，不妨碍大家都喜欢他，喜欢他身上的洒脱和那种放荡不羁的生活态度！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       八号人物，小迪，别看也带个&quot;小&quot;子，但在寝室也算是老大哥一个了；睡在博主下铺，一个有趣的男人，哈哈；生活上特别讲究，特别细心的一个人，会在我们吃饭的时候，提醒我们:&quot;这个菜不干净，刚才我吃了一个苍蝇出来，MD，恶心死我了&quot;【这样真的好吗，坏笑】，会在玩游戏的时候，提倡大家玩重口味的游戏，比如求生之路，但是却在玩的时候，叫的堪比杀猪声，还一个劲的说着：&quot;太特么吓人了.....&quot;【Oh No! 头疼】，会在生活中，充当知心大哥，教育和指导我们，但是人真的很单纯少年，缺点呢，就是开不起玩笑，认真的时候很认真，不认真的时候也很认真，哈哈，但是，不妨碍我们都很器重他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       九号人物，本人也，寝室年龄最小的一个，我就不做简短的自我介绍了，我可是本篇博文的主角，关于我，各位有得看了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的大学四年，很快活，无拘无束，没有思想包袱也没有就业压力【当时房价还没有疯涨，工作遍地都是】，完全活出了自己理想中的样子，吃喝玩乐样样不少【练就一个手好的操作，澄海3C溜的一B&lt;/span&gt;&lt;span&gt;】，逃课挂科什么的，也都亲自试验过，总之就是，颓废！没错，就是这两个字，当时放着那么好的专业门槛不好好学习，却要虚度整个大学四年，虽然博主那时候专业技能很优秀【我有这方面的天赋】，但却没有充分利用好时间和自身聪明的特性去专研学科，以至于毕业后，在专业知识上吃了不少亏，费了老大劲；正所谓你有一把好枪，你却不懂得如何保养它，时间久了，它也就一副锈铁的皮囊，你指望它的时候，它却哑火了；有时候，道理我们都懂，只是，晚熟的人不知道在什么年纪该干什么事，也好，至少博主现在明白过来了，不晚，不晚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　写到这个点了，一看时间，快十二点了，有点累了，标题是毕业后的这五年，我居然用了大半篇幅去讲述我的大学，我是想到什么就写什么，我这个人比较感性，喜欢写东西，上学的时候喜欢在QQ空间里写，后来毕业当了两年兵，喜欢把文字写在心里，再后来，部队复员回来工作后，又喜欢把文字写在博客上，时间是好东西啊，教会了我重新审视自己，今天就到这吧，后面的看心情，我再补上，讲讲博主的部队生活和工作上的心得，下一篇见...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434157/201810/1434157-20181027233032072-1307985239.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:31:00 +0000</pubDate>
<dc:creator>帅帅的鱼</dc:creator>
<og:description>一晃高考快十年了，毕业已五年有余，不禁在这个点感慨起来 -- 人生啊，你慢点吧，生活啊，容我缓一缓可好？ 09年，人生第一次参加高考【差点就有第二次了】，考场做题那叫一个自信和潇洒啊；你还别说，博主我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/appleyk/p/9863822.html</dc:identifier>
</item>
<item>
<title>Go基础系列：数据类型转换(strconv包) - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9863915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9863915.html</guid>
<description>&lt;p&gt;Go不会对数据进行隐式的类型转换，只能手动去执行转换操作。&lt;/p&gt;
&lt;h2 id=&quot;简单的转换操作&quot;&gt;简单的转换操作&lt;/h2&gt;
&lt;p&gt;转换数据类型的方式很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;valueOfTypeB = typeB(valueOfTypeA)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 浮点数
a := 5.0

// 转换为int类型
b := int(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go允许在底层结构相同的两个类型之间互转。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// IT类型的底层是int类型
type IT int

// a的类型为IT，底层是int
var a IT = 5

// 将a(IT)转换为int，b现在是int类型
b := int(5)

// 将b(int)转换为IT，c现在是IT类型
c := IT(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不是所有数据类型都能转换的，例如字母格式的string类型&quot;abcd&quot;转换为int肯定会失败&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;低精度转换为高精度时是安全的，高精度的值转换为低精度时会丢失精度。例如int32转换为int16，float32转换为int&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这种简单的转换方式不能对int(float)和string进行互转，要跨大类型转换，可以使用&lt;code&gt;strconv&lt;/code&gt;包提供的函数&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;strconv&quot;&gt;strconv&lt;/h2&gt;
&lt;p&gt;strconv包提供了简单数据类型之间的类型转换功能。可以将简单类型转换为字符串，也可以将字符串转换为其它简单类型。&lt;/p&gt;
&lt;p&gt;这个包里提供了很多函数，大概分为几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串转int：Atoi()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;int转字符串: Itoa()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;ParseTP类函数将string转换为TP类型：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。因为string转其它类型可能会失败，所以这些函数都有第二个返回值表示是否转换成功&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;其它类型转string类型：FormatBool()、FormatFloat()、FormatInt()、FormatUint()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;AppendTP类函数用于将TP转换成字符串后append到一个slice中：AppendBool()、AppendFloat()、AppendInt()、AppendUint()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有其他一些基本用不上的函数，见官方手册：&lt;code&gt;go doc strconv&lt;/code&gt;或者https://golang.org/pkg/strconv/。&lt;/p&gt;
&lt;p&gt;当有些类型无法转换时，将报错，返回的错误是strconv包中自行定义的error类型。有两种错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ErrRange = errors.New(&quot;value out of range&quot;)
var ErrSyntax = errors.New(&quot;invalid syntax&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，使用Atoi(&quot;a&quot;)将&quot;a&quot;转换为int类型，自然是不成功的。如果print输出err信息，将显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;strconv.Atoi: parsing &quot;a&quot;: invalid syntax&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;string和int的转换&quot;&gt;string和int的转换&lt;/h3&gt;
&lt;p&gt;最常见的是字符串和int之间的转换：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.int转换为字符串：Itoa()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Itoa(): int -&amp;gt; string
println(&quot;a&quot; + strconv.Itoa(32))  // a32&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.string转换为int：Atoi()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Atoi(s string) (int, error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于string可能无法转换为int，所以这个函数有两个返回值：第一个返回值是转换成int的值，第二个返回值判断是否转换成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Atoi(): string -&amp;gt; int
i,_ := strconv.Atoi(&quot;3&quot;)
println(3 + i)   // 6

// Atoi()转换失败
i,err := strconv.Atoi(&quot;a&quot;)
if err != nil {
    println(&quot;converted failed&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;parse类函数&quot;&gt;Parse类函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Parse类函数用于转换字符串为给定类型的值&lt;/strong&gt;：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。&lt;/p&gt;
&lt;p&gt;由于字符串转换为其它类型可能会失败，所以这些函数都有两个返回值，第一个返回值保存转换后的值，第二个返回值判断是否转换成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b, err := strconv.ParseBool(&quot;true&quot;)
f, err := strconv.ParseFloat(&quot;3.1415&quot;, 64)
i, err := strconv.ParseInt(&quot;-42&quot;, 10, 64)
u, err := strconv.ParseUint(&quot;42&quot;, 10, 64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ParseFloat()只能接收float64类型的浮点数。&lt;/p&gt;
&lt;p&gt;ParseInt()和ParseUint()有3个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (uint64, error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bitSize&lt;/code&gt;参数表示转换为什么位的int/uint，有效值为0、8、16、32、64。当bitSize=0的时候，表示转换为int或uint类型。例如bitSize=8表示转换后的值的类型为int8或uint8。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;base&lt;/code&gt;参数表示以什么进制的方式去解析给定的字符串，有效值为0、2-36。当base=0的时候，表示根据string的前缀来判断以什么进制去解析：&lt;code&gt;0x&lt;/code&gt;开头的以16进制的方式去解析，&lt;code&gt;0&lt;/code&gt;开头的以8进制方式去解析，其它的以10进制方式解析。&lt;/p&gt;
&lt;p&gt;以10进制方式解析&quot;-42&quot;，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;-42&quot;, 10, 64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以5进制方式解析&quot;23&quot;，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;23&quot;, 5, 64)
println(i)    // 13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为5进制的时候，23表示进位了2次，再加3，所以对应的十进制数为&lt;code&gt;5*2+3=13&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以16进制解析23，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;23&quot;, 16, 64)
println(i)    // 35&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为16进制的时候，23表示进位了2次，再加3，所以对应的十进制数为&lt;code&gt;16*2+3=35&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以15进制解析23，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;23&quot;, 15, 64)
println(i)    // 33&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为15进制的时候，23表示进位了2次，再加3，所以对应的十进制数为&lt;code&gt;15*2+3=33&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;format类函数&quot;&gt;Format类函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;将给定类型格式化为string类型&lt;/strong&gt;：FormatBool()、FormatFloat()、FormatInt()、FormatUint()。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s := strconv.FormatBool(true)
s := strconv.FormatFloat(3.1415, 'E', -1, 64)
s := strconv.FormatInt(-42, 16)
s := strconv.FormatUint(42, 16)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FormatInt()和FormatUint()有两个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func FormatInt(i int64, base int) string
func FormatUint(i uint64, base int) string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个参数base指定将第一个参数转换为多少进制，有效值为&lt;code&gt;2&amp;lt;=base&amp;lt;=36&lt;/code&gt;。当指定的进制位大于10的时候，超出10的数值以a-z字母表示。例如16进制时，10-15的数字分别使用a-f表示，17进制时，10-16的数值分别使用a-g表示。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;FormatInt(-42, 16)&lt;/code&gt;表示将-42转换为16进制数，转换的结果为-2a。&lt;/p&gt;
&lt;p&gt;FormatFloat()参数众多：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func FormatFloat(f float64, fmt byte, prec, bitSize int) string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bitSize参数表示转换为多少位(32或64)的浮点数对应的字符串。&lt;/p&gt;
&lt;h3 id=&quot;append类函数&quot;&gt;Append类函数&lt;/h3&gt;
&lt;p&gt;AppendTP类函数用于将TP转换成字符串后append到一个slice中：AppendBool()、AppendFloat()、AppendInt()、AppendUint()。&lt;/p&gt;
&lt;p&gt;Append类的函数和Format类的函数工作方式类似，只不过是将转换后的结果追加到一个slice中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    // 声明一个slice
    b10 := []byte(&quot;int (base 10):&quot;)
    
    // 将转换为10进制的string，追加到slice中
    b10 = strconv.AppendInt(b10, -42, 10)
    fmt.Println(string(b10))

    b16 := []byte(&quot;int (base 16):&quot;)
    b16 = strconv.AppendInt(b16, -42, 16)
    fmt.Println(string(b16))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int (base 10):-42
int (base 16):-2a&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 27 Oct 2018 15:31:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>Go不会对数据进行隐式的类型转换，只能手动去执行转换操作。 简单的转换操作 转换数据类型的方式很简单。 例如： Go允许在底层结构相同的两个类型之间互转。例如： 但注意： 1. 不是所有数据类型都能转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9863915.html</dc:identifier>
</item>
<item>
<title>运维小哥的工作自述 - 卡子火</title>
<link>http://www.cnblogs.com/kazihuo/p/9863894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kazihuo/p/9863894.html</guid>
<description>&lt;p&gt;　　光阴似箭，日月如梭！弹指间，回首想想，进公司的时间也不短了。在平凡的岗位上默默地耕耘着，似乎是那么不起眼~~但作为一颗螺丝钉，我要大声的告诉自己：螺丝钉也能有自己的价值体现！&lt;/p&gt;
&lt;p&gt;       于是乎，三省吾身！&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098305/201810/1098305-20181027231957094-1296597791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       几千号员工的上市企业，以总部和分部为个体划分，在个体中又以部门为单位划分，各部门的管理、财政、人事都实现独立。总而言之，一个独立的部门就像只小麻雀，五脏俱全！从新人入职的身份到看着新人入职，从环境的陌生到熟悉，从同事的初识到相处，一切的一切，似乎都是那么顺理成章的进行着~~&lt;/p&gt;
&lt;p&gt;      现在总结来看，上份工作算是系统运维，上至集群的升级和扩容，下至机房的上架与拉线，还得拉个箱子满世界的跑~~而目前的运维类型能也就给归个应用运维的类吧，部门做的是医疗健康的app，在进公司之前总想着偌大个企业，在运维体制、系统架构、服务优化、技术规范、监控手段等方面应该高大上，肯定很多地方能大开眼界，但是事实却是并不是想象中的那么高B格，啊哦~&lt;/p&gt;
&lt;p&gt;       公司的应用运维流程是开发在本地将代码调试好推送到Gitlab，通过Jenkins构建，实现将代码打成war包，提取包的md5值并传输到备份服务器，同时将包部署到Tomcat，上线后由测试进行功能验证。系统架构体系则是Nginx+Tomcat ！&lt;/p&gt;
&lt;p&gt;       因是传统的war包方式持续集成，故Jenkins中并未用到太多插件，打包、备份、部署等都是通过在Jenkins中添加的相关Shell命令进行操作。于是乎，当在Jenkins中新建Project时，通过原有的模板进行Copy后，还需多次手动的修改那些频繁出现在Shell命令中的参数（打包的包名、备份服务器地址、部署服务器地址等）。为了删繁就简，于是乎，我将内容集成在脚本中，通过运行脚本并传参的方式实现一次传参达到多次Shell内容参数的调用，Oye！&lt;/p&gt;
&lt;p&gt;       然后说说Gitlab，公司的一些数据资料、项目代码等都存在Gitlab中，而Gitlab权限掌管在运维手中，部门需要新开项目，在Gitlab上建立相应的代码Project都得是运维操办，原有的流程是确定新开项目，运维在Gitlab建立相应Project，然后通过SourceTree工具对新建的Project进行git初始化和指定分支的创建。于是乎，每次新开项目，Gitlab新建完Project后，都得别扭的在Windows中用SourceTree工具，总感觉怪怪的。为了删繁就简，于是乎，我将相关操作集成进脚本，并建立Jenkins执行操作，抛弃了Windows工具的同时实现了相应功能，麻麻再也不担心我不会用工具了，Oye！&lt;/p&gt;
&lt;p&gt;       随着工作的循序渐进，有天开发突然抱着电脑来找我了，说线上Bug紧急修复，要提取线上的代码为基底进行改动，所以问我要线上的代码。然后我就在想：“讲道理，运维负责项目上线，顶多也就支配下项目的版本回滚，代码是开发的命脉，确定线上代码的版本都还要找运维？开发难道不会对代码打好相应的版本标签么？”诶呀！脑壳疼，最终讨论出的结果就是：一个项目可能对应多个开发，项目上线运维一定在，而开发不一定在，开发的水平参差不齐，标签不知道打，或者没法统一等等~~好吧好吧！最后我还是选择在项目上线前通过脚本对其进行版本标记，实时确定线上代码版本，Oye！&lt;/p&gt;
&lt;p&gt;       运维字面上理解为运营、维护；而更深层次的是扮演着管理、制度、推行和监督角色，处理着自动化、网站架构优化、监控预警、流量及日志分析统计、权限管理、安全优化等事务，负责维护整体项目架构体系的稳定运行；同时让自动化的持续集成体系更具有制度化、规范化、流程化~~&lt;/p&gt;
&lt;p&gt;       然而我渐渐的发现了，此刻我不是个单纯的应用型运维，这简直就是啥活都干的功能型运维吖！好吧，既来之，则安之！干着干着，事儿慢慢就多了，譬如：Hi，Gitlab给开个账号；Hi，Gitlab给开个权限；Hi，项目接口502了；Hi，Web页面404了；Hi，项目加个代理；Hi，项目日志哪里看；Hi，这个项目上个预发；Hi，新建个项目环境；Hi，项目上个线~~等等，然后同事的内部访问地址异常了找你给配个DNS；SourceTree拉代码异常了找你给解决下；新同事入职了装些软件给支持一波~~~然后我自我安慰的告诉自己：这是一个认识小哥哥、小姐姐的机会，嗯，不错！&lt;/p&gt;
&lt;p&gt;       话说，不想当将军的士兵不是好士兵，Nice！于是乎，虽然我是一颗螺丝钉，却有着一个顶梁柱的梦~~所以，带着严谨性和责任心默默地耕耘在平凡的岗位上，尽自己的能力去规范化、流程化整个持续集成的运维体系及运作方式，尽自己的努力去将运维流程的自动化做到最大化。当然，这不仅是岗位价值的体现，更重要的是提高工作效率和工作质量，方便了大家的同时也提升了自我！&lt;/p&gt;
&lt;p&gt;       哦，对了，聊正事了。部门做的是app项目，绝大多数项目都是以war包的形式部署到Tomcat中，而当大量新项目的产生，涉及到服务部署、项目迁移等，最让人头疼的问题就是环境的一致性问题。为了删繁就简，于是乎，在老大的默许下，用上了Docker（测试环境）。通过Jenkins+Harbor+Tomcat+Docker+Nginx等服务衔接，配合自己写的Docker容器项目部署脚本，基本实现了个小小的自动化，在实现功能的同时简化了大量环境一致性的操作。因项目需多次更新代码重启服务进行调试，故容器的删除与启动较为频繁，脚本的大致思路是跑a项目容器前，先判断其是否已经在运行，若是，则彻底删除容器并更新代码重新启动，若项目容器是第一次启动，则随机生成映射端口，启动后将服务映射的端口记录到指定文件，当同一个项目需更新代码重新启动容器时，将到记录文件中调用记录的映射端口作为重新启动容器时的映射信息，即保证了容器重新生成的映射端口与第一次的生成信息的一致性！当然，目前只是单纯的用docker，后续估计要慢慢的用上编排工具Kubernetes~~~&lt;/p&gt;
&lt;p&gt;       诶呀！扯了辣么多，不知道读者有没有看晕，反正我差点给自己写晕了~~&lt;/p&gt;
&lt;p&gt;       目前个人工作的运维状况及运维体系大致就是这些了，不知道是不是也有和我感同身受的同僚，希望看了博文的技术小哥小姐们给个鼓励，同时，更希望的是有技术大佬能给一些建议和指教，站在现有的运维基底，怎么让运维体系更具自动化？更有B格范儿？傲娇的小眼神期望着你呢！哼哼哼~~&lt;/p&gt;
&lt;p&gt;       最后来一句：打酱油，我是认真滴！&lt;/p&gt;
&lt;p&gt;       Thank you ！&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:21:00 +0000</pubDate>
<dc:creator>卡子火</dc:creator>
<og:description>光阴似箭，日月如梭！弹指间，回首想想，进公司的时间也不短了。在平凡的岗位上默默地耕耘着，似乎是那么不起眼~~但作为一颗螺丝钉，我要大声的告诉自己：螺丝钉也能有自己的价值体现！ 于是乎，三省吾身！ 几千</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kazihuo/p/9863894.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 开发并部署到Ubuntu - Hubert_Biyo</title>
<link>http://www.cnblogs.com/HubertBiyo/p/9863506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HubertBiyo/p/9863506.html</guid>
<description>


&lt;p&gt;涉及：Asp.Net Core Webapi    Ubuntu服务器   Nginx代理&lt;/p&gt;

&lt;h3&gt;Asp.Net Core WebApi 开发&lt;/h3&gt;
&lt;p&gt;创建Asp.Net Core WebApi程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027161729165-1677895855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 创建一个简单的测试案例就可以了，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Hubert.Api.Demo.Controllers
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController : BaseController
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: api/Demo&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: api/Demo/5&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST: api/Demo&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Post([FromBody] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PUT: api/Demo/5&lt;/span&gt;
        [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Put(&lt;span&gt;int&lt;/span&gt; id, [FromBody] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE: api/ApiWithActions/5&lt;/span&gt;
        [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;BaseController  代码  这里可以写一些公共的方法参数等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Hubert.Api.Demo.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseController : ControllerBase
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发布Asp.Net Core WebApi程序&lt;/p&gt;
&lt;p&gt;可以先测试一下  部署到IIS需要安装 AspNetCoreModule  并且应用池设置无托管即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027163619608-153293279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;部署Asp.Net Core WebApi 到Ubuntu服务器&lt;/h3&gt;

&lt;p&gt;首先安装Asp.Net Core SDK  &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &amp;gt; microsoft.gpg&lt;/span&gt;
sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/&lt;span&gt;microsoft.gpg
sudo sh &lt;/span&gt;-c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo &quot;deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-bionic-prod bionic main&quot; &amp;gt; /etc/apt/sources.list.d/dotnetdev.list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; install apt-transport-&lt;span&gt;https
sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt;&lt;span&gt; update
sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; install dotnet-sdk-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看DotNet版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dotnet --version
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上传发布文件到Ubuntu&lt;/p&gt;
&lt;p&gt;创建文件夹命令  mkdir     上传文件 rz     &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027164559910-1270887411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027164658098-240185368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传成功之后  运行该程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027165227382-1197085102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过Http://Ip地址：5005  测试访问&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027165347018-1305177968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;安装Nginx并对其做相应配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;安装Nginx

sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt;&lt;span&gt; install nginx


查看Nginx版本

nginx &lt;/span&gt;-&lt;span&gt;v

启动nginx 或者重启nginx

service nginx start

service nginx restart

如果端口号被占用则会提示
nginx: [emerg] &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; directive &lt;span&gt;is&lt;/span&gt; not allowed here &lt;span&gt;in&lt;/span&gt; /etc/nginx/sites-enabled/&lt;span&gt;default&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt;
nginx: configuration file &lt;/span&gt;/etc/nginx/&lt;span&gt;nginx.conf test failed

这个时候你需要 查看端口是否被占用
netstat &lt;/span&gt;-&lt;span&gt;ntpl

杀死这个进程 
kill  关于80端口的进程
然后在启动nginx就可以啦&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建一个关于dotnetcore webapi的配置文件；我这里已经创建好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027170909381-1500081076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 输入命令vi  编辑这个配置文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027171043213-1952552003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还需要在nginx配置文件中引入Hosts文件夹的配置&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027171351657-1724746764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在http里配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
include /etc/nginx/hosts&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027171526200-183234316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后重启nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service nginx restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过域名访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027231040156-331278972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>Hubert_Biyo</dc:creator>
<og:description>涉及：Asp.Net Core Webapi Ubuntu服务器 Nginx代理 Asp.Net Core WebApi 开发 创建Asp.Net Core WebApi程序 创建一个简单的测试案例就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HubertBiyo/p/9863506.html</dc:identifier>
</item>
<item>
<title>学好数据结构和算法 —— 复杂度分析 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9863168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9863168.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;复杂度也称为渐进复杂度&lt;span&gt;，包括渐进时间复杂度和渐进空间复杂度&lt;span&gt;，描述算法随数据规模变化而逐渐变化的趋势&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;复杂度分析是评估算法好坏的基础理论方法，所以掌握好复杂度分析方法是很有必要的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先，学习数据结构是为了解决“快”和“省”的问题，那么如何去评估算法的速度快和省空间呢？这就需要掌握时间和空间复杂度分析。同一段代码运行在不同环境、不同配置机器、处理不同量级数据…效率肯定不会相同。时间复杂度和空间复杂度是不运行代码，从理论上粗略估计算法执行效率的方法。时间复杂度&lt;span&gt;一般用O来表示，如下例子：计算1,2,3…n的和。CPU执行每行代码时间很快，假设每行执行时间都一样&lt;span&gt;为&lt;span&gt;unit_time，第2行为一个&lt;span&gt;unit_time，第3、4行都执行了n遍，那么下面这段代码执行的耗时时间可以这么计算：(1+2*n) * unit_time。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     &lt;span&gt;public &lt;span&gt;int sum(&lt;span&gt;int&lt;span&gt; n) {
&lt;span&gt;2         &lt;span&gt;int sum = 0&lt;span&gt;;
&lt;span&gt;3         &lt;span&gt;for (&lt;span&gt;int i = 1; i &amp;lt;= n; i++&lt;span&gt;) {
&lt;span&gt;4             sum = sum +&lt;span&gt; i;
&lt;span&gt;5 &lt;span&gt;        }
&lt;span&gt;6         &lt;span&gt;return&lt;span&gt; sum;
&lt;span&gt;7     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似的再看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1     &lt;span&gt;public &lt;span&gt;int sum(&lt;span&gt;int&lt;span&gt; n) {
&lt;span&gt; 2         &lt;span&gt;int sum = 0&lt;span&gt;;
&lt;span&gt; 3         &lt;span&gt;int i = 1&lt;span&gt;;
&lt;span&gt; 4         &lt;span&gt;int&lt;span&gt; j;
&lt;span&gt; 5         &lt;span&gt;for (; i &amp;lt;= n; i++&lt;span&gt;) {
&lt;span&gt; 6             j = 1&lt;span&gt;;
&lt;span&gt; 7             &lt;span&gt;for (; j &amp;lt;= n; j++&lt;span&gt;) {
&lt;span&gt; 8                 sum = sum + i *&lt;span&gt; j;
&lt;span&gt; 9 &lt;span&gt;            }
&lt;span&gt;10 &lt;span&gt;        }
&lt;span&gt;11         &lt;span&gt;return&lt;span&gt; sum;
&lt;span&gt;12     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第2、3、4行分别执行执行了一次，时间为3unit_time，第5、6两行循环了n次为2n * unit_time，第7、8两行执行了n*n次为(n²) * unit_time，所以总的执行时间为：(2n²+2n+3) * unit_time&lt;/p&gt;
&lt;p&gt;可以看出来，所有代码执行时间T(n)与每行代码执行次数成正比。可以用如下公式来表示：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;T(n) = O(f(n))&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;T(n)表示代码的执行时间；&lt;/p&gt;
&lt;p&gt;n表示数据规模大小；&lt;/p&gt;
&lt;p&gt;f(n)表示每行代码执行的次数和，是一个表达式；&lt;/p&gt;
&lt;p&gt;O表示执行时间T(n)和f(n)表达式成正比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么上面两个时间复杂度可以表示为：&lt;/p&gt;
&lt;p&gt;T(n) = O&lt;span&gt;(1+2*n) 和 T(n) = O(2n²+2n+3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实际上O并不表示具体的执行时间，只是表示代码执行时间随数据规模变化的趋势，所以时间复杂度实际上是渐进时间复杂度的简称。当n很大时，系数对结果的影响很小可以忽略，上面两个例子的时间复杂度可以粗略简化为：&lt;/p&gt;
&lt;p&gt;T(n) = O&lt;span&gt;(n) 和 T(n) = O(n²)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为时间复杂度是表示的一种趋势，所以常常忽略常量、低阶、系数，只需要最大阶量级就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;分析时间复杂度的几个常见法则&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;1、只关注代码执行最多的一段代码&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;上面例子可以看出，复杂度忽略了低阶、常量和系数，所以执行最多的那一段最能表达时间复杂度的趋势。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2、加法法则：总复杂度等于各部分求和，然后取复杂度量级最高的&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;还是上面的例子，总的时间复杂度等于各部分代码时间复杂度的和，求和之后再用最能表达趋势的项来表示整段代码的时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;3、乘法法则：嵌套代码复杂度等于嵌套内外代码复杂度的乘积&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;上面第二段代码，j 循环段嵌套在 i 循环内部，所以 j 循环体内的时间复杂度等于单独 i 的时间复杂度乘以单独 j 的时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;常见的时间复杂度表示&lt;/h3&gt;
&lt;p&gt;常见的复杂度有以下几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;常量阶：O(1)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对数阶：O(logn)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线性阶：O(n)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;线性对数阶：O(nlogn)&lt;/li&gt;
&lt;li&gt;平方阶：O(n²)、立方阶O(n³)……&lt;/li&gt;
&lt;li&gt;指数阶：O(2ⁿ)&lt;/li&gt;
&lt;li&gt;阶乘阶：O(n!)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以这么来理解：如果一段代码有1000或10000行甚至更多，行数是一个常量，不会随着数据规模增大而变化，我们就认为时间复杂度为一个常量，用O(1)表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这几种复杂度效率曲线比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181027205420068-1393583158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟一个数组动态扩容例子，如果数组长度够，直接往里面插入一条数据；反之，将数组扩充一倍，然后往里面插入一条数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; arr.length;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; item) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] new_arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[len * 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 new_arr[i] =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             arr =&lt;span&gt; new_arr;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             len =&lt;span&gt; arr.length;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         arr[i] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;最好时间复杂度（best case time complexity）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;最好情况下某个算法的时间复杂度。最好情况下，数组空间足够，只需要执行插入数据就可以了，此时时间复杂度是O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;最坏时间复杂度(worst case time complexity)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;最坏情况下某个算法的时间复杂度。最坏情况下数组满了，需要先申请一个空间为原来两倍的数组，然后将数据拷贝进去，此时时间复杂度为O(n)。一般情况下我们说算法复杂度就是指的最坏情况时间复杂度，因为算法时间复杂度不会比最坏情况复杂度更差了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;平均时间复杂度(average case time complexity)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;最好时间复杂度和最坏时间复杂度都是极端情况下的时间复杂度，发生的概率并不算很大。平均时间复杂度是描述各种情况下平均的时间复杂度。上面的动态扩容例子将1到n+1次为一组来分析，前面n次的时间复杂度都是1，第n+1次时间复杂度是n，将一个数插入数组里的1 至 (n+1)个位置概率都为1/(n+1)，所以平均时间复杂度为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　O(n) = (1 + 1 + 1 + …+n)/(n+1) = O(1)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;均摊时间复杂度(amortized time complexity)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连续的关系。并且和这组数据类型的情况循环往复出现，这时候可以将这一组数据作为一个整体来分析，看看是否可以将最后一个耗时的操作复杂度均摊到其他的操作上，如果可以，那么这种分析方法就是均摊时间复杂度分析法。上面的例子来讲，第n+1次插入数据时候，数组刚好发生扩容，时间复杂度为O(n)，前面n次刚好将数组填满，每次时间复杂度都为O(1)，此时可以将第n+1次均摊到前面的n次上去，所以总的均摊时间复杂度还是O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;空间复杂度&lt;/h2&gt;
&lt;p&gt; 类比时间复杂度，&lt;span&gt;如下代码所示，第2行申请了一个长度为n的数据，第三行申请一个变量i为常量可以忽略，所以空间复杂度为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (; i &amp;lt; n; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             arr[i] = i + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:04:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>复杂度也称为渐进复杂度，包括渐进时间复杂度和渐进空间复杂度，描述算法随数据规模变化而逐渐变化的趋势。复杂度分析是评估算法好坏的基础理论方法，所以掌握好复杂度分析方法是很有必要的。 时间复杂度 首先，学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9863168.html</dc:identifier>
</item>
</channel>
</rss>