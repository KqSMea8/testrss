<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>React router动态加载组件-适配器模式的应用 - 我是leon</title>
<link>http://www.cnblogs.com/walls/p/9632541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walls/p/9632541.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文讲述怎么实现动态加载组件，并借此阐述适配器模式。&lt;/p&gt;
&lt;h2 id=&quot;一普通路由例子&quot;&gt;一、普通路由例子&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import Center from 'page/center';
import Data from 'page/data';

function App(){
    return (
        &amp;lt;Router&amp;gt;
          &amp;lt;Switch&amp;gt;
            &amp;lt;Route exact path=&quot;/&quot; render={() =&amp;gt; (&amp;lt;Redirect to=&quot;/center&quot; /&amp;gt;)} /&amp;gt;
            &amp;lt;Route path=&quot;/data&quot; component={Data} /&amp;gt;
            &amp;lt;Route path=&quot;/center&quot; component={Center} /&amp;gt;
            &amp;lt;Route render={() =&amp;gt; &amp;lt;h1 style={{ textAlign: 'center', marginTop: '160px', color:'rgba(255, 255, 255, 0.7)' }}&amp;gt;页面不见了&amp;lt;/h1&amp;gt;} /&amp;gt;
          &amp;lt;/Switch&amp;gt;
        &amp;lt;/Router&amp;gt;
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是最常见的&lt;code&gt;React router&lt;/code&gt;。在简单的单页应用中，这样写是ok的。因为打包后的单一js文件&lt;code&gt;bundle.js&lt;/code&gt;也不过200k左右，&lt;code&gt;gzip&lt;/code&gt;之后，对加载性能并没有太大的影响。&lt;br/&gt;但是，当产品经历多次迭代后，追加的页面导致&lt;code&gt;bundle.js&lt;/code&gt;的体积不断变大。这时候，优化就变得很有必要。&lt;/p&gt;
&lt;h2 id=&quot;二如何优化&quot;&gt;二、如何优化&lt;/h2&gt;
&lt;p&gt;优化使用到的一个重要理念就是——&lt;strong&gt;按需加载&lt;/strong&gt;。&lt;br/&gt;可以结合例子进行理解为：只加载当前页面需要用到的组件。&lt;/p&gt;
&lt;p&gt;比如当前访问的是&lt;code&gt;/center&lt;/code&gt;页，那么只需要加载&lt;code&gt;Center&lt;/code&gt;组件即可。不需要加载&lt;code&gt;Data&lt;/code&gt;组件。&lt;/p&gt;
&lt;p&gt;业界目前实现的方案有以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;react-router的动态路由&lt;code&gt;getComponent&lt;/code&gt;方法(router4已不支持)&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/jamiebuilds/react-loadable&quot;&gt;react-loadable&lt;/a&gt;小工具库&lt;/li&gt;
&lt;li&gt;自定义高阶组件进行按需加载&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而这些方案共通的点，就是利用webpack的&lt;code&gt;code splitting&lt;/code&gt;功能（&lt;em&gt;webpack1使用&lt;code&gt;require.ensure&lt;/code&gt;，webpack2/webpack3使用&lt;code&gt;import&lt;/code&gt;&lt;/em&gt;），将代码进行分割。&lt;/p&gt;
&lt;p&gt;接下来，将介绍如何用自定义高阶组件实现按需加载。&lt;/p&gt;
&lt;h2 id=&quot;三自定义高阶组件&quot;&gt;三、自定义高阶组件&lt;/h2&gt;
&lt;h3 id=&quot;webpack的import方法&quot;&gt;3.1 webpack的import方法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;webpack将&lt;code&gt;import()&lt;/code&gt;看做一个分割点并将其请求的module打包为一个独立的chunk。&lt;code&gt;import()&lt;/code&gt;以模块名称作为参数名并且返回一个&lt;strong&gt;Promise对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;import()&lt;/code&gt;返回的是Promise对象，所以不能直接给&lt;code&gt;&amp;lt;Router/&amp;gt;&lt;/code&gt;使用。&lt;/p&gt;
&lt;h3 id=&quot;采用适配器模式封装import&quot;&gt;3.2 采用适配器模式封装import()&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;（Adapter）:将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前场景，需要解决的是，使用&lt;code&gt;import()&lt;/code&gt;异步加载组件后，如何将加载的组件交给React进行更新。&lt;br/&gt;方法也很容易，就是利用&lt;code&gt;state&lt;/code&gt;。当异步加载好组件后，调用&lt;code&gt;setState&lt;/code&gt;方法，就可以通知到。&lt;br/&gt;那么，依照这个思路，新建个高阶组件，运用&lt;code&gt;适配器模式&lt;/code&gt;，来对&lt;code&gt;import()&lt;/code&gt;进行封装。&lt;/p&gt;
&lt;h3 id=&quot;实现异步加载方法asynccomponent&quot;&gt;3.3 实现异步加载方法asyncComponent&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react';

export const asyncComponent = loadComponent =&amp;gt; (

    class AsyncComponent extends React.Component {
        constructor(...args){
            super(...args);
    
            this.state = {
                Component: null,
            };

            this.hasLoadedComponent = this.hasLoadedComponent.bind(this);
        }
        componentWillMount() {
            if(this.hasLoadedComponent()){
                return;
            }
    
            loadComponent()
                .then(module =&amp;gt; module.default ? module.default : module)
                .then(Component =&amp;gt; {
                    this.setState({
                        Component
                    });
                })
                .catch(error =&amp;gt; {
                    /*eslint-disable*/
                    console.error('cannot load Component in &amp;lt;AsyncComponent&amp;gt;');
                    /*eslint-enable*/
                    throw error;
                })
        }
        hasLoadedComponent() {
            return this.state.Component !== null;
        }
        render(){
            const {
                Component
            } = this.state;

            return (Component) ? &amp;lt;Component {...this.props} /&amp;gt; : null;
        }
    }
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 使用方式 

const Center = asyncComponent(()=&amp;gt;import(/* webpackChunkName: 'pageCenter' */'page/center'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如例子所示，新建一个&lt;code&gt;asyncComponent&lt;/code&gt;方法，用于接收&lt;code&gt;import()&lt;/code&gt;返回的Promise对象。&lt;br/&gt;当&lt;code&gt;componentWillMount&lt;/code&gt;时（服务端渲染也有该生命周期方法），执行&lt;code&gt;import()&lt;/code&gt;，并将异步加载的组件，&lt;code&gt;set&lt;/code&gt;入&lt;code&gt;state&lt;/code&gt;，触发组件重新渲染。&lt;/p&gt;
&lt;h3 id=&quot;释疑&quot;&gt;3.4 释疑&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;state.Component初始化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;this.state = {
    Component: null,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;null&lt;/code&gt;，主要用于判断异步组件是否已经加载。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;module.default ? module.default : module&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里是为了兼容&lt;code&gt;具名&lt;/code&gt;和&lt;code&gt;default&lt;/code&gt;两种&lt;code&gt;export&lt;/code&gt;写法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;return (Component) ? &amp;lt;Component {...this.props} /&amp;gt; : null;&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的&lt;code&gt;null&lt;/code&gt;，其实可以用&lt;code&gt;&amp;lt;LoadingComponent /&amp;gt;&lt;/code&gt;代替。作用是：当异步组件还没加载好时，起到占位的作用。&lt;br/&gt;&lt;code&gt;this.props&lt;/code&gt;是通过&lt;code&gt;AsyncComponent&lt;/code&gt;组件透传给异步组件的。&lt;/p&gt;
&lt;h3 id=&quot;修改webpack构建&quot;&gt;3.5 修改webpack构建&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;output: {
    path: config.build.assetsRoot,
    filename: utils.assetsPath('js/[name].[chunkhash].js'),
    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在输出项中，增加&lt;code&gt;chunkFilename&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;
&lt;p&gt;自定义高阶组件的好处，是可以按最少的改动，来优化已有的旧项目。&lt;br/&gt;像上面的例子，只需要改变&lt;code&gt;import&lt;/code&gt;组件的方式即可。花最少的代价，就可以得到页面性能的提升。&lt;br/&gt;其实，&lt;code&gt;react-loadable&lt;/code&gt;也是按这种思路去实现的，只不过增加了很多附属的功能点而已。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26228500&quot;&gt;基于webpack Code Splitting实现react组件的按需加载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000009820646&quot;&gt;react中使用webpack2的import()异步加载组件的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 11 Sep 2018 23:50:00 +0000</pubDate>
<dc:creator>我是leon</dc:creator>
<og:description>前言 本文讲述怎么实现动态加载组件，并借此阐述适配器模式。 一、普通路由例子 以上是最常见的 。在简单的单页应用中，这样写是ok的。因为打包后的单一js文件 也不过200k左右， 之后，对加载性能并没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walls/p/9632541.html</dc:identifier>
</item>
<item>
<title>Nginx（四）------nginx 负载均衡 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9392912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9392912.html</guid>
<description>&lt;p&gt;　　在上一篇博客我们介绍了 Nginx 一个很重要的功能——代理，包括正向代理和反向代理。这两个代理的核心区别是：正向代理代理的是客户端，而反向代理代理的是服务器。其中我们又重点介绍了反向代理，以及如何通过 Nginx 来实现反向代理。那么了解了Nginx的反向代理之后，我们要通过Nginx的反向代理实现另一个重要功能——负载均衡。&lt;/p&gt;
&lt;h3&gt;1、负载均衡的由来&lt;/h3&gt;
&lt;p&gt;　　早期的系统架构，基本上都是如下形式的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908121550571-375749058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。&lt;/p&gt;
&lt;p&gt;　　这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？&lt;/p&gt;
&lt;p&gt;　　我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/7641540.html&quot; target=&quot;_blank&quot;&gt;摩尔定律&lt;/a&gt;的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？&lt;/p&gt;
&lt;p&gt;　　上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的&lt;strong&gt;负载均衡&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908131139969-1777205215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　负载均衡完美的解决了单个服务器硬件性能瓶颈的问题，但是随着而来的如何实现负载均衡呢？客户端怎么知道要将请求发送到那个服务器去处理呢？&lt;/p&gt;
&lt;h3&gt;2、Nginx实现负载均衡&lt;/h3&gt;
&lt;p&gt;　　Nginx 服务器是介于客户端和服务器之间的中介，通过上一篇博客讲解的反向代理的功能，客户端发送的请求先经过 Nginx ，然后通过 Nginx 将请求根据相应的规则分发到相应的服务器。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908131700302-1529457842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　主要配置指令为上一讲的 pass_proxy 指令以及 upstream 指令。负载均衡主要通过专门的硬件设备或者软件算法实现。通过硬件设备实现的负载均衡效果好、效率高、性能稳定，但是成本较高。而通过软件实现的负载均衡主要依赖于均衡算法的选择和程序的健壮性。均衡算法又主要分为两大类：&lt;/p&gt;
&lt;p&gt;　　静态负载均衡算法：主要包括轮询算法、基于比率的加权轮询算法或者基于优先级的加权轮询算法。&lt;/p&gt;
&lt;p&gt;　　动态负载均衡算法：主要包括基于任务量的最少连接优化算法、基于性能的最快响应优先算法、预测算法及动态性能分配算法等。&lt;/p&gt;
&lt;p&gt;　　静态负载均衡算法在一般网络环境下也能表现的比较好，动态负载均衡算法更加适用于复杂的网络环境。&lt;/p&gt;
&lt;p&gt;　　例子：&lt;/p&gt;
&lt;h4&gt;①、普通轮询算法&lt;/h4&gt;
&lt;p&gt;　　这是Nginx 默认的轮询算法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
例子：两台相同的Tomcat服务器，通过 localhost:8080 访问Tomcat1，通过 localhost:8081访问Tomcat2，现在我们要输入 localhost 这个地址，可以在这两个Tomcat服务器之间进行交替访问。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一、分别修改两个Tomcat服务器的端口为8080和8081。然后再修改Tomcat的首页，使得访问这两个页面时能够区分。如下：&lt;/p&gt;
&lt;p&gt;　　修改端口号文件为 server.xml ：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908145855894-2044798993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修改首页的路径为：webapps/ROOT/index.jsp&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908150006858-630938275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修改完成之后，分别启动这两个Tomcat服务器，然后分别输入相应的地址端口号：&lt;/p&gt;
&lt;p&gt;　　输入地址：localhost:8081&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908150514476-1375755078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　输入地址：localhost:8080&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908150452914-866570966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　二、修改 nginx 的配置文件 nginx.conf &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    upstream OrdinaryPolling {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     server 127.0.0.1:8080&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     server 127.0.0.1:8081&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OrdinaryPolling;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三、启动 nginx。然后在浏览器输入localhost 地址，观看页面变化：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908152509125-1859907953.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②、基于比例加权轮询&lt;/h4&gt;
&lt;p&gt;　　上述两台Tomcat服务器基本上是交替进行访问的。但是这里我们有个需求：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;由于Tomcat1服务器的配置更高点，我们希望该服务器接受更多的请求，而 Tomcat2 服务器配置低，希望其处理相对较少的请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　那么这时候就用到了加权轮询机制了。&lt;/p&gt;
&lt;p&gt;　　nginx.conf 配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    upstream OrdinaryPolling {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     server 127.0.0.1:8080 weight=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     server 127.0.0.1:8081 weight=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OrdinaryPolling;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实对比上面不加权的轮询方式，这里在 upstream 指令中多了一个 weight 指令。该指令用于配置前面请求处理的权重，默认值为 1。&lt;/p&gt;
&lt;p&gt;　　也就是说：第一种不加权的普通轮询，其实其加权值 weight 都为 1。&lt;/p&gt;
&lt;p&gt;　　下面我们看页面相应结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180908153300294-418662600.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　明显 8080 端口号出现的次数更多，试验的次数越多越接近我们配置的比例。&lt;/p&gt;
&lt;h4&gt;③、基于IP路由负载&lt;/h4&gt;
&lt;p&gt;　　我们知道一个请求在经过一个服务器处理时，服务器会保存相关的会话信息，比如session，但是该请求如果第一个服务器没处理完，通过nginx轮询到第二个服务器上，那么这个服务器是没有会话信息的。&lt;/p&gt;
&lt;p&gt;　　最典型的一个例子：用户第一次进入一个系统是需要进行登录身份验证的，首先将请求跳转到Tomcat1服务器进行处理，登录信息是保存在Tomcat1 上的，这时候需要进行别的操作，那么可能会将请求轮询到第二个Tomcat2上，那么由于Tomcat2 没有保存会话信息，会以为该用户没有登录，然后继续登录一次，如果有多个服务器，每次第一次访问都要进行登录，这显然是很影响用户体验的。&lt;/p&gt;
&lt;p&gt;　　这里产生的一个问题也就是集群环境下的 session 共享，如何解决这个问题？&lt;/p&gt;
&lt;p&gt;　　通常由两种方法：&lt;/p&gt;
&lt;p&gt;　　1、第一种方法是选择一个中间件，将登录信息保存在一个中间件上，这个中间件可以为 Redis 这样的数据库。那么第一次登录，我们将session 信息保存在 Redis 中，跳转到第二个服务器时，我们可以先去Redis上查询是否有登录信息，如果有，就能直接进行登录之后的操作了，而不用进行重复登录。&lt;/p&gt;
&lt;p&gt;　　2、第二种方法是根据客户端的IP地址划分，每次都将同一个 IP 地址发送的请求都分发到同一个 Tomcat 服务器，那么也不会存在 session 共享的问题。&lt;/p&gt;
&lt;p&gt;　　而 nginx 的基于 IP 路由负载的机制就是上诉第二种形式。大概配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    upstream OrdinaryPolling {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    ip_hash;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     server 127.0.0.1:8080 weight=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     server 127.0.0.1:8081 weight=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OrdinaryPolling;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：我们在 upstream 指令块中增加了 ip_hash 指令。该指令就是告诉 nginx 服务器，同一个 IP 地址客户端发送的请求都将分发到同一个 Tomcat 服务器进行处理。&lt;/p&gt;
&lt;h4&gt;④、基于服务器响应时间负载分配&lt;/h4&gt;
&lt;p&gt;　　根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    upstream OrdinaryPolling {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     server 127.0.0.1:8080 weight=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     server 127.0.0.1:8081 weight=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    fair;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OrdinaryPolling;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过增加了 fair 指令。&lt;/p&gt;
&lt;h4&gt;⑤、对不同域名实现负载均衡&lt;/h4&gt;
&lt;p&gt; 　　通过配合location 指令块我们还可以实现对不同域名实现负载均衡。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    upstream wordbackend {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     server 127.0.0.1:8080&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     server 127.0.0.1:8081&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    upstream pptbackend {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     server 127.0.0.1:8082&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     server 127.0.0.1:8083&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        server_name  localhost;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         location /word/&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wordbackend;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     location /ppt/&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pptbackend;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 11 Sep 2018 23:39:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Nginx（四）------nginx 负载均衡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9392912.html</dc:identifier>
</item>
<item>
<title>Linux桌面玩家装B指南：03.针对Gnome 3的Linux桌面进行美化 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop003.html</guid>
<description>&lt;h2 id=&quot;特别说明&quot;&gt;特别说明&lt;/h2&gt;
&lt;p&gt;要在我的随笔后写评论的小伙伴们请注意了：我的博客是使用 Markdown 编写的，并且启用了 MathJax 数学公式支持。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，则 MathJax 会认为这两个&lt;code&gt;$&lt;/code&gt;之间的内容是数学公式，从而出现格式混乱。如果大家确定自己写的评论不是数学公式，请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;四年前，我写了一篇 &lt;a href=&quot;https://www.cnblogs.com/youxia/p/linux012.html&quot;&gt;Linux 桌面美化那点事儿&lt;/a&gt;，是基于 Ubuntu 14.04 的，那时 Ubuntu 还是使用的 Unity 桌面。在四年的时间里，这篇随笔获得了大约 60000 的访问量，我甚是欣慰。世易时移，情随事迁，Ubuntu 目前的发行版已经放弃了 Unity 桌面，回归到了 Gnome 3，以前的美化方案就不太适用了。在这一篇中，我将针对 Gnome 3，讲一讲 Linux 桌面的美化思路。&lt;/p&gt;
&lt;p&gt;Linux 桌面的美化是非常必要的，我认为，不谈美化而劝人使用Linux桌面都是耍流氓。就算你把 Linux 桌面说得天花乱坠，别人安装完一看，不漂亮不顺眼不 professional，就不会再继续用下去了。Ubuntu 和 Fedora 的桌面已经算是比较美观的了，但是世上没有完美的系统，只有按照自己的想法进行改进，才能获得比较舒服的体验。&lt;/p&gt;
&lt;p&gt;Gnome 3 桌面的美化可以从以下几个方面着手：&lt;/p&gt;
&lt;p&gt;1、主题和扩展。可以通过访问网站 &lt;a href=&quot;https://www.gnome-look.org/&quot; class=&quot;uri&quot;&gt;https://www.gnome-look.org/&lt;/a&gt; 来查看和下载主题。在 Gnome 3 中，主要需要考虑的是 gnome-shell 主题、GTK 3 主题和图标主题。在 Ubuntu 中，默认的主题已经很不错了，所以我一般不改。Fedora 默认的主题稍差，那种比较 low 的灰灰的 3D 质感我并不喜欢，所以我往往会把它改成简单的、扁平的样式。在网络上，还有不少通过修改主题来让 Linux 桌面变成和 Mac OS 一样的外观，这种一味的模仿我并不喜欢，但确实可以试一试。另外，对于 gnome-shell，还可以安装 extensions 来扩展它的功能和进行美化，除了官方软件源中提供的 extensions，还可以访问 &lt;a href=&quot;https://extensions.gnome.org/&quot; class=&quot;uri&quot;&gt;https://extensions.gnome.org/&lt;/a&gt; 来查找最新的扩展。&lt;/p&gt;
&lt;p&gt;2、壁纸。赏心悦目的壁纸当然是可以点亮好心情的啦。看过我前面的随笔的朋友们应该会发现，我特别喜欢半透明的全屏窗口，露出后面的壁纸。所以，我收集了一大票的壁纸，然后设置为自动定时切换，怎一个爽字了得。&lt;/p&gt;
&lt;p&gt;3、字体。Linux 桌面系统的字体一直是一个历史遗留问题，当有人觉得 Linux 桌面不好看、不专业时，有很大一部分原因就是字体惹的祸。我曾经有一段时间就是因为 Redhat 的 Linux 字体发虚，而中科红旗的 Linux 字体清晰而放弃过 Redhat，甚至写过一些不正确的文章。当然，当我认识到 Linux 的字体是可以配置的后，我就把这些不正确的文章都删了。下一篇，我再专门论述 Linux 系统中字体的历史、现状以及配置方法。&lt;/p&gt;
&lt;p&gt;4、桌面小部件。一些精美的桌面小部件可以提供一些很实用的功能，同时也可以提高桌面的美化程度。由于我本人并不是特别喜欢桌面小部件，我不仅不喜欢桌面小部件，我连桌面图标都不放，所以这一部分并不做特别介绍。喜欢桌面小部件的朋友，可以了解一下 conky。&lt;/p&gt;
&lt;p&gt;5、Dock。即可以方便我们启动程序，又能在屏幕底下显示点东西，解决 Gnome 3 桌面头重脚轻的问题。在 Gnome 3 中，使用 Dash to dock 扩展就可以取得不错的效果了。如果一定要模仿苹果那样酷炫的效果，也可以选择 Cairo-dock。&lt;/p&gt;
&lt;p&gt;必须得说明的是，桌面美化是一个仁者见仁、智者见智的事。有可能你认为很美的界面，别人认为土得掉渣；有可能你认为很炫的特效，别人认为华而不实。我这里主要是为了让大家了解 Linux 桌面美化的机制，并提供一些美化思路，并不是说都让大家把桌面搞得和我一模一样。&lt;/p&gt;
&lt;h2 id=&quot;gnome-3-的特点&quot;&gt;Gnome 3 的特点&lt;/h2&gt;
&lt;p&gt;业界对 Gnome 3 桌面吹得很厉害，说它领先桌面设计领域十几年。可是对我这样的用户来讲，却总觉得 Gnome 3 默认的界面比较丑，还不流畅。这一定是我的打开方式不对。Gnome 3 究竟有哪些值得称道的地方呢？我们先来看看 &lt;a href=&quot;https://wiki.gnome.org/Projects/GnomeShell/Tour&quot;&gt;Gnome Shell 的官方 wiki&lt;/a&gt; 对它的介绍。后面的图片均来自于 Gnome Shell 的官方 wiki。&lt;/p&gt;
&lt;p&gt;首先，是它的 Desktop 界面，这是我们主要的工作区域，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907094549219-2042078209.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是一个中规中矩的桌面，应用程序的窗口显示在桌面上，只要配色和外观不要太丑，就不影响我们工作。和 Gnome 2 比，它的主要变化是去掉了桌面底部的 panel，只保留了屏幕顶部的 panel。同时，顶部 panel 中的元素也大大减少，没有类似 Windows 中开始菜单、窗口列表这样的元素，取而代之是最左边的那个 Activities 按钮。点击该按钮，就会弹出 Activities Overview 界面，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907101052780-535396928.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该界面中，左边显示的是 Dash，可以点击里面的图标启动常用的程序。中间显示的是应用程序窗口，可以查看当前打开的窗口有哪些，要切换到哪个窗口就点哪个窗口。右侧显示的是工作区，也可以通过鼠标的点击在工作区之间切换。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907101336513-954070963.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Activites Overview 界面不仅可以显示打开的窗口，还可以显示系统中安装的程序，便于启动 Dash 中没有的程序。程序都是大图标，而且有搜索功能，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907101507356-1926643556.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的展示，真不觉得 Gnome 3 有什么值得吹嘘的黑科技，如果真要说有什么先进的理念的话，大概就是对触摸屏设备的支持吧。主要表现有：1. Activites Overview 是占据整个屏幕的大界面，而不是像 Windows 的开始菜单那样只占据屏幕的一小部分；2.应用程序界面都是大图标，便于手指的点击；3.工作区图标也比较大，便于手指点击，也便于预览每个工作区中有哪些窗口。&lt;/p&gt;
&lt;p&gt;而我们桌面用户不一样，桌面用户依赖的是键盘和鼠标的输入，可以精准点击，对大图标没有多少依赖。如果能熟练使用快捷键，对 Gnome 3 的使用体验也是可以提升不少的。例如，不用点 Activities 按钮，按 Super 键（也就是键盘上的 Win 键）也可以调出 Activites Overview 界面。有一个比较人性化的功能是 Gnome 3 的工作区是动态工作区，只要占满了现有的工作区，它就会马上自动建立一个新工作区，省掉了我们自己建工作区的操作。在工作区之间切换，也可以使用快捷键，Ctrl+Alt+↑ 和 Ctrl+Alt+↓。最后，在窗口间切换也可以使用快捷键 Alt+Tab。窗口切换的效果如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907104045823-610908728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以上的内容还是不足以说明 Gnome Shell 有多优秀啊。我们继续挖掘 Gnome Shell 背后的技术。&lt;a href=&quot;https://wiki.gnome.org/Projects/GnomeShell/Technology&quot;&gt;Gnome Shell 的技术架构&lt;/a&gt;是这样的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907105035591-2115485553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来整个 Gnome Shell 都建立在 OpenGL 之上，这么说来性能应该是杠杠的了，使用显卡加速应该是妥妥的了。在 OpenGL 之上，建立了 Clutter 图形库，在 Clutter 之上，建立了 mutter 窗口管理器和 Shell Toolkit，而且 Shell Toolkit 是可以使用 CSS 定义外观的。再往上，还建立了一个 JavaScript 引擎和 gobject-introspection，这样就可以使用 JavaScript 来操控 Gnome Shell。原来黑科技藏在这里呢，我心里舒服多了。而且这一整条技术栈都是可以学习的，我们程序员的玩具又多了一种。&lt;/p&gt;
&lt;h2 id=&quot;ubuntu中的-gnome-3-桌面存在的问题&quot;&gt;Ubuntu中的 Gnome 3 桌面存在的问题&lt;/h2&gt;
&lt;p&gt;看完 Gnome Shell 的官方介绍，我们再回到亲爱的 Ubuntu。Ubuntu 这个发行版是已经对这个桌面做过一定美化的，而且 Ubuntu 一直都是那种暖红色的主题，还是比较讨人喜欢的，我就很喜欢 Eclipse 在 Ubuntu 中的表现。但是，Ubuntu 的桌面还是有不少需要改进的地方。见下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907151853433-1487768450.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;①左侧的 Dash。Ubuntu 的传统特色，也是我每次都要去掉的特色。Dash 虽然方便，但是屏幕左边缘被占掉这一条空间还是令人不爽的，而且和右边缘不对称。而且 Dash 的配色并不一定总能和桌面上的工作窗口保持同样的风格，所以有时看起来比较突兀。在以前的 Ubuntu 版本中，我总是设置为自动掩藏，然后鼠标在屏幕左侧划过时出现。在现在的版本总，该 Dash 是由 gnome-shell-extension-ubuntu-dock 扩展提供的，可以把它删掉，也可以把它设置为显示到屏幕底部。&lt;/p&gt;
&lt;p&gt;②左上角的“活动”按钮。这个按钮很别扭，本来把“Activities”翻译成“活动”，就很有点词不达意。而且这个按钮有点多余，不要它也可以，直接使用 Super 键调出 Activities Overview 界面更方便。使用 gnome-shell-extension-hide-activities 可以把这个按钮隐藏。&lt;/p&gt;
&lt;p&gt;③桌面顶端占用空间太多。从图中可以看到，当我把一个窗口最大化后，顶部有 Gnome Shell 的 top panel，其次是窗口的标题栏（top bar），再然后是窗口的菜单栏。这几个元素就占据了桌面顶端太多的空间。解决这个问题，有两个方案，一个是把窗口的标题栏放到 top panel 中，另一个是把菜单栏放到 top panel 中。可以使用 pixelsaver 插件或者 Global Application Menu 插件。&lt;/p&gt;
&lt;p&gt;④位于 top panel 中间的时钟。为了在 top panel 中留出足够的空间，我们需要把时钟移动到右边，可以使用 Frippery Move Clock 插件。&lt;/p&gt;
&lt;p&gt;⑤头重脚轻的问题。屏幕顶端元素众多，屏幕底端啥都没有，有点头重脚轻的感觉。可以使用 Dash to dock 插件，并设置为 Dock 显示在底部。当然，也可以使用 Cairo-dock。&lt;/p&gt;
&lt;p&gt;⑥背景图片太单一的问题。我当然有背景轮换大法啦。&lt;/p&gt;
&lt;h2 id=&quot;安装gnome-shell的extension&quot;&gt;安装Gnome Shell的Extension&lt;/h2&gt;
&lt;p&gt;分析完问题，下面开始实战。先从 gnome-shell-extension 入手，我们即可以使用 Ubuntu 官方软件仓库中的 extension，也可以到 &lt;a href=&quot;https://extensions.gnome.org/&quot; class=&quot;uri&quot;&gt;https://extensions.gnome.org/&lt;/a&gt; 下载 extension。我们需要安装两个工具，gnome-tweak-tool 和 chrome-gnome-shell，前者是 Gnome 的设置工具，后者可以使我们直接在 &lt;a href=&quot;https://extensions.gnome.org/&quot; class=&quot;uri&quot;&gt;https://extensions.gnome.org/&lt;/a&gt; 的网页上安装 extension。安装这两个工具的命令如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude install gnome-tweak-tool
sudo chrome-gnome-shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;sudo aptitude search gnome-shell-extension&lt;/code&gt;命令看一下 Ubuntu 的官方软件仓库中提供哪些 extension，并打开 gnome-tweak-tool 看看 Ubuntu 已经给我们预装了哪些 extension。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180905171240923-1804766578.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个插件都不是我们想要的，把它们卸载掉吧。命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude purge gnome-shell-extenion-appindicator gnome-shell-extension-ubuntu-dock&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按 Alt+F2，输入 r，按 Enter 运行，可以重启 Gnome Shell，卸载下面两个插件后，讨厌的左边 Dash 不见了，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907203032535-461446792.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面，来看看怎么把时钟移到右边。打开 &lt;a href=&quot;https://extensions.gnome.org/&quot; class=&quot;uri&quot;&gt;https://extensions.gnome.org/&lt;/a&gt; ，搜索 Frippery Move Clock，然后打开这个 extension 的页面，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907204145768-1292919411.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先要确认一下该 extension 能够支持的 gnome-shell 版本，Ubuntu 18.04 中的 gnome-shell 是 3.28 版，所以这个 extension 是可以装的。别的 extension 也一样，如果不支持这个版本的 gnome-shell，安装就会出错。直接在网页中点右上角的按钮，就可以安装了。安装完之后，时钟自动移到了 top panel 的右边，网页中的 extension 状态也从 off 变成了 on，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907204620132-886396372.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一些插件 Ubuntu 官方仓库中的就不错，可以直接安装。例如 Hide Activities 和 pixelsaver，还有 remove dropdown arrows。使用如下命令安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude install gnome-shell-extension-hide-activities
sudo aptitude install gnome-shell-extension-pixelsaver
sudo aptitude install gnome-shell-extension-remove-dropdown-arrows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完这三个 extension，重启 gnome-shell，使用 gnome-tweak-tool 开启这三个 extension 后，效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907205706843-307872702.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，“活动”按钮隐藏起来了，以后要启动程序必须使用 Super 键了。窗口的标题栏和 top panel 合并了，节约了一行空间。唯一的遗憾是窗口的最大化、最小化和关闭按钮不是在屏幕的最右端，想关窗口的时候找起来有点费劲。不过没关系，我们可以把这三个按钮放置到窗口的左边。这真的不是为了模仿苹果哦，是这样放要关窗口的时候按起来最方便。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907210136888-1723243816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反正安装 extension 就这两种方法，后面我就不讲安装过程了，直接展示 extension 的效果。&lt;/p&gt;
&lt;p&gt;Dash to dock，解决头重脚轻的问题，将 dock 设置为显示在屏幕下方，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907210646051-846403784.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Frippery Applications Menu，显示一个类似 Windows 开始菜单的应用程序菜单，我个人认为没啥用，毕竟我们不能总是用 Windows 的习惯使用电脑嘛。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907211127525-1540927973.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Places Status Indicator，显示一个菜单，便于我们快速定位文件系统中的常用位置。我也认为这个 extension 没啥用，因为 Gnome 自带的文件管理器就有这样的快速定位功能。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907212004207-158104479.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Open Weather，显示天气功能，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907212730571-435643581.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;System Monitor，系统监控，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907212739609-1598362802.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还是认为以上两个插件没什么用。下面是 Coverflow Alt-Tab，可以使窗口切换的效果更佳酷炫，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907214247540-1577752764.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在以上我考察的 extension 中，至少有四个我认为是没有用的，它们分别是：Frippery Applications Menu、Places Status Indicator、Open Weather、System Monitor。前面两个我认为没用，是因为 Gnome 3 已经有更好的 Overview 界面和 Dash 了，文件管理器也足够好用了，没必要再来这两个菜单。后两个我认为没用，是因为我觉得在桌面美化领域，大家一直以来都严重缺乏创意，不是显示天气，就是显示系统监控，如果用 conky 搞桌面小部件，显示的也是天气、CPU、内存、文件位置什么的，真的是烂大街了。至于窗口切换的效果，我觉得要不要都无所谓，没有谁一天到晚切换窗口玩，而且我觉得 Gnome 3 的动态工作区和它的快捷键已经很好用了。&lt;/p&gt;
&lt;p&gt;所以，我的桌面最终是下面这样的，前面考察的十个 extension，我只打开了五个，而且关闭了 Dock 的自动隐藏。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180907215600530-824584043.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更改gnome-shell的主题&quot;&gt;更改Gnome Shell的主题&lt;/h2&gt;
&lt;p&gt;Ubuntu 的主题我已经觉得很漂亮了，不想改。所以我就弄个 Fedora 28 玩一玩。我一般到 &lt;a href=&quot;https://www.gnome-look.org/&quot; class=&quot;uri&quot;&gt;https://www.gnome-look.org/&lt;/a&gt; 查找主题，当然，你也可以去 github 上找。Gnome Shell 的主题很多，一个一个试总会找到自己满意的。我这里就俗一把，以网络上最常见的模仿苹果的主题来做示例吧。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909110822231-235731699.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的这几个都是模仿 MacOS 的主题，就选择 macOS High sierra 和 macOS High sierra Dark 吧，点进去，会发现这两个主题都提供 for dash to dock 和 for dash to panel 的版本，而每个版本还分为透明和不透明。这里就选择 for dash to dock 的版本吧。下载，解压缩，然后把包含主题的文件夹拷贝到&lt;code&gt;/usr/share/themes&lt;/code&gt;目录中。然后，通过 Gnome Tweak Tool 更改 Gnome Shell 的主题，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909111312164-931772834.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Top panel 的颜色改变了。当然，这还不够，我们需要所有的窗口、窗口中的控件都改变样式。这需要 GTK 3 主题。我选择的是 X Arc Collection 这一款，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909111533702-397235790.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装过程是一样的，下载、解压缩，然后拷贝到&lt;code&gt;/usr/share/themes&lt;/code&gt;目录，使用 Gnome Tweak Tool 设置 GTK 3 主题（应用程序主题），如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909111714674-1772966454.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完之后，发现窗口漂亮多了。现在，我们还缺 dock 和图标主题。至于图标主题，可以选用经典的 numix 系列。非常幸运的是，Fedora 28 的官方仓库中自带该图标主题。使用如下命令安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo dnf install numix-icon-theme numix-icon-theme-circle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909112320150-552671815.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dock 就安装 dash to dock 吧，可以在 &lt;a href=&quot;https://extensions.gnome.org/&quot; class=&quot;uri&quot;&gt;https://extensions.gnome.org/&lt;/a&gt; 中安装，也可以直接使用 Fedora 28 官方软件仓库中自带的。如果使用官方软件仓库中自带的，使用如下命令安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo dnf install gnome-shell-extension-dash-to-dock&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 dock 设置为显示在屏幕底部，并使用 numix-circle 图标主题，其效果如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909112627571-1871295976.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，Gnome Shell 的主题有亮色和暗色可以选，相应的 GTK 3 主题也有亮色和暗色可以选。一般情况下，亮色和亮色搭配，暗色和暗色搭配。如果都选择暗色，就是下面这样的效果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909112948158-157443221.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是很漂亮的，不是吗？当然，这里只是简单展示了一下修改主题，除了修改主题之外，前面提到的 Hide Activities、pixelsaver、Frippery Move Clock、Remove Dropdown Arrow 等 extension 也是可以安装的，以便于进一步提升 Fedora 28 的体验。如果说还差点什么的话，那就是桌面壁纸不那么令人满意了。下一节，我们来设置让 Gnome 3 动态切换壁纸。&lt;/p&gt;
&lt;h2 id=&quot;动态切换壁纸&quot;&gt;动态切换壁纸&lt;/h2&gt;
&lt;p&gt;所以我们需要自己去网上下载一些自己喜欢的壁纸，风景也好，美女也好，动漫也好，游戏电影 CG 也好，看自己的爱好了。壁纸的尺寸和自己屏幕的分辨率匹配最佳，这样避免壁纸在放大缩小的过程中出现失真。把下载的图片都移动到&lt;code&gt;/usr/share/backgrounds/&lt;/code&gt;目录下，因为访问权限的原因，需要使用&lt;code&gt;sudo mv&lt;/code&gt;命令，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909210656562-29826453.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Gnome 3 自带自动切换壁纸的功能，这个功能是由两个 XML 文件控制的。首先，是在&lt;code&gt;/usr/share/backgrounds/contest&lt;/code&gt;目录下需要有一个动态壁纸定义文件，它定义了有哪些壁纸参与切换，以及切换的时间和频率；其次，是&lt;code&gt;/usr/share/gnome-background-properties/&lt;/code&gt;目录下需要一个 XML 文件，只有在这里的 XML 配置文件中提到的壁纸和动态壁纸，才能在 Gnome 3 的系统设置界面中看到。&lt;/p&gt;
&lt;p&gt;先来编写&lt;code&gt;/usr/share/backgrounds/contest&lt;/code&gt;目录下的动态壁纸定义文件。进入该目录后，可以看到系统自带一个动态壁纸定义文件 bionic.xml，我们可以参考其中的内容，依葫芦画瓢编写我们自己的动态壁纸定义文件。系统自带的动态壁纸定义文件如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909154445832-1717911460.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该文件的内容非常清晰明了，它就是设置每一张壁纸先保留多少秒，然后切换到另外一张壁纸，切换过程经过几秒。我下载的壁纸比较多，要手动写一个这样的配置文件是不可能的，一个一个的输入图片的路径和名称会累死人的，所以需要一个 Bash 脚本来自动生成一个这样的配置文件。我写的生成动态壁纸配置文件的 Bash 脚本如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;files=`ls -U /usr/share/backgrounds | grep -v contest`
last_file='empty'

echo '&amp;lt;background&amp;gt;'
echo '  &amp;lt;starttime&amp;gt;'
echo '    &amp;lt;year&amp;gt;2016&amp;lt;/year&amp;gt;'
echo '    &amp;lt;month&amp;gt;07&amp;lt;/month&amp;gt;'
echo '    &amp;lt;day&amp;gt;15&amp;lt;/day&amp;gt;'
echo '    &amp;lt;hour&amp;gt;00&amp;lt;/hour&amp;gt;'
echo '    &amp;lt;minute&amp;gt;00&amp;lt;/minute&amp;gt;'
echo '    &amp;lt;second&amp;gt;00&amp;lt;/second&amp;gt;'
echo '  &amp;lt;/starttime&amp;gt;'

for current_file in $files
do
    if [[ $last_file == 'empty' ]]
    then
        last_file=$current_file
        echo '  &amp;lt;static&amp;gt;'
        echo '    &amp;lt;duration&amp;gt;300.0&amp;lt;/duration&amp;gt;'
        echo &quot;    &amp;lt;file&amp;gt;/usr/share/backgrounds/$last_file&amp;lt;/file&amp;gt;&quot;
        echo '  &amp;lt;/static&amp;gt;'
    else
        echo '  &amp;lt;transition&amp;gt;'
        echo '    &amp;lt;duration&amp;gt;5.0&amp;lt;/duration&amp;gt;'
        echo &quot;    &amp;lt;from&amp;gt;/usr/share/backgrounds/$last_file&amp;lt;/from&amp;gt;&quot;
        echo &quot;    &amp;lt;to&amp;gt;/usr/share/backgrounds/$current_file&amp;lt;/to&amp;gt;&quot;
        echo '  &amp;lt;/transition&amp;gt;'
        echo '  &amp;lt;static&amp;gt;'
        echo '    &amp;lt;duration&amp;gt;300.0&amp;lt;/duration&amp;gt;'
        echo &quot;    &amp;lt;file&amp;gt;/usr/share/backgrounds/$current_file&amp;lt;/file&amp;gt;&quot;
        echo '  &amp;lt;/static&amp;gt;'
        last_file=$current_file
    fi
done

echo '&amp;lt;/background&amp;gt;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把上面的脚本保存为&lt;code&gt;generate_mywallpaper_xml.sh&lt;/code&gt;，然后使用&lt;code&gt;chmod u+x generate_mywallpaper_xml.sh&lt;/code&gt;为该脚本添加运行权限。这个脚本是直接访问&lt;code&gt;/usr/share/backgrounds&lt;/code&gt;目录的，生成的 XML 配置文件直接输出到标准输出。所以，这样生成自己的配置文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;./generate_mywallpaper_xml.sh &amp;gt; youxia.xml
sudo mv youxia.xml /usr/share/backgrounds/contest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来编写&lt;code&gt;/usr/share/gnome-background-properties/&lt;/code&gt;目录下的 XML 配置文件。进入该目录后，同样可以看到两个系统自带的配置文件，打开其中一个，参考其中的内容，使用&lt;code&gt;sudo vim youxia-wallpapers.xml&lt;/code&gt;命令建立我们自己的配置文件，在该文件中，引用前面生成的&lt;code&gt;/usr/share/backgrounds/contest/youxia.xml&lt;/code&gt;，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909212403697-2122306098.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存该文件后，就可以在系统设置中设置壁纸了，选择这个自定义的动态壁纸即可，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180909211844746-455785605.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Ubuntu 中设置好自动壁纸切换后的效果，我在&lt;a href=&quot;https://www.cnblogs.com/youxia/p/LinuxDesktop001.html&quot;&gt;Linux桌面玩家装B指南：01.玩转Linux系统的方法论&lt;/a&gt;中已经大量展示了，所以这里就不截图了。在 Fedora 28 中走完以上所有步骤后，可以得到如下的效果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180910200745280-1839191574.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这一篇随笔主要讲的是 Gnome 3 桌面的美化思路。这里展示了 gnome-shell-extension 的安装、主题的更改（包括 shell 主题、GTK 3 主题和图标主题）以及自动壁纸切换。影响 Linux 桌面是否好看好用还有一个非常重要的方面，那就是字体。关于 Linux 桌面字体配置方面的内容，敬请期待我的下一篇。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年09月12日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 22:39:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明 要在我的随笔后写评论的小伙伴们请注意了：我的博客是使用 Markdown 编写的，并且启用了 MathJax 数学公式支持。如果某条评论中出现了两个 ，则 MathJax 会认为这两个 之间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop003.html</dc:identifier>
</item>
<item>
<title>一统江湖的大前端（2）—— Mock.js + Node.js 如何与后端潇洒分手 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9632492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9632492.html</guid>
<description>&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，前端能做的事情已经太多了, &lt;code&gt;手机app开发&lt;/code&gt; , &lt;code&gt;桌面应用开发&lt;/code&gt; , &lt;code&gt;用于神经网络人工智能的库&lt;/code&gt; , &lt;code&gt;页面游戏&lt;/code&gt; , &lt;code&gt;数据可视化&lt;/code&gt; , 甚至 &lt;code&gt;嵌入式开发&lt;/code&gt; ，什么火就搞什么,活脱脱一个&lt;strong&gt;蹭热点小能手&lt;/strong&gt;。如果你也觉得前端的日常开发有些枯燥，不妨一起来看看前端的另一番模样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/11/8dc113ba5b0d3ef76f6928046022dbf5.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么你总是下不了班&quot;&gt;为什么你总是下不了班&lt;/h4&gt;
&lt;p&gt;大部分工程化的项目为方便维护，大多都会采用前后端分离的开发方式，而前端和后端的工作基本也是同时下发的，这时前端开发人员就会很尴尬，后端在干活的时候，领导几乎一定会让你先做个&lt;code&gt;静态页面&lt;/code&gt;看看，这时候你和后端之间可能只是约定了接口（当然也可能连接口都没约定，那我只能祝你幸福了），并没有数据的传输，没法直接拿到填充网页的数据，如果一次将前端代码写到位，那么打开网页时轻则页面提示没有获取到数据，重则直接报错退出脚本。&lt;/p&gt;
&lt;p&gt;而真正的问题在于&lt;code&gt;静态页面&lt;/code&gt;做起来是非常快的，以至于你的领导会认为当你把&lt;code&gt;静态页面&lt;/code&gt;中加入javascript的逻辑部分的代码后&lt;strong&gt;也应该非常快&lt;/strong&gt;,而实际上逻辑部分的代码量和联调的工作量几乎是写一个静态页面的&lt;em&gt;5-10倍&lt;/em&gt;。&lt;br/&gt;基本上前端的一个需求的开发至少需要经历&lt;strong&gt;静态页面&lt;/strong&gt;——&amp;gt;&lt;strong&gt;业务逻辑+静态数据&lt;/strong&gt;——&amp;gt;&lt;strong&gt;业务逻辑+http请求及数据处理&lt;/strong&gt;这几种不同形态才能交工，那么真实的时间轴变成了这样：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;后端&lt;/td&gt;
&lt;td&gt;写后台代码&lt;/td&gt;
&lt;td&gt;写后台代码&lt;/td&gt;
&lt;td&gt;回家睡觉&lt;/td&gt;
&lt;td&gt;回家睡觉或忙其他事&lt;/td&gt;
&lt;td&gt;修改前端提交的bug&lt;/td&gt;
&lt;td&gt;重复4-5直到能上线&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;前端&lt;/td&gt;
&lt;td&gt;写静态页面&lt;/td&gt;
&lt;td&gt;漫无目的改样式&lt;/td&gt;
&lt;td&gt;写前端逻辑&lt;/td&gt;
&lt;td&gt;边开发前端边测试接口&lt;/td&gt;
&lt;td&gt;漫无目的改样式&lt;/td&gt;
&lt;td&gt;重复4-5直到能上线&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;无论从哪个方面看，前端都是一个打杂的活，无论从哪个角度看，前端也都是一个小弟脸，下不了班好像也是应该的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;node.js&quot;&gt;Node.js&lt;/h4&gt;
&lt;p&gt;Node火起来的时候，前端就流行这样一句话：&lt;em&gt;不会Node.js的前端，是不完整的&lt;/em&gt;，简单地说，Node.js将javascript能力扩展至服务端的关键一步，js也是从此开始了自己无孔不入的风骚操作，网上关于如何使用Node.js搭起一个本地服务器数不胜数，本篇中使用express框架来快速搭建Mock服务器。&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/11/e24948e523978d01a5b3dde78b4690d7.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;mock.js&quot;&gt;Mock.js&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Mock.js&lt;/code&gt;(&lt;a href=&quot;https://github.com/nuysoft/Mock/wiki&quot;&gt;github仓库地址&lt;/a&gt;)是一个生成Mock数据（也就是虚拟数据）js库，语法简单明了却非常好用，支持前端和服务端两种环境引用,感兴趣的读者可以点击上面链接进行学习，官方Wiki提供了全套文档，最多1小时就可以上手。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;客户端&lt;/td&gt;
&lt;td&gt;操作方便，纯前端本地即可实现&lt;/td&gt;
&lt;td&gt;1.不易进行接口管理 2.协作人员无法获得Mock数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;服务端&lt;/td&gt;
&lt;td&gt;1.前端代码几乎不需改动 2.其他人员可访问获得Mock数据&lt;/td&gt;
&lt;td&gt;需要搭建Mock服务器，相较前者稍复杂&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单浏览一下其使用方式：&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/11/49700ae9c79b2f69d671720740aa19a7.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;# 安装
npm install mockjs
// 使用 Mock
var Mock = require('mockjs')
var data = Mock.mock({
    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素,每个元素均包含id,name,description属性
    'list|1-10': [{
        'id|+1': 1,// 属性 id 是一个自增数，起始值为 1，每次增 1
        'name': '@cname',//占位符语法，生成一个中文名称
        'description|3-5':'@csentence',//占位符语法，生成3-5个中文句子
        'area':'@province',//省份占位符，将随机生成省份名称
    }]
})
// 输出结果
console.log(JSON.stringify(data))&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;前端的任务到底是什么&quot;&gt;前端的任务到底是什么&lt;/h4&gt;
&lt;p&gt;前端开发的本质,是&lt;strong&gt;数据的采集和数据的呈现&lt;/strong&gt;,即把用户提交的数据准确安全地发送给服务器，把服务器传递的数据按照设计图展示在界面上，无论是否界面是否经过CSS的美化，是否经过交互设计的易用性优化，最本质的东西是一样的。&lt;br/&gt;换句话说，你需要做到的是后端给的数据正确时，确保将其按设计稿展示出来，后端给的数据不正确时，给出提示并尽可能不要让脚本报错退出。&lt;/p&gt;
&lt;h4 id=&quot;使用nodejs和mockjs搞事情&quot;&gt;使用Nodejs和Mockjs搞事情&lt;/h4&gt;
&lt;p&gt;建议的做法是：使用node.js框架express快速搭建服务器，与后端人员约定好接口后，使用Mock.js在服务端生成各类型虚拟数据，前端开发人员直接对接Mock服务器&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你应该做的，是一次性将前端代码写到位并能够快速定位联调异常，然后回家睡觉，而不是漫无目的劳作和等待跟其他人互相扯皮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;安装node.js&quot;&gt;1.安装node.js&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;+ 安装后打开cmd命令行，输入`node -v`， 若正确显示版本号则安装成功。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;附件中包含： &lt;strong&gt;nodeV8.9.4版本windows安装包&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;安装其他依赖包&quot;&gt;2.安装其他依赖包&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;yarn&lt;/code&gt;(替代npm的包管理工具): &lt;code&gt;npm install yarn&lt;/code&gt;(可选)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;express&lt;/code&gt; (express框架): &lt;code&gt;npm install express -g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;express-generator&lt;/code&gt; (express项目生成插件): &lt;code&gt;npm install express-generator -g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mockjs&lt;/code&gt;(模拟数据生成库): &lt;code&gt;npm install mockjs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若安装速度较慢，可切换npm源为cnpm或使用Yarn进行包管理&lt;/p&gt;
&lt;h5 id=&quot;生成新的express项目并编写服务端&quot;&gt;3.生成新的express项目并编写服务端&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇力求简单粗暴，只讲使用不讲express目录结构，感兴趣的同学可自行研究&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;♬ 3.1 在指定路径下打开命令行，输入&lt;code&gt;express mockserver&lt;/code&gt;,即可生成名为&lt;code&gt;mockserver&lt;/code&gt;的项目&lt;/p&gt;
&lt;p&gt;♬ 3.2 打开&lt;code&gt;app.js&lt;/code&gt;文件,在 &lt;em&gt;var app = express()&lt;/em&gt; 之后加入如下代码，屏蔽跨域:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;            app.all('*', function(req, res, next) {
                res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
                res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);
                next();
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;♬ 3.3 仿照&lt;code&gt;users.js&lt;/code&gt;文件的格式及其在&lt;code&gt;app.js&lt;/code&gt;文件中的路由挂载方式（任何一个熟练地代码搬运工肯定看得懂），引入&lt;code&gt;mockjs&lt;/code&gt;,生成需要的随机数据,当接收到前端发送的请求时,返回生成的数据:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//服务端响应代码片段/routes/operationboard.js:
//业务逻辑为查询系统告警信息列表
//node服务器启动后，请求地址为:127.0.0.1:3000/operationboard/systemwarn
//3000端口为express默认启动端口

var express = require('express');
var router = express.Router();
var Mock = require('mockjs');
var Random = Mock.Random;

router.get('/systemwarn', function (req, res, next) {
  var data =Mock.mock({
      'list|20':[{
            'id|+1':1,
            'serial_number|1-100':1,
            'warn_number|1-100':1,
            'warn_name|1':['流水线编排服务异常','磁盘占用超过阈值'],
            'warn_level|1':['紧急','重要'],
            'warn_detail':'环境IP:10.114.123.12,服务名称:XX',
            'create_time':Random.datetime(),
            'finish_time':Random.datetime(),
            'contact|4':'abc'
        }] 
      });

  res.send({
    meta : {
      message: 'success'
    },
    status:true,
    data: data.list
  })
})
module.exports = router;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器访问可在控制台打出返回数据:&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/11/57fae7b105b8b5ad7d5cc91fb80b311d.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;♬ 3.4 在&lt;em&gt;mockserver&lt;/em&gt;项目目录下打开命令行工具，输入&lt;code&gt;npm start&lt;/code&gt;,待服务启动后，打开前端页面即可看到服务器返回的模拟数据。&lt;/p&gt;
&lt;p&gt;♬ 3.5 开启其他人员的访问能力，其实就是在本地搭建一个服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方式1——通过express工程来实现node服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将前端代码拷贝至express项目目录中public文件夹(本例中为&lt;em&gt;/mockserver/public&lt;/em&gt;),打开命令行工具输入ipconfig查询本机IP，将127.0.0.1替换为本机IP，然后在浏览器直接访问即可打开网页。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方式2——传统Apache服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为方便管理，直接使用开源XAMPP集成环境，安装完成后一键开启apache服务器，并将前端代码拷贝至安装目录中htdoc文件夹中的子文件夹中，然后以方式1中类似的方式在浏览器中访问即可，由于服务端代码取消了跨域限制，故即使端口号不同，apache服务器中的网站仍然可以访问node服务器中的接口并拿到数据。&lt;/p&gt;
&lt;p&gt;♬ 3.6 最后，项目是大家一起做的，不是你撇清责任就完事了的，为你所做的一切提供一个可参考访问的&lt;code&gt;excel文档&lt;/code&gt;并把它发给与你合作开发的后端是有礼貌的做法。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 21:56:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9632492.html</dc:identifier>
</item>
<item>
<title>前端程序员成长的记录及被某IT外包公司套路的经历 - Elvisde_404</title>
<link>http://www.cnblogs.com/Elvisde1/p/9632491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Elvisde1/p/9632491.html</guid>
<description>&lt;p&gt;           亲身经历，记录下来，也敬告各位刚出社会的毕业生们，面试的时候千万擦亮眼睛。说一下事情的前因后果吧，本人坐标深圳，本科毕业三年，两年多的专职前端开发的经验。上个月8号从上家公司离职，休息加上看java的学习视频，大概这样过了十五天，准备用java,Vue搭一个自己的个人博客。因为上家公司的后台是用java写的，有的老项目前端是用jsp加jquery写的，工作中也经常接触，所以对java相对来说比较了解。但是搭着个东西可能也没有想象中的那么容易。前端页面倒是写得差不多了，本来想设计一个酷炫的，独一无二的界面效果加上布局什么的，其实这个东西如果你不抄袭，不模仿还是挺头疼的。写出来之后发现跟我想象的不是同一个东西，感觉有点迷。&lt;/p&gt;
&lt;p&gt;　　　　后来就在某忧上更新了简历，然后在拉钩上也更新了简历，但是我没投过简历，后面在外包的刺激下就给腾讯，顺丰，华为的前端岗位投了简历，但是没有回应，其实我也有自知之明。github上面没有拿的出手的轮子，没有对某一个方面了解的比较深入，根本没有机会。&lt;/p&gt;
&lt;p&gt;　　　   说一下我的经历吧，我的前端所有东西全部是我自学的，从刚开始在某宝上买的廉价视频教程，对照着上面乐此不疲的写静态HTML,CSS，学习JS基础，学习Jquery，看阮一峰大神写的博客，虽然当时可能还不知道那博客精髓在哪里，真的是通俗易懂，大道至简，推荐大家去看看，每天学习10多个小时，模仿各大网站，在找不到工作的烦恼下煎熬了几个月，钱也快要花完了。最终在朋友的帮助下找到第一份开发工作，刚开始工作的时候很懵逼，但是工作中用Jquery写静态页面，调ajax其实也没有想象中的那么难，后来公司要搞混合App，不太会，依然是网上去找资料，从此接触了ng1,Ionic，但是我还是主要做的是网站，接近一年的时间。因为某种原因离职来到深圳，本来当时在学angular1做混合app，但是我简历上也没有什么像样的项目，就模仿着做了个个人web简历，电梯楼层的一个单页的展示页面，自适应，还模仿了一个PC网站，没加meta标签，手机上依然可以看到全部视口，但是按钮什么的比较小，用jquery做的，大概有四十多个html，总共大概写了1个多月的静态的页面。放在github上，有一个很长的链接，可以在手机上直接访问，访问的速度很慢，甚至加载Css都要好几秒，一般我都是先打开，然后给面试官看，面试了几家，虽然是有点取巧，我记得有一个面试官对我做的东西不屑一顾，给他看那个没加meta页面，他说这是PC端的，他要移动端的。然后给他看电梯楼层的个人简历页面，他说这也叫移动端页面？其实我至今也不太明白他所说的移动端页面到底什么意思。然后他给我发了一个psd，看看我能不能做出来，我花了一晚上给他做好了发过去，没有任何回音。后来我面试了我的上家公司，公司做UPS的，面试的时候我把这两个页面给我当时的上司看，表示我们公司的前端可能做得不好，但是后台java写的比较好，可以来学习一下，我问他做不做APP什么的，他说后期会做。没多想就体检进了这家公司，挺正规的。技术上面前端是用jsp加jquery做的，里面很多&amp;lt;s:text name=&quot;&quot;&amp;gt;,&amp;lt;s:iterator .....&amp;gt;,&amp;lt;s:if .....&amp;gt;，刚进去的时候还有点懵，后来发现也就是java里面的变量，遍历的是java里面的list而已，做项目当时的老大也会给合理的时间给你。在那家公司我啃完了javascript高级程序设计，加了不少公众号，每天看一些文章，花钱买了angualr4.0 ionic3的视频教程，跟着写了一遍，看完jquery源码解析，虽然有些地方现在也不太懂，比如那种很长的正则。在公司偶尔也会写一下java的接口，大概接近一年，公司里面的东西感觉越写越轻松，似乎对每一个页面，每一个button了若指掌，当然页面也不多，也就几十页面，但是页面上面哪个地方报错，看一眼就知道哪个地方的问题，学到了不少，那种感觉真的很舒服。但是待久就感觉东西比较简单，进入了死循环，想挑战一下有点难度的东西。找了个理由辞职，经理挽留但是还是走了。&lt;/p&gt;
&lt;p&gt;　　　　 life==1&amp;amp;&amp;amp;life==2&amp;amp;&amp;amp;life==3可以实现吗？现实生活中或许不可以，在js中也许可以 &lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt; 　　　　　　function Life(){&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;  　　　　　　 return{&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;        　　　　　　 i:1,&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;     　　　　　　toString:function(){&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;         　　　　   return this.i++;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;      　　　　　　}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;     　　　　}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt; 　　　　}&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　　　var life = new Life();&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　上面说到开始投简历，某忧上更新简历的效果真的让人惊叹，可能老程序员们有过亲身体会，但是这种状况我还是第一次遇到。以前都没人理我，一天接到很多个电话，基本上都是外包。人力外包，项目外包什么的。刚开始还跟他们聊一下，还去面试过一次，后来的电话就问一下是不是外包，如果是就直接拒绝(之前找工作可能也是运气比较好，做的都是自己公司运营的项目)，拒绝的时候，有个别的HR确实牛X的不行，可能我说话也比较委婉，并不想用太强硬的词，动不动你找不找工作撒，什么某安,某为的区块链，微服务项目，什么我给你打电话是看你现在比较年轻，你学校又不行什么的（这个确实是我一直以来的痛点），什么再过几年你这简历我看都不想看。多的我也不想再说了，各位看官自己联想一下。&lt;/p&gt;
&lt;p&gt;                后来直到某公司打电话过来，我问她是不是做外包的，他说不是，然后就让她发地址。第二天忘了没去，又接到电话，就去面了个试，面试通常首先介绍我自己，然后我介绍了我做过的项目，然后这个面试我的人就开始讲了，说公司是做停车这一方面的东西，只字没提他们是做外包的，而且这个人对前端基本不懂，然后他说了最误导我的话，公司之前有人用C++写了Android,IOS的一个跨平台的框架，页面用html，然后巴拉巴拉一堆。我就问到有混合App的解决方案为什么不用，他说导航的问题，巴拉巴拉一堆，我说性能满足不吗，他接着我的话说是，我问他公司有没有UI，他说没有，但是都是参照同行的页面做的，然后他当场表示要我，让我立马来上班，公司急着要人，我说我考虑一下。其实他说完之后我知道他是在吹牛，但是没有当场戳穿他，倒是觉得即使没有写这个框架但多少应该还是有点东西吧。可能太年轻，就是这个错误的想法让我浪费了一周时间。&lt;/p&gt;
&lt;p&gt;                 后来又面试了其他两家公司，都是一些小公司并且拿到Offer。除了在拉钩上给腾讯那些公司投过简历，没有主动投过简历，只面试过三家公司，而且觉得那个领导挺傻的又不懂前端，这可能就是我被忽悠的主要原因。其实更傻的可能是我，太年轻。&lt;/p&gt;
&lt;p&gt;　　　　  周一去了那家忽悠我的公司，把我的毕业证复印件，学位证复印件，离职证明都给一个做人事的女的。然后那个公司的老板找我聊了一下，大概的意思代码写得好不好无所谓，出产品，用户看得懂就可以，当然立场不同，而且他又是老板，我就附和说这个当然，当时还不知道他们是外包公司，公司20几个人，当时填写个人履历的时候我看到了他们公司有一份文件写着未干满30天不发工资，然后有一个做人事的女的跟我说试用期不交公积金和五险,工资发放80%，我问她你们公司社保基数缴纳多少，她说3000，然后快速的拉我进群，我问她签不签合同，她说暂时不签，我顿时一阵心悸，当场我就有点想走人。但是一想来都来了，先看看。&lt;/p&gt;
&lt;p&gt;　　　　然后有一个跟我差不多大的人，暂时称呼他为甲，甲自己用的自己的笔记本，甲打开一个台式机的后台管理系统页面，然后还有一个移动端的界面，移动端的界面用JQ做的，我就没怎么看。我问甲后台系统是用什么框架，甲说ng2。然后我一看源码，代码上有ng-controller,$scope这种东西，一眼就看出来是ng1，然后我去问这个人，然后这个人指着一个类似package.json的东西，指着Angularxxxx:2.0.1跟我说是2，然后我指着Angular:1.x.x说这是1，那时候就感觉有点不对劲 。我大概的看了一下他们的代码，整体是用ng1+gulp+一个类似Emmet的模板做的，然后那个面试我的人给我发一大堆图片，当时我问他这边不用svn或者git吗，他表示用git，然后我到他们git上面去看了一下基本没有代码，那个面试我的人让我下午看一下easyui。后来下午我加了甲的微信，聊了一下，才发现我是来接他班的，跟我说什么这个公司还可以，但是他要离职。当天晚上我就在想第二天要不要去，实际上拿的钱比之前还要少，而且这个公司明显哪有问题，但是善良的我还是觉得不辞而别不太好。&lt;/p&gt;
&lt;p&gt;　　　　第二天，有一个项目群里面的人加我，这里称呼他为乙，问我是不是做前端的，然后他问我XXX的项目页面有没有做好，我说我昨天刚来，然后乙发了一个他们的项目简介给我看。那个项目页面还没开始动，当时微信群里面就在讨论用C++的poco搭一个web服务器的问题，后来微信群里面又有个人，称他为丙，让我丢html到服务器上面去测试，我通过webstorm的Browse Remote Host把东西丢上去。一看返回来的html的代码显示在上面，这肯定不对。丙又要我丢一个html到一个nginx服务器上面去，正常显示。后来他们就在修改，然后我就看他们那个用ng1做的项目源码，有一个改变页面颜色样式的组件明显有BUG，改了颜色改不回来，还有个锁屏的功能，用JS做的，也是个鸡肋，后台没有做任何处理，把那个锁屏display:none之后照样操作，很多CSS的废代码，样式无用。后面乙在微信群里面说那个服务器的东西改好了，然后给了我一些接口，让我在服务器上试一下。是给了我一个ip:8080的东西，但是那个Web服务器的端口是9088，一看这个东西就知道涉及跨域了。但还是用JQ写了个ajax，丢上去浏览器显示跨域报错。跟甲说了一下，他们在微信群里讨论。然后我就下了vue-cli,配置resource，数据返回的是字符串：接口未实现。然后他们说又改好了，端口改成一致了。然后我就把vue的默认项目的首页打了个包，丢上去。又出现一个很奇怪的问题，丢上去的html里面引用的JS文件报错，有一段JS乱码了。一开始我以为是我打包的问题，反复创建项目打包几次，还是乱码报错。我就把项目丢到那个nginx服务器上面，正常显示，我知道应该就是那个服务器的问题。我就把截图发到群里面，乙开始质疑我，说路径有没有问题？，文件确定是同一个么?我说是。&lt;/p&gt;
&lt;p&gt;　　　　晚上下班，丙一直给我发截图，说这个html为什么没有换行符，被压缩了。我说这个不影响，然后在看webpack和gulp的一些东西，这个问题被丙改到了晚上十二点多，在群里发截图，vue的那个默认首页可以正常访问。我问他什么问题，他说压根没有给我返回文件，我说浏览器里面可以看到JS报错了呀，他没有回答。&lt;/p&gt;
&lt;p&gt;　　　　第三天，早上九点。那个面试我的人在群里说进度跟不上了，你们那边的进度有点慢，我们是总包，巴拉巴拉的一堆。昨天晚上丙刚加班到十二点，他怼一句谈何进度有点慢，如果是工作量大的话我们会加班完成。当然加班是没有钱的。至此我完全搞明白了，原来不对的地方是他们公司是外包公司，从我接到那个面试电话，就开始忽悠我了。一整天我都在想这个事情。上午他们在群里发了两个系统的界面照片。让我照着这个做，一个BS的照片，一个居然还是CS的照片。页面奇丑无比。我问怎么还有CS的，这个怎么对照，那个面试我的人说根据BS的使用习惯让我看着调。然后给我发了几个CSS的文件，我打开了一个，一堆class，有点无语，然后我问有什么其他要求没有比如兼容性什么的，丙回答谷歌必须要兼容，360最好也兼容一下。下午，那个面试我的人在公司碰到我的时候问我怎么样，他说他看我用的VUE，我说我不准备用Jquery和easyui，准备用Vue和Elementui，他说要跟其他小组做成一致，要像同一个团队做出来的东西。我说这个样式改成一致的也可以啊。他说这个比较慢吧，我说差不多吧，后面丙开始在微信群里催页面，问我能不能出差去那边开发，我没有理他。晚上九点，那个面试我的人开始在群里面问进度，问有一个摄像头的监控准备怎么做，面试我的人和乙开始讨论，乙说用VLC，但是我看了一下，谷歌最新版本已经不兼容VLC了，他说摄像头是网络摄像头什么的，我说如果是网络摄像头的话也许可以把摄像头的页面嵌进来，但是这种需求我没有处理过，觉得还有点意思。讨论到晚上10点多&lt;/p&gt;
&lt;p&gt;　　　　第四天，早上九点，乙就开始让我给代码他。我写了一行iframe，给他测试一下不行，那个网络摄像头监控页面使用flash写的。其实flash的话应该也可以嵌，他开始问还有什么方案，没人回答。微信群里面乙又开始提VLC，并发给了我一个demo，我说谷歌已经不兼容了，强制不用还是怎么样？他说立马就说你没有下载插件，我说并不是我没有下载，是已经不再支持了。让他去下载个谷歌试一下。丙在微信群里面说必须支持谷歌。乙问还有什么方案，然后我没有理他，开始写我的页面，看了一下文档并没有仔细的去看，那个参照页面是用easyui写的一个多窗口一个东西，Elementui中并没有这样的组件，我用的vue路由实现，用watch监听路由变化的时候push到一个数组里面，在模板中循环出来那个数组，给元素绑定一个跳转路由的事件。&lt;/p&gt;
&lt;p&gt;　　　　下午群里面又开始催，页面有没有写好。我问他要参照页面，或者页面的逻辑，他给我发了一个后台业务逻辑的文档，里面写着数据库里面存储的字段类型。我说你把这个发给我干什么，乙说这个你看懂了没有，我有点不爽，不就是增删改查么，乙说还有把数据绑定到页面上去，我有点无语，说，好。&lt;/p&gt;
&lt;p&gt;              第五天，中午那个面试我的人又在问我怎么样，我说还好吧，没有什么难点。他说20多号能不能做完，我在想CSS上面没有UI,没有对照的东西，甚至具体的页面中显示什么东西我都不知道。我说那个后台页面差不多吧！他立马说还有那个前台的页面也要做完（一个是系统界面，还有一个是售票的界面），他说没什么复杂的吧，就是一些窗口切换display的东西，我们是总包，20多号就要上线。我说确实没有什么复杂的，但是没有UI，没有具体页面参照，这些细节东西也很花时间。他说那就不写样式，把JS写完，接口的话先用假数据，到时候把接口调通就可以。我又问他具体是20几号，他说22号。&lt;/p&gt;
&lt;p&gt;　　　　当天是7号，我刚来第五天，还没有签合同，除去两个周末一共十一天时间。后面我又认真的看一下需求，功能菜单上一共近60个功能，也就是说VUE要配置60个路由，加上页面一些逻辑，调通接口。即使大多数是增删改查，但是想要封装是不可能的，因为页面逻辑未知，UI未知，即使做出来了也是一堆垃圾，后期BUG无数，都是复制粘贴的，报错了你都不知道什么问题。当时我真的很深刻的体会到为什么大多数程序员不愿意进外包公司，因为模式，你就是他的一个赚钱工具，就是拧螺丝的一个人，接近深圳市最低的社保，试用期没有五险一金，入职不签合同，没干满30天不发工资，完全没风险，为什么外包公司要把前端后端分清楚呢？因为你离职了好招人，为什么会有这么多人跟你主动打电话问你找不找工作？不是因为你优秀，因为多招一个人，他们又可以早点多做完一个项目，那就意味着老板又多赚一笔钱。周末双休？那是搞笑的，因为实质上项目时间周末已经算在里面了，你的能力在他看来是没有意义的，会框架会复制粘贴就可以了。&lt;/p&gt;
&lt;p&gt;                我想起我面试时候他跟我说公司里面之前有个人用C++写跨IOS，Android的框架，之前我还以为他只是在吹牛，可能有写点什么东西出来，最起码不会像外包一样没有时间自己提升，疯狂赶进度，但是我错了。我现在知道他完全是在骗我，他就是外包。甲周五已经跟我交接，告诉我要悠着点，说页面就复制成一模一样的就可以了，本来是面试我的那个人要签字的地方，但是他让我签。让我签就让我签呗，反正我没签合同。下周一把我的离职报告拿回来，这个地方不是我想呆的地方，肯定要走人的。&lt;/p&gt;
&lt;p&gt;                晚上面试我的那个人在群里面发进度报告，晚上我就表示这个东西时间太短，代码会太烂，那个面试我的人表示后面可以慢慢改，丙说先把东西做出来再说，那边一直在催。当时我在想好啊，我给你做出来，做出来然后走人，正好VUE也练练手。把打包好的给你，想跟我要源码，你的脸怕是比城墙还厚？晚上去喝了点酒，真的很不爽。&lt;/p&gt;
&lt;p&gt;　　　　 周六的晚上稍微写了一点，然后睡觉。&lt;/p&gt;
&lt;p&gt;　　　　星期天调整了下心情。我体验了一下赶进度到底是个什么样的感觉，开始疯狂的复制粘贴，自己大概写了三十行代码。复制了一天，把我之前原生JS封装的一些东西，还有百度的大部分东西疯狂复制，在此感谢各位把代码写到博客上面的同志。配置33个路由，封装了一下http请求。后来打包的时候发现vue中路由的history模式，代码丢到tomcat服务器上面，刷新页面后JS的虚拟路由不存在会报404。把history模式删掉，路由中有一个#号很难看。还是要了解一下，要在服务器上修改一些东西。这是我用VUE写的第二个东西。&lt;/p&gt;
&lt;p&gt;　　　　当晚七点那个面试我的人又在发截图，丙说一直在催页面要我出差，我都不想理他，我就对面试我的人说明天我们聊聊。&lt;/p&gt;
&lt;p&gt;　　　　当晚思考了一晚上。&lt;/p&gt;
&lt;p&gt;               第二周星期一，以前公司没结清工资的理由要回了我离职证明，把打包好的项目放到他们服务器上，找面试我的那个人聊了两个小时，中间的对话有点颠覆我的想象力。我质问他那个写框架的事情是不是在骗我，他不承认是在骗我，巴巴拉拉的一堆，一顿胡说八道，我问他要源码看一下，他说没有。我问他你写了多久的程序，他说8年，我问他要他的github，他说没怎么用过github。我都怀疑他是个假的程序员，脸皮真的厚的可以。话不投机我就直接走了，毕竟没签合同，欺骗我，还耽误我一周的时间。&lt;/p&gt;
&lt;p&gt;　　　　 此文敬告那些正在找工作的程序员朋友们，以及正在努力的朋友们，找工作需谨慎。当一条咸鱼也要做一条有梦想的咸鱼。下面导航栏的明细。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1384741/201809/1384741-20180912053507286-1025748709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 11 Sep 2018 21:39:00 +0000</pubDate>
<dc:creator>Elvisde_404</dc:creator>
<og:description>亲身经历，记录下来，也敬告各位刚出社会的毕业生们，面试的时候千万擦亮眼睛。说一下事情的前因后果吧，本人坐标深圳，本科毕业三年，两年多的专职前端开发的经验。上个月8号从上家公司离职，休息加上看java的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Elvisde1/p/9632491.html</dc:identifier>
</item>
<item>
<title>Django模型层：多表查询 - 迎风而来</title>
<link>http://www.cnblogs.com/sui776265233/p/9631921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sui776265233/p/9631921.html</guid>
<description>&lt;h3&gt; 一 创建模型&lt;/h3&gt;
&lt;p&gt;实例：我们来假定下面这些概念，字段和关系&lt;/p&gt;
&lt;p&gt;作者模型：一个作者有姓名和年龄。&lt;/p&gt;
&lt;p&gt;作者详细模型：把作者的详情放到详情表，包含生日，手机号，家庭住址等信息。作者详情模型和作者模型之间是一对一的关系（one-to-one）&lt;/p&gt;
&lt;p&gt;出版商模型：出版商有名称，所在城市以及email。&lt;/p&gt;
&lt;p&gt;书籍模型： 书籍有书名和出版日期，一本书可能会有多个作者，一个作者也可以写多本书，所以作者和书籍的关系就是多对多的关联关系(many-to-many);一本书只应该由一个出版商出版，所以出版商和书籍是一对多关联关系(one-to-many)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9227a89d-0770-4897-ad9a-a16952359de1')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_9227a89d-0770-4897-ad9a-a16952359de1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9227a89d-0770-4897-ad9a-a16952359de1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9227a89d-0770-4897-ad9a-a16952359de1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9227a89d-0770-4897-ad9a-a16952359de1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Book

   id    title   price  publish    
     php     &lt;/span&gt;100&lt;span&gt;   人民出版社  
     python  &lt;/span&gt;200&lt;span&gt;   老男孩出版社   
     go      &lt;/span&gt;100&lt;span&gt;   人民出版社  
     java    &lt;/span&gt;300&lt;span&gt;   人民出版社  


为了存储出版社的邮箱，地址，在第一个表后面加字段

Book

   id    title   price  publish    email    addr    
     php     &lt;/span&gt;100   人民出版社   111&lt;span&gt;      北京
     python  &lt;/span&gt;200   老男孩出版社 222&lt;span&gt;      上海
     go      &lt;/span&gt;100   人民出版社   111&lt;span&gt;      北京
     java    &lt;/span&gt;300   人民出版社   111&lt;span&gt;      北京
   
这样会有大量重复的数据，浪费空间


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###################################################################################&lt;/span&gt;
&lt;span&gt;

一对多：一个出版社对应多本书（关联信息建在多的一方，也就是book表中）

Book

   id    title   price     publish_id   
     php     &lt;/span&gt;100         1&lt;span&gt;
     python  &lt;/span&gt;200         1&lt;span&gt;
     go      &lt;/span&gt;100         2&lt;span&gt;  
     java    &lt;/span&gt;300         1&lt;span&gt;


Publish

    id    name       email    addr    
   人民出版社   &lt;/span&gt;111&lt;span&gt;      北京       
   沙河出版社   &lt;/span&gt;222&lt;span&gt;      沙河



总结：一旦确定表关系是一对多：在多对应的表中创建关联字段（在多的表里创建关联字段）  ，publish_id


查询python这本书的出版社的邮箱(子查询)

   select publish_id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Book where title=&lt;span&gt;“python”
   select email &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Publish where id=1


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###################################################################################&lt;/span&gt;
&lt;span&gt;

多对多：一本书有多个作者，一个作者出多本书

Book

   id    title   price     publish_id    
     php     &lt;/span&gt;100         1&lt;span&gt;               
     python  &lt;/span&gt;200         1&lt;span&gt;
     go      &lt;/span&gt;100         2&lt;span&gt;  
     java    &lt;/span&gt;300         1&lt;span&gt;



Author
         id  name  age   addr
   alex  &lt;/span&gt;34&lt;span&gt;   beijing
   egon  &lt;/span&gt;55&lt;span&gt;   nanjing



Book2Author

    id    book_id  author_id
      &lt;/span&gt;2         1
      2         2
      3         2&lt;span&gt;

总结：一旦确定表关系是多对多：创建第三张关系表（创建中间表，中间表就三个字段，自己的id，书籍id和作者id） ：
          
          id      book_id   author_id


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; alex出版过的书籍名称(子查询)&lt;/span&gt;
&lt;span&gt;
select id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Author where name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

select book_id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Book2Author where  author_id=1&lt;span&gt;

select title &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Book where id =&lt;span&gt;book_id

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;###################################################################################&lt;/span&gt;
&lt;span&gt;

一对一：对作者详细信息的扩展（作者表和作者详情表）

Author
         id  name  age     ad_id(UNIQUE) 
   alex  &lt;/span&gt;34       1&lt;span&gt;     
   egon  &lt;/span&gt;55       2&lt;span&gt;     


AuthorDetail

   id    addr      gender    tel   gf_name   author_id(UNIQUE)
  beijing    male      &lt;/span&gt;110   小花           1&lt;span&gt;
  nanjing    male      &lt;/span&gt;911   杠娘           2&lt;span&gt;


总结： 一旦确定是一对一的关系：在两张表中的任意一张表中建立关联字段＋Unique






&lt;/span&gt;====================================&lt;span&gt;


Publish  
Book
Author
AuthorDetail
Book2Author



CREATE TABLE publish(
                id INT PRIMARY KEY auto_increment ,
                name VARCHAR (&lt;/span&gt;20&lt;span&gt;)
              );


CREATE TABLE book(
                id INT PRIMARY KEY auto_increment ,
                title VARCHAR (&lt;/span&gt;20&lt;span&gt;),
                price DECIMAL (&lt;/span&gt;8,2&lt;span&gt;),
                pub_date DATE ,
                publish_id INT ,
                FOREIGN KEY (publish_id) REFERENCES publish(id)
              );


CREATE TABLE authordetail(
                id INT PRIMARY KEY auto_increment ,
                tel VARCHAR (&lt;/span&gt;20&lt;span&gt;)
              );

CREATE TABLE author(
                id INT PRIMARY KEY auto_increment ,
                name VARCHAR (&lt;/span&gt;20&lt;span&gt;),
                age INT,
                authordetail_id INT UNIQUE ,
                FOREIGN KEY (authordetail_id) REFERENCES authordetail(id)
              );



CREATE  TABLE book2author(
       id INT PRIMARY KEY auto_increment ,
       book_id INT ,
       author_id INT ,
       FOREIGN KEY (book_id) REFERENCES book(id),
       FOREIGN KEY (author_id) REFERENCES author(id)
)

分析如下&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：关联字段与外键约束没有必然的联系（建管理字段是为了进行查询，建约束是为了不出现脏数据）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Models创建如下模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book(models.Model):
    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    price &lt;/span&gt;= models.DecimalField(max_digits=5, decimal_places=2&lt;span&gt;)
    publish_date &lt;/span&gt;=&lt;span&gt; models.DateField()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 阅读数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; reat_num=models.IntegerField(default=0)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 评论数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; commit_num=models.IntegerField(default=0)&lt;/span&gt;
&lt;span&gt;
    publish &lt;/span&gt;= models.ForeignKey(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Publish&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,to_field=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,on_delete=&lt;span&gt;models.CASCADE)
    authors&lt;/span&gt;=models.ManyToManyField(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    age &lt;/span&gt;=&lt;span&gt; models.IntegerField()
    author_detail &lt;/span&gt;= models.OneToOneField(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;AuthorDatail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,to_field=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,unique=True,on_delete=&lt;span&gt;models.CASCADE)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorDatail(models.Model):
    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    telephone &lt;/span&gt;=&lt;span&gt; models.BigIntegerField()
    birthday &lt;/span&gt;=&lt;span&gt; models.DateField()
    addr &lt;/span&gt;= models.CharField(max_length=64&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Publish(models.Model):
    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    city &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    email &lt;/span&gt;= models.EmailField()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1364097/201809/1364097-20180911232717435-1289362340.png&quot; alt=&quot;&quot; width=&quot;1103&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 表的名称&lt;code&gt;myapp_modelName&lt;/code&gt;，是根据 模型中的元数据自动生成的，也可以覆写为别的名称　　&lt;/li&gt;
&lt;li&gt;&lt;code&gt; id&lt;/code&gt; 字段是自动添加的&lt;/li&gt;
&lt;li&gt; 对于外键字段，Django 会在字段名上添加&lt;tt class=&quot;docutils literal&quot;&gt;&quot;_id&quot;&lt;/tt&gt; 来创建数据库中的列名&lt;/li&gt;
&lt;li&gt; 这个例子中的&lt;code&gt;CREATE TABLE&lt;/code&gt; SQL 语句使用PostgreSQL 语法格式，要注意的是Django 会根据settings 中指定的数据库类型来使用相应的SQL 语句。&lt;/li&gt;
&lt;li&gt; 定义好模型之后，你需要告诉Django _使用_这些模型。你要做的就是修改配置文件中的INSTALL_APPSZ中设置，在其中添加&lt;code&gt;models.py&lt;/code&gt;所在应用的名称。&lt;/li&gt;
&lt;li class=&quot;line&quot; data-line=&quot;91&quot;&gt;外键字段 ForeignKey 有一个 null=True 的设置(它允许外键接受空值 NULL)，你可以赋给它空值 None 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;二 &lt;span&gt;添加&lt;/span&gt;表记录&lt;/h3&gt;
&lt;h4&gt;一对多的&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方式1:
   publish_obj&lt;/span&gt;=Publish.objects.get(nid=1&lt;span&gt;)
   book_obj&lt;/span&gt;=Book.objects.create(title=&lt;span&gt;&quot;&quot;&lt;/span&gt;,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=100,publish=&lt;span&gt;publish_obj)
  
方式2:
   book_obj&lt;/span&gt;=Book.objects.create(title=&lt;span&gt;&quot;&quot;&lt;/span&gt;,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=100,publish_id=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;核心：book_obj.publish与book_obj.publish_id是什么？&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;关键点:

    一 book_obj.publish&lt;/span&gt;=Publish.objects.filter(id=&lt;span&gt;book_obj.publish_id).first()

    二 book_obj.authors.all()
       关键点:book.authors.all()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与这本书关联的作者集合&lt;/span&gt;
book.id=3&lt;span&gt;
book_authors
            id  book_id  author_ID
     &lt;/span&gt;3             1
     3             2&lt;span&gt;
 author
           id   name
  alex
  egon

    book_obj.authors.all()    &lt;/span&gt;-------&amp;gt;   [alex,egon]
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;多对多&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前生成的书籍对象&lt;/span&gt;
    book_obj=Book.objects.create(title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;追风筝的人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=200,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-11-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,publish_id=1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为书籍绑定的做作者对象&lt;/span&gt;
    yuan=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).first() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在Author表中主键为2的纪录&lt;/span&gt;
    egon=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).first() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在Author表中主键为1的纪录&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绑定多对多关系,即向关系表book_authors中添加纪录&lt;/span&gt;
    book_obj.authors.add(yuan,egon)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  将某些特定的 model 对象添加到被关联对象集合中。   =======    book_obj.authors.add(*[])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
book = Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    egon&lt;/span&gt;=Author.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    lqz&lt;/span&gt;=Author.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lqz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 没有返回值，直接传对象&lt;/span&gt;
&lt;span&gt;    book.authors.add(lqz,egon)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2 直接传作者id&lt;/span&gt;
    book.authors.add(1,3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3 直接传列表,会打散&lt;/span&gt;
    book.authors.add(*[1,2&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解除多对多关系&lt;/span&gt;
    book = Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1 传作者id&lt;/span&gt;
    book.authors.remove(1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2 传作者对象&lt;/span&gt;
    egon = Author.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    book.authors.remove(egon)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 传*列表&lt;/span&gt;
    book.authors.remove(*[1,2&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4 删除所有&lt;/span&gt;
&lt;span&gt;    book.authors.clear()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5 拿到与 这本书关联的所有作者，结果是queryset对象，作者列表&lt;/span&gt;
    ret=&lt;span&gt;book.authors.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(ret)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6 queryset对象，又可以继续点（查询红楼梦这本书所有作者的名字）&lt;/span&gt;
    ret=book.authors.all().values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以上总结：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; （1）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; book=Book.objects.filter(name='红楼梦').first()&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(book)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在点publish的时候，其实就是拿着publish_id又去app01_publish这个表里查数据了&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(book.publish)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; （2）book.authors.all()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;核心:book_obj.authors.all()是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多对多关系其它常用API：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
book_obj.authors.remove()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将某个特定的对象从被关联对象集合中去除。    ======   book_obj.authors.remove(*[])，可以指定解除关联对象的id值&lt;/span&gt;
book_obj.authors.clear()       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;清空被关联对象集合，即与书这个对象相关联的作者的绑定关系都被清除&lt;/span&gt;
book_obj.authors.set()         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先清空再设置，在重新设定绑定关系　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三 基于对象的跨表&lt;span&gt;查询&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;一对一查询（Author 与 AuthorDetail）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;正向查询(按字段：authorDetail)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
egon=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).first()   &lt;span&gt;#拿到作者对象
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(egon.authorDetail.telephone)  &lt;span&gt;#按照作者表中的authorDetail字段进行查询&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;反向查询(按表名：author)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询所有住址在北京的作者的姓名&lt;/span&gt;
authorDetail_list=AuthorDetail.objects.filter(addr=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先拿到地址为北京的左右作者的一个对象&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; authorDetail_list:
     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.author.name)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过作者详细信息点小写表名就可以拿到作者这个对象&lt;/span&gt;
   &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    A表Author(关联自动段)   B表 AuthorDetail
    # 正向查询   A---&amp;gt;B    关联字段再A，A去查询B表，这叫正向查询，按字段来查
    # 反向查询   B--》A    关联字段再A，B去查询A表，这叫反向查询，按表明小写
   &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('85062333-e056-4326-84a7-9fc8a68ebfda')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_85062333-e056-4326-84a7-9fc8a68ebfda&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_85062333-e056-4326-84a7-9fc8a68ebfda&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('85062333-e056-4326-84a7-9fc8a68ebfda',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_85062333-e056-4326-84a7-9fc8a68ebfda&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对一正向查询&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; lqz的手机号&lt;/span&gt;
    lqz=Author.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lqz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    tel&lt;/span&gt;=&lt;span&gt;lqz.author_detail.telephone
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tel)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对一反向查询&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 地址在北京的作者姓名&lt;/span&gt;
    author_detail=AuthorDatail.objects.filter(addr=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    name&lt;/span&gt;=&lt;span&gt;author_detail.author.name
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(name)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;一对多查询（publish与book）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;正向查询（按字段：publish）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询主键为1的书籍的出版社所在的城市&lt;/span&gt;
book_obj=Book.objects.filter(pk=1&lt;span&gt;).first()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; book_obj.publish 是主键为1的书籍对象关联的出版社对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(book_obj.publish.city)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反向查询（按表名：book_set）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
publish=Publish.objects.get(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;苹果出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;publish.book_set.all() : 与苹果出版社关联的所有书籍对象集合&lt;/span&gt;
book_list=&lt;span&gt;publish.book_set.all()    
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; book_obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; book_list:
       &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(book_obj.title)

　　　&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        A表book(关联自动段)   B表 publish
        # 正向查询   A---&amp;gt;B    关联字段再A，A去查询B表，这叫正向查询，按字段来查
        # 反向查询   B--》A    关联字段再A，B去查询A表，这叫反向查询，按表明小写_set
　　　&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a99f20a8-cc86-4cbe-81e9-15b365e1d685')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a99f20a8-cc86-4cbe-81e9-15b365e1d685&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a99f20a8-cc86-4cbe-81e9-15b365e1d685&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a99f20a8-cc86-4cbe-81e9-15b365e1d685',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a99f20a8-cc86-4cbe-81e9-15b365e1d685&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对多正向查询&lt;/span&gt;
    book=Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(book.publish)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;与这本书关联的出版社对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(book.publish.name)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对多反向查询&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 人民出版社出版过的书籍名称&lt;/span&gt;
    pub=Publish.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    ret&lt;/span&gt;=&lt;span&gt;pub.book_set.all()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;多对多查询 (Author 与 Book)&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;正向查询(按字段：authors)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 眉所有作者的名字以及手机号&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
book_obj&lt;/span&gt;=Book.objects.filter(title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;眉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).first() &lt;span&gt;#
&lt;/span&gt;authors=book_obj.authors.all() &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; author_obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; authors:
     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(author_obj.name,author_obj.authorDetail.telephone) &lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;反向查询(按表名：book_set)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询egon出过的所有书籍的名字&lt;/span&gt;
&lt;span&gt; 
    author_obj&lt;/span&gt;=Author.objects.get(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#
&lt;/span&gt;    book_list=author_obj.book_set.all()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;      #与egon作者相关的所有书籍&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; book_obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; book_list:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(book_obj.title)  &lt;span&gt;#
&lt;/span&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        A表book(关联自动段)   B表 publish
        # 正向查询   A---&amp;gt;B    
        # 反向查询   B--&amp;gt;A &lt;br/&gt;总结：一对一  正向：按字段  反向：按表名小写
        一对多  正向：按字段  反向：按表名小写_set
        多对多  正向：按字段  反向：按表名小写_set    
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('540e6e5d-a8b5-4138-861b-cef84df332bc')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_540e6e5d-a8b5-4138-861b-cef84df332bc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_540e6e5d-a8b5-4138-861b-cef84df332bc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('540e6e5d-a8b5-4138-861b-cef84df332bc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_540e6e5d-a8b5-4138-861b-cef84df332bc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询----查询红楼梦所有作者名称&lt;/span&gt;
    book=Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    ret&lt;/span&gt;=&lt;span&gt;book.authors.all()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; auth &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ret:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(auth.name)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询 查询lqz这个作者写的所有书&lt;/span&gt;
    author=Author.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lqz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).first()
    ret&lt;/span&gt;=&lt;span&gt;author.book_set.all()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以通过在 ForeignKey() 和ManyToManyField的定义中设置 related_name 的值来覆写 FOO_set 的名称。例如，如果 Article model 中做一下更改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
publish = ForeignKey(Book, related_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bookList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么接下来就会如我们看到这般:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询 人民出版社出版过的所有书籍&lt;/span&gt;
&lt;span&gt; 
publish&lt;/span&gt;=Publish.objects.get(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
book_list&lt;/span&gt;=publish.bookList.all()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与人民出版社关联的所有书籍对象集合&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四 基于双下划线的跨表查询&lt;/h3&gt;
&lt;p&gt;Django 还提供了一种直观而高效的方式在查询(lookups)中表示关联关系，它能自动确认 SQL JOIN 联系。要做跨关系查询，就使用两个下划线来链接模型(model)间关联字段的名称，直到最终链接到你想要的model 为止。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    正向查询按字段,反向查询按表名小写用来告诉ORM引擎join哪张表
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;一对一查询&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询alex的手机号&lt;/span&gt;
    
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询----按字段 (Author---&amp;gt;authordetail) Author表中有一个authordetail关联字段&lt;/span&gt;
    ret=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authordetail__telephone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#
&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询---按表名小写（authordetail---&amp;gt;Author）通过表名小写author拿到作者的的name字段&lt;/span&gt;
    ret=AuthorDetail.objects.filter(author__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;telephone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6a12e354-e622-42fe-9912-255459900ed3')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_6a12e354-e622-42fe-9912-255459900ed3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6a12e354-e622-42fe-9912-255459900ed3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6a12e354-e622-42fe-9912-255459900ed3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a12e354-e622-42fe-9912-255459900ed3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询lqz的手机号&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查&lt;/span&gt;
    ret=Author.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lqz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author_detail__telephone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查&lt;/span&gt;
    ret= AuthorDatail.objects.filter(author__name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lqz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;telephone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;一对多查询&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习:  查询苹果出版社出版过的所有书籍的名字与价格(一对多)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询 按字段:publish&lt;/span&gt;
&lt;span&gt;
    queryResult&lt;/span&gt;=&lt;span&gt;Book.objects 
　　　　　　　　　　　　.filter(publish__name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;苹果出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)#通过BOOK中的publish关联字段，拿到出版社的名字
　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#values_list中传的参数是我们要查询的字段
&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询 按表名:book&lt;/span&gt;
&lt;span&gt;
    queryResult&lt;/span&gt;=&lt;span&gt;Publish.objects
　　　　　　　　　　　　　　.filter(name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;苹果出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)   #出版社有name字段，所以可以直接拿到name字段
　　　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询的本质一样，就是select from的表不一样，Book表中的title字段要通过book表名小写__来拿到title字段&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9410a3d7-c163-4e2d-a9ee-b925be554c56')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9410a3d7-c163-4e2d-a9ee-b925be554c56&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9410a3d7-c163-4e2d-a9ee-b925be554c56&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9410a3d7-c163-4e2d-a9ee-b925be554c56',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9410a3d7-c163-4e2d-a9ee-b925be554c56&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询按字段，反向查询按表名小写&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询红楼梦这本书出版社的名字&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select * from app01_book inner join app01_publish&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; on app01_book.publish_id=app01_publish.nid&lt;/span&gt;
    ret=Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    ret&lt;/span&gt;=Publish.objects.filter(book__name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;多对多查询&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习: 查询alex出过的所有书籍的名字(多对多)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询 按字段:authors:&lt;/span&gt;
    queryResult=&lt;span&gt;Book.objects
　　　　　　　　　　　　.filter(authors__name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#BOOK表中有关联字段author,所以可以通过关联字段author__来拿到作者的名字
&lt;/span&gt;　　　　　　　　　　　　.values_list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#正向是Book表，所以可以直接拿到书的标题title&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询 按表名:book&lt;/span&gt;
    queryResult=&lt;span&gt;Author.objects
　　　　　　　　　　　　　　.filter(name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#Author可以直接拿到作者的名字字段name
&lt;/span&gt;　　　　　　　　　　　　　　.values_list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#因为关联字段在Book表中，所以通过表名BOOk小写__才能拿到Book表中的title和price字段&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('06a06359-6f36-499b-9466-37ef2d5feee6')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_06a06359-6f36-499b-9466-37ef2d5feee6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_06a06359-6f36-499b-9466-37ef2d5feee6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('06a06359-6f36-499b-9466-37ef2d5feee6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_06a06359-6f36-499b-9466-37ef2d5feee6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询按字段，反向查询按表名小写&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询红楼梦这本书出版社的名字&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select * from app01_book inner join app01_publish&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; on app01_book.publish_id=app01_publish.nid&lt;/span&gt;
    ret=Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    ret&lt;/span&gt;=Publish.objects.filter(book__name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; sql 语句就是from的表不一样&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -------多对多正向查询&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询红楼梦所有的作者&lt;/span&gt;
    ret=Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ---多对多反向查询&lt;/span&gt;
    ret=Author.objects.filter(book__name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ret&lt;/span&gt;=Author.objects.filter(book__name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author_detail__addr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    总结：用__告诉orm，要连接那个表
        一对一： 正向：按字段  反向：按表名小写 
        一对多：  正向：按字段  反向：按表名小写 
        多对多：  正向：按字段  反向：按表名小写 
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;进阶练习(连续跨表)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习: 查询人民出版社出版过的所有书籍的名字以及作者的姓名&lt;/span&gt;


    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向查询&lt;/span&gt;
    queryResult=&lt;span&gt;Book.objects
　　　　　　　　　　　　.filter(publish__name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询&lt;/span&gt;
    queryResult=&lt;span&gt;Publish.objects
　　　　　　　　　　　　　　.filter(name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__authors__age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__authors__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习: 手机号以151开头的作者出版过的所有书籍名称以及出版社名称&lt;/span&gt;


    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式1:&lt;/span&gt;
    queryResult=&lt;span&gt;Book.objects
　　　　　　　　　　　　.filter(authors__authorDetail__telephone__regex&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式2:    &lt;/span&gt;
    ret=&lt;span&gt;Author.objects
              .filter(authordetail__telephone__startswith&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
              .values(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__publish__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('76fb8226-da9f-4bc7-8ef2-10a262d52bfb')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_76fb8226-da9f-4bc7-8ef2-10a262d52bfb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_76fb8226-da9f-4bc7-8ef2-10a262d52bfb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('76fb8226-da9f-4bc7-8ef2-10a262d52bfb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_76fb8226-da9f-4bc7-8ef2-10a262d52bfb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----进阶练习，连续跨表&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询手机号以33开头的作者出版过的书籍名称以及书籍出版社名称&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; author_datail author book publish&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于authorDatail表&lt;/span&gt;
    ret=AuthorDatail.objects.filter(telephone__startswith=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author__book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author__book__publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于Author表&lt;/span&gt;
    ret=Author.objects.filter(author_detail__telephone__startswith=33).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于Book表&lt;/span&gt;
    ret=Book.objects.filter(authors__author_detail__telephone__startswith=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于Publish表&lt;/span&gt;
    ret=Publish.objects.filter(book__authors__author_detail__telephone__startswith=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;related_name&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
publish = ForeignKey(Blog, related_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bookList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习: 查询人民出版社出版过的所有书籍的名字与价格(一对多)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询 不再按表名:book,而是related_name:bookList&lt;/span&gt;
&lt;span&gt;

    queryResult&lt;/span&gt;=&lt;span&gt;Publish.objects
　　　　　　　　　　　　　　.filter(name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookList__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookList__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 反向查询时，如果定义了related_name ，则用related_name替换表名&lt;/p&gt;
&lt;h3&gt;五 聚合查询与分组查询&lt;/h3&gt;
&lt;h4&gt;&lt;tt class=&quot;descname&quot;&gt;聚合&lt;/tt&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;tt class=&quot;descname&quot;&gt;aggregate&lt;/tt&gt;(*args, **kwargs)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算所有图书的平均价格&lt;/span&gt;
 &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt; Avg &lt;span&gt;#
&lt;/span&gt; Book.objects.all().aggregate(Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#
#&lt;/span&gt;&lt;span&gt;{'price__avg': 34.35}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/tt&gt;是&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;QuerySet&lt;/span&gt;&lt;/tt&gt; 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。&lt;span id=&quot;yiyi-18&quot; class=&quot;yiyi-st&quot;&gt;键的名称是聚合值的标识符，&lt;span id=&quot;yiyi-19&quot; class=&quot;yiyi-st&quot;&gt;值是计算出来的聚合值。&lt;span id=&quot;yiyi-20&quot; class=&quot;yiyi-st&quot;&gt;键的名称是按照字段和聚合函数的名称自动生成出来的。&lt;span id=&quot;yiyi-21&quot; class=&quot;yiyi-st&quot;&gt;如果你想要为聚合值指定一个名称，可以向聚合子句提供它。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Book.objects.aggregate(average_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#
#&lt;/span&gt;&lt;span&gt;{'average_price': 34.35}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你希望生成不止一个聚合，你可以向&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;aggregate()&lt;/span&gt;&lt;/tt&gt;子句中添加另一个参数。&lt;span id=&quot;yiyi-23&quot; class=&quot;yiyi-st&quot;&gt;所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Avg, Max, Min
Book.objects.aggregate(Avg(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Min(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#
#&lt;/span&gt;&lt;span&gt;{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a431d79f-affd-4537-8fc4-d19881f57d54')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_a431d79f-affd-4537-8fc4-d19881f57d54&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a431d79f-affd-4537-8fc4-d19881f57d54&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a431d79f-affd-4537-8fc4-d19881f57d54',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a431d79f-affd-4537-8fc4-d19881f57d54&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询所有书籍的平均价格&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Avg,Count,Max,Min
    ret&lt;/span&gt;=Book.objects.all().aggregate(Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; {'price__avg': 202.896}&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以改名字&lt;/span&gt;
    ret=Book.objects.all().aggregate(avg_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计平均价格和最大价格&lt;/span&gt;
    ret=Book.objects.all().aggregate(avg_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),max_price=Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计最小价格&lt;/span&gt;
    ret = Book.objects.all().aggregate(avg_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), min_price=Min(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计个数和平均价格&lt;/span&gt;
    ret = Book.objects.all().aggregate(avg_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), max_price=Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),count=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    ret &lt;/span&gt;= Book.objects.all().aggregate(avg_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), max_price=Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),count=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;分组&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##################################－－单表分组查询－－#######################################################&lt;/span&gt;
&lt;span&gt;
查询每一个部门名称以及对应的员工数

emp:

id  name age   salary    dep
&lt;/span&gt;1   alex  12   2000&lt;span&gt;     销售部
&lt;/span&gt;2   egon  22   3000&lt;span&gt;     人事部
&lt;/span&gt;3   wen   22   5000&lt;span&gt;     人事部


sql语句:
select dep,Count(&lt;/span&gt;*) &lt;span&gt;from&lt;/span&gt;&lt;span&gt; emp group by dep;
ORM:
emp.objects.values(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例：查询每一个部门的名称，以及平均薪水&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; select dep,Avg(salary) from app01_emp group by dep&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Avg, Count, Max, Min
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ret=Emp.objects.values('dep').annotate(Avg('salary'))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 重新命名&lt;/span&gt;
ret=Emp.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(avg_salary=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

总结：单表分组查询orm语法：单表模型.objects.values(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;group by 的字段&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(聚合函数(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;统计的字段&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

　　查询每一个省份名称以及对应的员工数

　　Emp.objects.values(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;##################################－－多表分组查询－－###########################&lt;/span&gt;
&lt;span&gt;     Book表

        id   title    date      price  publish_id
        &lt;/span&gt;1    红楼梦    2012-12-12    101       1
        2    西游记    2012-12-12    101       1
        3    三国演绎    2012-12-12    101       1
        4    金梅    2012-12-12    301       2&lt;span&gt;


     Publish表
        id    name      addr   email
        &lt;/span&gt;1    人民出版社    北京       123&lt;span&gt;@qq.com
        &lt;/span&gt;2    南京出版社    南京       345@163&lt;span&gt;.com

多表分组查询：

&lt;/span&gt;1&lt;span&gt; 查询每个出版社出版的书籍个数
　　ret&lt;/span&gt;=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
&lt;/span&gt;2&lt;span&gt; 查询每个出版社的名称和书籍个数（先join，再分组）
    SELECT app01_publish.name,COUNT(app01_book.name) &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; app01_book
        INNER JOIN app01_publish
        on app01_publish.nid &lt;/span&gt;=&lt;span&gt; app01_book.publish_id
        GROUP BY app01_publish.nid
　　orm实现：
　　ret&lt;/span&gt;=Publish.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    ret&lt;/span&gt;=Publish.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
模型总结：跨表查询的模型：每一个后表模型.objects.value(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(聚合函数(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;关联表__统计字段&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).values()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每个作者的名字，以及出版过书籍的最高价格&lt;/span&gt;
    ret=Author.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每一个书籍的名称，以及对应的作者个数&lt;/span&gt;
    ret=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('517734b9-be18-4544-82ff-b2ec3c0e806b')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_517734b9-be18-4544-82ff-b2ec3c0e806b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_517734b9-be18-4544-82ff-b2ec3c0e806b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('517734b9-be18-4544-82ff-b2ec3c0e806b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_517734b9-be18-4544-82ff-b2ec3c0e806b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Emp(models.Model):
    name&lt;/span&gt;=models.CharField(max_length=32&lt;span&gt;)
    age&lt;/span&gt;=&lt;span&gt;models.IntegerField()
    salary&lt;/span&gt;=models.DecimalField(max_digits=8,decimal_places=2&lt;span&gt;)
    dep&lt;/span&gt;=models.CharField(max_length=32&lt;span&gt;)
    province&lt;/span&gt;=models.CharField(max_length=32)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;annotate()为调用的&lt;tt class=&quot;docutils literal&quot;&gt;QuerySet&lt;/tt&gt;中每一个对象都生成一个独立的统计值（统计方法用聚合函数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结 &lt;/strong&gt;：跨表分组查询本质就是将关联表join成一张表，再按单表的思路进行分组查询。&lt;/p&gt;
&lt;h4&gt;查询练习&lt;/h4&gt;
&lt;p&gt;(1) 练习：统计每一个出版社的最便宜的书&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
publishList=Publish.objects.annotate(MinPrice=Min(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; publish_obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; publishList:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(publish_obj.name,publish_obj.MinPrice)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;annotate的返回值是querySet，如果不想遍历对象，可以用上valuelist：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
queryResult= Publish.objects.annotate(MinPrice=Min(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).values_list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MinPrice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(queryResult)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sql语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
SELECT &quot;app01_publish&quot;.&quot;name&quot;, MIN(&quot;app01_book&quot;.&quot;price&quot;)  AS &quot;MinPrice&quot; FROM &quot;app01_publish&quot; 
LEFT  JOIN &quot;app01_book&quot; ON (&quot;app01_publish&quot;.&quot;nid&quot; = &quot;app01_book&quot;.&quot;publish_id&quot;) 
GROUP BY &quot;app01_publish&quot;.&quot;nid&quot;, &quot;app01_publish&quot;.&quot;name&quot;, &quot;app01_publish&quot;.&quot;city&quot;, &quot;app01_publish&quot;.&quot;email&quot; 
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2) 练习：统计每一本书的作者个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ret=Book.objects.annotate(authorsNum=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3) 统计每一本以py开头的书籍的作者个数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 queryResult=Book.objects.filter(title__startswith=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(num_authors=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4) 统计不止一个作者的图书：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
queryResult=Book.objects.annotate(num_authors=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).filter(num_authors__gt=1)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5) 根据一本图书作者数量的多少对查询集 &lt;tt class=&quot;docutils literal&quot;&gt;QuerySet&lt;/tt&gt;进行排序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Book.objects.annotate(num_authors=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).order_by(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(6) 查询各个作者出的书的总价格:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按author表的所有字段 group by&lt;/span&gt;
queryResult=Author.objects.annotate(SumPrice=Sum(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).values_list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SumPrice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(queryResult)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8993fb45-9e21-48e0-8042-822169300e4b')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_8993fb45-9e21-48e0-8042-822169300e4b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8993fb45-9e21-48e0-8042-822169300e4b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8993fb45-9e21-48e0-8042-822169300e4b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8993fb45-9e21-48e0-8042-822169300e4b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ————————————单表下的分组查询&lt;/span&gt;
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    查询每一个部门名称以及对应的员工数
    emp:
    id  name age   salary    dep
  alex  12   2000     销售部
  egon  22   3000     人事部
  wen   22   5000     人事部
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select count(id) from emp group by dep&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例一：查询每一个部门的名称，以及平均薪水&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select dep,Avg(salary) from app01_emp group by dep&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Avg, Count, Max, Min
    ret&lt;/span&gt;=Emp.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新命名&lt;/span&gt;
    ret=Emp.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(avg_salary=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ---*******单表分组查询ORM总结：表名.objects.values('group by 的字段').annotate(聚合函数（'统计的字段'）)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例2 查询每个省份对应的员工数&lt;/span&gt;
    ret=Emp.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    ret&lt;/span&gt;=Emp.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 补充知识点：&lt;/span&gt;
    ret=&lt;span&gt;Emp.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; select * from emp&lt;/span&gt;
    ret=Emp.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; select name from emp&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ****单表下，按照id进行分组是没有任何意义的&lt;/span&gt;
    ret=Emp.objects.all().annotate(Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ******多表分组查询&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每一个出版社出版的书籍个数&lt;/span&gt;
    ret=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每个出版社的名称以及出版社书的个数(先join在跨表分组)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正向&lt;/span&gt;
    ret=Publish.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    ret&lt;/span&gt;=Publish.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向&lt;/span&gt;
    ret=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    ret&lt;/span&gt;=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每个作者的名字，以及出版过书籍的最高价格&lt;/span&gt;
    ret=Author.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跨表查询的模型：每一个后表模型.objects.value('pk').annotate(聚合函数('关联表__统计字段')).values()&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每一个书籍的名称，以及对应的作者个数&lt;/span&gt;
    ret=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计不止一个作者的图书&lt;/span&gt;
    ret=Book.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(c=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).filter(c__gt=1).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;六 F查询与Q查询&lt;/h3&gt;
&lt;h4&gt;F查询&lt;/h4&gt;
&lt;p&gt;在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？&lt;/p&gt;
&lt;p&gt;Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询评论数大于收藏数的书籍&lt;/span&gt;
 &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt; F&lt;span&gt;#
&lt;/span&gt; Book.objects.filter(commnetNum__lt=F(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keepNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询评论数大于收藏数2倍的书籍&lt;/span&gt;
Book.objects.filter(commnetNum__lt=F(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keepNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)*2)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改操作也可以使用F函数,比如将每一本书的价格提高30元：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Book.objects.all().update(price=F(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+30)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Q查询&lt;/h4&gt;
&lt;p&gt;&lt;span id=&quot;yiyi-212&quot; class=&quot;yiyi-st&quot;&gt;&lt;tt class=&quot;xref py py-meth docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;filter()&lt;/span&gt;&lt;/tt&gt; 等方法中的关键字参数查询都是一起进行“AND” 的。 &lt;span id=&quot;yiyi-213&quot; class=&quot;yiyi-st&quot;&gt;如果你需要执行更复杂的查询（例如&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;OR&lt;/span&gt;&lt;/tt&gt; 语句），你可以使用&lt;tt class=&quot;xref py py-class docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q &lt;span class=&quot;pre&quot;&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt; Q&lt;span&gt;#
&lt;/span&gt;Q(title__startswith=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象可以使用&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&amp;amp;&lt;/span&gt;&lt;/tt&gt; 和&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;|&lt;/span&gt;&lt;/tt&gt; 操作符组合起来。&lt;span id=&quot;yiyi-218&quot; class=&quot;yiyi-st&quot;&gt;当一个操作符在两个&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象上使用时，它产生一个新的&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
bookList=Book.objects.filter(Q(authors__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)|Q(authors__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等同于下面的SQL &lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;WHERE&lt;/span&gt;&lt;/tt&gt; 子句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
WHERE name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; OR name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以组合&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&amp;amp;&lt;/span&gt;&lt;/tt&gt; 和&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;|&lt;/span&gt;&lt;/tt&gt;  操作符以及使用括号进行分组来编写任意复杂的&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象。&lt;span id=&quot;yiyi-222&quot; class=&quot;yiyi-st&quot;&gt;同时，&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象可以使用&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;~&lt;/span&gt;&lt;/tt&gt; 操作符取反，这允许组合正常的查询和取反(&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;NOT&lt;/span&gt;&lt;/tt&gt;) 查询：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;yiyi-st&quot;&gt;查询函数可以混合使用&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q 对象&lt;/span&gt;&lt;/tt&gt;和关键字参数。&lt;span id=&quot;yiyi-228&quot; class=&quot;yiyi-st&quot;&gt;所有提供给查询函数的参数（关键字参数或&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象）都将&quot;AND”在一起。&lt;span id=&quot;yiyi-229&quot; class=&quot;yiyi-st&quot;&gt;但是，如果出现&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Q&lt;/span&gt;&lt;/tt&gt; 对象，它必须位于所有关键字参数的前面。&lt;span id=&quot;yiyi-230&quot; class=&quot;yiyi-st&quot;&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
bookList=Book.objects.filter(Q(publishDate__year=2016) | Q(publishDate__year=2017), title__icontains=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询评论数大于阅读数的书籍&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; F,Q
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; select * from book where commit_num&amp;gt;read_num;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这样肯定是不行的&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Book.objects.filter(commit_num__gt=read_num)&lt;/span&gt;
    ret=Book.objects.filter(commit_num__gt=F(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reat_num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把所有书籍的价格加10&lt;/span&gt;
    Book.objects.all().update(price=F(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+10&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----Q函数，描述一个与，或，非的关系&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询名字叫红楼梦或者价格大于100的书&lt;/span&gt;
    ret=Book.objects.filter(Q(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)|Q(price__gt=100&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询名字叫红楼梦和价格大于100的书&lt;/span&gt;
    ret = Book.objects.filter(Q(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;amp; Q(price__gt=100&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 等同于&lt;/span&gt;
    ret2=Book.objects.filter(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,price__gt=100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以Q套Q&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询名字叫红楼梦和价格大于100  或者 nid大于2&lt;/span&gt;
    ret=Book.objects.filter((Q(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;amp; Q(price__gt=100))|Q(nid__gt=2&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----非&lt;/span&gt;
    ret=Book.objects.filter(~Q(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Q和键值对联合使用，但是键值对必须放在Q的后面(描述的是一个且的关系)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询名字不是红楼梦，并且价格大于100的书&lt;/span&gt;
    ret=Book.objects.filter(~Q(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;红楼梦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),price__gt=100&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 11 Sep 2018 16:58:00 +0000</pubDate>
<dc:creator>迎风而来</dc:creator>
<og:description>一 创建模型 实例：我们来假定下面这些概念，字段和关系 作者模型：一个作者有姓名和年龄。 作者详细模型：把作者的详情放到详情表，包含生日，手机号，家庭住址等信息。作者详情模型和作者模型之间是一对一的关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sui776265233/p/9631921.html</dc:identifier>
</item>
<item>
<title>java中Class.getMethods()和Class.getDeclaredMethods()的区别 - freeTimeWY</title>
<link>http://www.cnblogs.com/wy697495/p/9631909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wy697495/p/9631909.html</guid>
<description>&lt;p&gt;　　在java中，可以根据Class类的对象，知道某个类（接口）的一些属性（成员 ，方法，注释，注解）等。由于最近的工作中用到了这些，其中需要在代码中格局反射知道某些类的方法，查看文档的时候，看到了getMethods()和getDeclaredMethods()的差异。虽然两者都能实现目的，但个人觉得还是有必要区分下。&lt;/p&gt;
&lt;p&gt;　　JDK API（1.6）文档中是这样翻译两个方法的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getMethods()：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;返回一个包含某些 &lt;code&gt;Method&lt;/code&gt; 对象的数组，这些对象反映此 &lt;code&gt;Class&lt;/code&gt; 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 &lt;em&gt;member&lt;/em&gt; 方法。数组类返回从 &lt;code&gt;Object&lt;/code&gt; 类继承的所有（公共）member 方法。返回数组中的元素没有排序，也没有任何特定的顺序。如果此 &lt;code&gt;Class&lt;/code&gt; 对象表示没有公共成员方法的类或接口，或者表示一个基本类型或 void，则此方法返回长度为 0 的数组。类初始化方法 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 不包含在返回的数组中。如果类声明了带有相同参数类型的多个公共成员方法，则它们都会包含在返回的数组中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getDeclaredMethods()：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;返回 &lt;code&gt;Method&lt;/code&gt; 对象的一个数组，这些对象反映此 &lt;code&gt;Class&lt;/code&gt; 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。返回数组中的元素没有排序，也没有任何特定的顺序。如果该类或接口不声明任何方法，或者此 &lt;code&gt;Class&lt;/code&gt; 对象表示一个基本类型、一个数组类或 void，则此方法返回一个长度为 0 的数组。类初始化方法 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 不包含在返回数组中。如果该类声明带有相同参数类型的多个公共成员方法，则它们都包含在返回的数组中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　大致上来看，两个方法的区别主要在于：getMethods()返回的是该类以及超类的公共方法。getDeclaredMethods()返回该类本身自己声明的包括公共、保护、默认（包）访问和私有方法，但并不包括超类中的方法。比如如下列子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestObject
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method1()
    {
        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method2()
    {
        
    }
    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; method3()
    {
        
    }
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method4()
    {
        
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        Method[] methods &lt;/span&gt;= TestObject.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getMethods();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getMethods():&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods)
        {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(method.getName());
        }
        
        Method[] methods2 &lt;/span&gt;= TestObject.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getDeclaredMethods();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===========================&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getDeclaredMethods():&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods2)
        {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(method.getName());
        }
    }
}&lt;p&gt;运行TestClass结果：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;getMethods():&lt;br/&gt;method2&lt;br/&gt;wait&lt;br/&gt;wait&lt;br/&gt;wait&lt;br/&gt;equals&lt;br/&gt;toString&lt;br/&gt;hashCode&lt;br/&gt;getClass&lt;br/&gt;notify&lt;br/&gt;notifyAll&lt;br/&gt;===========================&lt;br/&gt;getDeclaredMethods():&lt;br/&gt;method1&lt;br/&gt;method2&lt;br/&gt;method3&lt;br/&gt;method4&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　很明显getMethods()就返回一个自己声明的method2()方法，其余的方法全部是来自Object类。getDeclaredMethods()返回了自生声明的四个方法。两个方法的主要区别就在这里吧。&lt;/p&gt;
&lt;p&gt;另外，返回Method数组为0 的情况也是JDK按照文档上介绍的一样。比如”空”接口，基本类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestInterface
{
    
}&lt;br/&gt;//两种方法返回的都是空&lt;br/&gt;以及基本类型：&lt;/span&gt;两种方法返回的也都是空
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Method[] methods = int.class.getMethods();&lt;br/&gt;Method[] methods2 = int.class.getDeclaredMethods();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;其实Class中有很多相似的方法比如：getAnnotations()和getDeclaredAnnotations()，以及getFields()和getDeclaredFields()等等，不同之处和上面基本一样。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：本文仅代表个人理解和看法哟！和本人所在公司和团体无任何关系！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 16:47:00 +0000</pubDate>
<dc:creator>freeTimeWY</dc:creator>
<og:description>在java中，可以根据Class类的对象，知道某个类（接口）的一些属性（成员 ，方法，注释，注解）等。由于最近的工作中用到了这些，其中需要在代码中格局反射知道某些类的方法，查看文档的时候，看到了get</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wy697495/p/9631909.html</dc:identifier>
</item>
<item>
<title>计算机网络系列--什么是电路交换和分组交换？ - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9631875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9631875.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;97.5&quot;&gt;
&lt;h4 id=&quot;-&quot;&gt;分组&lt;/h4&gt;
&lt;p&gt;首先我们来了解下分组的概念。所谓分组，就是将一个数据包分成一个个更小的数据包。例如对于一个10GB的数据包，总不可以一次性发送过去吧，而是把它分成若干个小的数据包发送过去。每个分组数据块的结构图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c1bc3b1ee955f?w=457&amp;amp;h=198&amp;amp;f=png&amp;amp;s=3401&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;文件头一般是一些说明性数据，例如源地址和目标地址，数据类型等。数据部分就是真正要传达给对象的内容&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;电路交换&lt;/h3&gt;
&lt;p&gt;所谓&lt;strong&gt;交换&lt;/strong&gt;，指的就是服务器与服务器之间的数据交换。数据传输交换的方式有几种，而&lt;strong&gt;电路交换&lt;/strong&gt;便是其中的一种。&lt;/p&gt;
&lt;p&gt;假如A和B之间要进行通信，我们就假设A要和E打个电话吧。当A输入E的电话号码，开始拨号之后，那么服务器要做的第一件事就是根据E的电话号码找到E在哪里，由于A通往E的路径有多条，会根据某种算法找到E之后，建立一条通路，然后进行数据的传输。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c1b28e4c686c1?w=569&amp;amp;h=358&amp;amp;f=png&amp;amp;s=7193&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们假设选的路径是A→D-→E&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c1b41e24dadff?w=562&amp;amp;h=369&amp;amp;f=png&amp;amp;s=8201&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;找到一条通往E的路径并建立会话的过程中，我们称之为电路交换的第一阶段—-建立连接。之后A和E在通话的过程中会始终&lt;strong&gt;霸占着这条路径&lt;/strong&gt;，数据传输的过程称为电路交换的第二阶段—-数据传输。&lt;/p&gt;
&lt;p&gt;电路交换的第三阶段，也就是最后一个阶段—-释放连接。A和B只要有一方挂了电话，那便了开始释放连接。&lt;br/&gt;传输例题图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c1b6702e45441?w=272&amp;amp;h=351&amp;amp;f=png&amp;amp;s=36326&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在这个过程中，新建连接需要花销一定的额外时间（想象你打电话的时候是不是出现&lt;strong&gt;正在拨号&lt;/strong&gt;的字眼），释放连接也会花销一些额外的时间。&lt;/p&gt;
&lt;p&gt;那么，电话交换的过程中，数据需要分组来传送吗？&lt;br/&gt;答是不用的，因为电话交换的过程中，A和B两个人始终霸占着一条通信电路，他们每说一句话，都会实时被对方获取，因此数据是不用分组的。&lt;br/&gt;从这也可以看出，电路交换的方式，在数据的传输上是比较&lt;strong&gt;高效、实时的&lt;/strong&gt;，只要A一发出数据，E立马就能收到了,这也是为什么我们的电话通信使用的是电路交换的方式。&lt;br/&gt;但由于一直霸占着这条路径，假如霸占的过程中A与E都在沉默不说话，那么将是对这条路径的极大浪费。因此，电路连接的方式资源的利用率是比较低的。&lt;br/&gt;而且，如果你通话的时间超级短，可能花在新建连接的时间比通话的时间还要长，这就更加难受了。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;稍微总结一下&lt;/h5&gt;
&lt;p&gt;电路连接的三个阶段：&lt;br/&gt;1、建立连接。&lt;br/&gt;2、数据传输。&lt;br/&gt;3、释放连接。&lt;br/&gt;优点：&lt;br/&gt;1、传输速度快、高效。&lt;br/&gt;2、实时。&lt;br/&gt;缺点：&lt;br/&gt;1、资源利用率低。&lt;br/&gt;2、新建连接需要占据一定的时间，甚至比通话的时间还长。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;分组交换&lt;/h3&gt;
&lt;p&gt;从名字&lt;strong&gt;分组&lt;/strong&gt;字眼，我们就可以知道，这种方式数据包是分组成更小的数据包进行传输的。分组交换的数据传输过程和电路交换不一样，分组交换采取&lt;strong&gt;存储转发传输&lt;/strong&gt;的机制。我们下面还是以A给E传输数据作为例子来讲解。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;假如A要给E发送一个数据包P，但这个数据包有点大，需要分成三组，例如分成p1,p2,p3三个更小的数据包。&lt;br/&gt;这时A给E传输数据不需要&lt;strong&gt;新建连接&lt;/strong&gt;这个过程，即不需要寻找一个通往E的路径。而且A直接把小的数据包丢给附近的路由器，然后A就不管了，例如A把p1丢给了B，这个时候A就不在去管p1的，当B收到p1这个完整的小数据包之后，B再丢给E。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;但是A不一定都会把剩下的数据包都丢给B，有可能会把其他的数据包p2丢给C,之后再把p3丢给D，然后C和D在转发丢给E。这些都是不确定的，会根据某种算法的选择路由器。&lt;br/&gt;这里有一个关键词&lt;strong&gt;存储&lt;/strong&gt;，就是说，B必须收到完整的p1数据包后才能进行转发，这也不难理解，因为p1数据包包含E的地址，如果不是完整的数据包，B也不知道该发给谁啊。&lt;br/&gt;示例图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c1b79e6a7fd9c?w=214&amp;amp;h=364&amp;amp;f=png&amp;amp;s=30516&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从电路交换的机制我们可以看出如下的一些问题：&lt;br/&gt;由于A把数据包丢给B之后就不管了，B什么时候会把p1转发出去，谁也不知道，而且可能B会绕几个圈子再发给E也是有可能的。因为，电路交换的机制在数据传输方面&lt;strong&gt;不具有实时性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;而且，很有可能会有很多路由器把数据包丢给B，这个时候就会造成&lt;strong&gt;通信阻塞&lt;/strong&gt;，这时可能p1只能排队等待B来发送。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;由于B路由器的容量是有限的，如果有太多的数据包丢给它，它可能会容纳不下，这时候就可能会出现&lt;strong&gt;丢包&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;再者，由于p1,p2,p3数据包都有文件头，里面都包含了A和E的一些信息，当然还有其他的信息。可以说这些文件头有很多重复的数据，因此分组交换发送的数据具有很多的&lt;strong&gt;重复无用数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;当然，分组交换还包括&lt;strong&gt;时延&lt;/strong&gt;的缺点，因为B必须收到一个完整的p1才能把p1转发出去，因为这个接受存储的过程中存在&lt;strong&gt;时延&lt;/strong&gt;，这种时延也成为&lt;strong&gt;传输时延&lt;/strong&gt;，当然还存在&lt;strong&gt;传播时延&lt;/strong&gt;和&lt;strong&gt;处理时延&lt;/strong&gt;等。所谓处理时延就是每次都得检查这个数据包的文件头和决定将该数据包传输给谁。&lt;/p&gt;
&lt;p&gt;说了电路交换的这么多缺点，那总得有优点吧？&lt;br/&gt;实际上，上面的那些缺点，其实都不是什么大问题的。电路交换最主要的优点就是&lt;strong&gt;设计简单&lt;/strong&gt;，资源&lt;strong&gt;利用率高&lt;/strong&gt;了。&lt;/p&gt;
&lt;h5 id=&quot;-&quot;&gt;总结下分组交换&lt;/h5&gt;
&lt;p&gt;分组交换采用把一个个小的数据包&lt;strong&gt;存储转发传输&lt;/strong&gt;的机制。&lt;br/&gt;主要的一些缺点：&lt;br/&gt;1、不具有实时性。&lt;br/&gt;2、存在延时。&lt;br/&gt;3、会造成通信阻塞。&lt;br/&gt;4、存在无用的重复数据。&lt;br/&gt;5、会出现丢包的情况。&lt;br/&gt;致命的优点：&lt;br/&gt;1、设计简单。&lt;br/&gt;2、资源利用率很高。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;生活中的通信选择&lt;/h3&gt;
&lt;p&gt;两种交换传输的特点决定了我们平时的电话通信使用的是电路交换，像互联网中的微信等这种不要求实时的通信用分组交换。&lt;br/&gt;这也就是为什么急事的时候会打电话，因为比较实时嘛。像微信这些，有时你发个信息，可能网络不好的话，或者太多人在同时使用的话，可能你的信息要过一阵子对方才能收到。&lt;/p&gt;
&lt;p&gt;这里可能有些人会说，分组交换为何要把数据包分成一小个来存储转发呢？一个大的数据包发过去不好吗？&lt;br/&gt;假如你的一个数据包100GB，那B这个路由器就得能存100GB的容量，可是发100GB的概率是极少数的，那把路由器设计成100GB不是很浪费？这也是为什么要分组成小数据包的原因之一。&lt;/p&gt;
&lt;p&gt;当然，还有一种&lt;strong&gt;报文交换&lt;/strong&gt;的方式，就是一整个数据包存储转发的，不过这种方式使用的比较少，再此就不详细展开了。&lt;/p&gt;
&lt;p&gt;来一张三种交换传输的图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/10/165c1b8f3ed287d9?w=736&amp;amp;h=544&amp;amp;f=png&amp;amp;s=145062&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关注公我的众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;，获取更多原创文章，后台回复&lt;strong&gt;礼包&lt;/strong&gt;送你一份特别的资源大礼包。同时也感谢把文章介绍给更多需要的人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 11 Sep 2018 16:22:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>分组 首先我们来了解下分组的概念。所谓分组，就是将一个数据包分成一个个更小的数据包。例如对于一个10GB的数据包，总不可以一次性发送过去吧，而是把它分成若干个小的数据包发送过去。每个分组数据块的结构图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9631875.html</dc:identifier>
</item>
<item>
<title>第三节：使用Log4net和过滤器记录异常信息，返回异常给前端 - 往事随灬锋</title>
<link>http://www.cnblogs.com/lifeng618/p/9630570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifeng618/p/9630570.html</guid>
<description>&lt;p&gt;上次面试，遇到，在项目中如何处理业务异常和代码异常，使用txt记录异常信息后，如何直接区分出异常的类型，异常怎么分类处理，希望大家能帮我提出宝贵的意见，完善处理异常，&lt;br/&gt;&lt;/p&gt;
&lt;h3&gt;统一返回参数&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    public class HeaderResult
    {
        public HeaderResult()
        {
            // ReSharper disable once VirtualMemberCallInConstructor
            IsSucceed = false;
        }
     
        public virtual bool IsSucceed { get; set; }
       
        public virtual string Message { get; set; }
      
        public virtual T Result { get; set; }
       
        public virtual string StatusCode { get; set; }
    }
    
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建一个过滤器&lt;/h3&gt;
&lt;p&gt;在过滤器中拦截异常信息，使用Log4net 记录日志到txt中，获取到异常信息统一返回给前端&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;pre&gt;

&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public class ProjectExceptionFilter : IExceptionFilter
 {
    public void OnException(ExceptionContext context)
    {         
       Exception exception = context.Exception;
        var exceptionType = exception.GetType().ToString();
        if (exceptionType == &quot;ProjectCore.Common.DomainException&quot;)
        {
            //用来分类处理业务逻辑
        }
        //获取controller的名称
        var controller = context.RouteData.Values[&quot;controller&quot;].ToString();
        //获取Action的名称
        var action = context.RouteData.Values[&quot;Action&quot;].ToString();
        var errorPath = controller + &quot;/&quot; + action;
        LogHelper.LogError(&quot;web service error:&quot; + errorPath, exception);           
        //返回异常信息给前端
        context.Result = new JsonResult(new HeaderResult&amp;lt;string&amp;gt;
        {
            Message = &quot;错误路径:&quot; + errorPath + &quot;:错误信息&quot; + exception.Message+&quot;&quot;,
            IsSucceed = false
        });         
        //异常已处理了
        context.ExceptionHandled = true;          
    }
}
&amp;lt;/pre&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Log4net 记录日志到txt中 log4net.config网上有许多，这里就不贴出来了&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;&lt;pre&gt;

&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public static class LogHelper
{
    private static ILog _logger;

    static LogHelper()
    {
        ILoggerRepository repository = LogManager.CreateRepository(&quot;NETCoreRepository&quot;);
        XmlConfigurator.Configure(repository, new FileInfo(&quot;log4net.config&quot;));          
        LogHelper._logger = LogManager.GetLogger(repository.Name, &quot;NETCorelog4net&quot;);
    }
    public static void LogError(string msg, Exception ex)
    {
        string errorMsg = string.Format(&quot;【抛出信息】：{0} &amp;lt;br/&amp;gt;【异常类型】：{1} &amp;lt;br/&amp;gt;【异常信息】：{2} &amp;lt;br/&amp;gt;【堆栈调用】：{3}&quot;, new object[] { msg,
        ex.GetType().Name, ex.Message, ex.StackTrace });
        errorMsg = errorMsg.Replace(&quot;\r\n&quot;, &quot;&amp;lt;br&amp;gt;&quot;);
        errorMsg = errorMsg.Replace(&quot;位置&quot;, &quot;&amp;lt;strong style=\&quot;color:red\&quot;&amp;gt;位置&amp;lt;/strong&amp;gt;&quot;);         
        LogHelper._logger.Error(errorMsg);
    }
    public static void LogInfo(string msg)
    {
        LogHelper._logger.Info((object)msg);
    }
    public static void LogDebug(string msg)
    {
        LogHelper._logger.Debug((object)msg);
    }
}
&amp;lt;/pre&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Startup 下面配置&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;pre&gt;

&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;       services.AddMvc(options =&amp;gt;
        {

            options.Filters.Add(typeof(ProjectExceptionFilter));              
            options.Filters.Add(typeof(ModelVerificationFilter));              
        }).
           SetCompatibilityVersion(CompatibilityVersion.Version_2_1).
            AddJsonOptions(options =&amp;gt;
            {
                //忽略循环引用
                options.SerializerSettings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
                //不使用驼峰样式的key
                options.SerializerSettings.ContractResolver = new DefaultContractResolver();
                //设置时间格式
                options.SerializerSettings.DateFormatString = &quot;yyyy-MM-dd&quot;;
            });
&amp;lt;/pre&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 11 Sep 2018 16:08:00 +0000</pubDate>
<dc:creator>往事随灬锋</dc:creator>
<og:description>上次面试，遇到，在项目中如何处理业务异常和代码异常，使用txt记录异常信息后，如何直接区分出异常的类型，异常怎么分类处理，希望大家能帮我提出宝贵的意见，完善处理异常， 统一返回参数 public cl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifeng618/p/9630570.html</dc:identifier>
</item>
<item>
<title>优先队列 Rust实现 - 弱冠</title>
<link>http://www.cnblogs.com/kwebi/p/9631773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwebi/p/9631773.html</guid>
<description>&lt;p&gt;优先队列是用来维护一组元素集合的数据结构&lt;/p&gt;
&lt;p&gt;一个最小优先队列支持下列操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;heap_insert_key(i, key)&lt;/code&gt;把key插入键i的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_extract_min()&lt;/code&gt;删除并返回堆的最小值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以用堆来实现优先队列&lt;br/&gt;关于建堆的操作，之前的文章已经介绍过了&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub struct MinHeap {
    size: usize,
    array: Vec&amp;lt;i32&amp;gt;,
}

impl MinHeap {
    pub fn new(array: Vec&amp;lt;i32&amp;gt;) -&amp;gt; MinHeap {
        MinHeap {
            size: array.len(),
            array,
        }
    }
    fn parent(i: usize) -&amp;gt; usize {
        i / 2
    }
    fn left(i: usize) -&amp;gt; usize {
        2 * i
    }
    fn right(i: usize) -&amp;gt; usize {
        2 * i + 1
    }
    fn heap_size(&amp;amp;self) -&amp;gt; usize {
        self.size
    }
    fn swap(&amp;amp;mut self, a: usize, b: usize) {
        self.array.swap(a, b);
    }
    fn min_heapify(&amp;amp;mut self, mut i: usize) {
        loop {
            let l = MinHeap::left(i);
            let r = MinHeap::right(i);
            let mut min;
            if l &amp;lt;= self.size &amp;amp;&amp;amp; self.array[i - 1] &amp;gt; self.array[l - 1] {
                min = l;
            } else {
                min = i;
            }
            if r &amp;lt;= self.size &amp;amp;&amp;amp; self.array[min - 1] &amp;gt; self.array[r - 1] {
                min = r;
            }
            if min == i {
                break;
            } else {
                self.swap(i - 1, min - 1);
            }
            i = min;
        }
    }
    pub fn build_min_heap(&amp;amp;mut self) {
        for i in (1..self.size + 1).rev() {
            self.min_heapify(i);
        }
    }
    fn heap_exterct_min(&amp;amp;mut self) -&amp;gt; i32 {
        let size = self.size;
        if size &amp;lt; 1 {
            panic!(&quot;heap underflow&quot;);
        }
        let max = self.array[0];
        self.swap(0, size - 1);
        self.size -= 1;
        self.min_heapify(1);
        max
    }
    pub fn heap_insert_key(&amp;amp;mut self, mut i: usize, key: i32) {
        if key &amp;gt; self.array[i - 1] {
            panic!(&quot;the new key is larger&quot;);
        }
        self.array[i - 1] = key;
        let mut parent = MinHeap::parent(i);
        while i &amp;gt; 1 &amp;amp;&amp;amp; self.array[i - 1] &amp;lt; self.array[parent - 1] {
            self.swap(i - 1, parent - 1);
            i = parent;
            parent = MinHeap::parent(i);
        }
    }
    pub fn min_heap_insert(&amp;amp;mut self, key: i32) {
        self.size += 1;
        self.array.push(i32::max_value());
        let i = self.size;
        self.heap_insert_key(i, key);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Sep 2018 15:46:00 +0000</pubDate>
<dc:creator>弱冠</dc:creator>
<og:description>优先队列 优先队列是用来维护一组元素集合的数据结构 一个最小优先队列支持下列操作： + 把key插入键i的值 + 删除并返回堆的最小值 可以用堆来实现优先队列 关于建堆的操作，之前的文章已经介绍过了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwebi/p/9631773.html</dc:identifier>
</item>
</channel>
</rss>