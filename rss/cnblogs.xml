<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>day26_Struts2学习笔记_03 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9243774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9243774.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;28&quot;&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;一、国际化概念（了解）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1&quot;&gt;&lt;span&gt;&lt;strong&gt;1、什么是国际化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;   &lt;code&gt;软件&lt;/code&gt;的国际化：软件开发时，要使它能同时应对世界不同地区和国家的访问，并针对不同地区和国家的访问，提供相应的、符合来访者阅读习惯的页面或数据。&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;&lt;span&gt;&lt;strong&gt;2、什么需要国际化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;   程序：需要国际化。&lt;br/&gt;   输入的数据：是什么样的就是什么样的。&lt;br/&gt;   比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户注册的表单，有用户名，密码这5个汉字，在zh_CN语言环境，显示的就是用户名和密码。但是在en_US语言环境，显示的就应该是username和password。这就是 &lt;code&gt;程序&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;用户名输入的是【张三】，密码输入的是【test】，那无论在什么语言环境都应该是是【张三】和【test】。这就是 &lt;code&gt;数据&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h3&quot;&gt;&lt;span&gt;&lt;strong&gt;3、固定文本的国际化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;   例如：消息提示、错误提示和菜单，导航栏等等固定文本。&lt;br/&gt;步骤：&lt;/p&gt;
&lt;h4 id=&quot;h31&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、创建一个消息资源包&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;   一个资源包由多个文件组成，这些文件名都有命名规范：&lt;code&gt;主要文件名_语言代码_国家代码.properties&lt;/code&gt;。&lt;br/&gt;   语言代码：由iso规定的。国家代码：由iso规定的。&lt;br/&gt;   当文件只有 &lt;code&gt;主要文件名.properties&lt;/code&gt; 时，表明它是 &lt;code&gt;默认资源包&lt;/code&gt;。浏览器会根据不同的语言环境找对应语言环境的资源包，当没有找到时，找默认的。&lt;br/&gt;   每个资源包的内容都由 &lt;code&gt;相同的key&lt;/code&gt; 和 &lt;code&gt;对应语言环境的value&lt;/code&gt; 组成。&lt;br/&gt;   比如：&lt;br/&gt;      &lt;code&gt;message_zh_CN.properties&lt;/code&gt; 、 &lt;code&gt;message_zh_HK.properties&lt;/code&gt;、&lt;code&gt;message_en_US.properties&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;h32&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、读取资源包中的内容&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;国际化的小测试，如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pb2obezfz.bkt.clouddn.com/01_%E5%9B%BD%E9%99%85%E5%8C%96%E5%B0%8F%E6%B5%8B%E8%AF%95.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;jsp中使用国际化：&lt;br/&gt;配置文件 &lt;code&gt;message_zh_CN.properties&lt;/code&gt; 和 &lt;code&gt;message_en_US.properties&lt;/code&gt; 的书写：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pb2obezfz.bkt.clouddn.com/02_jsp%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BD%E9%99%85%E5%8C%96_01.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;login.jsp文件：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pb2obezfz.bkt.clouddn.com/02_jsp%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BD%E9%99%85%E5%8C%96_02.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;效果如下图所示：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pb2obezfz.bkt.clouddn.com/02_jsp%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BD%E9%99%85%E5%8C%96_03.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://pb2obezfz.bkt.clouddn.com/02_jsp%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BD%E9%99%85%E5%8C%96_04.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;但是呢？&lt;code&gt;login.jsp中不允许出现下面的java代码块（jsp2.0以后的规定），需要用jsp的标签来替代。&lt;/code&gt;使用jstl的fmt标签，如下图所示：
&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;javascript language-javascript hljs&quot;&gt;&amp;lt;% &lt;br/&gt;Locale locale = request.getLocale();&lt;br/&gt;ResourceBundle bundle = ResourceBundle.getBundle(&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.itheima.resource.message&quot;&lt;/span&gt;,locale);&lt;br/&gt;%&amp;gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;　（很像dbutils中KeyedHandler封装数据的结构，&lt;code&gt;注意：只是像其封装数据的结构而已&lt;/code&gt;，把结果集封装成一个Map，Map里面又是一个Map，大Map的key是主键，大Map的value是一个小Map，是一条记录）&lt;/p&gt;


</description>
<pubDate>Fri, 29 Jun 2018 07:41:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9243774.html</dc:identifier>
</item>
<item>
<title>低于0.01%的极致Crash率是怎么做到的？ - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9243593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9243593.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看似系统Bug的Crash 99%都不是系统问题！本文将与你一起探索Crash分析的科学方法。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;在移动互联网闯荡多年的iOS手机管家，经过不断迭代创新，已经涵盖了隐私（加密相册）、安全（骚扰拦截、短信过滤）、工具（网络检测、照片清理、极简提醒等）等等各个方面，为千万用户提供安全专业的服务。但与此同时，工程代码也越来越庞大（近30万行），一丁点的问题都会影响大量的用户，所以手管一直在质量上下狠功夫，对Crash率更是追求极致。近几个迭代对Crash做了专项分析，Crash率在原本0.02%的基础上稳定降到0.01%，7.7.1版本逼近0.009%，此文将对两类典型的Crash案例进行分析总结。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、案例分析&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Crash主要产生在Objective-C方法调用或系统方法调用，所以本文的两个典型案例正是针对OC和C方法调用来展开：&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1.1. Crash发生在objc_msgSend&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Crash堆栈长这样！Σ（ﾟдﾟlll）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150530030-493040498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;

&lt;p&gt;是的，看到这个堆栈我也很方，一眼望去只有一行是工程的代码堆栈，还是个main，但深入分析了Objective-C的消息机制后我们还是能找到问题的突破口的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crash类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们看到这是一个SEGV_ACCERR类型的Crash，访问了错误的地址。&lt;/p&gt;

&lt;p&gt;其次，通过汇编代码分析objc_msgSend方法，我们可以得知objc_msgSend + 16这一行代码（如下图2）是在读取当前OC方法的receiver的isa指针偏移0x10的处的值（见附录推荐的objc_msgSend链接文章），由于对象已经被释放了，所以读取该地址导致了读取错误地址，也即产生了野指针Crash。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150547480-1615510565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查找寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是，我们查看Crash时各寄存器的值（见图3），其中x0是发生Crash的函数的第一个参数，针对objc_msgSend来说x0同时表示指向发生Crash的对象的地址，x1是Crash的函数的第二个参数，在objc_msgSend中表示Crash的对象调用的selector，RDM很贴心，已经帮我们查询出该selector为respondsToSelector:。如果x1是我们工程中自己写的一个方法就很容易分析问题了，直接查找工程代码，定位到该函数即可找到原因，可是respondsToSelector:调用的地方太多了，怎么办呢？我们还要继续往里挖。&lt;/p&gt;

&lt;p&gt;因为respondsToSelector:的参数是一个selector，所以只要再查出这个selector是什么（对应查询x2在符号表中的符号），也可以马上定位到问题代码。但是很遗憾，x2不在Crash报告中Binary Images中的任一个模块的地址范围内，那，还有办法吗？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150603767-202798424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3&lt;/p&gt;

&lt;p&gt;办法还是有的，我们知道lr寄存器是当前函数的上一层函数调用地址，如果能知道lr寄存器执行的方法就可以进一步确定问题，很幸运，lr的值刚好就是Binary Images中管家模块地址范围内（见图3，lr是0x000000010508be44，管家模块范围是0x104c24000 - 0x1055affff），于是在符号表中搜索lr对应的符号，得到如下的信息：（下图中的MQQABC为你的app的符号表文件，在xcode打包提交时需要保存下来，对应XXX.app.dSYM/Contents/Resources/DWARF/XXX）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150626253-295634450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4&lt;/p&gt;

&lt;p&gt;至此，我们知道图1那个只有main信息的堆栈产生的Crash是在-[MQQAlertView didDismissWithButtonIndex:]的第530行，产生Crash的原因是调用了respondsToSelector:，已经十分接近答案了，但是MQQAlertView是管家一个通用的弹窗组件，所以还需要知道是哪个页面出现了这个Crash。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定位问题页面&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;手管利用RDM的Crash上报组件可以在Crash产生时上报附件的特性，将一些关键的信息存储到了附件上（当前的ViewController堆栈、上一次释放的ViewController、applicationState等），可以在RDM平台上查看这些附件信息，于是我们查看附件信息，发现是在用户退出某页面A时产生的Crash。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;得出问题原因→→&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，Crash的路径已经很清楚了：用户进入页面A，页面A弹出一个弹窗，在弹窗未弹出前用户快速退出页面，退出页面时没有把弹窗关掉，然后用户点击了弹窗，由于弹窗的delegate是页面A，而页面A已经释放，所以导致了访问了野指针。&lt;/p&gt;

&lt;p&gt;问题原因查明，问题代码定位精确，问题也就不难修复了。&lt;/p&gt;

&lt;p&gt;注：objc_msgSend + 16是典型的野指针导致的Crash堆栈，遇到这类问题，基本上按照上述思路&lt;strong&gt;都可以顺利解决。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1.2. Crash发生在C函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;棘手的Crash通常关键堆栈都是落在系统函数上，这也为我们把锅甩给系统找到一个很好的借口，但想办法解决问题才是目标，毕竟系统是没办法帮你背这个锅的¯\_(ツ)_/¯下面这个例子是结合Crash报告提供的信息分析解决问题的典型案例：&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150704842-29587218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150711794-1213074556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5&lt;/p&gt;

&lt;p&gt;从Crash报告可以看到几个关键信息：&lt;/p&gt;

&lt;p&gt;1）Crash类型同样是访问了非法地址SEGV_ACCERR，非法地址是0x68&lt;/p&gt;

&lt;p&gt;2）Crash发生在子线程（Thread 7）&lt;/p&gt;

&lt;p&gt;3）Crash是落在flockfile + 24的位置上&lt;/p&gt;

&lt;p&gt;于是我们通过Xcode调试到flockfile函数，并定位到 + 24的位置（如下图6断点的位置）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150735292-2069512488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6&lt;/p&gt;

&lt;p&gt;ldr    x8,  [x19,  #0x68]  这句汇编代码的含义是从x19偏移0x68的地址上加载数据存储到x8中。结合SEGV_ACCERR，我们知道这个地址非法了，而且非法地址是0x68，也就是说x19 + 0x68 = 0x68，推出=&amp;gt; x19 = 0，再往上看到第5行：mov    x19,  x0，可以知道x19的值是由x0赋值得来的，所以x0 = 0，又因为x0是函数的第一个参数，所以可以得出flockfile的入参为0，查看flockfile的定义：&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;void                flockfile(FILE  *)；&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见，这里的FILE *指针为空了。结合堆栈中管家工程中的代码调用：&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt; - [MQQCBKAsdfUpdater mgPchAsdfCfgFileWithOFP:pFP:toFP:result:error:]&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到，传入了三个文件路径，所以问题必定是其中一个文件不存在了。至此就是我们从Crash报告中能分析出来的信息，再结合查看工程代码得出：问题代码最初是在主线程执行，中间dispatch到子线程（从Crash报告得出），线程间状态没有控制好导致切换到子线程执行的过程中文件被删除了而导致了Crash。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、方法总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上分析仅是对过程的回顾，略去了许多细节，这一节进行补充。因为Crash分析主要就是要搞清楚发生Crash时函数调用发生了什么，所以这一节主要分为几个部分：&lt;/p&gt;

&lt;p&gt;1）ARM64的函数调用约定&lt;/p&gt;

&lt;p&gt;2）常用汇编指令&lt;/p&gt;

&lt;p&gt;3）Objective-C函数调用的特点&lt;/p&gt;

&lt;p&gt;4）查找符号表&lt;/p&gt;

&lt;p&gt;5）Crash报告关键信息&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.1. ARM64函数调用约定&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;由于目前主流机型都是iPhone 5s以上的机型了，所以这里只介绍ARM64。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.1.1. ARM64指令集的寄存器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150819202-1897433124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图7（摘自ARM64参考手册）&lt;/p&gt;

&lt;p&gt;ARM64指令集有31个64bit的通用整形寄存器：x0到x30（w0到w30表示只取这些寄存器的低32位）&lt;/p&gt;

&lt;p&gt;x0到x7用来做参数传递，以及从子函数返回结果（通常通过x0返回，如果是一个比较大的结构体则结果会存在x8的执行地址上）&lt;/p&gt;

&lt;p&gt;LR：即x30寄存器，也叫链接寄存器，一般是保存返回上一层调用的地址&lt;/p&gt;

&lt;p&gt;FP：即r29，栈底寄存器&lt;/p&gt;

&lt;p&gt;外加一个栈顶寄存器SP&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.1.2. 栈&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;栈是从高地址到低地址延伸的，栈底是高地址，栈顶是低地址&lt;/p&gt;

&lt;p&gt;fp指向当前栈帧的栈低，即高地址&lt;/p&gt;

&lt;p&gt;sp指向当前栈帧的栈顶，即低地址&lt;/p&gt;

&lt;p&gt;下图8是_funcA调用_funcB的栈帧情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150841646-1790996479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图8（摘自技术博客）&lt;/p&gt;

&lt;p&gt;_funcB的前三行代码如图8的汇编代码所示：&lt;/p&gt;

&lt;p&gt;第1行stp指令是表示将_funcA的栈底指针fp、链接寄存器lr存到_funcA的栈顶sp - 0x10的地址上，并将sp设置为sp - 0x10（图中fp_B），方便后续从_funcB返回_funcA，并恢复_funcA的栈帧&lt;/p&gt;

&lt;p&gt;第2行是把sp赋给fp，即设置_funcB的栈底指针（图中fp_B）&lt;/p&gt;

&lt;p&gt;第3行是把sp设置为sp - 0x30。由此完成了_funcA对_funcB的调用。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.1.3. 实例分析&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;下面通过一个实例来分析函数的参数传递&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150905597-68679705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9&lt;/p&gt;

&lt;p&gt;如图9有两个方法，OC方法是一个按钮点击事件，点击后调用上面的C方法，为了调试方便C方法有11个参数，本例中&lt;strong&gt;入参的值是1到11&lt;/strong&gt;，可以观察到超过8个参数时是怎么传参的。&lt;/p&gt;

&lt;p&gt;为了看到调用过程的汇编代码，我们需要在- (IBAction)testCmethodCall1:(id)sender中设置断点，然后在Xcode中设置Always Show Disaasembly（见图10），这样调试过程中看的就是汇编代码了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150933044-1412528454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图10&lt;/p&gt;

&lt;p&gt;我们断点到OC方法，汇编代码如图11&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629150950898-970097854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图11&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数调用状态切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第1行：sub    sp,  sp,  #0x40  设置新的栈顶寄存器（sp）&lt;/p&gt;

&lt;p&gt;第2行：stp    x29,  x30,  [sp,  #0x30]  把栈底寄存器（x29即fp）、链接寄存器（x30即lr）保存起来&lt;/p&gt;

&lt;p&gt;第3行：add    x29,  sp,  #0x30  把fp（x29）设置为sp + 0x30，即设置新的栈底寄存器&lt;/p&gt;

&lt;p&gt;这3行，完成了系统对按钮点击事件方法的调用所需的状态切换工作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为C函数准备入参&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来直到str    w13,  [sp,  #0x8]  都是在为调用C方法准备参数，因为没有经过优化所以显得很啰嗦。&lt;/p&gt;

&lt;p&gt;orr    w8,  wzr,  #0x1  是一个或指令，把零寄存器或上1的值赋给w8寄存器，就是w8 = 1，下面的类似，分别把2到11赋给w9-w10、w3-w7、w11-w13&lt;/p&gt;

&lt;p&gt;stur    x0,  [x29,  #-0x8]  把x0保存到x29 - 0x8上&lt;/p&gt;

&lt;p&gt;stur    x1,  [x29,  #-0x10]  把x1保存到x29 - 0x10上&lt;/p&gt;

&lt;p&gt;str    x2,  [sp,  #0x18]  把x2保存到sp + 0x18上&lt;/p&gt;

&lt;p&gt;mov    x0,  x8把前面赋值为1的x8（orr    w8,  wzr,  #0x1）赋给x0&lt;/p&gt;

&lt;p&gt;mov    x1,  x9，同理，把2赋给x1&lt;/p&gt;

&lt;p&gt;mov    x2,  x10，同理，把3赋给x2，由此可见前面w8、w9、w10只是中转用的，至此x0-x7已经将可以直接传值的寄存器都赋上了正确的值，接下来的3行则可以看到是怎么处理超过8个整形参数的情况&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过栈传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;str    w11,  [sp]  把前面赋值为9（mov    w11,  #0x9）的w11存到栈顶位置&lt;/p&gt;

&lt;p&gt;str    w12,  [sp,  #0x4]  把前面赋值为10（mov    w12,  #0xa）的w12存到栈顶偏移0x4的位置&lt;/p&gt;

&lt;p&gt;str    w13,  [sp,  #0x8]  把前面赋值为11（mov    w13,  #0xb）的w13存到栈顶偏移0x8的位置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用C函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至此，入参全部准备完毕，接下来调用bl    0x104fc237c就可以调用C函数了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151022263-385995068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图12&lt;/p&gt;

&lt;p&gt;进入C函数的汇编代码，我们先明确下这段C函数的任务是：return a1 + a2 + a11，所以应该是把OC函数中w0、w1、w13（w13存在栈上[sp,  #0x8]）的值拿出来相加，得到的结果存到x0上，然后返回，所以：&lt;/p&gt;

&lt;p&gt;sub    sp,  sp,  #0x30  把栈顶指针设置为sp - 0x30，这样的话，之前w13存在的栈的位置就变成了[sp,  #0x38]，所以你会看到图12最后一个红圈ldr    w1,  [sp,  #0x38]其实就是把之前保存w13的值load到w1中&lt;/p&gt;

&lt;p&gt;str    w0,  [sp,  #0x2c]和str    w1,  [sp,  #0x28]把w0、w1的值存到栈上，然后又用ldr    w0,  [sp,  #0x2c]和ldr    w1,  [sp,  #0x28]把w0、w1的值取出来，没优化的汇编真的很啰嗦&lt;/p&gt;

&lt;p&gt;add    w0,  w0,  w1  把w0、w1的值加起来存到w0（即计算了a1 + a2）&lt;/p&gt;

&lt;p&gt;ldr    w1,  [sp,  #0x38]  前面说过取出w13的值存到w1&lt;/p&gt;

&lt;p&gt;add    w0,  w0,  w1  把w0、w1的值加起来存到w0（即计算了a1 + a2 + a11），现在计算完的结果存到了w0中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;由上面的分析过程我们可以看到：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;子函数开头的汇编代码会调整fp、sp指针&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;参数传递少于8个的使用x0-x7寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;超过8个的则使用栈来传递&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;子函数的返回值一般存在x0中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为x0、x1、x29、x30等寄存器有特殊含义，所以有时候会把这些寄存器的值先存到栈上，然后再使用它们&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.2. 常用汇编指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1节已经接触了几个汇编指令，下面整理下常用的几个汇编指令：&lt;/p&gt;

&lt;p&gt;mov    a,  b  即a = b&lt;/p&gt;

&lt;p&gt;ldr    a,  [b]  将b指针所在地址上的内容加载a寄存器中&lt;/p&gt;

&lt;p&gt;str    a,  [b]  将a寄存器存储到b指针指向地址上&lt;/p&gt;

&lt;p&gt;ldr    a,  [b,  #0x10]  从b寄存器地址+0x10的地址上加载内容到a寄存器中&lt;/p&gt;

&lt;p&gt;ldr    a,  [b,  #0x10]!  带感叹号的意思是把内容加载到a寄存器中，并且修改b寄存器为b = b + 0x10&lt;/p&gt;

&lt;p&gt;cmp    a,  b  比较a、b寄存器的值，会修改cpsr&lt;/p&gt;

&lt;p&gt;cbz    xd,  addr  判断xd寄存器是否为0，是则跳转到addr地址处执行&lt;/p&gt;

&lt;p&gt;cbnz    xd,  addr  判断xd寄存器是否不为0，不为0则跳转到addr&lt;/p&gt;

&lt;p&gt;b  跳转指令，不修改lr寄存器，所以子函数调用过程不会出现在堆栈中&lt;/p&gt;

&lt;p&gt;bl  跳转指令，修改lr寄存器，所以子函数调用过程会出现在堆栈中&lt;/p&gt;

&lt;p&gt;stp    a,  b,  [c]  从c地址中取出两个64位值分别存储到a、b两个寄存器中&lt;/p&gt;

&lt;p&gt;ldp    a,  b,  [c]  把a、b两个寄存器的值存储到c地址中&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.3. Objective-C函数调用的特点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Objective-C函数调用是一种特殊的函数调用，但最终也是转化为C函数调用的方式。&lt;/p&gt;

&lt;p&gt;我们都知道Objective-C调用最终都会调用objc_msgSend(id self, SEL selector, ...)，然后再用前面的知识分析objc_msgSend即可&lt;/p&gt;

&lt;p&gt;可以看到，x0就是调用的receiver，x1就是调用的selector，后面则是参数。具体可以查看附录中相关的文章。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.4. 查找符号表&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151051120-396105277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图13&lt;/p&gt;

&lt;p&gt;Crash报告中有Binary Images：&lt;/p&gt;

&lt;p&gt;1）模块的起止地址：比如图13中MQQABC模块的起始地址是0x104c24000，结束地址是0x1055affff，所以我们可以通过这些模块的起止地址来判断一个我们感兴趣的寄存器的地址是属于哪个模块的&lt;/p&gt;

&lt;p&gt;2）模块的UUID，如图13中MQQABC的UUID是f130b043a0c832d9958d89dab8339961，通过它可以判定你的符号文件是正确的，如图14用dwarfdump&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151106756-1720336618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图14&lt;/p&gt;
&lt;p&gt;3）用atos查找地址对应的符号，-l需要提供1）中提到的模块起始地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151119834-1379036390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图15&lt;/p&gt;

&lt;p&gt;4）如果用atos查找出来的结果仍然是个地址，还需要在mach-O文件的__TEXT段或__RODATA段的__objc_methname中进一步查找（注意：第一个红框中查询出来的0x在otool查找Mach-O文件中要去掉）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151132390-1908003166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图16&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2.5. Crash报告关键信息&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151157068-1969773716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图17&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151217390-196384548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图18 结合寄存器值查找关键信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201806/992994-20180629151230701-1850173448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图19 确定符号表UUID及起止地址&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;腾讯WeTest是由腾讯官方推出的一站式质量开放平台。&lt;/strong&gt;十余年品质管理经验，致力于质量标准建设、产品质量提升。腾讯WeTest为移动开发者提供兼容性测试、云真机、性能测试、安全防护、企鹅风讯（舆情分析）等优秀研发工具，为百余行业提供解决方案，覆盖产品在研发、运营各阶段的测试需求，历经千款产品磨砺。金牌专家团队，通过5大维度，41项指标，360度保障您的产品质量。&lt;/p&gt;

&lt;p&gt;腾讯互娱为提高苹果应用的审核通过率，专门成立了苹果审核测试团队，打造出iOS预审工具这款产品。经过长时间的内部运营和磨炼，腾讯苹果应用审核通过率从平均35%提升到90%+。&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击链接；&lt;/span&gt;&lt;/strong&gt;&lt;a href=&quot;http://wetest.qq.com/product/ios?from=content_cnblogs&quot;&gt;http://wetest.qq.com/product/ios&lt;/a&gt;&lt;strong&gt; 邀您立刻体验。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 07:15:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9243593.html</dc:identifier>
</item>
<item>
<title>开发自定义ScriptableRenderPipeline，将DrawCall降低180倍 - 陈嘉栋</title>
<link>http://www.cnblogs.com/murongxiaopifu/p/9243540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murongxiaopifu/p/9243540.html</guid>
<description>&lt;h2 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;大家都知道，Unity在2018版本中正式推出了Scriptable Render Pipeline。我们既可以通过Package Manager下载使用Unity预先创建好的LightWeight Render Pipeline和High Defination Render Pipeline，也可以自己动手创建自定义的Render Pipeline，实现一些符合自己心意的渲染策略。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-5cd34298ef96527c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-06-25 下午4.43.06.png&quot;/&gt;&lt;br/&gt;下面我们先简单介绍一下自定义SRP的使用方法，之后利用自定义的Render Pipeline来优化一个常见的情景，即渲染半透时由于渲染顺序被打乱，从而导致的合批失败。&lt;/p&gt;
&lt;h2 id=&quot;x01-一个简单的srp流水线实现&quot;&gt;0x01 一个简单的SRP流水线实现&lt;/h2&gt;
&lt;p&gt;如何自定义一个Scriptable Render Pipeline，Unity有一篇博客[1]已经做了简单的介绍。&lt;br/&gt;根据这篇博客，我们知道，首先要定义一个继承自&lt;strong&gt;UnityEngine.Experimental.Rendering.RenderPipeline&lt;/strong&gt;的类，并且覆写其中的&lt;strong&gt;Render&lt;/strong&gt;方法，在该方法中实现自己的渲染逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//定义渲染管线逻辑
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;

public class BasicPipeInstance : RenderPipeline
{
    private Color m_ClearColor = Color.black;

    public BasicPipeInstance(Color clearColor)
    {
        m_ClearColor = clearColor;
    }

    public override void Render(ScriptableRenderContext context, Camera[] cameras)
    {
        // does not so much yet :()
        base.Render(context, cameras);

        // clear buffers to the configured color
        var cmd = new CommandBuffer();
        cmd.ClearRenderTarget(true, true, m_ClearColor);
        context.ExecuteCommandBuffer(cmd);
        cmd.Release();
        context.Submit();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个脚本的逻辑十分简单，即使用纯色来清屏。ScriptableRenderContext 类的实例context即当前的渲染上下文，保存了当前的渲染状态。&lt;br/&gt;有了渲染管线的逻辑，之后我们要做的就是调用&lt;strong&gt;AssetDatabase.CreateAsset&lt;/strong&gt;将这个渲染管线保存为一个Asset，储存在硬盘上，并将这个Asset赋值给Graphics Setting以激活该管线。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-84e2e0377e19112a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们接下来就需要一个能够被Unity创建出Asset并被序列化保存的类，在SRP中这个类叫做&lt;strong&gt;RenderPipelineAsset&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ExecuteInEditMode]
//定义渲染管线Asset
public class BasicAssetPipe : RenderPipelineAsset
{
    public Color clearColor = Color.blue;

    protected override IRenderPipeline InternalCreatePipeline()
    {
        return new BasicPipeInstance(clearColor);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就能很方便的创建出一个渲染管线的Asset，和传统的Scriptable Object一样，我们可以直接通过Asset来修改其字段的内容，这里我们只定义了一个名字是clearColor的字段。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-63406690b69ab35a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，我们可以创建完Asset之后，再手动给Graphics Setting赋值，也可以直接在脚本中给Graphics Setting赋值，只需要访问GraphicsSettings.renderPipelineAsset即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using UnityEngine;
using UnityEditor;
using UnityEngine.Rendering;
public class MySRPCreate
{
    [MenuItem(&quot;Assets/Create/MySRP&quot;)]
    public static void CreateSRP()
    {
        var instance = ScriptableObject.CreateInstance&amp;lt;BasicAssetPipe&amp;gt;();
        AssetDatabase.CreateAsset(instance, &quot;Assets/MyScriptableRenderPipeline.asset&quot;);
        GraphicsSettings.renderPipelineAsset = instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，打开相关的菜单，点击按钮，整个Unity的传统渲染管线就被替换成了我们刚刚自定义的渲染管线——简单的说，就是一个纯色清屏。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-cae4690dc9ccf21d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x02-自定义管线让dc从3700到20&quot;&gt;0x02 自定义管线，让DC从3700到20&lt;/h2&gt;
&lt;p&gt;OK，接下来我们来看一个有趣的场景。这个场景中，我们通过脚本来生成2种角色，每一种角色的数量有1500名——需要渲染的当然还包括她们的影子。为了尽量减少DrawCall的数量，自然会想到开启GPU Instance。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-c59ab6e4b5500a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;这个是Unity的默认渲染管线的渲染成果，可是打开Frame Debugger我们可以发现渲染的成本高的吓人，DrawCall数量达到了3700次左右——在打开了GPU Instance的情况下。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-ccd3199462f2c31a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看一下某次DrawCall的GPU Instance失败原因，是由于&quot;Objects have different materials&quot;。而查看相关的DrawCall数据，可以发现2种角色和阴影出现了交替渲染的情况，这样便导致了materials 不同造成的GPU Instance失败。&lt;/p&gt;
&lt;p&gt;所以接下来我们要做的事情，就是能否自己来对这个场景内的对象进行渲染排序，因为我们希望的是角色和阴影的渲染不要交替出现，所以理想状态是先把所有的角色面片渲染出来，接下来再来渲染阴影。&lt;/p&gt;
&lt;p&gt;在自定义渲染流水线中实际调用绘制指令时，我们还会遇到一些别的类型和方法。例如，我们需要先对场景进行裁剪，选出需要被渲染的对象。&lt;br/&gt;在这里我们会遇到&lt;strong&gt;CullResults&lt;/strong&gt;结构体，以及&lt;strong&gt;ScriptableCullingParameters&lt;/strong&gt;结构体。通过这两个结构体以及它们所定义的方法，我们可以获取经过裁剪之后需要被渲染的对象以及灯光数据——分别保存在CullResults的&lt;strong&gt;visibleLights&lt;/strong&gt;字段以及&lt;strong&gt;visibleRenderers&lt;/strong&gt;字段中。&lt;br/&gt;获取了visibleLights也就是光照信息之后，我们就可以为我们的管线设置光照数据了。&lt;/p&gt;
&lt;p&gt;例如，我们把方向光的颜色传入到shader的&lt;strong&gt;LightColor0&lt;/strong&gt;变量中，把方向光的方向传入到shader的&lt;strong&gt;WorldSpaceLightPos0&lt;/strong&gt;变量中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    foreach( var visibleLight in visibleLights)
    {
        if (visibleLight.lightType == LightType.Directional)
        {
            Vector4 dir = -visibleLight.localToWorld.GetColumn(2) ;
            Shader.SetGlobalVector(ShaderNameHash.LightColor0, visibleLight.finalColor);
            Shader.SetGlobalVector(ShaderNameHash.WorldSpaceLightPos0, new Vector4(dir.x,dir.y,dir.z,0.0f) );
            break;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而visibleRenderers中保存的则是需要被渲染的对象。涉及到对象的渲染，我们显然需要确定一些渲染设置，在自定义管线中保存这些设置的是&lt;strong&gt;DrawRendererSettings&lt;/strong&gt;结构体。&lt;/p&gt;
&lt;p&gt;一些常见的渲染设置，例如最常见的便是设置所使用的shader——更具体的说是使用的pass，这里Unity也对Shader的pass名字做了一个简单封装，即&lt;strong&gt;ShaderPassName&lt;/strong&gt;结构体，它用来指定我们所使用的shader pass，正确设置后，Unity会在Renderer所使用的shader中寻找指定的pass。&lt;/p&gt;
&lt;p&gt;除此之外，如果需要被渲染的对象不是一个，那么显然会涉及到一个排序的问题。同样我们也可以设置DrawRendererSettings结构体的sorting.flags来确定排序规则。可以设置的排序规则，可以查看这个文档：&lt;br/&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/Experimental.Rendering.SortFlags.html&quot; class=&quot;uri&quot;&gt;https://docs.unity3d.com/ScriptReference/Experimental.Rendering.SortFlags.html&lt;/a&gt;&lt;br/&gt;其中有一个叫做SortFlags.OptimizeStateChanges的规则，看上去这个很适合我们的需求，因为它的技能描述是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sort objects to reduce draw state changes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时visibleRenderers中包括的待渲染对象不仅有角色、还包括四周的墙体、以及角色脚下的阴影面片，所以为了达到先把所有的角色面片渲染出来，接下来再来渲染阴影的目的——也就是说为了规避所谓的穿插问题——我们接下来先把需要渲染的角色过滤出来。此时我们需要另一个结构体来实现过滤的需求——&lt;strong&gt;FilterRenderersSettings&lt;/strong&gt;。FilterRenderersSettings可以按照待渲染对象所在的RenderQueue和layer来筛选真正需要被渲染的对象。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-a13ea13b36f3a0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，角色的渲染队列设置的3000，也就是transparent。所以我们可以用RenderQueue来进行一次筛选，再使用layer筛选出角色——角色所在的layer叫做Chara。&lt;/p&gt;
&lt;p&gt;Ok，到这里，我们就筛选出了需要被渲染的角色，并且设置好了角色的渲染状态。最后，我们直接调用Draw指令，并把这些设置作为参数传入Draw即可。&lt;br/&gt;把以上的逻辑封装为一个方法，在Render中调用该方法就可以渲染出所有的角色了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void DrawCharacter(ScriptableRenderContext context, Camera camera, ShaderPassName pass,SortFlags sortFlags)
{
    var settings = new DrawRendererSettings(camera, pass);
    settings.sorting.flags = sortFlags;

    var filterSettings = new FilterRenderersSettings(true)
    {
        renderQueueRange = RenderQueueRange.transparent,
        layerMask = 1 &amp;lt;&amp;lt; LayerDefine.CHARA
    };
    context.DrawRenderers(cull.visibleRenderers, ref settings, filterSettings);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就渲染出了3000多个角色——在只用了8个DrawCall的情况下。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-1f493660744cd6f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2018-06-28 下午6.20.41.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个小目标达成。&lt;/p&gt;
&lt;p&gt;背景墙体，和阴影其实也大同小异，因为我们已经对可能产生穿插渲染的对象做出了区分，先全部渲染角色，再渲染阴影。重点在于分组渲染。渲染墙体、阴影面片的代码要做的也便是将墙体、阴影对象过滤出来，进行单独渲染。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void DrawBg(ScriptableRenderContext context, Camera camera)
{
    var settings = new DrawRendererSettings(camera, basicPass);
    settings.sorting.flags = SortFlags.CommonOpaque;

    var filterSettings = new FilterRenderersSettings(true)
    {
        renderQueueRange = RenderQueueRange.opaque,
        layerMask = 1 &amp;lt;&amp;lt; LayerDefine.BG
    };
    context.DrawRenderers(cull.visibleRenderers, ref settings, filterSettings);
}

private void DrawShadow(ScriptableRenderContext context, Camera camera)
{
    var settings = new DrawRendererSettings(camera, basicPass);
    settings.sorting.flags = SortFlags.CommonTransparent;

    var filterSettings = new FilterRenderersSettings(true)
    {
        renderQueueRange = RenderQueueRange.transparent,
        layerMask = 1 &amp;lt;&amp;lt; LayerDefine.SHADOW
    };
    context.DrawRenderers(cull.visibleRenderers, ref settings, filterSettings);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，我们只需要再在Render方法中依次调用DrawBg和DrawShadow即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public override void Render(ScriptableRenderContext context, Camera[] cameras)
{
    base.Render(context, cameras);
    if (cmd == null)
    {
        cmd = new CommandBuffer();
    }
    foreach (var camera in cameras)
    {
        if (!CullResults.GetCullingParameters(camera, out cullingParams))
            continue;
        CullResults.Cull(ref cullingParams, context,ref cull);

        context.SetupCameraProperties(camera);

        cmd.Clear();
        cmd.ClearRenderTarget(true, true, Color.black,1.0f);
        context.ExecuteCommandBuffer(cmd);

        SetUpDirectionalLightParam(cull.visibleLights);

        //Draw
        DrawCharacter(context, camera, zPrepass, SortFlags.OptimizeStateChanges);
        DrawBg(context, camera);
        DrawShadow(context, camera);


        context.Submit();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;渲染的结果便是：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1372105-87700b4fe1a7b651.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;角色、背景、阴影分别渲染，互不干扰，而DrawCall也从Unity默认的管线中的3700次降低到了使用我们自定义管线的20次。&lt;/p&gt;
&lt;h2 id=&quot;x03-小结&quot;&gt;0x03 小结&lt;/h2&gt;
&lt;p&gt;利用SRP，我们可以根据项目自身的特点来定制很多有趣的内容，从这个小的演示中我们应该可以体验到这种灵活性所带来的性能上的提升。&lt;/p&gt;
&lt;p&gt;好了，如果有技术讨论的需求，欢迎加群：&lt;br/&gt;Unity官方中文社区群：470161914&lt;br/&gt;Unity官方中文社区②群：629212643&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;
&lt;p&gt;[1]&lt;a href=&quot;https://blogs.unity3d.com/cn/2018/01/31/srp-overview/&quot; class=&quot;uri&quot;&gt;https://blogs.unity3d.com/cn/2018/01/31/srp-overview/&lt;/a&gt;&lt;br/&gt;[2]&lt;a href=&quot;https://github.com/wotakuro/CustomScriptRenderPipelineTest&quot; class=&quot;uri&quot;&gt;https://github.com/wotakuro/CustomScriptRenderPipelineTest&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 07:08:00 +0000</pubDate>
<dc:creator>陈嘉栋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/murongxiaopifu/p/9243540.html</dc:identifier>
</item>
<item>
<title>索引的一些事一些情 - 浮云骑士LIN</title>
<link>http://www.cnblogs.com/linlinismine/p/9236169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linlinismine/p/9236169.html</guid>
<description>&lt;p&gt;&lt;strong&gt;    之前在我的上一篇文章《&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/linlinismine/p/9221517.html&quot;&gt;系统性能优化二三事&lt;/a&gt;》中提到了sql的性能优化的问题。因为时间和篇幅的关系，当时并没有进行什么讨论，那现在我们就来讨论关于索引的一些事一些情~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    认识索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    索引也叫做&quot;键(key)&quot;，是存储引擎用于快速找到记录的一种数据结构。&lt;/strong&gt;&lt;strong&gt;索引分为两种：b-tree索引、hash索引。这两种索引的实现上的区别是b-tree索引是建立一种叫b+tree的数据结构上面，而hash索引则是用一个hash函数建立一种类似hashmap的数据结构。因为底层结构的关系我们的b-tree索引支持、范围查询、排序、模糊匹配等功能,而hash索引只支持全值匹配查询。所以我们日常工作中用到的索引基本都是b-tree索引，并且后面的讨论的索引指的就是b-tree索引~。hash索引虽然只支持全值匹配，但是只要hash函数设计的好，key分布的均匀，基本上每次查询的时间复杂度都可以看作是O(1)，这性能也是杠杠的~。另外索引不一定是建了就能起效果，索引建的不好的一般的结果是没有走索引也就是索引没起效这种结果就是扫全表，但是有些时候你可能会发现走了某些索引的查询可能会比扫全表更慢。。。这个后面会有具体的例子进行量化分析~。所以我们知道建索引这么简单的一个操作也是个技术活~。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;    确定建索引的目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     建索引容易，但是建好索引不易。所以建索引之前我们先要了解一下索引是如何工作来帮助我们的sql实现快速查询，如果不了解其原理的话那我们就很难决定把表中的哪些列放到我们的索引和如何决定这些列的顺序~。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    其实总的来说&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;索引帮助我们的sql实现快速查是在体现在三个方面：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       1、减少服务器需要扫描的数据量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       2、避免排序和临时表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       3、将随机I/O变成顺序I/O&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   所以当我们建一个索引之后就可以围绕这三个维度来判断索引的好坏~。另外对于索引的评级是有一个三星标准的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   1、如果与一个查询相关的索引行是相邻的，或者至少足够靠近的话，那这个索引就可以被标记上第一颗星。这最小化了必须扫描的索引片的宽度。这句话看字面可能起来有绕，其实简单一点描述就是指如果数据库需要扫描的索引行是最少的那就获得了第一颗星~&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  2、如果索引行的顺序与查询语句的需求一致，则索引可以被标记上第二颗星。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  3、如果索引行包含查询语句中的所有列——那么索引就可以被标记上第三颗星。这避免了访问表的操作，仅访问索引就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    我们整理一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;数据库需要扫描的索引行是最少 -&amp;gt; &lt;strong&gt;减少服务器需要扫描的数据量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;索引行的顺序与查询语句的需求一致 -&amp;gt; &lt;/strong&gt;避免排序和临时表，&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;将随机I/O变成顺序I/O &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;索引行包含查询语句中的所有列 -&amp;gt; &lt;strong&gt;减少服务器需要扫描的数据量,&lt;/strong&gt;将随机I/O变成顺序I/O &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    所以你知道三星标准和三个维度其实说的是一回事儿~。 知道建索引的目标之后，那下面我们来学习一下如何建索引。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    如何建索引&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    这里讨论建的索引指的是b-tree索引并且我们指定数据库是mysql，&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;存储引擎是innodb。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;93.624500665779&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180628194435806-1106054000.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;204&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;p&gt;  &lt;strong&gt;  b-tree索引的结构如上图所示。从结构上我们知道b-tree索引是一个树状的数据结构结点间相互连接，同一层的结点从左到右按value的值排序好，其实这种数据结构就叫b+tree。这个b+tree中文的意思就叫平衡树的意思。叫平衡树的原因，因为从树的根结点到任意一个叶子经过的路径长度都是相等的~。对于b+ree这种&lt;/strong&gt;搜索树的结构来说其实树越矮越胖是越好的，因为在这些结构中查询数据的时间复杂度其实是与树的高度成正比的~，原理和我们的二叉搜索树是一样的。正因为b-tree索引因为数据是排好序的所以它支持模糊匹配，范围查询，排序，group by 等高级操作~。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   如果有一个情景是让我们从user表中查询名字叫&quot;jack&quot;的年龄是25岁的男性，那应该是怎么去建一个b-tree索引？。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   如果是我一般会建一个(name,age,sex)的b-tree复合索引,why?。因为复合索引有一个最左匹配原则，我们sql的过滤条件都是先按最左边的过滤，如果索引的前面的列不能过滤那么后面的列也是不能过滤的这个道理我相信大家都理解。而我们的用户查询中常用的一个查询就是根据名字查询，所以name要放在第一列，至于第二列为什么放的是age呢，其实是从我们上面的三个维度和三星原则出发的。因为name通常是sex是强相关的，比如在西方国家一个叫jack的人通常可以肯定是个man而不会是个miss，这个在东方国家也是适用的，你能想像一个男人起个名字叫翠花么。。。并且因为人口基数众多，同名的人也多。所以name,sex放在前面两列是起不了多大的过滤效果。这就不符合我们的&quot;&lt;/strong&gt;减少服务器需要扫描的数据量&quot;和三星标准的第一标准，但是age是可以的，并且如果是按年排序的话，age第二列就已经排好序了，不经意间我们就创建了一个二星索引，所以把age第二行!。sex第三列则是用于滤精确结果。如果查询只要求返回name,age,sex三列那我们都不需要去查表里面的数据，直接返回索引里面的数据就可以了，这就是一个perfect的三星索引~。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      下面列举一些常用建索引的最佳实践：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      1、一般建索引时优先创建复合索引而不是多个单列索引，比如常用的几个过滤条件是A,B,C。那就应该创建一个（A,B,C）同时包含三列的复合索引因为这样的过滤效果最好，而不是分别建A,B,C三个单独索引。因为mysql在一个查询语句中只能选择生效一个索引~。如果创建单列索引的话，比如生效了(A)索引，B,C列的过滤就只能是读取表中的记录之后再进行过滤，如果是(A,B,C）复合索引的话就直接在索引就可以过滤好记录，大大的减少了服务器的读取数量~。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      2、复合索引一般是常用的过滤项放在靠前的位置，两个强相关的列不要放在紧挨在一起，这个上面的jack例子就有说明。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      3、一般来说优先选择数字的列和字段较小的列建索引，选择数字的列是因为cpu天生就支持数字的比较，运算复杂度看作是O(1)，如果是varchar(n)的话就要一个个字符去比较，那平均复杂度就是O(n/2)了。选择字段较小的列是因为索引也是占空间，如果索引太大不放进内存里面那每次读索引都要进行一次磁盘的读取，这个就很影响性能了。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;strong&gt;顺序IO、随机IO与索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     上面提到 &quot;&lt;/strong&gt;索引建的不好的一般的结果是没有走索引也就是索引没起效这种结果就是扫全表，但是有些时候你可能会发现走了某些索引的查询可能会比扫全表更慢&quot;。why？这就需要分析顺序IO与随机IO的区别了。顺序IO指的磁盘沿着扇区一直扫，比如磁盘的读取速度是40M/S,一条记录的大小是400Byte。那读取一条记录的时间是0.01ms。而一次随机IO理想的估算是大概是10ms左右，分析如下所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;             &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180629115933079-2046532811.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;120&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180629120028936-183234273.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;93&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      比如从一个10W条记录里面读取2000条记录如果是扫全表那花的时间是&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      10ms + 100000 * 0.01ms ~= 1s&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;       如果是随机I/O：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;       2000 * 10ms = 20s;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;       所以如果你的建的索引并没有把随机I/O变成顺序I/O那就可能会出现上面的这种情况了。不过有时候也不必要太担心，因为db都有一个叫优化器的东西，优化器往往能够分析出这种成本，帮你选择一种合理的执行方式。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;      索引是唯一提升查询速度的因素吗？&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;       这个当然不是了。在&lt;/strong&gt;《&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/linlinismine/p/9221517.html&quot;&gt;系统性能优化二三事&lt;/a&gt;》中我们提到缓存是一种性能优化的方式~。其实这在db查询也是一样的道理，比如mysql服务器会预加载索引和表行数据进到缓存里面，如果缓存已经有了需要的数据，那就不需要读一次磁盘，而我们的磁盘也有一层缓存，如果磁盘缓存里面有需要的数据，也不需要进行一次物理文件的读取。所以缓存的设置也是很重要的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;      索引的误区和注意的地方。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;      1、索引的层级不要超过5层。这条是常见的索引规范，其实这条的规范是有一定的适用范围的，并不是绝对的适用。因为提出这条规范的时候当时的计算机的内存还是非常的小，内存能放的东西非常的有限。如果索引的层级太多，那内存就可能放不下索引，这样读索引就要读一次磁盘，这性能就很差。但现在的计算机内存的容量比当时已经增大了成千上百倍，即使时是超过5层的索引也是可以放到内存里面。索引的层数越多，那过滤的效果就越好，实际读取的表数据就越好。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    2、单表的索引数不要超过六个。这个其实也是有适用范围的。提出这个规范的原因一方面是上面提到内存问题，另一个是表频繁更新问题，因为如果更新表的索引列索引也是更新的，索引的更新最终也会写回到磁盘。这就会增加磁盘的负载，影响整个数据库的性能。但如果这个表是不怎么更新的呢，更新频率很低或者不存在瞬间密集的更新，其实建立超过六个的索引也是可以的。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     其实索引还有很多东西可以讲，不过要讲清楚的话恐怕还要个十篇八&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;篇才行。。。现在就暂说到这~。后面有时间再陆续分享。    &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     阅读容易，码字不易。如果你喜欢我的文章或者觉得有所收获就请你点下关注或者推荐吧。这样作者才更加有写下去的动力~。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 29 Jun 2018 07:03:00 +0000</pubDate>
<dc:creator>浮云骑士LIN</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linlinismine/p/9236169.html</dc:identifier>
</item>
<item>
<title>[python,2018-06-29] 37%法则及其拓展解决恋爱问题 - NullMoneyException</title>
<link>http://www.cnblogs.com/shijt/p/9243510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shijt/p/9243510.html</guid>
<description>&lt;h2&gt;苏格拉底的问题：&lt;/h2&gt;
&lt;p&gt;　　在一片麦田里摘出一颗最大最好的麦穗。但只能摘一次，而且不能回头。&lt;/p&gt;
&lt;p&gt;传说这是苏格拉底给他的弟子柏拉图提出的问题，又传说柏拉图进行了2次选择：&lt;/p&gt;
&lt;p&gt;1.柏拉图第一次走进麦田，他发现很多很好的麦穗，他摘下了他看到的第一个比较大的麦穗，然后继续往前走，却沮丧地发现自己越走越失望，前面还有不少更好的，但是他却不能再摘了。&lt;/p&gt;
&lt;p&gt;2.柏拉图第二次走进麦田，他依然发现很多很好的麦穗，但是这一次他吸取教训——前面一定有更好的。他一直向前走，直到发现自己差不多走出了麦田。按照规则，他回不去了，而他刚刚错过了最好的麦穗。&lt;/p&gt;
&lt;p&gt;那怎么做才能拿到最大最好的问题呢？&lt;/p&gt;
&lt;h2&gt;分析：&lt;/h2&gt;
&lt;h3&gt;转化为数学问题：&lt;/h3&gt;
&lt;p&gt;　　已知在一个无序的集合 N 中（集合大小已知），一次只能查看一个数，查看后选择是否取出这个数，在只能取一次的情况下，怎么取到集合 N 中的最大数？&lt;/p&gt;
&lt;h3&gt;猜想：&lt;/h3&gt;
&lt;p&gt;　　对于这个集合，要取出最大的数， &quot;最大&quot;肯定是比较出来的，既然是比较，必须要有比较的对象，所以我们把集合 N 拆分为2个子集A和B，集合A用来观察和比较，&lt;/p&gt;
&lt;p&gt;集合B用来抽取 “最大” 的数。&lt;/p&gt;
&lt;p&gt;　　那么，该怎么拆分集合N呢？&lt;/p&gt;
&lt;p&gt;　　想到了2种方法：&lt;/p&gt;
&lt;p&gt;1.根据 &lt;a title=&quot;百度百科-大数定律&quot; href=&quot;https://baike.baidu.com/item/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B/410082?fromtitle=%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86&amp;amp;fromid=9679413&amp;amp;fr=aladdin&quot; target=&quot;_blank&quot;&gt;大数定理&lt;/a&gt; ，多次模拟在集合中取数，比较 取出的数 等于 集合中最大数频率，以频率估算概率。&lt;/p&gt;
&lt;p&gt;2.遍历所有的情况，根据 &lt;a title=&quot;全概率公式&quot; href=&quot;https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F&quot; target=&quot;_blank&quot;&gt;全概率公式&lt;/a&gt; ，进行数学计算。&lt;/p&gt;
&lt;h2&gt;解法1：&lt;/h2&gt;
&lt;p&gt;假设集合N大小为100，生成长度为100的随机数组，求出前 k 个数中的最大值 max_base，&lt;/p&gt;
&lt;p&gt;从 k+1 开始，如果这个数大于 max_base，则取出这个数作为结果，&lt;/p&gt;
&lt;p&gt;如果第 k+1 个数到最后都小于max_base，则取出最后一个数作为结果。&lt;/p&gt;
&lt;p&gt;重复抽取 100000 次，以频率估算概率，&lt;/p&gt;
&lt;p&gt;k的值为1-100，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Author:shijt&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取数组中前 number 个数中的最大数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getMaxBase(number,random_list):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(random_list[:number])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getMaxGuess(number,random_list):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     max_guess=&lt;span&gt;getMaxBase(number,random_list)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(number,100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (random_list[i] &amp;gt;= max_guess &lt;span&gt;or&lt;/span&gt; i==99&lt;span&gt;):  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             max_guess =&lt;span&gt; random_list[i]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max_guess
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1,100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100000&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         random_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成长度为100的随机数组&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             random_list.append(random.randint(1, 10000&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (getMaxGuess(j, random_list) == getMaxBase(100&lt;span&gt;, random_list)):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             count += 1
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(j,count, count / 100000)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码重复执行了3次，得到结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230826/201806/1230826-20180629140041594-2039882854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现了3种不同的结果，分别是当k =37，39，36时，取出最大数的频率较高，都 约等于 0.373&lt;/p&gt;
&lt;p&gt;由此猜测，当选择 37%-38%的数作为参考时，取得最大数的概率较高，约为0.373&lt;/p&gt;

&lt;h2&gt;解法2：&lt;/h2&gt;
&lt;p&gt; 假设取 k 个数作为观察集合，则对于某个固定的k，第 i 个数为最大数，由全概率公式：&lt;/p&gt;
&lt;h4&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230826/201806/1230826-20180629141600493-1530853902.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;当n充分大时，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230826/201806/1230826-20180629141720455-1446473804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，x=k/n, p(k)=1,&lt;/p&gt;
&lt;p&gt;所以，-xlnx=1,解得x=1/e,即 k/n=1/e,   e为自然对数的底&lt;/p&gt;
&lt;p&gt;1/e约等于 0.3679,约等于37%&lt;/p&gt;

&lt;h2&gt;解后分析：&lt;/h2&gt;
&lt;p&gt; 我们可以看到，解法1和解法2的结果虽然比较接近，但还是有些差别，我认为造成这个差别的原因有2个：&lt;/p&gt;
&lt;p&gt;1.在解法二中，要求集合N足够大，而解法1中的n为 100 ，显然不能满足足够大的条件，但是由于本人计算机能力有限，仅能以此作为粗略计算；&lt;/p&gt;
&lt;p&gt; 2.当k为 35-39时，彼此之间的概率相差极小，而大数定理本身也是一种估算方法，误差难以避免。&lt;/p&gt;
&lt;p&gt;总的来说，对于苏格拉底的问题，显然最好的方法就是 先观察前37% 的麦穗，然后再遇到比前面麦穗更大的麦穗时，就摘下，否则，则摘取最后一颗麦穗。&lt;/p&gt;


&lt;p&gt;有人以以上数学模型来解决 &lt;a title=&quot;恋爱问题&quot; href=&quot;https://www.guokr.com/article/6768/&quot; target=&quot;_blank&quot;&gt;恋爱问题&lt;/a&gt; ，我觉得不妥，原因有3：&lt;/p&gt;
&lt;p&gt;1.我们不必总是找到最好的那个作为伴侣，可以接受一个&lt;span&gt;相对较好的&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;2.我们不能接受很差的人作为伴侣，（当只剩下一个人时，我们就没得选）；&lt;/p&gt;
&lt;p&gt;3.我们最终是为了找到伴侣，&lt;span&gt;找到比找到最好的更为重要&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;问题：&lt;/h2&gt;
&lt;p&gt;　　已知在一个无序的集合 N 中（集合大小已知），一次只能查看一个数，查看后选择是否取出这个数，在只能取一次的情况下，怎么取到集合 N 中的&lt;span&gt;较大数&lt;/span&gt;？&lt;/p&gt;
&lt;p&gt;　　假设我们不必取到最大的数，而是以最大数的90%作为基准，大于90%则为符合需求的数，那么取得较大数的概率为多少？&lt;/p&gt;
&lt;h2&gt;分析：&lt;/h2&gt;
&lt;p&gt;我们和上面解法1一样，用大量的模拟实验来计算频率，并用频率估算概率。&lt;/p&gt;
&lt;h2&gt;解法：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Author:shijt&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; random_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     random_list.append(random.randint(1, 10000&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getMaxBase(number, random_list):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; max(random_list[:number])*0.9
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getMaxGuess(number, random_list):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     max_guess =&lt;span&gt; getMaxBase(number, random_list)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(number,100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (random_list[i] &amp;gt;= max_guess &lt;span&gt;or&lt;/span&gt; i == 99&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             max_guess =&lt;span&gt; random_list[i]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max_guess
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1,100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10000&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         random_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             random_list.append(random.randint(1, 10000&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (getMaxGuess(j, random_list) &amp;gt;= getMaxBase(100&lt;span&gt;, random_list)):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             count += 1
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(j,count, count / 10000)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;结果：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230826/201806/1230826-20180629145715110-2139269787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当选择63-65%的数作为参考时，可以得到 较大数 的概率较高，约等于95.7%，可以说远远高于 37%了，这才比较适合作为 恋爱问题的解法。&lt;/p&gt;
&lt;p&gt;PS：当你愿意降低要求到85%时，你会发现，找到伴侣的概率约为 99%，还怕 找不到对象 吗？&lt;/p&gt;
&lt;p&gt;以上仅能作为参考，毕竟人心比数学复杂的多&lt;/p&gt;

</description>
<pubDate>Fri, 29 Jun 2018 07:03:00 +0000</pubDate>
<dc:creator>NullMoneyException</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shijt/p/9243510.html</dc:identifier>
</item>
<item>
<title>Tomcat安装之疑难杂症 - sewell</title>
<link>http://www.cnblogs.com/neural-net/p/9235717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neural-net/p/9235717.html</guid>
<description>&lt;p&gt;今天想了想，感觉队友似乎不太靠谱，还是要自己做个Web的期末项目保底....想着自己的水平应该不用太久就能搞定，结果就安装一个Tomcat竟然花了我几个小时。。而在中途我试了下用舍友的电脑几分钟就搞定了(ﾒ ﾟ皿ﾟ)ﾒ.....&lt;/p&gt;
&lt;p&gt;(｡ŏ_ŏ)......好吧，其实我是个菜逼....&lt;/p&gt;
&lt;p&gt;------------------------------&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、先从官网下载Tomcat：http://tomcat.apache.org/download-70.cgi&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;第一次下载的先看下这&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627193658611-187089088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从这里的表格可以看到各种版本的Tomcat所支持的JDK或者是JSP版本（记得只有向下兼容的原则）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627193737631-1029914328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在最左侧导航栏选择支持当前系统上安装的JDK版本后选择是使用压缩包形式安装还是exe文件形式的安装，一般建议zip形式直接安装（新手就看框住的三个链接就可以了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627194038381-1301868875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、一般多数新手喜欢的exe安装可能出现的问题&lt;/p&gt;
&lt;p&gt;一路默认配置下一步就可以了，但是到了这一步有可能报错&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627194159524-757538295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;报错原因是默认路径因为指向了不存在的jre路径，我的java目录下只有jre7并没有jre-10.0.1&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627194216120-844109516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以这里需要手动选择自己系统上安装的jdk路径，直接指向jdk目录就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627194252050-949430601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、zip安装建议直接解压在某个根目录文件下，复杂的文件结构会导致出错时增加不必要的麻烦（比如找文件...），其次要注意的是安装目录不要有中文或者是空格等奇奇怪怪的符号（不要给自己挖不必要的坑，后面发现会想哭的...）&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;二、配置环境变量....（最顺利的情况）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;cmd里能正确执行 &quot;java -version&quot;即配置完成，并不需要做额外的配置，直接运行tomcat即可。&lt;/p&gt;

&lt;p&gt;运行tomcat后再浏览器输入localhost:8080测试是否成功配置，出现下图为success...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627200712274-1604747042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;---------------------------------------------&lt;/p&gt;
&lt;p&gt;然后网上据说tomcat7.0后不再需要添加CATALINA环境变量，没测试过，不放心的可以加上（系统变量加），目录为tomcat安装的目录（并不需要动Path变量，假设JDK已经配置好的情况下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627195847222-1661875476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多参考：&lt;span&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/2c8c281daa77aa0008252aff.html&quot; target=&quot;_blank&quot;&gt;https://jingyan.baidu.com/article/2c8c281daa77aa0008252aff.html&lt;/a&gt;&lt;/span&gt;中的第五点&lt;/p&gt;
&lt;p&gt;----------------------------------------------&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;可能启动后dos界面一闪而过&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;（1）JDK配置错误&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用命令行启动Tomcat，从错误日志来判断&lt;/strong&gt;。因为如果手动启动tomcat时报错了程序就会秒关，但用命令行启动就可以较为清晰的找到错误的原因&lt;/p&gt;
&lt;p&gt;网上大部分教程说的都是通过cd进入到bin目录然后再运行startup.bat程序，但我一直都是直接进入到bin目录，然后按住shift键在文件夹内的空白处右击进入cmd，这样子进入cmd后就已经是在当前目录下了（真是省时又省力呢~妈妈再也不用担心我近视了(〃∀〃)）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180627204424555-1800547860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入后直接startup.bat运行即可，如果闪退后看到的信息是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180629122022451-1038819199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代表是JDK的配置问题&lt;/p&gt;

&lt;p&gt;估计有人会问，我cmd能正常执行&quot;java -version&quot;啊！怎么可能是我配错了，男人都是大猪蹄子(#`Д´)ﾉ  /黑脸&lt;/p&gt;
&lt;p&gt;哈哈....首先按照上面所说的保证jdk的版本能被当前所用的tomcat版本对应，&lt;strong&gt;然后！！然后！！！！很重要的一点！！！！&lt;/strong&gt;也是我后来查看日志发现的（&lt;strong&gt;错误：java.lang.UnsatisfiedLinkError: Can't load AMD 64-bit .dll on a IA 32-bit' platform&lt;/strong&gt;），jdk版本和tomcat对应并且能执行&quot;java -version&quot;并不意味着就兼容了，还要注意JDK是几位的，比如32位的jdk和64位的tomcat就是有问题的，但是32位的jdk能运行在64位的电脑上。jdk安装很久的童鞋可能不会注意到这一点（比如我(╯' - ')╯︵ ┻━┻）&lt;/p&gt;

&lt;h3&gt;（2）内存溢出&lt;/h3&gt;
&lt;p&gt; 一开始我以为我的问题也是内存溢出，试过了各种内存溢出的方法但然并卵，所以仅提高几个链接供参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013643039/article/details/51695240&quot; target=&quot;_blank&quot;&gt; https://blog.csdn.net/u013643039/article/details/51695240&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/java-class/p/5325527.html&quot; target=&quot;_blank&quot;&gt; https://www.cnblogs.com/java-class/p/5325527.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yangjing19910801/article/details/50629003/&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/yangjing19910801/article/details/50629003/&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;（3）端口冲突&lt;/h3&gt;
&lt;p&gt;在cmd中通过&quot;netstat -aon|findstr xxx&quot;命令查找端口使用情况&lt;/p&gt;
&lt;p&gt;比如查找端口8080的占用情况（Tomcat安装默认端口）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396954/201806/1396954-20180629120624913-1823158076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后记住最后一列对应的PID号到任务管理器的&lt;strong&gt;&lt;span&gt;详细信息&lt;/span&gt;&lt;/strong&gt;里杀掉对应进程，&lt;strong&gt;在服务可能会找不到&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;/span&gt;：PID号并不等于端口号，只是&lt;span&gt;各进程的身份标识，程序一运行系统就会自动分配给进程一个独一无二的PID，进程中止后PID被系统回收以便再次使用。总之不是端口号就对了ʅ（´◔౪◔）ʃ&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;如果看到了这里还没解决问题，那么恭喜你中奖了....&lt;/p&gt;
&lt;p&gt;1、在cmd运行startup.bat程序后发现tomcat并不是一闪而过，而是弹出一个Tomca窗口运行了一段时间后自动关闭了。又或者如果是使用exe形式下载的话使用Tomcat Monitor启动后发现自动关闭了...&lt;/p&gt;
&lt;p&gt;最直接的方法打开logs文件夹下的catalina日志文件查看详细报错信息（如果你看得懂(´･_･`)）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;但是！但是！！但是！！！ 最简单的方法就是试一下更低的版本！本来我尝试了8和9都解决不了但是换了7问题就顺利解决了（再次提示JDK版本一定要对应得上！！！）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、 已经启动了一个Tomcat&lt;/p&gt;
&lt;p&gt;网上大部分说法是已经启动了javax，杀掉就好，但我就比较奇葩，在后台反反复复看了几遍的确没有找到这个进程。。。。所以重启电脑吧...我就是这么解决的╮(╯_╰)╭&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以上就是目前个人配置Tomcat所遇到过的问题，如有错误，欢迎不吝赐教。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;根据个人电脑配置结构的不同所遇到的问题也会有所不同，遇到未知问题不要害怕。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所以网上的教程仅供参考，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;只有经过自己的思考才会得到属于自己的答案。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 29 Jun 2018 06:31:00 +0000</pubDate>
<dc:creator>sewell</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neural-net/p/9235717.html</dc:identifier>
</item>
<item>
<title>MySQL root密码忘记，原来还有更优雅的解法！ - iVictor</title>
<link>http://www.cnblogs.com/ivictor/p/9243259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivictor/p/9243259.html</guid>
<description>&lt;p&gt;一直以来，对于MySQL root密码的忘记，以为只有一种解法-skip-grant-tables。&lt;/p&gt;
&lt;p&gt;问了下群里的大咖，第一反应也是skip-grant-tables。通过搜索引擎简单搜索了下，无论是百度，抑或Google，只要是用中文搜索，首页都是这种解法。可见这种解法在某种程度上已经占据了使用者的心智。下面具体来看看。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;skip-grant-tables的解法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;首先，关闭实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里，只能通过kill mysqld进程的方式。&lt;/p&gt;
&lt;p&gt;注意：不是mysqld_safe进程，也切忌使用kill -9。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;ps&lt;/span&gt; -ef |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; mysqld
root      &lt;/span&gt;&lt;span&gt;6220&lt;/span&gt;  &lt;span&gt;6171&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /bin/&lt;span&gt;sh&lt;/span&gt; bin/mysqld_safe --defaults-&lt;span&gt;file&lt;/span&gt;=&lt;span&gt;my.cnf
mysql      &lt;/span&gt;&lt;span&gt;6347&lt;/span&gt;  &lt;span&gt;6220&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; /usr/local/mysql57/bin/mysqld --defaults-&lt;span&gt;file&lt;/span&gt;=my.cnf --basedir=/usr/local/mysql57 --datadir=/usr/local/mysql57/data --plugin-&lt;span&gt;dir&lt;/span&gt;=/usr/local/mysql57/lib/plugin --user=mysql --log-error=slowtech.err --pid-&lt;span&gt;file&lt;/span&gt;=slowtech.pid --socket=/usr/local/mysql57/data/mysql.sock --port=&lt;span&gt;3307&lt;/span&gt;&lt;span&gt;
root      &lt;/span&gt;&lt;span&gt;6418&lt;/span&gt;  &lt;span&gt;6171&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;grep&lt;/span&gt; --color=&lt;span&gt;auto mysqld

# &lt;/span&gt;&lt;span&gt;kill&lt;/span&gt; &lt;span&gt;6347&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用--skip-grant-tables参数，重启实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# bin&lt;span&gt;/&lt;/span&gt;mysqld_safe &lt;span&gt;--&lt;/span&gt;&lt;span&gt;defaults-file=my.cnf --skip-grant-tables  --skip-networking &amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置了该参数，则实例在启动过程中会跳过权限表的加载，这就意味着任何用户都能登录进来，并进行任何操作，相当不安全。&lt;/p&gt;
&lt;p&gt;建议同时添加--skip-networking参数。其会让实例关闭监听端口，自然也就无法建立TCP连接，而只能通过本地socket进行连接。&lt;/p&gt;
&lt;p&gt;MySQL8.0就是这么做的，在设置了--skip-grant-tables参数的同时会自动开启--skip-networking。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;修改密码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# mysql &lt;span&gt;-&lt;/span&gt;S &lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;mysql57&lt;span&gt;/&lt;/span&gt;data&lt;span&gt;/&lt;/span&gt;&lt;span&gt;mysql.sock

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; mysql.&lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; authentication_string&lt;span&gt;=&lt;/span&gt;password(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
Rows matched: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  Changed: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; flush &lt;span&gt;privileges&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;这里的update语句针对的是MySQL 5.7的操作，如果是在5.6版本，修改的应该是password字段，而不是authentication_string。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; mysql.&lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; password&lt;span&gt;=&lt;/span&gt;password(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;62&quot;&gt;
&lt;p&gt;而在MySQL 8.0.11版本中，这种方式基本不可行，因为其已移除了PASSWORD()函数及不再支持SET PASSWORD ... = PASSWORD ('auth_string')语法。&lt;/p&gt;
&lt;p&gt;不难发现，这种方式的可移植性实在太差，三个不同的版本，就先后经历了列名的改变，及命令的不可用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下面，介绍另外一种更通用的做法，还是在skip-grant-tables的基础上。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;与上面不同的是，其会先通过flush privileges操作触发权限表的加载，再使用alter user语句修改root用户的密码，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# bin&lt;span&gt;/&lt;/span&gt;mysql &lt;span&gt;-&lt;/span&gt;S &lt;span&gt;/&lt;/span&gt;usr&lt;span&gt;/&lt;/span&gt;local&lt;span&gt;/&lt;/span&gt;mysql57&lt;span&gt;/&lt;/span&gt;data&lt;span&gt;/&lt;/span&gt;&lt;span&gt;mysql.sock

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified &lt;span&gt;by&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
ERROR &lt;/span&gt;&lt;span&gt;1290&lt;/span&gt; (HY000): The MySQL server &lt;span&gt;is&lt;/span&gt; running &lt;span&gt;with&lt;/span&gt; the &lt;span&gt;--&lt;/span&gt;&lt;span&gt;skip-grant-tables option so it cannot execute this statement&lt;/span&gt;
&lt;span&gt;
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; flush &lt;span&gt;privileges&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified &lt;span&gt;by&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;免密码登录进来后，直接执行alter user操作是不行的，因为此时的权限表还没加载。可先通过flush privileges操作触发权限表的加载，再执行alter user操作。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;需要注意的是，通过alter user修改密码只适用于MySQL5.7和8.0，如果是MySQL 5.6，此处可写成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; mysql.&lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; password&lt;span&gt;=&lt;/span&gt;password(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; host&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后重启实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;;

# bin&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;mysqld_safe &lt;span&gt;--&lt;/span&gt;&lt;span&gt;defaults-file=my.cnf &amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，如果在启动的过程中没有指定--skip-networking参数，无需重启实例。但在网上看到的绝大多数方案，都是没有指定该参数，但重启了实例，实在没有必要。&lt;/p&gt;
&lt;p&gt;下面对这个方案做个总结：&lt;/p&gt;
&lt;p&gt;1. 如果只添加了--skip-grant-tables，修改完密码后，其实无需重启，执行flush privileges即可。&lt;/p&gt;
&lt;p&gt;2. 从安全角度出发，建议加上--skip-networking。但因其是静态参数，将其剔除掉需要重启实例。&lt;/p&gt;
&lt;p&gt;3. 加上--skip-networking，虽然可以屏蔽掉TCP连接，但对于本地其它用户，只要有socket文件的可读权限，都能无密码登录。还是存在安全隐患。&lt;/p&gt;
&lt;p&gt;4. 不建议通过update的方式修改密码，更通用的其实是alter user。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更优雅的解法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相对于skip-grant-tables方案，我们来看看另外一种更优雅的解法，其只会重启一次，且基本上不存在安全隐患。&lt;/p&gt;
&lt;p&gt;首先，依旧是关闭实例&lt;/p&gt;
&lt;p&gt;其次，创建一个sql文件&lt;/p&gt;
&lt;p&gt;写上密码修改语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# vim init.sql 
&lt;/span&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified &lt;span&gt;by&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后，使用--init-file参数，启动实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# bin&lt;span&gt;/&lt;/span&gt;mysqld_safe &lt;span&gt;--&lt;/span&gt;&lt;span&gt;defaults-file=my.cnf --init-file=/usr/local/mysql57/init.sql &amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实例启动成功后，密码即修改完毕~&lt;/p&gt;

&lt;p&gt;如果mysql实例是通过服务脚本来管理的，除了创建sql文件，整个操作可简化为一步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# service mysqld restart &lt;span&gt;--&lt;/span&gt;&lt;span&gt;init-file=/usr/local/mysql57/init.sql &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：该操作只适用于/etc/init.d/mysqld这种服务管理方式，不适用于RHEL 7新推出的systemd。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Fri, 29 Jun 2018 06:29:00 +0000</pubDate>
<dc:creator>iVictor</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ivictor/p/9243259.html</dc:identifier>
</item>
<item>
<title>初探Parcel - james·von</title>
<link>http://www.cnblogs.com/rock-roll/p/9240766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rock-roll/p/9240766.html</guid>
<description>&lt;p&gt;昨天趁有点时间看了前不久很火的构建工具Parcel，这里说下初步使用的感受，尤其是将其放到实际项目中和Webpack进行比较。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先说下笔者目前的技术栈。最近的前端项目主要以管理后台为主，技术栈都是React.js + Redux + React-Router + Antd + Create-react-app这套，版本均为较新的版本。Webpack构建工具体系由Create-react-app脚手架初始化，因默认打包功能不太丰富，笔者eject出打包相关的配置文件，在原基础上添加了额外功能：&lt;/p&gt;
&lt;p&gt;1. 代码分割与模块异步懒加载&lt;/p&gt;
&lt;p&gt;2. 模块按需加载&lt;/p&gt;
&lt;p&gt;3. less以及postcss的支持&lt;/p&gt;
&lt;p&gt;4. 字体文件的打包&lt;/p&gt;
&lt;p&gt;5. JS模块热替换(原始只支持样式的热替换)&lt;/p&gt;
&lt;p&gt;6. dev-server(Express)正向代理、代理的destination参数接收、HTTPS的启用以支持h/2协议&lt;/p&gt;
&lt;p&gt;前5项考虑到资源大小、首屏性能、样式的兼容以及书写的方便、整体开发的便捷性，是无论在dev或是production环境都会有的。&lt;/p&gt;
&lt;p&gt;第6项正向代理是因为笔者这个项目的底层是分布式文件存储系统 + 基于Cluster模块的Node.js集群 + MongDB分片式集群 + HA集群，dev环境是跑在Vagrant Centos7.x虚拟机集群里的，production环境是直接跑在Centos7里的，对操作系统以及机器硬件依赖大。数据流从文件存储系统底层传递到Node.js层再传递到Web前端，且Web前端和Node.js后端只有基于HTTP、Websocket的交互，在开发时出于工程化的考虑，直接和底层环境隔离，进而方便调试，只需要Webpack的dev-server代理到Node.js上层Nginx即可，无需到Vagrant起的虚拟机中部署修改后的前端代码，也不需要Fiddler或者Charles代理服务端的文件到本地文件，只需要在'npm start'后跟上协议 + 跑有Node.js服务的IP + Node.js进程监听的端口号即可，会将此参数传给dev-server的正向代理配置。&lt;/p&gt;
&lt;p&gt;由此可见，如果说你的项目很简单，CLI提供的初始功能即可满足需求，正是如此Facebook在Create-react-app中，直接把最基本的构建有关的文件都放到了node_modules中，只暴露出了命令，使用者根本不需要去维护构建有关的文件。如果说业务需求较复杂会对工程化要求高，如果CLI工具初始化的Webpack打包体系的初始功能不满足业务需求，也是需要额外加入很多东西的，并且需要我们手动去配置。&lt;/p&gt;
&lt;p&gt;Webpack的功能确实强大，相对于Browserify来说，Webpack真的是大而全。但类似于字典的API文档和各种loader与plugin运用，无形中提高了整个工具链的技术门槛，对于大多数没有深入研究的开发者来说，只能是知道Webpack的基本用法和要点的概念，再用到具体的loader和plugin的时候再去查看文档，然后过一定时间不使用基本又会忘掉。而要准确的说出某个loader或者plugin的功能和配置方法是有一定难度的。而且Webpack的每个大版本之间也存在一定的功能和API上的变化，当你熟悉了这个版本后，下一个版本就来了...... 有没有一种&quot;铁杵磨成针&quot;的感觉呢？&lt;/p&gt;
&lt;p&gt;目前前端的开发模式、技术栈与工具链基本都相同，为什么不能在构建工具内部就给出能适配大多数业务需求的默认的配置而省去烦人的手动配置呢？所以Parcel号称的&lt;strong&gt;零配置&lt;/strong&gt;的吸引力是很大的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Parcel初探&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;笔者新起了一个demo项目，但功能复杂度模拟真实项目：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629104649244-339841241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照Parcel官方要求做了最基础的package.json和.babelrc配置，其他都应用零配置默认的项，不做额外配置。Parcel版本为1.9.3.&lt;/p&gt;
&lt;p&gt;index.html为Parcel打包的入口，依赖src/index.js文件。&lt;/p&gt;
&lt;p&gt;src文件夹为源资源目录：&lt;/p&gt;
&lt;p&gt;src --&lt;br/&gt;       |--  components      存放高度抽象的公用组件&lt;/p&gt;
&lt;p&gt;　　 |--  redux      存放redux初始化、action、reducer&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       |--  styleSheets      存放公共和各组件的样式less&lt;/p&gt;
&lt;p&gt;       |--  views      存放业务视图组件&lt;/p&gt;
&lt;p&gt;       |--  index.js      JS入口文件&lt;/p&gt;
&lt;p&gt;路由、代码分割、Antd UI组件按需加载、Redux相关、样式等功能都支持。这是使用Parcel打包过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629120942588-1958061878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打包后的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629120426004-468391781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是打包过程中对计算机硬件资源的利用：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629120505360-1721348949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、使用Webpack打包同一个项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629142246658-578895148.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;笔者再起了一个项目，技术栈和上个段落中的项目相同，但使用前言中提到的Webpack工具链打包该项目。懒得修改index.html的目录，于是新建了public文件夹把index.html放进去，并删除了&amp;lt;script&amp;gt;引入，由'html-webpack-plugin'插件注入JS脚本路径。&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629140531036-1278508041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是打包过程中对计算机硬件资源的利用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986162/201806/986162-20180629121023473-1763063721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 速度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先当前版本Parcel在速度上绝对比Webpack未使用HappyPack时要快上很多，从计算机CPU使用率可以看出，笔者计算机CPU是i7 4770HQ 4c/8t，在执行Parcel构建时，8个线程均被使用上了，虽然超线程技术产生的额外线程的是引用率并比不上物理核心，但已经很不错了。第二次使用Parcel打包后，可以看到速度较上次还有明显提升，这是因为第一次打包生成了.cache目录的原因，可以记录上一次打包的状态。反观Webpack仅仅只能使用4个物理核心的线程，对核心线程的利用率也并不高，对超线程技术支持不友好，而且耗时很长，拖拖拉拉，当然使用上了HappyPack后会有一定改善。这就是Parcel打包速度快的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 质量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在零配置下Parcel似乎没有类似于TreeShaking的技术，或者是说压缩的质量并不高，而导致打包出来的资源大小要大很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 使用场景的支持性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在纯的web前端项目中，Parcel似乎没有什么问题和报错，而当我们打包Node.js项目时，会产生因为有些require写法不支持而报错等问题，当然打包后端醒目可能不是Parcel的目的。而Webpack在这方面做得较好，支持构建的应用较为丰富得多，基本上使用JS的各种项目都支持。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Parcel的零配置打包着实让人眼前一亮，但是限制还是很多的，并且为了零配置而抛弃掉了很多灵活配置，导致对打包过程和资源输出有自定义需求的时候还必须自己去修改或者使用额外的插件。那么这样一来岂不是又回到了Webpack等的老路上去了。总之如果没有太复杂和自定义的业务需求Parcel能够让整个过程很清爽，反之请使用Webpack，如果觉得Webpack构建太慢，可以使用HappPack增加多进程处理以达到模拟多线程的目的，充分利用计算机超线程技术的功能(如果有的话)。当然这也不是必须的，因为又会有谁在不停地打包开发环境的代码呢？而且一般大型项目，一般也会直接使用CLI脚手架工具搭建环境，像React.js官方的Create-react-app一样，构建相关的文件都没有暴露出来的，提供可以直接使用的'npm start'、'npm run build'等命令。如果你不需要自定义修改，从某种程度来说它就是零配置的！&lt;/p&gt;
&lt;p&gt;Parcel还需打磨！&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 06:26:00 +0000</pubDate>
<dc:creator>james&amp;#183;von</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rock-roll/p/9240766.html</dc:identifier>
</item>
<item>
<title>MVC路由深入详解2---MapRoute - 小王子的博客</title>
<link>http://www.cnblogs.com/xiaowangzi1987/p/9225206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaowangzi1987/p/9225206.html</guid>
<description>&lt;h3&gt;引言&lt;/h3&gt;
&lt;p&gt;               前面我们讲了IgnoreRoute&lt;a href=&quot;https://www.cnblogs.com/xiaowangzi1987/p/9224175.html&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;               现在我们讲讲核心的MapRoute，还是提前准备Reflection工具，若是没准备，可以看“”MVC路由深入详解1---IgnoreRoute”中的System.Web.dll源码&lt;/p&gt;
&lt;h3&gt;一.RouteCollection&lt;/h3&gt;
&lt;p&gt;               我们来看看RouteCollection.MapRoute，截图如下：&lt;/p&gt;
&lt;p&gt;                        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1096235/201806/1096235-20180625151430442-2086153913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;               相信大家看到了RouteCollectionExtensions是一个静态类，是对RouteCollection的扩展（关于扩展方法的大家可以百度，此处不做详细描述）。好家伙，我们看看这个扩展方法走向何方（这个时候就是Reflection发挥作用的时候了）。&lt;/p&gt;
&lt;p&gt;               引用“”MVC路由深入详解1---IgnoreRoute”中的内容，看看MapRoute的参数传入的是什么：&lt;/p&gt;
&lt;p&gt;                              name:       &quot;Default&quot;&lt;/p&gt;
&lt;p&gt;                              url:           &quot;{controller}/{action}/{id}&quot;&lt;/p&gt;
&lt;p&gt;                              defaults:   new { controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional }  ---&amp;gt;这是个匿名类型&lt;/p&gt;

&lt;p&gt;               我们看看扩展方法去了哪里：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                              public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;a title=&quot;System.Web.Routing.Route CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web:4.0.0.0:b03f5f7f11d50a3a/System.Web.Routing.Route&quot;&gt;Route&lt;/a&gt; &lt;strong&gt;&lt;a class=&quot;bold&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web.Mvc:5.2.3.0:31bf3856ad364e35/System.Web.Mvc.RouteCollectionExtensions/MapRoute(System.Web.Routing.RouteCollection,String,String,Object):System.Web.Routing.Route&quot;&gt;MapRoute&lt;/a&gt;&lt;/strong&gt;(&lt;span&gt;this&lt;/span&gt; &lt;a title=&quot;System.Web.Routing.RouteCollection CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web:4.0.0.0:b03f5f7f11d50a3a/System.Web.Routing.RouteCollection&quot;&gt;RouteCollection&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;routes, &lt;a title=&quot;System.String CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.String&quot;&gt;string&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;name, &lt;a title=&quot;System.String CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.String&quot;&gt;string&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;url, &lt;a title=&quot;System.Object CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Object&quot;&gt;object&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;defaults) =&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;routes.&lt;a title=&quot;Route System.Web.Mvc.RouteCollectionExtensions.MapRoute(RouteCollection routes, string name, string url, object defaults, object constraints); CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web.Mvc:5.2.3.0:31bf3856ad364e35/System.Web.Mvc.RouteCollectionExtensions/MapRoute(System.Web.Routing.RouteCollection,String,String,Object,Object):System.Web.Routing.Route&quot;&gt;MapRoute&lt;/a&gt;(&lt;span class=&quot;VariableReference&quot;&gt;name, &lt;span class=&quot;VariableReference&quot;&gt;url, &lt;span class=&quot;VariableReference&quot;&gt;defaults, &lt;span&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;               我们接着往下走&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;     &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;em&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                              public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;a title=&quot;System.Web.Routing.Route CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web:4.0.0.0:b03f5f7f11d50a3a/System.Web.Routing.Route&quot;&gt;Route&lt;/a&gt; &lt;a class=&quot;bold&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web.Mvc:5.2.3.0:31bf3856ad364e35/System.Web.Mvc.RouteCollectionExtensions/MapRoute(System.Web.Routing.RouteCollection,String,String,Object,Object):System.Web.Routing.Route&quot;&gt;MapRoute&lt;/a&gt;(&lt;span&gt;this&lt;/span&gt; &lt;a title=&quot;System.Web.Routing.RouteCollection CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web:4.0.0.0:b03f5f7f11d50a3a/System.Web.Routing.RouteCollection&quot;&gt;RouteCollection&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;routes, &lt;a title=&quot;System.String CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.String&quot;&gt;string&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;name, &lt;a title=&quot;System.String CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.String&quot;&gt;string&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;url, &lt;a title=&quot;System.Object CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Object&quot;&gt;object&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;defaults, &lt;a title=&quot;System.Object CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Object&quot;&gt;object&lt;/a&gt; &lt;span class=&quot;VariableReference&quot;&gt;constraints) =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;routes.&lt;a title=&quot;Route System.Web.Mvc.RouteCollectionExtensions.MapRoute(RouteCollection routes, string name, string url, object defaults, object constraints, string[] namespaces); CTRL+Click to open in new tab.&quot; href=&quot;http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://System.Web.Mvc:5.2.3.0:31bf3856ad364e35/System.Web.Mvc.RouteCollectionExtensions/MapRoute(System.Web.Routing.RouteCollection,String,String,Object,Object,String%5b%5d):System.Web.Routing.Route&quot;&gt;MapRoute&lt;/a&gt;(&lt;span class=&quot;VariableReference&quot;&gt;name, &lt;span class=&quot;VariableReference&quot;&gt;url, &lt;span class=&quot;VariableReference&quot;&gt;defaults, &lt;span class=&quot;VariableReference&quot;&gt;constraints, &lt;span&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;&lt;span class=&quot;VariableReference&quot;&gt;               接着&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; Route MapRoute(&lt;span&gt;string&lt;/span&gt; name,&lt;span&gt;string&lt;/span&gt; url,&lt;span&gt;object&lt;/span&gt; defaults,&lt;span&gt;object&lt;/span&gt; constraints=&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;[] param=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(url==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Route route &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Route(url, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcRouteHandler())
            {
                Defaults&lt;/span&gt;=&lt;span&gt;CreateRouteValueDictionaryUncached(defaults),
                Constraints&lt;/span&gt;=&lt;span&gt;CreateRouteValueDictionaryUncached(constraints),
                DataTokens&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Web.Routing.RouteValueDictionary()
            };
            ConstraintValidation.Validate(route);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((param != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; (param.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
            {
                route.DataTokens[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Namespaces&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; param;
            }
            Add(name, route);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; route;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                上面新建了一个Route,Route就是一条具体的路由 ，new Route(url, new MvcRouteHandler())传入规则url和new MvcRouteHandler()。&lt;/p&gt;
&lt;h3&gt;二.CreateRouteValueDictionaryUncached      &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        private static System.Web.Routing.RouteValueDictionary CreateRouteValueDictionaryUncached(object values)
        {
            IDictionary&amp;lt;string, object&amp;gt; dictionary = values as IDictionary&amp;lt;string, object&amp;gt;;
            if (dictionary != null)
            {
                return new System.Web.Routing.RouteValueDictionary(dictionary);
            }
            return System.Web.WebPages.TypeHelper.ObjectToDictionaryUncached(values);
        }          
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三.MvcRouteHandler&lt;/h3&gt;
&lt;p&gt;               我们继续拆解MvcRouteHandler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; MvcRouteHandler: System.Web.Routing.IRouteHandler
    {
        System.Web.Mvc.IControllerFactory _controllerFactory;
        public&lt;span&gt; MvcRouteHandler() { }
        public&lt;span&gt; MvcRouteHandler(System.Web.Mvc.IControllerFactory controllFactory)
        {
            _controllerFactory =&lt;span&gt; controllFactory;
        }
        protected virtual&lt;span&gt; IHttpHandler GetHttpHandler(System.Web.Routing.RequestContext requestContext)
        {
            //SetSessionStateBehavior:在派生类重写时，设置支持HTTP请求所必须的会话状态行为的类型
&lt;span&gt;            requestContext.HttpContext.SetSessionStateBehavior(GetSessionStateBehavior(requestContext));
            return new&lt;span&gt; MvcHandler(requestContext);
        }
        IHttpHandler System.Web.Routing.IRouteHandler.GetHttpHandler(System.Web.Routing.RequestContext requestContext)
        {
            return&lt;span&gt; GetHttpHandler(requestContext);
        }

        protected virtual&lt;span&gt; System.Web.SessionState.SessionStateBehavior GetSessionStateBehavior(System.Web.Routing.RequestContext requestContext)
        {
            string str = (string)requestContext.RouteData.Values[&quot;controller&quot;&lt;span&gt;];
            if (string&lt;span&gt;.IsNullOrEmpty(str))
            {
                throw new&lt;span&gt; InvalidOperationException(System.Web.Mvc.Properties.MvcResources.MvcRouteHandler_RouteValuesHasNoController);
            }
            IControllerFactory factory = _controllerFactory ??&lt;span&gt; ControllerBuilder.Current.GetControllerFactory();
            return&lt;span&gt; factory.GetControllerSessionBehavior(requestContext, str);
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四.RouteValueDictionary&lt;/h3&gt;
&lt;p&gt;             RouteValueDictionary是对Dictionary&amp;lt;string,object&amp;gt;进行包装，下面是RouteValueDictionary拆解   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; RouteValueDictionary(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; values)
{
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._dictionary = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.AddValues(values);
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddValues(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; values)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (values != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (PropertyDescriptor descriptor &lt;span&gt;in&lt;/span&gt;&lt;span&gt; TypeDescriptor.GetProperties(values))
        {
            &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; obj2 =&lt;span&gt; descriptor.GetValue(values);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Add(descriptor.Name, obj2);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;             我们来看看效果&lt;/p&gt;
&lt;p&gt;                &lt;img src=&quot;https://images2018.cnblogs.com/blog/1096235/201806/1096235-20180629113352144-1089703816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;五.Add(name,route)&lt;/h3&gt;
&lt;p&gt;             我们来看看这个Add方法：   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, RouteBase item)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(name) &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._namedMap.ContainsKey(name))
            {
                &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;[] args = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] { name };
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;throw new ArgumentException(string.Format(CultureInfo.CurrentUICulture, System.Web.SR.GetString(&quot;RouteCollection_DuplicateName&quot;), args), &quot;name&quot;);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Add(item);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(name))
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._namedMap[name] =&lt;span&gt; item;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;             里面做了重复路由名称验证，Add方法的第二个参数是RouteBase,我们看看MapRoute方法里传入给Add方法的参数是Route。Route是继承于RouteBase，RouteBase是一个抽象类，这个类是为继承类服务的，里面定义了GetRouteData和GetVirtualPath两个抽象方法。&lt;/p&gt;
&lt;p&gt;             GetRouteData：解析请求url，提取数据，如：/home/index 得到：controller/home,action/index提取得到的数据会包装成RouteData&lt;/p&gt;
&lt;p&gt;             GetVirtualPath:生成URL&lt;/p&gt;
&lt;h3&gt;六.RouteBase Route    &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteBase
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Methods&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; RouteBase();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; RouteData GetRouteData(HttpContextBase httpContext);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Route : RouteBase
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fields&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ParsedRoute _parsedRoute;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _url;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; HttpMethodParameterName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Methods&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Route(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url, IRouteHandler routeHandler);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Route(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url, RouteValueDictionary defaults, IRouteHandler routeHandler);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Route(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url, RouteValueDictionary defaults, RouteValueDictionary constraints, IRouteHandler routeHandler);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Route(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url, RouteValueDictionary defaults, RouteValueDictionary constraints, RouteValueDictionary dataTokens, IRouteHandler routeHandler);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; RouteData GetRouteData(HttpContextBase httpContext);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ProcessConstraint(HttpContextBase httpContext, &lt;span&gt;object&lt;/span&gt; constraint, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; parameterName, RouteValueDictionary values, RouteDirection routeDirection);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ProcessConstraints(HttpContextBase httpContext, RouteValueDictionary values, RouteDirection routeDirection);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Properties&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; RouteValueDictionary Constraints { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RouteValueDictionary DataTokens { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RouteValueDictionary Defaults { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IRouteHandler RouteHandler { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;              Route添加了几个属性&lt;/p&gt;
&lt;p&gt;                          Constraints:保存约束规则，最终保存为RouteValueDictionary&lt;/p&gt;
&lt;p&gt;                          DataTokens:附加参数，指定controller的空间命名也放在这里。&lt;/p&gt;
&lt;p&gt;                          Defaults:保存规则的默认值&lt;/p&gt;
&lt;p&gt;                          url:规则URL&lt;/p&gt;
&lt;p&gt;             我们来看看GetRouteData，我们看看RouteData routeData=RouteCollection.GetRouteData(context)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RouteData GetRouteData(HttpContextBase httpContext)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (httpContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (httpContext.Request == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(RoutingResources.RouteTable_ContextMissingRequest, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.RouteExistingFiles)
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; appRelativeCurrentExecutionFilePath =&lt;span&gt; httpContext.Request.AppRelativeCurrentExecutionFilePath;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((appRelativeCurrentExecutionFilePath != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; (&lt;span&gt;this&lt;/span&gt;._vpp != &lt;span&gt;null&lt;/span&gt;)) &amp;amp;&amp;amp; (&lt;span&gt;this&lt;/span&gt;._vpp.FileExists(appRelativeCurrentExecutionFilePath) || &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._vpp.DirectoryExists(appRelativeCurrentExecutionFilePath)))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetReadLock())
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (RouteBase base2 &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
        {
            RouteData routeData &lt;/span&gt;=&lt;span&gt; base2.GetRouteData(httpContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (routeData != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; routeData;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;             上述代码中最后通过递归遍历自己所有的路由规则，分别调用我们所有注册在RouteTable.Routes---&amp;gt;RouteCollection。&lt;/p&gt;

&lt;p&gt;             我们还注意到上面有这么一段： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;if (!this.RouteExistingFiles)&lt;br/&gt;    {&lt;br/&gt;        string appRelativeCurrentExecutionFilePath = httpContext.Request.AppRelativeCurrentExecutionFilePath;&lt;br/&gt;        if (((appRelativeCurrentExecutionFilePath != &quot;~/&quot;) &amp;amp;&amp;amp; (this._vpp != null)) &amp;amp;&amp;amp; (this._vpp.FileExists(appRelativeCurrentExecutionFilePath) || this._vpp.DirectoryExists(appRelativeCurrentExecutionFilePath)))&lt;br/&gt;        {&lt;br/&gt;            return null;&lt;br/&gt;        }&lt;br/&gt;    }&lt;/p&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;             RouteCollection 有这么一个属性RouteExistingFiles.当为false时，就检测请求的路径地址是否己经存在文件或目录，如果存在，则直接不走路由了，直接返回null，默认就是false，我们可以实验一下。当然这里是忽略了根目录的，不然默认我们 http://www.xxx.com/ 也不能访问了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;19&quot;&gt;public static void RegisterRoutes(RouteCollection routes)&lt;br/&gt;        {&lt;br/&gt;            routes.IgnoreRoute(&quot;{resource}.axd/{*pathInfo}&quot;);&lt;p&gt;            routes.MapRoute(&lt;br/&gt;                &quot;Default&quot;, // Route name&lt;br/&gt;                &quot;{controller}/{action}/{id}&quot;, // URL with parameters&lt;br/&gt;                new { controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional }, // Parameter defaults&lt;br/&gt;                new string[] { &quot;MVCTest.Controllers&quot; }&lt;br/&gt;            );&lt;br/&gt;        }&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;http://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;             这里是默认的路由注册，按理说我们访问 home 时，会去到 home controller 的 index，但是我们在在项目里加一个 home 目录，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/lindaohui/mvc.jpg&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;249&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;             我们再访问：&lt;a href=&quot;http://localhost:2144/home/&quot;&gt;http://localhost:2144/home/&lt;/a&gt; 我们发现，无法找到该资源，也就是检测到home这个目录存在时，就不走路由了。&lt;/p&gt;

&lt;p&gt;            为尊重原创，本文的编写参考了以下博文和文章：&lt;/p&gt;
&lt;p&gt;                       程序园： http://www.cnblogs.com/lindaohui/archive/2012/08/31/2664047.html&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;

</description>
<pubDate>Fri, 29 Jun 2018 06:17:00 +0000</pubDate>
<dc:creator>小王子的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaowangzi1987/p/9225206.html</dc:identifier>
</item>
<item>
<title>Unity串口通信 - 年轻诠释我们的梦想</title>
<link>http://www.cnblogs.com/damonHead/p/9243130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/damonHead/p/9243130.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、&lt;span class=&quot;Apple-tab-span&quot;&gt;串口简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;Apple-tab-span&quot;&gt;串行接口（串口）通常指COM接口，是采用串行通信方式的扩展接口。串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。特别适用于远距离通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1&lt;/span&gt;、查看串口：右键 我的电脑-管理-设备管理器-端口，选择一个端口，双击查看属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177650/201806/1177650-20180629131518461-142832672.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、 串口属性:从上图中可以看到串口属性，串口通信最重要的属性参数是波特率、数据位、停止位和奇偶校验。对于两个进行通信的端口，这些参数必须匹配。&lt;/p&gt;
&lt;p&gt;（1）波特率：这是一个衡量符号传输速率的参数。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送960个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为960Bd，比特率为10位*960个/秒=9600bps。&lt;/p&gt;
&lt;p&gt;（2）数据位：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据往往不会是8位的，标准的值是6、7和8位。标准的ASCII码是0～127（7位），扩展的ASCII码是0～255（8位）。&lt;/p&gt;
&lt;p&gt;（3）停止位：用于表示单个包的最后几位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。&lt;/p&gt;
&lt;p&gt;（4）校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。&lt;/p&gt;
&lt;p&gt;3、串口通信原理：&lt;/p&gt;
&lt;p&gt;串行接口在嵌入式系统中是一种重要的数据通信接口，其本质功能是作为CPU和串行设备间的编码转换器。在发送数据时，数据从CPU经串行端口，字节数据转换为串行的位；在接收数据时，串行的位转换为字节数据。&lt;/p&gt;
&lt;p&gt;4、常用的协议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RS-232:&lt;/strong&gt; 标准串口，最常用的一种串行通讯接口采取不平衡传输方式，即所谓单端通讯, 是为点对点通讯而设计的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RS-422:&lt;/strong&gt; 支持点对多的双向通信。采用单独的发送和接收通道，因此不必控制数据方向，各装置之间任何必须的信号交换均可以按软件方式（XON/XOFF握手）或硬件方式（一对单独的双绞线）实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RS-485:&lt;/strong&gt; 从RS-422基础上发展而来的， RS-485可以采用二线与四线方式，二线制可实现真正的多点双向通信，而采用四线连接时，与RS-422一样只能实现点对多的通信，但它比RS-422有改进，无论四线还是二线连接方式总线上可多接到32个设备。&lt;/p&gt;
&lt;p&gt;串口的接口标准规范9针串口：&lt;/p&gt;
&lt;p&gt;\ 1 2 3 4 5 /&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;\ 6 7 8 9 /&lt;/p&gt;
&lt;p&gt;针脚功能：&lt;/p&gt;
&lt;p&gt;1、载波检测(CD)      &lt;/p&gt;
&lt;p&gt;2、接受数据(RXD)&lt;/p&gt;
&lt;p&gt;3、发出数据(TXD)&lt;/p&gt;
&lt;p&gt;4、数据终端准备好(DTR)&lt;/p&gt;
&lt;p&gt;5、信号地线(SG)&lt;/p&gt;
&lt;p&gt;6、数据准备好(DSR)&lt;/p&gt;
&lt;p&gt;7、请求发送(RTS)&lt;/p&gt;
&lt;p&gt;8、清除发送(CTS)&lt;/p&gt;
&lt;p&gt;9、振铃指示(RI)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、使用C#和Unity进行串口编程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在对串口进行编程时候，我们要向串口发送指令，然后我们解析串口返回的指令。从.NET Framework 2.0开始，C#提供了SerialPort类用于实现串口控制。&lt;strong&gt;命名空间&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;System.IO.Ports。详细信息可以参看（&lt;a title=&quot;MSDN技术文档&quot; href=&quot;https://docs.microsoft.com/en-us/previous-versions/&quot; target=&quot;_blank&quot;&gt;MSDN技术文档&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;1、 常用的字段：&lt;/p&gt;
&lt;p&gt;PortName：获取或设置通信端口&lt;/p&gt;
&lt;p&gt;BaudRate：获取或设置串行波特率&lt;/p&gt;
&lt;p&gt;DataBits：获取或设置每个字节的标准数据位长度&lt;/p&gt;
&lt;p&gt;Parity：获取或设置奇偶效验检查协议&lt;/p&gt;
&lt;p&gt;StopBits：获取或设置每个字节的标准停止位数&lt;/p&gt;
&lt;p&gt;2、 常用方法：&lt;/p&gt;
&lt;p&gt;Close：关闭端口连接，将IsOpen属性设置false,并释放内部Stream对象&lt;/p&gt;
&lt;p&gt;GetPortNames：获取当前计算机的串行端口名称数组&lt;/p&gt;
&lt;p&gt;Open：打开一个新的串行端口连接&lt;/p&gt;
&lt;p&gt;Read：从SerialPort输入缓冲区中读取&lt;/p&gt;
&lt;p&gt;Write：将数据写入串行端口输出缓冲区&lt;/p&gt;
&lt;p&gt;3、常用事件：&lt;/p&gt;
&lt;p&gt;DataReceived：表示将处理SerialPort对象的数据接收事件的方法&lt;/p&gt;
&lt;p&gt;DisPosed：通过调用释放组件时发生Dispose方法（继承自Component）&lt;/p&gt;
&lt;p&gt;4、SerialPort 控件使用流程&lt;/p&gt;
&lt;p&gt;流程是设置通信端口号及波特率、数据位、停止位和校验位，再打开端口连接、发送数据、接收数据，最后关闭端口连接步骤。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 三、编程遇到的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、没有将Unity3D的API平台切换成.NET2.0，这时Unity编写SerialPort类会报错。&lt;/p&gt;
&lt;p&gt;解决方法：将Unity3D的API平台切换成.NET2.0，切换方法： “Edit–&amp;gt;project Setting–&amp;gt;Player–&amp;gt;Other Setting –&amp;gt;Api Compatibility level”。在这里将“.NET2.0 Subset”切换为“.NET2.0”&lt;/p&gt;
&lt;p&gt;2、Unity的目标平台没有切换为Windows平台，会提示该命名空间不支持SystemIO,提示你切换工具。&lt;/p&gt;
&lt;p&gt;解决方法：把目标平台切换为Windows平台，否则是其他平台会报错误。&lt;/p&gt;
&lt;p&gt;3、串口发送的信息不能正常解析&lt;/p&gt;
&lt;p&gt;解决方法：把串口发送的消息使用字节流进行转换。（字符流转换）&lt;/p&gt;
&lt;p&gt;4、串口接收信息的缺失问题&lt;/p&gt;
&lt;p&gt;（1）接收字符串（string）：port.ReadLine()&lt;/p&gt;
&lt;p&gt;数据接收可能错误，数据丢失，数据接收不到&lt;/p&gt;
&lt;p&gt;（2）接收字节数组（byte[]）：port.Read()&lt;/p&gt;
&lt;p&gt;接收数据断层，会分两次接收完整数据&lt;/p&gt;
&lt;p&gt;（3）接收单个字节（byte）：port.ReadByte()&lt;/p&gt;
&lt;p&gt;将接收到的数据进行组合&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;代码可以直接使用，测试有效，直接复制到Unity脚本中和串口调试助手配合使用即可。&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO.Ports;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PortControl : MonoBehaviour
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 定义串口属性
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GUIText gui;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;public GUIText Test;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义基本信息&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; portName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COM3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口名&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; baudRate = &lt;span&gt;9600&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;波特率&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Parity parity = Parity.None;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;效验位&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dataBits = &lt;span&gt;8&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据位&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; StopBits stopBits = StopBits.One;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止位&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     SerialPort sp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    Thread dataReceiveThread;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送的消息&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt; listReceive = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;[] strchar = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[&lt;span&gt;100&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收的字符信息转换为字符数组信息&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        OpenPort();
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         dataReceiveThread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadStart(DataReceiveFunction));
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;        dataReceiveThread.Start();
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update()
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 创建串口，并打开串口
&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OpenPort()
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建串口&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         sp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SerialPort(portName, baudRate, parity, dataBits, stopBits);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         sp.ReadTimeout = &lt;span&gt;400&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            sp.Open();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            Debug.Log(ex.Message);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 程序退出时关闭串口
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnApplicationQuit()
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        ClosePort();
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClosePort()
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            sp.Close();
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            dataReceiveThread.Abort();
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            Debug.Log(ex.Message);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 打印接收的信息
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintData()
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; listReceive.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             strchar[i] = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)(listReceive[i]);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             str = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;(strchar);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        Debug.Log(str);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 接收数据
&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DataReceiveFunction()
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 按单个字节发送处理信息，不能接收中文
&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;while (sp != null &amp;amp;&amp;amp; sp.IsOpen)
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Thread.Sleep(1);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    try
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        byte addr = Convert.ToByte(sp.ReadByte());
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        sp.DiscardInBuffer();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        listReceive.Add(addr);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        PrintData();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    catch
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;listReceive.Clear();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;} &lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 按字节数组发送处理信息，信息缺失
&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; bytes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (sp != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; sp.IsOpen)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                     bytes = sp.Read(buffer, &lt;span&gt;0&lt;/span&gt;, buffer.Length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收字节&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                         &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                         &lt;span&gt;string&lt;/span&gt; strbytes =&lt;span&gt; Encoding.Default.GetString(buffer);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                        Debug.Log(strbytes);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (ex.GetType() != &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ThreadAbortException))
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;             Thread.Sleep(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;     &lt;span&gt;#region&lt;/span&gt; 发送数据
&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WriteData(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; dataStr)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sp.IsOpen)
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;            sp.Write(dataStr);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGUI()
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         message =&lt;span&gt; GUILayout.TextField(message);
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (GUILayout.Button(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send Input&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;            WriteData(message);
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; test = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AA BB 01 12345 01AB 0@ab 发送&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试字符串&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (GUILayout.Button(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;            WriteData(test);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 29 Jun 2018 06:05:00 +0000</pubDate>
<dc:creator>年轻诠释我们的梦想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/damonHead/p/9243130.html</dc:identifier>
</item>
</channel>
</rss>