<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发（11）- 有关线程池的10个问题 - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/9473681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/9473681.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在日常开发中，线程池是使用非常频繁的一种技术，无论是服务端多线程接收用户请求，还是客户端多线程处理数据，都会用到线程池技术，那么全面的了解线程池的使用、背后的实现原理以及合理的优化线程池的大小等都是非常有必要的。这篇文章会通过对一系列的问题的解答来讲解线程池的基本功能以及背后的原理，希望能对大家有所帮助。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;举个例子来说明为什么要使用线程池，有什么好处？&lt;/li&gt;
&lt;li&gt;jdk1.8中提供了哪几种基本的线程池？&lt;/li&gt;
&lt;li&gt;线程池几大组件的关系？&lt;/li&gt;
&lt;li&gt;ExecutorService的生命周期？&lt;/li&gt;
&lt;li&gt;线程池中的线程能设置超时吗？&lt;/li&gt;
&lt;li&gt;怎么取消线程池中的线程？&lt;/li&gt;
&lt;li&gt;如何设置一个合适的线程池大小？&lt;/li&gt;
&lt;li&gt;当使用有界队列时，如何设置一个合适的队列大小？&lt;/li&gt;
&lt;li&gt;当使用有界队列时，如果队列已满，如何选择合适的拒绝策略？&lt;/li&gt;
&lt;li&gt;如何统计线程池中的线程执行时间？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;举个例子来说明为什么要使用线程池有什么好处&quot;&gt;举个例子来说明为什么要使用线程池，有什么好处？&lt;/h2&gt;
&lt;p&gt;先来看这样一个场景，服务端在一个线程内通过监听8888端口来接收多个客户端的消息。为了避免阻塞主线程，每收到一个消息，就开启一个新的线程来处理，这样主线程就可以不停的接收新的消息。不使用线程池时代码的简单实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws IOException {
    ServerSocket serverSocket = new ServerSocket(8888);

    while (true) {
        try {
            Socket socket = serverSocket.accept();

            new Thread(() -&amp;gt; {
                try {
                    InputStream inputStream = socket.getInputStream();
                    //do something
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }).start();

        } catch (IOException e) {
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过每次new一个新的线程的方式，不会阻塞主线程，提高了服务端接收消息的能力。但是存在几个非常明显的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不停初始化线程的内存消耗，任何时候资源都是有限的，无限制的新建线程会占用大量的内存空间。&lt;/li&gt;
&lt;li&gt;在CPU资源有限的情况下，新建更多的线程不仅不能达到并发处理客户端消息的目的，相反由于线程间的切换更加频繁，会导致处理时间更长，效率更加低下。&lt;/li&gt;
&lt;li&gt;线程本身的创建与销毁都需要耗费服务器资源。&lt;/li&gt;
&lt;li&gt;不方便对线程进行集中管理。&lt;br/&gt;而这些问题都是可以通过使用线程池得倒解决的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jdk1.8中提供了哪几种基本的线程池以及它们的使用场景&quot;&gt;jdk1.8中提供了哪几种基本的线程池以及它们的使用场景？&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;newFixedThreadPool,固定线程数的线程池。它的核心线程数(corePoolSize)和最大线程数(maximumPoolSize)是相等的。同时它使用一个无界的阻塞队列LinkedBlockingQueue来存储额外的任务，也就是说当达到nThreads的线程数在运行之后，所有的后续线程都会进入LinkedBlockingQueue中，不会再创建新的线程。&lt;/p&gt;
&lt;p&gt;使用场景：因为线程数固定，一般适用于可预测的并行任务执行环境。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;newCachedThreadPool，可缓存线程的线程池。默认核心线程数(corePoolSize)为0，最大线程数(maximumPoolSize)为Integer.MAX_VALUE，它还有一个过期时间为60秒，当线程闲置超过60秒之后会被回收。内部使用SynchronousQueue作为阻塞队列。&lt;/p&gt;
&lt;p&gt;使用场景：由于SynchronousQueue无容量的特性，导致了newCachedThreadPool不适合做长时间的任务。因为如果单个任务执行时间过长，每当无空闲线程时，会导致开启新线程，而线程数量可以达到Integer.MAX_VALUE，存储队列又不能缓存任务，很容易导致OOM的问题。所以他的使用场景一般在大量短时间任务的执行上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;newSingleThreadExecutor，单线程线程池。默认核心线程数(corePoolSize)和最大线程数(maximumPoolSize)都为1，使用无界阻塞队列LinkedBlockingQueue。&lt;/p&gt;
&lt;p&gt;使用场景：由于只能有一个线程在执行，而且其他任务都会排队，适用于单线程串行执行有序任务的环境。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;newScheduledThreadPool与newSingleThreadScheduledExecutor，执行延时或者周期性任务的线程池，使用了一个内部实现的DelayedWorkQueue阻塞队列。可以看到它的返回结果是ScheduledExecutorService，它扩展了ExecutorService接口，提供了用于延时和周期执行任务的方法。&lt;/p&gt;
&lt;p&gt;使用场景：用于延时启动任务，或需要周期性执行的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }

    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }

    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;newWorkStealingPool，它是jdk1.8提供的一种线程池，用于执行并行任务。默认并行级别为当前可用最大可用cpu数量的线程。&lt;/p&gt;
&lt;p&gt;使用场景：用于大耗时同时可以分段并行的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static ExecutorService newWorkStealingPool() {
        return new ForkJoinPool
            (Runtime.getRuntime().availableProcessors(),
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程池几大组件的关系&quot;&gt;线程池几大组件的关系？&lt;/h2&gt;
&lt;p&gt;线程池简单来说可以分为四大组件：Executor、ExecutorService、Executors以及ThreadPoolExecutor。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Executor接口定义了一个以Runnable为参数的execute方法。这也是对线程池框架的一个抽象，它将线程池能做什么和具体怎么做拆分开来，也可以看做是一个生产者和消费者模式，Executor负责生产任务，具体的线程池负责消费任务，让使用者能够更加灵活的切换线程池具体策略，它也是线程池多样性的基础。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;那么在ThreadPoolExecutor中，是怎么实现execute方法的呢？来看下ThreadPoolExecutor中execute方法的源码，里面的注释实在太详细了，简直时良好注释的典范。这里只做个简单总结：首先当工作线程小于核心线程数时会尝试添加worker到队列中去运行，如果核心线程不够用会将任务加入队列中，如果入队也不成功，会采取拒绝策略。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
        * Proceed in 3 steps:
        *
        * 1. If fewer than corePoolSize threads are running, try to
        * start a new thread with the given command as its first
        * task.  The call to addWorker atomically checks runState and
        * workerCount, and so prevents false alarms that would add
        * threads when it shouldn't, by returning false.
        *
        * 2. If a task can be successfully queued, then we still need
        * to double-check whether we should have added a thread
        * (because existing ones died since last checking) or that
        * the pool shut down since entry into this method. So we
        * recheck state and if necessary roll back the enqueuing if
        * stopped, or start a new thread if there are none.
        *
        * 3. If we cannot queue task, then we try to add a new
        * thread.  If it fails, we know we are shut down or saturated
        * and so reject the task.
        */
    //ctl通过位运算同时标记了线程数量以及线程状态
    int c = ctl.get();
    //workerCountOf方法用来统计当前运行的线程数量
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ExecutorService接口继承自Executor接口，提供了更加完善的线程池控制功能。并将线程池的状态分为运行中，关闭，终止三种。同时提供了带返回值的提交，方便更好的控制提交的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {
    //关闭线程池，关闭状态
    void shutdown();
    //立即关闭线程池，关闭状态
    List&amp;lt;Runnable&amp;gt; shutdownNow();
    
    boolean isShutdown();
    
    boolean isTerminated();
    //提交一个Callable类型的任务，带Future返回值
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
    //提交一个Runnable类型的任务，带Future返回值
    Future&amp;lt;?&amp;gt; submit(Runnable task);
    //一段时间后终止线程池，终止状态
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;还是通过ThreadPoolExecutor来说明，ThreadPoolExecutor中将线程池状态进行了扩展，定义了5种状态，这5种状态通过Integer.SIZE的高3位来表示。代码如下：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;* The runState provides the main lifecycle control, taking on values:
*   能够接受新任务也能处理队列中的任务
*   RUNNING:  Accept new tasks and process queued tasks
*   不能接受新任务，但能处理队列中的任务
*   SHUTDOWN: Don't accept new tasks, but process queued tasks
    不能接受新任务，也不能处理队列中的任务，同时会中断正在执行的任务
*   STOP:     Don't accept new tasks, don't process queued tasks,
*             and interrupt in-progress tasks
    所有的任务都被终止，工作线程为0
*   TIDYING:  All tasks have terminated, workerCount is zero,
*             the thread transitioning to state TIDYING
*             will run the terminated() hook method
    terminated方法执行完成
*   TERMINATED: terminated() has completed
private static final int COUNT_BITS = Integer.SIZE - 3;

private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;//101
private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;//000
private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;//001
private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;//010
private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;//011&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;再来看看通过ExecutorService接口对这5种状态的转换：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {
    //关闭线程池，线程池状态会从RUNNING变为SHUTDOWN
    void shutdown();
    //立即关闭线程池RUNNING或者SHUTDOWN到STOP
    List&amp;lt;Runnable&amp;gt; shutdownNow();
    //STOP、TIDYING以及TERMINATED都返回true
    boolean isShutdown();
    //TERMINATED状态返回true
    boolean isTerminated();
    //一段时间后终止线程池，TERMINATED
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Executors提供了一系列获取线程池的静态方法，相当于线程池工厂，是对ThreadPoolExecutor的一个封装，简化了用户切换Executor和ExecutorService的各种实现细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ThreadPoolExecutor是对Executor以及ExecutorService的实现，提供了具体的线程池实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;executorservice的生命周期&quot;&gt;ExecutorService的生命周期？&lt;/h2&gt;
&lt;p&gt;这个问题在上面已经做了解说，ExecutorService的生命周期通过接口定义可以分为运行中，关闭，终止三种状态。&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor在具体实现上提供了更加详细的五种状态：RUNNING、SHUTDOWN、STOP、TIDYING以及TERMINATED。各种状态的说明以及转换可以看上一个问题的答案。&lt;/p&gt;
&lt;h2 id=&quot;线程池中的线程能设置超时吗&quot;&gt;线程池中的线程能设置超时吗？&lt;/h2&gt;
&lt;p&gt;线程池中的线程是可以进行超时控制的，通过ExecutorService的submit来提交任务，这样会返回一个Future类型的结果，来看看Future接口的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {
    
    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();
    //获取返回结果，并在出现错误或者中断时throws Exception
    V get() throws InterruptedException, ExecutionException;
    //timeout时间内获取返回结果，并在出现错误、中断以及超时时throws Exception
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Future定义了get()以及get(long timeout, TimeUnit unit)方法，get()方法会阻塞当前调用，一直到获取到返回结果，get(long timeout, TimeUnit unit)会在指定时间内阻塞，当超时后会抛出TimeoutException错误。这样就可以达到线程超时控制的目的。简单使用示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Future&amp;lt;String&amp;gt; future = executor.submit(callable);
try {
    future.get(2000, TimeUnit.SECONDS);
} catch (InterruptedException e1) {
    //中断后处理
} catch (ExecutionException e1) {
    //抛出异常处理
} catch (TimeoutException e1) {
    //超时处理
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有一个问题就是因为get方法是阻塞的---通过LockSupport.park实现，那么线程池中线程比较多的情况下要怎么获取每个线程的超时呢？这里除了自定义线程池实现或者自定义线程工厂来实现之外，使用ThreadPoolExecutor本身的功能我也没想到更好的办法。有一个非常笨的解决方案是开启同线程池数量相等的线程进行监听。大家如果有更好的办法可以留言提出。&lt;/p&gt;
&lt;h2 id=&quot;怎么取消线程池中的线程&quot;&gt;怎么取消线程池中的线程？&lt;/h2&gt;
&lt;p&gt;这个问题和上面的问题解决方案一样，同样也是通过ExecutorService的submit来提交任务，获取Future，调用Future中的cancel方法来达到目的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {
    boolean cancel(boolean mayInterruptIfRunning);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cancel方法有一个mayInterruptIfRunning参数，当为true时，代表任务能接受并处理中断，调用了interrupt方法。如果为false，代表如果任务没启动就不要运行它，不会调用interrupt方法。&lt;/p&gt;
&lt;p&gt;取消的本质实际上还是通过interrupt来实现的，这就是说，如果线程本身不能响应中断，就算调用了cancel方法也没用。一般情况下通过lockInterruptibly、park和await方法阻塞的线程都是能响应中断的，运行中的线程就需要开发者自己实现中断了。&lt;/p&gt;
&lt;h2 id=&quot;如何设置一个合适的线程池大小&quot;&gt;如何设置一个合适的线程池大小？&lt;/h2&gt;
&lt;p&gt;如何设置一个合适的线程池大小，这个问题我觉得是没有一个固定公式的。或者可以说，只有一些简单的设置规则，但放到具体业务中，又各有不同，只能根据现场环境测试过后再来分析。&lt;/p&gt;
&lt;p&gt;设置合适的线程池大小分为两部分，一部分是最大线程池大小，一部分是最小线程池大小。在ThreadPoolExecutor中体现在最大线程数(maximumPoolSize)和核心线程数(corePoolSize)。&lt;/p&gt;
&lt;p&gt;最大线程池大小的设置首先跟当前机器cpu核心数密切相关，一般情况来说要想最大化利用cpu，设置为cpu核心数就可以了，比如4核cpu服务器可以设置为4。但实际情况又大有不同，因为往往我们执行的任务都会涉及到IO，比如任务中执行了一个从数据库查询数据的操作，那么这段时间cpu实际上是没有最大化利用的，这样我们就可以适当扩大maximumPoolSize的大小。在有些情况下任务会是cpu密集型的，如果这样设置更多的线程不仅不会提高效率，反而因为线程的创建销毁以及切换开销而大大降低了效率，所以说最大线程池的大小需要根据业务情况具体测试后才能设置一个合适的大小。&lt;/p&gt;
&lt;p&gt;最小线程池大小相比较最大线程池大小设置起来相对容易一些，因为最小线程一般来说是可以根据业务情况来预估进行设置，比如大多数情况下会有2个任务在运行，很小概率会有超过2个任务运行，那么直接设置最小线程池大小为2就可以。但有一点需要知道的是每间隔多长时间会有超过2个任务，如果每2分钟会有一次超过2个任务的情况，那么我们可以将线程过期时间设置的稍微久一点，比如4分钟，这样就算频繁的超过2个任务，也可以利用缓存的线程池。&lt;/p&gt;
&lt;p&gt;总的来说设置最大和最小线程池都是一个没有固定公式的问题，都需要考虑实际业务情况和机器配置，根据实际业务情况多做测试才能做到最优化设置。在一切没有决定之前，可以使用软件架构的KISS原则，设置最大以及最小线程数都为cpu核心数即可，后续在做优化。&lt;/p&gt;
&lt;h2 id=&quot;当使用有界队列时如何设置一个合适的队列大小&quot;&gt;当使用有界队列时，如何设置一个合适的队列大小？&lt;/h2&gt;
&lt;p&gt;要设置合适的队列大小，先要明白队列什么时候会被使用。在ThreadPoolExecutor的实现中，使用队列的情况有点特殊。它会先使用核心线程池大小的线程，之后会将任务加入队列中，再之后队列满了之后才会扩大到最大线程池大小的线程。也就是说队列的使用并不是等待线程不够用了才使用，而是等待核心线程不够用了就使用。我不是太能理解这样设计的意图，按《Java性能权威权威指南》一书中的说法是这样提供了两个节流阀，第一个是队列，第二个是最大线程池。但这样做并不能给使用者最优的体验，既然要使用最大线程池，那为什么不在第一次就使用呢？&lt;/p&gt;
&lt;p&gt;知道了ThreadPoolExecutor使用线程池的时机，那么再来预估合适的队列大小就很方便了。如果单个任务执行时间在100ms，最小线程数是2，使用者能忍受的最大延时在2s，那么我们可以这样简单推算出队列大小：2/2s/100ms=10，这样满队列时最大延时就在2s之内。当然还有其他一些影响因素，比如部分任务超过或者小于100ms，最大线程池的利用等等，可以在这基础上做简单调整。&lt;/p&gt;
&lt;h2 id=&quot;当使用有界队列时如果队列已满如何选择合适的拒绝策略&quot;&gt;当使用有界队列时，如果队列已满，如何选择合适的拒绝策略？&lt;/h2&gt;
&lt;p&gt;ThreadPoolExecutor中提供了四种RejectedExecutionHandler，每种分工都比较明确，选择起来并不困难。它们分别是：AbortPolicy、DiscardPolicy、DiscardOldestPolicy以及CallerRunsPolicy。下面贴出了他们的源码并做了简单说明，使用的时候可以根据需要自行选择。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//AbortPolicy
//默认的拒绝策略，直接抛出RejectedExecutionException异常供调用者做后续处理
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                            &quot; rejected from &quot; +
                                            e.toString());
}

//DiscardPolicy
//不做任何处理，将任务直接抛弃掉
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
}

//DiscardOldestPolicy
//抛弃队列中的下一个任务，然后尝试做提交。这个使用我觉得应该是在知道当前要提交的任务比较重要，必须要被执行的场景
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
        e.getQueue().poll();
        e.execute(r);
    }
}

//CallerRunsPolicy
//直接使用调用者线程执行，相当于同步执行，会阻塞调用者线程，不太友好感觉。
public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
        r.run();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何统计线程池中的线程执行时间&quot;&gt;如何统计线程池中的线程执行时间？&lt;/h2&gt;
&lt;p&gt;要统计线程池中的线程执行时间，就需要了解线程池中的线程是在什么地方，什么时机执行的？知道了线程的执行状态，然后在线程执行前后添加自己的处理就可以了，所以先来找到ThreadPoolExecutor中线程具体执行的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                    (Thread.interrupted() &amp;amp;&amp;amp;
                    runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task); //执行task.run()的前置方法
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);//执行task.run()的后置方法
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到runWorker方法中在task.run()也就是任务执行前后分别执行了beforeExecute以及afterExecute方法，着两个方法在ThreadPoolExecutor的继承类中都是可重写的，提供了极大的灵活性。我们可以在继承ThreadPoolExecutor之后在任务执行前后做任何自己需要做的事情，当然也就包括任务执行的时间统计了。&lt;/p&gt;
&lt;p&gt;顺便说一句，熟悉spring源码的同学看到这里是不是发现和spring中的postprocesser前后置处理器有异曲同工之妙？区别在于一个是通过继承来覆盖，一个是通过接口来实现。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实线程池框架涉及到的问题远不止这些，包括ThreadFactory、ForkJoinPool等等还有很多值得花时间研究的地方。本文也只是阅读jdk源码、《Java并发编程实战》以及《Java性能优化权威指南》之后的一点点总结，如有错误遗漏的地方，希望大家能多多指出。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《Java并发编程实战》&lt;/li&gt;
&lt;li&gt;《Java性能优化权威指南》&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 08 Nov 2018 23:30:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<og:description>引言 在日常开发中，线程池是使用非常频繁的一种技术，无论是服务端多线程接收用户请求，还是客户端多线程处理数据，都会用到线程池技术，那么全面的了解线程池的使用、背后的实现原理以及合理的优化线程池的大小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/9473681.html</dc:identifier>
</item>
<item>
<title>Python函数基础 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9932901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9932901.html</guid>
<description>&lt;h2 id=&quot;函数声明调用返回基础&quot;&gt;函数声明、调用、返回基础&lt;/h2&gt;
&lt;p&gt;Python中使用def关键字来声明函数，声明函数的格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def func_name(args):
    ...body...
    [return ...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有3个需要注意的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;函数名后面必须加冒号&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果函数体和def不在同一行，则必须缩进&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;return指定函数返回值，用来结束函数
&lt;ul&gt;&lt;li&gt;但return语句是可有可无的，如果不给return，则等价于加上了&lt;code&gt;return None&lt;/code&gt;，即函数默认返回None结构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果函数体body语句只有一行，或者可以简写为一行，则可以写在def的同行。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def myfunc(x,y,z): print(x+y+z)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数声明好之后，就可以执行函数，执行函数也称为调用函数，方式为&lt;code&gt;func_name(args)&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myfunc(1,2,3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数中往往会包含一个return或多个return语句，它可以出现在函数中的任意位置处，它用来结束函数的执行，并返回给定的值。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def func(x):
    return x+5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示返回&lt;code&gt;x+5&lt;/code&gt;的值，返回值是一种值类型，所以可以赋值给变量、可以输出、可以操作等等。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(func(3))    # 输出返回值

a=func(4)         # 赋值给变量
print(a)

print(func(5)+3)  # 数值操作&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return语句是可选的，如果函数中不指定return语句，则默认返回None，即类似于&lt;code&gt;return None&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;关于函数参数&quot;&gt;关于函数参数&lt;/h2&gt;
&lt;p&gt;函数的参数其实也是变量，只不过这些变量是独属于函数的本地变量，函数外部无法访问。在函数调用的时候，会将给定的值传递给函数的参数，这实际上是变量赋值的过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def myfunc(x,y,z):
    print(x,y,z)

myfunc(1,2,3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;def首先声明好函数，然后到了&lt;code&gt;myfunc(1,2,3)&lt;/code&gt;时，表示调用函数(执行函数)，调用函数时会将给定的值&lt;code&gt;1,2,3&lt;/code&gt;传递给函数的参数&lt;code&gt;x,y,z&lt;/code&gt;，其实就是变量赋值&lt;code&gt;x=1,y=2,z=3&lt;/code&gt;，然后使用print输出它们。&lt;/p&gt;
&lt;p&gt;由于python是动态语言，无需先声明变量，也无需指定变量的类型，所以python的函数参数和返回值非常的灵活。任何类型的变量或数据结构都可以传递给参数，这实际上是变量赋值的过程。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myfunc(1,2,3)
myfunc(&quot;abc&quot;,2,&quot;def&quot;)
myfunc([1,2,3],4,5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面几个函数调用语句中，赋值给参数的值可以是数值类型，可以是字符串类型，可以是列表类型，也可以是其它任何数据类型。&lt;/p&gt;
&lt;p&gt;python函数的参数相比其它语言要复杂一些，意味着要灵活很多，短短一个小节的篇幅完全没法解释清楚，关于参数细节，详细内容见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9832640.html&quot;&gt;后面的文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;函数声明调用的过程详述&quot;&gt;函数声明、调用的过程详述&lt;/h2&gt;
&lt;p&gt;def用来声明一个函数，python的函数包括函数名称、参数、函数体、函数体中涉及到的变量、返回值。&lt;/p&gt;
&lt;p&gt;实际上，&lt;strong&gt;函数名称其实是一个变量名，def表示将保存在某块内存区域中的函数代码体赋值给函数名变量&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def myfunc(x,y,z):
    ...CODE...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面表示将函数体赋值给变量名myfunc。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181108212800669-239434560.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然是变量，就可以进行输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def myfunc(x):
    return x+5

print(myfunc)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;function myfunc at 0x032EA6F0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于python是解释型语言，所以必须先定义函数，才能调用函数。&lt;/p&gt;
&lt;p&gt;如果导入一个模块文件，导入的时候会解释、执行文件中的代码，包括def语句，也就是说，导入文件时会先声明好函数。&lt;/p&gt;

&lt;h3 id=&quot;函数变量的细节&quot;&gt;函数变量的细节&lt;/h3&gt;
&lt;p&gt;请一定理解本节内容，也许细节方面可能会有些不准确，但对于深入理解函数来说(不仅限于python语言)，是非常有帮助的，特别是理解作用域规则的时候。&lt;/p&gt;
&lt;p&gt;python是解释性语言，读一行解释一行，解释一行忘记一行。而函数是一种代码块，代码块是一个解释单元，是一个整体。&lt;strong&gt;在代码块范围内不会忘记读取过的行，也不会读一行就立即解释一行，而是读取完所有代码块内的行，然后统筹安排地进行解释&lt;/strong&gt;。关于这一点，在后面的文章&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9925021.html#blogaaa3&quot;&gt;代码块详述&lt;/a&gt;中有非常详细的解释，建议一读。&lt;/p&gt;
&lt;p&gt;当python读取到def所在行的时候，知道这是一个函数声明语句，它有一个属于自己的代码块范围，于是会读完整个代码块，然后解释这个代码块。在这个解释过程中，&lt;strong&gt;会记录好变量以及该变量的所属作用域(是全局范围内的变量还是函数的本地变量)，但一定注意，def声明函数的过程中不会进行变量的赋值(参数默认值除外，见下文)，只有在函数调用的时候才会进行变量赋值。换句话说，在def声明函数的过程中，在函数被调用之前，函数所记录的变量一直都是变量的地址，或者通俗一点理解为记录变量的名称，而不会进行变量的赋值替换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=3
def myfunc(a,b):
    c=10
    print(x,a,b,c)

myfunc(5,6)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&quot;3 5 6 10&quot;。&lt;/p&gt;
&lt;p&gt;上面的函数涉及到了4个变量：a、b、c、x。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局变量x&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;本地变量a、b、c，其中本地变量a和b是函数的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在def的过程中，会完完整整地记录好这些变量以及所属作用域，但只会记录，不会进行变量的赋值。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181108221001603-1929424192.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后函数被调用，这时候才会开始根据记录的作用域搜索变量是否存在，是否已经赋值(非本地变量)，并对需要赋值的变量赋值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查找全局变量变量x，它在全局作用域内已经赋值过了，所以只需找到这个全局变量即可&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;查找本地变量a、b、c，它们是属于函数myfunc的本地变量，而a和b是参数变量，所以最先对它们进行赋值&lt;code&gt;a=5,b=6&lt;/code&gt;，然后赋值普通的本地变量&lt;code&gt;c=10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181108222127574-61430612.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后执行&lt;code&gt;print(x,a,b,c)&lt;/code&gt;输出这些变量的值。&lt;/p&gt;
&lt;p&gt;还需注意，python是读一行解释一行的，在函数调用过程中，因为&lt;code&gt;c=10&lt;/code&gt;在&lt;code&gt;print()&lt;/code&gt;的前面，所以是先赋值&lt;code&gt;c=10&lt;/code&gt;，再执行print，如果print在&lt;code&gt;c=10&lt;/code&gt;前面，则先执行print，再赋值，这显然是错误的，因为print()中使用了变量c，但目前还没有对其赋值。这和其它语言可能有些不同(特别是编译型语言)，它们可能会无视变量赋值以及变量使用的位置前后关系。&lt;/p&gt;
&lt;p&gt;如果上面的示例中，函数myfunc调用之前，将变量x赋值为另一个值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=3
def myfunc(a,b):
    c=10
    print(x,a,b,c)

x=33
myfunc(5,6)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时将输出：&quot;33 5 6 10&quot;。因为x是全局变量，只有在函数调用的时候才会去找到变量x对应的值，而这时全局变量的值已经是33。&lt;/p&gt;
&lt;h2 id=&quot;匿名函数lambda&quot;&gt;匿名函数lambda&lt;/h2&gt;
&lt;p&gt;匿名函数是指没有名称的函数，任何编程语言中，匿名函数都扮演着重要角色，它的功能非常灵活，但是匿名函数中的逻辑一般很简单，否则直接使用命名函数更好，匿名函数常用于回调函数、闭包等等。&lt;/p&gt;
&lt;p&gt;在python中使用lambda关键字声明匿名函数，python中的&lt;strong&gt;lambda是一个表达式而不是一个语句&lt;/strong&gt;，这意味着某些语句环境下可能无法使用def声明函数，但却可以使用lambda声明匿名函数。当然，匿名函数能实现的功能，命名函数也以一样都能实现，只不过有时候可能会比较复杂，可读性会更差。&lt;/p&gt;
&lt;p&gt;lambda声明匿名函数的方式很简单，lambda关键字后面跟上参数列表，然后一个冒号，冒号后跟一个表达式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lambda argl, arg2,... argN :expression statement&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;lambda表达式返回一个匿名函数，这个匿名函数可以赋值给一个变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 声明匿名函数，并赋值给变量f
f = lambda x,y,z: x+y+z

print(f)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;function &amp;lt;lambda&amp;gt; at 0x027EA6F0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然匿名函数赋值给了变量，这个函数就像是命名变量一样，可以通过这个变量去调用这个匿名函数。当然，它毕竟还是匿名函数，正如上面输出的结果中&lt;code&gt;function &amp;lt;lambda&amp;gt;&lt;/code&gt;所示。而且，匿名函数并非一定要赋值给变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 调用匿名函数
print(f(2,3,4))  # 输出9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;匿名函数的返回值是冒号后面的表达式计算得到的结果&lt;/strong&gt;。对于上面的示例，它等价于&lt;code&gt;return x+y+z&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为lambda是一个表达式，所以可以写在任何表达式可以出现的位置处，而某些语句上下文环境中，并不能直接使用def来声明。例如，将函数保存到一个列表中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;L=[ lambda x: x * 2,
    lambda x: x * 3,
    lambda x: x * 4 ]

print(L[0](2))
print(L[1](2))
print(L[2](2))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的lambda出现在列表的内部，且这里面的匿名函数并赋值给某个变量。像def语句就无法出现在这样的环境中，如果真要使用def来声明函数，并保存到列表中，只能在L的外部使用def定义，然后将函数名来保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f1(x): return x * 2
def f2(x): return x * 3
def f3(x): return x * 4

L=[f1,f2,f3]

print(L[0](2))
print(L[1](2))
print(L[2](2))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上去没什么问题，但函数定义的位置和列表L定义的位置可能会相差甚远，可读性可能会非常差。&lt;/p&gt;
&lt;p&gt;同理的，还可以将匿名函数保存在字典的value位置上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;key='four'
print(
    {
        'two':(lambda x: x * 2),
        'three':(lambda x: x * 3),
        'four':(lambda x: x * 4)
    }[key](2)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数嵌套&quot;&gt;函数嵌套&lt;/h2&gt;
&lt;p&gt;函数内部可以嵌套函数。一般来说，在函数嵌套时，内层函数会作为外层函数的返回值(当然，并非必须)。既然内层函数要作为返回值，这个嵌套的内层函数更可能会是lambda匿名函数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    y=10
    def g(z):
        return x+y+z
    return g&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的函数f()中嵌套了一个g()，并返回这个g()。其实上面示例中的g()是一个闭包函数。&lt;/p&gt;
&lt;p&gt;既然f()返回的是函数，这个函数可以赋值给其它变量，也可以直接调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 将嵌套的函数赋值给变量myfunc
# 这时myfunc()和g()是等价的
myfunc = f(3)
print( myfunc(5) )

# 直接调用g()
print( f(3)(5) )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，嵌套lambda匿名函数也可以，且更常见：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    y=10
    return lambda z: x+y+z&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;嵌套在循环内部的函数&quot;&gt;嵌套在循环内部的函数&lt;/h3&gt;
&lt;p&gt;看下面嵌套在循环内部的函数，在每个迭代过程中都声明一个匿名函数，这个匿名函数返回循环控制变量i，同时将声明的匿名函数保存到列表L中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f():
    L=[]
    for i in range(5):
        L.append( lambda : i )
    return L&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果调用该函数f()，并调用保存在列表中的每个匿名函数，会发现它们的值完全相同，且都是循环迭代的最后一个元素值&lt;code&gt;i=4&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List = f()
print(List[0]())
print(List[1]())
print(List[2]())
print(List[3]())
print(List[4]())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4
4
4
4
4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么会如此？为什么循环迭代过程中的i没有影响到匿名函数的返回值？这是一个非常值得思考的问题，如果不理解结果，请仔细回顾前文&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/9932901.html#blog2018002430&quot;&gt;函数变量的细节&lt;/a&gt;。如果还是不理解，请阅读&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9925021.html&quot;&gt;Python作用域详述&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;嵌套函数的作用域&quot;&gt;嵌套函数的作用域&lt;/h3&gt;
&lt;p&gt;此处给几个示例，这些示例的结果对于只学过python的人来说，可能会很容易理解，但对于学过其它语言的人来说，很容易混淆出错。&lt;/p&gt;
&lt;p&gt;此处并不会对这些示例的结果进行解释，因为只要理解了前文&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/9932901.html#blog2018002430&quot;&gt;函数变量的细节&lt;/a&gt;，这几个示例的结果很容易理解。&lt;/p&gt;
&lt;p&gt;同样，更详细的内容参见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9925021.html&quot;&gt;Python作用域详述&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=3
def f():
    x=4
    g()
    print(&quot;f:&quot;,x)

def g():
    print(&quot;g:&quot;,x)

f()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;g: 3
f: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在调用函数前，修改全局变量x的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=3
def f():
    x=4
    g()
    print(&quot;f:&quot;,x)

def g():
    print(&quot;g:&quot;,x)

x=6
f()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;g: 6
f: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果把g()的声明放在f()的内部呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x=3
def f():
    x=4
    def g():
        print(&quot;g:&quot;,x)
    print(&quot;f:&quot;,x)
    x=5
    return g

f()()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;f: 4
g: 5&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 08 Nov 2018 16:47:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>函数声明、调用、返回基础 Python中使用def关键字来声明函数，声明函数的格式为： 有3个需要注意的地方： 1. 函数名后面必须加冒号 2. 如果函数体和def不在同一行，则必须缩进 3. ret</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9932901.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：12. 优秀的文本化编辑思想大碰撞（Markdown、LaTeX、MathJax） - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop012.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这样一个标题可能不太准确，因为确实无法准确地解释什么叫“文本化编辑思想”。其实我这篇随笔主要是想探讨 Markdown、LaTeX、MathJax，有兴趣的朋友可以继续往下看，同时别忘记了顺手点个赞。&lt;/p&gt;
&lt;p&gt;先回忆一下我们平时用什么工具记笔记，最简单的可能直接上记事本，但是稍微需要点格式支持的，记事本的功能就不够用了，这时应该至少会用一个类似 Word 的“所见即所得”的可视化编辑器。很多时候我们要记录和分享的不仅仅只是文字，它还包含有各种各样的格式，比如字体、字号、颜色、标题、列表等等。这个格式可以让我们很容易地分辨笔记中的大纲和细节，也很容易突出显示需要强调的内容，便于我们阅读和理解，必要的时候，还可以在笔记中插入图片。“所见即所得”编辑器提供的编辑方法确实是最朴素的编辑思想：当你想要改变某些文字的样式时，你只需要选中它，然后在各种菜单、对话框里设置它的格式即可。这种排版很美观、样式很丰富的文章，可以称之为“富文本”。&lt;/p&gt;
&lt;p&gt;如果进行更深层次的思考，就会发现“富文本”存在很多缺点，特别是对于我们这些程序员、理工男来说更是这样。下面略举几例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“富文本”编辑起来太慢了，写文章时，即要考虑文章内容，又要考虑文章格式，写几段字就要点半天鼠标；&lt;/li&gt;
&lt;li&gt;“富文本”需要专业的编辑器来编辑和阅读，如果没有编辑器，或者编辑器不兼容，那只有欲哭无泪了；&lt;/li&gt;
&lt;li&gt;“富文本”往往让形式取代逻辑，文章可能从外观上看各级标题的文字大小、缩进都很正确，但是逻辑上无法指定层级关系；&lt;/li&gt;
&lt;li&gt;“富文本”中的格式信息太冗余了，淹没了文章的内容；&lt;/li&gt;
&lt;li&gt;“富文本”对计算机不友好，存储格式不透明不说，也让基于文本行比较的工具（如 diff 之类）无用武之地。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，优秀的思想应该是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文章就应该存储为纯文本的格式，用任何工具都可以阅读和编辑；&lt;/li&gt;
&lt;li&gt;该纯文本的内容即要适合人类阅读，也要计算机容易理解；&lt;/li&gt;
&lt;li&gt;能正确指定文章各部分的逻辑结构；&lt;/li&gt;
&lt;li&gt;内容和显示分离，作者只用考虑文章的内容和逻辑结构，而文章怎么显示得好看是专业的人和工具的事。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是我标题中说的“文本化编辑思想”。这种思想在计算机领域由来已久，并逐渐形成一种哲学。比如互联网上广泛使用的 HTML、XML 等，就是把信息储存为纯文本，用任何工具都可以阅读和编辑，并且能正确地指定内容的逻辑结构，而浏览器和 CSS 则控制文章如何显示。但是，HTML 标签还是太多了，如果没有浏览器，完全靠人工脑补阅读起来还是太困难了。于是，就诞生了 Markdown。&lt;/p&gt;
&lt;p&gt;在文本编辑领域还有另外一个难题，那就是数学公式（或者其它类似数学公式的东西，比如乐谱），它们显示起来是二维的，而且其中使用的很多符号标准键盘根本无法输入，使用的字体和正文也不一样。好在 Unix/Linux 世界中，它们有一个比较好的解决方法，那就是 LaTeX。当然，也有很多可视化的编辑器提供数学公式编辑的功能，比如 Word 的公式编辑器，比如 TexMacs。但是正如前文所述，从优秀的“文本化编辑思想”来思考，最好的依然是 LaTeX，因为使用 LaTeX 就是使用纯文本的方式输入数学公式，输入速度快，人和计算机都容易理解。LaTeX 的思想影响广泛，很多编辑器都支持以 LaTeX 语法输入数学公式。要在网页上显示数学公式，则非 MathJax 莫属了，它是一个 JavaScript 库，可以识别网页中的 LaTeX 格式的数学公式并将其完美显示出来。博客园的数学公式支持用的就是这个。&lt;/p&gt;
&lt;h2 id=&quot;markdown-的特点和工具&quot;&gt;Markdown 的特点和工具&lt;/h2&gt;
&lt;p&gt;Markdown 的宗旨就是“易读易写”，所以用 Markdown 语法写的文档，以纯文本的格式直接阅读也是非常方便的。如果对外观的要求非常高，就可以通过相应的工具将 Markdown 文档转化成 HTML 或者 PDF。Markdown 的语法非常简单，一般情况下一个多小时就学会了。目前，我在博客园中发博客基本上就是使用博客园的 Markdown 编辑器了。博客园使用和 Github 完全一样的 Markdown 语法，在这里可以阅读它的完整介绍：&lt;a href=&quot;https://github.github.com/gfm/&quot;&gt;GitHub Flavored Markdown Spec&lt;/a&gt;。Markdown 用起来很舒服，除了上传图片，基本上不用动鼠标，而且近期已经有好几个人表扬我的博客排版比较舒服了。&lt;/p&gt;
&lt;p&gt;在 Linux 桌面系统中，我使用 ReText 编辑 Markdown 文档。在 Ubuntu 中只需要&lt;code&gt;sudo apt-get install retext&lt;/code&gt;即可以安装该软件。另外还有一些比较出名的 Markdown 编辑器，比如 reMarkable 或者 Typora，但是这两款编辑器 Ubuntu 的官方软件仓库中没有，需要自己去下载安装，所以我就不用了。另外就是 Atom 编辑器也支持 Markdown，但是我试用以后觉得它的界面不好看，所以也不用。我觉得 ReText 就不错了，其界面如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108090753032-228417771.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108091854762-630009468.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然，这个预览的结果并不漂亮，也和我博客园中的样式完全不一样。这是因为我并没有为我的预览功能指定 CSS 样式表。前面说过，文本化编辑思想就是内容和显示分离，写作的时候，只需要考虑内容就可以了，而显示效果，可以由 CSS 样式表控制。如果我想让预览的效果和我的博客中一样，只需要把我博客中的 CSS 扒下来就可以了。同理，如果看到有哪个网站的文章显示效果比较好看，把它的 CSS 样式扒下来即可。另外，从上图的预览功能可以看到，现在最新版的 ReText 可以显示一定的数学公式，但是对行内的数学公式没有显示，那是因为我们没有为 ReText 指定 MathJax 数学公式扩展。点击 ReText 的 &quot;编辑&quot;-&amp;gt;&quot;个人偏好&quot; 菜单，在弹出的对话框里面可以设置我们使用的 CSS 样式表和 MathJax 扩展，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108095826061-1334205655.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再重新启动 ReText，其预览效果就是这样的了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108095550776-283852625.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108095337751-2059524044.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MathJax 支持 LaTeX 语法，至于 LaTeX 编辑数学公式的语法，我这里再为大家送上一份资料：《&lt;a href=&quot;http://files.cnblogs.com/youxia/lshort.pdf&quot;&gt;一份不太短的LaTeX 2e介绍&lt;/a&gt;》。&lt;/p&gt;
&lt;h2 id=&quot;数学公式和-latex&quot;&gt;数学公式和 LaTex&lt;/h2&gt;
&lt;p&gt;在我上一节中，我提到了 MathJax，我的博客中和 ReText 中的数学公式支持就靠它了。MathJax 支持 LaTex 的语法，所以平时写笔记，使用 Markdown 和 Mathjax 就够了。但是真正需要写科技论文的时候，就不得不上 LaTex 了。在这一节里，我再来谈谈 LaTeX。&lt;/p&gt;
&lt;p&gt;在很多人心中，LaTeX 是一个很专业的排版系统，同时也是一个很复杂的系统。说到专业，确实很多科技论文都是用 LaTeX 写作，而且很多知名的杂志社只接受 LaTeX 格式的投稿。使用 LaTeX 排版得到的效果那是超级赞，特别是对科技论文中充斥的数学公式而言。说到复杂，不仅是因为 LaTeX 排版语言命令繁多，更因为它数之不尽的宏包，学习成本真的是相当相当相当的高。&lt;/p&gt;
&lt;p&gt;对于一套 LaTeX 排版系统，它究竟包含哪些东西呢？我认为它主要可以分成这样几个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个排版引擎，TeX 或 pdfTeX 或 XeTeX；&lt;/li&gt;
&lt;li&gt;一系列的字体；&lt;/li&gt;
&lt;li&gt;一系列的宏包；&lt;/li&gt;
&lt;li&gt;一些工具，比如用来查看各种排版引擎输出的排版结果，或者在 dvi、ps、pdf 等格式之间的转换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而对于 LaTeX 排版系统的复杂性，我认为主要是由于历史原因引起的，理由如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最早的由 Knuth 教授写的 TeX 引擎不支持 UTF-8 编码的输入文件，所以要让它支持中文实在是太难了；&lt;/li&gt;
&lt;li&gt;最早的 TeX 系统自带一套字体，要扩展它就得扩展相应领域的字体，比如 LaTeX 自带丰富的数学字体，要把字体安装到 TeX 系统中是一件非常复杂的事情；&lt;/li&gt;
&lt;li&gt;大量的第三方宏包，安装和学习都非常困难；&lt;/li&gt;
&lt;li&gt;都什么年代了，谁还用 dvi 格式和 ps 格式啊，用 pdf 多方便啊。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这些历史原因引起的复杂性，现在早就解决了，只是很多书籍没有写清楚而已。我认为现在用 LaTeX 其实很方便的，理由如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Knuth 教授的 Tex 引擎用来瞻仰即可，实际工作中使用 XeTeX 引擎，完美支持 Unicode 字符集和 UTF-8 编码，中文再也不是问题；&lt;/li&gt;
&lt;li&gt;字体神马的，Knuth 教授的 METAFONT 早过时了，现在谁还不用 TrueType 啊？好的字体当然少不了像 Microsoft、Adobe、Apple 这些既有钱又有品味的公司出品了；&lt;/li&gt;
&lt;li&gt;XeTeX 引擎可以直接使用操作系统中安装的字体，再也不用考虑把字体安装到 TeX 系统中了；&lt;/li&gt;
&lt;li&gt;XeTeX 引擎直接输出 pdf 格式的文件；&lt;/li&gt;
&lt;li&gt;排版也可以有 IDE 工具，比如 TeXWorks 或 TexStudio；&lt;/li&gt;
&lt;li&gt;至于宏包太多这个问题，我们可以用现成的发行版嘛，比如 texlive 套装。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面开始实战。我是在 Ubuntu 系统下使用 texlive，使用&lt;code&gt;sudo aptitude search texlive&lt;/code&gt;命令，可以看到大量和 texlive 有关的包。考虑到我们需要使用中文，所以需要同时安装 texlive-lang-cjk 和 texlive-xetex。前面分析过，XeTeX 引擎和 XeLaTeX 引擎是支持Unicode 字符集和 UTF-8 编码的基础，而 texlive-lang-cjk 提供中文字体和中文排版的支持。和四年前相比，texlive 更加成熟，以上三个包安装完之后，不需要借用 Windows 的字体，也不需要修改任何配置文件，真正做到了开箱即用。这样安装 texlive：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude install texlive texlive-lang-cjk texlive-xetex&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以前我使用 TeXWorks，现在在朋友的推荐下使用 TexStudio。使用以下命令安装 TexStudio：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude install texstudio&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用 TexStudio 的时候，先进入它的设置界面，将引擎更改为 XeLaTeX，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108170642638-742364537.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后写一段测试文字，Build 一下，然后预览，就可以看到排版效果了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108170656868-1730009175.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于写写中文文档，使用 ctex 宏包就足够了，并不是很复杂。LaTeX 还有一些更加复杂的功能，比如制作幻灯片啊、绘图啊什么的，都有相应的宏包可以使用，而且安装 texlive 的时候，都安装了非常详细的帮助文档，只需要打开&lt;code&gt;/usr/share/texlive/doc.html&lt;/code&gt;这个文件，就可以看到所有宏包和帮助文档的列表，我前面分享的《&lt;a href=&quot;http://files.cnblogs.com/youxia/lshort.pdf&quot;&gt;一份不太短的LaTeX介绍&lt;/a&gt;》里面有，经典的《Tex by Topic》里面也有，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181108114054826-1015877641.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这个一公里长的帮助文档列表，你有什么感想呢？&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年11月09日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 16:31:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop012.html</dc:identifier>
</item>
<item>
<title>全局解释器锁GIL - itlongfei</title>
<link>http://www.cnblogs.com/lfblogs/p/9932882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lfblogs/p/9932882.html</guid>
<description>&lt;p&gt;解释一下对GIL的理解？&lt;/p&gt;
&lt;p&gt;　　GIL 又叫全局解释器锁，首先说一点，Python语言与GIL全局解释器锁没有关系，仅仅是因为历史原因，在cpython解释器中还存在GIL难以移除。GIL是功能与性能权衡后的产物，它有着存在的合理性，也有着难以移除的历史客观因素。&lt;/p&gt;

&lt;p&gt;为什么存在GIL?&lt;/p&gt;
&lt;p&gt;　　在早期的开发过程中，因为物理因素限制，从最开始的单核CPU发展为多核CPU, 想要充分发挥多核CPU的性能需要利用到多线程编程，Python中同样引入了多线程编程，而多线程编程引入带来的问题是：线程之间数据的一致性和状态同步的问题。 而想解决这些问题最好的方法就是加一把锁，所以就有了GIL全局解释器锁这样一把大锁。&lt;/p&gt;
&lt;p&gt;　　随着越来越多的代码库开发者接受GIL，而后逐渐大量依赖于这一特性进行开发，到最后发现GIL对多核CPU多线程编程的效率是低效影响的时候，想要移除这一特性，却发现已经很难了。&lt;/p&gt;

&lt;p&gt;谈谈GIL的作用？&lt;/p&gt;
&lt;p&gt;　　第一个作用： 当前线程必须需要先获取GIL,才能进入CPU执行代码。GIL的存在保障了在同一时刻只能有一个线程获取GIL，执行代码。&lt;/p&gt;
&lt;p&gt;　　第二个作用：当遇到IO阻塞时，执行线程会释放GIL,给其他线程获取锁执行代码的机会。&lt;/p&gt;

&lt;p&gt;　　问题: 如果是CPU密集型，一直占有CPU,而没有遇到IO阻塞，是不是其他线程就没有机会执行？&lt;/p&gt;
&lt;p&gt;　　其实也并不是这样，在解释器中会进行周期性的代码检测和执行代码调度，在Python2中使用的是计数器的方式释放GIL，就是当计数达到一定阀值，当前执行线程就会释放GIL给其他线程执行的机会。但会出现的问题就是: 当前执行线程刚释放了GIL可能又会立即再获取GIL进行执行。 在Python3中使用的是计时器的方式释放GIL，就是当前执行线程执行时间达到一定阀值就会释放GIL，给其他线程执行的机会。这样避免了当前执行线程刚释放GIL又立即获取的情况，同时在线程中增加了线程优先级，高优先级的线程可以迫使执行的线程释放GIL，进行执行。&lt;/p&gt;

&lt;p&gt;谈谈GIL的设计缺陷和影响？&lt;/p&gt;
&lt;p&gt;　　在早期的开发过程中，为了让各个线程能够平均的利用CPU的执行时间，python中采用的是计数的方式切换执行代码，就是当计数（执行的线程代码数）达到一定的阀值，执行线程就会释放GIL锁，给其他线程执行的机会。这一模式在单核CPU中没有问题，因为无论是其他哪个线程被唤醒，都能够成功的获取GIL进入CPU执行代码。而在多核CPU中则会有问题，当唤醒其它核心上的线程时候，大多数情况下总是当前主线程刚刚释放GIL，又会立即再次获取GIL进行执行，而其他被唤醒的线程只能白白等待浪费CPU的执行时间，等到执行时间结束，会进入到待唤醒待调度状态，再次被唤醒，再次等待，如此恶性循环着。&lt;/p&gt;
&lt;p&gt;　　GIL的影响有： GIL无疑是一把全局排他锁，它的存在保证了再同一时刻只能有一个线程获取GIL进行执行代码，所以就无法让多核CPU多线程实现并行，而想充分发挥多核CPU的最大性能就是实现多任务并行。  下面解释一下什么是并发和并行。&lt;/p&gt;
&lt;p&gt;　　并发： 当任务数大于CPU核心数时，总有一些任务是没有在执行的，只不过是因为CPU的切换速度很快，让人感觉像是多任务同时在一起执行。&lt;/p&gt;
&lt;p&gt;　　并行： 当任务数小于或者等于CPU核心数时，每个任务都有一个对应的核来处理执行，是真正意义上的多任务同时一起执行。&lt;/p&gt;

&lt;p&gt;如何避免GIL的影响？&lt;/p&gt;
&lt;p&gt;　　方法一: 更换python解释器，比如jpython，用java开发的python解释器。 但因为众多的库都是建立在GIL这一特性下开发的，所以更换解释器很多库用不了，不划算。&lt;/p&gt;
&lt;p&gt;　　方法二： 使用多进程代替多线程。 multiprocession库的开发很大程度上就是为了弥补threading库因为GIL特性低效的缺陷，它完整的复制了一份threading里面的API接口便于迁移管理。 唯一的不同就是它是多进程而不是多线程，每一个进程都有自己的GIL锁，不会出现进程直接GIL锁的竞争。而多线程的时候则会出现释放GIL多个线程同时争抢锁的情况，这样会浪费CPU的性能资源。&lt;/p&gt;
&lt;p&gt;　　但多进程也不是万良解药，它的引入同时会增加实现进程间通信和状态同步的难度，在多线程中对公共资源进行修改，只需要在线程中gloab 声明一下就可以了，多线程之间是共享全局变量的。而在多进程中，则需要使用一个Queue队列，通过put 或者get来传递数据，增加了开发的难度。多进程间是不共享全局变量的。&lt;/p&gt;

</description>
<pubDate>Thu, 08 Nov 2018 16:28:00 +0000</pubDate>
<dc:creator>itlongfei</dc:creator>
<og:description>解释一下对GIL的理解？ GIL 又叫全局解释器锁，首先说一点，Python语言与GIL全局解释器锁没有关系，仅仅是因为历史原因，在cpython解释器中还存在GIL难以移除。GIL是功能与性能权衡后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lfblogs/p/9932882.html</dc:identifier>
</item>
<item>
<title>java异步编程降低延迟 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/9932845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/9932845.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;在平时开发的过程中，其实有很多可以采用多线程优化的地方，像ExecutorService、CompletionService、CompletableFuture和并行流等类，只是没有去注意，这里总结下日常工作中常用的一些方法。&lt;/p&gt;
&lt;h2 id=&quot;一executorservice和completionservice&quot;&gt;一、ExecutorService和CompletionService&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本的execute和submit方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个其实没有太多好说的，因为这个是最基本的，基本使用线程池的都会使用到这个方法，主要用于异步执行任务，submit和execute的区别就在于，submit有一个方法的回执，可以利用这个Future对这个任务的生命周期进行干预。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;invokeAll和invokeAny方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人没有注意到这两个方法，这两个方法其实也是非常有用的，例如你有很多可以并行执行的操作投递到线程池，执行完之后就挨个调用Future的get获取结果最后生成结果，这两个步骤其实就是invokeAll已经封装好的。他的内部实现也很简单和你手动取每个值是一样的，这个方法只会到所有任务执行完毕或者设定的时间超时了才会返回。实现非常简单：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; for (int i = 0, size = futures.size(); i &amp;lt; size; i++) {
                Future&amp;lt;T&amp;gt; f = futures.get(i);
                if (!f.isDone()) {
                    try {
                        f.get();
                    } catch (CancellationException ignore) {
                    } catch (ExecutionException ignore) {
                    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;invokeAny方法稍微比invokeAll复杂些，内部是基于ExecutorCompletionService实现的。如果有一个任务返回了就直接返回结果，如果第一个完成的任务抛出了异常那么这个方法会抛出对应的异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CompletionService&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类名中文翻译就是完成服务，这个类组合了ExecutorService，实现逻辑非常简单，内部存放了一个阻塞队列，当投递的任务完成时会将对应的Future放入这个阻塞队列，这样就可以做到投递的任务在完成的顺序依次放入阻塞队列。这就是上面invokeAny实现利用主要逻辑。利用阻塞队列的poll和take方法，在第一个返回时就取消剩余的任务。&lt;br/&gt;虽然invokeAny已经封装了CompletionService的逻辑但是有些场景这个类还是很有用的。比如现在我想要得到一个最先完成的但是没有抛出异常的，这种情况下我们就需要写一个类似于invokeAny的例子。jdk注释中给出了例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void solve(Executor e,
            Collection&amp;lt;Callable&amp;lt;Result&amp;gt;&amp;gt; solvers)
     throws InterruptedException {
     CompletionService&amp;lt;Result&amp;gt; ecs
         = new ExecutorCompletionService&amp;lt;Result&amp;gt;(e);
     int n = solvers.size();
     List&amp;lt;Future&amp;lt;Result&amp;gt;&amp;gt; futures
         = new ArrayList&amp;lt;Future&amp;lt;Result&amp;gt;&amp;gt;(n);
     Result result = null;
     try {
         for (Callable&amp;lt;Result&amp;gt; s : solvers)
             futures.add(ecs.submit(s));
         for (int i = 0; i &amp;lt; n; ++i) {
             try {
                 Result r = ecs.take().get();
                 if (r != null) {
                     result = r;
                     break;
                 }
             } catch (ExecutionException ignore) {}
         }
     }
     finally {
         for (Future&amp;lt;Result&amp;gt; f : futures)
             f.cancel(true);
     }

     if (result != null)
         use(result);
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类也很容易想到一个场景，我有很多任务是可以并发执行了，这时可以使用invokeAll，但是让必须等到所有的任务执行完毕才能返回，这时如果有一个任务被io阻塞了很慢将会导致整个方法阻塞。如果是利用CompletionService的话，因为他是按照任务的完成顺序往队列里放，所以我们可以全部提交后，利用他的poll或者take方法遍历任务，先完成的任务返回就可以直接消费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;讲到这里我觉得有必要提一下Future，因为线程池中投递任务submit方法均为返回Future这个对象。Future你可以把它理解成对这个任务的建模，你得这个对象可以利用这个对象来管理任务的生命周期，例如get方法获取结果，cancel来取消这个任务，以及isDnoe来判断任务是否取消等。api没有什么难理解的地方，主要是取消任务这一块需要结合中断来理解，cancel参数的Boolean值就是说能不能给这个任务发中断，如果可以他内部实际就是通过中断来停止任务，需要用户代码响应中断。FutureTask中的cancel源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (mayInterruptIfRunning) {
    try {
        Thread t = runner;
        if (t != null)
            t.interrupt();
    } finally { // final state
        UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二completablefuture重要&quot;&gt;二、CompletableFuture（重要）&lt;/h2&gt;
&lt;p&gt;上面简单说了下Future，Future是jdk5.0就已经引进的，但是他的能力非常的弱，主要是缺少了一个回调的机制，很多框架都基于它提供了增强版像guava的&lt;code&gt;ListenableFuture&lt;/code&gt;和spring中的&lt;code&gt;ListenableFuture&lt;/code&gt;。直到java8出现了CompletableFuture才弥补了jdk的这个特性。&lt;br/&gt;可能很多人没有注意到这个类，因为平时没关注这方面，其实如果好好的学习下这个类就会发现这个类的功能非常强大，和stream类似的设计思想，使用非常简洁。可以基于教程好好研究一下，这里介绍下常用的操作。&lt;/p&gt;
&lt;p&gt;在以前我们投递到线程中任务返回的Future中，我们只能实现一些简单的轮询，取消等api。如果现在有这样的一些类似的需求：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行一个任务，当任务执行完的时候执行一个动作（相当于任务执行完触发回调）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    CompletableFuture.runAsync(() -&amp;gt; System.out.println(&quot;hello word&quot;)).whenComplete((aVoid, throwable) -&amp;gt; System.out.println(&quot;任务完成&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;任务执行完的时候在发起另外一个任务（这里是有顺序性的，第二个依赖于第一个任务）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CompletableFuture.supplyAsync(() -&amp;gt; 12).thenApply(Function.identity()).thenAccept(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同时执行多个任务，当全部完成的时候执行一个动作&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Integer join = CompletableFuture.supplyAsync(() -&amp;gt; {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 1;
        }).thenCombine(CompletableFuture.supplyAsync(() -&amp;gt; {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 2;
        }), Integer::sum).join();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到上面的这些任务都不简单，但是如果使用CompletionStage却变得十分容易，对任务的组合正是CompletableFuture的强项，下面大概说下CompletionStage的api。&lt;br/&gt;通过观察就会发现CompletionStage的一种类型操作都会有三种重载形式，分别如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;XXX()&lt;/li&gt;
&lt;li&gt;XXXAsync()&lt;/li&gt;
&lt;li&gt;XXXAsync(executors参数)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一个表示这个操作在当前线程池中的当前线程直接执行，第二个表示会重新投递到当前线程池执行，第三个则表示会重新投递到传入的线程池继续执行。一般情况都会采用第一种形式和第三种，第一种是最常用的，可以减少线程的上下文切换，第三种情况主要用户切换线程池，我们很多时候会根据不同的任务比如io密集型，cpu密集型创建不同的线程池，考虑这样一种情况，我创建了一个ncpu+1的线程池1，和一个上限500的线程池2，第一个任务是cpu密集型，第二个依赖于第一个且是io密集型，这时候我们可以选择将第一个投递到线程池1，然后第二个通过传入线程池参数重新投递到线程池2中执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;thenRun 前一个任务&lt;span&gt;正常执行&lt;/span&gt;完后执行一个任务&lt;/li&gt;
&lt;li&gt;thenAccept&lt;/li&gt;
&lt;li&gt;thenApply&lt;/li&gt;
&lt;li&gt;thenCompose&lt;/li&gt;
&lt;li&gt;handle &lt;em&gt;前一个任务执行完后执行(包括前一个抛出异常)，如果前面任务未抛出异常当前任务抛出异常则结果就是抛出异常，如果前面任务抛出异常e1当前任务抛出异常e2则结果就是抛出异常e1&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;whenComplete&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;exceptionally 如果前一个任务未抛出异常则不执行&lt;/li&gt;
&lt;li&gt;XXXBoth(thenCombine) 两个任务全都&lt;span&gt;正常完成&lt;/span&gt;时执行&lt;/li&gt;
&lt;li&gt;XXXEither 当最先完成的任务是&lt;span&gt;正常完成&lt;/span&gt;时执行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的方法大致可以再分为三组，分别是1-4,5-7,8-9。&lt;/p&gt;
&lt;p&gt;1-4： 这个很好理解，四个方法都十分类似，这里要提下的就是thenApply和thenCompose，会感觉有点难理解，你可以从java的stream中map和flatMap的角度来理解，这两个方法做的事实际是一样的，只不过形式不一样，主要也是在和stream结合的过程中会用到，所以一般很少用到thenCompose。另外有一点很重要：&lt;em&gt;如果前一个任务执行过程抛出了异常那么这个任务就不会执行也&lt;strong&gt;不会有任何提示&lt;/strong&gt;，除非你调用CompletableFuture的get等获取结果的方法会再次得到异常，不然这个异常信息就丢了，需要十分注意这个点。&lt;/em&gt;&lt;br/&gt;5-7： 1-4的方法如果前面的任务抛出异常则会导致1-4任务的不执行。5-7的方法都可以对异常进行处理，如果前一个抛出了异常，会有参数传入，可以做相应的处理，很多时候可以利用这三个方法来记录日志，你看whenComplete就完全是一个透传的效果&lt;br/&gt;8-9： 这两组类型分别是对两个任务的与和或条件的组合工具方法。没什么难理解的，主要就是thenCombine，其实他实现的语义就是applyAfterBoth，只不过名字稍微不同而已。另外说下XXXEither，他的语义是任意一个任务执行完成后执行相应的动作，需要注意的地方就是如果最先完成的那个任务抛出的是异常这个任务就不会执行。&lt;/p&gt;
&lt;p&gt;再次提醒下异常，如果你对最后的CompletablFuture会调用get等取结果的方法那没什么，执行过程中抛出的异常会再次抛出，但是如果你只是调用后不再去取结果，就像thenApply结尾那么就一定要非常小心，如果前一个方法抛出异常你的thenApply的任务便不会执行，而且都没有什么提示。你可以对相应的任务包装打印异常在rethrow,如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AsyncableWrapper {

    public static final Runnable of(Runnable runnable) {
        return () -&amp;gt; {
            try {
                runnable.run();
            } catch (Exception e) {
                log.error(&quot;执行异步任务失败&quot;, e);
                throw e;
            }
        };
    }


    public &amp;lt;T&amp;gt; Consumer&amp;lt;T&amp;gt; ofConsumer(Consumer&amp;lt;T&amp;gt; consumer) {
        return o -&amp;gt; {
            try {
                consumer.accept(o);
            } catch (Exception e) {
                log.error(&quot;执行异步任务失败，&quot;, e);
                throw e;
            }
        };
    }

    public &amp;lt;T&amp;gt; Supplier&amp;lt;T&amp;gt; ofSupply(Supplier&amp;lt;T&amp;gt; supplier) {
        return () -&amp;gt; {
            try {
                return supplier.get();
            } catch (Exception e) {
                log.error(&quot;执行异步任务失败，&quot;, e);
                throw e;
            }
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的这个代码你可以试试执行的结果，用来测试异常：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CompletableFuture.supplyAsync(() -&amp;gt; 1).whenComplete((o, throwable) -&amp;gt; {
    System.out.println(&quot;when1&quot;);
    throw new RuntimeException();
}).thenAccept(o -&amp;gt; {
    System.out.println(&quot;accetp2&quot;);
}).thenApply(aVoid -&amp;gt; {
    System.out.println(&quot;apply&quot;);
    return 1;
}).whenComplete((integer, throwable) -&amp;gt; {
    System.out.println(&quot;when2&quot;);
}).thenAccept(integer -&amp;gt; {
    System.out.println(&quot;accetp&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;join: 在之前Future的api中，只有get方法，会抛出受检查异常，受检查在lambda表达式中需要捕获使得代码看上去不那么美观，因此引入了join，除了包装了受检异常，其他行为和get一样&lt;/p&gt;
&lt;p&gt;getNow:可以立即返回，参数可以写入默认值，在轮询的场景中会有用到&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工具方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;anyOf:用于等待一组任务任意一个最先完成&lt;/p&gt;
&lt;p&gt;allOf:用于等待一组任务全部完成&lt;/p&gt;
&lt;p&gt;这两个方法和上面的XXXEither和XXXBoth很相似，只不过是多个CompletablFuture。抛出异常的规则也是一样的。常用形式如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CompletableFuture.allOf(c1, c2, c3).join();&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;三stream中的parallel并行流&quot;&gt;三、stream中的parallel（并行流）&lt;/h2&gt;
&lt;p&gt;在处理一批任务的时候，大部分场景都会有个集合，例如一个id列表，然后我们需要获取每个id的信息，通过http接口，但是没有批量接口，这时候我们可以采用并行来提高性能。&lt;/p&gt;
&lt;p&gt;流中有个简单的方法parallel可以并行执行，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Arrays.stream(new int[]{1, 2, 3}).parallel().forEach(operand -&amp;gt; {
    try {
        System.out.println(&quot;执行任务:&quot; + operand);
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的转换成并行流十分简单，执行时间一秒左右，就多了一个方法调用。那么如果每个任务执行完还有第二个步骤那怎么办呢，很容易想到结合ComplablFuture使用，那就是如下的形式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CompletableFuture[] completableFutures = Arrays.stream(new Integer[]{1, 2, 3})
        .map(operand -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; {
            try {
                System.out.println(&quot;执行任务:&quot; + operand);
                Thread.sleep(1000);
                return operand;
            } catch (InterruptedException e) {
                e.printStackTrace();
                return 0;
            }
        })).map(integerCompletableFuture -&amp;gt; integerCompletableFuture.thenApply(integer -&amp;gt; {
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
            }
            return integer;
        })).toArray(CompletableFuture[]::new);
CompletableFuture.allOf(completableFutures).join();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的耗时大概在2秒左右，Stream和ComplablFuture组合功能是十分强大的，另外你可以注意到上面的代码中我移除了parallel()方法，因为ComplablFuture本身就利用了线程池，再利用parallel()是没必要的，反而会增加线程上下文的切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际执行的线程池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用并行流和异步的过程中，肯定会非常好奇到底实际执行代码是在哪里，异步可能会好理解些，因为他很多方法例如thenAcceptAsync提供了线程池是你可以配置的。但是如果不传的那么实际使用的是ForkJoinPool。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  private static final Executor asyncPool = useCommonPool ?
        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并行流内部使用的也是上述的线程池，但是并行流却没有提供显示设置线程池的方法，这就导致有些阻塞的方法不适合采用并行流，其实他也是可以设定线程池的只不过不是像你想的那样，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ExecutorService executorService = Executors.newWorkStealingPool();
executorService.execute(() -&amp;gt; {
        CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(1);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            throw new RuntimeException();
        }).runAfterEither(CompletableFuture.supplyAsync(() -&amp;gt; {
            System.out.println(2);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 1;
        }), () -&amp;gt; System.out.println(123));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键点就在于上面代码中的executorService，他是ForkJoinPool的实例，&lt;strong&gt;并行流执行的过程中如果发现当前线程是ForkJoinPool的实例，那么会利用当前的ForkJoinPool来并行执行&lt;/strong&gt;，从而改变了线程池。如果只是计算操作，没有涉及io和锁等阻塞那么使用默认的线程池是很不错的行为，就像平时对集合使用stream来计算就完全没必要改变线程池。但是在使用线程池提高性能的很多时候都会涉及io操作，如Rpc，Db，Http等操作，这时候完全有必要根据相应的业务场景提供一个合适的线程池，而不是使用一个统一的线程池。关于利用并行stream还是ComplablFuture，如果不涉及io以及任务组合等操作，我更会倾向使用stream，更多的情况下我会选择使用ComplablFuture，结构更清晰。&lt;/p&gt;
&lt;p&gt;关于线程池的总结可以参考我的这篇文章 &lt;a href=&quot;https://www.cnblogs.com/chenfangzhi/p/9912484.html&quot;&gt;java线程池和中断总结&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;四实际使用的另外一点总结&quot;&gt;四、实际使用的另外一点总结：&lt;/h2&gt;
&lt;p&gt;刚开始接触异步的时候觉得他是提升性能的银弹，但是其实很多技术都有适合的场景，不能为了技术而技术。这里举个反例，当时在公司调用rpc的时候例如根据id列表批量获取信息，因为不想麻烦别人有刚好试试异步api，就采用了每个id调用一次，利用异步来降低延迟的方案，后来实际证明是非常错误的！假设有100个id，如果对方提供了批量操作的rpc，那么一次往返即可，采用异步方案多增加199次调用，吞吐量严重降低，另外因为接口有调用限制，并发上去后接口的全部返回失败！这种场景rpc每个操作耗时短，就非常适合提供批量操作而不是每个调用一次。&lt;br/&gt;再来个正面例子，公司最近对接腾讯云的人脸识别服务，因为是Http接口，而且每个接口返回比较慢，所以非常适合采用线程池和异步来优化延迟。&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 16:11:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>java异步编程降低延迟 在平时开发的过程中，其实有很多可以采用多线程优化的地方，像ExecutorService、CompletionService、CompletableFuture和并行流等类，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/9932845.html</dc:identifier>
</item>
<item>
<title>Shell编程-03-Shell中的特殊变量和扩展变量 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9932841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9932841.html</guid>
<description>&lt;h3 id=&quot;特殊变量&quot;&gt;特殊变量&lt;/h3&gt;
&lt;p&gt;    在Shell中的特殊变量主要分别两种&lt;strong&gt;位置参数变量&lt;/strong&gt;、&lt;strong&gt;状态变量&lt;/strong&gt;两种。&lt;/p&gt;
&lt;h4 id=&quot;位置参数变量&quot;&gt;位置参数变量&lt;/h4&gt;
&lt;p&gt;    Shell中的位置参数变量主要是指$0、$1、$#等，主要用于从命令行、函数或脚本执行等地方传递参数。详细说明如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;$0&lt;/strong&gt;:获取当前执行的Shell脚本的文件名，如脚本中包含路径，则输出也包括路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$n&lt;/strong&gt;:获取当前执行的Shell脚本的第n个参数值，如n&amp;gt;9，则需要使用用大括号，如${10}，各参数间用&lt;strong&gt;空格&lt;/strong&gt;进行分隔&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$#&lt;/strong&gt;:获取当前执行的Shell脚本传入参数的总个数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$*&lt;/strong&gt;:获取当前执行的Shell所有传入参数，&lt;strong&gt;如不加引号则与$@功能相同&lt;/strong&gt;，如果添加双引号**&quot;$*&quot;，则表示将所有传入参数视为单个字符串**，相当于&quot;$1 $2 $3&quot;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$@&lt;/strong&gt;:获取当前执行的Shell所有传入参数，**如不加引号则与$*功能相同&lt;strong&gt;，如果添加双引号&lt;/strong&gt;&quot;$@&quot;，则表示将所有传入参数视为独立的字符串**，相当于&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当&quot;$*&quot;和&quot;$@&quot;都添加双引号时，两者的功能有所区别；如不加，则功能相同，无区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;位置参数变量示例&quot;&gt;位置参数变量示例&lt;/h4&gt;
&lt;p&gt;1、示例一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat para.sh
#!/bin/bash
echo $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15}
echo '$0  is:' $0
echo '$1  is:' $1
echo '$12 is:' ${12}
echo '$#  is:' $#
echo '$*  is:' $*
echo '&quot;$*&quot;is:' &quot;$*&quot;
echo '$@  is:' $@
echo '&quot;$@&quot;is:' &quot;$@&quot;
# 输出结果
[root@localhost Test]# bash ~/Test/para.sh {a..z}
a b c d e f g h i j k l m n o
$0  is: /root/Test/para.sh
$1  is: a
$12 is: l
$#  is: 26
$*  is: a b c d e f g h i j k l m n o p q r s t u v w x y z
&quot;$*&quot;is: a b c d e f g h i j k l m n o p q r s t u v w x y z
$@  is: a b c d e f g h i j k l m n o p q r s t u v w x y z
&quot;$@&quot;is: a b c d e f g h i j k l m n o p q r s t u v w x y z&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、传入的参数个数多于脚本定义的参数时，则多出的参数会忽略&lt;br/&gt;2、传入的参数中如使用双引号，则会当作一个参数值进行传递&lt;br/&gt;3、位置参数如大于9，需要使用${}进行传递&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、示例二：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat testposition.sh 
#!/bin/bash
echo '$# $1 $2 $3 $* $@'
echo $# $1 $2 $3 $*  $@
echo &quot;************&quot;
echo '$*'
for tmp in $*
 do
   echo $tmp
 done
echo &quot;************&quot;
echo &quot;@@@@@@@@@@@@&quot;
echo '$@'
for temp in $@
 do
  echo $temp
 done
echo &quot;@@@@@@@@@@@@&quot;

echo '&quot;*&quot;*&quot;*&quot;*&quot;*&quot;*'

echo '$*'
for i in &quot;$*&quot;
 do
   echo $i
 done
echo '&quot;*&quot;*&quot;*&quot;*&quot;*&quot;*'

echo '&quot;@&quot;@&quot;@&quot;@&quot;@&quot;@'

echo '$@'
for j in &quot;$@&quot;
 do
  echo $j
 done
echo '&quot;@&quot;@&quot;@&quot;@&quot;@&quot;@'

[root@localhost Test]# bash testposition.sh  &quot;Hello Jack&quot; Welcome &quot;to Shanghai&quot;
$# $1 $2 $3 $* $@
3 Hello Jack Welcome to Shanghai Hello Jack Welcome to Shanghai Hello Jack Welcome to Shanghai
************
$* # 未加双引号，所以会输出全部参数，则第一个和第三个参数会拆开
Hello
Jack
Welcome
to
Shanghai
************
@@@@@@@@@@@@
$@ # 未加双引号，所以会输出全部参数，则第一个和第三个参数会拆开
Hello
Jack
Welcome
to
Shanghai
@@@@@@@@@@@@
&quot;*&quot;*&quot;*&quot;*&quot;*&quot;*
$* # 添加双引号后，传入的参数全部当一个参数进行输出
Hello Jack Welcome to Shanghai
&quot;*&quot;*&quot;*&quot;*&quot;*&quot;*
&quot;@&quot;@&quot;@&quot;@&quot;@&quot;@
$@ # 添加双引号后，传入的参数全部当独立的参数进行输出
Hello Jack
Welcome
to Shanghai
&quot;@&quot;@&quot;@&quot;@&quot;@&quot;@&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;状态变量&quot;&gt;状态变量&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;$?&lt;/strong&gt;:获取上一个命令或脚本的执行状态值（0:成功，其他：失败）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$$&lt;/strong&gt;:获取当前执行的Shell的进程号（PID）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;$！&lt;/strong&gt;:获取上一个在后台工作的进程的进程号&lt;/li&gt;
&lt;li&gt;**$_**:获取在些之前执行的命令或脚本的最后一个参数&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上四个状态变量，仅$?常用，其他三个了解即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在日常使场景中，$?主要用法如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、判断命令和脚本是否执行成功&lt;/li&gt;
&lt;li&gt;2、如脚本中调用&lt;strong&gt;exit 数字&lt;/strong&gt;，则会返回该数字给$?&lt;/li&gt;
&lt;li&gt;3、如在函数中，则可以通过&lt;strong&gt;return 数字&lt;/strong&gt;将该数字返回给$?&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;状态变量示例&quot;&gt;状态变量示例&lt;/h4&gt;
&lt;p&gt;1、$?示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# ll /etc/profile
-rw-r--r--. 1 root root 1819 4月  11 2018 /etc/profile
[root@localhost Test]# echo $?
0
[root@localhost Test]# ll /etc/profild
ls: 无法访问/etc/profild: 没有那个文件或目录
[root@localhost Test]# echo $?
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、$$示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat testPID.sh
#!/bin/bash
echo $$ &amp;gt; /tmp/test.pid
sleep 300

[root@localhost Test]# bash testPID.sh  &amp;amp; # 将当前脚本调用到后台执行
[1] 1671
[root@localhost Test]# ps -ef | grep testPID | grep -v grep
root      1671 23706  0 16:37 pts/0    00:00:00 bash testPID.sh # 查询PID&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、$!示例：&lt;br/&gt;    $!功能类似于$$，只不过是获取上一次执行脚本的PID&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash testPID.sh  &amp;amp;
[1] 24078
[root@localhost Test]# echo $!
24078 # 打印上一次在后台执行的进程号
[root@localhost Test]# ps -ef | grep testPID | grep -v grep
root     24078 23706  0 16:42 pts/0    00:00:00 bash testPID.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、$_示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash para.sh {a..z}
a b c d e f g h i j k l m n o
$0  is: para.sh
$1  is: a
$12 is: l
$#  is: 26
$*  is: a b c d e f g h i j k l m n o p q r s t u v w x y z
&quot;$*&quot;is: a b c d e f g h i j k l m n o p q r s t u v w x y z
$@  is: a b c d e f g h i j k l m n o p q r s t u v w x y z
&quot;$@&quot;is: a b c d e f g h i j k l m n o p q r s t u v w x y z
[root@localhost Test]# echo $_
z # 打印最后一个传入的参数值&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bash-内置变量&quot;&gt;Bash 内置变量&lt;/h4&gt;
&lt;p&gt;    常用的内部命令有&lt;strong&gt;echo、eval、exec、export、read、shift、exit&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;echo&quot;&gt;echo&lt;/h5&gt;
&lt;p&gt;    主要用于打印信息，其命令格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo [options] args&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用参数如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;不换行输出内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;解析转义字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;echo常用转义字符如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;换行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;回车&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;Tab&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;退格&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;纵向制表符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;eval&quot;&gt;eval&lt;/h5&gt;
&lt;p&gt;    当Shell程序运行到eval语句时，将读入参数args，并将它们组合成一个新的命令而后执行。其命令格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;eval args&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;exec&quot;&gt;exec&lt;/h5&gt;
&lt;p&gt;    exec主要用于在不创建新的子进程的情况下，转而执行指定的命令，当指定命令执行完后，则终止该进程。其命令格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec args&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当使用exec打开文件后，read命令每次都会将文件指针移动到下一行进行读取，直至结束。因此常用来处理文件内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;read&quot;&gt;read&lt;/h5&gt;
&lt;p&gt;    从标准输入读取变量或字符串等信息并传递给其他变量，其命令格式如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read args&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shift&quot;&gt;shift&lt;/h5&gt;
&lt;p&gt;    对传入的位置参数依次向左移动一个位置，并使用位置参数$#减1，直至0为止。其命令格式如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shift postition args&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;shift如果不带参数，则默认左移1位&lt;br/&gt;如传入的参数为$1 $2 $3，如执行一次shift，则之前的$3变成$2，$2变成$1，$1消失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;exit&quot;&gt;exit&lt;/h5&gt;
&lt;p&gt;    常用于退出Shell，在日常使用过程中可使用&lt;strong&gt;exit num&lt;/strong&gt;来自定义返回状态数。&lt;/p&gt;
&lt;h4 id=&quot;bash-内置变量示例&quot;&gt;Bash 内置变量示例&lt;/h4&gt;
&lt;p&gt;1、echo&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# echo &quot;Test&quot;;echo &quot;Dao&quot;
Test
Dao
[root@localhost Test]# echo -n &quot;Test&quot;;echo &quot;Dao&quot;
TestDao
[root@localhost Test]# echo -e &quot;Test\tName\n Dao&quot;
Test    Name
 Dao&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、eval&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat eval.sh
#!/bin/bash

echo &quot;No eval&quot;
echo \$$#
echo &quot;Add eval&quot;
eval echo \$$#

[root@localhost Test]# bash eval.sh  a b
No eval
$2 # 未添加evel时，$#为2，则输出$2
Add eval
b  # 添加evel后，则重新对传入的参数进行解析，则输出传入的第2个参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、exec&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# exec ls
eval.sh  para.sh  ping.sh  testPID.sh  testposition.sh
[admin@localhost ~]$  # 在执行exec后则终止当前Shell进程，因此从root用户退出到普通用户
# 与read一起读取文件
[root@localhost ~]# seq 5 &amp;gt; /tmp/rand.log
[root@localhost ~]# cat /tmp/rand.log 
1
2
3
4
5
[root@localhost Test]# cat exec.sh
#!/bin/bash
exec &amp;lt; /tmp/rand.log
while read line
 do
  echo $line
 done
echo &quot;Completed&quot;

[root@localhost Test]# bash exec.sh
1
2
3
4
5
Completed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、read&lt;br/&gt;可以参考公众号中read命令一文&lt;/p&gt;
&lt;p&gt;5、shift&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat shift.sh
#!/bin/bash
echo $1 $2 $3 $4 $5
until [ -z $1 ]
do
  echo $@
  shift 1
done
[root@localhost Test]# bash shift.sh {1..5}
1 2 3 4 5
1 2 3 4 5
2 3 4 5
3 4 5
4 5
5&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;变量扩展&quot;&gt;变量扩展&lt;/h3&gt;
&lt;h4 id=&quot;变量扩展说明&quot;&gt;变量扩展说明&lt;/h4&gt;
&lt;p&gt;    Shell中变量扩展说明如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;${var}&lt;/strong&gt;:返回${var}的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${#var}&lt;/strong&gt;:返回${var}的字符长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var:offset}&lt;/strong&gt;:返回${var}从位置offset之后开始提取字符至结束&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var:offset:length}&lt;/strong&gt;:返回${var}从offset之后，提取长度为length的字符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var#word}&lt;/strong&gt;：返回从${var}&lt;strong&gt;开头&lt;/strong&gt;开始删除&lt;strong&gt;最短匹配&lt;/strong&gt;的word子符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var##word}&lt;/strong&gt;:返回从${var}&lt;strong&gt;开头&lt;/strong&gt;开始删除&lt;strong&gt;最长匹配&lt;/strong&gt;的word子符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var%word}&lt;/strong&gt;:返回从${var}&lt;strong&gt;结尾&lt;/strong&gt;开始删除&lt;strong&gt;最短匹配&lt;/strong&gt;的word子符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var%%word}&lt;/strong&gt;:返回从${var}&lt;strong&gt;结尾&lt;/strong&gt;开始删除&lt;strong&gt;最长匹配&lt;/strong&gt;的word子符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var/oldstring/newstring}&lt;/strong&gt;:使用newstring替换第一个匹配的字符oldstring&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var//oldstring/newstring}&lt;/strong&gt;:使用newstring替换所有匹配的字符oldstring&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var:-word}&lt;/strong&gt;:如果变量var的值为空或未赋值，则将word做为返回值，常用于防止变量为空或未定义而导致的异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var:=word}&lt;/strong&gt;:如果变量var的值为空或未赋值，则将word赋值给var并返回其值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var:?word}&lt;/strong&gt;:如果变量var的值为空或未赋值，则将word做为标准错误输出，否则则输出变量的值，常用于捕捉因变量未定义而导致的错误并退出程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;${var:+word}&lt;/strong&gt;:如果变量var的值为空或未赋值，则什么都不做，否则word字符将替换变量的值&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;其中${var:-word}、${var:=word}、${var:?word}、${var:+word}中的冒号也可以省略，则将变量为空或未赋值修改为未赋值，去掉了为空的检测， 即运算符仅检测变量是否未赋值&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;变量扩展示例&quot;&gt;变量扩展示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost init.d]# var=&quot;This is test string&quot;
[root@localhost init.d]# echo $var
This is test string
[root@localhost init.d]# echo ${var}
This is test string
[root@localhost init.d]# echo ${#var} # 统计字符长度
19
[root@localhost init.d]# echo ${var:5} # 从第5个位置开始截取字符
is test string
[root@localhost init.d]# echo ${var:5:2} # 从第5个位置开始截取2个字符
is
[root@localhost init.d]# echo ${var#This} # 从开头删除最短匹配的字符 is
is test string
[root@localhost init.d]# echo ${var##This}  # 从开头删除最长匹配的字符 is
is test string
[root@localhost init.d]# echo ${var%g} # 从结尾删除最短匹配的字符 is
This is test strin
[root@localhost init.d]# echo ${var%%g} # 从结尾删除最长匹配的字符 is
This is test strin
[root@localhost init.d]# echo ${var/is/newis} # 替换第一个匹配的字符
Thnewis is test string
[root@localhost init.d]# echo ${var//is/newis} # 替换所有匹配到的字符
Thnewis newis test string

[root@localhost init.d]# echo $centos # 变量未定义

[root@localhost init.d]# echo ${centos:-UNDEFINE} # 变量为空，返回UNDEFINE
UNDEFINE
[root@localhost init.d]# centos=&quot;CentOS&quot;
[root@localhost init.d]# echo ${centos:-UNDEFINE} # 变量已经定义，返回变量本身的值
CentOS
[root@localhost init.d]# unset centos # 取消变量值
[root@localhost init.d]# echo $centos

[root@localhost init.d]# result=${centos:=UNDEFINE}
[root@localhost init.d]# echo $result
UNDEFINE
[root@localhost init.d]# echo $centos # 变量值为空，则将UNDEFINE赋值给centos
UNDEFINE
[root@localhost init.d]# unset centos
[root@localhost init.d]# echo ${centos:?can not find variable centos}

-bash: centos: can not find variable centos  # 变量值为空，输出自定义错误信息

[root@localhost init.d]# centos=&quot;IS DEFINED&quot;
[root@localhost init.d]# echo ${centos:?can not find variable centos}
IS DEFINED               #变量值已定义，则输出变量值
[root@localhost init.d]# unset centos
[root@localhost init.d]# echo ${centos:+do nothing} # 变量值为空，什么都不操作输出

[root@localhost init.d]# centos=&quot;do&quot;
[root@localhost init.d]# echo ${centos:+do nothing}  # 变量已赋值，则输出自定义的消息
do nothing&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 16:09:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>特殊变量     在Shell中的特殊变量主要分别两种 位置参数变量 、 状态变量 两种。 位置参数变量     Shell中的位置参数变量主要是指\$0、\$</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9932841.html</dc:identifier>
</item>
<item>
<title>白话HTTPS - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/9932821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/9932821.html</guid>
<description>&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201811/826860-20181108235633878-1120657050.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;只是在应用层与传输层之间添加了一个SSL层&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HTTPS为什么会安全？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然HTTPS是披着SSL外衣的HTTP，那SSL是什么呢？&lt;/p&gt;
&lt;p&gt;SSL是安全套接字层，是目前比较成熟的提供可靠数据传输的安全协议。SSL可以提供证书认证，数据加密，完整性保护等保护性策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据加密原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSL采用的加密策略是：非对此加密+对称加密的混合加密方式&lt;/p&gt;
&lt;p&gt;对成加密：单纯的对称加密，加密解密的效率高，但是在客户端于服务端共享密钥时，容易被中间劫持泄露，不够安全&lt;/p&gt;
&lt;p&gt;非对称加密：是新一代加密方案，加密解密销量低，但是可以实现密钥的安全传输，想通过公钥解出私钥难道极大，基本不可能。&lt;/p&gt;

&lt;p&gt;最中采用在第一次交换共享密钥时，使用非对称加密。然后用共享密钥加密。这样既避免了密钥被劫持，又保证了效率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据完整性策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用报文摘要的策略，防止报文主题被修改&lt;/p&gt;
&lt;p&gt;在报文发送前，先通过md5-base64加密，得到一个报文主体的摘要，把这个摘要放到请求首部中，等服务器收到信息，采用同样的算法，加密报文主体，根据得到的结果是否和报文摘要一致来判断数据的完整性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SSL和TLS的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前常见的加密协议有两个SSL3.0和TLS1.0，它们之间有什么区别呢？&lt;/p&gt;
&lt;p&gt; SSL（Secure Socket Layer）：是有浏览器开发商网景通信公司发起并开发到了SSL3.0版本&lt;/p&gt;
&lt;p&gt; TLS（Transport Layer Security）：后面主导权移交给了IETF组织，他们在SSL3.0基础上开发了 TLS一系列版本。它们是“父子”关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTPS协议安全通信步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTPS协议安全通信步骤中有三个主角元素：客户端，服务器，第三方可信任的证书颁发机构&lt;/p&gt;
&lt;p&gt;过程如下：&lt;/p&gt;
&lt;p&gt;1.服务器的运维人员向“第三方可信任的证书颁发机构”提供公司的有效信息+公钥。&lt;/p&gt;
&lt;p&gt;2.“第三方可信任的证书颁发机构”认证公司有效，就用“第三方可信任的证书颁发机构”的私钥给服务器的公钥签名，然后创建一个证书，证书中加入了公钥+公钥签名结果，发给服务器。服务器运营人员需要支付一定的费用。&lt;/p&gt;
&lt;p&gt;3.客服端安装浏览器，浏览器内部内置了“第三方可信任的证书颁发机构”的根证书，里面包含了“第三方可信任的证书颁发机构”的公钥信息&lt;/p&gt;
&lt;p&gt;//正式开始SSL通信&lt;/p&gt;
&lt;p&gt;4.客户端发送请求给ClientHello到服务器，请求报文中包含客户端支持的SSL指定版本号，加密组件列表（使用的加密算法和密钥长度）&lt;/p&gt;
&lt;p&gt;5.服务端收到请求后，也回发生个ClientHello回应，里面包含了使用的SSL版本和加密组件（该加密组件是从客户端发生的列表中筛选出来的）&lt;/p&gt;
&lt;p&gt;6.紧接着服务器发生证书报文（Certificate），将服务器申请的公钥证书传给客户端&lt;/p&gt;
&lt;p&gt;7.然后服务器发生一个Server Hello Done报文给客户端，表示初期阶段的SSL握手协商结束。&lt;/p&gt;

&lt;p&gt;8.客户端收到服务器发来的公钥证书后，拿本地存储的第三方机构根证书中的公钥对证书中的签名信息解密，如果解密的结构同证书中的原始服务器公钥信息一样，证明服务器可信。&lt;/p&gt;
&lt;p&gt;9.接着客户端在本地生成一个随机密码字符串。用服务器的公钥加密这个字符串，将得到的结果传递给服务器器。&lt;/p&gt;
&lt;p&gt;10.然后客户端再发送一个Change Cipher Spec报文（修改加密规则说明）给服务器，告诉服务器下面的通信将采用刚才的随机密码字符串作为加密密钥。&lt;/p&gt;
&lt;p&gt;11.最后客户端发生一个Finish报文，报文中包含了从连接到现在所有报文的整体校验码，上面一系列的握手协商是否能最后成功，就看服务器能否正确解密这个Finish报文了。&lt;/p&gt;

&lt;p&gt;12.服务器正确解密后，也发送个Change Cipher Spec报文（修改加密规则说明）给客户端。&lt;/p&gt;
&lt;p&gt;13.最后服务端也发送个Finish报文让客户端解密验证。&lt;/p&gt;

&lt;p&gt;14.等客户端、服务器两者的Finished报文都正常交换后，SSL连接算是正式建立完成。下面的通信就会受到SSL的加密保护。&lt;/p&gt;
&lt;p&gt;15.现在客户端就可以安全的给服务器发送简单的应用层协议（http）了，并得到受保护的响应&lt;/p&gt;

&lt;p&gt;16.最后通讯完成，由客户端发送close_notify报文，通知服务器断开链接。&lt;/p&gt;

</description>
<pubDate>Thu, 08 Nov 2018 16:01:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>HTTPS是传输协议吗？ HTTPS与HTTP有什么关系？ HTTPS为什么会安全？ 闲扯一下 Mac笔记本、Windows台式机、Linux主机。像这三种类型，它们硬件不同，系统不同，服务端处理的编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/9932821.html</dc:identifier>
</item>
<item>
<title>4.1ASP.NET Core请求过程「深入浅出ASP.NET Core系列」 - 张飞洪</title>
<link>http://www.cnblogs.com/jackyfei/p/9927065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfei/p/9927065.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;希望给你3-5分钟的碎片化学习，可能是坐地铁、等公交，积少成多，水滴石穿，谢谢关注。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里展示整体的HTTP请求的过程，这里化繁为简，保留了主干流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201811/127185-20181108230943300-1181581079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从浏览器输入域名开始，这里忽略了建立TCP的3次握手，向服务器发起HTTPRequest请求，服务器接受到之后，会触发服务器对网站的动态解析，然后把生成的网页信息通过HTTPResponse返回给用户，内部包含HTML的Body，Head等信息，最后就是浏览器对这些HTML信息进行内部引擎渲染的过程了。&lt;/p&gt;

&lt;p&gt;ASP.NET Core是整个HTTP请求的一个环节，这个环节都做了哪些工作呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201811/127185-20181108230924796-1722203288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，整个请求流程更加细化，特别是ASP.NET Core Application进行了放大，内部包含很重要的两个组建，一个是Kestrel，一个是管道，而管道不是一个，可以是多个，使用的委托方式，可以无限扩展。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201811/127185-20181108232217281-1292266548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core Applicaton进一步放大，可以了解到，Kestrel其实在这里并没有做真正的核心处理，只是做一层封装为HttpContext，并往下传。真正处理请求的是管道，管道其实就是RequestDelegate，处理完成后封装成HttpContext进行回传，当然，HttpContext内含HttpRequest和HttpResponse。以上只是一个初略的描述，但是作为开发来说，有个初步印象就可以了，再细化下去，已经超过碎片化时间，先打住，如果要继续深究，请关注我后面的专题内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5.4905660377358&quot;&gt;
&lt;p&gt; 我是张飞洪，入行10年有余，人不堪其忧，吾不改其乐，谢谢您关注我的&lt;a href=&quot;http://mp.toutiao.com/preview_article/?pgc_id=6621514934175924744&quot; target=&quot;_blank&quot;&gt;头条号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 08 Nov 2018 15:36:00 +0000</pubDate>
<dc:creator>张飞洪</dc:creator>
<og:description>希望给你3-5分钟的碎片化学习，可能是坐地铁、等公交，积少成多，水滴石穿，谢谢关注。 HTTP请求过程 这里展示整体的HTTP请求的过程，这里化繁为简，保留了主干流程： 从浏览器输入域名开始，这里忽略</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackyfei/p/9927065.html</dc:identifier>
</item>
<item>
<title>【杂谈】Java I/O的底层实现 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9932348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9932348.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java I/O功能封装的很好，使用起来很方便，就是刚开始学的时候，如果不了解装饰器模式，会被他繁多的类给吓到。用多了也就习惯了，而且现在有很多实用的封装良好的实用类，可直接读写整个文件。开发者不知道底层实现细节，也可以灵活使用，这是封装的一大优点。但是，作为一名软件开发人员，对其所使用的代码不能仅仅停留在熟悉功能特性上，最好对其实现原理也要有一定了解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：本文引用了部分外文内容，并根据自己的理解进行了翻译，连接将在文末贴出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; --------------------------------------外文引用内容Begin（已翻译）----------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲处理、内核空间vs用户空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;缓冲，以及如何处理缓冲是所有IO的基本内容。术语&quot;I/O&quot;（输入输出）指的不过就是&lt;span&gt;&lt;strong&gt;从缓冲区移入或移除数据&lt;/strong&gt;&lt;/span&gt;。通常，进程执行I/O操作的方式是，向操作系统发送请求，请求其填充自己的缓冲区（或者把自己缓冲区的内容写出）。这就是I/O这个概念的全部内容。要实现这些传输操作，操作系统底层的实现非常复杂。但是在概念上，本文所要讲述的内容则非常直白。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181108213823896-609313275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注意：User space和Kernel space 都属于内存。内存分为两个区，用户区和系统区（内核区）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上图简要展示了，&lt;span&gt;&lt;strong&gt;块数据&lt;/strong&gt;&lt;/span&gt;如何从外部源头（比如硬盘）移入到进程的内存空间的过程。首先，这个进程通过&lt;strong&gt;系统调用&lt;/strong&gt;read()，请求填充自己的缓冲区。这将导致内核发送一个命令到磁盘控制器，使其从磁盘中抓取数据。磁盘控制器通过DMA把数据直接写入到内核空间缓冲区，这个过程不需要CPU干预。一旦磁盘控制器完成了填充数据的任务，内核就将数据从内核空间的临时缓冲区转移到进程指定的缓冲区内。&lt;/p&gt;
&lt;p&gt;　　有一件事需要注意，&lt;span&gt;&lt;strong&gt;内核会试图缓冲或者说预加载一些数据&lt;/strong&gt;&lt;/span&gt;，所以有可能进程所请求的数据已经在内核空间里了。如果这样的话，进程请求的数据，只需要从内核缓冲区拷贝一份即可。如果数据不在内核空间内，则在内核获取数据到内存的过程中，此进程将被挂起。&lt;/p&gt;
&lt;p&gt;--------------------------------------外文引用内容End（已翻译）-------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上述内容可知：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java的读写操作，底层由C/C++实现。而不是直接与OS接触&lt;/li&gt;
&lt;li&gt;C/C++读写操作，需要OS服务&lt;/li&gt;
&lt;li&gt;内核自带缓冲，会过分加载&lt;/li&gt;
&lt;li&gt;如果内存中没有数据的缓冲，读写操作将阻塞当前线程（OS会帮你挂起线程）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;DMA&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　DMA（Direct Memory Access，直接内存存取）是I/O设备控制方式的一种。我个人认为它们的主要差别在于CPU的参与I/O控制的程度&lt;/p&gt;
&lt;p&gt;I/O设备控制方式有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序I/O方式——CPU需反复检查&lt;/li&gt;
&lt;li&gt;中断I/O方式——每完成一个字节的读写，通知CPU&lt;/li&gt;
&lt;li&gt;DMA方式——每完成一个块(多字节)的读写，通知CPU&lt;/li&gt;
&lt;li&gt;I/O通道方式（暂不了解）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在DMA读写I/O设备的时候，CPU不会被影响，它可以继续执行。注意！这里能继续执行，指的是CPU可以继续运行，而此I/O操作的线程已经被挂起，不参与CPU调度。I/O操作完成后，该线程才被唤醒，参与调度（加入就绪队列，等待时间片）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;系统调用是应用程序间接调用OS函数的方式。C语言有提供与系统调用相对应的库函数。这里就是read、write。&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BufferedXXStream&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　注意，对于Java来说，系统调用的开销是比较大的。首先读写操作要触发的是本地方法read0，readBytes，write0，writeBytes，这里JNI需要一定开销。还有就是每产生一个系统调用，就可能产生上千个机器指令，这种开销是不容小觑的。所以，我们要尝试减少系统调用。那有人就会问了，不行啊，我数据又不能缺斤少两，少读少写肯定出问题，怎么减少调用？这不是很好解决吗，每次多读写一点，调用的次数不就少了嘛。而BufferedXXStream就是这么用的，例如，BufferedInputStream的read无参方法只读取一个字节，而实际上BufferedInputStream默认读取了8kb，这些数据用字节数组保留。&lt;/p&gt;
&lt;p&gt; 　    对了，如果对上图，不是很理解，可以看看这张。&lt;/p&gt;
&lt;p&gt;　　 即运行时，有一个对象BufferedInputStream，其调用一次read()方法，数据保留到buf数组中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181108232129731-1245975992.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;entry-title&quot;&gt;&lt;a href=&quot;https://howtodoinjava.com/java/io/how-java-io-works-internally-at-lower-level/&quot; target=&quot;_blank&quot;&gt;How Java I/O Works Internally at Lower Level?&lt;/a&gt;（需FQ）&lt;/p&gt;
</description>
<pubDate>Thu, 08 Nov 2018 15:31:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 Java I/O功能封装的很好，使用起来很方便，就是刚开始学的时候，如果不了解装饰器模式，会被他繁多的类给吓到。用多了也就习惯了，而且现在有很多实用的封装良好的实用类，可直接读写整个文件。开发者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9932348.html</dc:identifier>
</item>
<item>
<title>java集合之LinkedList - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/9932657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/9932657.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: java集合之LinkedList&lt;br/&gt;tags: java集合&lt;br/&gt;author: 辰砂&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。&lt;/p&gt;
&lt;p&gt;注意，此实现不是同步的。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法来“包装”该列表。最好在创建时完成这一操作，以防止对列表进行意外的不同步访问，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; List list = Collections.synchronizedList(new LinkedList(...));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230257810-2085537773.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LinkedList&amp;lt;E&amp;gt;
    extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。&lt;/p&gt;
&lt;p&gt;LinkedList 实现 List 接口，能对它进行队列操作。&lt;/p&gt;
&lt;p&gt;LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。&lt;/p&gt;
&lt;p&gt;LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。&lt;/p&gt;
&lt;p&gt;LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。&lt;/p&gt;
&lt;p&gt;LinkedList 是非同步的&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二.linkedlist的用法-参考优秀博文&quot;&gt;二.LinkedList的用法 (参考优秀博文)&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class LinkedListTest {
    public static void main(String[] args) {
        // 测试LinkedList的API
        testLinkedListAPIs() ;

        // 将LinkedList当作 LIFO(后进先出)的堆栈
        useLinkedListAsLIFO();

        // 将LinkedList当作 FIFO(先进先出)的队列
        useLinkedListAsFIFO();
    }

    /*
     * 测试LinkedList中部分API
     */
    private static void testLinkedListAPIs() {
        String val = null;
        //LinkedList llist;
        //llist.offer(&quot;10&quot;);
        // 新建一个LinkedList
        LinkedList llist = new LinkedList();
        //---- 添加操作 ----
        // 依次添加1,2,3
        llist.add(&quot;1&quot;);
        llist.add(&quot;2&quot;);
        llist.add(&quot;3&quot;);

        // 将“4”添加到第一个位置
        llist.add(1, &quot;4&quot;);


        System.out.println(&quot;\nTest \&quot;addFirst(), removeFirst(), getFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  失败的话，抛出异常！
        llist.addFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeFirst():&quot;+llist.removeFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getFirst():&quot;+llist.getFirst());


        System.out.println(&quot;\nTest \&quot;offerFirst(), pollFirst(), peekFirst()\&quot;&quot;);
        // (01) 将“10”添加到第一个位置。  返回true。
        llist.offerFirst(&quot;10&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollFirst():&quot;+llist.pollFirst());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekFirst():&quot;+llist.peekFirst());


        System.out.println(&quot;\nTest \&quot;addLast(), removeLast(), getLast()\&quot;&quot;);
        // (01) 将“20”添加到最后一个位置。  失败的话，抛出异常！
        llist.addLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将最后一个元素删除。        失败的话，抛出异常！
        System.out.println(&quot;llist.removeLast():&quot;+llist.removeLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取最后一个元素。          失败的话，抛出异常！
        System.out.println(&quot;llist.getLast():&quot;+llist.getLast());


        System.out.println(&quot;\nTest \&quot;offerLast(), pollLast(), peekLast()\&quot;&quot;);
        // (01) 将“20”添加到第一个位置。  返回true。
        llist.offerLast(&quot;20&quot;);
        System.out.println(&quot;llist:&quot;+llist);
        // (02) 将第一个元素删除。        失败的话，返回null。
        System.out.println(&quot;llist.pollLast():&quot;+llist.pollLast());
        System.out.println(&quot;llist:&quot;+llist);
        // (03) 获取第一个元素。          失败的话，返回null。
        System.out.println(&quot;llist.peekLast():&quot;+llist.peekLast());



        // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！
        llist.set(2, &quot;300&quot;);
        // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！
        System.out.println(&quot;\nget(3):&quot;+llist.get(2));


        // ---- toArray(T[] a) ----
        // 将LinkedList转行为数组
        String[] arr = (String[])llist.toArray(new String[0]);
        for(String str:arr) {
            System.out.println(&quot;str:&quot;+str);
        }

        // 输出大小
        System.out.println(&quot;size:&quot;+llist.size());
        // 清空LinkedList
        llist.clear();
        // 判断LinkedList是否为空
        System.out.println(&quot;isEmpty():&quot;+llist.isEmpty()+&quot;\n&quot;);

    }

    /**
     * 将LinkedList当作 LIFO(后进先出)的堆栈
     */
    private static void useLinkedListAsLIFO() {
        System.out.println(&quot;\nuseLinkedListAsLIFO&quot;);
        // 新建一个LinkedList
        LinkedList stack = new LinkedList();

        // 将1,2,3,4添加到堆栈中
        stack.push(&quot;1&quot;);
        stack.push(&quot;2&quot;);
        stack.push(&quot;3&quot;);
        stack.push(&quot;4&quot;);
        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);

        // 删除“栈顶元素”
        System.out.println(&quot;stack.pop():&quot;+stack.pop());

        // 取出“栈顶元素”
        System.out.println(&quot;stack.peek():&quot;+stack.peek());

        // 打印“栈”
        System.out.println(&quot;stack:&quot;+stack);
    }

    /**
     * 将LinkedList当作 FIFO(先进先出)的队列
     */
    private static void useLinkedListAsFIFO() {
        System.out.println(&quot;\nuseLinkedListAsFIFO&quot;);
        // 新建一个LinkedList
        LinkedList queue = new LinkedList();

        // 将10,20,30,40添加到队列。每次都是插入到末尾
        queue.add(&quot;10&quot;);
        queue.add(&quot;20&quot;);
        queue.add(&quot;30&quot;);
        queue.add(&quot;40&quot;);
        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);

        // 删除(队列的第一个元素)
        System.out.println(&quot;queue.remove():&quot;+queue.remove());

        // 读取(队列的第一个元素)
        System.out.println(&quot;queue.element():&quot;+queue.element());

        // 打印“队列”
        System.out.println(&quot;queue:&quot;+queue);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.源码解读&quot;&gt;三.源码解读&lt;/h2&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;1.数据结构&lt;/h3&gt;
&lt;p&gt;LinkedList 是一个双向链表。内部类 Node 是 LinkedList 中的基本数据结构，包含当前节点值，上一个节点得引用，和下个节点的引用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 链表中有多少个节点，默认为 0    
transient int size = 0;
// 头节点
transient Node&amp;lt;E&amp;gt; first;
// 尾节点
transient Node&amp;lt;E&amp;gt; last;
    private static class Node&amp;lt;E&amp;gt; {
        E item;
        Node&amp;lt;E&amp;gt; next;
        Node&amp;lt;E&amp;gt; prev;
        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230334351-2123075201.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造方法&quot;&gt;2.构造方法&lt;/h3&gt;
&lt;p&gt;比较简单，默认无参构造，和一个 Collection 参数的构造（ 将里面元素按顺序前后连接，修改节点个数，并且操作次数 + 1 ）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public LinkedList() {
    }

    /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param  c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {
        this();
        addAll(c);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加方法add&quot;&gt;3.添加方法ADD&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 尾部插入
public boolean add(E e) {
    // 去为节点加
    linkLast(e);
    return true;
}
// 将指定的元素防止在链表的尾节点，以前的尾节点变成它前面的节点，如果上个尾节点为null，说明以前是的空链表。
void linkLast(E e) {
    final Node&amp;lt;E&amp;gt; l = last;
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
 // 添加一个，我们就需要把size增加
    size++;
    modCount++;
}
add(int index, E element)
  public void add(int index, E element) {
  // 边界校验
      checkPositionIndex(index);
      if (index == size)
          linkLast(element);
      else
          linkBefore(element, node(index));
  }
  /**
   * Returns the (non-null) Node at the specified element index.
   */
  Node&amp;lt;E&amp;gt; node(int index) {
      // assert isElementIndex(index);
// 双链表可以分别从 头节点 或者尾节点开始遍历，计算它是在前面一半，还是在后面的位置，决定遍历方式。
// 这也是LinkedList 为什么要使用双向链表，提升了使用游标操作链表的效率。
      if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
          Node&amp;lt;E&amp;gt; x = first;
          for (int i = 0; i &amp;lt; index; i++)
              x = x.next;
          return x;
      } else {
          Node&amp;lt;E&amp;gt; x = last;
          for (int i = size - 1; i &amp;gt; index; i--)
              x = x.prev;
          return x;
      }
  }
  /**
   * Inserts element e before non-null Node succ.
   */
  void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
      // assert succ != null;
      final Node&amp;lt;E&amp;gt; pred = succ.prev;
      final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
      succ.prev = newNode;
      if (pred == null)
          first = newNode;
      else
          pred.next = newNode;
      size++;
      modCount++;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查索引是否越界，虽然 ListedList 中没有索引概念；&lt;br/&gt;如果 index 和 size 相同，则在尾节点上加上元素；&lt;br/&gt;不相同的话，先去遍历链表查找到索引位置的节点，然后在它的前面插入节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230403582-1035346423.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 1.s-&amp;gt;prior=p-&amp;gt;prior;
 2. p-&amp;gt;prior-&amp;gt;next=s;
 3. s-&amp;gt;next=p;
 4. p-&amp;gt;prior=s;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取元素get&quot;&gt;4.获取元素Get&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E get(int index) {  
// 检查索引越界；
// 跟上面的一样，查找该索引位置的节点，然后获取它的元素。
    checkElementIndex(index);  
    return node(index).item;  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除元素remove&quot;&gt;5.删除元素Remove&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   public E remove() {
       return removeFirst();
   }
   // 移除头节点
   public E removeFirst() {
       final Node&amp;lt;E&amp;gt; f = first;
       if (f == null)
           throw new NoSuchElementException();
       return unlinkFirst(f);
   }
   // 参数 f 为头节点
// 将头节点指向 next 节点，如果 next节点 为 null 则链表 为 null ，链表大小减 1 ，修改次数记录加 1.
   private E unlinkFirst(Node&amp;lt;E&amp;gt; f) {
       // assert f == first &amp;amp;&amp;amp; f != null;
       final E element = f.item;
       final Node&amp;lt;E&amp;gt; next = f.next;
       f.item = null;
       f.next = null; // help GC
       first = next;
       if (next == null)
           last = null;
       else
           next.prev = null;
       size--;
       modCount++;
       return element;
   }
public E remove(int index) {  
    checkElementIndex(index);  
    return unlink(node(index));  
}  
    /**
     * Unlinks non-null node x.
     */
    E unlink(Node&amp;lt;E&amp;gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&amp;lt;E&amp;gt; next = x.next;
        final Node&amp;lt;E&amp;gt; prev = x.prev;
        // 如果本节点为头节点，头节点指向next
        if (prev == null) {
            first = next;
        } else {
            // 不是头节点，则将前节点和后节点连接起来，然后删掉本节点的引用 GC
            prev.next = next;
            x.prev = null;
        }
        // 如果是尾节点，则将尾节点指向前节点
        if (next == null) {
            last = prev;
        } else {
            // 连接，双向链表，双方都有引用，删除自身的引用GC
            next.prev = prev;
            x.next = null;
        }
        // 删除自身 GC
        x.item = null;
        size--;
        modCount++;
        return element;
    }

// 遍历 equals 找出 node，然后调用 unlink(Node&amp;lt;E&amp;gt; x)   
public boolean remove(Object o) {
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201811/1513801-20181108230420521-947719206.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新元素set&quot;&gt;6.更新元素Set&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
*有索引，第一件事去检查索引是否越界；根据索引找出 node；
*替换 node 的元素，返回 该索引位置 Node 的旧元素的值。
*注意，Set 方法不增加LinkedList 的修改次数
*/
public E set(int index, E element) {
    checkElementIndex(index);
    Node&amp;lt;E&amp;gt; x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;清空clear&quot;&gt;7.清空clear()&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//释放所有的元素，让他们直接无引用，垃圾回收器发现这些 node 元素是不可达的时候，释放内存。
// 数据恢复默认；修改次数记录加一。
public void clear() {  
       // Clearing all of the links between nodes is &quot;unnecessary&quot;, but:  
       // - helps a generational GC if the discarded nodes inhabit  
       //   more than one generation  
       // - is sure to free memory even if there is a reachable Iterator  
       for (Node&amp;lt;E&amp;gt; x = first; x != null; ) {  
           Node&amp;lt;E&amp;gt; next = x.next;  
           x.item = null;  
           x.next = null;  
           x.prev = null;  
           x = next;  
       }  
       first = last = null;  
       size = 0;  
       modCount++;  
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四arraylist和linkedlist比较&quot;&gt;四、ArrayList和LinkedList比较&lt;/h2&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于随机访问，ArrayList优于LinkedList&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于插入和删除操作，LinkedList优于ArrayList&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;https://blog.wuwii.com/java-linkedlist.html#more&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/skywang12345/p/3308807.html&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 08 Nov 2018 15:06:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>title: java集合之LinkedList tags: java集合 author: 辰砂 一. LinkedList概述： List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/9932657.html</dc:identifier>
</item>
</channel>
</rss>