<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python全栈工程师（异常（高级）、运算符重载） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9380227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9380227.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;ParisGabriel&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;Python人工智能从入门到精通&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;对象的属性管理函数:&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;getattr(&lt;/strong&gt;&lt;/span&gt;obj, name[,default)&lt;br/&gt;　　　　从对象&lt;strong&gt;得到对象&lt;/strong&gt;的&lt;strong&gt;属性&lt;/strong&gt;，getattr（x， “y”） 等同于x， y &lt;strong&gt;当&lt;/strong&gt;属性&lt;br/&gt;　　　　&lt;strong&gt;不存在时&lt;/strong&gt; 如果&lt;strong&gt;给&lt;/strong&gt;出&lt;strong&gt;default&lt;/strong&gt;参数则&lt;strong&gt;返回default&lt;/strong&gt;&lt;br/&gt;　　　　如果&lt;strong&gt;没&lt;/strong&gt;有&lt;strong&gt;给出default&lt;/strong&gt; ，&lt;strong&gt;则&lt;/strong&gt;产生一个&lt;strong&gt;AttributeError错误&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;hasattr&lt;/span&gt;&lt;/strong&gt;（obj， name）用&lt;strong&gt;给定&lt;/strong&gt;的&lt;strong&gt;name返回&lt;/strong&gt;对象obj&lt;strong&gt;是否有此属性&lt;/strong&gt;&lt;br/&gt;　　　　此种做法可以&lt;strong&gt;避免&lt;/strong&gt;在&lt;strong&gt;getattr&lt;/strong&gt;（obj，name）时引发&lt;strong&gt;错误&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;setattr&lt;/strong&gt;&lt;/span&gt;(obj, name, value) &lt;strong&gt;给&lt;/strong&gt;对象obj的名为name的&lt;br/&gt;　　　　&lt;strong&gt;属性设置相应的值&lt;/strong&gt;value, set(x, 'y', v) 等同于 x.y = v&lt;/p&gt;&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;delattr&lt;/strong&gt;&lt;/span&gt;(obj, name) &lt;strong&gt;删除&lt;/strong&gt;对象obj中的name&lt;strong&gt;属性&lt;/strong&gt;&lt;br/&gt;,　　　　 delattr(x, 'y') 等同于 del x.y&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;


d &lt;/span&gt;=&lt;span&gt; Dog()
d.color &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;白色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

v &lt;/span&gt;= getattr(d, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于 v = d.color&lt;/span&gt;
v = getattr(d, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出错,没有d.kinds属性&lt;/span&gt;
v = getattr(d, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这个属性&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; v= '没有这个属性'&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
setattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;京巴&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于d.kinds ='京巴'&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
delattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于 del d.kinds&lt;/span&gt;
hasattr(d, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kinds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异常（高级）：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;可以用于异常的语句&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;&lt;span&gt;try-except&lt;/span&gt;&lt;/strong&gt; # &lt;strong&gt;捕获异常&lt;/strong&gt;，得到通知&lt;br/&gt;　　　　&lt;strong&gt;&lt;span&gt;try-finally&lt;/span&gt;&lt;/strong&gt; # 左任何流程（正常/异常）都必须&lt;strong&gt;执行要执行的语句&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;raise&lt;/strong&gt;&lt;/span&gt; # &lt;strong&gt;发送异常&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;&lt;strong&gt;assert&lt;/strong&gt;&lt;/span&gt; # 根据条件&lt;strong&gt;发送异常&lt;/strong&gt;通知&lt;br/&gt;&lt;strong&gt;&lt;span&gt;with&lt;/span&gt; 语句：&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;语法&lt;/strong&gt;：&lt;br/&gt;　　　　with 表达式1[as 变量1]， 表达式2[as 变量2]....&lt;br/&gt;　　&lt;strong&gt;作用&lt;/strong&gt;：&lt;br/&gt;　　　　使用与对资源进行访问的场合，确保使用过程中&lt;strong&gt;不管&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;是否&lt;/strong&gt;发生&lt;strong&gt;异常都会执行&lt;/strong&gt;必要的&lt;span&gt;&lt;strong&gt;“清理操作”&lt;/strong&gt;&lt;/span&gt;，并&lt;strong&gt;释放资源&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;（如： 文件使用后自动关闭，线程中锁的自动获取和释放等）&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;说明&lt;/strong&gt;：&lt;br/&gt;　　　　执行表达式，&lt;span&gt;as&lt;/span&gt;子句中的&lt;strong&gt;变量绑定生成的对象&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;with语句&lt;/strong&gt;并&lt;strong&gt;不改变异常&lt;/strong&gt;的状态&lt;br/&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; with语句打开文件和自动关闭&lt;/span&gt;


&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
            int(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 出现异常&lt;/span&gt;
&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件打开失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件操作过程中错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; try-finally语句打开文件和关闭&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(x)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开文件失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件操作过程中错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
    f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改原来的copy文件功能&lt;/span&gt;
&lt;span&gt;
src_filename &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入源文件路径名: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
dst_filename &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入目标文件路径名: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    with open(src_filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as src,\
            open(dst_filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) as dst:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开源文件用来读数据&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                    b &lt;/span&gt;= src.read(4096&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; b:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 已经再也读不到数据了&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
                    dst.write(b)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;复制成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;复制失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;环境管理器：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;类内有&lt;span&gt;__enter__&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;__exit__&lt;/span&gt;&lt;/strong&gt;实例&lt;strong&gt;方法&lt;/strong&gt;的类&lt;strong&gt;被称为环境管理器&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;能&lt;/strong&gt;够用&lt;span&gt;&lt;strong&gt;with&lt;/strong&gt;&lt;/span&gt;进行&lt;strong&gt;管理的&lt;/strong&gt;对象&lt;strong&gt;必须是环境管理器&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;说明：&lt;/strong&gt;&lt;br/&gt;　　　　&lt;span&gt;__enter__&lt;/span&gt;将在&lt;strong&gt;进入with语句时被调&lt;/strong&gt;用并返回由as变量绑定的对象&lt;br/&gt;　　　　&lt;span&gt;__exit__&lt;/span&gt;将在&lt;strong&gt;离开with语句时被调用&lt;/strong&gt;，且&lt;strong&gt;可以用参数来判断&lt;/strong&gt;在&lt;br/&gt;　　　　&lt;strong&gt;离开&lt;/strong&gt;with语句&lt;strong&gt;时是否有异常&lt;/strong&gt;发生&lt;strong&gt;并&lt;/strong&gt;作出相应的&lt;strong&gt;处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个自定义的类创建的对象能够使用ｗｉｔｈ语句&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;此类的对象可用于ｗｉｔｈ语句进行管理&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__enter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经进入ｗｉｔｈ语句中，资源分配成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;&amp;lt;&amp;lt;-- 此处返回的对象将由as变量绑定&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__exit__&lt;/span&gt;&lt;span&gt;(self, exc_type, exc_val, exc_tb):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;离开ｗｉｔｈ语句,资源释放成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; exc_type &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当离开ｗｉｔｈ语句时没有异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;有异常发生　异常类型：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,exc_type , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;异常值：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  exc_val)


with A() as a:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是ｗｉｔｈ语句中的语句&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;故意制造的异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;运算符重载：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　&lt;strong&gt;什么是运算符重载&lt;/strong&gt;&lt;br/&gt;　　　　&lt;strong&gt;让自定义的类生成的对象（实例）能够使用运算符进行操作&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;作用：&lt;/strong&gt;&lt;br/&gt;　　　　1.让&lt;span&gt;自定义&lt;/span&gt;的类的实例&lt;span&gt;能&lt;/span&gt;够运行&lt;span&gt;运算符操作&lt;/span&gt;&lt;br/&gt;　　　　2.让程序简洁易读&lt;br/&gt;　　　　3.对定义对象&lt;strong&gt;将运算符赋予新的运算规则&lt;/strong&gt;&lt;br/&gt;　&lt;strong&gt;　说明：&lt;/strong&gt;&lt;br/&gt;　　　　运算符重载方法的参数已经有固定含义，不建议改变原有的含义&lt;br/&gt;　　　　算数运算符重载：&lt;/p&gt;&lt;p&gt;方法名 　　　　　　 　　　　 运算符和表达式 　　　　　　 说明&lt;br/&gt;&lt;span&gt;__add__&lt;/span&gt;(self, rhs) 　　 　　　　  self + rsh 　　　　　　　　 加法&lt;br/&gt;&lt;span&gt;__sub__&lt;/span&gt;(self, rhs) 　　　　　　   self - rsh 　　　　　　　　  减法&lt;br/&gt;&lt;span&gt;__mul__&lt;/span&gt;(self, rhs) 　　　　　　   self * rsh 　　　　　　　　  乘法&lt;br/&gt;&lt;span&gt;__truediv__&lt;/span&gt;(self, rhs) 　　　　     self / rsh 　　　　　　　　   除法&lt;br/&gt;&lt;span&gt;__floordiv__&lt;/span&gt;(self, rhs) 　　　　     self // rsh 　　　　　　        地板除&lt;br/&gt;&lt;span&gt;__mod__&lt;/span&gt;(self, rhs) 　　　　　　  self % rsh 　　　　　　　    求模&lt;br/&gt;&lt;span&gt;__pow__&lt;/span&gt;(self, rhs) 　　　　          self ** rsh 　　　　　　　　  幂&lt;/p&gt;
&lt;p&gt;rhs（self hand side） &lt;span&gt;右手边&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyNumber:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, val):
        self.data &lt;/span&gt;=&lt;span&gt; val

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self, rsh):
        v &lt;/span&gt;= self.data +&lt;span&gt; rsh.data
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; MyNumber(v)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;&lt;span&gt;(self, rsh):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyNumber(self.data -&lt;span&gt; rsh.data)


n1 &lt;/span&gt;= MyNumber(100&lt;span&gt;)
n2 &lt;/span&gt;= MyNumber(200&lt;span&gt;)
n3 &lt;/span&gt;= n1 + n2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于　n3 = n1.__add__(n2)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; n3 = n1.__add__(n2)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(t(n1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, n1 - n2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;反向算术运算符的重载&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;当&lt;/strong&gt;运算符的&lt;strong&gt;左侧为内建类型,右侧为自义类型&lt;/strong&gt;的对象&lt;strong&gt;进行算术运算&lt;/strong&gt;符运算&lt;strong&gt;时&lt;/strong&gt;,&lt;strong&gt;会出现&lt;span&gt;TypeError&lt;/span&gt;错误,&lt;/strong&gt;&lt;br/&gt;　　因&lt;strong&gt;无法修改内建类&lt;/strong&gt;的代码来实现运算符重载,&lt;strong&gt;此时需要使用反向&lt;/strong&gt;算术运算符&lt;strong&gt;重载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反向算术运算符重载&lt;br/&gt;方法名 　　　　　　　　　　 运算符和表达式                         说明&lt;br/&gt;&lt;span&gt;__radd__&lt;/span&gt;(self, lhs) 　　　　　　 lhs + self 　　　　　　　 　 加法&lt;br/&gt;&lt;span&gt;__rsub__&lt;/span&gt;(self, lhs) 　　　　　　 lhs - self 　　　　　　　  　 减法&lt;br/&gt;&lt;span&gt;__rmul__&lt;/span&gt;(self, lhs)　　　　　　  lhs * self　　　　　　　   　 乘法&lt;br/&gt;&lt;span&gt;__rtruediv__&lt;/span&gt;(self, lhs)　　　　　lhs / self 　　　　　　  　 　 除法&lt;br/&gt;&lt;span&gt;__rfloordiv__&lt;/span&gt;(self, lhs)　　　　   lhs // self　　　　　　 　  　 地板除&lt;br/&gt;&lt;span&gt;__rmod__&lt;/span&gt;(self, lhs) 　　　　       lhs % self 　　　　　　        取模(求余)&lt;br/&gt;&lt;span&gt;__rpow__&lt;/span&gt;(self, lhs)　　　　　    lhs ** self 　　　　　　　  　 幂&lt;/p&gt;
&lt;p&gt;lhs(left hand side) 右手边&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意返向算述运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.beta &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.bata = list(lst)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__mul__&lt;/span&gt;&lt;span&gt;(self, rhs):

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList(self.beta *&lt;span&gt; rhs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__mul__　被到调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__rmul__&lt;/span&gt;&lt;span&gt;(self, lhs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__rmul__　被到调用&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList(self.beta * lhs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向传参&lt;/span&gt;
&lt;span&gt;

L1 &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])
L2 &lt;/span&gt;= MyList(range(4, 7&lt;span&gt;))
L3 &lt;/span&gt;= 2 * L1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; L1.__rmul__(2)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(L3)

L5 &lt;/span&gt;= L1 * 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; L5 = L1.__mul__(2)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(L5)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, 1, 2, 3])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复合赋值算术运算符的重载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　以&lt;strong&gt;复合赋值&lt;/strong&gt;算术运算符 x += y 为例,此运算会&lt;strong&gt;优先调用x.&lt;span&gt;__iadd__&lt;/span&gt;(y) 方法&lt;/strong&gt;,&lt;br/&gt;　　如果&lt;strong&gt;&lt;span&gt;没有&lt;/span&gt;__iadd__&lt;/strong&gt;方法&lt;strong&gt;时会&lt;/strong&gt;将复合赋值运算&lt;strong&gt;拆解为 x = x + y&lt;/strong&gt;,然后&lt;strong&gt;调用x = x.&lt;span&gt;__add__&lt;/span&gt;(y)&lt;/strong&gt; 方法&lt;br/&gt;　　如果再&lt;strong&gt;不存在 &lt;span&gt;__add__&lt;/span&gt;&lt;/strong&gt;方法则会触发&lt;strong&gt;&lt;span&gt;TypeError&lt;/span&gt;异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其它复合赋值运算符也具有相同的规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;复合赋值算术运算符重载&lt;br/&gt;　　方法名　　　　　　　　　 运算符和表达式 　　　　　　 说明&lt;br/&gt;&lt;span&gt;__iadd__&lt;/span&gt;(self, lhs)　　　　　　 lhs += self 　　　　　　　　 加法&lt;br/&gt;&lt;span&gt;__isub__&lt;/span&gt;(self, lhs) 　　　　　　 lhs -= self 　　　　　　　　 减法&lt;br/&gt;&lt;span&gt;__imul__&lt;/span&gt;(self, lhs) 　　　　　　 lhs *= self 　　　　　　　　 乘法&lt;br/&gt;&lt;span&gt;__itruediv__&lt;/span&gt;(self,lhs) 　　　　　lhs /= self 　　　　　　　　  除法&lt;br/&gt;&lt;span&gt;__ifloordiv__&lt;/span&gt;(self, lhs)　　　　   lhs //= self 　　　　　　　　 地板除&lt;br/&gt;&lt;span&gt;__imod__&lt;/span&gt;(self, lhs)　　　　　　lhs %= self　　　　　　 　　 取模(求余)&lt;br/&gt;&lt;span&gt;__ipow__&lt;/span&gt;(self, lhs) 　　　　　　lhs **= self　　　　　　　　 幂&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.beta = [x for x in lst]&lt;/span&gt;
        self.bata =&lt;span&gt; list(lst)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iadd__&lt;/span&gt;&lt;span&gt;(self, rhs):
        self.beta &lt;/span&gt;+= rhs.beta  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; id不变&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;&lt;span&gt;(self, rhs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList(self.beta + rhs.beta)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; id会不变&lt;/span&gt;
&lt;span&gt;

L &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(lst):
    lst &lt;/span&gt;+= MyList([4, 5, 6&lt;span&gt;])


f1(L)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;复合赋值算术运算符重载&lt;br/&gt;　　方法名 　　　　　　　　　　 运算符和表达式 　　　　 　　 说明&lt;br/&gt;&lt;span&gt;__lt__&lt;/span&gt;(self, rhs) 　　　　　　　　   self &amp;lt; rhs 　　　　　       　   小于&lt;br/&gt;&lt;span&gt;__le__&lt;/span&gt;(self, rhs) 　　　　　　　　  self &amp;lt;= rhs 　　　　　      　  小于等于&lt;br/&gt;&lt;span&gt;__gt__&lt;/span&gt;(self, rhs) 　　　　　　　　  self &amp;gt; rhs 　　　　　　　  　 大于&lt;br/&gt;&lt;span&gt;__ge__&lt;/span&gt;(self, rhs) 　　　　　　　　 self &amp;gt;= rhs 　　　　　　        大于等于&lt;br/&gt;&lt;span&gt;__eq__&lt;/span&gt;(self, rhs) 　　　　　　　　 self == rhs 　　　　　　        等于&lt;br/&gt;&lt;span&gt;__ne__&lt;/span&gt;(self, rhs) 　　　　　　　　 self != rhs 　　　　　　         不等于&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意比较运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;=&lt;span&gt; list(iterable)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__eq__&lt;/span&gt;&lt;span&gt;(self, rhs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.data ==&lt;span&gt; rhs.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__gt__&lt;/span&gt;&lt;span&gt;(self, rhs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.data &amp;gt;&lt;span&gt; rhs.data


L1 &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])
L2 &lt;/span&gt;= MyList([1, 2, 3&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L1 == L2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; True&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(L1 &amp;gt; L2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; False&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(L1 == L2)  # 如果没有__eq__　方法判断两个对象的id&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(L1 &amp;gt; L2)  # 如果没有__gt__　方法报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;位运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__invert__(self) ~ self 取反(一元运算符)&lt;br/&gt;__and__(self, rhs) self &amp;amp; rhs 位与&lt;br/&gt;__or__(self, rhs) self | rhs 位或&lt;br/&gt;__xor__(self, rhs) self ^ rhs 位异或&lt;br/&gt;__lshift__(self, rhs) self &amp;lt;&amp;lt; rhs 左移&lt;br/&gt;__rshift__(self, rhs) self &amp;gt;&amp;gt; rhs 右移&lt;/p&gt;
&lt;p&gt;反向位运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__rand__(self, lhs) lhs &amp;amp; self 位与&lt;br/&gt;__ror__(self, lhs) lhs | self 位或&lt;br/&gt;__rxor__(self, lhs) lhs ^ self 位异或&lt;br/&gt;__rlshift__(self, lhs) lhs &amp;lt;&amp;lt; self 左移&lt;br/&gt;__rrshift__(self, lhs) lhs &amp;gt;&amp;gt; self 右移&lt;/p&gt;
&lt;p&gt;复合赋值位运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__iand__(self, rhs) self &amp;amp;= rhs 位与&lt;br/&gt;__ior__(self, rhs) self |= rhs 位或&lt;br/&gt;__ixor__(self, rhs) self ^= rhs 位异或&lt;br/&gt;__ilshift__(self, rhs) self &amp;lt;&amp;lt;= rhs 左移&lt;br/&gt;__irshift__(self, rhs) self &amp;gt;&amp;gt;= rhs 右移&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;一元运算符重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__invert__(self) ~ self 取反(一元运算符)&lt;br/&gt;__pos__(self) + self 正号&lt;br/&gt;__neg__(self) - self 负号&lt;/p&gt;
&lt;p&gt;语法:&lt;br/&gt;def __xxx__(self):&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意一元运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.beta &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.bata = list(lst)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__neg__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList((-x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.beta))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__pos__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyList((abs(x) &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.beta))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; L = []&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for x in self.beta:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     if x &amp;gt; 0:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         L.append(x)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     else:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         L.append(-x)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return MyList(L)&lt;/span&gt;
&lt;span&gt;

L1 &lt;/span&gt;= MyList([1, -2, 3, -4, 5&lt;span&gt;])
L2 &lt;/span&gt;= -&lt;span&gt;L1
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([-1, 2, -3, 4, -5])&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实现用正号运算符返回全部元素为正数的自定义列表&lt;/span&gt;
L3 = +&lt;span&gt; L1
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L3)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, 4, 5])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;in / not in 运算符重载&lt;br/&gt;重载方法:&lt;br/&gt;def __contains__(self, e):&lt;br/&gt;....&lt;br/&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; in  not in 重载&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, lst=&lt;span&gt;[]):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;在初始化方法内为每个对象都创建一个bata属性
        　　　bata 用来绑定每个对象自己的列表
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        self.beta &lt;/span&gt;= [x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.bata = list(lst)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.beta

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__contains__&lt;/span&gt;&lt;span&gt;(self, e):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.beta


L1 &lt;/span&gt;= MyList([1, 2, -3, 4, -5&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(3 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(4 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; L1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(5 &lt;span&gt;in&lt;/span&gt; L1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;索引和切片运算符的重载&lt;br/&gt;方法名 运算符和表达式 说明&lt;br/&gt;__getitem__(self, i) x = self[i] 索引/切片取值&lt;br/&gt;__setitem__(self, i, val) self[i] = val 索引/切片赋值&lt;br/&gt;__delitem__(self, i) del self[i] 删除索引/切片&lt;/p&gt;
&lt;p&gt;作用:&lt;br/&gt;让自定义的类的对象能够支持索引和切片操作&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意 索引/切片 运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;=&lt;span&gt; list(iterable)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;索引i的值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data[i]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, i, v):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__setitem__被调用, i=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, v)
        self.data[i] &lt;/span&gt;=&lt;span&gt; v

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.data[i]


L1 &lt;/span&gt;= MyList([1, -2, 3, -4, 5&lt;span&gt;])
v &lt;/span&gt;= L1[2]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; v = 3&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(v)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
L1[1] = 2
&lt;span&gt;print&lt;/span&gt;(L1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, -4, 5])&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; L1[3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; MyList([1, 2, 3, 5])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;slice 函数:&lt;br/&gt;作用:&lt;br/&gt;用于创建一个slice切片对象,此对象存储切片的信息&lt;br/&gt;格式:&lt;br/&gt;slice(start=None, stop=None, step=None)&lt;br/&gt;slice对象的属性&lt;br/&gt;s.start 切片的起始值, 默认为None&lt;br/&gt;s.stop 切片的终止值, 默认为None&lt;br/&gt;s.step 切片的步长, 默认为None&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此示例示意 索引/切片 运算符的重载&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, iterable):
        self.data &lt;/span&gt;=&lt;span&gt; list(iterable)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyList(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.data

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;索引i的值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(i) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; int:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在进行索引操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; type(i) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; slice:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在进行切片操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;起始值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i.start)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;终止值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i.stop)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;步长值是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i.step)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.data[i]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, i, v):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__setitem__被调用, i=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, v)
        self.data[i] &lt;/span&gt;=&lt;span&gt; v

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, i):
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.data[i]


L1 &lt;/span&gt;= MyList([1, -2, 3, -4, 5&lt;span&gt;])
L2 &lt;/span&gt;= L1[::2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(L2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特性属性 @property&lt;br/&gt;实现其它语言所拥有的 getter 和 setter 的功能&lt;/p&gt;
&lt;p&gt;作用:&lt;br/&gt;用来模拟一个属性&lt;br/&gt;通过@property 装饰器可以对模拟属性的取值和赋值加以控制&lt;br/&gt;示例见:&lt;br/&gt;示例：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, s):
        self.&lt;/span&gt;&lt;span&gt;__score&lt;/span&gt; = s  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 私有属性,不让其它人任意修改成绩&lt;/span&gt;
&lt;span&gt;
    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; score(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;伪装模拟私有一个成绩属性　并返回成绩&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;&lt;span&gt;

    @score.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; score(self, v):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;实现设置者setter , 对用户的复制加以限制&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;assert&lt;/span&gt; 0 &amp;lt;= v &amp;lt;= 100, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成绩不合法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__score&lt;/span&gt; =&lt;span&gt; v


s &lt;/span&gt;= Student(59&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s.score)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 希望有一个属性能得到成绩　　虚拟属性不能复制&lt;/span&gt;
s.score = 80  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过s.score　来修改成绩&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(s.score)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改成功　s.score看似属性　是模拟属性　实际内部已经被替换&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题:&lt;br/&gt;L = [1, 2, 3]&lt;br/&gt;def f1(lst):&lt;br/&gt;lst += [4, 5, 6]&lt;/p&gt;
&lt;p&gt;f1(L)&lt;br/&gt;print(L) # [1, 2, 3, 4, 5, 6] 为什么&lt;/p&gt;
&lt;p&gt;L = (1, 2, 3)&lt;br/&gt;def f1(lst):&lt;br/&gt;lst += (4, 5, 6) # lst = lst + (4, 5, 6)&lt;br/&gt;f1(L)&lt;br/&gt;print(L) # (1, 2, 3) 为什么&lt;/p&gt;

&lt;p&gt;练习:&lt;br/&gt;1. 实现两个自定义的列表相加&lt;br/&gt;class MyList:&lt;br/&gt;.... 此处自己实现&lt;br/&gt;L1 = MyList([1, 2, 3])&lt;br/&gt;L2 = MyList(range(4, 7))&lt;br/&gt;L3 = L1 + L2&lt;br/&gt;print(L3) # MyList([1, 2, 3, 4, 5, 6])&lt;br/&gt;L4 = L2 + L1&lt;br/&gt;print(L4) # MyList([4, 5, 6, 1, 2, 3])&lt;br/&gt;L5 = L1 * 2&lt;br/&gt;print(L5) # MyList([1, 2, 3, 1, 2, 3])&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;练习:&lt;br/&gt;实现有序集合类 OrderSet() 能实现两个集合的交集 &amp;amp;,全集 |,&lt;br/&gt;补集 - 对称补集 ^, ==/!= , in/ not in 等操作&lt;br/&gt;要求集合内部用 list 存储&lt;br/&gt;class OrderSet:&lt;br/&gt;...&lt;br/&gt;s1 = OrderSet([1, 2, 3, 4])&lt;br/&gt;s2 = OrderSet([3, 4, 5])&lt;br/&gt;print(s1 &amp;amp; s2) # OrderSet([3, 4])&lt;br/&gt;print(s1 | s2) # OrderSet([1, 2, 3, 4, 5])&lt;br/&gt;print(s1 ^ s2) # OrderSet([1, 2, 5])&lt;br/&gt;if OrderSet([1, 2, 3]) != OrderSet([3, 4, 5]):&lt;br/&gt;print(&quot;不相等&quot;)&lt;br/&gt;if s2 == OrderSet(3, 4, 5):&lt;br/&gt;print('s2 == OrderSet(3, 4, 5) is True')&lt;br/&gt;if 2 in s1:&lt;br/&gt;print(&quot;2在 s1中&quot;)&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:37:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9380227.html</dc:identifier>
</item>
<item>
<title>神奇的C语言，这才是C语言大牛操作，作为面试题，怕是秒杀众人 - C语言叶子编程</title>
<link>http://www.cnblogs.com/yezibiancheng/p/9380198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yezibiancheng/p/9380198.html</guid>
<description>&lt;p class=&quot;imgbox&quot;&gt;&lt;img class=&quot;image-loaded&quot; src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/31afafd8362f9173374c948c03d59007x457x454x14.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/31afafd8362f9173374c948c03d59007x457x454x14.jpeg&quot; data-width=&quot;457&quot; data-height=&quot;454&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;13542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然下面列出来的几点都是C的基础用法，只不过是这些用法可能平时不会被注意。所以很多东西第一次看到的时候，可能会觉得很怪异，但是细细想想就能很好的理解，也就能更好的清楚C语言的一些特性。但是在具体的编码过程当中，我还是希望都能老老实实规规矩矩的。因为程序员不需要太多棱角，把代码写得规范整洁比耍小聪明要重要得多。下面我列举了5个例子说明一些问题，如果你是老手看到这些就一笑而过吧，如果是新手，我相信还是会得到一些启发的。&lt;/p&gt;
&lt;p&gt;1. #和##在宏中的作用，以及带参宏，参数的传递问题。&lt;/p&gt;
&lt;p&gt;2. 结构体中域的偏移位置的计算问题。&lt;/p&gt;
&lt;p&gt;3. 结构体的定义以及初始化的用法。&lt;/p&gt;
&lt;p&gt;4. 数组和指针在运算中的等价关系。&lt;/p&gt;
&lt;p&gt;5. 数组在栈中的“变异”。&lt;/p&gt;
&lt;p&gt;1. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/808e5a6dc57961b0a4cc0793d527d907x640x431x22.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/808e5a6dc57961b0a4cc0793d527d907x640x431x22.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;431&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;22050&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 预编译中#是将右边的参数转成一个字符串，##是将左右两边的参数连接成一个字符串。例子是#的用法。&lt;/p&gt;
&lt;p&gt;B) 宏当中的参数其实是以逗号(,)分隔的，其他的字符其实都被看成同一个参数，但是换行和空白其实被处理过了，使参数在同一个行中。有兴趣的自己多做些测试吧，这个用法可以用于要写包含特殊字符的字符串，免得要写很多的转义字符()，但是中间不能有逗号，呵呵~&lt;/p&gt;
&lt;p&gt;2. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/423b4c87cf122c46b9b3b01eed7827dcx640x429x21.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/423b4c87cf122c46b9b3b01eed7827dcx640x429x21.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;429&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;20743&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) &amp;amp;((struct _st*)0)-&amp;gt;b 的作用是输出_st结构体中b的偏移。为什么用0当成指针呢，其实很好理解：如果一个_st结构体的地址是0，那么b的地址其实就是b在结构体中的偏移。&lt;/p&gt;
&lt;p&gt;B) 其实按理，如果先做((struct _st*)0)-&amp;gt;b运算，那么程序肯定异常，所以编译器还是做了优化的，具体编译器怎么做的，我也没深究。&lt;/p&gt;
&lt;p&gt;3. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/968e2adb7814a66a2e8bd5a6a4c4fbe9x640x460x25.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/968e2adb7814a66a2e8bd5a6a4c4fbe9x640x460x25.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;460&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;24579&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 在结构体的初始化时，可以指定域进行初始化，如例子中的.c = 1,顺序可以颠倒，这样做的好处就是可读性较强，对于大结构的初始化，在阅读时很方便。缺点就是低版本的编译器可能不支持。&lt;/p&gt;
&lt;p&gt;B) 在结构体的声明中，可以指定域的大小，如例子中的int a : 1; 说明a只暂用一个bit，充分展示了C对二进制处理反面的亲和力。&lt;/p&gt;
&lt;p&gt;C) 为什么s.c输出是-1，而不是1，其实很简单，因为0xFFFFFFFF表示的是-1，那么一个1bit大小的变量，所有位上面都是1，那么它也表示-1。所以编码的过程中，有符号和无符号混用其实是很危险的一件事情。&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/96117b6bba63a1c082b6aab914fabf4dx640x407x30.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/96117b6bba63a1c082b6aab914fabf4dx640x407x30.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;407&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;30474&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/d388a5960c63fb8a4cae5de1dd48517dx640x442x25.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/d388a5960c63fb8a4cae5de1dd48517dx640x442x25.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;442&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;25408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 0[a] = 'x';是什么玩意儿？如果写成a[0]='x';其实你就明白是什么意思了，但是说白了，a[0]和0[a]在编译器看来是一样的。因为数组在做[]运行时，其实是做指针的加法运行：a[0]等价于*(a+0)。所以0[a]也就等价于*(0+a)是完全正确的。&lt;/p&gt;
&lt;p&gt;5. 例子：&lt;/p&gt;
&lt;p class=&quot;imgbox&quot;&gt;&lt;img src=&quot;http://image.uc.cn/o/wemedia/s/upload/2018/f25967dd7f57f4650e51438fc1e2ee46x640x401x22.jpeg;,3,jpegx;3,700x.jpg&quot; alt=&quot;&quot; data-original=&quot;http://image.uc.cn/s/wemedia/s/upload/2018/f25967dd7f57f4650e51438fc1e2ee46x640x401x22.jpeg&quot; data-width=&quot;640&quot; data-height=&quot;401&quot; data-infoed=&quot;1&quot; data-format=&quot;JPEG&quot; data-size=&quot;22396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;A) 为什么两行的结果会不一样？在一般情况下，按我的理解，一个数组a，&amp;amp;a和&amp;amp;a[0]的值是一样的。但是当a在形参当中时就不一样了。例子中，func函数中的a，其实a变量是在func函数的栈当中，在func内部，a其实已经被转化成char *a，所以&amp;amp;a是表示指针变量a在栈中的地址，而&amp;amp;a[0]表示的是指针指向的内存空间的第一个元素的地址，其实也就是调用者传入的数组的第一个元素的地址。不知道我说明白了没有！！&lt;/p&gt;
&lt;p&gt;B) 这个可能比较难理解，关键是明白一点，在数组作为形参时，是被转换成指针看待的。&lt;/p&gt;
&lt;p&gt;我有一个微信公众号，经常会分享一些C语言/C++技术相关的干货；如果你喜欢我的分享，可以用微信搜索“C语言学习部落”关注&lt;/p&gt;
&lt;p&gt;欢迎大家加入千人交流答疑裙：627+012+464&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 15:26:00 +0000</pubDate>
<dc:creator>C语言叶子编程</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yezibiancheng/p/9380198.html</dc:identifier>
</item>
<item>
<title>[图解Java]Condition - GoldArowana</title>
<link>http://www.cnblogs.com/noKing/p/9380091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noKing/p/9380091.html</guid>
<description>&lt;h2&gt;图解Condition&lt;/h2&gt;
&lt;h3&gt;0. demo&lt;/h3&gt;
&lt;p&gt;我先给出一个demo, 这样大家就可以根据我给的这段代码, 边调试边看源码了. 还是那句话: 注意&quot;My&quot; , 我把ReentrantLock类 改名为了 &quot;MyReentrantLock&quot;类 , &quot;Lock&quot;类 改名为了&quot;MyLock&quot;类. 大家粘贴我的代码的时候, 把相应的&quot;My&quot;都去掉就好了, 否则会编译报错哦.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.util.Scanner;
import java.util.concurrent.locks.Condition;
import java.util.function.Supplier;

public class ConditionTest {
    static final Scanner scanner = new Scanner(System.in);
    static volatile String cmd = &quot;&quot;;
    private static MyReentrantLock lock = new MyReentrantLock(true);
    private static Condition condition = lock.newCondition();

    public static void main(String[] args) {
        for (String name : new String[]{&quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w5&quot;, &quot;w6&quot;})
            new Thread(() -&amp;gt; func(() -&amp;gt; lock, name)).start();
        new Thread(() -&amp;gt; signalOne(() -&amp;gt; lock, &quot;s&quot;)).start();

        while (scanner.hasNext()) {
            cmd = scanner.nextLine();
        }
    }

    public static void func(Supplier&amp;lt;MyLock&amp;gt; myLockSupplier, String name) {
        blockUntilEquals(() -&amp;gt; cmd, name);
        myLockSupplier.get().lock();

        System.out.println(name + &quot;阻塞等待...&quot;);
        try {
            condition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;释放了&quot; + name);

        myLockSupplier.get().unlock();
    }

    public static void signalOne(Supplier&amp;lt;MyLock&amp;gt; myLockSupplier, String name) {
        while (true) {
            blockUntilEquals(() -&amp;gt; cmd, name);
            myLockSupplier.get().lock();
            condition.signal();
            System.out.println(&quot;通知唤醒了一个等待...&quot;);
            myLockSupplier.get().unlock();
        }
    }

    private static void blockUntilEquals(Supplier&amp;lt;String&amp;gt; cmdSupplier, final String expect) {
        while (!cmdSupplier.get().equals(expect))
            quietSleep(1000);
        clearCmd();
    }

    private static void quietSleep(int mills) {
        try {
            Thread.sleep(mills);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void clearCmd() {
        cmd = &quot;&quot;;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用例子在下面. &lt;/p&gt;
&lt;p&gt;首先输入w1, 让线程1执行await() . 然后输入w2, 让线程2执行await(). 然后输入w3, 让线程3执行await().&lt;/p&gt;
&lt;p&gt;接下来输入3次 s, 没输入一次s, 并按下回车, 就会signal通知一个await等待.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727172514983-545531193.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1. 开始图解Condition&lt;/h3&gt;
&lt;p&gt;想用ReentrantLock的Condition, 那么就首先要有个ReentrantLock锁.&lt;/p&gt;
&lt;p&gt;实例化一个锁, ReentrantLock里只有一个成员变量sync.&lt;/p&gt;
&lt;p&gt;sync实例里面有四个成员变量.&lt;/p&gt;
&lt;p&gt;分别表示:&lt;/p&gt;
&lt;p&gt;          1. state - 锁计数器&lt;/p&gt;
&lt;p&gt;          2. exclusiveOwnerThread - 锁的持有线程&lt;/p&gt;
&lt;p&gt;          3. head - `等待队列`的头结点.&lt;/p&gt;
&lt;p&gt;          4. tail - 指向`等待队列`的最后一个元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727173553916-1338431673.png&quot; alt=&quot;&quot; height=&quot;300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后咱们实例化了一个Condition. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727174242628-890690893.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当咱们输入w1后, 第一个线程就申请了锁, 并且申请成功.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727174621075-238210493.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后就执行到了await()方法.&lt;/p&gt;
&lt;p&gt;将线程1封装为Node节点, 然后waitState置为-2.  -2的含义是Condition.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727175723594-203858123.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; await()方法内部的第一个步骤就是把当前线程(线程1)插入到了`条件队列`中.&lt;/p&gt;

&lt;p&gt;然后就开始释放当前线程(线程1)的锁了, 而且是完全释放, 一次就释放掉全部重入次数哦, 也就是直接让state等于0. &lt;/p&gt;
&lt;p&gt;释放完锁了, 然后挂起线程1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727183733969-1750615281.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后让线程2进行await.( 也就是前面的demo程序中在控制台输入了w2.)&lt;/p&gt;
&lt;p&gt;线程2执行await()之前当然是先获取锁了.&lt;/p&gt;
&lt;p&gt;由于此时, 锁是空闲的. 所以线程2成功获取到了锁. 淡橙色的阴影部分为变化的内容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727183910474-39681418.jpg&quot; alt=&quot;&quot; height=&quot;600px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;获取锁之后, 线程2就该执行await()了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727184019742-1836066772.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如上图, 将线程封装为Node, 然后尾插到`条件队里`中, 只是await() 方法的第一步.&lt;/p&gt;
&lt;p&gt;然后的操作, 就是完全释放线程2的锁, 然后挂起线程.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727183505897-1988515706.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果这个时候咱们在上面demo程序的控制台输入&quot;s&quot;, 那么就会让线程s 申请锁, 申请成功后, 就会执行signal.&lt;/p&gt;
&lt;p&gt;首先是线程s申请锁成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727184812042-617800133.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 线程s成功获取了锁以后, 就是该执行signal()了.&lt;/p&gt;
&lt;p&gt; 首先将`条件队列`里的第一个节点脱离出来:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727185904919-705350543.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后把waitState从-2改为0 :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727221819704-1473450189.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后要做的就是把从`条件队列`中脱离出来的Node(就是线程1对应的Node节点), 尾插到`等待队列`中.&lt;/p&gt;
&lt;p&gt;但是`等待队列`此时还未被初始化, 所以插入到`等待队列`之前, 要把`等待队列`初始化了. 见下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727222821455-1777207639.jpg&quot; alt=&quot;&quot; height=&quot;700px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; `等待队列`初始化完了. 接下来就是把线程1对应的Node, 尾插到`等待队列`中了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727223747076-1197743443.jpg&quot; alt=&quot;&quot; height=&quot;700px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后将当前尾插的那个节点的前驱的waitState置为-1.  -1表示下一个节点等待着被唤醒. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180727224343294-1374168491.jpg&quot; alt=&quot;&quot; height=&quot;700px&quot;/&gt; &lt;/p&gt;
&lt;p&gt;接下来就是线程s会执行到unlock(). 然后就会释放锁, 之后就是唤醒`等待队列`中的第一个线程.&lt;/p&gt;
&lt;p&gt;如此就介绍完了signal()&lt;/p&gt;

&lt;p&gt;一个signal命令, 就把一个await的线程从`条件队列中`移到了`等待队列`中. 到了等待队列中之后, 剩下的就是跟&quot;锁解锁后, 唤醒下一个执行&quot;这样的步骤一样了.&lt;/p&gt;
&lt;p&gt;我觉得await方法就是将线程尾插到`条件队列`中. signal()方法就是把条件队列中的第一个元素, 尾插入到`等待队列`中.&lt;/p&gt;
&lt;p&gt;所以我觉得不必往下分析了.&lt;/p&gt;
&lt;p&gt;也可能是我理所当然了, 有问题的话之后再补充.&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 14:59:00 +0000</pubDate>
<dc:creator>GoldArowana</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noKing/p/9380091.html</dc:identifier>
</item>
<item>
<title>Spring_总结_03_装配Bean之自动装配 - shirayner</title>
<link>http://www.cnblogs.com/shirui/p/9379975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shirui/p/9379975.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;本文承接上一节：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shirui/p/9375135.html&quot; target=&quot;_blank&quot;&gt;Spring_总结_02_依赖注入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在上一节我们了解到依赖注入的实质就是装配。&lt;/p&gt;
&lt;p&gt;这一节我们来学习下装配Bean的相关知识。&lt;/p&gt;

&lt;h2&gt;二、Bean的装配机制&lt;/h2&gt;
&lt;h3&gt;1.三种装配机制&lt;/h3&gt;
&lt;p&gt;Spring提供了三种主要的bean的装配机制：&lt;/p&gt;
&lt;p&gt;（1）隐式的bean发现机制和自动装配&lt;/p&gt;
&lt;p&gt;（2）在Java中进行显示配置&lt;/p&gt;
&lt;p&gt;（3）在XML中进行显示配置&lt;/p&gt;

&lt;h3&gt;2.如何选择&lt;/h3&gt;
&lt;p&gt;（1）第一考虑自动装配，显示配置越少越好。&lt;/p&gt;
&lt;p&gt;（2）当必须要显示配置的时候，再使用类型安全并且比XML更强大的JavaConfig&lt;/p&gt;
&lt;p&gt;（3）最后，只有当你想用使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。&lt;/p&gt;

&lt;p&gt;这里以一个小例子来阐述组件扫描和装配。创建CompactDisc类，Spring会发现它并为其创建一个bean。然后，创建一个CDPlayer类，Spring会发现它，并将CompactDisc bean注入进来。&lt;/p&gt;

&lt;h2&gt;二、自动装配的过程&lt;/h2&gt;
&lt;p&gt;Spring从两个角度来实现自动化装配：&lt;/p&gt;
&lt;p&gt;（1）组件扫描（component scanning）：Spring 会自动发现应用上下文中所创建的bean&lt;/p&gt;
&lt;p&gt;（2）自动装配（autowiring）：Spring 自动满足bean之间的依赖&lt;/p&gt;

&lt;p&gt;实现自动装配的过程如下：&lt;/p&gt;
&lt;p&gt;    （1）启用组件扫描： @ComponentScan&lt;/p&gt;
&lt;p&gt;    （2）声明bean      ：  @Component&lt;/p&gt;
&lt;p&gt;      (3)  自动装配bean ： @Autowired&lt;/p&gt;

&lt;h2&gt;三、启用组件扫描&lt;/h2&gt;
&lt;p&gt;组件扫描默认是不开启的，我们需要显示配置一下Spring，从而让它寻找带有@Component注解的类，并为其创建Bean。&lt;/p&gt;

&lt;p&gt;配置类 CDPlayerConfig&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Configuration   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
@ComponentScan   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CDPlayerConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1. 默认扫描包&lt;/h3&gt;
&lt;p&gt;1处：声明这是一个配置类&lt;/p&gt;
&lt;p&gt;2处：开启组件扫描。默认会扫描配置类所在同级包及其子包，查找带有@Component注解的类。&lt;/p&gt;

&lt;h3&gt;2. 设置组件扫描的基础包&lt;/h3&gt;
&lt;p&gt;ComponentScan源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cdc9c29d-5d79-4d0c-83bd-e3ee95088caa')&quot; readability=&quot;44&quot;&gt;&lt;img id=&quot;code_img_closed_cdc9c29d-5d79-4d0c-83bd-e3ee95088caa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cdc9c29d-5d79-4d0c-83bd-e3ee95088caa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cdc9c29d-5d79-4d0c-83bd-e3ee95088caa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cdc9c29d-5d79-4d0c-83bd-e3ee95088caa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Documented;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Repeatable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.support.BeanNameGenerator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.annotation.AliasFor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.type.filter.TypeFilter;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Configures component scanning directives for use with @{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Configuration} classes.
 * Provides support parallel with Spring XML's {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; &amp;lt;context:component-scan&amp;gt;} element.
 *
 * &amp;lt;p&amp;gt;Either {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #basePackageClasses} or {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #basePackages} (or its alias
 * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #value}) may be specified to define specific packages to scan. If specific
 * packages are not defined, scanning will occur from the package of the
 * class that declares this annotation.
 *
 * &amp;lt;p&amp;gt;Note that the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; &amp;lt;context:component-scan&amp;gt;} element has an
 * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; annotation-config} attribute; however, this annotation does not. This is because
 * in almost all cases when using {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @ComponentScan}, default annotation config
 * processing (e.g. processing {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Autowired} and friends) is assumed. Furthermore,
 * when using {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AnnotationConfigApplicationContext}, annotation config processors are
 * always registered, meaning that any attempt to disable them at the
 * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @ComponentScan} level would be ignored.
 *
 * &amp;lt;p&amp;gt;See {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Configuration @Configuration}'s Javadoc for usage examples.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Chris Beams
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Juergen Hoeller
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Sam Brannen
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 3.1
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; Configuration
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ComponentScan {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Alias for {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #basePackages}.
     * &amp;lt;p&amp;gt;Allows for more concise annotation declarations if no other attributes
     * are needed &amp;amp;mdash; for example, {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @ComponentScan(&quot;org.my.pkg&quot;)}
     * instead of {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @ComponentScan(basePackages = &quot;org.my.pkg&quot;)}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @AliasFor(&lt;/span&gt;&quot;basePackages&quot;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Base packages to scan for annotated components.
     * &amp;lt;p&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #value} is an alias for (and mutually exclusive with) this
     * attribute.
     * &amp;lt;p&amp;gt;Use {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #basePackageClasses} for a type-safe alternative to
     * String-based package names.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
    String[] basePackages() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Type-safe alternative to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #basePackages} for specifying the packages
     * to scan for annotated components. The package of each class specified will be scanned.
     * &amp;lt;p&amp;gt;Consider creating a special no-op marker class or interface in each package
     * that serves no purpose other than being referenced by this attribute.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;?&amp;gt;[] basePackageClasses() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; BeanNameGenerator} class to be used for naming detected components
     * within the Spring container.
     * &amp;lt;p&amp;gt;The default value of the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; BeanNameGenerator} interface itself indicates
     * that the scanner used to process this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @ComponentScan} annotation should
     * use its inherited bean name generator, e.g. the default
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AnnotationBeanNameGenerator} or any custom instance supplied to the
     * application context at bootstrap time.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; AnnotationConfigApplicationContext#setBeanNameGenerator(BeanNameGenerator)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; BeanNameGenerator&amp;gt; nameGenerator() &lt;span&gt;default&lt;/span&gt; BeanNameGenerator.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ScopeMetadataResolver} to be used for resolving the scope of detected components.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; ScopeMetadataResolver&amp;gt; scopeResolver() &lt;span&gt;default&lt;/span&gt; AnnotationScopeMetadataResolver.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicates whether proxies should be generated for detected components, which may be
     * necessary when using scopes in a proxy-style fashion.
     * &amp;lt;p&amp;gt;The default is defer to the default behavior of the component scanner used to
     * execute the actual scan.
     * &amp;lt;p&amp;gt;Note that setting this attribute overrides any value set for {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #scopeResolver}.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; ClassPathBeanDefinitionScanner#setScopedProxyMode(ScopedProxyMode)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ScopedProxyMode scopedProxy() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; ScopedProxyMode.DEFAULT;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Controls the class files eligible for component detection.
     * &amp;lt;p&amp;gt;Consider use of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #includeFilters} and {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #excludeFilters}
     * for a more flexible approach.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String resourcePattern() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Indicates whether automatic detection of classes annotated with {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Component}
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Repository}, {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Service}, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Controller} should be enabled.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; useDefaultFilters() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Specifies which types are eligible for component scanning.
     * &amp;lt;p&amp;gt;Further narrows the set of candidate components from everything in {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #basePackages}
     * to everything in the base packages that matches the given filter or filters.
     * &amp;lt;p&amp;gt;Note that these filters will be applied in addition to the default filters, if specified.
     * Any type under the specified base packages which matches a given filter will be included,
     * even if it does not match the default filters (i.e. is not annotated with {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Component}).
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #resourcePattern()
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #useDefaultFilters()
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Filter[] includeFilters() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Specifies which types are not eligible for component scanning.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #resourcePattern
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Filter[] excludeFilters() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Specify whether scanned beans should be registered for lazy initialization.
     * &amp;lt;p&amp;gt;Default is {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; false}; switch this to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} when desired.
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 4.1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; lazyInit() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Declares the type filter to be used as an {&lt;/span&gt;&lt;span&gt;@linkplain&lt;/span&gt;&lt;span&gt; ComponentScan#includeFilters
     * include filter} or {&lt;/span&gt;&lt;span&gt;@linkplain&lt;/span&gt;&lt;span&gt; ComponentScan#excludeFilters exclude filter}.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Retention(RetentionPolicy.RUNTIME)
    @Target({})
    @&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Filter {

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * The type of filter to use.
         * &amp;lt;p&amp;gt;Default is {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; FilterType#ANNOTATION}.
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #classes
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #pattern
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        FilterType type() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; FilterType.ANNOTATION;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Alias for {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #classes}.
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #classes
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @AliasFor(&lt;/span&gt;&quot;classes&quot;&lt;span&gt;)
        Class&lt;/span&gt;&amp;lt;?&amp;gt;[] value() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * The class or classes to use as the filter.
         * &amp;lt;p&amp;gt;The following table explains how the classes will be interpreted
         * based on the configured value of the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #type} attribute.
         * &amp;lt;table border=&quot;1&quot;&amp;gt;
         * &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; FilterType}&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Class Interpreted As&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
         * &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; FilterType#ANNOTATION ANNOTATION}&amp;lt;/td&amp;gt;
         * &amp;lt;td&amp;gt;the annotation itself&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
         * &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; FilterType#ASSIGNABLE_TYPE ASSIGNABLE_TYPE}&amp;lt;/td&amp;gt;
         * &amp;lt;td&amp;gt;the type that detected components should be assignable to&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
         * &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; FilterType#CUSTOM CUSTOM}&amp;lt;/td&amp;gt;
         * &amp;lt;td&amp;gt;an implementation of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; TypeFilter}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
         * &amp;lt;/table&amp;gt;
         * &amp;lt;p&amp;gt;When multiple classes are specified, &amp;lt;em&amp;gt;OR&amp;lt;/em&amp;gt; logic is applied
         * &amp;amp;mdash; for example, &quot;include types annotated with {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Foo} OR {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Bar}&quot;.
         * &amp;lt;p&amp;gt;Custom {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; TypeFilter TypeFilters} may optionally implement any of the
         * following {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.Aware Aware} interfaces, and
         * their respective methods will be called prior to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; TypeFilter#match match}:
         * &amp;lt;ul&amp;gt;
         * &amp;lt;li&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.context.EnvironmentAware EnvironmentAware}&amp;lt;/li&amp;gt;
         * &amp;lt;li&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware}
         * &amp;lt;li&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware}
         * &amp;lt;li&amp;gt;{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.context.ResourceLoaderAware ResourceLoaderAware}
         * &amp;lt;/ul&amp;gt;
         * &amp;lt;p&amp;gt;Specifying zero classes is permitted but will have no effect on component
         * scanning.
         * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 4.2
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #value
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #type
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
        Class&lt;/span&gt;&amp;lt;?&amp;gt;[] classes() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * The pattern (or patterns) to use for the filter, as an alternative
         * to specifying a Class {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #value}.
         * &amp;lt;p&amp;gt;If {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #type} is set to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; FilterType#ASPECTJ ASPECTJ},
         * this is an AspectJ type pattern expression. If {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #type} is
         * set to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; FilterType#REGEX REGEX}, this is a regex pattern
         * for the fully-qualified class names to match.
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #type
         * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #classes
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        String[] pattern() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中，通过 basePackages 可用String类型来指定基础包。&lt;/p&gt;
&lt;p&gt;           通过 basePackageClasses 可用类或接口（建议使用&lt;span&gt;空标记接口&lt;/span&gt;）来指定基础包，这些类或接口所在的包将会作为组件扫描的基础包。&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0aafecb1-243f-4094-865e-da60996c8860')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0aafecb1-243f-4094-865e-da60996c8860&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0aafecb1-243f-4094-865e-da60996c8860&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0aafecb1-243f-4094-865e-da60996c8860',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0aafecb1-243f-4094-865e-da60996c8860&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ComponentScan(basePackages &lt;/span&gt;= &quot;com.ray.soundsystem&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CDPlayerConfig {
}


@Configuration
@ComponentScan(basePackages &lt;/span&gt;= {&quot;com.ray.soundsystem&quot;,&quot;com.ray.video&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CDPlayerConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('02b73a9d-b42d-4b4b-bec8-ad504f7301a1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_02b73a9d-b42d-4b4b-bec8-ad504f7301a1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_02b73a9d-b42d-4b4b-bec8-ad504f7301a1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('02b73a9d-b42d-4b4b-bec8-ad504f7301a1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_02b73a9d-b42d-4b4b-bec8-ad504f7301a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SoundSystemScanConfig {
    
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; VideoScanConfig {

}

@Configuration
@ComponentScan(basePackageClasses &lt;/span&gt;= {SoundSystemScanConfig.&lt;span&gt;class&lt;/span&gt;,VideoScanConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CDPlayerConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;四、声明bean&lt;/h2&gt;
&lt;h3&gt;1.  @Component声明bean&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9a9f1f25-ef8f-44e1-a375-2f928ec48a39')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_9a9f1f25-ef8f-44e1-a375-2f928ec48a39&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9a9f1f25-ef8f-44e1-a375-2f928ec48a39&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9a9f1f25-ef8f-44e1-a375-2f928ec48a39',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9a9f1f25-ef8f-44e1-a375-2f928ec48a39&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComPactDisc {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(){
        System.out.println(&lt;/span&gt;&quot;play music&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;如上述代码所示，&lt;span&gt;通过@Component来声明一个组件&lt;/span&gt;，表明该类会作为组件类，并告知Spring要为这个类创建bean。&lt;/p&gt;
&lt;p&gt;可用以下注解来声明一个组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Component  ： 标注通用组件&lt;/li&gt;
&lt;li&gt;@Controller     ： 标注控制器&lt;/li&gt;
&lt;li&gt;@Service        ：  标注Service&lt;/li&gt;
&lt;li&gt;@Respository ：  标注数据访问层&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过查看源码，可知，@Controller、@Service、@Repository 能声明bean 是因为他们都组合了@Component。&lt;/p&gt;
&lt;p&gt;以Controller为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;span&gt;@Component
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; Controller
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.为组件命名&lt;/h3&gt;
&lt;p&gt;Spring 会为所有的bean都指定一个ID，默认为类名首字母小写。&lt;/p&gt;
&lt;p&gt;但也可通过@Component的value属性来将为bean命名，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9f0fc301-5d5f-44c4-af0a-2fc94cbbc0b0')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_9f0fc301-5d5f-44c4-af0a-2fc94cbbc0b0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9f0fc301-5d5f-44c4-af0a-2fc94cbbc0b0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9f0fc301-5d5f-44c4-af0a-2fc94cbbc0b0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9f0fc301-5d5f-44c4-af0a-2fc94cbbc0b0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
@Component(&quot;compactDisc1&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComPactDisc {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(){
        System.out.println(&lt;/span&gt;&quot;play music&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;五、自动装配bean&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1e8f9896-03ea-457d-8e8d-131add267d37')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_1e8f9896-03ea-457d-8e8d-131add267d37&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1e8f9896-03ea-457d-8e8d-131add267d37&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1e8f9896-03ea-457d-8e8d-131add267d37',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1e8f9896-03ea-457d-8e8d-131add267d37&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CDPlayer {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ComPactDisc cd;
    
    
    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CDPlayer( ComPactDisc cd){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cd =&lt;span&gt;cd;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(){
        cd.play();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;（1）通过 @Autowired 注解，声明让Spring来自动注入符合要求的bean&lt;/p&gt;
&lt;p&gt;（2）&lt;span&gt;@Autowired 注解可用在属性上以及任何方法上&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（3）当@Autowired 注解用在方法上时，Spring会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求，那么这个bean将会被装配进来。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Jul 2018 14:24:00 +0000</pubDate>
<dc:creator>shirayner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shirui/p/9379975.html</dc:identifier>
</item>
<item>
<title>吴恩达深度学习笔记 couse2 1.1~1.14 深度学习的实用层面 - Dar_Alpha</title>
<link>http://www.cnblogs.com/Dar-/p/9379956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dar-/p/9379956.html</guid>
<description>&lt;p&gt;1.1 Train/dev/test sets&lt;/p&gt;
&lt;p&gt;在构建一个神经网络的时候我们往往需要设计很多参数,如:layers,learning rates ,acivation functions,hidden units, 而这些参数我们往往不能一次性就能设计到成为了最佳的参数,往往是我们自己有一些想法,然后写出代码,开始实验,然后开始调整,再次更改代码实验,就这样一步步调整,得到最佳的参数.使神经网络的性能最佳.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727162355511-1353080261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前深度学习被应用到很多领域,如NLP,Vision,Speech recognize等等,往往在某个领域的效果好的深度神经网络不能直接应用在其他领域中.&lt;/p&gt;
&lt;p&gt;设置最佳的train/dev/test sets能够提高训练的效率.&lt;/p&gt;
&lt;p&gt;train set用于训练算法模型,dev set 用于验证各个算法情况,来选择最好的算法,test set 用于测试算法的最好情况,作为该算法的无偏估计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727163252040-68467259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在训练样本比较少的情况,我们可以设置train/dev/test set 的比值为70/30/0 or 60/20/20&lt;/p&gt;
&lt;p&gt;训练样本比较庞大的时候,可以设置他们的比值为98/1/1,样本越大,那么train所占的比值便越大,因为我们的目的是得到最佳的神经网络模型,而样本十分庞大时,dev/test sets 的比值小也会有庞大的样本,它们只是用来验证与测试最佳的神经网络,并不需要数目巨大的样本,所以它们的比值可以设计的相对更小一些.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727164109425-1650157166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们往往会遇到一种情况:假设我们做了一个app要对猫的图片进行一个判断,训练的与 验证/测试的样本来源不同,解决这个问题的方法是保证dev/test sets的来源一致&lt;/p&gt;
&lt;p&gt;值得一提的是，训练样本非常重要，通常我们可以将现有的训练样本做一些处理，例如图片的翻转、假如随机噪声等，来扩大训练样本的数量，从而让该模型更加强大。即使Train sets和Dev/Test sets不来自同一分布，使用这些技巧也能提高模型性能。&lt;/p&gt;
&lt;p&gt;如果没有Test sets也是没有问题的。Test sets的目标主要是进行无偏估计。我们可以通过Train sets训练不同的算法模型，然后分别在Dev sets上进行验证，根据结果选择最好的算法模型。这样也是可以的，不需要再进行无偏估计了。如果只有Train sets和Dev sets，通常也有人把这里的Dev sets称为Test sets，我们要注意加以区别。&lt;/p&gt;
&lt;p&gt;1.2~1.3  Bias and Variance&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727164826226-1386969285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入特征与输出值 接近一个线性关系时,这种欠拟合的情况我们可以称之为高偏差, 相反的出现过拟合的情况时,我们称之为高方差.  而上图中间那张就是我们所期望得到的.接下来我们通过一些数据来更加直观的理解什么是高偏差 ,什么是高方差&lt;/p&gt;
&lt;p&gt;假设我们train set error 与test set error如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727165517502-1018672284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一种情况,train set error 小,而dev set error大,说明过拟合,属于high variance,第二种,train set error 较大,dev set error 接近,欠拟合,属于high bias,&lt;/p&gt;
&lt;p&gt;第三种情况train set error 较大,且dev set error 与train set error 相差大,那么既是high variance 又是high bias,图像如下 紫色线表示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727170319596-226321885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那么该如何使得偏差减小来得到最佳的神经网络模型呢,方法如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727170030896-188137870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; high bias:用更复杂网络&lt;/p&gt;
&lt;p&gt;high variance:更多的数据,正则化,完善网络&lt;/p&gt;
&lt;p&gt;1.4 Regularization&lt;/p&gt;
&lt;p&gt;回顾一下之前的logistic regression,采用L2  regularization 结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727173407347-667565065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们只是对w进行了一个正则化,因为w的维度相对于b来说比较大,所以b可以忽略&lt;/p&gt;
&lt;p&gt;我们把&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-11-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-399&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-400&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-401&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-402&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-403&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-404&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-405&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-406&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-407&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-408&quot; class=&quot;mi&quot;&gt;w &lt;span id=&quot;MathJax-Span-409&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-410&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-411&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-412&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-413&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-414&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-415&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-416&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-417&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-418&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-419&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-420&quot; class=&quot;mo&quot;&gt;| &lt;span id=&quot;MathJax-Span-421&quot; class=&quot;mn&quot;&gt;2  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;||w[l]||2 称为Frobenius范数，记为&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-12-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;msubsup&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;F&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msubsup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-422&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-423&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-424&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-425&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-426&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-427&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-428&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-429&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-430&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-431&quot; class=&quot;mi&quot;&gt;w &lt;span id=&quot;MathJax-Span-432&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-433&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-434&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-435&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-436&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-437&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-438&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-439&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-440&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-441&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-442&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-443&quot; class=&quot;mo&quot;&gt;| &lt;sup&gt;2&lt;/sup&gt;&lt;span id=&quot;MathJax-Span-444&quot; class=&quot;mn&quot;&gt; &lt;sub&gt;F&lt;/sub&gt;&lt;span id=&quot;MathJax-Span-445&quot; class=&quot;mi&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;。一个矩阵的Frobenius范数就是计算所有元素平方和再开方，如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里要注意的是,当我们对w进行正则化的时候,更新参数w的时候,dw也应该要变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727174329976-2032408166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时w也叫weight decay,这是因为更新w[l]时会比没有正则项的时候少αλ/m *w[l],不断迭代,w就会不断更新,不断减小.  &lt;/p&gt;

&lt;p&gt;除了L2 regularization 以外,还有L1 regularization  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727203833422-629551273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与L2 regularization相比，L1 regularization得到的w更加稀疏，即很多w为零值。其优点是节约存储空间，因为大部分w为0。然而，实际上L1 regularization在解决high variance方面比L2 regularization并不更具优势。而且，L1的在微分求导方面比较复杂。所以，一般L2 regularization更加常用。&lt;/p&gt;

&lt;h3 id=&quot;5-why-regularization-reduces-overfitting&quot;&gt;&lt;strong&gt;1.5 Why regularization reduces overfitting&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为什么正则化可以减少过拟合&lt;/p&gt;
&lt;p&gt;当λ足够大的时候,w[l]约等于0,即该神经网络中的某些神经元对整个网络基本没影响了,整个nn由复杂变得简单,识别特征的复杂度也变得更简单&lt;/p&gt;
&lt;p&gt;因此，选择合适大小的&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-25-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BB;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-760&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-761&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-762&quot; class=&quot;mi&quot;&gt;λ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;λ 值，就能够同时避免high bias和high variance，得到最佳模型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727200319354-1721307789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一种直观的理解是如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727200857492-1218670644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设激活函数为tanh函数,调整λ使得w足够小,当w很小的时候,z也变得很小,g(z)趋向于一个线性函数,整个模型趋向于一个线性回归,这就完成了high variance 到high bias 的改变&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727201240360-437427354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.6  dropout regularizationn&lt;/p&gt;
&lt;p&gt;Dropout是指在深度学习网络的训练过程中，对于每层的神经元，按照一定的概率将其暂时从网络中丢弃。也就是说，每次训练时，每一层都有部分神经元不工作，起到简化复杂网络模型的效果，从而避免发生过拟合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727201807491-1950515905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 用Inverted dropout实现dropout ,假设有一个NN,要对第三层进行dropout,令keep_prob=0.8,设一个d3的随机向量,该随机向量的维度与a[3]保持一致,让其小于keep_prob,则其中80%的元素为1，20%的元素为0。 然后对第3层的神经元进行一个删减,&lt;code class=&quot;language-python hljs has-numbering&quot;&gt;a3= np.multiply(a3,d3),相乘使得其中20%的值为0,即作为下一个输入层的值为0,对下一个输出层便不会存在影响.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后，还要对&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-38-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-866&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-867&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-868&quot; class=&quot;mi&quot;&gt;a3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;进行scale up处理，即：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-python hljs has-numbering&quot;&gt;a3/= keep_prob&lt;/code&gt;&lt;br/&gt;进行这一步的原因是使得下一层的期望输入值不发生改变,删减20%之后,便要除以80%&lt;/pre&gt;
&lt;p&gt;Inverted dropout的另外一个好处就是在对该dropout后的神经网络进行测试时能够减少scaling问题。因为在训练时，使用scale up保证&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-44-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-889&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-890&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-891&quot; class=&quot;mi&quot;&gt;a3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的期望值没有大的变化，测试时就不需要再对样本数据进行类似的尺度伸缩操作了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于m个样本，单次迭代训练时，随机删除掉隐藏层一定数量的神经元；然后，在删除后的剩下的神经元上正向和反向更新权重w和常数项b；接着，下一次迭代中，再恢复之前删除的神经元，重新随机删除一定数量的神经元，进行正向和反向更新w和b。不断重复上述过程，直至迭代训练完成。&lt;/p&gt;
&lt;p&gt;值得注意的是，使用dropout训练结束后，在测试和实际应用模型时，不需要进行dropout和随机删减神经元，所有的神经元都在工作。&lt;/p&gt;


&lt;p&gt;1.7 understand dropout&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727211001988-130255468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dropout 能起作用的原因是,他会随机的删除某些隐藏单元,使得下一层的输出值不会过分的依赖于某一个隐藏单元,从而实现了降低权重的效果&lt;/p&gt;

&lt;p&gt;在使用dropout 的时候,对于整个神经网络影响最大的层keep_prob可以调低一些,如上图第二层的w维度为(7,7),对整个NN影响最大,所以设计keep_prob可以调小一些,而影响小的可以keep_prob调大一些&lt;/p&gt;
&lt;p&gt;一般来说，神经元越多的隐藏层，keep_out可以设置得小一些.，例如0.5；神经元越少的隐藏层，keep_out可以设置的大一些，例如0.8，设置是1。另外，实际应用中，不建议对输入层进行dropout，如果输入层维度很大，例如图片，那么可以设置dropout，但keep_out应设置的大一些，例如0.8，0.9。总体来说，就是越容易出现overfitting的隐藏层，其keep_prob就设置的相对小一些。没有准确固定的做法，通常可以根据validation进行选择。&lt;/p&gt;
&lt;p&gt;使用dropout的时候，可以通过绘制cost function来进行debug，看看dropout是否正确执行。一般做法是，将所有层的keep_prob全设置为1，再绘制cost function，即涵盖所有神经元，看J是否单调下降。下一次迭代训练时，再将keep_prob设置为其它值。&lt;/p&gt;
&lt;p&gt;1.8 other regularization methods&lt;/p&gt;
&lt;p&gt;对于处理过拟合问题我们可以提供更多的样本,关于样本的提供,我们能对已有的样本进行处理得到新的样本,这叫data augmentation,如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727212328824-1297575348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;另一种防止过拟合的方法是early stoping&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727212718032-997027294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 一般train set error 随着迭代次数增加而减小,而dev/test sets 会先减少后增加&lt;/p&gt;
&lt;p&gt; Early stopping的做法通过减少迭代次数来防止过拟合，同时实现既减少了cost function J,有不会产生过拟合,但并没有分开解决的好,L2 regularization能分开解决J和过拟合的问题,L2 regularization常用,但L2 的参数λ选择较复杂,early stopping胜在简单.&lt;/p&gt;

&lt;p&gt;1.9 Normalizing Inputs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727213706251-2006739050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对数据进行一个归一化可以提高训练的速度,归一化的步骤:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727214105544-292356687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是对训练集的数据归一化训练后,dev/test set 验证/测试时也要进行一个归一化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727214315190-106917365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 归一化的原因是使得w的数量级相差不多,以便于更好的梯度下降&lt;/p&gt;
&lt;p&gt;假如输入特征是二维的，且x1的范围是[1,1000]，x2的范围是[0,1]。如果不进行标准化处理，x1与x2之间分布极不平衡，训练得到的w1和w2也会在数量级上差别很大,这样导致的结果是cost function与w和b的关系可能是一个非常细长的椭圆形碗。对其进行梯度下降算法时，由于w1和w2数值差异很大，只能选择很小的学习因子&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-53-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B1;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-974&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-975&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-976&quot; class=&quot;mi&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;α ，来避免J发生振荡。一旦&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-54-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B1;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-977&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-978&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-979&quot; class=&quot;mi&quot;&gt;α &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;较大，必然发生振荡，J不再单调下降&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B1;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B1;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;如果进行了标准化操作，x1与x2分布均匀，w1和w2数值差别不大，得到的cost function与w和b的关系是类似圆形碗。对其进行梯度下降算法时，&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-55-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B1;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-980&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-981&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-982&quot; class=&quot;mi&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;α 可以选择相对大一些，且J一般不会发生振荡&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 另外一种情况，如果输入特征之间的范围本来就比较接近，那么不进行标准化操作也是没有太大影响的。但是，标准化处理在大多数场合下还是值得推荐的。&lt;/p&gt;

&lt;p&gt;1.10 Vanish and Exploding gradients&lt;/p&gt;
&lt;p&gt;梯度消失和梯度爆炸指的是神经网络中计算的梯度非常小或非常大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727215055342-2020587078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举一个例子:&lt;/p&gt;
&lt;p&gt;假设b[l]为0,那么最后的输出y hat 为 w[l]*w[l-1]*...w[1]*x的一个函数,如果每一层的w都大于1,那么每一层的输出值会呈现一个指数的形式增加,如果每一层的w都小于1,会呈指数的形式递减,如上图所示&lt;/p&gt;

&lt;h3 id=&quot;11-weight-initialization-for-deep-networks&quot;&gt;&lt;strong&gt;1.11 Weight Initialization for Deep Networks&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727215956688-83857408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果激活函数是tanh，在初始化w时，令其方差为&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-python hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1/n&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-72-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mfrac&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;/mfrac&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;。相应的python伪代码为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-python hljs has-numbering&quot;&gt;w[l] = np.random.randn(n[l],n[l-&lt;span class=&quot;hljs-number&quot;&gt;1])*np.sqrt(&lt;span class=&quot;hljs-number&quot;&gt;1/n[l-&lt;span class=&quot;hljs-number&quot;&gt;1]) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果激活函数是ReLU，权重w的初始化一般令其方差为&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-73-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mfrac&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;/mfrac&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1164&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1165&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1167&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-1168&quot; class=&quot;mi&quot;&gt;n  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;2n ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-python hljs has-numbering&quot;&gt;w[l] = np.random.randn(n[l],n[l-&lt;span class=&quot;hljs-number&quot;&gt;1])*np.sqrt(&lt;span class=&quot;hljs-number&quot;&gt;2/n[l-&lt;span class=&quot;hljs-number&quot;&gt;1]) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，Yoshua Bengio提出了另外一种初始化w的方法，令其方差为&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-74-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mfrac&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mrow&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/mfrac&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1169&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1170&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1172&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-1173&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1174&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1175&quot; class=&quot;mi&quot;&gt;n &lt;span id=&quot;MathJax-Span-1176&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1177&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1178&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1179&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1180&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1181&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-1182&quot; class=&quot;mo&quot;&gt;] &lt;span id=&quot;MathJax-Span-1183&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1184&quot; class=&quot;mi&quot;&gt;n &lt;span id=&quot;MathJax-Span-1185&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1186&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1187&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-1188&quot; class=&quot;mi&quot;&gt;l&lt;span id=&quot;MathJax-Span-1189&quot; class=&quot;mo&quot;&gt;]   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;2n[l−1]n[l] ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;language-python hljs has-numbering&quot;&gt;w[l] = np.random.randn(n[l],n[l-&lt;span class=&quot;hljs-number&quot;&gt;1])*np.sqrt(&lt;span class=&quot;hljs-number&quot;&gt;2/n[l-&lt;span class=&quot;hljs-number&quot;&gt;1]*n[l]) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于选择哪种初始化方法因人而异，可以根据不同的激活函数选择不同方法。另外，我们可以对这些初始化方法中设置某些参数，作为超参数，通过验证集进行验证，得到最优参数，来优化神经网络。&lt;/p&gt;
&lt;p&gt;1.12~1.14 Gradient check&lt;/p&gt;
&lt;p&gt;Back Propagation神经网络有一项重要的测试是梯度检查（gradient checking）。其目的是检查验证反向传播过程中梯度下降算法是否正确。&lt;/p&gt;
&lt;p&gt;函数在某点的梯度如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727221002881-2147230006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;神经网络中的梯度检查如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727221102423-1571288891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727221114647-150513603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.w,b组成的函数J(w,b),把w,b看做一个向量θ,&lt;/p&gt;
&lt;p&gt;2.反向传播的dw,db组成一个向量dθ&lt;/p&gt;
&lt;p&gt;则对1的求导应约等于2中的dθ,如上图所示&lt;/p&gt;
&lt;p&gt;通过比较两者的欧式距离(Euclidean),来比较两者的相似度&lt;/p&gt;
&lt;p&gt;一般来说，如果欧氏距离越小，例如&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-94-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;10&amp;lt;/mn&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;7&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1532&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1533&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1535&quot; class=&quot;mn&quot;&gt;10 &lt;span id=&quot;MathJax-Span-1536&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1537&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1538&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1539&quot; class=&quot;mn&quot;&gt;7  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;10−7 ，甚至更小，则表明&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-95-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;p&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;p&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;o&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1540&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1541&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1542&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1543&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1544&quot; class=&quot;mi&quot;&gt;θ &lt;span id=&quot;MathJax-Span-1545&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1546&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1547&quot; class=&quot;mi&quot;&gt;a&lt;span id=&quot;MathJax-Span-1548&quot; class=&quot;mi&quot;&gt;p&lt;span id=&quot;MathJax-Span-1549&quot; class=&quot;mi&quot;&gt;p&lt;span id=&quot;MathJax-Span-1550&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-1551&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-1552&quot; class=&quot;mi&quot;&gt;x  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 与&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-96-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1553&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1554&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1555&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1556&quot; class=&quot;mi&quot;&gt;θ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 越接近，即反向梯度计算是正确的，没有bugs。如果欧氏距离较大，例如&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-97-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;10&amp;lt;/mn&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;5&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1557&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1558&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1560&quot; class=&quot;mn&quot;&gt;10 &lt;span id=&quot;MathJax-Span-1561&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1562&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1563&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1564&quot; class=&quot;mn&quot;&gt;5  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;10−5 ，则表明梯度计算可能出现问题，需要再次检查是否有bugs存在。如果欧氏距离很大，例如&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-98-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mn&amp;gt;10&amp;lt;/mn&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;3&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1565&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1566&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1568&quot; class=&quot;mn&quot;&gt;10 &lt;span id=&quot;MathJax-Span-1569&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1570&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1571&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-1572&quot; class=&quot;mn&quot;&gt;3  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;10−3 ，甚至更大，则表明&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-99-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;p&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;p&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;o&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1573&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1574&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1575&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1576&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-1577&quot; class=&quot;mi&quot;&gt;θ &lt;span id=&quot;MathJax-Span-1578&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-1579&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1580&quot; class=&quot;mi&quot;&gt;a&lt;span id=&quot;MathJax-Span-1581&quot; class=&quot;mi&quot;&gt;p&lt;span id=&quot;MathJax-Span-1582&quot; class=&quot;mi&quot;&gt;p&lt;span id=&quot;MathJax-Span-1583&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-1584&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-1585&quot; class=&quot;mi&quot;&gt;x  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;与&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-100-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;d&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03B8;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1586&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1587&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1588&quot; class=&quot;mi&quot;&gt;d&lt;span id=&quot;MathJax-Span-1589&quot; class=&quot;mi&quot;&gt;θ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 差别很大，梯度下降计算过程有bugs，需要仔细检查。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 使用梯度检查的注意事项:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201807/1389768-20180727221826012-1221871649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;不要在整个训练过程中都进行梯度检查，仅仅作为debug使用。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果梯度检查出现错误，找到对应出错的梯度，检查其推导是否出现错误。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意不要忽略正则化项，计算近似梯度的时候要包括进去。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;梯度检查时关闭dropout，检查完毕后再打开dropout。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;随机初始化时运行梯度检查，经过一些训练后再进行梯度检查（不常用）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;







&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;/pre&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;code class=&quot;language-python hljs has-numbering&quot;&gt; &lt;/code&gt;&lt;/em&gt;
&lt;/pre&gt;

</description>
<pubDate>Fri, 27 Jul 2018 14:19:00 +0000</pubDate>
<dc:creator>Dar_Alpha</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dar-/p/9379956.html</dc:identifier>
</item>
<item>
<title>Spring中AOP的初窥和入门小案例 - 初心--</title>
<link>http://www.cnblogs.com/wh1520577322/p/9379873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wh1520577322/p/9379873.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;AOP&lt;span&gt;：面向切面编程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;AOP&lt;span&gt;的主要作用：是为了程序员更好的关注&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，专心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;做事&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　加上双引号的意思：所谓业务，是指他的核心，各行业中需要处理的核心事务，核心啊&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　像日志的记录，事务的管理，权限分配等这些交叉业务，同一个项目中使用多次，直接提取出来成为公共的比较好，再用面向切面的方式，进行代码的编辑，业务的实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;AOP&lt;span&gt;的原理 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216909/201807/1216909-20180727214503950-1194595556.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　&lt;strong&gt;&lt;span&gt;入门案例：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　用最基本的方式模拟一道日志的记录和最后执行完业务的操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　&lt;/span&gt;DAO&lt;span&gt;层（一个接口，一个他的实现类，模拟操作修改数据库）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.dao;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*//*&lt;/span&gt;&lt;span&gt;dao层接口&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHellowDAO {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;aop入门案例&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSome();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.dao.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.dao.IHellowDAO;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*//*&lt;/span&gt;&lt;span&gt;dao层实现类&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HellowDAOImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IHellowDAO{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSome() {
        System.out.println(&lt;/span&gt;&quot;数据已经成功写入到DB&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;service&lt;span&gt;层（也是一个接口，一个实现类，主要做的&lt;/span&gt;&lt;span&gt;aop&lt;/span&gt;&lt;span&gt;的增强操作，操作的是&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;层，业务逻辑处理层操作的）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.service;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*//*&lt;/span&gt;&lt;span&gt;service层接口&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHellowService {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;aop入门案例&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSome();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.dao.IHellowDAO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.service.IHellowService;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*//*&lt;/span&gt;&lt;span&gt;service层实现类 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HellowServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IHellowService {
    IHellowDAO dao;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSome() {
        dao.doSome();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHellowDAO getDao() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dao;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDao(IHellowDAO dao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dao =&lt;span&gt; dao;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　新开多的一层，叫&lt;/span&gt;aop&lt;span&gt;层，他就存放了增强的操作（也就是交叉业务，例如日志记录等），此处我放了俩个类，一个执行前置增强，一个后置增强&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.aop;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.MethodBeforeAdvice;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*//*&lt;/span&gt;&lt;span&gt;前置增强&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoggerBefore &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodBeforeAdvice {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; before(Method method, Object[] objects, Object o) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;日志记录&quot;&lt;span&gt;);
    }
}







&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.aop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.AfterReturningAdvice;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*//*&lt;/span&gt;&lt;span&gt;后置增强&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoggerAfter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AfterReturningAdvice {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterReturning(Object o, Method method, Object[] objects, Object o1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;===============after==================&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前置增强，需要实现&lt;/span&gt;MethodBeforeAdvice,&lt;span&gt;后置增强，需要实现&lt;/span&gt;&lt;span&gt;AfterReturningAdvice&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接下来就是书写大配置&lt;/span&gt;xml&lt;span&gt;文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;有个注意的点，由于我用的&lt;/span&gt;idea&lt;span&gt;，他会自动生成上面的&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;的&lt;/span&gt; &lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;xsi&lt;/span&gt;&lt;span&gt;，如果你不是用&lt;/span&gt;&lt;span&gt;idea&lt;/span&gt;&lt;span&gt;的话，手动配置一道吧&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt; 3&lt;/span&gt;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
&lt;span&gt; 4&lt;/span&gt;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;!--aop入门案例起--&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;!--dao--&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;bean id=&quot;dao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day04aop.dao.impl.HellowDAOImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;!--service--&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;bean id=&quot;service&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day04aop.service.impl.HellowServiceImpl&quot;&amp;gt;
&lt;span&gt;11&lt;/span&gt;         &amp;lt;property name=&quot;dao&quot; ref=&quot;dao&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt;12&lt;/span&gt;     &amp;lt;/bean&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;!--通知--&amp;gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;bean id=&quot;afterAdvice&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day04aop.aop.LoggerAfter&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;bean id=&quot;beforeAdvice&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day04aop.aop.LoggerBefore&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt;16&lt;/span&gt;     &amp;lt;!--aop--&amp;gt;
&lt;span&gt;17&lt;/span&gt;     &amp;lt;aop:config&amp;gt;
&lt;span&gt;18&lt;/span&gt;         &amp;lt;!--切点--&amp;gt;
&lt;span&gt;19&lt;/span&gt;         &amp;lt;aop:pointcut id=&quot;mypointcut&quot; expression=&quot;execution(* *..service.*.*(..))&quot;&amp;gt;&amp;lt;/aop:pointcut&amp;gt;
&lt;span&gt;20&lt;/span&gt;         &amp;lt;!--&amp;lt;aop:pointcut id=&quot;mypointcut&quot; expression=&quot;execution(public void cn.dawn.day04aop.service.IHellowService.doSome())&quot;&amp;gt;&amp;lt;/aop:pointcut&amp;gt;--&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;!--&amp;lt;aop:pointcut id=&quot;mypointcut&quot; expression=&quot;execution(* *..service.*.*(..))&quot;&amp;gt;--&amp;gt;
&lt;span&gt;22&lt;/span&gt;         &amp;lt;!--顾问，织入--&amp;gt;
&lt;span&gt;23&lt;/span&gt;         &amp;lt;aop:advisor advice-ref=&quot;beforeAdvice&quot; pointcut-ref=&quot;mypointcut&quot;&amp;gt;&amp;lt;/aop:advisor&amp;gt;
&lt;span&gt;24&lt;/span&gt;         &amp;lt;aop:advisor advice-ref=&quot;afterAdvice&quot; pointcut-ref=&quot;mypointcut&quot;&amp;gt;&amp;lt;/aop:advisor&amp;gt;
&lt;span&gt;25&lt;/span&gt;     &amp;lt;/aop:config&amp;gt;
&lt;span&gt;26&lt;/span&gt;     &amp;lt;!--aop入门案例完毕--&amp;gt;
&lt;span&gt;27&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　&lt;span&gt;这儿有一个切点&lt;/span&gt;&lt;/span&gt;&lt;span&gt;pointcut&lt;span&gt;，我说一下他的&lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;的属性吧，他就是里面放一个匹配的（可以说叫公式？）方法的公式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　他的使用规则我放在下面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216909/201807/1216909-20180727215044694-1236999758.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;span&gt;　&lt;span&gt;接下来单测方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.dawn.day03printer.printer.Printer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.dawn.day04aop.service.IHellowService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/3.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test20180305 {
    @Test
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;aop入门案例&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; t01(){
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;ApplicationContext-day04aop.xml&quot;&lt;span&gt;);
        IHellowService service &lt;/span&gt;= (IHellowService) context.getBean(&quot;service&quot;&lt;span&gt;);
        service.doSome();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　运行结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216909/201807/1216909-20180727215144250-363463396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;04.&lt;/strong&gt;&lt;a href=&quot;http://www.cnblogs.com/DawnCHENXI/p/8510689.html&quot;&gt;&lt;strong&gt;&lt;span&gt;Spring&lt;span&gt;的&lt;/span&gt;&lt;span&gt;DI&lt;/span&gt;&lt;span&gt;的构造注入，&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;命名注入，和集合注入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;DI&lt;span&gt;和&lt;/span&gt;&lt;span&gt;IOC&lt;/span&gt;&lt;span&gt;相比，&lt;/span&gt;&lt;span&gt;DI&lt;/span&gt;&lt;span&gt;更偏向于实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;DI&lt;span&gt;的&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;方式注入在前面入门案例里有写，所以此处不多啰嗦，直接开搞，先说构造注入和&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;命名注入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　构造方式，理所当然要有带参构造，这儿值得注意的是，你最好再补全一个无参构造，因为你写了带参构造，系统就不再会为你默认补全一个无参构造了，当你在不经意或者不知情的情况下被调用了，就会报错&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　&lt;/span&gt;P&lt;span&gt;命名则有注意的是那个头文件&lt;/span&gt; &lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;xsi&lt;/span&gt;&lt;span&gt;需要你去配置一道，我下面有，你直接&lt;/span&gt;&lt;span&gt;copy&lt;/span&gt;&lt;span&gt;就可以&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day05diup;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String color;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String type;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getColor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setColor(String color) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setType(String type) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day05diup;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*///&lt;/span&gt;&lt;span&gt;student类public class Student {&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;带参构造&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student(String name, Integer age, Car car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无参构造&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; car;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCar(Car car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;在大配置&lt;/span&gt;xml&lt;span&gt;文件中&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd &quot;&amp;gt;

    &amp;lt;bean id=&quot;car&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day05diup.Car&quot;&amp;gt;
        &amp;lt;property name=&quot;color&quot; value=&quot;黑色&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;type&quot; value=&quot;奥迪&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--di构造注入--&amp;gt;
    &amp;lt;!--&amp;lt;bean id=&quot;student&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day05diup.Student&quot;&amp;gt;
        &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;孟六&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;20&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg index=&quot;2&quot; ref=&quot;car&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;

    &amp;lt;!--p命名注入--&amp;gt;
    &amp;lt;bean id=&quot;student&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.dawn.day05diup.Student&quot; p:name=&quot;孟小六&quot; p:age=&quot;8&quot; p:car-ref=&quot;car&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;没有什么好讲的，带参构造的注入方法，&lt;/span&gt;index&lt;span&gt;索引从&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;开始，对应的是那个带参构造的&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　单测方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;diP命名注入&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; t02(){
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;ApplicationContext-day05diup.xml&quot;&lt;span&gt;);
        Student student &lt;/span&gt;= (Student) context.getBean(&quot;student&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;学生&quot;+student.getName()+&quot;开着&quot;+student.getCar().getColor()+&quot;的&quot;+&lt;span&gt;student.getCar().getType());
    }



    @Test
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;di构造注入&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; t01(){
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;ApplicationContext-day05diup.xml&quot;&lt;span&gt;);
        Student student &lt;/span&gt;= (Student) context.getBean(&quot;student&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;学生&quot;+student.getName()+&quot;开着&quot;+student.getCar().getColor()+&quot;的&quot;+&lt;span&gt;student.getCar().getType());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;集合注入：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　数组，&lt;/span&gt;List&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　实体类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.dawn.day05diup;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by Dawn on 2018/3/5.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyCollection {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] array;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; list;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; set;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt; map;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Properties properties;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;MyCollection{&quot; +
                &quot;array=&quot; + Arrays.toString(array) +
                &quot;, list=&quot; + list +
                &quot;, set=&quot; + set +
                &quot;, map=&quot; + map +
                &quot;, properties=&quot; + properties +
                '}'&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] getArray() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setArray(String[] array) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.array =&lt;span&gt; array;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getList() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setList(List&amp;lt;String&amp;gt;&lt;span&gt; list) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; getSet() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; set;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSet(Set&amp;lt;String&amp;gt;&lt;span&gt; set) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.set =&lt;span&gt; set;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMap(Map&amp;lt;String, String&amp;gt;&lt;span&gt; map) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map =&lt;span&gt; map;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Properties getProperties() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; properties;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProperties(Properties properties) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.properties =&lt;span&gt; properties;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;大配置中的bean节点
 

&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;di的集合注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mycollection&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.dawn.day05diup.MyCollection&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;数组注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;array&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;array&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;孟六&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;孟六十六&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;孟六百六十六&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;array&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;list集合注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;奥迪&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;奥小迪&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;奥迪迪&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;set集合注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;set&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;set1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;set2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;set3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;map集合注入&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;map&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;姓名&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;孟五&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;年龄&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;555&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;v1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;v2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;v3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;单测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  @Test
    /*di集合注入*/
    public void t03(){
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;ApplicationContext-day05diup.xml&quot;);
        MyCollection mycollection = (MyCollection) context.getBean(&quot;mycollection&quot;);
        System.out.println(mycollection);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;span&gt;由于重写了&lt;/span&gt;&lt;/span&gt;&lt;span&gt;toString&lt;span&gt;，可以直接一览无余&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;这里我扩充一下 java 中的tostring();&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; toString()&lt;span&gt;方法&lt;/span&gt; &lt;span&gt;相信大家都用到过，一般用于以字符串的形式返回对象的相关数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;翻译一下官方解释：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　&lt;/span&gt;1&lt;span&gt;、返回一个对于这个&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt; &lt;span&gt;简明的、可读的 的字符串&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　&lt;/span&gt;2&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;类的子类被鼓励去重写这个方法来提供一个实现用于描述对象的类型和数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;自己的理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;写这个方法的用途就是为了方便操作，所以在文件操作里面可用可不用&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;就是一个类中有集合&lt;/span&gt; &lt;span&gt;当你输出这个集合时它会以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216909/201807/1216909-20180727220046872-1721337482.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种可以直接换算成字符串&lt;/span&gt; &lt;span&gt;十分的方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有&lt;/span&gt; toString()    &lt;span&gt;将会打印出来内存地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1216909/201807/1216909-20180727220058600-986714237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更方便咱们程序员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 14:02:00 +0000</pubDate>
<dc:creator>初心--</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wh1520577322/p/9379873.html</dc:identifier>
</item>
<item>
<title>Java同步—线程锁和条件对象 - 吃了炫迈的猫°</title>
<link>http://www.cnblogs.com/Fill/p/9379776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fill/p/9379776.html</guid>
<description>&lt;p&gt;在大多数多线程应用中，都是两个及以上线程需要共享对同一数据的存取，所以有可能出现两个线程同时访问同一个资源的情况，这种情况叫做：&lt;strong&gt;竞争条件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Java中为了解决并发的数据访问问题，一般使用&lt;u&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;/u&gt;这个概念来解决。&lt;/p&gt;
&lt;p&gt;有几种机制防止代码收到并发访问的干扰：&lt;/p&gt;
&lt;p&gt;1.synchronized关键字（自动创建一个锁及相关的条件）&lt;/p&gt;
&lt;p&gt;2.ReentrantLock类+Java.util.concurrent包中的lock接口（在Java5.0的时候引入）&lt;/p&gt;
&lt;h3 id=&quot;reentrantlock的使用&quot;&gt;ReentrantLock的使用&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public void Method() {
        boolean flag = false;//标识条件
        ReentrantLock locker = new ReentrantLock();
        locker.lock();//开启线程锁
        try {
            //do some work...
        } catch (Exception ex) {

        } finally {
            locker.unlock();//解锁线程
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;locker.lock();&lt;/code&gt;&lt;br/&gt;确保只有一个线程进入临界区，一旦一个线程进入之后，会获得锁对象，其他线程无法通过lock语句。当其他线程调用lock时，它们会被阻塞，知道第一个线程释放锁对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;locker.unlock();&lt;/code&gt;&lt;br/&gt;解锁操作，一定要放到finally里，因为如果try语句里出了问题，锁必须被释放，否则其他线程将永远被阻塞&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为系统会随机为线程分配资源，所以在线程获得锁对象之后，可能被系统剥夺运行权，这时候其他线程来访问，但是发现有锁，进不去，只能等拿到锁对象的线程把里面的代码执行完毕后，释放锁，第二个线程才能运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设说做一个银行转账的功能，线程锁操作应该定义在&lt;strong&gt;银行类&lt;/strong&gt;的&lt;strong&gt;转账方法&lt;/strong&gt;里，因为这样每个银行对象都有一个锁对象，两个线程访问一个银行对象的时候，那么锁以串行方式提供服务。但是，如果每个线程访问不同的银行对象，每个线程都会得到不同的锁对象，彼此之间不会冲突，所以就不会造成不必要的线程阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁是可重入的，线程可以重复获得已经持有的锁，锁通过一个持有&lt;em&gt;数量计数&lt;/em&gt;来跟踪对lock方法的嵌套使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设说，一个线程获得锁之后，要执行A方法，但是A方法里面又调用了B方法，这时候这个线程获得了两个锁对象，当线程执行B方法的时候，也会被锁死，防止其他线程乱入，当B方法执行完毕后，锁对象变成了一个，当A方法也执行完毕的时候，锁对象变成了0个，线程释放锁。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;synchronized关键字&quot;&gt;synchronized关键字&lt;/h3&gt;
&lt;p&gt;前面我们讲了ReentrantLock锁对象的使用，但是在系统里面我们不一定要使用ReentrantLock锁，Java中还提供了一个内部的&lt;strong&gt;隐式锁&lt;/strong&gt;，关键字是&lt;strong&gt;synchronized&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized void Method() {
    //do some work...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要在返回值前面加上synchronized锁，就会实现上面ReentrantLock锁同样的效果.&lt;/p&gt;
&lt;h3 id=&quot;conditional条件对象&quot;&gt;Conditional条件对象&lt;/h3&gt;
&lt;p&gt;通常，线程拿到锁对象之后，却发现需要满足某一条件才能继续向下执行。&lt;/p&gt;
&lt;p&gt;拿银行程序来举例子，我们需要转账方账户有足够的资金才能转出到目标账户，这时候需要用到ReentrantLock对象，因为如果我们已经完成转账方账户有足够的资金的判断之后，线程被其他线程中断，等其他线程执行完之后，转账方的钱又没有了足够的资金，这时候因为系统已经完成了判断，所以会继续向下执行，然后银行系统就会出现问题。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void Transfer(int from, int to, double amount) {
    if (Accounts[from] &amp;gt; amount)//系统在结束判断之后被剥夺运行权,然后账户通过网银转出所有钱,银行凉凉
        DoTransfer(from, to, amount);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们就需要使用ReentrantLock对象了，我们修改一下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void Transfer(int from, int to, double amount) {
    ReentrantLock locker = new ReentrantLock();
    locker.lock();
    try {
        while (Accounts[from] &amp;lt; amount) {
            //等待有足够的钱
        }
        DoTransfer(from, to, amount);
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        locker.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样又有了问题，当前线程获取了锁对象之后，开始执行代码，发现钱不够，进入等待状态，然后其他线程又因为锁的原因无法给该账户转账，就会一直进入等待状态。&lt;/p&gt;
&lt;p&gt;这个问题如何解决呢？&lt;/p&gt;
&lt;p&gt;条件对象登场！&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void Transfer(int from, int to, double amount) {
    ReentrantLock locker = new ReentrantLock();
    Condition sufficientFunds = locker.newCondition();//条件对象，
    lock.lock();
    try {
        while (Accounts[from] &amp;lt; amount) {
            sufficientFunds.await();
            //等待有足够的钱
        }
        DoTransfer(from, to, amount);
        sufficientFunds.signalAll();
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        locker.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;条件对象的关键字是:&lt;strong&gt;Condition&lt;/strong&gt;，一个锁对象可以有一个或多个相关的条件对象。可以通过&lt;strong&gt;&lt;em&gt;锁对象.newCondition&lt;/em&gt;&lt;/strong&gt;方法获得一个条件对象.&lt;/p&gt;
&lt;p&gt;一般关于条件对象的命名需要能够反映它表达的条件的名字，所以在这里我们叫他sufficientFund，表示&lt;strong&gt;余额充足&lt;/strong&gt;的意思。&lt;/p&gt;
&lt;p&gt;在进入锁之前，我们创建一个条件，然后如果金额不足，在这里调用条件对象的&lt;strong&gt;await&lt;/strong&gt;方法，通知系统当前线程进入&lt;strong&gt;挂起状态&lt;/strong&gt;，让其他线程执行。这样你这次调用会被锁定，然后系统可以再次调用该方法给其他账户转账，当每一次转账完成后，执行转账操作的线程在底部调用&lt;strong&gt;signalAll&lt;/strong&gt;通知所有线程可以继续运行了，因为我们有可能是转足够的钱给当前账户，这时候有可能该线程会继续执行（不一定是你，是通知所有线程，如果通知的线程还是不符合条件，会继续调用&lt;strong&gt;await&lt;/strong&gt;方法，并完成转账操作，然后&lt;strong&gt;通知其他挂起的线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你说为啥不直接通知当前线程？不行，可以调用&lt;strong&gt;signal&lt;/strong&gt;方法只通知一个线程，但是如果这个线程操作的账户还是没钱（不是转账给这个账户的情况），那这个线程又进入等待了，这时候已经没有线程能通知其他线程了，程序死锁，所以还是用signal比较保险。&lt;/p&gt;
&lt;p&gt;以上是使用&lt;strong&gt;ReentrantLock&lt;/strong&gt;+&lt;strong&gt;Condition&lt;/strong&gt;对象，那你说我要是使用&lt;strong&gt;synchronized&lt;/strong&gt;隐式锁怎么办？&lt;/p&gt;
&lt;p&gt;也可以，而且不需要&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void Transfer(int from, int to, double amount) {
     while (Accounts[from] &amp;lt; amount) {
            wait();//这个wait方法是定义在Object类里面的，可以直接用，和条件对象的await一样，挂起线程
            //等待有足够的钱
        }
        DoTransfer(from, to, amount);
        notifyAll();//通知其他挂起的线程
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Object类里面定义了wait、notifyAll、notify方法，对应await、signalAll和signal方法，用来操作隐式锁，&lt;strong&gt;synchronized只能有一个条件，而ReentrantLock显式声明的锁可以用绑定多个Condition条件.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;同步块&quot;&gt;同步块&lt;/h3&gt;
&lt;p&gt;除了我们上面讲的两种获取线程锁的方式，还有另外一种机制获得锁，这种方式比较特殊，叫做&lt;strong&gt;同步块&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Object locker = new Object();
synchronized (locker) {
    //do some work
}

//也可以直接锁当前类的对象
sychronized(this){
    //do some work
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码会获得Object类型locker对象的锁，这种锁是一个特殊的锁，在上面的代码中，创建这个Object类对象只是单纯用来使用其持有的锁.&lt;/p&gt;
&lt;p&gt;这种机制叫做&lt;strong&gt;同步块&lt;/strong&gt;，应用场景也很广：有的时候，我们并不是整个一个方法都需要同步，只是方法里的部分代码块需要同步，这种情况下，我们如果将这个方法声明为&lt;strong&gt;synchronized&lt;/strong&gt;，尤其是方法很大的时候，会造成很大的资源浪费。所以在这种情况下我们可以使用&lt;strong&gt;synchronized&lt;/strong&gt;关键字来声明同步块:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void Method() {
    //do some work without synchronized
    synchronized (this) {
        //do some synchronized operation
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;监视器的概念&quot;&gt;监视器的概念&lt;/h3&gt;
&lt;p&gt;锁和条件是同步中一个很重要的工具，但是它们并不是面向对象的。多年来，Java的研究人员努力寻找一种方法，可以在不需要考虑如何加锁的情况下，就能保证多线程的安全性。最成功的的一个解决方案叫做&lt;strong&gt;monitor&lt;/strong&gt;监视器，&lt;strong&gt;这个对象内置于每一个Object变量中，相当于一个许可证。拿到许可证就可以进行操作，没有拿到则需要阻塞等待。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;监视器具有以下特性:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.监视器是只包含私有域的类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.每个监视器对象都有一个相关的锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.使用监视器对象的锁对所有的方法进行加锁&lt;/strong&gt;（举个例子:如果调用&lt;strong&gt;obj.Method&lt;/strong&gt;方法，&lt;strong&gt;obj对象的锁会在方法调用的时候自动获得&lt;/strong&gt;，当&lt;strong&gt;方法结束或返回之后会自动释放该锁&lt;/strong&gt;。&lt;strong&gt;因为所有的域都是私有的，这样可以确保一个线程在操作类对象的时候，没有其他线程可以访问里面的域&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.该锁对象可以有任意多个相关条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你也可以自己创建一个监视器类，只要符合以上的要求即可。&lt;/p&gt;
&lt;p&gt;其实我们使用的&lt;strong&gt;synchronized&lt;/strong&gt;关键字就是使用了&lt;strong&gt;monitor&lt;/strong&gt;来实现&lt;strong&gt;加锁解锁&lt;/strong&gt;，所以又被称为&lt;strong&gt;内部锁&lt;/strong&gt;。&lt;strong&gt;因为Object类实现了监视器，所以对象又被内置于任何一个对象之中。&lt;/strong&gt;这就是我们为什么可以使用&lt;strong&gt;synchronized(locker)&lt;/strong&gt;的方式锁定一个代码块了，其实只是用到了locker对象中内置的monitor而已。&lt;strong&gt;每一个对象的monitor类又是唯一的，所以就是唯一的许可证，拿到许可证的线程才可以执行，执行完后释放对象的monitor才可以被其他线程获取。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized (this) {
    //do some synchronized operation
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它在字节码文件中会被编译为:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;monitorenter;//get monitor，enter the synchronized block
            //do some synchronized operation
monitorexit;//leavel the synchronized block,release the monitor&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 27 Jul 2018 13:39:00 +0000</pubDate>
<dc:creator>吃了炫迈的猫&amp;#176;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fill/p/9379776.html</dc:identifier>
</item>
<item>
<title>spring AOP面向切面编程 - kin1492</title>
<link>http://www.cnblogs.com/kin1492/p/9379621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kin1492/p/9379621.html</guid>
<description>&lt;h2&gt;spring AOP切面编程&lt;/h2&gt;
&lt;p&gt;面向切面编程就是将程序中经常用到的功能抽取出来形成独立于程序业务逻辑的一个切面，当你的程序要用到的时候不要修改原来的业务代码就能将切面的功能嵌入到你的程序里面。而spring AOP 正是来帮我们实现这样的功能的。通过spring AOP能降低程序耦合性，比如在程序中经常要记录操作日志，安全认证等功能。传统上来说我们会写一个类用来专门写日志，一个类需要写日志的时候只需要调用那个写日志的类执行相应的方法就行了，这样一个类就对另一个类产生了依赖。通过spring AOP我们不用在我们的业务代码里关心业务以外的代码，只需要实现我们的业务代码就行，其他的都给切面。这个有点像python中的装饰器，对python熟悉的就容易理解了，而在python中也很容实现，这是函数式编程的一大特点吧，但是对于纯面向对象的java来说实现就得借助动态代理来实现了，本博客只是简单的介绍什么是spring AOP以及其用法，对于其实现原理感兴趣的可以自己研究。&lt;/p&gt;
&lt;p&gt;从一个小需求说起：一天老板对你说：你把这个程序中所有函数的执行时间给我打印出来，？？？没接触过spring AOP的一个一个方法的改啊改啊。。。。。生无可恋有没有，所有的方法。。。。怎么办？？不干了，辞职！！哈哈，开个玩笑。这么简单的事，用spring AOP立马就解决。&lt;/p&gt;
&lt;p&gt;一个小的demo&lt;/p&gt;
&lt;p&gt;intellij idea建一个maven项目&lt;/p&gt;
&lt;p&gt;file --&amp;gt;new Project ---&amp;gt;Maven&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180727195636785-531273224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180727195850429-601768995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择自己的仓库位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180727200118993-1684072825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置项目位置，点下一步项目就创建好了。&lt;/p&gt;
&lt;p&gt;配置程序的依赖包，pom.xml文件如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
  xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;spring_aop&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring_aop&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

  &amp;lt;name&amp;gt;spring_aop Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;!-- FIXME change it to the project's website --&amp;gt;
  &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.example.com&amp;lt;/url&amp;gt;&lt;/span&gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--spring相关包--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.3.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- AspectJ --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;aspectjrt&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.6.10&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.7.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;


  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;spring_aop&amp;lt;/finalName&amp;gt;
    &amp;lt;pluginManagement&amp;gt;&amp;lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&amp;gt;
      &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-clean-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;!-- see http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&amp;gt;&lt;/span&gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.20.1&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-install-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.5.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-deploy-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
    &amp;lt;/pluginManagement&amp;gt;
  &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main 下新建一个resource文件，并标志为Resource Root，并创建一个bean.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;!--目标类--&amp;gt;
 &amp;lt;bean id=&quot;stdServer&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.cqh.spring.demo.services.StudentServer&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;main下新建java文件夹并将java文件夹标志为Source&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180727200851299-1964605692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建pacakge和类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180727204132188-1462287537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;StudentServer类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cqh.spring.demo.services;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentServer {


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addStudent(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务逻辑，&lt;/span&gt;
            System.out.println(&quot;执行新增学生业务&quot;&lt;span&gt;);
            Thread.sleep(&lt;/span&gt;10000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateStudent(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务逻辑，&lt;/span&gt;
            System.out.println(&quot;执行修改学生业务&quot;&lt;span&gt;);
            Thread.sleep(&lt;/span&gt;50000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cqh.spring.demo.main;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cqh.spring.demo.services.StudentServer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        ClassPathXmlApplicationContext ac &lt;/span&gt;=
                &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;bean.xml&quot;&lt;span&gt;);
        StudentServer s &lt;/span&gt;= (StudentServer)ac.getBean(&quot;stdServer&quot;&lt;span&gt;);
        s.addStudent();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在执行，会看到addStudent运行了，只是打印了执行新增学生业务，并没有输出方法的执行时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
执行新增学生业务
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来神奇事就要发生了，在bean.xml中添加如下配置，同时TiemAspect的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;

    &amp;lt;!--目标类--&amp;gt;
 &amp;lt;bean id=&quot;stdServer&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.cqh.spring.demo.services.StudentServer&quot;&amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;!--切面类--&amp;gt;
 &amp;lt;bean id=&quot;timeAspect&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.cqh.spring.demo.aop.TimeAspect&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;!--切面配置--&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut id=&quot;std&quot; expression=&quot;execution(* com.cqh.spring.demo.services.*.*(..))&quot;/&amp;gt;

        &amp;lt;aop:aspect ref=&quot;timeAspect&quot;&amp;gt;
            &amp;lt;aop:around method=&quot;recorderTime&quot; pointcut-ref=&quot;std&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;

    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cqh.spring.demo.aop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 切面类，独立于业务逻辑外的功能
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeAspect {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 记录方法的执行时间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; point
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; recorderTime(ProceedingJoinPoint point){
        Long startTime &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            point.proceed();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable throwable) {
            throwable.printStackTrace();
        }
        Long endTime &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
        System.out.print(&lt;/span&gt;&quot;执行时间：&quot;+(endTime-startTime)+&quot;ms&quot;&lt;span&gt;);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次运行main，等了大约10s,会发现时间已经出来了吧，在没有修改addStudent方法业务代码的基础上，把addStudent方法的执行时间输出来了吧，这样任务就完成了。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;spring AOP面向切面：在不修改原有业务功能的基础给原来的方法扩展功能，其方式之一：使用配置，方式二：使用@Aspect相关注解。这里使用的是配置的方式。&lt;/p&gt;
&lt;p&gt;要配置的东西如下：&lt;/p&gt;
&lt;p&gt;1. 目标方法，也就是你要给他扩展功能的方法 ，也就常说的切入点表达式&lt;/p&gt;
&lt;p&gt;这里对应于expression=&quot;execution(* com.cqh.spring.demo.services.*.*(..)) 的内容&lt;/p&gt;
&lt;p&gt;切入点的完整的格式 &lt;span/&gt;&lt;/p&gt;
&lt;p&gt; modifiers-pattern 修饰符 可选 public private protected&lt;/p&gt;
&lt;p&gt;ret-type-pattern 返回类型 必选 * 代表任意类型&lt;/p&gt;
&lt;p&gt;declaring-type-pattern 方法的声明类型&lt;/p&gt;
&lt;p&gt;name-patterm 方法名称类型&lt;/p&gt;
&lt;p&gt;set* 以set开头的所有的方法名称&lt;/p&gt;
&lt;p&gt;update* 以update开头的所有的方法名称&lt;/p&gt;
&lt;p&gt;param-pattern 参数匹配&lt;/p&gt;
&lt;p&gt;　　(..) 任意多个参数，每个参数任意多个类型&lt;/p&gt;
&lt;p&gt;　　(*,String) 两个参数 第一个是任意类型，第二个是String&lt;/p&gt;
&lt;p&gt;　　(String,*,Integer) 三个参数，第一个是String类型，第二个是任意类型，第三个是Integer类型&lt;/p&gt;
&lt;p&gt;　　throws-pattern 异常的匹配模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　execution(* com.cqh.spring.demo.services.*(..));cn.itcast.spring.aop.xml.AService下的所有的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　execution(public * com.cqh.spring.demo.services.*.*(..)) 返回值为任意类型，修饰符为public，在com.cqh.spring.demo.services包及子包下的所有的类的所有的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　exectuion(* com.cqh.spring..*.update*(*,String))返回值是任意类型，在com.cqh.spring包及子包下所有的以update开头的参数为两个，第一个为任意类型第二个为String类型的&lt;/span&gt;所有类的所有的方法&lt;/p&gt;
&lt;p&gt;2.设置通知，也就是在切面类里面的方法&lt;/p&gt;
&lt;p&gt;在spring AOP里面有5中类型的通知&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1446360/201807/1446360-20180727211705076-353865409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前置通知就是在目标方法执行之前执行，使用&amp;lt;aop:before  method=&quot;func1&quot; pointcut-ref=&quot;std&quot;/&amp;gt;来设置 ，这样会找到其切面类里面对应的func1方法（根据method属性），通过pointcut-ref找到切入点这里是&lt;/p&gt;
&lt;pre&gt;
&amp;lt;aop:pointcut id=&quot;std&quot; expression=&quot;execution(* com.cqh.spring.demo.services.*.*(..))&quot;/&amp;gt;
&lt;/pre&gt;
&lt;p&gt;  也就是只要能匹配上这个切入点表达式的方法在执行之前都会执行func1，而我们可以在func1里面决定是否继续执行目标方法&lt;/p&gt;
&lt;p&gt;应用：一个用户发来一个请求，会调用查看用户信息的方法，需要权限的控制，而权限的控制不属于业务，因此就需要在切面授权，有权限放行继续执行查看用户信息的业务方法&lt;/p&gt;
&lt;p&gt;否则不再执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Auth(ProceedingJoinPoint point){
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; authentic = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询是否有权限，代码省略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (authentic){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放行&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                point.proceed();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行后面的通知或目标方法&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable throwable) {
                throwable.printStackTrace();
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;no privilege !!!!!!!&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后置通知在目标方法之后执行，无论目标方法是否发生异常都会执行，使用&amp;lt;aop:after method=&quot;&quot;  pointcut-ref=&quot;xxxx&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;返回后通知在目标方法成功执行后执行，使用&amp;lt;aop:after-returning method=&quot;func3&quot; pointcut-ref=&quot;&quot; returning=&quot;ret&quot;/&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; point
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ret  目标方法的返回值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; func3(JoinPoint point, Object ret){
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;环绕通知，在目标方法之前和目标方法执行之后都会执行。这里打印目标方法执行的时间就是用的环绕通知。&lt;/p&gt;
&lt;p&gt;抛出异常后通知使用 &amp;lt;aop:after-throwing method=&quot;error&quot; throwing=&quot;e&quot; pointcut-ref=&quot;xxx&quot;/&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; point
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e  目标方法抛出的异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; error(JoinPoint point,Throwable e){
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这基本的使用配置的方式就介绍完了。思考：怎么使用spring aop记录详细的日志，比如每个业务方法在调用时，记录如下信息：当前登录的用户 操作的业务 调用的方法，操作的时间给记录到数据库&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 13:00:00 +0000</pubDate>
<dc:creator>kin1492</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kin1492/p/9379621.html</dc:identifier>
</item>
<item>
<title>设计模式（二十三）—— 模板方法 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9361918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9361918.html</guid>
<description>&lt;h2 id=&quot;模式简介&quot;&gt;模式简介&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日常开发过程中我们经常会遇到一些行为结构大致相同，具体实现不同的场景。例如，开发一款文档读取工具，读取文档大致步骤可以抽象为打开文档-&amp;gt;读取内容-&amp;gt;关闭文档，但是根据文档类型不同，又需要一些具体的操作来完成这些行为(操作text文档和excel文档的方法是不同的)。这种情况下，就可以用抽象的操作定义算法骨架，在子类中重定义这些操作以提供具体的行为。&lt;/p&gt;
&lt;h2 id=&quot;结构分析&quot;&gt;结构分析&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;uml类图&quot;&gt;UML类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180724184139803-584783427.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色说明&quot;&gt;角色说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;AbstractClass&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;抽象类。定义一系列抽象方法，具体的操作延迟到子类实现，并提供一个模板方法，定义整个算法的骨架。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConcreteClass&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体类。实现抽象类中的抽象方法。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;抽象类中提供模板方法定义算法骨架，将具体的操作延迟到子类中实现。&lt;/p&gt;
&lt;h3 id=&quot;结构代码&quot;&gt;结构代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//抽象类
public abstract class AbstractClass
{
    public abstract void PrimitiveOperation1();
    public abstract void PrimitiveOperation2();
    public void TemplateMethod()
    {
        PrimitiveOperation1();
        PrimitiveOperation2();
    }
}

//具体类A
public class ConcreteClassA : AbstractClass
{
    public override void PrimitiveOperation1()
    {
        Console.WriteLine(&quot;ConcreteClassA.PrimitiveOperation1&quot;);
    }

    public override void PrimitiveOperation2()
    {
        Console.WriteLine(&quot;ConcreteClassA.PrimitiveOpeartion2&quot;);
    }
}

//具体类B
public class ConcreteClassB : AbstractClass
{
    public override void PrimitiveOperation1()
    {
        Console.WriteLine(&quot;ConcreteClassB.PrimitiveOperation1&quot;);
    }

    public override void PrimitiveOperation2()
    {
        Console.WriteLine(&quot;ConcreteClassB.PrimitiveOperation2&quot;);
    }
}

//客户端调用
class Program
{
    static void Main(string[] args)
    {
        AbstractClass a = new ConcreteClassA();
        a.TemplateMethod();

        AbstractClass b = new ConcreteClassB();
        b.TemplateMethod();
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180724183503486-622236837.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例分析&quot;&gt;示例分析&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;本节模拟文章开头提到的文档读取器示例，首先声明文档读取器抽象类，通过DoRead方法定义文档读取的骨架。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class DocumentReader
{
    protected string _fileName;
    public DocumentReader(string fileName)
    {
        _fileName = fileName;
    }
    public abstract void Open();
    public abstract void Read();
    public abstract void Close();
    public void DoRead()
    {
        Open();
        Read();
        Close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明具体类TextReader和ExcelReader，分别实现抽象类中的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TextReader : DocumentReader
{
    public TextReader(string path) : base(path)
    {
    }

    public override void Close()
    {
        Console.WriteLine($&quot;Closing Text file : [{_fileName}]&quot;);
    }

    public override void Open()
    {
        Console.WriteLine($&quot;Openning Text file : [{_fileName}]&quot;);
    }

    public override void Read()
    {
        Console.WriteLine($&quot;Reading Text file : [{_fileName}]&quot;);
    }
}

public class ExcelReader : DocumentReader
{
    public ExcelReader(string path) : base(path)
    {
    }

    public override void Close()
    {
        Console.WriteLine($&quot;Closing Excel : [{_fileName}]&quot;);
    }

    public override void Open()
    {
        Console.WriteLine($&quot;Openning Excel : [{_fileName}]&quot;);
    }

    public override void Read()
    {
        Console.WriteLine($&quot;Reading Excel : [{_fileName}]&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        string textFileName = &quot;abc.txt&quot;;
        DocumentReader text = new TextReader(textFileName);
        text.DoRead();

        string excelFileName = &quot;abc.xlsx&quot;;
        DocumentReader excel = new ExcelReader(excelFileName);
        excel.DoRead();
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180724193819296-1077737499.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;hr/&gt;</description>
<pubDate>Fri, 27 Jul 2018 12:58:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9361918.html</dc:identifier>
</item>
<item>
<title>令牌桶算法限流 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/9379516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/9379516.html</guid>
<description>&lt;h2&gt;限流&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;限流是对某一时间窗口内的请求数进行限制，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。常用的限流算法有令牌桶和和漏桶，而Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;缓存：缓存的目的是提升系统访问速度和增大系统处理容量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们经常在调别人的接口的时候会发现有限制，比如微信公众平台接口、百度API Store、聚合API等等这样的，对方会限制每天最多调多少次或者每分钟最多调多少次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们自己在开发系统的时候也需要考虑到这些，比如我们公司在上传商品的时候就做了限流，因为用户每一次上传商品，我们需要将商品数据同到到美团、饿了么、京东、百度、自营等第三方平台，这个工作量是巨大，频繁操作会拖慢系统，故做限流。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上都是题外话，接下来我们重点看一下令牌桶算法&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;令牌桶算法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面是从网上找的两张图来描述令牌桶算法：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727184550598-845634570.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727184559491-371099708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;RateLimiter&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot;&gt;https://github.com/google/guava&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727185243164-1080939791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RateLimiter的代码不长，注释加代码432行，看一下RateLimiter怎么用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cjs.example;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.util.concurrent.RateLimiter;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleDateFormat sdf = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RateLimiter rateLimiter = RateLimiter.create(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * tryAcquire尝试获取permit，默认超时时间是0，意思是拿不到就立即返回false
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     @RequestMapping(&quot;/sayHello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (rateLimiter.tryAcquire()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一次拿1个&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             System.out.println(sdf.format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 Thread.sleep(500&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             System.out.println(&quot;limit&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * acquire拿不到就等待，拿到为止
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     @RequestMapping(&quot;/sayHi&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHi() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         rateLimiter.acquire(5); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一次拿5个&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         System.out.println(sdf.format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;hi&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727185756001-2126438531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727192937920-1827417915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727193010457-248832890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727193056009-1747942169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;关于RateLimiter：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;A rate limiter。每个acquire()方法如果必要的话会阻塞直到一个permit可用，然后消费它。获得permit以后不需要释放。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RateLimiter在并发环境下使用是安全的：它将限制所有线程调用的总速率。注意，它不保证公平调用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RateLimiter在并发环境下使用是安全的：它将限制所有线程调用的总速率。注意，它不保证公平调用。Rate limiter（直译为：速度限制器）经常被用来限制一些物理或者逻辑资源的访问速率。这和java.util.concurrent.Semaphore正好形成对照。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个RateLimiter主要定义了发放permits的速率。如果没有额外的配置，permits将以固定的速度分配，单位是每秒多少permits。默认情况下，Permits将会被稳定的平缓的发放。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以配置一个RateLimiter有一个预热期，在此期间permits的发放速度每秒稳步增长直到到达稳定的速率&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;基本用法：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; RateLimiter rateLimiter = RateLimiter.create(2.0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; rate is &quot;2 permits per second&quot;&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; submitTasks(List&amp;lt;Runnable&amp;gt;&lt;span&gt; tasks, Executor executor) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Runnable task : tasks) {
        rateLimiter.acquire(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; may wait&lt;/span&gt;
&lt;span&gt;        executor.execute(task);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727190953899-767102701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SmoothBursty以稳定的速度生成permit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SmoothWarmingUp是渐进式的生成，最终达到最大值趋于稳定&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727191654729-920034681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;源码片段解读：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RateLimiter {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用给定的吞吐量（“permits per second”）创建一个RateLimiter。
     * 通常是QPS
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RateLimiter create(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; permitsPerSecond) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; create(permitsPerSecond, SleepingStopwatch.createFromSystemTimer());
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; RateLimiter create(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; permitsPerSecond, SleepingStopwatch stopwatch) {
        RateLimiter rateLimiter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SmoothBursty(stopwatch, 1.0 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; maxBurstSeconds &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
        rateLimiter.setRate(permitsPerSecond);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rateLimiter;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用给定的吞吐量(QPS)和一个预热期创建一个RateLimiter
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RateLimiter create(&lt;span&gt;double&lt;/span&gt; permitsPerSecond, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; warmupPeriod, TimeUnit unit) {
        checkArgument(warmupPeriod &lt;/span&gt;&amp;gt;= 0, &quot;warmupPeriod must not be negative: %s&quot;&lt;span&gt;, warmupPeriod);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; create(permitsPerSecond, warmupPeriod, unit, 3.0&lt;span&gt;, SleepingStopwatch.createFromSystemTimer());
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; RateLimiter create(
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; permitsPerSecond,
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; warmupPeriod,
            TimeUnit unit,
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; coldFactor,
            SleepingStopwatch stopwatch) {
        RateLimiter rateLimiter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);
        rateLimiter.setRate(permitsPerSecond);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rateLimiter;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SleepingStopwatch stopwatch;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    锁&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Object mutexDoNotUseDirectly;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object mutex() {
        Object mutex &lt;/span&gt;=&lt;span&gt; mutexDoNotUseDirectly;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mutex == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                mutex &lt;/span&gt;=&lt;span&gt; mutexDoNotUseDirectly;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mutex == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    mutexDoNotUseDirectly &lt;/span&gt;= mutex = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mutex;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从RateLimiter中获取一个permit，阻塞直到请求可以获得为止
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 休眠的时间，单位是秒，如果没有被限制则是0.0
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; acquire() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; acquire(1&lt;span&gt;);
    }
  
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从RateLimiter中获取指定数量的permits，阻塞直到请求可以获得为止
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; microsToWait =&lt;span&gt; reserve(permits);
        stopwatch.sleepMicrosUninterruptibly(microsToWait);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1.0 * microsToWait / SECONDS.toMicros(1L&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 预定给定数量的permits以备将来使用
     * 直到这些预定数量的permits可以被消费则返回逝去的微秒数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; reserve(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) {
        checkPermits(permits);
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (mutex()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; reserveAndGetWaitLength(permits, stopwatch.readMicros());
        }
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkPermits(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) {
        checkArgument(permits &lt;/span&gt;&amp;gt; 0, &quot;Requested permits (%s) must be positive&quot;&lt;span&gt;, permits);
    }
    
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; reserveAndGetWaitLength(&lt;span&gt;int&lt;/span&gt; permits, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nowMicros) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; momentAvailable =&lt;span&gt; reserveEarliestAvailable(permits, nowMicros);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; max(momentAvailable - nowMicros, 0&lt;span&gt;);
    }
}
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SmoothRateLimiter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RateLimiter {
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The currently stored permits. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt;&lt;span&gt; storedPermits;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The maximum number of stored permits. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt;&lt;span&gt; maxPermits;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits
     * per second has a stable interval of 200ms.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt;&lt;span&gt; stableIntervalMicros;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The time when the next request (no matter its size) will be granted. After granting a request,
     * this is pushed further in the future. Large requests push this further than small requests.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nextFreeTicketMicros = 0L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; could be either in the past or future&lt;/span&gt;
    
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; reserveEarliestAvailable(&lt;span&gt;int&lt;/span&gt; requiredPermits, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nowMicros) {
        resync(nowMicros);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; returnValue =&lt;span&gt; nextFreeTicketMicros;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; storedPermitsToSpend = min(requiredPermits, &lt;span&gt;this&lt;/span&gt;.storedPermits);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    本次可以获取到的permit数量&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; freshPermits = requiredPermits - storedPermitsToSpend;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    差值，如果存储的permit大于本次需要的permit数量则此处是0，否则是一个正数&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; waitMicros =&lt;span&gt;
            storedPermitsToWaitTime(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.storedPermits, storedPermitsToSpend)
                &lt;/span&gt;+ (&lt;span&gt;long&lt;/span&gt;) (freshPermits * stableIntervalMicros);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    计算需要等待的时间（微秒）&lt;/span&gt;

        &lt;span&gt;this&lt;/span&gt;.nextFreeTicketMicros =&lt;span&gt; LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.storedPermits -= storedPermitsToSpend;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    减去本次消费的permit数&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnValue;
    }
    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; resync(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nowMicros) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if nextFreeTicket is in the past, resync to now&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (nowMicros &amp;gt; nextFreeTicketMicros) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    表示当前可以获得permit&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    计算这段时间可以生成多少个permit&lt;/span&gt;
            storedPermits = min(maxPermits, storedPermits + newPermits);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    如果超过maxPermit，则取maxPermit，否则取存储的permit+新生成的permit&lt;/span&gt;
            nextFreeTicketMicros = nowMicros;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    设置下一次可以获得permit的时间点为当前时间&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;RateLimiter实现的令牌桶算法，不仅可以应对正常流量的限速，而且可以处理突发暴增的请求，实现平滑限流。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过代码，我们可以看到它可以预消费，怎么讲呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nextFreeTicketMicros表示下一次请求获得permits的最早时间。每次授权一个请求以后，这个值会向后推移（PS：想象一下时间轴）即向未来推移。因此，大的请求会比小的请求推得更。这里的大小指的是获取permit的数量。这个应该很好理解，因为上一次请求获取的permit数越多，那么下一次再获取授权时更待的时候会更长，反之，如果上一次获取的少，那么时间向后推移的就少，下一次获得许可的时间更短。可见，都是有代价的。正所谓：要浪漫就要付出代价。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还要注意到一点，就是获取令牌和处理请求是两个动作，而且，并不是每一次都获取一个，也不要想当然的认为一个请求获取一个permit（或者叫令牌），可以再看看前面那幅图&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Stopwatch&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一个以纳秒为单位度量流逝时间的对象。它是一个相对时间，而不是绝对时间。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Stopwatch stopwatch =&lt;span&gt; Stopwatch.createStarted();
System.out.println(&lt;/span&gt;&quot;hahah&quot;&lt;span&gt;);
stopwatch.stop();
Duration duration &lt;/span&gt;=&lt;span&gt; stopwatch.elapsed();
System.out.println(stopwatch);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Semaphore（信号量）&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;一个信号量维护了一系列permits。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次调用acquire()方法获取permit，如果必要的话会阻塞直到有一个permit可用为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用release()方法则会释放自己持有的permit，即用完了再还回去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信号量限制的是并发访问临界资源的线程数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;令牌桶算法 VS 漏桶算法&lt;/h2&gt;
&lt;h3&gt;漏桶&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;令牌桶&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常使用，而牺牲掉了少部分流量，这是合理的，如果因为极少部分流量需要保证的话，那么就可能导致系统达到极限而挂掉，得不偿失。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小定律：排队理论&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Little%27s_law&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Little%27s_law&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;the long-term average number L of customers in a stationary system is equal to the long-term average effective arrival rate λ multiplied by the average time W that a customer spends in the system. Expressed algebraically the law is：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727195445375-1406272747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;在一个固定系统中，顾客的长期平均数量&lt;strong&gt;L&lt;/strong&gt;等于顾客的长期平均到达速率&lt;strong&gt;λ&lt;/strong&gt;乘以顾客在系统中平均花费的时间&lt;strong&gt;W&lt;/strong&gt;。用公式表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727195520820-1749595692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这看起来很容易，但这是一个非常显著的举世瞩目的结果，因为这种关系“不受到达过程的分布，服务分布，服务顺序，或其他任何因素的影响”。这个结果适用于任何系统，特别是适用于系统内的系统。唯一的要求是系统必须是稳定的非抢占式的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;例子&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;例1：找响应时间&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;假设有一个应用程序没有简单的方法来度量响应时间。如果系统的平均数量和吞吐量是已知的，那么平均响应时间就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mean response time = mean number in system / mean throughput&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平均响应时间 = 系统的平均数量 / 平均吞吐量.&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;例2：顾客在店里&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;想象一下，一家小商店只有一个柜台和一个可供浏览的区域，每次只能有一个人在柜台，并且没有人不买东西就离开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这个系统大致是：进入 --&amp;gt; 浏览 --&amp;gt; 柜台结账 --&amp;gt; 离开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个稳定的系统中，人们进入商店的速度就是他们到达商店的速度（我们叫做到达速度），它们离开的速度叫做离开速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相比之下，到达速度超过离开速度代表是一个不稳定的系统，这就会造成等待的顾客数量将逐渐增加到无穷大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面的小定律告诉我们，商店的平均顾客数量L等于有效的到达速度λ乘以顾客在商店的平均停留时间W。用公式表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727195826804-163021892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设，顾客以每小时10个的速度到达，并且平均停留时间是0.5小时。那么这就意味着，任意时间商店的平均顾客数量是5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727195921801-228132830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在假设商店正在考虑做更多的广告，把到达率提高到每小时20。商店必须准备好容纳平均10人，或者必须将每个顾客在商店中的时间减少到0.25小时。商店可以通过更快地结帐或者增加更多的柜台来达到后者的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以把前面的小定律应用到商店系统中。例如，考虑柜台和在柜台前排的队。假设平均有2个人在柜台前排队，我们知道顾客到达速度是每小时10，所以顾客平均必须停留时间为0.2小时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201807/874963-20180727200004348-640104162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这是单机（单进程）的限流，是JVM级别的的限流，所有的令牌生成都是在内存中，在分布式环境下不能直接这么用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们能把permit放到Redis中就可以在分布式环境中用了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/jek123456/article/details/77152571&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/jek123456/article/details/77152571&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/syc001/article/details/72841951&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/syc001/article/details/72841951&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012875897&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000012875897&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/charleslei/article/details/53152883&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/charleslei/article/details/53152883&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.jianshu.com/p/8f548e469bbe&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/8f548e469bbe&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/f-zhao/p/7210158.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/f-zhao/p/7210158.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://m.jb51.net/article/127996.htm&quot; target=&quot;_blank&quot;&gt;https://m.jb51.net/article/127996.htm&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Jul 2018 12:25:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/9379516.html</dc:identifier>
</item>
</channel>
</rss>