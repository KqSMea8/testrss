<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>16.C++-初探标准库 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8642083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8642083.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;在别人代码里,经常看到&lt;span&gt;std命名空间&lt;/span&gt;,比如使用std命名空间里的标准输入输出流对象&lt;span&gt;cout&lt;/span&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;           

using namespace std;

int main()
{
    cout &amp;lt;&amp;lt; &quot;Hello world&quot; &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;span&gt;cout&lt;/span&gt;相当于控制台输出(console out),然后通过&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt;左移操作符,将每个字符打印出来.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;endl&lt;/span&gt;相当于就是&lt;span&gt;'\n'&lt;/span&gt;换行.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来我们便通过&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/8635556.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;上章学习的操作符重载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;,来实现上面功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#include &quot;stdio.h&quot;&lt;br/&gt;const char endl='\n';

class Console{
public:
       Console&amp;amp; operator &amp;lt;&amp;lt;(const char* str)
       {
              printf(&quot;%s&quot;,str);
              return *this;
       } 

       Console&amp;amp; operator &amp;lt;&amp;lt;(char c)
       {
              printf(&quot;%c&quot;,c);
              return *this;
       }
};

Console cout;

int main()
{
       cout&amp;lt;&amp;lt;&quot;Hello world&quot;&amp;lt;&amp;lt;endl;
       return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;上面的操作符重载&lt;span&gt;(&amp;lt;&amp;lt;)&lt;/span&gt;,为什么返回值是&lt;span&gt;return *this&lt;/span&gt;?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为,我们需要连续使用&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt;,比如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
cout&amp;lt;&amp;lt;&quot;Hello word&quot;&amp;lt;&amp;lt;endl;      //等价于:   (cout&amp;lt;&amp;lt;&quot;Hello word&quot;)&amp;lt;&amp;lt;endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行&lt;span&gt;(cout&amp;lt;&amp;lt;&quot;Hello word&quot;)&lt;/span&gt;后,便会将cout对象&lt;strong&gt;&lt;span&gt;return出来&lt;/span&gt;&lt;/strong&gt;,然后继续调用&lt;strong&gt;&lt;span&gt;cout&amp;lt;&amp;lt;endl.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过cout后,便无需再写输出格式了,不会像&lt;span&gt;&lt;strong&gt;printf()&lt;/strong&gt;&lt;/span&gt;那么麻烦了. &lt;/p&gt;
&lt;p&gt;而前辈们已经将cout,cin这些开发成C++标准库了,我们直接调用就好了.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;C++标准库描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C++标准库是由&lt;span&gt;&lt;strong&gt;类库&lt;/strong&gt;&lt;/span&gt; 和&lt;strong&gt;&lt;span&gt;函数库&lt;/span&gt;&lt;/strong&gt; 组成的集合, 不是C++语言的一部分&lt;/li&gt;
&lt;li&gt;C++标准库中定义的类和对象,都位于&lt;span&gt;&lt;strong&gt;std命名空间&lt;/strong&gt;&lt;/span&gt;中&lt;/li&gt;
&lt;li&gt;C++标准库的头文件都&lt;span&gt;&lt;strong&gt;不带.h后缀&lt;/strong&gt;&lt;/span&gt;,比如: &lt;span&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;C++标准库&lt;span&gt;&lt;strong&gt;涵盖了C库&lt;/strong&gt;&lt;/span&gt;的功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++标准库里还实现了多数常用的&lt;strong&gt;&lt;span&gt;数据结构&lt;/span&gt;&lt;/strong&gt;以及类似&lt;span&gt;&lt;strong&gt;C语言的库&lt;/strong&gt;&lt;/span&gt;,比如:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201803/1182576-20180324233402013-1858909436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的&lt;span&gt;&lt;strong&gt;&amp;lt;cstdio&amp;gt;&lt;/strong&gt;&lt;/span&gt;,是将以前C语言的stdio.h包含的内容都被定义在&lt;span&gt;&lt;strong&gt;命名空间std&lt;/strong&gt;&lt;/span&gt;中.&lt;/p&gt;
&lt;p&gt;而以前的&lt;span&gt;&lt;strong&gt;stdio.h&lt;/strong&gt;&lt;/span&gt;的内容是被定义在&lt;strong&gt;&lt;span&gt;全局命名空间&lt;/span&gt;&lt;/strong&gt;中的.&lt;/p&gt;
&lt;p&gt;所以使用C++标准库时,需要使用&lt;span&gt;&lt;strong&gt;using namespace std;&lt;/strong&gt;&lt;/span&gt; 来声明使用std命令空间.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来下章,来&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/8642163.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;学习C++标准库-string类&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 24 Mar 2018 15:42:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8642083.html</dc:identifier>
</item>
<item>
<title>JS面向对象与面向过程 - gxlself</title>
<link>http://www.cnblogs.com/gxlself/p/8642081.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxlself/p/8642081.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向对象编程:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　就是将你的需求抽象成一个对象,然后针对这个对象分析其特征(属性)与动作(方法)--这个对象就称之为类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向过程编程:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　特点:封装,就是将你需要的功能放在一个对象里面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-----------创建一个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Person = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name, height, weight){
　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;&lt;br/&gt;　　this.say = function(){&lt;br/&gt;　　　　console.log(&quot;hello world&quot;);&lt;br/&gt;　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就创建了一个 Person 类,他有三个属性,但是我们同样也可以在类的原型添加属性和方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Person.prototye.work = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
   console.log(&lt;/span&gt;'Java'&lt;span&gt;)      
}&lt;br/&gt;或者你也可以这样写:&lt;br/&gt;Person.prototype = {&lt;br/&gt;　　work: function(){&lt;br/&gt;　　　　console.log('Java')&lt;br/&gt;　　}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是通常我们用来封装类的方式,把我们常用的属性和方法已经封装到我们抽象的Person这个类里面了~&lt;/p&gt;
&lt;p&gt;在使用这个Person这个类的时候我们不能直接使用person类,需要用 new 关键字去实例化(创建)一个新的对象,这样我们就可以通过对象点属相或者方法去访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; peopleOne = &lt;span&gt;new&lt;/span&gt; Person('Mike','180cm','60kg')&lt;br/&gt;console.log(peopleOne.name)   // Mike
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Js是一种基于原型prototype的语言,在原型上添加方法和属性,都可以通过创建的对象去访问.&lt;/p&gt;
&lt;p&gt;原因就在于每创建一个对象时,都有一个原型prototype用于指向其集成的属性和方法~&lt;/p&gt;
&lt;p&gt;所以,我们创建的对象去使用类自身没有封装的方法时,就会通过prototype一级一级查找,通过prototype继承的属性和方法都可以被访问而不会再创建~&lt;/p&gt;
&lt;p&gt;　　constructor大家都不陌生,是构造函数,Js中,当创建一个函数或者对象时都会为其创建一个原型对象prototype,而prototype对象又会像函数中的额this一样创建一个constructor属性,那么这个属性指向的就是拥有整个原型对象的函数或对象..(另外:Js中,万物兼对象,函数function也是对象)..新创建的对象访问类的原型指向的对象可以通过 __proto__ 但是实际开发中,这个并不会使用...&lt;/p&gt;
&lt;p&gt;　　prototype对象中的属性和方法被称为共有属性和共有方法.类也有私有属性和私有方法,通过该类实例的对象不能访问~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span readability=&quot;4&quot;&gt; Person(name,age){&lt;br/&gt;　　//对象公有属性&lt;br/&gt;　　this.name = name;&lt;br/&gt;　　this.age = age&lt;br/&gt;　　//对象公有属性&lt;br/&gt;　　this.say = function () {&lt;br/&gt;　　　　alert('hello')&lt;br/&gt;　　}&lt;br/&gt;//特权方法&lt;br/&gt;　　this.getName = function(){&lt;br/&gt;　　　　return this.name&lt;br/&gt;　　}&lt;br/&gt;　　this.setName = function(newName){&lt;br/&gt;　　　　this.name = newName&lt;br/&gt;　　}&lt;br/&gt;　　&lt;br/&gt;　　//私有属性&lt;br/&gt;　　var num = 100&lt;br/&gt;　　//私有方法&lt;br/&gt;　　function ill(){}&lt;br/&gt;　　&lt;br/&gt;　　//构造器&lt;br/&gt;　　this.setName('mike')&lt;br/&gt;　　}
}&lt;br/&gt;//类静态公有属性&lt;br/&gt;Person.isChinese = true;&lt;br/&gt;//类静态方法&lt;br/&gt;Person.run = function () {&lt;br/&gt;　　console.log('running')&lt;br/&gt;}&lt;p&gt;Person.prototype = {&lt;br/&gt;　　//公有属性&lt;br/&gt;　　isYoung: true,&lt;br/&gt;　　//公有方法&lt;br/&gt;　　sing: function(){&lt;br/&gt;　　　　console.log('singing')&lt;br/&gt;　　}&lt;br/&gt;}&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然我们也可以将类的静态变量通过闭包来实现,例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre readability=&quot;15&quot;&gt;
&lt;span&gt;var&lt;/span&gt; Person = (function(){&lt;br/&gt;　　//静态私有变量&lt;br/&gt;　　var isCute = true&lt;br/&gt;　　//静态私有方法&lt;br/&gt;　　function run() {}&lt;p&gt;　　//返回构造函数&lt;br/&gt;　　return function(name,age){&lt;br/&gt;　　　　//私有变量&lt;br/&gt;　　　　var num = 100&lt;br/&gt;　　　　//私有方法&lt;br/&gt;　　　　function ill(){}&lt;/p&gt;&lt;p&gt;　　　　//特权方法&lt;br/&gt;　　　　this.getName=function(){}&lt;br/&gt;　　　　this.setName=function(newName){}&lt;br/&gt;　　　　//公有属性&lt;br/&gt;　　　　this.name=name;&lt;br/&gt;　　　　//公有方法&lt;br/&gt;　　　　this.draw=function(){}&lt;br/&gt;　　　　//构造器&lt;br/&gt;　　　　this.setName(newName)&lt;br/&gt;　　}&lt;br/&gt;})()&lt;/p&gt;&lt;p&gt;Person.prototype={&lt;br/&gt;　　//静态公有属性&lt;br/&gt;　　isYoung:true,&lt;br/&gt;　　//静态公有方法&lt;br/&gt;　　run:function(){}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 闭包时有限访问弄一个函数作用域中变量的函数,即在一个函数内部创建另一个函数&lt;/p&gt;
&lt;p&gt;我们将这个闭包作为创建对象的构造函数,这样它既是闭包,又是可实例对象的函数,即可访问到类函数作用域中的变量,例如 isCute 这个变量,此时就是静态私有变量, run 方法为静态私有方法...当然闭包内部有自己的私有变量 num ,私有方法 ill ...(以上面闭包为例)&lt;/p&gt;
&lt;p&gt;当然,也可以在闭包内部实现完整的类然后将其返回(return)出去,这里不做示例~&lt;/p&gt;

&lt;p&gt;既然有了类,但是有些人总会不可避免的忘记 new 关键字,这时候,我们需要可以手动为其加个判断,以防没有 new 而出错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var Person = function(name){&lt;br/&gt;　　if(this instanceof Person){&lt;br/&gt;　　　　this.name = name&lt;br/&gt;　　}else{&lt;br/&gt;　　　　return new Person(name)&lt;br/&gt;　　}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时,你就不必再为少了new关键字而出错~~&lt;/p&gt;
&lt;p&gt;本篇结束,后续更新...&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 15:41:00 +0000</pubDate>
<dc:creator>gxlself</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxlself/p/8642081.html</dc:identifier>
</item>
<item>
<title>Dubbo学习1-Hello world - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/hello-dubbo.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/hello-dubbo.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/dubbo.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;互联网技术到今天已经非常成熟和稳定了，其中为了解决高并发、大规模的服务请求，出现了微服务、RPC这样的分布式架构。今天就从头开始学习RPC框架dubbo。&lt;/p&gt;
&lt;h2 id=&quot;为什么要学dubbo&quot;&gt;为什么要学Dubbo&lt;/h2&gt;
&lt;p&gt;关于分布式的解决方案有很多，光RPC框架就有很多种，甚至有人&lt;a href=&quot;http://colobu.com/2018/01/31/benchmark-2018-spring-of-popular-rpc-frameworks/&quot;&gt;比较了RPC框架性能&lt;/a&gt;, 结果显示dubbo垫底，以及spring cloud这种推崇Rest Http请求代替RPC, 那为什么还要学习RPC?&lt;/p&gt;
&lt;p&gt;首先，RPC框架的发展并没有因为Spring Cloud的出现而变的衰弱。其次，历史悠久的市场上大部分公司都会使用RPC来解决分布式问题。&lt;/p&gt;
&lt;p&gt;那么，为啥要选Dubbo? 只能说Dubbo在国内的流行程度远超过gRPC、thrift等，而且中文资料很多，在国内的技术圈混则必须要掌握这个技能。当然，缺点也不少，比如由于官方很长时间没有维护导致Dubbo各种落后。令人惊喜的是，Alibaba已经开始专注开源项目了，dubbo重新开启维护，进入Apache Incubating。然而，很多人也因此选择了其他RPC来代替dubbo。&lt;/p&gt;
&lt;p&gt;Dubbo发音问题： da bou; &lt;code&gt;|ˈdʌbəʊ|&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是rpc&quot;&gt;什么是RPC&lt;/h2&gt;
&lt;p&gt;RPC(Remote Procedure Call)表示远程过程调用。&lt;/p&gt;
&lt;p&gt;两台机器A和B。A部署了首页的服务，想要获取订单信息，订单服务部署在机器B上。这样，A通过远程调用B上的函数(function)来得到信息就属于远程过程调用。&lt;/p&gt;
&lt;p&gt;以下来自&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/25536695/answer/36197244&quot;&gt;谁能用通俗的语言解释一下什么是 RPC 框架？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/rpc.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.首先，要解决通讯的问题。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程调用共享同一个连接。&lt;br/&gt;2.第二，要解决寻址问题。也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器(如主机或IP地址)以及特定的端口，方法的名称是什么，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。&lt;br/&gt;3.第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化(Serialize)或编组(marshal), 通过寻址和传输将序列化的二进制发送给B服务器。&lt;br/&gt;4.第四，B服务器收到请求后，需要对参数进行反序列化(序列化的逆操作)，恢复为内存中的表达方式，然后找到对应的方法(寻址的一部分)进行本地调用，然后得到返回值。&lt;br/&gt;5.第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用。&lt;/p&gt;
&lt;h2 id=&quot;dubbo的产生背景&quot;&gt;Dubbo的产生背景&lt;/h2&gt;
&lt;p&gt;以下来自&lt;a href=&quot;http://dubbo.apache.org/books/dubbo-user-book/preface/architecture.html&quot;&gt;Dubbo官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/dubbo-architecture-roadmap.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;单一应用架构&quot;&gt;单一应用架构&lt;/h3&gt;
&lt;p&gt;当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。&lt;/p&gt;
&lt;h3 id=&quot;垂直应用架构&quot;&gt;垂直应用架构&lt;/h3&gt;
&lt;p&gt;当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。&lt;/p&gt;
&lt;h3 id=&quot;分布式服务架构&quot;&gt;分布式服务架构&lt;/h3&gt;
&lt;p&gt;当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。&lt;/p&gt;
&lt;h3 id=&quot;流动计算架构&quot;&gt;流动计算架构&lt;/h3&gt;
&lt;p&gt;当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。&lt;/p&gt;
&lt;h2 id=&quot;dubbo面临的需求&quot;&gt;Dubbo面临的需求&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/dubbo-service-governance.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。&lt;/strong&gt; 此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系&lt;/strong&gt;。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？&lt;/strong&gt; 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。&lt;/p&gt;
&lt;p&gt;以上是 Dubbo 最基本的几个需求。&lt;/p&gt;
&lt;h2 id=&quot;dubbo的架构&quot;&gt;Dubbo的架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://oe20lp6p0.bkt.clouddn.com/blog/2018/dubbo-architecture.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;节点角色说明&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Provider&lt;/td&gt;
&lt;td&gt;暴露服务的服务提供方&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Consumer&lt;/td&gt;
&lt;td&gt;调用远程服务的服务消费方&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Registry&lt;/td&gt;
&lt;td&gt;服务注册与发现的注册中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Monitor&lt;/td&gt;
&lt;td&gt;统计服务的调用次数和调用时间的监控中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Container&lt;/td&gt;
&lt;td&gt;服务运行容器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;调用关系说明&lt;/p&gt;
&lt;p&gt;1.服务容器负责启动，加载，运行服务提供者。&lt;br/&gt;2.服务提供者在启动时，向注册中心注册自己提供的服务。&lt;br/&gt;3.服务消费者在启动时，向注册中心订阅自己所需的服务。&lt;br/&gt;4.注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。&lt;br/&gt;5.服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;br/&gt;6.服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。&lt;/p&gt;
&lt;p&gt;Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。&lt;/p&gt;
&lt;h2 id=&quot;demo-time&quot;&gt;Demo time&lt;/h2&gt;
&lt;p&gt;首先，确认本次的目标。学习一项技术首先要了解背景以及意义。前文摘自官网的内容已经给出了答案。然后就是一个Hello World, 给学习者一个信心：这东西很容易上手的。So，接下来的demo依旧来自官方，特别简单的一个模拟运行。后面再继续深入用法。&lt;/p&gt;
&lt;p&gt;由于Maven在之前极盛行，demo仍旧用maven当作构建工具，当然，后面熟悉后可切换为gradle。&lt;/p&gt;
&lt;p&gt;本次demo见 &lt;a href=&quot;https://github.com/Ryan-Miao/dubbo-hello-demo&quot; class=&quot;uri&quot;&gt;https://github.com/Ryan-Miao/dubbo-hello-demo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建一个maven项目&quot;&gt;新建一个maven项目&lt;/h3&gt;
&lt;p&gt;在idea里新建空的maven项目。&lt;/p&gt;
&lt;p&gt;File-&amp;gt;new-&amp;gt;project-&amp;gt;maven&lt;/p&gt;
&lt;p&gt;填写group和artifact。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;project&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;         xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;         xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;kw&quot;&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;dubbo-hello-demo&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;pom&lt;span class=&quot;kw&quot;&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;java.version&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/java.version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;repositories&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;id&amp;gt;&lt;/span&gt;central&lt;span class=&quot;kw&quot;&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span class=&quot;kw&quot;&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;aliyun&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/repositories&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;pluginRepositories&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;pluginRepository&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;id&amp;gt;&lt;/span&gt;central&lt;span class=&quot;kw&quot;&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span class=&quot;kw&quot;&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;aliyun&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/pluginRepository&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/pluginRepositories&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;提供服务的api&quot;&gt;提供服务的API&lt;/h3&gt;
&lt;p&gt;通过上述的介绍也能理解，消费者需要知道提供者的接口，那么就一定要共享接口和参数以及响应类。所以，我们先抽离一个单独的API项目来专门声明API。&lt;/p&gt;
&lt;p&gt;在项目名上右键，new -&amp;gt; moudle, 选择maven，新建一个新的空maven项目。&lt;/p&gt;
&lt;p&gt;然后，创建一个用户服务接口&lt;code&gt;com.test.hello.api.IUserService&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.hello.api;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; IUserService {
    String &lt;span class=&quot;fu&quot;&gt;sayHi&lt;/span&gt;(String name);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次的主角是dubbo，所以就不填充参数和包结构整理了。简单传入参数String和返回String就好。&lt;/p&gt;
&lt;h3 id=&quot;提供服务的provider&quot;&gt;提供服务的provider&lt;/h3&gt;
&lt;p&gt;刚才声明了一个服务的接口，我们还需要一个实现，来提供真实的服务。而这个服务则是一个独立的项目。我们可以部署在某个机器上。&lt;/p&gt;
&lt;p&gt;在项目名上右键，new -&amp;gt; module， 选择Spring Initializr, 然后只选择web就可以了。最终生成的pom如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;project&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;kw&quot;&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;hello-provider&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class=&quot;kw&quot;&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;hello-provider&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;description&amp;gt;&lt;/span&gt;Demo for dubbo provider hello world&lt;span class=&quot;kw&quot;&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0.0.RELEASE&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;relativePath/&amp;gt;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- lookup parent from repository --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span&gt;UTF-8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;project.reporting.outputEncoding&amp;gt;&lt;/span&gt;UTF-8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/project.reporting.outputEncoding&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;java.version&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/java.version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo.version&amp;gt;&lt;/span&gt;2.6.1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dubbo.version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.alibaba&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;dubbo&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${dubbo.version}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;hello-api&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，手动添加dubbo依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还要引入我们刚才定义的共享接口定义项目：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;hello-api&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，就是实现这个接口了。创建实现类&lt;code&gt;com.test.helloprovider.service.impl.UserService&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.helloprovider.service.impl;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;import com.test.hello.api.IUserService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; UserService &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; IUserService {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;sayHi&lt;/span&gt;(String name) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Hi &quot;&lt;/span&gt; + name + &lt;span class=&quot;st&quot;&gt;&quot;, current date is: &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，只要把这个服务发布出去就行了。在spring cloud里，发布一个服务就是发布web项目，启动tomcat来提供一个rest api。而在这里，我们不需要。我们要做的是把自己注册到dubbo里，等消费者来拿。&lt;/p&gt;
&lt;p&gt;在resource下新建&lt;code&gt;provider.xml&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:dubbo=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:application&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hello-provider&quot;&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 使用multicast广播注册中心暴露服务地址 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:registry&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; address=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;multicast://224.5.6.7:1234&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 用dubbo协议在20880端口暴露服务 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:protocol&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dubbo&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; port=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;20880&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:service&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; interface=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.test.hello.api.IUserService&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;userService&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 和本地bean一样实现服务 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;userService&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.test.helloprovider.service.impl.UserService&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们只要启动Spring容器就行了，我们的bean还是声明在spring里的。&lt;/p&gt;
&lt;p&gt;创建一个启动类&lt;code&gt;com.test.helloprovider.HelloProviderApplication&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.helloprovider;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.support.ClassPathXmlApplicationContext;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.IOException;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HelloProviderApplication {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        ClassPathXmlApplicationContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[] {&lt;span class=&quot;st&quot;&gt;&quot;provider.xml&quot;&lt;/span&gt;});
        context.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        System.&lt;span class=&quot;fu&quot;&gt;in&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;// 按任意键退出&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行main方法即可。&lt;/p&gt;
&lt;p&gt;这里的注册中心只是简单的multicast组播。这样，我们就发布了一个用户服务，提供sayHi方法。接下来只要给消费者调用就行。&lt;/p&gt;
&lt;h3 id=&quot;消费服务的consumer&quot;&gt;消费服务的consumer&lt;/h3&gt;
&lt;p&gt;同样的步骤，我们来建立一个consumer。这个consumer是另一个独立的项目，这个项目也可以部署在另一个机器上。这个项目需要调用provider的项目来获得用户信息。&lt;/p&gt;
&lt;p&gt;和provider不同的是，项目的artifact不一样。&lt;/p&gt;
&lt;p&gt;新建好之后就可以在spring容器里远程调用了。同样在resource下新建一个consumer.xml&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xmlns:dubbo=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;       xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:application&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;hello-consumer&quot;&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:registry&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; address=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;multicast://224.5.6.7:1234&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dubbo:reference&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;userService&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; interface=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.test.hello.api.IUserService&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，调用我们的bean完成消费。创建启动类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HelloConsumerApplication {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ClassPathXmlApplicationContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[]{&lt;span class=&quot;st&quot;&gt;&quot;consumer.xml&quot;&lt;/span&gt;});
        context.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; IUserService userService = context.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;userService&quot;&lt;/span&gt;, IUserService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 获取远程服务代理&lt;/span&gt;
        String hello = userService.&lt;span class=&quot;fu&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;world&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 执行远程方法&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;===================================&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(hello); &lt;span class=&quot;co&quot;&gt;// 显示调用结果&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;===================================&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行main方法可以看到控制台打印内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
22:43:38.034 [main] INFO com.alibaba.dubbo.config.AbstractConfig -  [DUBBO] Refer dubbo service com.test.hello.api.IUserService from url multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?anyhost=true&amp;amp;application=consumer-of-helloworld-app&amp;amp;check=false&amp;amp;dubbo=2.6.1&amp;amp;generic=false&amp;amp;interface=com.test.hello.api.IUserService&amp;amp;methods=sayHi&amp;amp;pid=6204&amp;amp;register.ip=192.168.0.108&amp;amp;remote.timestamp=1521902609769&amp;amp;side=consumer&amp;amp;timestamp=1521902617561, dubbo version: 2.6.1, current host: 192.168.0.108
22:43:38.206 [DubboClientHandler-192.168.0.108:20880-thread-1] DEBUG com.alibaba.dubbo.remoting.transport.DecodeHandler -  [DUBBO] Decode decodeable message com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult, dubbo version: 2.6.1, current host: 192.168.0.108
===================================
Hi world, current date is: Sat Mar 24 22:43:38 CST 2018
===================================
22:43:38.207 [DubboShutdownHook] INFO com.alibaba.dubbo.config.AbstractConfig -  [DUBBO] Run shutdown hook now., dubbo version: 2.6.1, current host: 192.168.0.108
22:43:38.208 [DubboShutdownHook] INFO com.alibaba.dubbo.registry.support.AbstractRegistryFactory -  [DUBBO] Close all registries [multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=consumer-of-helloworld-app&amp;amp;dubbo=2.6.1&amp;amp;interface=com.alibaba.dubbo.registry.RegistryService&amp;amp;pid=6204&amp;amp;timestamp=1521902617639], dubbo version: 2.6.1, current host: 192.168.0.108
22:43:38.208 [DubboShutdownHook] INFO com.alibaba.dubbo.registry.multicast.MulticastRegistry -  [DUBBO] Destroy registry:multicast://224.5.6.7:1234/com.alibaba.dubbo.registry.RegistryService?application=consumer-of-helloworld-app&amp;amp;dubbo=2.6.1&amp;amp;interface=com.alibaba.dubbo.registry.RegistryService&amp;amp;pid=6204&amp;amp;timestamp=1521902617639, dubbo version: 2.6.1, current host: 192.168.0.108
22:43:38.208 [DubboShutdownHook] INFO com.alibaba.dubbo.registry.multicast.MulticastRegistry -  [DUBBO] Unregister: consumer://192.168.0.108/com.test.hello.api.IUserService?application=consumer-of-helloworld-app&amp;amp;category=consumers&amp;amp;check=false&amp;amp;dubbo=2.6.1&amp;amp;interface=com.test.hello.api.IUserService&amp;amp;methods=sayHi&amp;amp;pid=6204&amp;amp;side=consumer&amp;amp;timestamp=1521902617561, dubbo version: 2.6.1, current host: 192.168.0.108
22:43:38.208 [DubboShutdownHook] INFO com.alibaba.dubbo.registry.multicast.MulticastRegistry -  [DUBBO] Send broadcast message: unregister consumer://192.168.0.108/com.test.hello.api.IUserService?application=consumer-of-helloworld-app&amp;amp;category=consumers&amp;amp;check=false&amp;amp;dubbo=2.6.1&amp;amp;interface=com.test.hello.api.IUserService&amp;amp;methods=sayHi&amp;amp;pid=6204&amp;amp;side=consumer&amp;amp;timestamp=1521902617561 to /224.5.6.7:1234, dubbo version: 2.6.1, current host: 192.168.0.108&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此，hello world 完成。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Sat, 24 Mar 2018 15:23:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/hello-dubbo.html</dc:identifier>
</item>
<item>
<title>IMLite轻量级即时通信工具开发指南 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8641965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8641965.html</guid>
<description>&lt;p&gt;花了一周时间开发了一个简单的即时通信工具，勉强算是程序原型。现在我把开发流程和一些个人的想法记录下来。本文首先介绍程序架构和通信接口，之后会聚焦到服务器的信号槽设计原则，接下来将解释有关TCP通信的粘包问题和解决方案，最后一个部分是一些改进建议。&lt;/p&gt;
&lt;p&gt;源码下载：&lt;a title=&quot;源码&quot; href=&quot;https://gitee.com/learnhow/imlite&quot; target=&quot;_blank&quot;&gt;https://gitee.com/learnhow/imlite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;程序架构图例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/871676/201803/871676-20180324182800756-513898184.jpg&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一、架构方案介绍&lt;/p&gt;
&lt;p&gt;主程序（MainWindow）启动服务器（TcpServer），在收到客户端的连接请求之后会开启一个线程并创建子连接（TcpSocket）。目前支持的消息类型有三种，分别为：Message——由客户端发起的端到端消息或直接由服务器发起的广播消息，这是即时通信最基础的通信要求。MessageConnCallback——由服务器向新连接的终端发起的socketID反向注册信息，目的是告知客户端本次连接在服务器端生成的socketID。MessageConnecter——由服务器向所有终端发布的一条广播，通知所有终端其他的终端socketID和客户端自定义的nickname，这是实现端到端通信的基础。&lt;/p&gt;
&lt;p&gt;端到端通信的原理实际上是由客户端发送一条携带了接收方socketID的信息。服务器在收到后会解析并进行转发。&lt;/p&gt;
&lt;p&gt;为了让多种消息类型能够统一，程序提供了MessageInterface接口和TcpSocketData对象。所有的消息类型都必须实现MessageInterface接口，并且在发送端和接收端都必须通过TcpSocketData来注册消息类型包括进行序列化和反序列化。&lt;/p&gt;
&lt;p&gt;NetPacket提供了消息打包和解包方法。为发送的数据包加上一个字符串作为包尾，并且在接收端可以根据包尾来解包并分割为原始报文。更详细的信息将在第三节介绍。&lt;/p&gt;
&lt;p&gt;SQLiteService实现了一种简单的数据保存方法，由于程序开发的重点不在于此，并没有做专门设计。二次开发中应该会重新设计，这里一带而过。&lt;/p&gt;
&lt;p&gt;二、通信机制介绍&lt;/p&gt;
&lt;p&gt;本例中所有对象的通信都采用信号槽，信号槽是Qt提供的一种消息流转机制。在命名规则上，程序按照Qt的命名方案：槽的命名使用动词一般现在时，信号命名使用动词过去时。并且以“谁创建谁连接”的原则编写，例如：TcpServer负责创建所有的子连接TcpSocket，因此与它的信号槽连接都会放在TcpServer中实现。&lt;/p&gt;
&lt;p&gt;接下来以客户端向服务器端发起连接请求为例做简单介绍。服务器（TcpServer）通过incomingConnection（qintptr）方法产生socketID，立刻通过子连接向终端发送connectionCallback信号，接着会发送广播向终端通知有新的连接加入，最后还会向UI层发送一个与显示有关的信号（程序中表现为在QWidgetList中增加一个Item）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当有新的终端连接请求时被调用&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::incomingConnection(qintptr handle)
{
    ...

    clientStatusConnect(QString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).arg(handle));
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::clientStatusConnect(QString socketDescriptor)
{

    socketnicknamemap.insert(socketDescriptor, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Guest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向终端反向注册handle&lt;/span&gt;
&lt;span&gt;    MessageConnCallback callback; 
    callback.setSocketDescriptor(socketDescriptor);
    emit connectionCallback(callback); ①

    MessageConnecter msgConn;
    msgConn.setConnectors(socketnicknamemap);
    emit terminalsPublished(msgConn); ②

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反馈信号至UI:增加终端&lt;/span&gt;
    emit clientStatusTriggered(socketDescriptor, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它的代码就不一一解释了。&lt;/p&gt;
&lt;p&gt;三、Tcp粘包和解决方案&lt;/p&gt;
&lt;p&gt;观察上面的源码片段，当有新连接产生后，服务器会“同时”向终端发送两条数据（注：①②）。客户端的void dataRecv()方法会调用QByteArray buff = tcpSocket-&amp;gt;readAll()读取数据，这时有极大的几率发生“粘包”——服务器发送的两条报文A、B，客户端以A+B作为一条报文读取出来。我的解决方案是在发送端为每段报文增加一个字符串（CF07D）作为结束标志，在接收端就以此标志对报文分割。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
QByteArray NetPacket::package(&lt;span&gt;const&lt;/span&gt; QByteArray &amp;amp;&lt;span&gt;data)
{
    QByteArray wrap(data);
    wrap &lt;/span&gt;+=&lt;span&gt; splite;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrap;
}

QList&lt;/span&gt;&amp;lt;QByteArray&amp;gt; NetPacket::unpackage(&lt;span&gt;const&lt;/span&gt; QByteArray &amp;amp;&lt;span&gt;wrap)
{
    QList&lt;/span&gt;&amp;lt;QByteArray&amp;gt;&lt;span&gt; bufflist;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pos = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; prev = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((pos = wrap.indexOf(splite, pos)) != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        QByteArray part &lt;/span&gt;=&lt;span&gt; wrap.mid(prev, pos);
        bufflist.push_back(part);
        pos &lt;/span&gt;+=&lt;span&gt; splite.length();
        prev &lt;/span&gt;=&lt;span&gt; pos;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bufflist;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、问题及改进建议&lt;/p&gt;
&lt;p&gt;（1）信号槽是一个好东西，但是不能滥用：程序中所有对象的数据流转都是通过信号槽机制。不可否认这样做似乎减少了模块耦合，但是增加了维护的难度。并且看上去也显得“乱糟糟”的。如果一条数据同时需要经过多个对象处理，就必须为此设计多个信号槽。&lt;/p&gt;
&lt;p&gt;（2）把消息分开传输：服务器的自连接与客户端之间只使用了一个socket端口通信（8361），这样在接收端就必须为不同的消息类型设计不同的type值。更加合理的做法是让客户端与服务器同时使用多个端口进行通信，既有利于需求扩展又不至于让接收端的方法无限膨胀。&lt;/p&gt;

</description>
<pubDate>Sat, 24 Mar 2018 15:13:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8641965.html</dc:identifier>
</item>
<item>
<title>Go实现海量日志收集系统(一) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8641951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8641951.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;项目背景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;每个系统都有日志，当系统出现问题时，需要通过日志解决问题&lt;/li&gt;
&lt;li&gt;当系统机器比较少时，登陆到服务器上查看即可满足&lt;/li&gt;
&lt;li&gt;当系统机器规模巨大，登陆到机器上查看几乎不现实&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然即使是机器规模不大，一个系统通常也会涉及到多种语言的开发，拿我们公司来说，底层是通过c++开发的，而也业务应用层是通过Python开发的，并且即使是C++也分了很多级别应用，python这边同样也是有多个应用，那么问题来了，每次系统出问题了，如何能够迅速查问题? 好一点的情况可能是python应用层查日志发现是系统底层处理异常了，于是又叫C++同事来查，如果C++这边能够迅速定位出错误告知python层这边还好，如果错误好排查，可能就是各个开发层的都在一起查到底是哪里引起的。当然可能这样说比较笼统，但是却引发了一个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当系统出现问题后，如何根据日志迅速的定位问题出在一个应用层？&lt;/li&gt;
&lt;li&gt;在平常的工作中如何根据日志分析出一个请求到系统主要在那个应用层耗时较大？&lt;/li&gt;
&lt;li&gt;在平常的工作中如何获取一个请求到达系统后在各个层测日志汇总？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对以上问题，我们想要实现的一个解决方案是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把机器上的日志实时收集，统一的存储到中心系统&lt;/li&gt;
&lt;li&gt;然后再对这些日志建立索引，通过搜索即可以找到对应日志&lt;/li&gt;
&lt;li&gt;通过提供界面友好的web界面，通过web即可以完成日志搜索&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于实现这个系统时可能会面临的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实时日志量非常大，每天几十亿条(虽然现在我们公司的系统还没达到这个级别)&lt;/li&gt;
&lt;li&gt;日志准实时收集，延迟控制在分钟级别&lt;/li&gt;
&lt;li&gt;能够水平可扩展&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于日志收集系统，业界的解决方案是ELK&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225452947-1873167550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ELK的解决方案是通用的一套解决方案，所以不免就会产生以下的几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运维成本高，每增加一个日志收集，都需要手动修改配置&lt;/li&gt;
&lt;li&gt;监控缺失，无法准确获取logstash的状态&lt;/li&gt;
&lt;li&gt;无法做定制化开发以及维护&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对这种情况，其实我们想要的系统是agent可以动态的获取某个服务器我们需要监控哪些日志&lt;br/&gt;以及那些日志我们需要收集，并且当我们需要收集日志的服务器下线了，我们可以动态的停止收集&lt;br/&gt;当然这些实现的效果最终也是通过web界面呈现。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;日志收集系统设计&lt;/h2&gt;
&lt;p&gt;主要的架构图为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225517856-1199618814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于各个组件的说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Log Agent，日志收集客户端，用来收集服务器上的日志&lt;/li&gt;
&lt;li&gt;Kafka，高吞吐量的分布式队列，linkin开发，apache顶级开源项目&lt;/li&gt;
&lt;li&gt;ES，elasticsearch，开源的搜索引擎，提供基于http restful的web接口&lt;/li&gt;
&lt;li&gt;Hadoop，分布式计算框架，能够对大量数据进行分布式处理的平台&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_3&quot;&gt;关于Kakfa的介绍&lt;/h2&gt;
&lt;p&gt;Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。&lt;/p&gt;
&lt;p&gt;注：这里关于Kafka并不会介绍太多，只是对基本的内容和应用场景的说明，毕竟展开来说，这里的知识也是费非常多的&lt;/p&gt;
&lt;p&gt;Kafka中有几个基本的消息术语需要了解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka将消息以topic为单位进行归纳。&lt;/li&gt;
&lt;li&gt;将向Kafka topic发布消息的程序成为producers.&lt;/li&gt;
&lt;li&gt;将预订topics并消费消息的程序成为consumer.&lt;/li&gt;
&lt;li&gt;Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225604354-920551257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Kafka的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可靠性 - Kafka是分布式，分区，复制和容错的。&lt;/li&gt;
&lt;li&gt;可扩展性 - Kafka消息传递系统轻松缩放，无需停机。&lt;/li&gt;
&lt;li&gt;耐用性 - Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。&lt;/li&gt;
&lt;li&gt;性能 - Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kafka非常快，并保证零停机和零数据丢失。&lt;/p&gt;
&lt;p&gt;Kafka的应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步处理, 把非关键流程异步化，提高系统的响应时间和健壮性&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225629403-9950891.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225746102-816782515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用解耦,通过消息队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225804436-417233228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225814908-630089644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流量削峰&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225831524-2037857749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2 id=&quot;toc_4&quot;&gt;关于ZooKeeper介绍&lt;/h2&gt;
&lt;p&gt;ZooKeeper是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。ZooKeeper通过其简单的架构和API解决了这个问题。ZooKeeper允许开发人员专注于核心应用程序逻辑，而不必担心应用程序的分布式特性。&lt;br/&gt;Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。&lt;/p&gt;
&lt;p&gt;ZooKeeper主要包含几下几个组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client（客户端）：我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。&lt;/li&gt;
&lt;li&gt;Server（服务器）：服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。&lt;/li&gt;
&lt;li&gt;Ensemble：ZooKeeper服务器组。形成ensemble所需的最小节点数为3。&lt;/li&gt;
&lt;li&gt;Leader： 服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。&lt;/li&gt;
&lt;li&gt;Follower：跟随leader指令的服务器节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ZooKeeper的应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务注册&amp;amp;服务发现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225908728-754497138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置中心&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324225945047-744965166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    Zookeeper是强一致的&lt;em id=&quot;__mceDel&quot;&gt;多个客户端同时在Zookeeper上创建相同znode，只有一个创建成功&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_5&quot;&gt;关于Log Agent&lt;/h2&gt;
&lt;p&gt;这个就是我们后面要通过代码实现的一步分内容,主要实现的功能是：&lt;br/&gt;类似于我们在linux下通过tail的方法读日志文件，讲读取的内容发给Kafka&lt;br/&gt;这里需要知道的是，我们这里的tailf是可以动态变化的，当配置文件发生变化是，可以通知我们程序自动增加需要增加的tailf去获取相应的日志并发给kafka producer&lt;br/&gt;主要由一下几部目录组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka&lt;/li&gt;
&lt;li&gt;tailf&lt;/li&gt;
&lt;li&gt;config&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;log&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180324230050191-52915922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;以上是对整个要开发的系统的一个总的概括，以及架构的一个构建，并且各个组件的实现，接下来会一个一个实现每个部分的功能，下一篇文章会实现上述组件中log Agent的开发&lt;/p&gt;

</description>
<pubDate>Sat, 24 Mar 2018 15:02:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8641951.html</dc:identifier>
</item>
<item>
<title>走近webpack（2）--css打包及压缩js - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8586458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8586458.html</guid>
<description>&lt;p&gt;　　前面的文章介绍了webpack的devServer以及多入口多出口文件的配置，咱们继续往下学。&lt;/p&gt;
&lt;p&gt;　　在开始学习接下来的知识之前，我们先回顾一下，前文提到了webpack的简单配置方法，但是只详细说了下入口和出口文件的配置，并没有更多的去解释其他选项的配置，比如loader，plugin等。那么咱们现在就来学一下module的配置。前面说过，&lt;strong&gt;module的主要作用就是通过l&lt;/strong&gt;oaders来配置，解析，转换不同类型的模块。比如说，可以把less,sass转换成css，可以把es6甚至es7语法转换成大部分浏览器可以运行的js代码。所有的loaders都需要在npm中单独安装并且在module中配置后才可以使用。&lt;strong&gt;loader的主要配置只有test和use两种，简单来说就是。你要匹配的文件是什么，用test来过滤。用use来确定你要用什么loader来转换你匹配到的文件&lt;/strong&gt;。下面咱们开始第一个loader的使用。&lt;/p&gt;
&lt;p&gt;　　首先我们来安装两个loader,css-loader和style-loader。运行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install style-loader css-loader --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;其中，style-loader&lt;/strong&gt;主要用于将css插入到页面的style标签中等。css-loader&lt;strong&gt;主要用于处理css中的url()&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;然后我们查看package.json中的devDependecies中多了两个配置项，也就是我们安装的css-loader和style-loader说明安装成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201803/1184971-20180316221835156-1867308017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后，我们在src文件夹下新建一个css文件夹，并且新建一个index.css文件。&lt;/p&gt;
&lt;p&gt;　　此时，你的文件目录结构应该是这样的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201803/1184971-20180316222546573-1497298430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在文件中我们写上如下的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body&lt;/span&gt;{&lt;span&gt;
   background&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;; 
}&lt;span&gt;
#title&lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt;orange&lt;/span&gt;;&lt;span&gt;  
  color&lt;/span&gt;:&lt;span&gt;blue&lt;/span&gt;;      
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只是这样还不行，我们需要在src/entry.js中引入这个css文件，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import idxcss from './css/index.css'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后一步，也是最重要的一步，我们在webpack.config.js中的module中配置一下我们已经安装好的loader：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module:{
        rules: [
            {
              test: &lt;/span&gt;/\.css$/&lt;span&gt;,
              use: [ &lt;/span&gt;'style-loader', 'css-loader'&lt;span&gt; ]
            }
          ]
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，让我们npm run build一下！打开index.html，我们发现css已经被写入了。&lt;/p&gt;
&lt;p&gt;　　下面我们介绍一下loader的其他几种写法，意思都一样，你们喜欢哪个用哪个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;第一种写法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
module:{
    rules:[
        {
            test:&lt;/span&gt;/\.css$/&lt;span&gt;,
            use:[&lt;/span&gt;'style-loader','css-loader'&lt;span&gt;]
        }
    ]
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;第二种写法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
module:{
    rules:[
        {
            test:&lt;/span&gt;/\.css$/&lt;span&gt;,
            loader:[&lt;/span&gt;'style-loader','css-loader'&lt;span&gt;]
        }
    ]    
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;第三种写法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
module:{
     rules:[
        {
            test:&lt;/span&gt;/\.css$/&lt;span&gt;,
            use: [
                {
                    loader: &lt;/span&gt;&quot;style-loader&quot;&lt;span&gt;
                }, {
                    loader: &lt;/span&gt;&quot;css-loader&quot;&lt;span&gt;
                 }
            ]
        }
    ]
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok,下面我们来学一下如何压缩JS，我们需要用到uglifyjs-webpack-plugin，一个压缩JS的插件，没错，插件，plugins。那么看一下我们如何使用他呢。&lt;/p&gt;
&lt;p&gt;　　uglifyjs-webpack-plugin已经集成在webpack中，所以我们不用下载安装了，直接在config.js中引入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const uglify = require('uglifyjs-webpack-plugin');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在module的plugin选项下new一个uglify就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201803/1184971-20180316230924954-1332741839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们npm run build一下就打包成功了。&lt;strong&gt;JS压缩通常都是用在生产环境中的&lt;/strong&gt;。下面来看看html文件是如何打包的。&lt;/p&gt;
&lt;p&gt;　　先把dist目录下的index.html复制到src目录下，然后把dist目录下的文件都删除。&lt;/p&gt;
&lt;p&gt;　　html文件的打包需要用到另一个插件，&lt;span class=&quot;crayon-e&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&lt;span class=&quot;crayon-e&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;html&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;webpack&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;plugin。我们先安装一下吧：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save-dev html-webpack-plugin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装完成之后，我们需要引入这个插件，&lt;strong&gt;所有的插件使用都是这三步，安装（除了webpack集成的可以省去安装这一步），引入，配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201803/1184971-20180316232401435-840076936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后，我们需要在plugins下配置一下这个插件。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; htmlPlugin({
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;压缩文件，removeAttributeQuotes指去掉属性的双引号，目前你随便不用也行&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    minify:{
        removeAttributeQuotes:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;加入hash值，为了避免浏览器缓存js&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    hash:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;要打包的html文件的路径及名称&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    template:&lt;/span&gt;'./src/index.html'&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置完成，npm run build一下会发现dist目录下已经生成了三个文件。至此我们就学会了打包css，压缩js和打包生成html文件。如果稍微细心一点你会发现，其实webpack主要的作用就在于loader和plugin，也正是如此，webpack才有了它多样化个性化的配置方法。下一篇文章，我们一起学一下如何用webpack来处理图片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 14:58:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8586458.html</dc:identifier>
</item>
<item>
<title>201571030319 四则运算 - 马绍辉</title>
<link>http://www.cnblogs.com/mashaohui/p/8641934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mashaohui/p/8641934.html</guid>
<description>&lt;p&gt;项目源码展示网址：https://github.com/nigulasiletai/Dem&lt;/p&gt;
&lt;p&gt;1、需求分析：程序可接收一个输入参数n，然后随机产生n道加减乘除练习题，每个数字在 0 和 100 之间，运算符在3个到5个之间。&lt;em id=&quot;__mceDel&quot;&gt;为了让小学生得到充分锻炼，每个练习题至少要包含2种运算符。同时，由于小学生没有分数与负数的概念，你所出的练习题在运算过程中不得出现负数与非整数，比如不能出 3/5+2=2.6，2-5+10=7等算。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2、功能设计：输入一个参数n,随机生成n道算式，即当输入生成式子个数为5时，产生五个具有运算符和数字组成的算式。&lt;/p&gt;
&lt;p&gt;3、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1350825/201803/1350825-20180324224931048-941784771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;psp：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;center&quot;&gt;PSP2.1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;center&quot;&gt;任务内容&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;计划完成需要的时间(min)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;实际完成需要的时间(min)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Planning&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;计划&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;35&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Estimate&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;估计这个任务需要多少时间，并规划大致工作步骤&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;50&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;60&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Development&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;开发&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;80&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;90&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Analysis&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;需求分析 (包括学习新技术)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;19&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Design Spec&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;生成设计文档&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;15&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;18&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt; Design Review&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设计复审 (和同事审核设计文档)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt; Coding Standard&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;代码规范 (为目前的开发制定合适的规范)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt; Design&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;具体设计&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Coding&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;具体编码&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;80&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;120&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Code Review&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;代码复审&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Test&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;测试（自我测试，修改代码，提交修改）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;25&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Reporting&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;报告&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Test Report&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;测试报告&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Size Measurement&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot;&gt;
&lt;p align=&quot;left&quot;&gt;计算工作量&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;228&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;Postmortem &amp;amp; Process Improvement Plan&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;255&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;事后总结 ,并提出过程改进计划&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;15&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;170&quot;&gt;
&lt;p align=&quot;center&quot;&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;心得体会：通过本次实验以后了解了很多自身的不足之处，需要在以后的试验中多加注意。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 14:58:00 +0000</pubDate>
<dc:creator>马绍辉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mashaohui/p/8641934.html</dc:identifier>
</item>
<item>
<title>Python : Module - FangJinuo</title>
<link>http://www.cnblogs.com/f1194361820/p/8641288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f1194361820/p/8641288.html</guid>
<description>&lt;p&gt;          在Python中，一个.py文件代表一个Module。在Module中可以是任何的符合Python文件格式的Python脚本。了解Module导入机制大有用处。&lt;/p&gt;

&lt;h2&gt;1 Module组成&lt;/h2&gt;
&lt;p&gt;         一个.py文件就是一个module。Module中包括attribute, function等。 这里说的attribute其实是module的global variable。&lt;/p&gt;
&lt;p&gt;在一个ModuleTests.py文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d251b850-71ae-43c3-b8cd-3af8afcc4efc')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d251b850-71ae-43c3-b8cd-3af8afcc4efc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d251b850-71ae-43c3-b8cd-3af8afcc4efc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d251b850-71ae-43c3-b8cd-3af8afcc4efc',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d251b850-71ae-43c3-b8cd-3af8afcc4efc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;-*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
全局变量
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; hello doc&lt;/span&gt;
&lt;span&gt;global&lt;/span&gt;&lt;span&gt; moduleName
moduleName &lt;/span&gt;= &lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;
a &lt;/span&gt;= 1

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; printModuleName():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a+1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(moduleName)

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
if __name__ == '__main__' : 
    print('current module name is &quot;' + __name__+'&quot;')
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;


printModuleName()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dir())

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;__builtin__&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__builtin__&lt;/span&gt; == &lt;span&gt;__builtins__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__package__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__name__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;         除了你自己定义的那些全局变量和函数外，每一个module还有一些内置的全局变量。在这个module就包括了三个attribute：a,moduleName,printModuleName。如果该模块被导入到另一个模块，在另个一模块中，就可以通过某种方式来访问这三个attribute。&lt;/p&gt;

&lt;h3&gt;1.1 Module 内置全局变量&lt;/h3&gt;
&lt;p&gt;         每一个模块，都会有一些默认的attribute（全局变量）。dir()函数 是python中的一个顶级函数，勇于查看模块内容。例如上面的例子中，使用dir()查看结果是：&lt;/p&gt;
&lt;p&gt; ['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'a', 'moduleName', 'printModuleName']。其中a, moduleName, printModuleName 是由用户自定义的。其他的全是内置的。&lt;/p&gt;
&lt;p&gt;        1）&lt;span&gt;&lt;strong&gt;__name__&lt;/strong&gt;&lt;/span&gt; ：模块的名称。例如上面的ModuleTests.py，模块的名称默认就是ModuleTests。在运行时，如果一个module是程序入口，那么__name__就是”__main__”。它是最常用的。&lt;/p&gt;
&lt;p&gt;        2）&lt;span&gt;&lt;strong&gt;__builtins__&lt;/strong&gt;&lt;/span&gt;：在Python中有一个内置的module，叫做：__builtin__，它是一个Python的模块。而任何一个Python的模块都有一个__builtins__全局变量，它就是内置模块__builtin__的引用。可以通过如下代码测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;__builtin__&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;__builtin__&lt;/span&gt; == &lt;span&gt;__builtins__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        // 测试结果是True&lt;/p&gt;
&lt;p&gt;        3）&lt;span&gt;&lt;strong&gt;__doc__&lt;/strong&gt;&lt;/span&gt;：module的文档说明。即便是Python的初学者都知道Python中的多行注释是用三对单引号或者双引号包含的。网上有人说__doc__其实就是注释，这句话呢说的太随意容易给人误解。经过测试，确认__doc__应该是：&lt;span&gt;&lt;strong&gt;文件头之后&lt;/strong&gt;、&lt;strong&gt;代码（包含&lt;/strong&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;strong&gt;）之前&lt;/strong&gt; 的 &lt;strong&gt;第一个&lt;/strong&gt; &lt;strong&gt;多行注释&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        4）&lt;span&gt;&lt;strong&gt;__file__&lt;/strong&gt;&lt;/span&gt;：当前module所在的文件的路径。&lt;/p&gt;
&lt;p&gt;        5）&lt;span&gt;&lt;strong&gt;__package__&lt;/strong&gt;&lt;/span&gt;：当前module所在的包名。如果没有，为None。&lt;/p&gt;

&lt;h2&gt;2 Module导入&lt;/h2&gt;
&lt;h3&gt;2.1 导入及其使用&lt;/h3&gt;
&lt;p&gt;         一个Module可以导入（import）到其他的Python脚本中使用。导入方式有多种：&lt;/p&gt;
&lt;p&gt;        1）import module1&lt;/p&gt;
&lt;p&gt;        2）import module1 as m1&lt;/p&gt;
&lt;p&gt;        3）from module1 import xxx&lt;/p&gt;
&lt;p&gt;        4）from module1 import xxx as yyy&lt;/p&gt;
&lt;p&gt;        从包（package）导入，也分为类似的三种：&lt;/p&gt;
&lt;p&gt;        1）import p1.p2.p3.module1 &lt;/p&gt;
&lt;p&gt;        2）import p1.p2.p3.module1 as m1&lt;/p&gt;
&lt;p&gt;        3）from p1.p2.p3.module1 import xxx&lt;/p&gt;
&lt;p&gt;        4）from p1.p2.p3.module1 import xxx as yyy&lt;/p&gt;
&lt;p&gt;        假设module1有两个attribue: a1,a2， 两个function: f1,f2下面来说明这几种导入方式的区别：&lt;/p&gt;
&lt;p&gt;         方式一是导入整个module1, 并将赋值给一个变量module1，来供使用。使用时，可以使用module1.a1, module1.a2, module1.f1(params), module.f2(params)&lt;/p&gt;
&lt;p&gt;         方式二是在方式一的基础上，重命名为m1,也就是说使用时得使用： m1.a1, m1.a2, m1.f1, m1.f2。&lt;/p&gt;
&lt;p&gt;         方式三是导入模块的部分内容（导入一个或者一些attribute或者function） 。例如 from module1 import a1，导入完成后，在当前的模块中创建了一个 a1的变量。调用是直接调用a1即可。&lt;/p&gt;
&lt;p&gt;         方式四对于导入一个attribute或者function时，可以重命名。例如 from module1 import a1 as msg，那么导入完毕，就是在当前的模块中创建了一个msg的变量，指向了module1.a1。 我们在调用时，只能通过msg来调用。&lt;/p&gt;

&lt;h3&gt;2.2 一次加载多次导入&lt;/h3&gt;

&lt;p&gt;       对于上面的4种导入方式，不论哪一种，都有两个阶段：1）找到module对象，2）按需分配给变量。&lt;/p&gt;
&lt;p&gt;       模块本身就是为了复用的。在一个大的项目中，一些基础的、公共的模块通常会被大量使用，也就是说会被很多的module导入使用。我们也知道，module是放在py文件中的。如个一个module被大量导入时，难道要每一次导入，都去磁盘上找一py文件吗？&lt;/p&gt;
&lt;p&gt;       显然不能这样设计，如果真的这样设计，程序的性能将是极差的了。&lt;/p&gt;
&lt;p&gt;       对于同样的问题，Java中的做法是，使用ClassLoader加载类，并采用父加载器委托机制。尽可能的保证，同一个ClassLoader下，在多次引用一个类时，都是同一个。我们可以将该方式称为一次加载，多地使用。&lt;/p&gt;
&lt;p&gt;       Python的设计者，也考虑到这个问题。也采用了类似方案，被我称为一次加载，多次导入。我们假设它有一个Module Loader的存在，在首次加载（其实是首次import）时，执行流程如下：&lt;/p&gt;
&lt;p&gt;       1）由Module Loader从检索路径下找出相应的模块&lt;/p&gt;
&lt;p&gt;       2）编译或者找到合适的字节码文件（.pyc结尾）&lt;/p&gt;
&lt;p&gt;       3）解释执行要导入的Module，并放入缓存。&lt;/p&gt;
&lt;p&gt;       4）将导入的Module对象（或者其属性）分配给当前Module下的变量。&lt;/p&gt;
&lt;p&gt;      随后整个程序中再有执行import该moudle时，只需要从缓存中拿到该module，然后执行4）。&lt;/p&gt;

&lt;p&gt;       此外，对于过程2）有这样4种情况：&lt;/p&gt;
&lt;p&gt;       A: 若.py与.pyc都存在：会对.py文件的最后修改时间与.pyc文件的最后修改时间比较。执行时间靠后的那个。&lt;/p&gt;
&lt;p&gt;       B: 若.py与.pyc都不存在，继续找，如果最终都没有找到，出错。&lt;/p&gt;
&lt;p&gt;       C: 若.py存在，.pyc不存在：编译.py为.pyc。&lt;/p&gt;
&lt;p&gt;       D:若.py不存在，.pyc存在，直接执行.pyc。&lt;/p&gt;

&lt;p&gt;       再者还要说明2点：&lt;/p&gt;
&lt;p&gt;       1）一次加载，多次导入的机制，在Python程序包中提供的交互式命令行里使用import是不管用的。在交互式下，一次加载只能用于一次导入。&lt;/p&gt;
&lt;p&gt;       2）一般main py是不会被编译成pyc的，一个模块要想被编译成pyc，需要import到其他模块才行。&lt;/p&gt;

&lt;h3&gt;2.3 搜索路径&lt;/h3&gt;
&lt;p&gt;       依据Java编程经验来看，通常程序会将文件放在不同的地方。Python必然也不例外。Python的搜索顺序为：&lt;/p&gt;
&lt;p&gt;       1）  已加载模块的缓存&lt;/p&gt;
&lt;p&gt;       2）  内置模块&lt;/p&gt;
&lt;p&gt;       3）  sys.path&lt;/p&gt;
&lt;p&gt;       其中sys.path包含以下几部分：&lt;/p&gt;
&lt;p&gt;       1）入口程序的目录&lt;/p&gt;
&lt;p&gt;       2）系统环境变量PYTHONPATH代表的目录&lt;/p&gt;
&lt;p&gt;       3）标准Python库目录&lt;/p&gt;
&lt;p&gt;       4）任何.pth文件的内容（如果存在的话）&lt;/p&gt;

&lt;p&gt;       下面使用命令看一下sys.path的目录有哪些：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
[&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\windows\\SYSTEM32\\python27.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\Program Files\\Python\\Python27\\DLLs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\Program Files\\Python\\Python27\\lib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\Program Files\\Python\\Python27\\lib\\plat-win&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\Program Files\\Python\\Python27\\lib\\lib-tk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\Program Files\\Python\\Python27&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\Program Files\\Python\\Python27\\lib\\site-packages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        如果要加载的module不在上述目录下，可以通过3钟手段：&lt;/p&gt;
&lt;p&gt;        1）  配置环境变量PYTHONPATH，配置是与环境变量PATH的风格一样。&lt;/p&gt;
&lt;p&gt;        2）  程序动态修改sys.path&lt;/p&gt;
&lt;p&gt;        3）  放到site-packages目录下。&lt;/p&gt;

&lt;h3&gt;2.4 reload()&lt;/h3&gt;
&lt;p&gt;        有些情况下，我们需要在程序运行是对程序代码做修改。例如我们需要监控某一方法执行快慢，是否存在性能问题时。我们需要在function的开始、结束部分记录一个startTime,endTime，依此来判定执行性能时。像这样的场景下，因为Module的加载一次，多长调用的机制，我们修改完代码，也不会生效。此时就需要一种机制来重新加载module，以达到期望效果。reload() 就可以解决这个问题。&lt;/p&gt;
&lt;p&gt;        reload(module) 是一个函数，参数是一个module对象。执行reload，就会等于再一次进行加载。&lt;/p&gt;

&lt;h2&gt;3 Package&lt;/h2&gt;

&lt;h3&gt;3.1 __init__.py&lt;/h3&gt;
&lt;p&gt;        每一个package下必须有一个__init__.py文件，该文件用于表明当前目录可以作为一个package。&lt;/p&gt;
&lt;p&gt;        __init__.py 也是一个python，当首次加载相应的package时，会执行__init__.py。&lt;/p&gt;
&lt;p&gt;        __init__.py文件可以什么也没有，也可以指定__all__或（和）__path。&lt;/p&gt;

&lt;h3&gt;3.2 __all__&lt;/h3&gt;
&lt;p&gt;       __all__的值是一个列表，用于当程序中使用 from pkg1.pkg2.pkg3 import * 时。&lt;/p&gt;
&lt;p&gt;       就拿Python_HOME/Lib/下的json包来做实验，由于该文件比较大，我就写出主要部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__version__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.0.9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;__all__&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dump&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dumps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;loads&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JSONDecoder&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JSONEncoder&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]
&lt;/span&gt;&lt;span&gt;__author__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob Ippolito &amp;lt;bob@redivi.com&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; .decoder &lt;span&gt;import&lt;/span&gt;&lt;span&gt; JSONDecoder
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .encoder &lt;span&gt;import&lt;/span&gt;&lt;span&gt; JSONEncoder

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dump(params):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dumps(params):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; load(params):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; loads(params):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       目录结构如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/512650/201803/512650-20180324200926347-69508502.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;       当程序中使用 from json import * 引起json包首次加载时，执行过程如下：&lt;/p&gt;
&lt;p&gt;       1）找到json目录，执行__init__.py 执行完毕后：包下会暴漏出：load,loads,dump.dumps, JSONDecoder, JSONEncoder&lt;/p&gt;
&lt;p&gt;       2）查找* ，即从__all__找出要导出的变量。&lt;/p&gt;

&lt;p&gt;       当程序使用Import json.encoder引起json包首次加载时，执行过程如下：&lt;/p&gt;
&lt;p&gt;       1）找到json目录，执行__init__.py 执行完毕后：包下会暴漏出：load,loads,dump.dumps, JSONDecoder, JSONEncoder （以供from json import * 使用）&lt;/p&gt;
&lt;p&gt;       2）导入json包到一个变量里（此后程序可以直接使用json.encoder, json.decoder,json.scanner）&lt;/p&gt;

&lt;p&gt;       上述结论，来源于下面的测试用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;-*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
Package Import Test
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;from json import *&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; json &lt;span&gt;import&lt;/span&gt;&lt;span&gt; encoder
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.encoder ==&lt;span&gt; encoder)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.decoder &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.scanner &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dir())
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3.3 __path__&lt;/span&gt; &lt;/h3&gt;
&lt;p&gt;       该变量用于配置包下的搜索位置。例如：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       在Utils下增加2个目录Linux和Windows, 并各有一个echo.py文件, 目录如下 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 Sound/Utils/  
    |--&lt;span&gt; Linux        目录下没有__init__.py文件, 不是包, 只是一个普通目录  
    &lt;/span&gt;|   `--&lt;span&gt; echo.py  
    &lt;/span&gt;|--&lt;span&gt; Windows      目录下没有__init__.py文件, 不是包, 只是一个普通目录  
    &lt;/span&gt;|   `--&lt;span&gt; echo.py  
    &lt;/span&gt;|-- &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py  
    &lt;/span&gt;|--&lt;span&gt; echo.py  
    &lt;/span&gt;|--&lt;span&gt; reverse.py  
    `&lt;/span&gt;-- surround.py  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      如果__init__.py是空的，当使用import Sound.Utils.echo导入echo时，会导入的是Sound/Utils/echo.py。   &lt;/p&gt;
&lt;p&gt;      接下来我将__init__.py做如下修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os 

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sound.Utils.__init__.__path__ before change:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;__path__&lt;/span&gt;&lt;span&gt; 

dirname &lt;/span&gt;= &lt;span&gt;__path__&lt;/span&gt;&lt;span&gt;[0] 
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.platform[0:5] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 
        &lt;/span&gt;&lt;span&gt;__path__&lt;/span&gt;.insert( 0, os.path.join(dirname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) ) 
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;: 
        &lt;/span&gt;&lt;span&gt;__path__&lt;/span&gt;.insert( 0, os.path.join(dirname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Windows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) ) 
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sound.Utils.__init__.__path__ AFTER change:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;__path__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      在Linux上执行import Sound.Utils.echo，那么搜索路径就会变成了： 'Sound/Utils/Linux', 'Sound/Utils'。以此来达到自动化的按需加载响应的module的功能。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 12:22:00 +0000</pubDate>
<dc:creator>FangJinuo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f1194361820/p/8641288.html</dc:identifier>
</item>
<item>
<title>JVM学习一：JVM之类加载器概况 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/8640448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/8640448.html</guid>
<description>&lt;p&gt;&lt;span&gt;18年转眼就3月份都快结束了，也就是说一个季度就结束了；而我也因为年前笔记本坏了，今天刚修好了，那么也应该继续学习和博客之旅了。今年的博客之旅，从JVM开始学起，下面我们就言归正传，进入正题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、Java虚拟机与程序的生命周期&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个运行时的Java虚拟机(JVM)负责运行一个Java程序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当启动一个Java程序时，一个虚拟机实例诞生；当程序关闭退出，这个虚拟机实例也就随之消亡.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果在同一台计算机上同时运行多个Java程序，将得到多个Java虚拟机实例，每个Java程序都运行于它自己的Java虚拟机实例中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在如下几种情况下，Java虚拟机将结束生命周期：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.执行了System.exit()方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.程序正常执行结束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.程序在执行过程中遇到了异常或错误而异常终止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.由于操作系统出现错误而导致Java虚拟机进程终止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、类加载器ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面我们提到了java 程序是基于JVM之上运行的，那么我们知道我们编写的java程序，首先java编译器将我们的源代码编译成为字节码，然后由JVM将字节码load到内存中，接着我们的程序就可以创建对象了，我们知道JVM将字节码load到内存之后将将建立内存模型（JVM的内存模型我们将在稍后阐述），那JVM是怎么将类load到内存中的呢？对了，是通过Classloader；也就是我们说的类加载器。在讲解具体类加载执行流程前，我们来看一段代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; counter1;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter2 = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Singleton() {

       counter1&lt;/span&gt;++&lt;span&gt;;

       counter2&lt;/span&gt;++&lt;span&gt;;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCounter1() {

       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; counter1;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCounter2() {

       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; counter2;

    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Singleton getInstance(){

       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; singleton;

    }

}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassLoaderTest {


    @SuppressWarnings(&lt;/span&gt;&quot;static-access&quot;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

       Singleton singleton&lt;/span&gt;=&lt;span&gt;Singleton.getInstance();

       System.out.println(&lt;/span&gt;&quot;counter1:&quot;+&lt;span&gt;singleton.getCounter1());

       System.out.println(&lt;/span&gt;&quot;counter2:&quot;+&lt;span&gt;singleton.getCounter2());

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们先猜测一下运行结果,然后我们再来调换一下单实例生成的顺序，将：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; counter1;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter2 = 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; counter1;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; counter2 = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton singleton=&lt;span&gt;new&lt;/span&gt; Singleton();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后我们会惊奇的发现，竟然结果是不一样的，这又是为什么呢？ 学过JVM的的类加载器过程的估计一定知道了，但没有学过的，那么不要急，让我们一起来揭秘。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、类的加载流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;紧接着上面的类型，让我们来看下类加载器到底是如何来加载的，流程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180324185026193-1958361134.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;即类加载经历了：&lt;strong&gt;&lt;em&gt;加载 --&amp;gt; &lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;连接 --&amp;gt; &lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;初始化&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.加载：查找并加载类的二进制数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加载就是将二进制的字节码通过IO输入到JVM中，我们的字节码是存在于硬盘上面的，而所用的类都必须加载到内存中才能运行起来，加载就是通过IO把字节码从硬盘迁移到内存中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;详细分析见：《JVM学习二：JVM之类加载器之加载分析》：http://www.cnblogs.com/pony1223/p/8641015.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.连接：连接又分为三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证：确保被加载类的正确性。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;即验证class文件是否符合JVM的要求。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;准备：为类的静态变量分配内存，并将其初始化为默认值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;解析：把类中的符号引用转换为直接引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;详细分析见：《JVM学习三：JVM之类加载器之连接分析》：http://www.cnblogs.com/pony1223/p/8641083.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.初始化：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为类的静态变量赋予正确的初始值，即在程序里为静态变量指定的初始值，或静态代码块中的赋值操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;静态代码块是从上到下顺序执行的，可以对一个静态变量多次赋值，最后的结果为静态变量的初始值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;详细分析见：《JVM学习四：JVM之类加载器之初始化分析》：http://www.cnblogs.com/pony1223/p/8641181.html&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;圣思园张龙老师深入Java虚拟机系列&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 12:05:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/8640448.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC编程——路由 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8640648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8640648.html</guid>
<description>&lt;p&gt;&lt;strong&gt;框架自动生成的路由配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324175649800-1305171488.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图中，路由配置文件为&lt;/span&gt;App_Start文件夹下的RouteConfig.cs。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteConfig
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterRoutes(RouteCollection routes)
        {
            routes.IgnoreRoute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{resource}.axd/{*pathInfo}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            routes.MapRoute(
                name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller}/{action}/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                defaults: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; { controller = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id =&lt;span&gt; UrlParameter.Optional }
            );
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：路由中的控制器和操作不区分大小写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;忽略路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IgnoreRoute为RouteCollection 的扩展方法，作用是忽略指定样式的路由。&lt;/p&gt;
&lt;p&gt;上面routes.IgnoreRoute(&quot;{resource}.axd/{*pathInfo}&quot;);中的{resource}代表一个路由参数，{resource}.axd代表以.axd结尾的字符串；{*pathInfo}也是一个路由参数，*代表匹配任何字符串，那么以pathInfo结尾的串都会匹配到。这条语句完整含义是：以axd结尾的任何字符串，不论斜杠后是何种字符串都不执行路由行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;映射路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MapRoute也是RouteCollection 的扩展方法，映射路由。&lt;/p&gt;
&lt;p&gt;MapRoute有多个重载的方法，所有的参数含义如下：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;173&quot;&gt;
&lt;p&gt;参数名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;133&quot;&gt;
&lt;p&gt;参数类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;
&lt;p&gt;注释&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;173&quot;&gt;
&lt;p&gt;name&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;133&quot;&gt;
&lt;p&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;
&lt;p&gt;路由名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;173&quot;&gt;
&lt;p&gt;url&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;133&quot;&gt;
&lt;p&gt;string&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;
&lt;p&gt;Url模式&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;173&quot;&gt;
&lt;p&gt;defaults&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;133&quot;&gt;
&lt;p&gt;object&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;
&lt;p&gt;默认路由值对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;173&quot;&gt;
&lt;p&gt;constraints&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;133&quot;&gt;
&lt;p&gt;object&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;一组表达式，限定URL参数值&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;173&quot;&gt;
&lt;p&gt;namespaces&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;133&quot;&gt;
&lt;p&gt;string[]&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;251&quot;&gt;
&lt;p&gt;设置一组命名空间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;参数解析&lt;/p&gt;
&lt;p&gt;1）defaults设置默认的路由值对象，&lt;/p&gt;
&lt;p&gt;2）constraints：通过正则表达式来设置约束条件&lt;/p&gt;
&lt;p&gt;如constraints:new {id=@&quot;\d+&quot;}&lt;span&gt;限制&lt;/span&gt;id只能是数值类型&lt;/p&gt;
&lt;p&gt;&lt;span&gt;规则：从前到后逐段匹配，请求&lt;/span&gt;URL参数少于定义的URL时，默认配置补全对应的参数。&lt;/p&gt;
&lt;p&gt;几个例子：&lt;/p&gt;
&lt;p&gt;routes.MapRoute(&lt;/p&gt;
&lt;p&gt;                name:&quot;&quot;,&lt;/p&gt;
&lt;p&gt;                url:&quot;V1/{controller}/{action}/{id}&quot;,&lt;/p&gt;
&lt;p&gt;                defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional },&lt;/p&gt;
&lt;p&gt;                constraints:new {id=@&quot;\d+&quot;}&lt;/p&gt;
&lt;p&gt;                );&lt;/p&gt;
&lt;p&gt;3）url&lt;/p&gt;
&lt;p&gt;{controller}/{action}/{id}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种形式包括了三段，段指的是路由中用&lt;/span&gt;/隔开的部分。约定路由中的控制器和操作用controller和action表达。&lt;/p&gt;
&lt;p&gt;段也可以包含字面值。&lt;/p&gt;
&lt;p&gt;不允许有两个连续的段值：&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;不允许：{controller}{action}/{id}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合法的：&lt;/span&gt;{language}-{current}/{controller}/{action}/{id}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多个路由的选择问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当配置多个路由时，从上到下依次匹配，直至匹配到一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配现有文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过设置RouteCollection.RouteExistingFiles属性来确定是否可以匹配到现有文件。若，routes.RouteExistingFiles = false;则，禁止匹配到现有文件，只能匹配路由表里的虚拟路由。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;        public static void RegisterRoutes(RouteCollection routes)&lt;/p&gt;
&lt;p&gt;        {&lt;/p&gt;
&lt;p&gt;            routes.RouteExistingFiles = true;&lt;/p&gt;
&lt;p&gt;            //其他配置&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用特性配置路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将属性RouteAttribute 标记到控制器或控制器操作上。&lt;/p&gt;
&lt;p&gt;[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = true)]&lt;/p&gt;
&lt;p&gt;public sealed class RouteAttribute : Attribute, IDirectRouteFactory, IRouteInfoProvider&lt;/p&gt;
&lt;p&gt;使用特性的三个属性或构造函数：&lt;/p&gt;
&lt;p&gt;public RouteAttribute(string template)：template是路由匹配模式&lt;/p&gt;
&lt;p&gt;Name：获取或设置路由名称&lt;/p&gt;
&lt;p&gt;Order：获取或设置路由应用顺序&lt;/p&gt;
&lt;p&gt;Template：获取路由匹配模式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;URL与搜索引擎优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）URL越短越好&lt;/p&gt;
&lt;p&gt;2）用破折号而不是下划线&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;使用小写字母。根据&lt;/span&gt;HTTP规范，URL区分大小写，一般的搜索引擎遵循HTTP规范。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;Glimpse观察路由&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;安装&lt;/span&gt;Glimpse&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址&lt;/span&gt;http://getglimpse.com/Docs/#download找到所需安装命令。在网站上可以看到不只应用于MVC；这里主要是使用这个工具观察路由，所以下载MVC包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324175838939-1861353171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开&lt;/span&gt;VS-&amp;gt;工具-&amp;gt;NuGet程序包管理器-&amp;gt;程序包管理器控制台，在控制台上输入命令：Install-Package Glimpse.MVC5，然后回车，执行安装，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324175940689-1248050944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;启用&lt;/span&gt;Glimpse&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行&lt;/span&gt;web应用，输入地址格式为:网站根目录/glimpse.axd，例如&lt;/p&gt;
&lt;p&gt;http://localhost:51881/glimpse.axd，显示界面如下，点击Turn Glimpse on启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324183018439-252161122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Glimpse观察&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动了&lt;/span&gt;Glimpse以后，输入http://localhost:51881/Home/Contact，看到下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324180045498-348267926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意浏览器下方多了一条统计信息，从这里可以看到路由请求的相关信息，以上面输入的地址为例：&lt;/p&gt;
&lt;p&gt;浏览器请求耗时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324180112665-1170153131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务端响应耗时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324180150337-662278504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下面的图标查看更加详细的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324180215328-1748625859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;展示详细信息的界面如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201803/1024858-20180324180240888-2107607704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到配置，运行环境，模型绑定，请求，路由，服务器，时间统计等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;扩展路由&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;创建自定义路由约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承IRouteConstraint&lt;span&gt;接口，实现&lt;/span&gt;Match方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomRouteConstraint : IRouteConstraint
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Match(HttpContextBase httpContext, Route route, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; parameterName, RouteValueDictionary values, RouteDirection routeDirection)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现验证

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证通过返回true&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;routes.MapRoute(
                name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CustomConstr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                url:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller}/{action}/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                defaults: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; { controller = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id =&lt;span&gt; UrlParameter.Optional },
                constraints:&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; {id=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomRouteConstraint()}
                );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)首先，UrlRouteModule处理新请求，将请求URL映射到定义的路由器上。&lt;/p&gt;
&lt;p&gt;2)若URL匹配到已定义的路由，那么创建IRouteHandler实例（默认实例为MvcRouteHandler对象）。&lt;/p&gt;
&lt;p&gt;3)IRouteHandler返回HTTP处理器实例（默认的为MvcHandler），HTTP处理器实例负责处理请求消息。&lt;/p&gt;
&lt;p&gt;4)HTTP处理器实例使用IControllerFactory（控制器工厂）创建对应的控制器对象。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;1）如果请求的URL能够匹配到网站根目录下的实体文件，那么不会再匹配虚拟路由，除非通过RouteCollection.RouteExistingFiles来设置改变这一行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Jess Chadwick/Todd Snyder/Hrusikesh Panda，徐雷/徐扬&lt;/p&gt;
&lt;p&gt;译。ASP.NET MVC4 Web编程&lt;/p&gt;
&lt;p&gt;2.Jon Galloway/Phil Haack/Brad Wilson/K. Scott Allen，孙远帅/邹权译  ASP.NET MVC4 高级编程（第四版）&lt;/p&gt;
&lt;p&gt;3.黄保翕，ASP.NET MVC4开发指南&lt;/p&gt;
&lt;p&gt;4.蒋金楠，ASP.NET MVC4框架揭秘&lt;/p&gt;
&lt;p&gt;5.https://www.asp.net/mvc&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Mar 2018 10:06:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8640648.html</dc:identifier>
</item>
</channel>
</rss>