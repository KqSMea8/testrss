<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Android开发学习笔记之一】5大布局方式详解 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/7912855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/7912855.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Android中常用的5大布局方式有以下几种：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线性布局（LinearLayout）：按照垂直或者水平方向布局的组件。&lt;/li&gt;
&lt;li&gt;帧布局（FrameLayout）：组件从屏幕左上方布局组件。&lt;/li&gt;
&lt;li&gt;表格布局（TableLayout）：按照行列方式布局组件。&lt;/li&gt;
&lt;li&gt;相对布局（RelativeLayout）：相对其它组件的布局方式。&lt;/li&gt;
&lt;li&gt; 绝对布局（AbsoluteLayout）：按照绝对坐标来布局组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;线性布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线性布局是Android开发中最常见的一种布局方式，它是按照垂直或者水平方向来布局，通过“android:orientation”属性可以设置线性布局的方向。属性值有垂直（vertical）和水平（horizontal）两种。&lt;/p&gt;
&lt;p&gt;常用的属性：&lt;/p&gt;
&lt;p&gt;android:orientation：可以设置布局的方向&lt;br/&gt;android:gravity:用来控制组件的对齐方式&lt;br/&gt;layout_weight：控制各个组件在布局中的相对大小&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;第一个实例&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128231720894-1832251801.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②核心代码如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;main.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt;       
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EditText 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            android:orientation&lt;/span&gt;&lt;span&gt;=&quot;horizontal&quot;&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; android:gravity=&quot;right&quot;表示Button组件向右对齐 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                android:text&lt;/span&gt;&lt;span&gt;=&quot;确定&quot;&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                android:text&lt;/span&gt;&lt;span&gt;=&quot;取消&quot;&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt;    
&lt;span&gt;34&lt;/span&gt;          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;第二个实例&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;①效果图：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128231759612-2035346771.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;②核心代码：&lt;/p&gt;
&lt;p&gt;mian.xml&lt;/p&gt;
&lt;div readability=&quot;12.3955535661&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt; android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;      
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;android:orientation&lt;/span&gt;&lt;span&gt;=&quot;horizontal&quot;&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;           
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;red&quot;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#aa0000&quot;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;android:gravity=&quot;center_horizontal&quot;水平居中 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;   
&lt;span&gt;21&lt;/span&gt;          &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;layout_weight属性以控制各个控件在布局中的相对大小。layout_weight属性是一个非负整数值。  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;             线性布局会根据该控件layout_weight值与其所处布局中所有控件layout_weight值之和的比值为该控件分配占用的区域。  
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            例如，在水平布局的LinearLayout中有两个Button，这两个Button的layout_weight属性值都为1，  
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            那么这两个按钮都会被拉伸到整个屏幕宽度的一半。如果layout_weight指为0，控件会按原大小显示，不会被拉伸；  
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            对于其余layout_weight属性值大于0的控件，系统将会减去layout_weight属性值为0的控件的宽度或者高度，  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            再用剩余的宽度或高度按相应的比例来分配每一个控件显示的宽度或高度&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Teal&quot;&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#008080&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;           
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;blue&quot;&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#0000aa&quot;&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;           
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;orange&quot;&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center_horizontal&quot;&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#FFA500&quot;&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;               
&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout 
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;           
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row one&quot;&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#aa0000&quot;&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;  &lt;span&gt;--&amp;gt;&lt;/span&gt;   
&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row two&quot;&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#DDA0DD&quot;&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;           
&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row three&quot;&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#008080&quot;&lt;/span&gt; 
&lt;span&gt;82&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt;    
&lt;span&gt;86&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView 
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;             &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;row four&quot;&lt;/span&gt; 
&lt;span&gt;88&lt;/span&gt; &lt;span&gt;            android:textSize&lt;/span&gt;&lt;span&gt;=&quot;15pt&quot;&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#FFA500&quot;&lt;/span&gt; 
&lt;span&gt;90&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt;91&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; 
&lt;span&gt;93&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt;       
&lt;span&gt;94&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;95&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. &lt;strong&gt;帧布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;帧布局是从屏幕的左上角（0,0）坐标开始布局，多个组件层叠排列，第一个添加的组件放到最底层，最后添加到框架中的视图显示在最上面。上一层的会覆盖下一层的控件。&lt;/p&gt;
&lt;p&gt;简单的例子&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128232137847-1348176364.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9.3359543632439&quot;&gt;
&lt;p&gt;② 核心代码：&lt;/p&gt;
&lt;p&gt;main.xml&lt;/p&gt;
&lt;div readability=&quot;16.212418300654&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FrameLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;   
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;300dp&quot;&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#00BFFF&quot;&lt;/span&gt;          
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;260dp&quot;&lt;/span&gt;   
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;260dp&quot;&lt;/span&gt;   
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#FFC0CB&quot;&lt;/span&gt;          
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;220dp&quot;&lt;/span&gt;   
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;220dp&quot;&lt;/span&gt;   
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            android:background&lt;/span&gt;&lt;span&gt;=&quot;#0000FF&quot;&lt;/span&gt;          
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FrameLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.&lt;strong&gt;表格布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表格布局是一个ViewGroup以表格显示它的子视图（view）元素，即行和列标识一个视图的位置。&lt;/p&gt;
&lt;p&gt;表格布局常用的属性如下：&lt;/p&gt;
&lt;p&gt;android:collapseColumns：隐藏指定的列&lt;br/&gt;android:shrinkColumns：收缩指定的列以适合屏幕，不会挤出屏幕&lt;br/&gt;android:stretchColumns：尽量把指定的列填充空白部分&lt;br/&gt;android:layout_column:控件放在指定的列&lt;br/&gt;android:layout_span:该控件所跨越的列数&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;简单的例子：&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;div readability=&quot;6.3317929759704&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128232248722-957320473.jpg&quot; alt=&quot;&quot;/&gt;&lt;p&gt;② 核心代码：&lt;/p&gt;
&lt;p&gt; main.xml&lt;/p&gt;
&lt;div readability=&quot;11.197936210131&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TableLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button1&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button2&quot;&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button3&quot;&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;android:text&lt;/span&gt;&lt;span&gt;=&quot;Button4&quot;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;android:layout_span&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                android:text&lt;/span&gt;&lt;span&gt;=&quot;Button5&quot;&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TableRow&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;           
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TableLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.&lt;strong&gt;相对布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相对布局是按照组件之间的相对位置来布局，比如在某个组件的左边，右边，上面和下面等。&lt;/p&gt;

&lt;p&gt;简单的例子&lt;/p&gt;
&lt;p&gt;①效果图：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201711/1100338-20171128232721112-758227716.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;p&gt;② 核心代码：&lt;/p&gt;
&lt;p&gt;main.xml&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;fill_parent&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        android:padding&lt;/span&gt;&lt;span&gt;=&quot;10px&quot;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView    
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tev1&quot;&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;   
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;   
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            android:layout_marginBottom&lt;/span&gt;&lt;span&gt;=&quot;30dp&quot;&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            android:text&lt;/span&gt;&lt;span&gt;=&quot;Please Type Here:&quot;&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EditText 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/tx1&quot;&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/tev1&quot;&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/btn1&quot;&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/tx1&quot;&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            android:layout_alignParentRight&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            android:text&lt;/span&gt;&lt;span&gt;=&quot;确定&quot;&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/btn2&quot;&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/tx1&quot;&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            android:layout_toLeftOf&lt;/span&gt;&lt;span&gt;=&quot;@id/btn1&quot;&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            android:layout_marginRight&lt;/span&gt;&lt;span&gt;=&quot;30dp&quot;&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            android:text&lt;/span&gt;&lt;span&gt;=&quot;取消&quot;&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. &lt;strong&gt;绝对布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 绝对布局通过指定子组件的确切X,Y坐标来确定组件的位置，在Android2.0 API文档中标明该类已经过期，可以使用FrameLayout或者RelativeLayout来代替。所以这里不再详细介绍。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 28 Nov 2017 15:29:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/7912855.html</dc:identifier>
</item>
<item>
<title>JavaWeb框架SSH_Struts2_(三) - Mairr</title>
<link>http://www.cnblogs.com/Mairr/p/7906086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mairr/p/7906086.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. Struts2的拦截器（使用拦截器实现权限控制）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;拦截器简介&lt;br/&gt;&lt;ul&gt;&lt;li&gt;拦截器概述&lt;/li&gt;
&lt;li&gt;拦截器工作原理&lt;/li&gt;
&lt;li&gt;拦截器的配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Struts2的内建拦截器
&lt;ul&gt;&lt;li&gt;内建拦截器的介绍&lt;/li&gt;
&lt;li&gt;内建拦截器的配置&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自定义拦截器
&lt;ul&gt;&lt;li&gt;实现自定义拦截器&lt;/li&gt;
&lt;li&gt;应用案例--&amp;gt;使用拦截器实现权限控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 具体内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 拦截器的概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;拦截器是Struts2的核心组成部分，它可以动态的拦截Action调用的对象，类似与Servlet中的过滤器。Struts2的拦截器是AOP(Aspect-Object-Programming,面向切面编程)的一种实现策略，是可插拔的，需要某一个功能时就“插入”这个功能的拦截器，不需要这个功能就“拔出”拦截器。开发者只需要提供拦截器的实现类，并将其配置在Struts.xml中即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.2 拦截器的工作原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　通常情况下，拦截器都是一代理的方式调用的，它&lt;span&gt;&lt;em&gt;&lt;strong&gt;在一个Action执行前后进行拦截&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;，围绕着Action和Result的执行而执行，其工作方式如下图所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171127204404300-1173413336.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Struts2拦截器实现原理与Servlet过滤器实现原理类似，它以链式执行，&lt;strong&gt;&lt;span&gt;&lt;em&gt;对真正要执行的方法（execute（））进行拦截&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;。首先执行Action配置的拦截器，在Action和Result执行之后，拦截器会再次执行（与先前调用的顺序相反），在此链式执行的过程中，每一个拦截器都可以直接返回，从而终止余下的拦截器、Action及Result的执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1.3 拦截器的配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1） 拦截器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;拦截器的配置在struts.xml文件中完成的，它通常以&amp;lt;interceptor&amp;gt;标签开头，以&amp;lt;/interceptor&amp;gt;标签结束。定义拦截器的语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorName&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;paramName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;paramValue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述语法格式中，name属性用来指定拦截器的名称，class属性用于指定拦截器的实现类。在定义时，使用&amp;lt;param&amp;gt;标签传入参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2） 拦截器栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在实际开发中，在Action执行前同时执行多个拦截动作，如用户登陆检查等，这时可以把多个拦截器组成拦截器栈。在使用时，可以将栈内的多个拦截器当成一个整体来引用。当拦截器栈被附加到一个Action上时，在执行Action之前必须先执行拦截器栈中的每一个拦截器。&lt;/p&gt;
&lt;p&gt;　　定义拦截器栈使用&amp;lt;interceptors&amp;gt;和&amp;lt;interceptor-stack&amp;gt;子元素，当配置多个拦截器时，需要使用&amp;lt;interceptor-ref&amp;gt;元素来指定多个拦截器，配置语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorStackName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorName&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
              ...
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述语法中，interceptorStackName值表示配置的拦截器栈的名称，interceptorName值表示拦截器的名称。除此之外，在一个拦截器栈中还可以包含另一个拦截器栈，实例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;拦截器的声明&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义一个拦截器栈mystack,该拦截器栈中包括两个拦截器和一个拦截器栈&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中定义的拦截器栈是myStack，在myStack栈中，除了引用了两个自定义的拦截器interceptor1和interceptor2外，还引用了一个内置拦截器栈defaultStack，这个拦截器是必须要引入的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3） 默认拦截器栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　默认拦截器可以对其指定包中的所有Action起到拦截的作用。一旦为某个包指定了默认拦截器，并且该包中的Action未显式地指定拦截器，则会使用默认拦截器。默认拦截器需要使用&amp;lt;default-interceptor-ref&amp;gt;元素，此元素为&amp;lt;package&amp;gt;元素的子元素。其语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;拦截器(栈)的名称&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述语法格式中，name属性的值必须是已经存在的拦截器或拦截器栈的名称。下面用该语法格式配置一个默认拦截器，示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;拦截器的声明&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;拦截器栈的名称&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;interceptorClass&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义一个拦截器栈mystack,该拦截器栈中包括两个拦截器和一个拦截器栈&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptor2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置该包下的默认拦截器，既可以是拦截器，也可以是拦截器栈 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cn.itcast.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中，指定了包下的默认拦截器是一个拦截器栈，该拦截器栈将会作用于包下所有的Action。&lt;/p&gt;
&lt;p&gt;　　Notice：一个包下只能定义一个默认拦截器，如果需要多个拦截器作为默认拦截器，则可以将这些拦截器定义为一个拦截器栈，再将这个拦截器栈作为默认拦截器即可。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 Struts2的内建拦截器&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2.1 内建拦截器的介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;只要自定义的包继承了Struts2的struts-default包，就可以使用默认包中的拦截器，否则需要自己定义拦截器。在Struts-default.xml中每一个拦截器都具有不同的意义（具体拦截器说明---&amp;gt;省略）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2.2 内建拦截器的配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面2.1已经介绍过相关配置，此处不再赘述。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 Struts2自定义拦截器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　struts2的内置拦截器可以实现大部分的拦截任务，但是一些与系统逻辑相关的通用功能（如权限的控制、用户登陆控制等），则需要通过自定义拦截器来实现。本节详讲如何自定义拦截器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3.1 实现自定义拦截器&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　在程序开发过程中，如果需要开发自己的拦截器类，就需要直接或间接地实现com.opensymphony.xwork2. interceptor. Interceptor接口，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.DefaultActionInvocation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Interceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy();
    String interceptor (DefaultActionInvocation)&lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该接口提供一下三个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;void init（）：该方法在拦截器被创建后会立即被调用，它在拦截器的生命周期只有内只被调用一次。可以在该方法中对相关的资源进行必要的初始化;&lt;/li&gt;
&lt;li&gt;void destroy（）：该方法与init（）方法相对应，在拦截器实例被销毁之前，将调用该方法来释放与拦截器相关的资源。它在拦截器的生命周期内也只被调用一次。&lt;/li&gt;
&lt;li&gt;Spring intercept（ActionInvocation invocation）throws Exception：该方法是拦截器的核心方法，用来真正执行拦截工作的代码，实现具体的拦截工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.3.2 应用案例-----使用拦截器实现权限控制&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;通过之前对拦截器学习，可以将自定义拦截器的使用分为一下三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户自定义拦截器类，必须实现Interceptor接口或者继承AbstractInterceptor类;&lt;/li&gt;
&lt;li&gt;需要在struts.xml中，定义自定义拦截器;&lt;/li&gt;
&lt;li&gt;在struts.xml中的Action中使用拦截器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;

&lt;p&gt;（1）在intellij idea中创建Struts2的项目（可参考之前的博客 http://www.cnblogs.com/Mairr/p/7846747.html）&lt;/p&gt;
&lt;p&gt;（2）web.xml配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;&lt;/span&gt;&lt;span&gt;
         version&lt;/span&gt;&lt;span&gt;=&quot;3.1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;struts2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;struts2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;首页(这一块儿是自己加进来的)&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;main.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）在src目录下创建java包，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128213936175-2091634270.png&quot; alt=&quot;&quot; width=&quot;241&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）User.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.domin;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)LoginAction.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.Mairr.domin.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ModelDriven;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginAction &lt;span&gt;extends&lt;/span&gt; ActionSupport &lt;span&gt;implements&lt;/span&gt; ModelDriven &amp;lt;User&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getModel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String execute() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取ActionContext&lt;/span&gt;
        ActionContext actionContext =&lt;span&gt; ActionContext.getContext();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;Mairr&quot;.equals(user.getUsername()) &amp;amp;&amp;amp; &quot;123&quot;&lt;span&gt;.equals(user.getPassword())) {
            actionContext.getSession().put(&lt;/span&gt;&quot;user&quot;&lt;span&gt;, user);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            actionContext.put(&lt;/span&gt;&quot;msg&quot;, &quot;用户名或者密码不正确&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INPUT;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(6) BookAction.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(){
        System.out.println(&lt;/span&gt;&quot;book add&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String del(){
        System.out.println(&lt;/span&gt;&quot;book del&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String update(){
        System.out.println(&lt;/span&gt;&quot;book update&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String find(){
        System.out.println(&lt;/span&gt;&quot;book find&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(7)PrivilegeInterceptor.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.Mairr.interceptor;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.Action;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionInvocation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.interceptor.AbstractInterceptor;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PrivilegeInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractInterceptor{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String intercept(ActionInvocation invocation)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到ActionContext&lt;/span&gt;
        ActionContext actionContext =&lt;span&gt; invocation.getInvocationContext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取user对象&lt;/span&gt;
        Object user = actionContext.getSession().get(&quot;user&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(user != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; invocation.invoke();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            actionContext.put(&lt;/span&gt;&quot;msg&quot;,&quot;您还未登录，请先登陆&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Action.LOGIN;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户如果不存在，返回login直&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(8) main.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%--
  &lt;/span&gt;&lt;span&gt;Created by IntelliJ IDEA.
  User: mairr
  Date: 17-11-28
  Time: 下午5:18
  To change this template use File | Settings | File Templates.
--%&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;main.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book del&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book add&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book update&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;book find&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(9) login.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%--
  &lt;/span&gt;&lt;span&gt;Created by IntelliJ IDEA.
  User: mairr
  Date: 17-11-28
  Time: 下午5:17
  To change this template use File | Settings | File Templates.
--%&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登陆&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        ${requestScope.msg}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;login.action&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align: right;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;密码：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;align&lt;/span&gt;&lt;span&gt;=&quot;right&quot;&lt;/span&gt;&lt;span&gt; colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;登陆&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(10)success.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%--
  &lt;/span&gt;&lt;span&gt;Created by IntelliJ IDEA.
  User: mairr
  Date: 17-11-28
  Time: 下午5:42
  To change this template use File | Settings | File Templates.
--%&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;%@ page &lt;/span&gt;&lt;span&gt;contentType&lt;/span&gt;&lt;span&gt;=&quot;text/html;charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&quot;java&quot;&lt;/span&gt;&lt;span&gt; %&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;成功页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
用户${user.username}操作成功
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(11) struts.xml配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;
        &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts2&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;声明拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;privilege&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.Mairr.interceptor.PrivilegeInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;privilege&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;用户登陆操作&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.Mairr.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/main.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;关于book操作&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;book_*&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.Mairr.action.BookAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;{1}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/login.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;在action中使用自定义拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;strong&gt;完成上述程序之后，发布程序，登录本机http端口，查看拦截器实现功能;（http://localhost:8080/login.jsp）&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录界面如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128221525706-1283913007.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;

&lt;p&gt;---------&amp;gt;(登陆失败)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128221737347-1513695899.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登陆成功（用户名：Mairr   密码：123 ）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128222037300-495010381.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-----------&amp;gt;(登陆成功，页面跳转到操作界面)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128222234206-1143041419.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;

&lt;p&gt;--------&amp;gt;(选择操作)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194681/201711/1194681-20171128222515894-1575007049.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;strong&gt;上面的案例中，创建了一个方法过滤拦截器PrivilegeInterceptor，然后在Struts.xml中配置了该拦截器，如果用户没有登陆，则无法对页面进行相应的操作，只有登陆后才有权操作页面的相应功能。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 14:31:00 +0000</pubDate>
<dc:creator>Mairr</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mairr/p/7906086.html</dc:identifier>
</item>
<item>
<title>Kafka设计解析（八）- Exactly Once语义与事务机制原理 - 郭俊Jason</title>
<link>http://www.cnblogs.com/jasongj/p/7912348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jasongj/p/7912348.html</guid>
<description>&lt;blockquote readability=&quot;3.3650793650794&quot;&gt;
&lt;p&gt;原创文章，首发自&lt;a href=&quot;http://www.jasongj.com/&quot;&gt;&lt;strong&gt;作者个人博客&lt;/strong&gt;&lt;/a&gt;，转载请务必将下面这段话置于文章开头处。&lt;br/&gt;本文转发自&lt;a href=&quot;http://www.jasongj.com/&quot;&gt;&lt;strong&gt;技术世界&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.jasongj.com/kafka/transaction/&quot;&gt;原文链接&lt;/a&gt;　&lt;a href=&quot;http://www.jasongj.com/kafka/transaction/&quot; class=&quot;uri&quot;&gt;http://www.jasongj.com/kafka/transaction/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文所有Kafka原理性的描述除特殊说明外均基于Kafka 1.0.0版本。&lt;/p&gt;

&lt;p&gt;Kafka事务机制的实现主要是为了支持&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Exactly Once&lt;/code&gt;即正好一次语义&lt;/li&gt;
&lt;li&gt;操作的原子性&lt;/li&gt;
&lt;li&gt;有状态操作的可恢复性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;exactly-once&quot;&gt;2.1 &lt;code&gt;Exactly Once&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;《&lt;a href=&quot;http://www.cnblogs.com/2015/03/10/KafkaColumn1/#Kafka-delivery-guarantee&quot;&gt;Kafka背景及架构介绍&lt;/a&gt;》一文中有说明Kafka在0.11.0.0之前的版本中只支持&lt;code&gt;At Least Once&lt;/code&gt;和&lt;code&gt;At Most Once&lt;/code&gt;语义，尚不支持&lt;code&gt;Exactly Once&lt;/code&gt;语义。&lt;/p&gt;
&lt;p&gt;但是在很多要求严格的场景下，如使用Kafka处理交易数据，&lt;code&gt;Exactly Once&lt;/code&gt;语义是必须的。我们可以通过让下游系统具有幂等性来配合Kafka的&lt;code&gt;At Least Once&lt;/code&gt;语义来间接实现&lt;code&gt;Exactly Once&lt;/code&gt;。但是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该方案要求下游系统支持幂等操作，限制了Kafka的适用场景&lt;/li&gt;
&lt;li&gt;实现门槛相对较高，需要用户对Kafka的工作机制非常了解&lt;/li&gt;
&lt;li&gt;对于Kafka Stream而言，Kafka本身即是自己的下游系统，但Kafka在0.11.0.0版本之前不具有幂等发送能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，Kafka本身对&lt;code&gt;Exactly Once&lt;/code&gt;语义的支持就非常必要。&lt;/p&gt;
&lt;h2 id=&quot;操作原子性&quot;&gt;2.2 操作原子性&lt;/h2&gt;
&lt;p&gt;操作的原子性是指，多个操作要么全部成功要么全部失败，不存在部分成功部分失败的可能。&lt;/p&gt;
&lt;p&gt;实现原子性操作的意义在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作结果更可控，有助于提升数据一致性&lt;/li&gt;
&lt;li&gt;便于故障恢复。因为操作是原子的，从故障中恢复时只需要重试该操作（如果原操作失败）或者直接跳过该操作（如果原操作成功），而不需要记录中间状态，更不需要针对中间状态作特殊处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;幂等性发送&quot;&gt;3.1 幂等性发送&lt;/h2&gt;
&lt;p&gt;上文提到，实现&lt;code&gt;Exactly Once&lt;/code&gt;的一种方法是让下游系统具有幂等处理特性，而在Kafka Stream中，Kafka Producer本身就是“下游”系统，因此如果能让Producer具有幂等处理特性，那就可以让Kafka Stream在一定程度上支持&lt;code&gt;Exactly once&lt;/code&gt;语义。&lt;/p&gt;
&lt;p&gt;为了实现Producer的幂等语义，Kafka引入了&lt;code&gt;Producer ID&lt;/code&gt;（即&lt;code&gt;PID&lt;/code&gt;）和&lt;code&gt;Sequence Number&lt;/code&gt;。每个新的Producer在初始化的时候会被分配一个唯一的PID，该PID对用户完全透明而不会暴露给用户。&lt;/p&gt;
&lt;p&gt;对于每个PID，该Producer发送数据的每个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;都对应一个从0开始单调递增的&lt;code&gt;Sequence Number&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类似地，Broker端也会为每个&lt;code&gt;&amp;lt;PID, Topic, Partition&amp;gt;&lt;/code&gt;维护一个序号，并且每次Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号（即最后一次Commit的消息的序号）大一，则Broker会接受它，否则将其丢弃：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果消息序号比Broker维护的序号大一以上，说明中间有数据尚未写入，也即乱序，此时Broker拒绝该消息，Producer抛出&lt;code&gt;InvalidSequenceNumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出&lt;code&gt;DuplicateSequenceNumber&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述设计解决了0.11.0.0之前版本中的两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Broker保存消息后，发送ACK前宕机，Producer认为消息未发送成功并重试，造成数据重复&lt;/li&gt;
&lt;li&gt;前一条消息发送失败，后一条消息发送成功，前一条消息重试后成功，造成数据乱序&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事务性保证&quot;&gt;3.2 事务性保证&lt;/h2&gt;
&lt;p&gt;上述幂等设计只能保证单个Producer对于同一个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的&lt;code&gt;Exactly Once&lt;/code&gt;语义。&lt;/p&gt;
&lt;p&gt;另外，它并不能保证写操作的原子性——即多个写操作，要么全部被Commit要么全部不被Commit。&lt;/p&gt;
&lt;p&gt;更不能保证多个读写操作的的原子性。尤其对于Kafka Stream应用而言，典型的操作即是从某个Topic消费数据，经过一系列转换后写回另一个Topic，保证从源Topic的读取与向目标Topic的写入的原子性有助于从故障中恢复。&lt;/p&gt;
&lt;p&gt;事务保证可使得应用程序将生产数据和消费数据当作一个原子单元来处理，要么全部成功，要么全部失败，即使该生产或消费跨多个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，有状态的应用也可以保证重启后从断点处继续处理，也即事务恢复。&lt;/p&gt;
&lt;p&gt;为了实现这种效果，应用程序必须提供一个稳定的（重启后不变）唯一的ID，也即&lt;code&gt;Transaction ID&lt;/code&gt;。&lt;code&gt;Transactin ID&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;可能一一对应。区别在于&lt;code&gt;Transaction ID&lt;/code&gt;由用户提供，而&lt;code&gt;PID&lt;/code&gt;是内部的实现对用户透明。&lt;/p&gt;
&lt;p&gt;另外，为了保证新的Producer启动后，旧的具有相同&lt;code&gt;Transaction ID&lt;/code&gt;的Producer即失效，每次Producer通过&lt;code&gt;Transaction ID&lt;/code&gt;拿到PID的同时，还会获取一个单调递增的epoch。由于旧的Producer的epoch比新Producer的epoch小，Kafka可以很容易识别出该Producer是老的Producer并拒绝其请求。&lt;/p&gt;
&lt;p&gt;有了&lt;code&gt;Transaction ID&lt;/code&gt;后，Kafka可保证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨Session的数据幂等发送。当具有相同&lt;code&gt;Transaction ID&lt;/code&gt;的新的Producer实例被创建且工作时，旧的且拥有相同&lt;code&gt;Transaction ID&lt;/code&gt;的Producer将不再工作。&lt;/li&gt;
&lt;li&gt;跨Session的事务恢复。如果某个应用实例宕机，新的实例可以保证任何未完成的旧的事务要么Commit要么Abort，使得新实例从一个正常状态开始工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，上述的事务保证是从Producer的角度去考虑的。从Consumer的角度来看，该保证会相对弱一些。尤其是不能保证所有被某事务Commit过的所有消息都被一起消费，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于压缩的Topic而言，同一事务的某些消息可能被其它版本覆盖&lt;/li&gt;
&lt;li&gt;事务包含的消息可能分布在多个Segment中（即使在同一个Partition内），当老的Segment被删除时，该事务的部分数据可能会丢失&lt;/li&gt;
&lt;li&gt;Consumer在一个事务内可能通过seek方法访问任意Offset的消息，从而可能丢失部分消息&lt;/li&gt;
&lt;li&gt;Consumer可能并不需要消费某一事务内的所有Partition，因此它将永远不会读取组成该事务的所有消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;事务性消息传递&quot;&gt;4.1 事务性消息传递&lt;/h2&gt;
&lt;p&gt;这一节所说的事务主要指原子性，也即Producer将多条消息作为一个事务批量发送，要么全部成功要么全部失败。&lt;/p&gt;
&lt;p&gt;为了实现这一点，Kafka 0.11.0.0引入了一个服务器端的模块，名为&lt;code&gt;Transaction Coordinator&lt;/code&gt;，用于管理Producer发送的消息的事务性。&lt;/p&gt;
&lt;p&gt;该&lt;code&gt;Transaction Coordinator&lt;/code&gt;维护&lt;code&gt;Transaction Log&lt;/code&gt;，该log存于一个内部的Topic内。由于Topic数据具有持久性，因此事务的状态也具有持久性。&lt;/p&gt;
&lt;p&gt;Producer并不直接读写&lt;code&gt;Transaction Log&lt;/code&gt;，它与&lt;code&gt;Transaction Coordinator&lt;/code&gt;通信，然后由&lt;code&gt;Transaction Coordinator&lt;/code&gt;将该事务的状态插入相应的&lt;code&gt;Transaction Log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transaction Log&lt;/code&gt;的设计与&lt;code&gt;Offset Log&lt;/code&gt;用于保存Consumer的Offset类似。&lt;/p&gt;
&lt;h2 id=&quot;事务中offset的提交&quot;&gt;4.2 事务中Offset的提交&lt;/h2&gt;
&lt;p&gt;许多基于Kafka的应用，尤其是Kafka Stream应用中同时包含Consumer和Producer，前者负责从Kafka中获取消息，后者负责将处理完的数据写回Kafka的其它Topic中。&lt;/p&gt;
&lt;p&gt;为了实现该场景下的事务的原子性，Kafka需要保证对Consumer Offset的Commit与Producer对发送消息的Commit包含在同一个事务中。否则，如果在二者Commit中间发生异常，根据二者Commit的顺序可能会造成数据丢失和数据重复：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果先Commit Producer发送数据的事务再Commit Consumer的Offset，即&lt;code&gt;At Least Once&lt;/code&gt;语义，可能造成数据重复。&lt;/li&gt;
&lt;li&gt;如果先Commit Consumer的Offset，再Commit Producer数据发送事务，即&lt;code&gt;At Most Once&lt;/code&gt;语义，可能造成数据丢失。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;用于事务特性的控制型消息&quot;&gt;4.3 用于事务特性的控制型消息&lt;/h2&gt;
&lt;p&gt;为了区分写入Partition的消息被Commit还是Abort，Kafka引入了一种特殊类型的消息，即&lt;code&gt;Control Message&lt;/code&gt;。该类消息的Value内不包含任何应用相关的数据，并且不会暴露给应用程序。它只用于Broker与Client间的内部通信。&lt;/p&gt;
&lt;p&gt;对于Producer端事务，Kafka以Control Message的形式引入一系列的&lt;code&gt;Transaction Marker&lt;/code&gt;。Consumer即可通过该标记判定对应的消息被Commit了还是Abort了，然后结合该Consumer配置的隔离级别决定是否应该将该消息返回给应用程序。&lt;/p&gt;
&lt;h2 id=&quot;事务处理样例代码&quot;&gt;4.4 事务处理样例代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Producer&amp;lt;String, String&amp;gt; producer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;(props);
    
&lt;span class=&quot;co&quot;&gt;// 初始化事务，包括结束该Transaction ID对应的未完成的事务（如果有）&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 保证新的事务在一个正确的状态下启动&lt;/span&gt;
producer.&lt;span class=&quot;fu&quot;&gt;initTransactions&lt;/span&gt;();

&lt;span class=&quot;co&quot;&gt;// 开始事务&lt;/span&gt;
producer.&lt;span class=&quot;fu&quot;&gt;beginTransaction&lt;/span&gt;();

&lt;span class=&quot;co&quot;&gt;// 消费数据&lt;/span&gt;
ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);

&lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
    &lt;span class=&quot;co&quot;&gt;// 发送数据&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&lt;span class=&quot;st&quot;&gt;&quot;Topic&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Key&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Value&quot;&lt;/span&gt;));
    
    &lt;span class=&quot;co&quot;&gt;// 发送消费数据的Offset，将上述数据消费与数据发送纳入同一个Transaction内&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;sendOffsetsToTransaction&lt;/span&gt;(offsets, &lt;span class=&quot;st&quot;&gt;&quot;group1&quot;&lt;/span&gt;);

    &lt;span class=&quot;co&quot;&gt;// 数据发送及Offset发送均成功的情况下，提交事务&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;commitTransaction&lt;/span&gt;();
} &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) {
    &lt;span class=&quot;co&quot;&gt;// 数据发送或者Offset发送出现异常时，终止事务&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;abortTransaction&lt;/span&gt;();
} &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// 关闭Producer和Consumer&lt;/span&gt;
    producer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    consumer.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;完整事务过程&quot;&gt;4.5 完整事务过程&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;100%&quot; src=&quot;http://www.jasongj.com/img/kafka/KafkaColumn8/KafkaTransaction.png&quot; alt=&quot;Kafka Transaction&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;找到transaction-coordinator&quot;&gt;4.5.1 找到&lt;code&gt;Transaction Coordinator&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;Transaction Coordinator&lt;/code&gt;是分配PID和管理事务的核心，因此Producer要做的第一件事情就是通过向任意一个Broker发送&lt;code&gt;FindCoordinator&lt;/code&gt;请求找到&lt;code&gt;Transaction Coordinator&lt;/code&gt;的位置。&lt;/p&gt;
&lt;p&gt;注意：只有应用程序为Producer配置了&lt;code&gt;Transaction ID&lt;/code&gt;时才可使用事务特性，也才需要这一步。另外，由于事务性要求Producer开启幂等特性，因此通过将&lt;code&gt;transactional.id&lt;/code&gt;设置为非空从而开启事务特性的同时也需要通过将&lt;code&gt;enable.idempotence&lt;/code&gt;设置为true来开启幂等特性。&lt;/p&gt;
&lt;h3 id=&quot;获取pid&quot;&gt;4.5.2 获取PID&lt;/h3&gt;
&lt;p&gt;找到&lt;code&gt;Transaction Coordinator&lt;/code&gt;后，具有幂等特性的Producer必须发起&lt;code&gt;InitPidRequest&lt;/code&gt;请求以获取PID。&lt;/p&gt;
&lt;p&gt;注意：只要开启了幂等特性即必须执行该操作，而无须考虑该Producer是否开启了事务特性。&lt;/p&gt;
&lt;p&gt;*** 如果事务特性被开启 ***&lt;br/&gt;&lt;code&gt;InitPidRequest&lt;/code&gt;会发送给&lt;code&gt;Transaction Coordinator&lt;/code&gt;。如果&lt;code&gt;Transaction Coordinator&lt;/code&gt;是第一次收到包含有该&lt;code&gt;Transaction ID&lt;/code&gt;的InitPidRequest请求，它将会把该&lt;code&gt;&amp;lt;TransactionID, PID&amp;gt;&lt;/code&gt;存入&lt;code&gt;Transaction Log&lt;/code&gt;，如上图中步骤2.1所示。这样可保证该对应关系被持久化，从而保证即使&lt;code&gt;Transaction Coordinator&lt;/code&gt;宕机该对应关系也不会丢失。&lt;/p&gt;
&lt;p&gt;除了返回PID外，&lt;code&gt;InitPidRequest&lt;/code&gt;还会执行如下任务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加该PID对应的epoch。具有相同PID但epoch小于该epoch的其它Producer（如果有）新开启的事务将被拒绝。&lt;/li&gt;
&lt;li&gt;恢复（Commit或Abort）之前的Producer未完成的事务（如果有）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;code&gt;InitPidRequest&lt;/code&gt;的处理过程是同步阻塞的。一旦该调用正确返回，Producer即可开始新的事务。&lt;/p&gt;
&lt;p&gt;另外，如果事务特性未开启，&lt;code&gt;InitPidRequest&lt;/code&gt;可发送至任意Broker，并且会得到一个全新的唯一的PID。该Producer将只能使用幂等特性以及单一Session内的事务特性，而不能使用跨Session的事务特性。&lt;/p&gt;
&lt;h3 id=&quot;开启事务&quot;&gt;4.5.3 开启事务&lt;/h3&gt;
&lt;p&gt;Kafka从0.11.0.0版本开始，提供&lt;code&gt;beginTransaction()&lt;/code&gt;方法用于开启一个事务。调用该方法后，Producer本地会记录已经开启了事务，但&lt;code&gt;Transaction Coordinator&lt;/code&gt;只有在Producer发送第一条消息后才认为事务已经开启。&lt;/p&gt;
&lt;h3 id=&quot;consume-transform-produce&quot;&gt;4.5.4 Consume-Transform-Produce&lt;/h3&gt;
&lt;p&gt;这一阶段，包含了整个事务的数据处理过程，并且包含了多种请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AddPartitionsToTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;一个Producer可能会给多个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;发送数据，给一个新的&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;发送数据前，它需要先向&lt;code&gt;Transaction Coordinator&lt;/code&gt;发送&lt;code&gt;AddPartitionsToTxnRequest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;会将该&lt;code&gt;&amp;lt;Transaction, Topic, Partition&amp;gt;&lt;/code&gt;存于&lt;code&gt;Transaction Log&lt;/code&gt;内，并将其状态置为&lt;code&gt;BEGIN&lt;/code&gt;，如上图中步骤4.1所示。有了该信息后，我们才可以在后续步骤中为每个&lt;code&gt;Topic, Partition&amp;gt;&lt;/code&gt;设置COMMIT或者ABORT标记（如上图中步骤5.2所示）。&lt;/p&gt;
&lt;p&gt;另外，如果该&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;为该事务中第一个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;，&lt;code&gt;Transaction Coordinator&lt;/code&gt;还会启动对该事务的计时（每个事务都有自己的超时时间）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ProduceRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;Producer通过一个或多个&lt;code&gt;ProduceRequest&lt;/code&gt;发送一系列消息。除了应用数据外，该请求还包含了PID，epoch，和&lt;code&gt;Sequence Number&lt;/code&gt;。该过程如上图中步骤4.2所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;AddOffsetsToTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;为了提供事务性，Producer新增了&lt;code&gt;sendOffsetsToTransaction&lt;/code&gt;方法，该方法将多组消息的发送和消费放入同一批处理内。&lt;/p&gt;
&lt;p&gt;该方法先判断在当前事务中该方法是否已经被调用并传入了相同的Group ID。若是，直接跳到下一步；若不是，则向&lt;code&gt;Transaction Coordinator&lt;/code&gt;发送&lt;code&gt;AddOffsetsToTxnRequests&lt;/code&gt;请求，&lt;code&gt;Transaction Coordinator&lt;/code&gt;将对应的所有&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;存于&lt;code&gt;Transaction Log&lt;/code&gt;中，并将其状态记为&lt;code&gt;BEGIN&lt;/code&gt;，如上图中步骤4.3所示。该方法会阻塞直到收到响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TxnOffsetCommitRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;作为&lt;code&gt;sendOffsetsToTransaction&lt;/code&gt;方法的一部分，在处理完&lt;code&gt;AddOffsetsToTxnRequest&lt;/code&gt;后，Producer也会发送&lt;code&gt;TxnOffsetCommit&lt;/code&gt;请求给&lt;code&gt;Consumer Coordinator&lt;/code&gt;从而将本事务包含的与读操作相关的各&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的Offset持久化到内部的&lt;code&gt;__consumer_offsets&lt;/code&gt;中，如上图步骤4.4所示。&lt;/p&gt;
&lt;p&gt;在此过程中，&lt;code&gt;Consumer Coordinator&lt;/code&gt;会通过PID和对应的epoch来验证是否应该允许该Producer的该请求。&lt;/p&gt;
&lt;p&gt;这里需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写入&lt;code&gt;__consumer_offsets&lt;/code&gt;的Offset信息在当前事务Commit前对外是不可见的。也即在当前事务被Commit前，可认为该Offset尚未Commit，也即对应的消息尚未被完成处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Consumer Coordinator&lt;/code&gt;并不会立即更新缓存中相应&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的Offset，因为此时这些更新操作尚未被COMMIT或ABORT。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;commit或abort事务&quot;&gt;4.5.5 Commit或Abort事务&lt;/h3&gt;
&lt;p&gt;一旦上述数据写入操作完成，应用程序必须调用&lt;code&gt;KafkaProducer&lt;/code&gt;的&lt;code&gt;commitTransaction&lt;/code&gt;方法或者&lt;code&gt;abortTransaction&lt;/code&gt;方法以结束当前事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;EndTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;commitTransaction&lt;/code&gt;方法使得Producer写入的数据对下游Consumer可见。&lt;code&gt;abortTransaction&lt;/code&gt;方法通过&lt;code&gt;Transaction Marker&lt;/code&gt;将Producer写入的数据标记为&lt;code&gt;Aborted&lt;/code&gt;状态。下游的Consumer如果将&lt;code&gt;isolation.level&lt;/code&gt;设置为&lt;code&gt;READ_COMMITTED&lt;/code&gt;，则它读到被Abort的消息后直接将其丢弃而不会返回给客户程序，也即被Abort的消息对应用程序不可见。&lt;/p&gt;
&lt;p&gt;无论是Commit还是Abort，Producer都会发送&lt;code&gt;EndTxnRequest&lt;/code&gt;请求给&lt;code&gt;Transaction Coordinator&lt;/code&gt;，并通过标志位标识是应该Commit还是Abort。&lt;/p&gt;
&lt;p&gt;收到该请求后，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会进行如下操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;消息写入&lt;code&gt;Transaction Log&lt;/code&gt;，如上图中步骤5.1所示&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;WriteTxnMarker&lt;/code&gt;请求以&lt;code&gt;Transaction Marker&lt;/code&gt;的形式将&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;信息写入用户数据日志以及&lt;code&gt;Offset Log&lt;/code&gt;中，如上图中步骤5.2所示&lt;/li&gt;
&lt;li&gt;最后将&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;信息写入&lt;code&gt;Transaction Log&lt;/code&gt;中，如上图中步骤5.3所示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;补充说明：对于&lt;code&gt;commitTransaction&lt;/code&gt;方法，它会在发送&lt;code&gt;EndTxnRequest&lt;/code&gt;之前先调用flush方法以确保所有发送出去的数据都得到相应的ACK。对于&lt;code&gt;abortTransaction&lt;/code&gt;方法，在发送&lt;code&gt;EndTxnRequest&lt;/code&gt;之前直接将当前Buffer中的事务性消息（如果有）全部丢弃，但必须等待所有被发送但尚未收到ACK的消息发送完成。&lt;/p&gt;
&lt;p&gt;上述第二步是实现将一组读操作与写操作作为一个事务处理的关键。因为Producer写入的数据Topic以及记录Comsumer Offset的Topic会被写入相同的&lt;code&gt;Transactin Marker&lt;/code&gt;，所以这一组读操作与写操作要么全部COMMIT要么全部ABORT。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;WriteTxnMarkerRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;上面提到的&lt;code&gt;WriteTxnMarkerRequest&lt;/code&gt;由&lt;code&gt;Transaction Coordinator&lt;/code&gt;发送给当前事务涉及到的每个&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的Leader。收到该请求后，对应的Leader会将对应的&lt;code&gt;COMMIT(PID)&lt;/code&gt;或者&lt;code&gt;ABORT(PID)&lt;/code&gt;控制信息写入日志，如上图中步骤5.2所示。&lt;/p&gt;
&lt;p&gt;该控制消息向Broker以及Consumer表明对应PID的消息被Commit了还是被Abort了。&lt;/p&gt;
&lt;p&gt;这里要注意，如果事务也涉及到&lt;code&gt;__consumer_offsets&lt;/code&gt;，即该事务中有消费数据的操作且将该消费的Offset存于&lt;code&gt;__consumer_offsets&lt;/code&gt;中，&lt;code&gt;Transaction Coordinator&lt;/code&gt;也需要向该内部Topic的各Partition的Leader发送&lt;code&gt;WriteTxnMarkerRequest&lt;/code&gt;从而写入&lt;code&gt;COMMIT(PID)&lt;/code&gt;或&lt;code&gt;COMMIT(PID)&lt;/code&gt;控制信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;写入最终的&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;消息&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;写完所有的&lt;code&gt;Transaction Marker&lt;/code&gt;后，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会将最终的&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;消息写入&lt;code&gt;Transaction Log&lt;/code&gt;中以标明该事务结束，如上图中步骤5.3所示。&lt;/p&gt;
&lt;p&gt;此时，&lt;code&gt;Transaction Log&lt;/code&gt;中所有关于该事务的消息全部可以移除。当然，由于Kafka内数据是Append Only的，不可直接更新和删除，这里说的移除只是将其标记为null从而在Log Compact时不再保留。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;的写入并不需要得到所有Rreplica的ACK，因为如果该消息丢失，可以根据事务协议重发。&lt;/p&gt;
&lt;p&gt;补充说明，如果参与该事务的某些&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;在被写入&lt;code&gt;Transaction Marker&lt;/code&gt;前不可用，它对&lt;code&gt;READ_COMMITTED&lt;/code&gt;的Consumer不可见，但不影响其它可用&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;的COMMIT或ABORT。在该&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;恢复可用后，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会重新根据&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;向该&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;发送&lt;code&gt;Transaction Marker&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4.6 总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PID&lt;/code&gt;与&lt;code&gt;Sequence Number&lt;/code&gt;的引入实现了写操作的幂等性&lt;/li&gt;
&lt;li&gt;写操作的幂等性结合&lt;code&gt;At Least Once&lt;/code&gt;语义实现了单一Session内的&lt;code&gt;Exactly Once&lt;/code&gt;语义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Transaction Marker&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;提供了识别消息是否应该被读取的能力，从而实现了事务的隔离性&lt;/li&gt;
&lt;li&gt;Offset的更新标记了消息是否被读取，从而将对读操作的事务处理转换成了对写（Offset）操作的事务处理&lt;/li&gt;
&lt;li&gt;Kafka事务的本质是，将一组写操作（如果有）对应的消息与一组读操作（如果有）对应的Offset的更新进行同样的标记（即&lt;code&gt;Transaction Marker&lt;/code&gt;）来实现事务中涉及的所有读写操作同时对外可见或同时对外不可见&lt;/li&gt;
&lt;li&gt;Kafka只提供对Kafka本身的读写操作的事务性，不提供包含外部系统的事务性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;exception处理&quot;&gt;5.1 Exception处理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidProducerEpoch&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;这是一种Fatal Error，它说明当前Producer是一个过期的实例，有&lt;code&gt;Transaction ID&lt;/code&gt;相同但epoch更新的Producer实例被创建并使用。此时Producer会停止并抛出Exception。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidPidMapping&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;没有与该&lt;code&gt;Transaction ID&lt;/code&gt;对应的PID。此时Producer会通过包含有&lt;code&gt;Transaction ID&lt;/code&gt;的&lt;code&gt;InitPidRequest&lt;/code&gt;请求创建一个新的PID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NotCorrdinatorForGTransactionalId&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;该&lt;code&gt;Transaction Coordinator&lt;/code&gt;不负责该当前事务。Producer会通过&lt;code&gt;FindCoordinatorRequest&lt;/code&gt;请求重新寻找对应的&lt;code&gt;Transaction Coordinator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidTxnRequest&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;违反了事务协议。正确的Client实现不应该出现这种Exception。如果该异常发生了，用户需要检查自己的客户端实现是否有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;CoordinatorNotAvailable&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;仍在初始化中。Producer只需要重试即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;DuplicateSequenceNumber&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;发送的消息的序号低于Broker预期。该异常说明该消息已经被成功处理过，Producer可以直接忽略该异常并处理下一条消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidSequenceNumber&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;这是一个Fatal Error，它说明发送的消息中的序号大于Broker预期。此时有两种可能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据乱序。比如前面的消息发送失败后重试期间，新的消息被接收。正常情况下不应该出现该问题，因为当幂等发送启用时，&lt;code&gt;max.inflight.requests.per.connection&lt;/code&gt;被强制设置为1，而&lt;code&gt;acks&lt;/code&gt;被强制设置为all。故前面消息重试期间，后续消息不会被发送，也即不会发生乱序。并且只有ISR中所有Replica都ACK，Producer才会认为消息已经被发送，也即不存在Broker端数据丢失问题。&lt;/li&gt;
&lt;li&gt;服务器由于日志被Truncate而造成数据丢失。此时应该停止Producer并将此Fatal Error报告给用户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvalidTransactionTimeout&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;InitPidRequest&lt;/code&gt;调用出现的Fatal Error。它表明Producer传入的timeout时间不在可接受范围内，应该停止Producer并报告给用户。&lt;/p&gt;
&lt;h2 id=&quot;处理transaction-coordinator失败&quot;&gt;5.2 处理&lt;code&gt;Transaction Coordinator&lt;/code&gt;失败&lt;/h2&gt;
&lt;h3 id=&quot;写prepare_commitprepare_abort前失败&quot;&gt;5.2.1 写&lt;code&gt;PREPARE_COMMIT/PREPARE_ABORT&lt;/code&gt;前失败&lt;/h3&gt;
&lt;p&gt;Producer通过&lt;code&gt;FindCoordinatorRequest&lt;/code&gt;找到新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;，并通过&lt;code&gt;EndTxnRequest&lt;/code&gt;请求发起&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;流程，新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;继续处理&lt;code&gt;EndTxnRequest&lt;/code&gt;请求——写&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，写&lt;code&gt;Transaction Marker&lt;/code&gt;，写&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;写完prepare_commitprepare_abort后失败&quot;&gt;5.2.2 写完&lt;code&gt;PREPARE_COMMIT/PREPARE_ABORT&lt;/code&gt;后失败&lt;/h3&gt;
&lt;p&gt;此时旧的&lt;code&gt;Transaction Coordinator&lt;/code&gt;可能已经成功写入部分&lt;code&gt;Transaction Marker&lt;/code&gt;。新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;会重复这些操作，所以部分Partition中可能会存在重复的&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;，但只要该Producer在此期间没有发起新的事务，这些重复的&lt;code&gt;Transaction Marker&lt;/code&gt;就不是问题。&lt;/p&gt;
&lt;h3 id=&quot;写完complete_commitabort后失败&quot;&gt;5.2.3 写完&lt;code&gt;COMPLETE_COMMIT/ABORT&lt;/code&gt;后失败&lt;/h3&gt;
&lt;p&gt;旧的&lt;code&gt;Transaction Coordinator&lt;/code&gt;可能已经写完了&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;或&lt;code&gt;COMPLETE_ABORT&lt;/code&gt;但在返回&lt;code&gt;EndTxnRequest&lt;/code&gt;之前失败。该场景下，新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;会直接给Producer返回成功。&lt;/p&gt;
&lt;h2 id=&quot;事务过期机制&quot;&gt;5.3 事务过期机制&lt;/h2&gt;
&lt;h3 id=&quot;事务超时&quot;&gt;5.3.1 事务超时&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;transaction.timeout.ms&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;终止过期事务&quot;&gt;5.3.2 终止过期事务&lt;/h3&gt;
&lt;p&gt;当Producer失败时，&lt;code&gt;Transaction Coordinator&lt;/code&gt;必须能够主动的让某些进行中的事务过期。否则没有Producer的参与，&lt;code&gt;Transaction Coordinator&lt;/code&gt;无法判断这些事务应该如何处理，这会造成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果这种进行中事务太多，会造成&lt;code&gt;Transaction Coordinator&lt;/code&gt;需要维护大量的事务状态，大量占用内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Transaction Log&lt;/code&gt;内也会存在大量数据，造成新的&lt;code&gt;Transaction Coordinator&lt;/code&gt;启动缓慢&lt;/li&gt;
&lt;li&gt;&lt;code&gt;READ_COMMITTED&lt;/code&gt;的Consumer需要缓存大量的消息，造成不必要的内存浪费甚至是OOM&lt;/li&gt;
&lt;li&gt;如果多个&lt;code&gt;Transaction ID&lt;/code&gt;不同的Producer交叉写同一个Partition，当一个Producer的事务状态不更新时，&lt;code&gt;READ_COMMITTED&lt;/code&gt;的Consumer为了保证顺序消费而被阻塞&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了避免上述问题，&lt;code&gt;Transaction Coordinator&lt;/code&gt;会周期性遍历内存中的事务状态Map，并执行如下操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果状态是&lt;code&gt;BEGIN&lt;/code&gt;并且其最后更新时间与当前时间差大于&lt;code&gt;transaction.remove.expired.transaction.cleanup.interval.ms&lt;/code&gt;（默认值为1小时），则主动将其终止：1）未避免原Producer临时恢复与当前终止流程冲突，增加该Producer对应的PID的epoch，并确保将该更新的信息写入&lt;code&gt;Transaction Log&lt;/code&gt;；2）以更新后的epoch回滚事务，从而使得该事务相关的所有Broker都更新其缓存的该PID的epoch从而拒绝旧Producer的写操作&lt;/li&gt;
&lt;li&gt;如果状态是&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;，完成后续的COMMIT流程————向各&lt;code&gt;&amp;lt;Topic, Partition&amp;gt;&lt;/code&gt;写入&lt;code&gt;Transaction Marker&lt;/code&gt;，在&lt;code&gt;Transaction Log&lt;/code&gt;内写入&lt;code&gt;COMPLETE_COMMIT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果状态是&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，完成后续ABORT流程&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;终止transaction-id&quot;&gt;5.3 终止&lt;code&gt;Transaction ID&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;某&lt;code&gt;Transaction ID&lt;/code&gt;的Producer可能很长时间不再发送数据，&lt;code&gt;Transaction Coordinator&lt;/code&gt;没必要再保存该&lt;code&gt;Transaction ID&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;等的映射，否则可能会造成大量的资源浪费。因此需要有一个机制探测不再活跃的&lt;code&gt;Transaction ID&lt;/code&gt;并将其信息删除。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transaction Coordinator&lt;/code&gt;会周期性遍历内存中的&lt;code&gt;Transaction ID&lt;/code&gt;与&lt;code&gt;PID&lt;/code&gt;映射，如果某&lt;code&gt;Transaction ID&lt;/code&gt;没有对应的正在进行中的事务并且它对应的最后一个事务的结束时间与当前时间差大于&lt;code&gt;transactional.id.expiration.ms&lt;/code&gt;（默认值是7天），则将其从内存中删除并在&lt;code&gt;Transaction Log&lt;/code&gt;中将其对应的日志的值设置为null从而使得Log Compact可将其记录删除。&lt;/p&gt;

&lt;h2 id=&quot;postgresql-mvcc&quot;&gt;6.1 PostgreSQL MVCC&lt;/h2&gt;
&lt;p&gt;Kafka的事务机制与《&lt;a href=&quot;http://www.cnblogs.com/sql/mvcc/&quot;&gt;MVCC PostgreSQL实现事务和多版本并发控制的精华&lt;/a&gt;》一文中介绍的PostgreSQL通过MVCC实现事务的机制非常类似，对于事务的回滚，并不需要删除已写入的数据，都是将写入数据的事务标记为Rollback/Abort从而在读数据时过滤该数据。&lt;/p&gt;
&lt;h2 id=&quot;两阶段提交&quot;&gt;6.2 两阶段提交&lt;/h2&gt;
&lt;p&gt;Kafka的事务机制与《&lt;a href=&quot;http://www.cnblogs.com/big_data/two_phase_commit/#两阶段提交原理&quot;&gt;分布式事务（一）两阶段提交及JTA&lt;/a&gt;》一文中所介绍的两阶段提交机制看似相似，都分PREPARE阶段和最终COMMIT阶段，但又有很大不同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka事务机制中，PREPARE时即要指明是&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;还是&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，并且只须在&lt;code&gt;Transaction Log&lt;/code&gt;中标记即可，无须其它组件参与。而两阶段提交的PREPARE需要发送给所有的分布式事务参与方，并且事务参与方需要尽可能准备好，并根据准备情况返回&lt;code&gt;Prepared&lt;/code&gt;或&lt;code&gt;Non-Prepared&lt;/code&gt;状态给事务管理器。&lt;/li&gt;
&lt;li&gt;Kafka事务中，一但发起&lt;code&gt;PREPARE_COMMIT&lt;/code&gt;或&lt;code&gt;PREPARE_ABORT&lt;/code&gt;，则确定该事务最终的结果应该是被&lt;code&gt;COMMIT&lt;/code&gt;或&lt;code&gt;ABORT&lt;/code&gt;。而分布式事务中，PREPARE后由各事务参与方返回状态，只有所有参与方均返回&lt;code&gt;Prepared&lt;/code&gt;状态才会真正执行COMMIT，否则执行ROLLBACK&lt;/li&gt;
&lt;li&gt;Kafka事务机制中，某几个Partition在COMMIT或ABORT过程中变为不可用，只影响该Partition不影响其它Partition。两阶段提交中，若唯一收到COMMIT命令参与者Crash，其它事务参与方无法判断事务状态从而使得整个事务阻塞&lt;/li&gt;
&lt;li&gt;Kafka事务机制引入事务超时机制，有效避免了挂起的事务影响其它事务的问题&lt;/li&gt;
&lt;li&gt;Kafka事务机制中存在多个&lt;code&gt;Transaction Coordinator&lt;/code&gt;实例，而分布式事务中只有一个事务管理器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;zookeeper&quot;&gt;6.3 Zookeeper&lt;/h2&gt;
&lt;p&gt;Zookeeper的原子广播协议与两阶段提交以及Kafka事务机制有相似之处，但又有各自的特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka事务可COMMIT也可ABORT。而Zookeeper原子广播协议只有COMMIT没有ABORT。当然，Zookeeper不COMMIT某消息也即等效于ABORT该消息的更新。&lt;/li&gt;
&lt;li&gt;Kafka存在多个&lt;code&gt;Transaction Coordinator&lt;/code&gt;实例，扩展性较好。而Zookeeper写操作只能在Leader节点进行，所以其写性能远低于读性能。&lt;/li&gt;
&lt;li&gt;Kafka事务是COMMIT还是ABORT完全取决于Producer即客户端。而Zookeeper原子广播协议中某条消息是否被COMMIT取决于是否有一大半FOLLOWER ACK该消息。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 28 Nov 2017 13:56:00 +0000</pubDate>
<dc:creator>郭俊Jason</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jasongj/p/7912348.html</dc:identifier>
</item>
<item>
<title>基于 nodejs 的 webSockt （socket.io） - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/7911937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/7911937.html</guid>
<description>&lt;h3 id=&quot;基于-nodejs-的-websockt-socket.io-理解&quot;&gt;基于 nodejs 的 webSockt （socket.io） 理解&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;本文的业务基础是在基于 nodejs 的 socket.io 的直播间聊天室（IM）应用来的。

项目中具体的 框架如下 express + mongodb + socket.io

在介绍 socket.io  之前，我们有必要对 webSocket 进行根本的原理的理解。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一websocket-的前生今世&quot;&gt;一、webSocket 的前生今世&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1、什么是 webSocket？
2、如何去用？
3、经常使用的场景？
4、需要注意的地方
好了，下面我们就按照上面 提到的四点来进行分析。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;什么是-websocket&quot;&gt;1、 什么是 websocket&lt;/h5&gt;
&lt;p&gt;官方文档解读： &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API&quot;&gt;webSocket&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这个是 MDN 的官方文档。详细的内容需要读者自己仔细去阅读了，笔者这里只介绍 容易出错的问题。

1、WebSockets 是一个可以创建和服务器间进行双向会话的高级技术。通过这个API你可以向服务器发送消息并接受基于事件驱动的响应，这样就不用向服务器轮询获取数据了。

当然这个只是说用来解决 不用向服务器轮询获取数据问题。 这么来说的话其实还是不太够 ‘官方’。

非官方理解： B/S 结构的软件项目中，客户端通过 http、https 等方式获得服务器消息，但是默认的 http 协议只支持 请求响应模式，这种模式简化了 web 服务器，减少服务器负担，加快网站的响应速度。 但是不能满足 我们实时消息推送，聊天室等功能，这个时候 websocket 这个本 作为 unix 进程通信机制 就被嫁接到了 应用程序间网络通信，从而就有了如今的 socket&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;websocket-通信模型&quot;&gt;2、Websocket: 通信模型&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675289/201711/675289-20171128114429503-1348300976.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。

特点： 事件驱动、异步 使用 ws 或者 wss 协议的 socket、 实现真正意义上的 推送功能

这里的  ws 和 wss 区别跟 http 和 https 的区别一样（安全性）

缺点就是 兼容性（今年已经 2017年了，应该可以不用考虑这个问题了）&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;websocket-客户端&quot;&gt;3、 websocket 客户端&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;官方文档中回提供系列的 api 具体如下：

分类如下：

a） 连接类：

    1、send() 向远程服务器发送数据
    2、close() 关闭该websocket链接

b) 监听函数类：

    1、onopen 当网络连接建立时触发该事件
    2、onerror 当网络发生错误时触发该事件
    3、onclose 当 websocket 被关闭时触发该事件
    4、onmessage 当 websocket 接收到服务器发来的消息的时触发的事件，也是通信中最重要的一个监听事件。 其中 我们可以定义各类 onmessage 事件的 type 从而 扩展我们的 onmessage 事件。

c) websocket还定义了一个readyState属性:

    1、CONNECTING(0) websocket正尝试与服务器建立连接
    2、OPEN(1) websocket与服务器已经建立连接
    3、CLOSING(2) websocket正在关闭与服务器的连接
    4、CLOSED(3) websocket已经关闭了与服务器的连接&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;websocket-服务端&quot;&gt;4、 websocket 服务端&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;服务端就像是一个分发中心， 但是首先都得通过 connect 创建连接 从而形成 ws 的长连接。

只要 长连接 连接成功，那么接下来的事情就很好操作了， 比如在服务端 emit 触发一个事件，那么在 服务端就需要监听 on 方法来监听同一个事件，最后如果需要让 当前房间（注: 这里有个 单房间 和 多房间的概念，我们在后面的介绍中会仔细的提到的）内的所有连接用户都被通知到这则消息，那么 在监听到服务端触发的消息的同时，再来触发一个广播给 客户端， 这个时候只要是在当前 ws 连接线上的所有用户都会被 emit 触发到这个事件，从而实现了 广播。

上面的这一长段话，可能暂时不太好理解，但是如果 亲手来写上这么一个 demo 就会理解很多了。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;二-基于-nodejs-的-websocket-框架-socket.io&quot;&gt;二、 基于 nodeJs 的 webSocket 框架 socket.io&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;socket.io 是这篇文章的主角，因为它对 webSocket 做了一个非常完善的封装， 并且提出了 多房间  多命名空间的 概念，让多聊天室同时存在不再是一个问题，所以，下面就会详细的来介绍下 socket.io 这个框架&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://socket.io/&quot;&gt;http://socket.io&lt;/a&gt; 这个是官网&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我们在官网中 可以看到非常简洁的 socket.io 的应用方法。

并且还展示了一个全世界通用的 IM （虽然这里常常可以看到 f**k xxx）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，下面就针对 这个 socket.io 再进行一个详细的介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、 Server api

2、 Client api

3、 Rooms and NameSpace&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这要就针对这三个来进行介绍&lt;/p&gt;
&lt;h5 id=&quot;server-api&quot;&gt;1、 Server api&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;服务端初始化 io 对象&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io'&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// or&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; Server &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Server&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;这个时候就需要看 你的后台 服务的语言， php java nodejs 等等

我是用的 nodejs 所以直接 使用 express or koa2 均可

然后创建 http-server 服务&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; socket &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;express&lt;/span&gt;()

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; server &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;http&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createServer&lt;/span&gt;(app)

io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;socket&lt;/span&gt;(server)

&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(socket) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// to do somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;上面的这个步骤就可以轻松的 通过 nodejs + express 创建了一个 socket 服务端的 服务了&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;client-api&quot;&gt;2、 Client api&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;上面的步骤中已经在 服务端进行了 一些列 的操作 ，这个时候就需要 在服务端 创建 连接


首先是 需要在 前端引用 这个 socket 文件&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/socket.io/socket.io.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;  const socket = io&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;'http://localhost'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/script&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; io &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'socket.io-client'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// or with import syntax&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; io &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'socket.io-client'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;然后 创建 连接&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; socket &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;io&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;然后 触发监听  'connection'&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; (socket) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; token &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;handshake&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;query&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;加入这个时候你在 服务端 打印 debug 如果顺利 就可以轻松 完成了第一个 socket 的链接啦~&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;rooms-and-namespace&quot;&gt;3、 Rooms and NameSpace&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;最后这里 介绍到的  rooms 和 namespace 的概念

在多房间 聊天室 中 占据了很大的作用

其中 介绍下 rooms  的 概念 ， 关于 namespace 相关可以到 socket.io 官网中进行查看&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
&lt;span class=&quot;co&quot;&gt;// 广播给当前房间除了自己以外的所有人 &lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;broadcast&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;to&lt;/span&gt;(roomId).&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'msg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;   
    &lt;span class=&quot;co&quot;&gt;// take somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;// 广播给当前房间中自己&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'msg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// take somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)


&lt;span class=&quot;co&quot;&gt;// 广播给当前房间的所有人 &lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;to&lt;/span&gt;(roomId).&lt;span class=&quot;at&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'msg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;co&quot;&gt;// take somethings&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;然后再结合上面的 监听 、 触发 方法，完成一系列的需求任务。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恩，今天先到这里，有什么问题，可以留言互相学习。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 12:35:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/7911937.html</dc:identifier>
</item>
<item>
<title>项目实战9—企业级分布式存储应用与实战MogileFS、FastDFS - 阿龙along</title>
<link>http://www.cnblogs.com/along21/p/7911676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/7911676.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192643253-1858308752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;企业级分布式存储应用与实战-mogilefs&lt;/p&gt;
&lt;p&gt;　　环境：公司已经有了大量沉淀用户，为了让这些沉淀用户长期使用公司平台，公司决定&lt;strong&gt;增加用户粘性，逐步发展基于社交属性的多样化业务模式&lt;/strong&gt;，决定开展用户讨论区、卖家秀、买家秀、用户试穿短视频等业务，因此，公司新的业务的业务特征将需要海量数据存储，你的领导要求基于开源技术，实现对公司海量存储业务的技术研究和实现，你可以完成任务吗？&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;总项目流程图&lt;/strong&gt;，详见 &lt;a href=&quot;http://www.cnblogs.com/along21/p/7435612.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/along21/p/7435612.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实验前准备：配置好yum源、防火墙关闭、各节点时钟服务同步&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实战一：企业级分布式存储应用与实战 mogilefs 实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;架构图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192644081-758113981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）mogileFS主要由三部分构成：&lt;strong&gt;tracker节点，database节点，storage节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;&lt;strong&gt;Tracker(MogileFSd 进程)&lt;/strong&gt;&lt;/span&gt;：这个是 MogileFS 的核心部分，他是一个&lt;span&gt;&lt;strong&gt;调度器&lt;/strong&gt;&lt;/span&gt;，MogileFSd 进程就是trackers进程程序，trackers 做了很多工作：Replication,Deletion,Query,Reaper,Monitor 等等，这个是基于事件的( event-based ) 父进程/消息总线来管理所有来之于客户端应用的交互(requesting operations to be performed),，包括将请求负载平衡到多个&quot;query workers&quot;中，然后让 MogileFSd 的子进程去处理；&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;&lt;strong&gt;MySQL&lt;/strong&gt;&lt;/span&gt;：用来存放 MogileFS 的&lt;span&gt;&lt;strong&gt;元数据 (命名空间, 和文件在哪里)&lt;/strong&gt;&lt;/span&gt;，是Trackers 来操作和管理它，可以用mogdbsetup程序来初始化数据库，因为数据库保存了MogileFS的所有元数据，建议做成HA架构；&lt;/p&gt;
&lt;p&gt;③ &lt;span&gt;&lt;strong&gt;Storage Nodes&lt;/strong&gt;&lt;/span&gt;：这个是 MogileFS 存储文件存放在这些机器上,也是 mogstored 节点,也叫Storage Server,一台存储主要都要启动一个 mogstored 服务.扩容就是增加这些机器，&lt;span&gt;&lt;strong&gt;实际文件存放的地方&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;（2）MogileFS管理的几个概念：&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;&lt;strong&gt;Domain域&lt;/strong&gt;&lt;/span&gt;：一个MogileFS可以有多个Domain，用来存放不同文件（大小，类型），同一个Domain内&lt;strong&gt;key必须唯一&lt;/strong&gt;，&lt;strong&gt;不同Domain内，key可以相同；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;② 每一个存储节点称为一个&lt;span&gt;&lt;strong&gt;主机host&lt;/strong&gt;&lt;/span&gt;，一个主机上可以有多个存储设备dev(单独的硬盘)，每个设备都有ID号，Domain+Fid用来定位文件。&lt;/p&gt;
&lt;p&gt;③ &lt;span&gt;&lt;strong&gt;Class&lt;/strong&gt;&lt;/span&gt;：文件属性管理，定位文件存储在不同设备上的&lt;strong&gt;份数&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;（3）工作流程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次&lt;/strong&gt;文件的上传和读取，&lt;strong&gt;都经过前端&lt;span&gt;TrackerServer 服务器&lt;/span&gt;&lt;/strong&gt;，trackerServer 服务器&lt;strong&gt;受到client 端的请求&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;查询数据库&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;返回一个&lt;/strong&gt;上传或者是读取的可用的&lt;span&gt;&lt;strong&gt;后端StorageServer 的地址&lt;/strong&gt;&lt;/span&gt;，然后由&lt;strong&gt;client 端&lt;/strong&gt;直接&lt;strong&gt;操作后端StorageServer 服务器&lt;/strong&gt;。upload 操作返回就是成功或者失败的结果，read操作就是返回对应的查询数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192644581-1173750007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）mogilefs 服务很特殊：服务配置完毕，开启服务后；还需命令行命令，服务才能真正生效！&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1、环境准备&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;机器名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;IP配置&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;服务角色&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker-srv&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.107&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;调度器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker、mysql&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;storage node1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;文件存放&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;mogstored 服务&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;storage node2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;文件存放&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;mogstored 服务&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;2、下载安装，每个机器都一样&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;两个安装方式：yum安装 和 perl程序安装&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：yum安装（推荐）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）所依赖的包，centos 自带的&lt;/p&gt;
&lt;p&gt;yum install perl-Net-Netmask perl-IO-String perl-Sys-Syslog perl-IO-AIO&lt;/p&gt;

&lt;p&gt;（2）服务的rpm包，我已经放在我的网盘里了，需要的私聊 &lt;a href=&quot;http://pan.baidu.com/s/1c2bGc84&quot;&gt;&lt;span&gt;http://pan.baidu.com/s/1c2bGc84&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MogileFS-Server-2.46-2.el6.noarch.rpm        #核心服务&lt;/p&gt;
&lt;p&gt;perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm  #socket&lt;/p&gt;
&lt;p&gt;MogileFS-Server-mogilefsd-2.46-2.el6.noarch.rpm    # tracker节点&lt;/p&gt;
&lt;p&gt;perl-MogileFS-Client-1.14-1.el6.noarch.rpm  #客户端&lt;/p&gt;
&lt;p&gt;MogileFS-Server-mogstored-2.46-2.el6.noarch.rpm   #Storage存储节点&lt;/p&gt;
&lt;p&gt;MogileFS-Utils-2.19-1.el6.noarch.rpm    #主要是MogileFS的一些管理工具，例如mogadm等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192644987-1088605019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）开始安装&lt;/p&gt;
&lt;p&gt;cd mogileFS/&lt;/p&gt;
&lt;p&gt;yum localinstall ./* -y&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二：perl程序源码包安装&lt;/strong&gt;：通过perl的包管理命令cpanm进行安装&lt;/p&gt;
&lt;p&gt;（1）依赖的包&lt;/p&gt;
&lt;p&gt;yum -y install make gcc unzip perl-DBD-MySQL perl perl-CPAN perl-YAML perl-Time-HiRes&lt;/p&gt;
&lt;p&gt;（2）cpanm安装&lt;/p&gt;
&lt;p&gt;wget http://xrl.us/cpanm -O /usr/bin/cpanm;&lt;/p&gt;
&lt;p&gt;sudo chmod +x /usr/bin/cpanm&lt;/p&gt;
&lt;p&gt;#cpanm DBD::mysql&lt;/p&gt;
&lt;p&gt;#cpanm MogileFS::Server&lt;/p&gt;
&lt;p&gt;#cpanm MogileFS::Utils&lt;/p&gt;
&lt;p&gt;#cpanm MogileFS::Client&lt;/p&gt;
&lt;p&gt;#cpanm IO::AIO&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、数据库初始化&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）创建mogilefs 所需要的用户并授权&lt;/p&gt;
&lt;p&gt;systemctl start mariadb 开启mysql服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MariaDB [mogilefs]&amp;gt; GRANT ALL PRIVILEGES ON mogilefs.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mogile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; @&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mogile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; WITH GRANT OPTION;
MariaDB [mogilefs]&lt;/span&gt;&amp;gt; flush privileges;    刷新下权限
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）设定数据库：数据库初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mogdbsetup --dbpass=mogile&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;4、在tracker-srv 服务器上，启动mogilefsd服务&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）修改管理tracker 的配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;vim /etc/&lt;span&gt;&lt;strong&gt;mogilefs/mogilefsd.conf&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;① 配置数据库连接相关信息
db_dsn &lt;/span&gt;= DBI:mysql:mogilefs:host=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
db_user &lt;/span&gt;=&lt;span&gt; mogile
db_pass &lt;/span&gt;=&lt;span&gt; mogile
② 下边的只需修改监听地址和端口
listen &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; #mogilefs监听地址，监听在127.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.1表示只允许从本机登录进行管理
query_jobs &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;   #启动多少个查询工作线程
delete_jobs &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;    #启动多少个删除工作线程
replicate_jobs &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;   #启动多少个复制工作线程
reaper_jobs &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;      #启动多少个用于回收资源的线程
maxconns &lt;/span&gt;= &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;   #存储系统的最大连接数.
httplisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7500&lt;/span&gt;&lt;span&gt;   #可通过http访问的服务端口
mgmtlisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7501&lt;/span&gt;&lt;span&gt;   #mogilefs的管理端口
docroot &lt;/span&gt;= /var/mogdata   #该项决定了数据的在storage上存储的实际位置,建议使用的是一个单独挂载使用的磁盘
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）创建进程需要的目录，并授权&lt;/p&gt;
&lt;p&gt;mkdir /var/run/mogilefsd/&lt;/p&gt;
&lt;p&gt;chown -R mogilefs.mogilefs /var/run/mogilefsd&lt;/p&gt;

&lt;p&gt;（3）开启服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; /etc/init.d/mogilefsd start&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192645347-983737594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有时候会显示启动失败；但实际则是启动成功了。可以&lt;/p&gt;
&lt;p&gt;ss -nutlp|grep mogilefs 查询是否有mogilefsd 的监听ip和端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192645690-1342235373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、在两台storage node 上，启动mogstored服务&lt;/h3&gt;
&lt;p&gt;（1）修改storage node 的配置文件&lt;/p&gt;
&lt;p&gt;vim /etc/&lt;span&gt;&lt;strong&gt;mogilefs/mogstored.conf&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
maxconns = &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;   #存储系统的最大连接数.
httplisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7500&lt;/span&gt;&lt;span&gt;    #可通过http访问的服务端口
mgmtlisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7501&lt;/span&gt;&lt;span&gt;   #mogilefs的管理端口
docroot &lt;/span&gt;= /data/mogdata    #该项决定了数据的在storage上存储的实际位置,建议使用的是一个单独挂载使用的磁盘
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192646034-1467575814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）创建storage 存储的目录&lt;/p&gt;
&lt;p&gt;mkdir -p /data/mogdata&lt;/p&gt;
&lt;p&gt;（3）授权&lt;/p&gt;
&lt;p&gt;cd /data/&lt;/p&gt;
&lt;p&gt;chown mogilefs.mogilefs mogdata/ -R&lt;/p&gt;
&lt;p&gt;（4）开启服务，有时候开启服务显示失败，其实已经成功&lt;/p&gt;
&lt;p&gt;/etc/init.d/mogstored start&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192646581-161857885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、修改客户端工具配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;vim /etc/mogilefs/mogilefs.conf 客户端工具配置文件&lt;/p&gt;
&lt;p&gt;trackers=192.168.30.107:7001 #自己的tracker 的服务IP和端口&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;7、storage node 节点加入到MogileFS 的系统中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在tracker 的服务器上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）加入&quot;存储节点&lt;/strong&gt;storage node1/2&lt;strong&gt;&quot;到 trackers 中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mogadm --tracker=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; host add node1 --ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.7&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=&lt;span&gt;alive
mogadm &lt;/span&gt;--tracker=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; host add node2 --ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.2&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=alive
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）查询信息，检查主机是否加入到 MogileFS 的系统中&lt;/p&gt;
&lt;p&gt;mogadm &lt;strong&gt;check&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192647222-174962243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;mogadm &lt;strong&gt;host list&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192647597-70740089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）当然，操作错误也可以修改&lt;/p&gt;
&lt;p&gt;mogadm host &lt;span&gt;&lt;strong&gt;modify&lt;/strong&gt;&lt;/span&gt; node1 --ip=192.168.30.7 --port=7500 --status=alive&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;8、创建设备&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在两个storage node 服务器上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建&quot;设备&quot;实验的目录并授权，格式： dev + ID&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：所有系统中 ID 不能重复，也必须和配置文件中的路径一样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cd mogdata/&lt;/p&gt;
&lt;p&gt;mkdir dev1&lt;/p&gt;
&lt;p&gt;chown mogilefs.mogilefs dev1/ -R 加权限&lt;/p&gt;
&lt;p&gt;设置成功，会在dev1下生成一个文件，是tracker 过来测试留下来的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192648003-1697881063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）在另一台服务器上也一样&lt;/p&gt;
&lt;p&gt;cd mogdata/&lt;/p&gt;
&lt;p&gt;mkdir dev2&lt;/p&gt;
&lt;p&gt;chown mogilefs.mogilefs dev2/ -R&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;9、两个设备加入 MogileFS 的存储系统中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）在tracker 上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mogadm&lt;/strong&gt; --tracker=192.168.30.107:7001 &lt;strong&gt;device add node1 1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mogadm --tracker=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; device add node1 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
mogadm &lt;/span&gt;--tracker=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; device add node2 &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）查看设备信息&lt;/p&gt;
&lt;p&gt;mogadm check 检测出来两个设备的信息了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192648659-2112275214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;mogadm device list 能查询设备的详细信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192649112-763462984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）在数据库中也能查出设备&lt;/p&gt;
&lt;p&gt;MariaDB [mogilefs]&amp;gt; select * from device;&lt;/p&gt;
&lt;p&gt;MariaDB [mogilefs]&amp;gt; select * from host;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192649550-767172410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;10、划分域、class&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;mogadm &lt;strong&gt;domain add img&lt;/strong&gt; 创建一个img域&lt;/p&gt;
&lt;p&gt;mogadm &lt;strong&gt;class&lt;/strong&gt; add img &lt;strong&gt;along --mindevcount=3&lt;/strong&gt; 在img域中创建一个along的class，可以存放3份&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192650050-1361352631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;11、上传文件且测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）上传一张图片&lt;/p&gt;
&lt;p&gt;mogupload --domain=img --key=test --file=along.jpg 向img域中上传一张along.jpg的图片，key为test&lt;/p&gt;
&lt;p&gt;mogfileinfo --domain=img --key=test 查询文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192650409-1027853907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）网页访问&lt;span&gt;http://192.168.30.2:7500/dev2/0/000/000/0000000002.fid&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192650878-1991016147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）当然，也可以删除图片&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mogdelete&lt;/strong&gt; --domain=img --key=test&lt;/p&gt;

&lt;p&gt;（4）在数据库也能查看到&lt;/p&gt;
&lt;p&gt;MariaDB [mogilefs]&amp;gt; select * from file;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192651190-417131413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）在后端两个storage node 上也能查到图片，图片就是存放到storage node服务器上的&lt;/p&gt;
&lt;p&gt;注意：本来，后端两个storage node 上应该都有存放的图片，&lt;strong&gt;能互相复制，是副本关系&lt;/strong&gt;，但这一版本有BUG&lt;/p&gt;
&lt;p&gt;我的只有在storage node2 上才有这张图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192651534-1614372459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;12、修复bug，实现后端storage node 同步存储&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;分析：因为这个版本有bug，所以需降版本&lt;/p&gt;
&lt;p&gt;（1）下载包&lt;/p&gt;
&lt;p&gt;wget &lt;span&gt;http://search.cpan.org/CPAN/authors/id/B/BR/BRADFITZ/Sys-Syscall-0.23.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也可以http://search.cpan.org/CPAN/authors/id/B/BR/BRADFITZ/Sys-Syscall-0.23.tar.gz 去网站直&lt;/p&gt;
&lt;p&gt;接下载&lt;/p&gt;
&lt;p&gt;（2）上传，解压缩&lt;/p&gt;
&lt;p&gt;rz，tar xvf Sys-Syscall-0.23.tar.gz -C /tmp&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;编译安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 因为是perl 语言编写的，所以需要安装perl 编译安装的环境&lt;/p&gt;
&lt;p&gt;yum -y install make gcc unzip perl-DBD-MySQL perl perl-CPAN perl-YAML perl-Time-HiRes&lt;/p&gt;
&lt;p&gt;② 编译安装&lt;/p&gt;
&lt;p&gt;cd /tmp/Sys-Syscall-0.23/&lt;/p&gt;
&lt;p&gt;perl Makefile.PL 准备环境&lt;/p&gt;
&lt;p&gt;make &amp;amp; make install&lt;/p&gt;

&lt;p&gt;（4）重启服务&lt;/p&gt;
&lt;p&gt;① 在tracker 服务器是，有时候开启服务显示失败，其实已经成功&lt;/p&gt;
&lt;p&gt;/etc/init.d/mogilefsd stop&lt;/p&gt;
&lt;p&gt;/etc/init.d/mogilefsd start&lt;/p&gt;
&lt;p&gt;② 在storage node 服务器上，有时候开启服务显示失败，其实已经成功&lt;/p&gt;
&lt;p&gt;/etc/init.d/mogstored stop&lt;/p&gt;
&lt;p&gt;/etc/init.d/mogstored start&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192652097-67911727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）测试&lt;/p&gt;
&lt;p&gt;① 再上传一张图片&lt;/p&gt;
&lt;p&gt;mogupload --domain=img --key=test1 --file=along.jpg&lt;/p&gt;
&lt;p&gt;② 在两个storage node 服务器上，存储已经实现同步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192652800-731203974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192653237-495964688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;实战二：mogilefs 和mysql主从 实现分布式存储&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128194530456-1488033359.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt;在database 上实现&lt;strong&gt;mysql的主从&lt;/strong&gt;；且为了提升性能，在&lt;strong&gt;每个节点上都配置tracker&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、环境准备&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;机器名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;IP配置&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;服务角色&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;mogilefs-&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql-master&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.107&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;主数据库&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker、mysql&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;mogilefs-&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql-slave&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;从数据库&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker、mysql&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;mogilefs-&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;store1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;文件存放&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker、storage&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;mogilefs-&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;store2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;文件存放&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker、storage&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;2、在所有机器上下载安装mogilefs&lt;/h3&gt;
&lt;p&gt;（1）所依赖的包，centos 自带的&lt;/p&gt;
&lt;p&gt;yum install perl-Net-Netmask perl-IO-String perl-Sys-Syslog perl-IO-AIO&lt;/p&gt;

&lt;p&gt;（2）服务的rpm包，我已经放在我的网盘里了，需要的私聊 &lt;a href=&quot;http://pan.baidu.com/s/1c2bGc84&quot;&gt;&lt;span&gt;http://pan.baidu.com/s/1c2bGc84&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MogileFS-Server-2.46-2.el6.noarch.rpm #核心服务&lt;/p&gt;
&lt;p&gt;perl-Danga-Socket-1.61-1.el6.rf.noarch.rpm #socket&lt;/p&gt;
&lt;p&gt;MogileFS-Server-mogilefsd-2.46-2.el6.noarch.rpm # tracker节点&lt;/p&gt;
&lt;p&gt;perl-MogileFS-Client-1.14-1.el6.noarch.rpm #客户端&lt;/p&gt;
&lt;p&gt;MogileFS-Server-mogstored-2.46-2.el6.noarch.rpm #Storage存储节点&lt;/p&gt;
&lt;p&gt;MogileFS-Utils-2.19-1.el6.noarch.rpm #主要是MogileFS的一些管理工具，例如mogadm等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192653706-1502495837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）开始安装&lt;/p&gt;
&lt;p&gt;cd mogileFS/&lt;/p&gt;
&lt;p&gt;yum localinstall ./* -y&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、在两台mysql上实现主从&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）&lt;strong&gt;在主mysql 上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① vim /etc/my.cnf 修改mysql主配置文件，对master进行配置，包括打开二进制日志，指定唯一的servr ID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
server-&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;         #配置server-&lt;span&gt;id&lt;/span&gt;&lt;span&gt;，让主服务器有唯一ID号
log&lt;/span&gt;-bin=mysql-&lt;span&gt;bin   #打开Mysql日志，日志格式为二进制
skip&lt;/span&gt;-name-resolve   #关闭名称解析，（非必须）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192654019-1689847096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;systemctl start mariadb 开启服务&lt;/p&gt;

&lt;p&gt;② &lt;strong&gt;创建并授权&lt;/strong&gt;slave mysql 用的复制帐号&lt;/p&gt;
&lt;p&gt;MariaDB [(none)]&amp;gt; grant replication slave,replication client on *.* to slave@'192.168.30.7' identified by 'along';&lt;/p&gt;

&lt;p&gt;③ 查看主服务器状态&lt;/p&gt;
&lt;p&gt;在Master的数据库执行show master status，查看主服务器二进制日志状态，位置号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192654519-2058255815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）&lt;strong&gt;在从mysql 上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;① 修改主配置文件&lt;/p&gt;
&lt;p&gt;vim /etc/my.cnf 打开中继日志，指定唯一的servr ID，设置只读权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
server-&lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;       #配置server-&lt;span&gt;id&lt;/span&gt;&lt;span&gt;，让从服务器有唯一ID号
relay_log &lt;/span&gt;= mysql-relay-&lt;span&gt;bin    #打开Mysql日志，日志格式为二进制
read_only &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;    #设置只读权限
log_bin &lt;/span&gt;= mysql-&lt;span&gt;bin         #开启从服务器二进制日志，（非必须）
log_slave_updates &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;  #使得更新的数据写进二进制日志中&lt;strong&gt; &lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192654831-1907603453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;systemctl start mariadb 开启服务&lt;/p&gt;

&lt;p&gt;② &lt;strong&gt;启动从服务器复制线程&lt;/strong&gt;，让slave连接master，并开始重做master二进制日志中的事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
MariaDB [(none)]&amp;gt; change master to master_host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.30.107&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;-&amp;gt; master_user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;-&amp;gt; master_password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;along&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;-&amp;gt; master_log_file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql-bin.000001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;-&amp;gt; master_log_pos=&lt;span&gt;245&lt;/span&gt;&lt;span&gt;;
MariaDB [(none)]&lt;/span&gt;&amp;gt;  start slave;   # 启动复制线程，就是打开I/O线程和SQL线程；实现拉主的bin-log到从的relay-log上；再从relay-log写到数据库内存里
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 查看从服务器状态&lt;/p&gt;
&lt;p&gt;可使用SHOW SLAVE STATUS\G查看从服务器状态，如下所示，也可用show processlist \G查看当前复制状态：&lt;/p&gt;
&lt;p&gt;Slave_IO_Running: Yes #IO线程正常运行&lt;/p&gt;
&lt;p&gt;Slave_SQL_Running: Yes #SQL线程正常运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192655456-1153264041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、初始化数据库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）在主mysql上授权，因为主从同步，所以只需操作主&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON mogilefs.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mogile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.30.%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mogile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; WITH GRANT OPTION;
MariaDB [mogilefs]&lt;/span&gt;&amp;gt; flush privileges;    刷新下权限
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）数据库初始化，在两个机器上都初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mogdbsetup --dbpass=mogile&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4&lt;/span&gt;、在所有机器上，开启tracker服务&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）修改管理tracker 的配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;vim /etc/&lt;span&gt;&lt;strong&gt;mogilefs/mogilefsd.conf&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;① 配置数据库连接相关信息
db_dsn &lt;/span&gt;= DBI:mysql:mogilefs:host=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;&lt;span&gt;
db_user &lt;/span&gt;=&lt;span&gt; mogile
db_pass &lt;/span&gt;=&lt;span&gt; mogile
② 下边的只需修改监听地址和端口
listen &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt; #mogilefs监听地址，监听在127.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.1表示只允许从本机登录进行管理；注意，4台机器写自己的IP地址
listen &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.7&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
listen &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.2&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
listen &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.3&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
注意：不是写4个，是在4个机器上分别写&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）创建进程需要的目录，并授权&lt;/p&gt;
&lt;p&gt;mkdir /var/run/mogilefsd/&lt;/p&gt;
&lt;p&gt;chown -R mogilefs.mogilefs /var/run/mogilefsd&lt;/p&gt;

&lt;p&gt;（3）开启服务，4台都开启&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; /etc/init.d/mogilefsd start&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192655878-555144274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有时候会显示启动失败；但实际则是启动成功了。可以&lt;/p&gt;
&lt;p&gt;ss -nutlp|grep mogilefs 查询是否有mogilefsd 的监听ip和端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192656159-1887174536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、在两个&lt;span&gt;mogilefs-store&lt;/span&gt; 上开启storage 服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）修改storage node 的配置文件&lt;/p&gt;
&lt;p&gt;vim /etc/&lt;span&gt;&lt;strong&gt;mogilefs/mogstored.conf&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
maxconns = &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;   #存储系统的最大连接数.
httplisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7500&lt;/span&gt;&lt;span&gt;    #可通过http访问的服务端口
mgmtlisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7501&lt;/span&gt;&lt;span&gt;   #mogilefs的管理端口
docroot &lt;/span&gt;= /data/mogdata    #该项决定了数据的在storage上存储的实际位置,建议使用的是一个单独挂载使用的磁盘
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192656440-1143087292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）创建storage 存储的目录&lt;/p&gt;
&lt;p&gt;mkdir -p /data/mogdata&lt;/p&gt;
&lt;p&gt;（3）授权&lt;/p&gt;
&lt;p&gt;cd /data/&lt;/p&gt;
&lt;p&gt;chown mogilefs.mogilefs mogdata/ -R&lt;/p&gt;
&lt;p&gt;（4）开启服务，有时候开启服务显示失败，其实已经成功&lt;/p&gt;
&lt;p&gt;/etc/init.d/mogstored start&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192656800-1106844914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、修改客户端工具配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;vim /etc/mogilefs/mogilefs.conf 客户端工具配置文件，&lt;strong&gt;4个机器写自己的tracker&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
trackers=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;   #自己的tracker 的服务IP和端口
trackers&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.7&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
trackers&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.2&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
trackers&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.3&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
注意：是各自写各自的，不是都写在一个机器里&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;7、storage node 节点加入到MogileFS 的系统中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在tracker 的服务器上：只需在一个tracker 服务器上做就行了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）加入&quot;存储节点&lt;/strong&gt;storage node1/2&lt;strong&gt;&quot;到 trackers 中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mogadm  host add node1 --ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.3&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=&lt;span&gt;alive
mogadm  host add node2 &lt;/span&gt;--ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.2&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=alive
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）查询信息，检查主机是否加入到 MogileFS 的系统中&lt;/p&gt;
&lt;p&gt;mogadm &lt;strong&gt;check&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mogadm &lt;strong&gt;host list&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（3）当然，操作错误也可以修改&lt;/p&gt;
&lt;p&gt;mogadm host &lt;span&gt;&lt;strong&gt;modify&lt;/strong&gt;&lt;/span&gt; node1 --ip=192.168.30.3 --port=7500 --status=alive&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;8、创建设备&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在&lt;span&gt;mogilefs-store1&lt;/span&gt; 服务器上：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建&quot;设备&quot;实验的目录并授权，格式： dev + ID&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：所有系统中 ID 不能重复，也必须和配置文件中的路径一样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cd /data/mogdata/&lt;/p&gt;
&lt;p&gt;mkdir dev1&lt;/p&gt;
&lt;p&gt;chown mogilefs.mogilefs dev1/ -R 加权限&lt;/p&gt;
&lt;p&gt;设置成功，会在dev1下生成一个文件，是tracker 过来测试留下来的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192657175-635124720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）在另一台服务器上也一样&lt;/p&gt;
&lt;p&gt;cd mogdata/&lt;/p&gt;
&lt;p&gt;mkdir dev2&lt;/p&gt;
&lt;p&gt;chown mogilefs.mogilefs dev2/ -R&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;9、两个设备加入 MogileFS 的存储系统中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）在tracker 上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mogadm  device add node1 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
mogadm  device add node2 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）查看设备信息&lt;/p&gt;
&lt;p&gt;mogadm check 检测出来两个设备的信息了&lt;/p&gt;
&lt;p&gt;mogadm device list 能查询设备的详细信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192657659-625307518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）在数据库中也能查出设备&lt;/p&gt;
&lt;p&gt;MariaDB [mogilefs]&amp;gt; select * from device;&lt;/p&gt;
&lt;p&gt;MariaDB [mogilefs]&amp;gt; select * from host;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192658081-787675723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10划分域/class、11上传文件且测试、12修复bug  步骤都同上&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实战三：FastDFS 实现分布式存储&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;架构图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192702253-432290862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）FastDFS核心组件&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;&lt;strong&gt;Tracker：调度器&lt;/strong&gt;&lt;/span&gt;，负责维持集群的信息，例如各group及其内部的storage node，这些信息也是storage node报告所生成；&lt;strong&gt;每个storage node会周期性向tracker发心跳信息&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;② &lt;span&gt;&lt;strong&gt;storage server：以group为单位&lt;/strong&gt;&lt;/span&gt;进行组织，任何一个storage server都应该属于某个group，一个group应该包含多个storage server；&lt;strong&gt;在同一个group内部，各storage server的数据互相冗余；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（2）FastDFS架构的特点&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;只有两个角色&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;tracker server和storage server&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;不需要存储文件索引信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• 所有服务器都是&lt;strong&gt;对等的&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;不存在Master-Slave关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 存储服务器采用&lt;span&gt;&lt;strong&gt;分组方式&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;同组内存储服务器上的文件完全相同（RAID 1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;不同组的storage server之间不会相互通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• 由&lt;span&gt;&lt;strong&gt;storage server主动向tracker server报告状态信息&lt;/strong&gt;&lt;/span&gt;，tracker server之间通常不会相互通信&lt;/p&gt;

&lt;p&gt;（3）FastDFS同步机制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;① 采用&lt;span&gt;binlog&lt;/span&gt;&lt;/strong&gt;文件&lt;strong&gt;记录更新操作&lt;/strong&gt;，根据&lt;strong&gt;binlog进行文件同步&lt;span&gt;同一组内的storage server之间是对等的，文件上传、删除等操作可以在任意一台storage server上进行；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;② 文件同步只在同组内的storage server之间进行&lt;/strong&gt;，采用push方式，即&lt;strong&gt;源服务器同步给目标服务器；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;③ 源头数据才需要同步，备份数据不需要再次同步&lt;/strong&gt;，否则就构成环路了；&lt;/p&gt;
&lt;p&gt;上述第二条规则有个例外，就是&lt;strong&gt;新增&lt;/strong&gt;加一台storage server时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器。&lt;/p&gt;

&lt;p&gt;（4）FastDFS运行机制&lt;/p&gt;
&lt;p&gt;---&amp;gt; 上传文件&lt;/p&gt;
&lt;p&gt;① client询问tracker上传到的storage；&lt;/p&gt;
&lt;p&gt;② tracker返回一台可用的storage；&lt;/p&gt;
&lt;p&gt;③ client直接和storage通信完成文件上传，storage返回&lt;span&gt;&lt;strong&gt;文件ID&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192702612-95334821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;--- 下载文件&lt;/p&gt;
&lt;p&gt;① client询问tracker下载文件的storage，参数为&lt;span&gt;&lt;strong&gt;文件ID（组名和文件名）&lt;/strong&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;② tracker返回一台可用的storage；&lt;/p&gt;
&lt;p&gt;③ client直接和storage通信完成文件下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192703065-913918825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）&lt;strong&gt;FastDFS 与 mogileFS 的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192703534-1731643440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1、环境准备&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;机器名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;IP配置&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;服务角色&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker-srv&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.107&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;调度器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;tracker、不需mysql&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;storage srv1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;文件存放&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;storage srv2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;192.168.30.2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;文件存放&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;2、下载安装&lt;/h3&gt;
&lt;p&gt;mkdir /fastdfs 创建一个存放fastdfs所需包的目录&lt;/p&gt;
&lt;p&gt;所需要的包，我已经存放在我的网盘了，有需要的私聊&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/share/init?surl=c2bGc84&quot;&gt;&lt;span&gt;https://pan.baidu.com/share/init?surl=c2bGc84&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;cd /fastdfs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192703831-2035684060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;yum -y localinstall ./*&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3、在tracke 的服务器上，开启tracke 服务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）修改配置文件&lt;/p&gt;
&lt;p&gt;cd /etc/fdfs tracker的配置文件的模板已经准备好了，只需复制修改就好&lt;/p&gt;
&lt;p&gt;cp tracker.conf.sample tracker.conf&lt;/p&gt;

&lt;p&gt;vim /etc/&lt;strong&gt;fdfs/tracker.conf    &lt;/strong&gt;必须修改的一项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;base_path=/data/fastdfs/tracker     &lt;/strong&gt;#base源路径&lt;/p&gt;
&lt;p&gt;① 还可以修改一些自己需要的，如上传、下载方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192704675-1385673302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 访问权限控制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192705409-328199787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）创建目录&lt;/p&gt;
&lt;p&gt;mkdir /data/fastdfs/tracker -p&lt;/p&gt;

&lt;p&gt;（3）启动tracker服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/etc/init.d/fdfs_trackerd start&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192705815-1473691878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4、在后端两台storage server上，开启storage 快照&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在storage server上 storage的配置文件的模板已经准备好了，只需复制修改就好&lt;/p&gt;
&lt;p&gt;cd /etc/fdfs&lt;/p&gt;
&lt;p&gt;cp storage.conf.sample storage.conf&lt;/p&gt;
&lt;p&gt;（1）修改配置文件&lt;/p&gt;
&lt;p&gt;vim &lt;strong&gt;storage.conf&lt;/strong&gt; 必须修改3项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
base_path=/data/fastdfs/&lt;span&gt;storage   #base源路径
store_path0&lt;/span&gt;=/data/fastdfs/&lt;span&gt;storage    #实际存储目录
tracker_server&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;    #指定tracker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）创建目录&lt;/p&gt;
&lt;p&gt;mkdir /data/fastdfs/storage -p&lt;/p&gt;

&lt;p&gt;（3）开启服务&lt;/p&gt;
&lt;p&gt;/etc/init.d/fdfs_storaged start&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192706206-817613278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（4）生成了存放文件的目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192706847-1588352092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;5、设置客户端配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）设置客户端配置文件&lt;/p&gt;
&lt;p&gt;cd /etc/fdfs&lt;/p&gt;
&lt;p&gt;cp client.conf.sample client.conf 复制模板&lt;/p&gt;
&lt;p&gt;vim client.conf 修改2行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
base_path=/data/fastdfs/&lt;span&gt;tracker
tracker_server&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）查看存储节点状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fdfs_monitor /etc/fdfs/client.conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192707503-739725149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;6、FastDFS的上传、下载&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）fdfs_&lt;strong&gt;upload&lt;/strong&gt;_file &lt;strong&gt;/etc/fdfs/client.conf&lt;/strong&gt; xiaomi.zip 上传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192707925-1304781400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）在后端两个storage server 上，两个是同步的，一样&lt;/p&gt;
&lt;p&gt;① 二进制文件有记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192708534-652136445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;② 确实能找到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192709097-1129734139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）文件查看&lt;/p&gt;
&lt;p&gt;fdfs_&lt;strong&gt;file_info&lt;/strong&gt; /etc/fdfs/client.conf group1/M00/00/00/wKgeAlodCEGAXOuMB3o1rOpTQ-0771.zip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192709612-602466821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：上传到了192.168.30.2 的机器上，然后push推到192.168.30.7上&lt;/p&gt;

&lt;p&gt;（4）文件下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
fdfs_download_file /etc/fdfs/client.conf group1/M00/&lt;span&gt;00&lt;/span&gt;/&lt;span&gt;00&lt;/span&gt;/wKgeAlodCEGAXOuMB3o1rOpTQ-&lt;span&gt;0771&lt;/span&gt;.&lt;span&gt;zip&lt;/span&gt;&lt;span&gt;
md5sum xiaomi.&lt;/span&gt;&lt;span&gt;zip&lt;/span&gt; wKgeAlodCEGAXOuMB3o1rOpTQ-&lt;span&gt;0771&lt;/span&gt;.&lt;span&gt;zip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192710034-1554215011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：md5值是一样的&lt;/strong&gt;，表明是同一个文件&lt;/p&gt;

&lt;p&gt;（5）删除&lt;/p&gt;
&lt;p&gt;fdfs_&lt;strong&gt;delect&lt;/strong&gt;_file /etc/fdfs/client.conf group1/M00/00/00/wKgeAlodCEGAXOuMB3o1rOpTQ-0771.zip&lt;/p&gt;

&lt;p&gt;（6）上传测试&lt;/p&gt;
&lt;p&gt;fdfs_&lt;strong&gt;test&lt;/strong&gt; /etc/fdfs/client.conf &lt;strong&gt;upload&lt;/strong&gt; xiaomi.zip [FILE | BUFF | CALLBACK]&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;实验四：FastDFS实现nginx代理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在两个后端storage server 上实现的&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、安装nginx 插件，也存放到我的网盘里了，rz&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;yum -y localinstall nginx-*&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192710690-263102065.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、在nginx上加载模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;vim /etc/nginx/nginx.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
location /group1/&lt;span&gt;M00 {
        root &lt;/span&gt;/data/fastdfs/storage/&lt;span&gt;data;
        ngx_fastdfs_module;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3、修改fastdfs 模块的配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;vim /etc/fdfs/&lt;strong&gt;mod_fastdfs.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tracker_server=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.107&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;&lt;span&gt;
url_have_group_name &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
store_path0&lt;/span&gt;=/data/fastdfs/storage
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4、开启nginx 服务，测试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;systemctl start nginx&lt;/p&gt;
&lt;p&gt;网页测试 &lt;a href=&quot;http://192.168.30.2/group1/M00/00/00/wKgeB1odET-AGOSlAAAbjMSvzS8917.jpg&quot;&gt;&lt;span&gt;http://192.168.30.2/group1/M00/00/00/wKgeB1odET-AGOSlAAAbjMSvzS8917.jpg&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1216496/201711/1216496-20171128192711315-950981284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前面的实战，后几天慢慢补上！！！大家见谅。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 12:12:00 +0000</pubDate>
<dc:creator>阿龙along</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/7911676.html</dc:identifier>
</item>
<item>
<title>Python学习笔记整理总结【Memcache &amp; Redis】 - 李小小小伟</title>
<link>http://www.cnblogs.com/liwei1153300111/p/7911350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei1153300111/p/7911350.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Memcached&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;1、简介&lt;/strong&gt;&lt;br/&gt;Memcached 是一个高性能的分布式内存对象缓存系统，一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。用来存储小块的任意数据（字符串、对象）。比如：数据库调用、API调用或者是页面渲染的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、本质&lt;/strong&gt;&lt;br/&gt;它是一个简洁的key-value存储系统。其守护进程（daemon ）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、特征&lt;/strong&gt;&lt;br/&gt;　　①协议简单&lt;br/&gt;　　②基于libevent的事件处理&lt;br/&gt;　　③内置内存存储方式&lt;br/&gt;　　④memcached不互相通信的分布式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、主要操作&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;① add&lt;/span&gt;&lt;/strong&gt;：添加一条键值对，如果已经存在的 key，重复执行add操作异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  
&lt;span&gt;3&lt;/span&gt; mc = memcache.Client([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], debug=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; mc.add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;②replace&lt;/span&gt;&lt;/strong&gt;：修改某个key的值，如果key不存在，则异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  
&lt;span&gt;3&lt;/span&gt; mc = memcache.Client([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], debug=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果memcache中存在kkkk，则替换成功，否则异常&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; mc.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kkkk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;999&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;MemCached: while expecting 'STORED', got unexpected response 'NOT_STORED'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;③set 和 set_multi&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;set ：设置一个键值对，如果key不存在，则创建，如果key存在，则修改&lt;br/&gt;set_multi ：设置多个键值对，如果key不存在，则创建，如果key存在，则修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
 
mc &lt;/span&gt;= memcache.Client([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], debug=&lt;span&gt;True)
 
mc.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lianzhilei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mc.set_multi({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;val1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;val2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;④、delete 和 delete_multi&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;delete ：在Memcached中删除指定的一个键值对&lt;br/&gt;delete_multi ：在Memcached中删除指定的多个键值对&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
 
mc &lt;/span&gt;= memcache.Client([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], debug=&lt;span&gt;True)
 
mc.delete(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mc.delete_multi([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑤、get 和 get_multi&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;get ：获取一个键值对&lt;br/&gt;get_multi ：获取多一个键值对&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
 
mc &lt;/span&gt;= memcache.Client([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], debug=&lt;span&gt;True)
 
val &lt;/span&gt;= mc.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
item_dict &lt;/span&gt;= mc.get_multi([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑦、decr 和 incr　&lt;/span&gt;&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;incr ：自增，将Memcached中的某一个值增加 N （ N默认为1 ）&lt;br/&gt;decr ： 自减，将Memcached中的某一个值减少 N （ N默认为1 ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
 
mc &lt;/span&gt;= memcache.Client([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], debug=&lt;span&gt;True)
mc.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
mc.incr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; k1 = 778&lt;/span&gt;
&lt;span&gt; 
mc.incr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; k1 = 788&lt;/span&gt;
&lt;span&gt; 
mc.decr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; k1 = 787&lt;/span&gt;
&lt;span&gt; 
mc.decr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; k1 = 777&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;⑧、gets 和 cas&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如商城商品剩余个数，假设改值保存在memcache中，product_count = 900&lt;br/&gt;A用户刷新页面从memcache中读取到product_count = 900&lt;br/&gt;B用户刷新页面从memcache中读取到product_count = 900&lt;/p&gt;
&lt;p&gt;如果A、B用户均购买商品&lt;/p&gt;
&lt;p&gt;A用户修改商品剩余个数 product_count＝899&lt;br/&gt;B用户修改商品剩余个数 product_count＝899&lt;/p&gt;
&lt;p&gt;如此一来缓存内的数据便不在正确，两个用户购买商品后，商品剩余还是 899&lt;br/&gt;如果使用python的set和get来操作以上过程，那么程序就会如上述所示情况！&lt;/p&gt;
&lt;p&gt;如果想要避免此情况的发生，只要使用 gets 和 cas 即可，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; memcache
 
mc &lt;/span&gt;= memcache.Client([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.20.219:12000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], debug=True, cache_cas=&lt;span&gt;True)
 
v &lt;/span&gt;= mc.gets(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果有人在gets之后和cas之前修改了product_count，那么，下面的设置将会执行失败，剖出异常，从而避免非正常数据的产生&lt;/span&gt;
mc.cas(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;product_count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;899&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; Ps：本质上每次执行gets时，会从memcache中获取一个自增的数字，通过cas去修改gets的值时，会携带之前获取的自增值和memcache中的自增值进行比较，如果相等，则可以提交，如果不想等，那表示在gets和cas执行之间，又有其他人执行了gets（获取了缓冲的指定值）， 如此一来有可能出现非正常数据，则不允许修改&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Redis&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;1、简介&lt;/strong&gt;&lt;br/&gt;redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、特点&lt;/strong&gt;&lt;br/&gt;　　①、Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;br/&gt;　　②、Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;br/&gt;　　③、Redis支持数据的备份，即master-slave模式的数据备份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、redis-py 的API的使用&lt;/strong&gt;&lt;br/&gt;　　1）连接方式&lt;br/&gt;　　2）连接池&lt;br/&gt;　　3）操作管道&lt;br/&gt;　　　　&amp;lt;1&amp;gt;String 操作&lt;br/&gt;　　　　&amp;lt;2&amp;gt;Hash 操作&lt;br/&gt;　　　　&amp;lt;3&amp;gt;List 操作&lt;br/&gt;　　　　&amp;lt;4&amp;gt;Set 操作&lt;br/&gt;　　　　&amp;lt;5&amp;gt;Sort Set 操作&lt;br/&gt;　　4）管道&lt;br/&gt;　　5）发布订阅&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）连接方式&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
 
r &lt;/span&gt;= redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.211.55.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
r.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; r.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）连接池&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;每个Redis实例都会维护一个自己的连接池，&lt;strong&gt;&lt;span&gt;避免每次建立、释放连接的开销&lt;/span&gt;&lt;/strong&gt;。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  
&lt;span&gt;3&lt;/span&gt; pool = redis.ConnectionPool(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.211.55.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  
&lt;span&gt;5&lt;/span&gt; r = redis.Redis(connection_pool=&lt;span&gt;pool)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; r.set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; r.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）操作管道&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;1&amp;gt;String 操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;redis中的String在在内存中按照一个name对应一个value来存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1077788/201711/1077788-20171128180853206-582911828.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;① set(name, value, ex=None, px=None, nx=False, xx=&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;False)&lt;/strong&gt;&lt;/span&gt;
在Redis中设置值，默认，不存在则创建，存在则修改
参数：
     ex，过期时间（秒）
     px，过期时间（毫秒）
     nx，如果设置为True，则只有name不存在时，当前set操作才执行
     xx，如果设置为True，则只有name存在时，当前set操作才执行
 
&lt;/span&gt;127.0.0.1:6379&amp;gt; set name lzl ex 2&lt;span&gt;
OK
&lt;/span&gt;127.0.0.1:6379&amp;gt;&lt;span&gt; get name
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379&amp;gt;&lt;span&gt; get name
(nil)
&lt;strong&gt;&lt;span&gt;② setnx(name, value)&lt;/span&gt;&lt;/strong&gt;
设置值，只有name不存在时，执行设置操作（添加）
 
&lt;/span&gt;127.0.0.1:6379&amp;gt;&lt;span&gt; setnx name lianzhilei
(integer) 0
&lt;/span&gt;127.0.0.1:6379&amp;gt;&lt;span&gt; get name
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379&amp;gt;&lt;span&gt; setnx name2 lianzhilei
(integer) &lt;/span&gt;1
127.0.0.1:6379&amp;gt;&lt;span&gt; get name2
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lianzhilei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
③ setex(name, value, time)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; time，过期时间（数字秒 或 timedelta对象）&lt;/span&gt;
 
127.0.0.1:6379&amp;gt; setex age 2 18&lt;span&gt;
OK
&lt;/span&gt;127.0.0.1:6379&amp;gt;&lt;span&gt; get age
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379&amp;gt;&lt;span&gt; get age
(nil)
&lt;strong&gt;&lt;span&gt;④ psetex(name, time_ms, value)
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; time_ms，过期时间（数字毫秒 或 timedelta对象）&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑤ mset(*args, **&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;kwargs)&lt;/span&gt;&lt;/strong&gt;
批量设置值
如：
    mset(k1&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, k2=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    或
    mget({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
 
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; mset name lzl age 18&lt;span&gt;
OK
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; keys *
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑥ get(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取值&lt;/span&gt;
&lt;span&gt; 
r.set(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; b'lzl'&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑦ mget(keys, *&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;args)&lt;/span&gt;&lt;/strong&gt;
批量获取
如：
    mget(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    或
    r.mget([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
 
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt;&lt;span&gt; mget name age
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;
⑧ getset(name, value)&lt;/span&gt;&lt;/strong&gt;
设置新值并获取原来的值
 
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt;&lt;span&gt; getset name eric
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; get name
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑨ getrange(key, start, end)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取子序列（根据字节获取，非字符）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，Redis 的 name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start，起始位置（字节）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; end，结束位置（字节）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如： &quot;连志雷&quot; ，0-3表示 &quot;连&quot;&lt;/span&gt;
 
127.0.0.1:6379[2]&amp;gt; getrange name 0 5
&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lianzh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑩ setrange(name, offset, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; offset，字符串的索引，字节（一个汉字三个字节）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; value，要设置的值&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑪ setbit(name, offset, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对name对应值的二进制表示的位进行操作&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; offset，位的索引（将值变换成二进制后再进行索引）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; value，值只能是 1 或 0&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注：如果在Redis中有一个对应： n1 = &quot;foo&quot;，&lt;/span&gt;
        那么字符串foo的二进制表示为：01100110 01101111 01101111&lt;span&gt;
    所以，如果执行 setbit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 7, 1&lt;span&gt;)，则就会将第7位设置为1，
        那么最终二进制则变成 &lt;/span&gt;01100111 01101111 01101111，即：&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 扩展，转换二进制表示：&lt;/span&gt;
  
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; source = &quot;连志雷&quot;&lt;/span&gt;
    source = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; source:
        num &lt;/span&gt;=&lt;span&gt; ord(i)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(bin(num).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;))
  
    特别的，如果source是汉字 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连志雷&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;怎么办？
    答：对于utf&lt;/span&gt;-8，每一个汉字占 3 个字节，那么 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;武沛齐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 则有 9个字节
       对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制
        &lt;/span&gt;11100110 10101101 10100110 11100110 10110010 10011011 11101001 10111101 10010000
 
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; set n1 foo
OK
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; setbit n1 7 1&lt;span&gt;
(integer) 0
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt;&lt;span&gt; get n1
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;
setbit巨流弊的应用场景，想想什么情况下会用到这个功能呢？超大型的应用平台，比如新浪微博，我想查看当前正在登陆的用户，如何实现？当然你会想到，用户登陆后在数据库上的用户信息上做个标记，然后count去统计做标记的用户一共有多少，so，当前用户查看迎刃而解；OK，好好，首先每个用户登录都要设置标记，如果当前用户几个亿，那么得存几个亿的标记位，超级占用库的开销；现在就有一个无敌高效的办法，即统计当前在线用户，又显示在线用户ID，那就是利用二进制位，什么意思呢？看下面的代码就能明白了&lt;/span&gt;

统计在线用户数
 
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; setbit lineuser 1000 1      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1000表示用户id &lt;/span&gt;
&lt;span&gt;(integer) 0
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; setbit lineuser 55 1&lt;span&gt;
(integer) 0
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; setbit lineuser 6000 1&lt;span&gt;
(integer) 0
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; bitcount lineuser        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计当前二进制位1的个数，即当前在线用户数&lt;/span&gt;&lt;/strong&gt;
(integer) 3&lt;span&gt;&lt;strong&gt;&lt;span&gt;
bitcount统计二级制位中1的个数，setbit和bitcount配合使用，轻松解决当前在线用户数的问题，这还不是最厉害的，我们还能利用这个统计当前在线的都有谁
&lt;/span&gt;&lt;/strong&gt;
查看用户ID有没有在线
 
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt; getbit lineuser 1000        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看id1000   1表示在线 0表示不在线&lt;/span&gt;
(integer) 1
127.0.0.1:6379[2]&amp;gt; getbit lineuser 100&lt;span&gt;
(integer) 0
&lt;strong&gt;&lt;span&gt;当然我们还可以通过for循环或者yield生成器打印出所有的在线用户ID，1字节&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;=8位，那么10m=&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8000万位，即一个亿的在线用户也就10m多的内存就可搞定，优化就在点滴之间&lt;/span&gt;

&lt;span&gt;⑫ getbit(name, offset)

&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的值的二进制表示中的某位的值 （0或1）&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑬ bitcount(key, start=None, end=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的值的二进制表示中 1 的个数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; key，Redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start，位起始位置&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; end，位结束位置&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑭ bitop(operation, dest, *keys)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dest, 新的Redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; *keys,要查找的Redis的name&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    bitop(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AND&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑮ strlen(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回name对应值的字节长度（一个汉字3个字节）&lt;/span&gt;
 
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; get name
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lianzhilei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; strlen name
(integer) &lt;/span&gt;10&lt;strong&gt;&lt;span&gt;
⑯ incr(self, name, amount=1)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name,Redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; amount,自增数（必须是整数）&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注：同incrby&lt;/span&gt;
 
127.0.0.1:6379[2]&amp;gt; incr login_users     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自增&lt;/span&gt;
(integer) 1
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; incr login_users
(integer) &lt;/span&gt;2
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; incr login_users
(integer) &lt;/span&gt;3&lt;strong&gt;&lt;span&gt;
⑰ incrbyfloat(self, name, amount=1.0)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name,Redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; amount,自增数（浮点型）&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑱ decr(self, name, amount=1)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name,Redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; amount,自减数（整数）&lt;/span&gt;
 
127.0.0.1:6379[2]&amp;gt; decr login_users     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;自减&lt;/span&gt;
(integer) 2
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; decr login_users
(integer) &lt;/span&gt;1
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; decr login_users
(integer) 0
&lt;strong&gt;&lt;span&gt;⑲ append(key, value)
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在redis name对应的值后面追加内容&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
&lt;span&gt;    key, redis的name
    value, 要追加的字符串
 
&lt;/span&gt;127.0.0.1:6379[2]&amp;gt;&lt;span&gt; append name jjjj
(integer) &lt;/span&gt;14
127.0.0.1:6379[2]&amp;gt;&lt;span&gt; get name
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lianzhileijjjj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;2&amp;gt;Hash 操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在内存中按照一个name对应多个value来存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1077788/201711/1077788-20171128182351472-1865845840.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;① hset(name, key, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; name对应的hash中设置一个键值对（不存在，则创建；否则，修改）&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; key，name对应的hash中的key&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; value，name对应的hash中的value&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hset class14 name lzl
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt; hset class14 age 18&lt;span&gt;
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt; hset class14 id 10001&lt;span&gt;
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hgetall class14
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
4) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
5) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
6) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hget class14 name
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hkeys class14
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hvals class14
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
② hmset(name, mapping)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的hash中批量设置键值对&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mapping，字典，如：{'k1':'v1', 'k2': 'v2'}&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; r.hmset('xx', {'k1':'v1', 'k2': 'v2'})&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; hmset info k1 1 k2 2&lt;span&gt;
OK
&lt;/span&gt;127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hmget info k1 k2
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
③ hget(name,key)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的hash中获取根据key获取value&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;④ hmget(name, keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的hash中获取多个key的值&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，reids对应的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; keys，要获取key集合，如：['k1', 'k2', 'k3']&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; *args，要获取的key，如：k1,k2,k3&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; r.mget('xx', ['k1', 'k2'])&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 或&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print r.hmget('xx', 'k1', 'k2')&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; hmset info k1 1 k2 2&lt;span&gt;
OK
&lt;/span&gt;127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hmget info k1 k2
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;
⑤ hgetall(name)&lt;/span&gt;&lt;/strong&gt;
获取name对应hash的所有键值
&lt;strong&gt;&lt;span&gt;⑥ hlen(name)
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的hash中键值对的个数&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hlen info
(integer) &lt;/span&gt;2&lt;span&gt;&lt;strong&gt;
⑦ hkeys(name)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的hash中所有的key的值&lt;/span&gt;
&lt;span&gt;⑧ hvals(name)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的hash中所有的value的值&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑨ hexists(name, key)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查name对应的hash是否存在当前传入的key&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hexists info k1
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; hexists info k3
(integer) 0
&lt;strong&gt;&lt;span&gt;⑩ hdel(name,&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;*keys)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将name对应的hash中指定key的键值对删除&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑪ hincrby(name, key, amount=1)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自增name对应的hash中的指定key的值，不存在则创建key=amount&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis中的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; key， hash对应的key&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; amount，自增数（整数）&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; hincrby info k3 1&lt;span&gt;
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt; hincrby info k3 1&lt;span&gt;
(integer) &lt;/span&gt;2
127.0.0.1:6379[3]&amp;gt; hincrby info k3 1&lt;span&gt;
(integer) &lt;/span&gt;3&lt;strong&gt;&lt;span&gt;
⑫ hincrbyfloat(name, key, amount=1.0)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自增name对应的hash中的指定key的值，不存在则创建key=amount&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis中的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; key， hash对应的key&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; amount，自增数（浮点数）&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自增name对应的hash中的指定key的值，不存在则创建key=amount&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑬ hscan(name, cursor=0, match=None, count=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cursor，游标（基于游标分批取获取数据）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; match，匹配指定key，默认None 表示所有的key&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一次：cursor1, data1 = r.hscan('xx', cursor=0, match=None, count=None)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二次：cursor2, data1 = r.hscan('xx', cursor=cursor1, match=None, count=None)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; hscan info 0 match k*
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) 1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   4) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   5) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
   6) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑭ hscan_iter(name, match=None, count=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用yield封装hscan创建生成器，实现分批去redis中获取数据&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; match，匹配指定key，默认None 表示所有的key&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for item in r.hscan_iter('xx'):&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print item&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;lt;3&amp;gt;List 操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;redis中的List在在内存中按照一个name对应一个List来存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1077788/201711/1077788-20171128182425847-958687517.png&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;194&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;① lpush(name,values)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的list中添加元素，每个新的元素都添加到列表的最左边&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; r.lpush('oo', 11,22,33)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存顺序为: 33,22,11&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 扩展：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rpush(name, values) 表示从右向左操作&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; lpush names lzl alex wupeiqi
(integer) &lt;/span&gt;3
127.0.0.1:6379[3]&amp;gt; lrange names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;
② lpushx(name,value)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rpushx(name, value) 表示从右向左操作&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;③ llen(name)&lt;/span&gt;&lt;/strong&gt;
name对应的list元素的个数
 
&lt;/span&gt;127.0.0.1:6379[3]&amp;gt;&lt;span&gt; llen names
(integer) &lt;/span&gt;3&lt;strong&gt;&lt;span&gt;
④ linsert(name, where, refvalue, value))
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的列表的某一个值前或后插入一个新值&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; where，BEFORE或AFTER&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; refvalue，标杆值，即：在它前后插入数据&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; value，要插入的数据&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; linsert names BEFORE alex befor
(integer) &lt;/span&gt;4
127.0.0.1:6379[3]&amp;gt; lrange names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;befor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
4) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑤ lset(name, index, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对name对应的list中的某一个索引位置重新赋值&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; index，list的索引位置&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; value，要设置的值&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; lset names 3&lt;span&gt; LianZhiLei
OK
&lt;/span&gt;127.0.0.1:6379[3]&amp;gt; lrange names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;befor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
4) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LianZhiLei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑥ lrem(name, value, num)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的list中删除指定的值&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; value，要删除的值&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; num，  num=0，删除列表中所有的指定值；&lt;/span&gt;
           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; num=2,从前到后，删除2个；&lt;/span&gt;
           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; num=-2,从后向前，删除2个&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; lrem names 1&lt;span&gt; befor
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt; lrange names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LianZhiLei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑦ lpop(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rpop(name) 表示从右向左操作&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; lpop names
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;
⑧ lindex(name, index)&lt;/span&gt;&lt;/strong&gt;
在name对应的列表中根据索引获取列表元素
&lt;strong&gt;&lt;span&gt;⑨ lrange(name, start, end)
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的列表分片获取数据&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start，索引的起始位置&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; end，索引结束位置&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;⑩ ltrim(name, start, end)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的列表中移除没有在start-end索引之间的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start，索引的起始位置&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; end，索引结束位置&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; LRANGE names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
4) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LianZhiLei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt; ltrim names 1 2&lt;span&gt;
OK
&lt;/span&gt;127.0.0.1:6379[3]&amp;gt; LRANGE names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑪ rpoplpush(src, dst)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; src，要取数据的列表的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dst，要添加数据的列表的name&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; rpush names2 LZL
(integer) &lt;/span&gt;1
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; RPOPLPUSH names names2
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt; lrange names 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt; lrange names2 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LZL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑫ blpop(keys, timeout)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将多个列表排列，按照从左到右去pop对应列表的元素&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; keys，redis的name的集合&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; r.brpop(keys, timeout)，从右向左获取数据&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑬ brpoplpush(src, dst, timeout=0)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; src，取出并要移除元素的列表对应的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dst，要插入元素的列表对应的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑭ 自定义增量迭代
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、获取name对应的所有列表&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、循环列表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：&lt;/span&gt;
  
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; list_iter(name):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    自定义redis列表增量迭代
    :param name: redis中的name，即：迭代name对应的列表
    :return: yield 返回 列表元素
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    list_count &lt;/span&gt;=&lt;span&gt; r.llen(name)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xrange(list_count):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; r.lindex(name, index)
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; list_iter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;4&amp;gt;Set 操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Set集合就是不允许重复的列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;① sadd(name,values)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; name对应的集合中添加元素&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; sadd names alex alex lzl lzl jack
(integer) &lt;/span&gt;3
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; smembers names
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;
② scard(name)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的集合中元素个数&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; scard names
(integer) &lt;/span&gt;3&lt;strong&gt;&lt;span&gt;
③ sdiff(keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在第一个name对应的集合中且不在其他name对应的集合的元素集合（差级）&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; sadd names2 eric lzl wupeiqi
(integer) &lt;/span&gt;3
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; sdiff names names2
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
④ sdiffstore(dest, keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name1集合里有但是name2集合里没有的元素，然后把元素添加到dest对应的集合中&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; SMEMBERS names
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; SMEMBERS names2
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wupeiqi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; SDIFFSTORE dest names names2
(integer) &lt;/span&gt;2
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; SMEMBERS dest
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑤ sinter(keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取多个name集合中的交集&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; SINTER names names2
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑥ sinterstore(dest, keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取多个name对应集合的交集，再讲其加入到dest对应的集合中&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑦ sismember(name, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查value是否是name对应的集合的成员&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt;&lt;span&gt; SISMEMBER names lzl
(integer) &lt;/span&gt;1&lt;span&gt;&lt;strong&gt;
⑧ smembers(name)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的集合的所有成员&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑨ smove(src, dst, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将某个成员从一个集合中移动到另外一个集合&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑩ spop(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从集合的右侧（尾部）移除一个成员，并将其返回&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑪ srandmember(name, numbers)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从name对应的集合中随机获取 numbers 个元素&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑫ srem(name, values)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的集合中删除某些值&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑬ sunion(keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取多一个name对应的集合的并集&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑭ sunionstore(dest,keys, *args)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑮ sscan(name, cursor=0, match=None, count=None)
    sscan_iter(name, match=None, count=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大&lt;/span&gt;
 
127.0.0.1:6379[3]&amp;gt; sscan names 0 match l*
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) 1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;5&amp;gt;Sort Set 操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;104&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;① zadd(name, *args, **kwargs)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在name对应的有序集合中添加元素&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zadd('zz', 'n1', 1, 'n2', 2)&lt;/span&gt;
     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 或&lt;/span&gt;
     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zadd('zz', n1=11, n2=22)&lt;/span&gt;
 
127.0.0.1:6379[4]&amp;gt; zadd z1 10 lzl 5 alex 8 jack  11&lt;span&gt; lzl
(integer) &lt;/span&gt;3
127.0.0.1:6379[4]&amp;gt; ZRANGE z1 0 -1
1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按分值排序并去重&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;② zcard(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的有序集合元素的数量&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;③ zcount(name, min, max)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应的有序集合中分数 在 [min,max] 之间的个数&lt;/span&gt;
 
127.0.0.1:6379[4]&amp;gt; ZCOUNT z1 6 9&lt;span&gt;
(integer) &lt;/span&gt;1&lt;strong&gt;&lt;span&gt;
④ zincrby(name, value, amount)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自增name对应的有序集合的 name 对应的分数&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑤ zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按照索引范围获取name对应的有序集合的元素&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start，有序集合索引起始位置（非分数）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; end，有序集合索引结束位置（非分数）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; desc，排序规则，默认按照分数从小到大排序&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; withscores，是否获取元素的分数，默认只获取元素的值&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; score_cast_func，对分数进行数据转换的函数&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从大到小排序&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zrevrange(name, start, end, withscores=False, score_cast_func=float)&lt;/span&gt;
  
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按照分数范围获取name对应的有序集合的元素&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从大到小排序&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)&lt;/span&gt;
 
127.0.0.1:6379[4]&amp;gt; ZRANGE z1 0 -1&lt;span&gt; withscores
&lt;/span&gt;1) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
2) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
3) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
4) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
5) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lzl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
6) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
⑥ zrank(name, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取某个值在 name对应的有序集合中的排行（从 0 开始）&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zrevrank(name, value)，从大到小排序&lt;/span&gt;
 
127.0.0.1:6379[4]&amp;gt;&lt;span&gt; ZRANK z1 lzl
(integer) &lt;/span&gt;2
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;排名第二&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑦ zrangebylex(name, min, max, start=None, num=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name，redis的name&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; min，右区间（值）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start，对结果进行分片处理，索引位置&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; num，对结果进行分片处理，索引后面的num个元素&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; r.zrangebylex('myzset', &quot;-&quot;, &quot;[ca&quot;) 结果为：['aa', 'ba', 'ca']&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从大到小排序&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zrevrangebylex(name, max, min, start=None, num=None)&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑧ zrem(name, values)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除name对应的有序集合中值是values的成员&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如：zrem('zz', ['s1', 's2'])&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑨ zremrangebyrank(name, min, max)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据排行范围删除&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑩ zremrangebyscore(name, min, max)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据分数范围删除&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑪ zremrangebylex(name, min, max)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据值返回删除&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑫ zscore(name, value)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应有序集合中 value 对应的分数&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑬ zinterstore(dest, keys, aggregate=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; aggregate的值为:  SUM  MIN  MAX&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑭ zunionstore(dest, keys, aggregate=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; aggregate的值为:  SUM  MIN  MAX&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;⑮ zscan(name, cursor=0, match=None, count=None, score_cast_func=float)
　 zscan_iter(name, match=None, count=None,score_cast_func=float)
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;6&amp;gt;其他常用操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;① delete(*names)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据删除redis中的任意数据类型&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;② exists(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测redis的name是否存在&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;③ keys(pattern='*')
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据模型获取redis的name&lt;/span&gt;
  
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更多：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; KEYS * 匹配数据库中所有 key 。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; KEYS h*llo 匹配 hllo 和 heeeeello 等。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;④ expire(name ,time)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为某个redis的某个name设置超时时间&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑤ rename(src, dst)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对redis的name重命名为&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑥ move(name, db))
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将redis的某个值移动到指定的db下&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑦ randomkey()
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 随机获取一个redis的name（不删除）&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑧ type(name)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取name对应值的类型&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;⑨ scan(cursor=0, match=None, count=None)
　 scan_iter(match=None, count=None)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同字符串操作，用于增量迭代获取key&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）管道&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_05661ca7-4c7a-4a68-8838-4bd44071e01f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_05661ca7-4c7a-4a68-8838-4bd44071e01f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_05661ca7-4c7a-4a68-8838-4bd44071e01f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   
&lt;span&gt; 3&lt;/span&gt; pool = redis.ConnectionPool(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.211.55.4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=6379&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt; r = redis.Redis(connection_pool=&lt;span&gt;pool)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pipe = r.pipeline(transaction=False)&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; pipe = r.pipeline(transaction=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   
&lt;span&gt;10&lt;/span&gt; pipe.set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; pipe.set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;role&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   
&lt;span&gt;13&lt;/span&gt; pipe.execute()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）发布/订阅&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1077788/201711/1077788-20171128183336644-1109542464.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;182&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#&lt;strong&gt;redishelper&lt;/strong&gt;##&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;-Author-soloLi&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisHelper:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.&lt;span&gt;__conn&lt;/span&gt; = redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.20.219&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         self.chan_sub = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fm104.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         self.chan_pub = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fm104.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;  
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; public(self, msg):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         self.&lt;span&gt;__conn&lt;/span&gt;&lt;span&gt;.publish(self.chan_pub, msg)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; subscribe(self):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         pub = self.&lt;span&gt;__conn&lt;/span&gt;.pubsub()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开收音机&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         pub.subscribe(self.chan_sub)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调频道&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         pub.parse_response()           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;准备接受&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; pub
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#订阅者##&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;-Author-soloLi&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; redishelper &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RedisHelper
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; obj =&lt;span&gt; RedisHelper()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; redis_sub =&lt;span&gt; obj.subscribe()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     msg =&lt;span&gt; redis_sub.parse_response()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(msg)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#发布者##&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;-Author-soloLi&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; redishelper &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RedisHelper
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; obj =&lt;span&gt; RedisHelper()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; obj.public(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 更多操作：http://doc.redisfans.com/&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、Redis和Memcached的区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、数据类型支持不同&lt;/span&gt;&lt;br/&gt;Memcached仅支持简单的key-value结构的数据记录，Redis拥有更多的数据结构和并支持更丰富的数据操作，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、内存管理机制不同&lt;/span&gt;&lt;br/&gt;在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、数据持久化支持&lt;/span&gt;&lt;br/&gt;Redis支持内存数据的持久化，而memcached是不支持。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、集群管理的不同&lt;/span&gt;&lt;br/&gt;Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、性能对比&lt;/span&gt;&lt;br/&gt;由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 11:30:00 +0000</pubDate>
<dc:creator>李小小小伟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liwei1153300111/p/7911350.html</dc:identifier>
</item>
<item>
<title>决策：加入创业公司的考虑 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/7911619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/7911619.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/815275/201711/815275-20171128190823940-799714673.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大约两年前，也就是 2015 年，那个创业公司如雨后春笋般出现，又如昙花一现般凋零的双创年代。我碰到过一个人，一年换了三个公司，我就问：为什么这么频繁跳槽呢？而答案也让我吃了一惊，因为他加入的每家公司，没几个月公司就关门了。&lt;/p&gt;
&lt;p&gt;那时候，我也收到过来自创业公司的邀约，而我最终选择了拒绝。这样的决策回想起来，当时可能是一种模糊的意会，谈不上多理性的分析。那有没有更理性而科学，决策胜率更高的方法呢？如今我想尝试回答这个问题。&lt;/p&gt;
&lt;h2 id=&quot;期望&quot;&gt;期望&lt;/h2&gt;
&lt;p&gt;为什么要加入创业公司，你的期望是什么？也许有下面几种原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自由成长&lt;/li&gt;
&lt;li&gt;变身土豪&lt;/li&gt;
&lt;li&gt;追求梦想&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自由成长&quot;&gt;自由成长&lt;/h3&gt;
&lt;p&gt;创业公司相对成熟的大公司，会有更大的自由度。能接触的东西更多，需要处理的问题也更多，会让人更容易自由成长为一种各类问题的多面手。对于程序员而言，很可能就是成长为全栈工程师。&lt;/p&gt;
&lt;p&gt;有些人就会觉得在大公司过于拘束，干的事情专业分工很精细，并不适合自己相对广泛的兴趣路线。&lt;/p&gt;
&lt;h3 id=&quot;变身土豪&quot;&gt;变身土豪&lt;/h3&gt;
&lt;p&gt;坊间一直流传着创业公司上市 IPO 一夜变身土豪的故事，但我们不妨理性得来分析一下。&lt;/p&gt;
&lt;p&gt;最早期的创业公司，大概处在天使轮阶段。作为技术人，如果你的经验和背景足以成为以技术合伙人的身份加入，那么大概你可以拿到公司占比 5% 左右的期权。假如公司最后成功 IPO 上市了，市值 100 亿，那么你的股票兑现就值大约 5 亿了（这里忽略行权和各类税务成本），成功变身土豪。但关键点在于，从天使轮到上市途中，统计数据上显示会倒下 99% 的创业公司。&lt;/p&gt;
&lt;p&gt;如果创业公司进展到了 A 轮，你再加入，成为合伙人的概率就低了，更可能成为一名高管。这时能分到的期权会少一个量级，大约 0.5%。最终公司上市，还是 100 亿市值，勉强还能成为一个瘦点的土豪。&lt;/p&gt;
&lt;p&gt;进一步到了 B 轮，再加入时，想成为高管的能力和背景要求都更高了，这时能拿到的期权比例会进一步下降一个量级，大约 0.05%。100 亿的市值，按这个比例就不太能成为土豪了。&lt;/p&gt;
&lt;p&gt;到了 C 轮，公司上市的可能性大大增高，前景可期。但这时加入能拿到的比例进一步下降一个量级到 0.005%，如果这时公司的上市预期市值就 100 亿，估计也吸引不到什么人了。&lt;/p&gt;
&lt;p&gt;过了 C 轮还没上市的公司，继续融资到 DEFG 轮的，这些基本都不算是什么创业小公司了，都是创业巨头，如：美团、滴滴。&lt;/p&gt;
&lt;h3 id=&quot;追求梦想&quot;&gt;追求梦想&lt;/h3&gt;
&lt;p&gt;你想为你的梦想支付多大的成本与代价。&lt;/p&gt;
&lt;p&gt;假如你当下在成熟的大公司工作，大公司无论工资还是配股的收益都有很高的确定性。创业公司即使给你开出同等的工资（这比较罕见，而且创业公司也不希望招一个只要高工资，不要公司期权的人吧），相对大公司的稳定性和持续性，也依然处于劣势。&lt;/p&gt;
&lt;p&gt;更可能的情况是，创业公司给你的工资加上按目前融资轮次估值的期权价值一起，才勉强和你在大公司每年的确定收益相持平。站在创业公司的角度，当然会觉得期权价值的不菲，而且每进入下一轮期权价值一般都会增幅巨大，拥有很大的增值潜力。而站在你的角度而言，给期权的正确估值应该是 0，期权的兑现日期你无法预期是多久，也许是五年，也可能是十年后。&lt;/p&gt;
&lt;p&gt;将期权更多的看作彩票。如果期权让你发了财，这非常好，但是你应当确保自己的工资报酬至少可以接受，也就是说即使你的合同中没有期权，你也仍然会选择加入这家创业公司。这中间相对你在大公司的确定性收益的差距便是追求梦想的直接经济成本，也可以理解为你选择创业的风险投入资本。&lt;/p&gt;
&lt;p&gt;最理想情况下，通过一次创业的成功，上述三者都一次实现了，但现实却往往没那么理想。&lt;/p&gt;
&lt;h2 id=&quot;条件&quot;&gt;条件&lt;/h2&gt;
&lt;p&gt;搞清楚了自身的期望与需要付出的成本与代价，再来理性的看看其他方面的因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创始人创业的目的是什么，期望是什么？&lt;/strong&gt;&lt;br/&gt;创业毕竟是一段长期的旅程，大家的目的、价值观、期望差距太大，必然走不长远，身边就目睹过这样的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创始人以前的口碑和信用如何？&lt;/strong&gt;&lt;br/&gt;有信用污点的人并不值得合作与跟随，而且前面说的创业公司期权，最终能否兑现（国内）跟这一点关系密切。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公司的核心团队如何？&lt;/strong&gt;&lt;br/&gt;看看之前都有些什么样的人，你对这个团队的感觉契合么？这个团队是合作融洽，还是各怀鬼胎。有些小公司，人虽不多，办公室政治比大公司还厉害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对你的定位是什么？&lt;/strong&gt;&lt;br/&gt;创业公司在发展初期容易遇到技术瓶颈，以招 CTO 的名义，来找一个能解决当前技术瓶颈的专业人才。也许你会被名头（Title）吸引，解决完问题，度过了这个瓶颈，老板还会觉得你的价值还足够大么？不是有句话么：技术总是短期被高估，长期被低估。而你自身还能跟得上公司的发展需要么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公司是否有明确的业务方向？有哪些对手？相对竞争的核心优势是什么？&lt;/strong&gt;&lt;br/&gt;很多做技术的同学都不太关心业务的商业模式，也许这在大公司可以，毕竟船大，一般也就感觉不到风浪。但在创业公司则不然，如果业务没有明确的方向和优势，你憧憬着踏上了火箭，结果却是小舢板，起大风时感觉还走得挺快，风一停，就只好随波荡漾了。&lt;/p&gt;
&lt;p&gt;也许还有很多其他方面你关注的条件和因素，在选择前都可以先列出来比较。只是最后我比较确定的一件事是，不会有任何一家公司满足你所有心仪的条件，这时就需要你做决策了。&lt;/p&gt;
&lt;h2 id=&quot;决策&quot;&gt;决策&lt;/h2&gt;
&lt;p&gt;决策之前，期望是内省，条件是外因。决策就是将客观的外因与主观内省进行匹配判断选择的过程。&lt;/p&gt;
&lt;p&gt;决策很难，让人经常很矛盾，很沮丧。往回看，我们总能找到适合自己的最优决策路径，我们沮丧是因为当初没有选这条路。往前看，其实有无数的路径分支，我怎么可能选中最优路径，有这样的方法吗？没有。&lt;/p&gt;
&lt;p&gt;这样的决策就像古时先哲讲过的一个故事，大意是：你有一个机会经过一条路，这条路两边都是大大小小的宝石，你只能走过这条路一次，捡起其中一块宝石，中间不能更换。捡到最大的宝石就是最优策略，但你怎么实现这个最优策略呢？其实没有方法能保证。&lt;/p&gt;
&lt;p&gt;而先哲的建议是，前 1/3 的路径，你只观察周围的宝石，最大的有多大，平均大小大概在什么水平，但不出手捡。经过前 1/3 的路程，你应该有一个预期的大小标准，这个标准可能略比平均大小大一些，但不应该以之前看见的最大的为标准。再走剩下的 2/3 路程时，你只要看见第一个符合这个标准的宝石，就可以出手捡起，之后快速走完全程。&lt;/p&gt;
&lt;p&gt;这个方法不能保证你捡到最大的宝石，但能有很大概率保证你捡到符合自己预期标准大小的宝石，而这个预期标准，就是你的 “满意标准”。这个捡宝石的决策就是 “满意决策”，满意决策是一种折衷决策，只是在当时情况下可选的最佳行动方案。&lt;/p&gt;
&lt;p&gt;人生中会有很多类似 “捡宝石” 这样的决策场景：找工作、找伴侣、选房子、买股票，甚至是买任何东西，只不过因为其中大部分东西的购买支付代价低，你不会有太大的决策压力。前 1/3 的路程就是让你在决策前充分观察、调研、确定你的满意标准，之后面对第一个满意对象就能够直接决策，然后继续快速前行。&lt;/p&gt;
&lt;p&gt;满意决策的方案就是让你做完决策不纠结，即使后来回看离最优还有差距，也不遗憾。因为，人一生要面对的决策很多，“满意决策” 的办法让你省下了 2/3 纠结的路程，继续快速前行。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;决策过后，有遗憾，没不甘。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 11:09:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/7911619.html</dc:identifier>
</item>
<item>
<title>深入浅出多线程——ReentrantLock (一) - 行者悟空</title>
<link>http://www.cnblogs.com/itunic/p/java-reentrant-lock1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itunic/p/java-reentrant-lock1.html</guid>
<description>&lt;p&gt;　　ReentrantLock是一个排它重入锁，与synchronized关键字语意类似，但比其功能更为强大。该类位于java.util.concurrent.locks包下，是Lock接口的实现类。基本用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; X {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
 
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; m() {
      lock.lock();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; block until condition holds&lt;/span&gt;
      &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... method body&lt;/span&gt;
      } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        lock.unlock()
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本文章会围绕核心方法lock()，unlock()进行分析。在开始之前，对部分概念进行阐述：&lt;/p&gt;
&lt;p&gt;　　1，RenntrantLock是一个排它重入锁，重入次数为Integer.MAX_VALUE，其中通过构造实现两大核心（公平锁，非公平锁）。在默认情况下是非公平锁。&lt;/p&gt;
&lt;p&gt;　　2，RenntrantLock的公平锁和非公平锁基于抽象类AbstractQueuedSynchornizer，简称AQS。在源码分析阶段，也会涉及该类相关的原理分析。更加详细的会在后续文章中单独说明。&lt;/p&gt;
&lt;p&gt;　　3，AQS中涉及到了大量的Compare and swap操作，简称CAS。CAS利用的是cpu级别原子指令无锁的去修改目标值，在并发场景下只会有一个成功。在java中有大量的应用，其中最经典的为java.util.concurrent.atomic包下的相关类。更加详细的阐述会在后续文章中单独说明。&lt;/p&gt;
&lt;h3&gt;原理分析&lt;/h3&gt;
&lt;p&gt;　　我们按照默认的不公平锁为例子进行深入。&lt;/p&gt;
&lt;h4&gt;lock()方法分析&lt;/h4&gt;
&lt;h5&gt;NonfairSync.lock()&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        setExclusiveOwnerThread(Thread.currentThread());
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         acquire(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先去尝试将state值从0改为1，如果修改成功，把该线程设置为Owner。因为用CAS的方式去修改这个值，在并发环境下只会有一个成功。不成功的则进入acquire(1)方法。&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.acquire(int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            selfInterrupt();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该方法，首先在此尝试修改state的值，尽量用最小的代价设置成功。&lt;/p&gt;
&lt;p&gt;具体方法代码如下：&lt;/p&gt;
&lt;h5&gt;NonfairSync.tryAcquire(int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nonfairTryAcquire(acquires);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接调用了nonfairTryAcquire(acquires)。如下：&lt;/p&gt;
&lt;h5&gt;Sync.nonfairTryAcquire(int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; nonfairTryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; Thread current =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (compareAndSetState(0&lt;span&gt;, acquires)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                    setExclusiveOwnerThread(current);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current ==&lt;span&gt; getExclusiveOwnerThread()) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; nextc = c +&lt;span&gt; acquires;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                setState(nextc);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先判断state的值是否为0。如果为0，则尝试修改state为1，如果设置成功，则将执行线程Owner为当前线程。如果state不为0，则判断当前线程是否与执行线程Owner一致。如果一致则只对state加1，这个地方实现了类似偏向锁。&lt;/p&gt;
&lt;p&gt;　　如果条件都不满足，返回false，则执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。从里往外看，&lt;/p&gt;
&lt;p&gt;　　首先调用的是addWaiter(Node.EXCLUSIVE)方法，该方法的参数为Node.EXCLUSIVE，表示为队列为独占模式。&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.addWaiter(Node)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Try the fast path of enq; backup to full enq on failure&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         Node pred =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             node.prev =&lt;span&gt; pred;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 pred.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        enq(node);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第2行代码是 创建了一个独占模式的队列节点node，通过node实现可以看出是双向链表数据结构。&lt;/p&gt;
&lt;p&gt;　　判断列队pred是否为空，如果不为空，则node的节点prev变量设置为pred。尝试去修改列队tail的值为node，如果成功则直接返回。&lt;/p&gt;
&lt;p&gt;　　因为第一次进入，tail肯定为空，直接执行enq(node)方法。&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.enq(Node)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Node t =&lt;span&gt; tail;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must initialize&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node()))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     tail =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 node.prev =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     t.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　enq(node)方法进来是一个自旋操作，一段很经典的代码。&lt;/p&gt;
&lt;p&gt;　　首先判断tail是否为空，因为第一次进入肯定为空。那么实例化一个空节点，将队列head，tail指向该空节点。完成该动作后再次自旋，此时tail肯定是不为空的，则直接执行else内容。&lt;/p&gt;
&lt;p&gt;　　首先将node节点的上游指向tail后利用cas将队列tail设置为node，然后将原先的tail（t）的next指向node，此时node节点成功加入列队中。&lt;/p&gt;
&lt;p&gt;　　再次回到acquire(1)方法，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法。&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.acquireQueued(Node,int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    setHead(node);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                     failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; interrupted;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    parkAndCheckInterrupt())
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　该方法进来也是一个自旋操作，与enq方法类似。&lt;/p&gt;
&lt;p&gt;　　第6行，node的上游此时指向的是空节点，虽然和head相等，但是由于是空线程，那么在执行tryAcquire(arg)方法肯定返回false。&lt;/p&gt;
&lt;p&gt;　　代码直接来到了第13行，shouldParkAfterFailedAcquire(p,node)方法先执行，如下：&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(Node,Node)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; pred.waitStatus;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 node.prev = pred =&lt;span&gt; pred.prev;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             } &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             pred.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先判断node的上游节点的等待状态是否为-1，因为node的上游节点是空对象，waitStatus为初始值0。该方法会直接返回运行else里面内容，将waitStatus修改为-1。&lt;/p&gt;
&lt;p&gt;　　通过acquireQueued自旋会再次来到该方法，此时waitStatus的值为-1，返回true。然后执行第二个方法parkAndCheckInterrupt()方法。如下：&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.parkAndCheckInterrupt()&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; parkAndCheckInterrupt() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         LockSupport.park(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　进入该方法直接调用LockSupport.park(this)方法，意思是将该线程直接暂停，其线程状态在Runnable变为WAITING。等待调用LockSupport.unpark(this)将其唤醒，再次进入acquireQueued的自旋当中，直至能成功的把state的值从0变为1为止，当修改成功后，将队列的head设置为当前node。&lt;/p&gt;
&lt;h4&gt;unlock()方法分析&lt;/h4&gt;
&lt;h5&gt;ReentrantLock.lock()&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         sync.release(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个没啥好说的，直接调用了AQS里面的release方法了。&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.release(int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryRelease(arg)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             Node h =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                unparkSuccessor(h);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　首先调用tryRelease(int)方法，尝试去释放该锁。如果释放成功，则进入if方法体，首先判断队列的head不为空，在判断head.waitStatus不为0（当前实际值为-1），则调用unparkSuccessor(Node)。&lt;/p&gt;
&lt;h5&gt;Sync.tryRelease(int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; c = getState() -&lt;span&gt; releases;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Thread.currentThread() !=&lt;span&gt; getExclusiveOwnerThread())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; free = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 free = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 setExclusiveOwnerThread(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            setState(c);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先将state减1后，判断是否为0，如果为0，则正式释放，如果不为0，仅仅将state的值更新。在这个方法可以反映出 lock()调用几次，必须有相应的unlock()调用次数，否则造成死锁。&lt;/p&gt;
&lt;h5&gt;AbstractQueuedSynchronizer.unparkSuccessor(int)&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; node.waitStatus;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             compareAndSetWaitStatus(node, ws, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         Node s =&lt;span&gt; node.next;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             s = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     s =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            LockSupport.unpark(s.thread);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先判断node.waitStatus是否小于0，如果小于0，则将state变量修改为0。其次获取到node的下游节点，如果下游节点s 为空或者被取消，则从队列尾部向前查找符合条件的节点。如果不为空或者未被取消，则调用LockSupport.unpark(s.thread)将其唤醒。&lt;/p&gt;
&lt;h3&gt; 总结&lt;/h3&gt;
&lt;p&gt;　　通过分析lock()和unlock()，我们得知AQS内部实现了一个基于双向链表的队列。发成资源竞争时，因为CAS的特性只会有一个成功，其他的均进入该队列，有点类似于synchronized的临界区。&lt;/p&gt;
&lt;p&gt;　　执行中的线程再次调用lock()时，并不会进入等待列队，而是将state加1继续执行，基于偏向锁的思想去实现的。&lt;/p&gt;
&lt;p&gt;　　在线程释放时，也要对应着将state进行每次减1。直到state值为0，才认为当前线程真正的释放。释放后调用当前线程的下游节点去执行，此时，因为是非公平锁的缘故，可能新加入的线程在当前线程释放时征用成功，state值又变为1。那当前线程的下游节点再次陷入WAITING状态。&lt;/p&gt;

</description>
<pubDate>Tue, 28 Nov 2017 09:47:00 +0000</pubDate>
<dc:creator>行者悟空</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itunic/p/java-reentrant-lock1.html</dc:identifier>
</item>
<item>
<title>基于socket.io打造hybrid调试页面 - 撒网要见鱼</title>
<link>http://www.cnblogs.com/dailc/p/7910900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dailc/p/7910900.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;参考的&lt;a href=&quot;https://wsdebug.dingtalk.com/?spm=a219a.7629140.0.0.BHzRGr&quot;&gt;钉钉调试页面&lt;/a&gt;实现，仅供学习！&lt;/p&gt;
&lt;p&gt;功能为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PC端编写代码，手机端执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决的痛点是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;避免了调试&lt;code&gt;hybrid&lt;/code&gt;应用时重复写各种测试页面&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;源码与示例&quot;&gt;源码与示例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dailc/node-server-examples/tree/master/node-socketio-hybriddebug&quot; class=&quot;uri&quot;&gt;https://github.com/dailc/node-server-examples/tree/master/node-socketio-hybriddebug&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;vs&quot;&gt;`npm install`&lt;/span&gt;

&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;.&lt;span class=&quot;vs&quot;&gt;`npm run serve`&lt;/span&gt;启动&lt;span class=&quot;vs&quot;&gt;`node`&lt;/span&gt;服务

&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;.浏览器打开&lt;span class=&quot;vs&quot;&gt;`./test/debugroom.html`&lt;/span&gt;页面

&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;.开始测试（浏览器直接打开或手机扫码）

注意，手机端链接请确保在同一个网段&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意⚠️，实际情况请重写&lt;code&gt;client&lt;/code&gt;页面，让其支持对于&lt;code&gt;Hybrid&lt;/code&gt;容器的API&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3437876-e57856c2b0457cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3437876-0030c8871cf57100.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;原理其实非常简单，就是&lt;code&gt;HTML5&lt;/code&gt;中的&lt;code&gt;websocket&lt;/code&gt;，而且为了方便，还直接使用了成熟的第三方库&lt;code&gt;socket.io&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;基本交互如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;.先启动一个node后台（控制台），基于&lt;span class=&quot;vs&quot;&gt;`express`&lt;/span&gt;和&lt;span class=&quot;vs&quot;&gt;`socket.io`&lt;/span&gt;监听&lt;span class=&quot;vs&quot;&gt;`socket`&lt;/span&gt;连接

&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;.打开一个PC端调试页面，连接后台，创建一个房间（可以创建N个房间）

&lt;span class=&quot;fl&quot;&gt;3.&lt;/span&gt;PC端页面基于房间号生成对应房间的客户端地址（每一个房间中可以有&lt;span class=&quot;vs&quot;&gt;`N`&lt;/span&gt;个客户端），并基于地址创建二维码，方便使用（可以基于&lt;span class=&quot;vs&quot;&gt;`qrcode.js`&lt;/span&gt;等库）

&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;.&lt;span class=&quot;vs&quot;&gt;`Hybrid`&lt;/span&gt;客户端扫码后（或者打开客户端链接后），客户端页面连接后台，根据当前的房间号，在房间中创建客户端

&lt;span class=&quot;fl&quot;&gt;5.&lt;/span&gt;PC端输入代码后，点击执行时，会将代码文本发送到后台，然后后台再推送给客户端，客户端通过&lt;span class=&quot;vs&quot;&gt;`eval`&lt;/span&gt;即可执行这段代码，执行完毕后也可通过同样方式通知PC端&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul readability=&quot;-0.85454545454545&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务端是引用的&lt;code&gt;npm&lt;/code&gt;的&lt;code&gt;socket.io&lt;/code&gt;包&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.77142857142857&quot;&gt;
&lt;p&gt;客户端是引用&lt;a href=&quot;https://github.com/socketio/socket.io-client&quot;&gt;socket.io-client&lt;/a&gt;项目中发布的&lt;code&gt;socket.io.js&lt;/code&gt;文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;后台程序直接基于&lt;code&gt;es6&lt;/code&gt;语法编写的，然后基于&lt;code&gt;gulp&lt;/code&gt;打包成&lt;code&gt;dest&lt;/code&gt;文件，实际运行的是&lt;code&gt;dest&lt;/code&gt;中的发布文件，代码规范接近与&lt;code&gt;airbnb&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;前端页面的话比较随意，样式还大量用了钉钉原本的样式，也没有考虑各种浏览器的兼容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么说是&lt;code&gt;hybrid&lt;/code&gt;调试页面？因为打造它的核心需求就是用来调试&lt;code&gt;hybrid&lt;/code&gt;API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;
&lt;p&gt;由于篇幅关系（也没有必要），并不会将所有代码都介绍一遍，只会介绍一些重点步骤，更多的可以直接阅读源码（源码中已经足够清晰）&lt;/p&gt;
&lt;h3 id=&quot;设计debugroompc端和debugclienthybrid端&quot;&gt;设计&lt;code&gt;DebugRoom&lt;/code&gt;（PC端）和&lt;code&gt;DebugClient&lt;/code&gt;（&lt;code&gt;hybrid&lt;/code&gt;端）&lt;/h3&gt;
&lt;p&gt;根据交互，PC端和hybrid端都需要和后台连接，因此这里直接单独封装了两个类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DebuRoom类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;房间的定义是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DebugRoom &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 所属的房间号&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_roomId&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 所持有的socket对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_socket&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 客户端持有默认是一个空对象，key是clientid，value是client&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_clients&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;id&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;clients&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;socket&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;getClientsCount&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;removeClient&lt;/span&gt;(client)
    &lt;span class=&quot;at&quot;&gt;addClient&lt;/span&gt;(client)
    &lt;span class=&quot;at&quot;&gt;clearClients&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;DebugClient类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端的定义是：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;只有一个&lt;code&gt;socket&lt;/code&gt;引用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有一个客户端&lt;code&gt;id&lt;/code&gt;标识&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个房间&lt;code&gt;id&lt;/code&gt;引用，指向对于的房间号（当然其实也可以是引用&lt;code&gt;DebugRoom&lt;/code&gt;对象的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DebugClient &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 所属的房间号&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_roomId&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 客户端id&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_clientId&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 所持有的socket对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;_socket&lt;/span&gt;
    
    &lt;span class=&quot;at&quot;&gt;id&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;roomId&lt;/span&gt;()
    &lt;span class=&quot;at&quot;&gt;socket&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;设计一些交互接口&quot;&gt;设计一些交互接口&lt;/h3&gt;
&lt;p&gt;前后端交互通过&lt;code&gt;socket.io&lt;/code&gt;中定义的事件来，以下是房间以及客户端和后台的交互事件接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用交互事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 后台监听连接，每有一个连接时（前端通过`io.connect`），会通知客户端触发'open'事件&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'connection'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)

&lt;span class=&quot;co&quot;&gt;// 后台监听关闭连接，每当连接关闭时（前端直接关闭或调用`socket.disconnect`），会检测本地房间与客户端，如果关闭的是客户端，则移除这个客户端，对于的房间下的引用也置空，否则如果是房间，移除并关闭房间内所有的客户端&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'disconnect'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;房间与客户端：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 前台监听打开事件，此时，如果是房间，则会通知后台触发'create room'，否则通知后台触发'create client'&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'open'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)

&lt;span class=&quot;co&quot;&gt;// 前台监听连接是否关闭&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'disconnect'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;房间与后台交互事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 监听创建房间，如果房间ID合法，则会创建一个新的房间（new DebugRoom）&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'create room'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)
&lt;span class=&quot;co&quot;&gt;// 监听房间分发数据，并且将数据转发给房间内的所有客户端，通知客户端触发'receive dispatch data'事件&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'dispatch data'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;房间：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 监听客户端创建，每一个客户端加入对应房间时都会通知这个房间&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'client created'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)
&lt;span class=&quot;co&quot;&gt;// 监听客户端关闭，每一个客户端退出时都会通知这个房间&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'client destroy'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)
&lt;span class=&quot;co&quot;&gt;// 监听客户端执行，客户端每执行一次分发数据时，都会通知房间是否执行成功&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'client excuted'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端与后台交互事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 监听客户端创建，如果房间已存在，并且客户端id合法，才会正常创建，创建完后会通知房间触发'client created'事件&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'create client'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)
&lt;span class=&quot;co&quot;&gt;// 监听客户端响应执行，客户端执行一次分发数据后，会通知后台，后台接收到这个事件后，通知房间触发'client excuted'事件&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'client excute notify'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 监听接收分发数据，接收完后会执行数据中的代码，并且通知后台是否执行成功，触发后台的'client excute notify'事件&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'receive dispatch data'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;一些逻辑上的细节&quot;&gt;一些逻辑上的细节&lt;/h3&gt;
&lt;p&gt;以上流程就是整套程序的基本思路与交互，这里再补充一些交互细节&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用全局的&lt;code&gt;roomsHash&lt;/code&gt;和&lt;code&gt;clientsHash&lt;/code&gt;缓存住所有的房间和客户端，方便直接查询&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每次创建时，&lt;code&gt;id&lt;/code&gt;可以直接绑定在对于的&lt;code&gt;socket&lt;/code&gt;中，这样更方便&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;房间和客户端&lt;code&gt;id&lt;/code&gt;最好不要直接使用，可以进过一次编码（这样可以直接使用中文）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端失联时，一定要先判断房间是否以及销毁，不要重复操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;失去连接后，缓存中的引用要及时清除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多源码请参考&lt;a href=&quot;https://github.com/dailc/node-server-examples/tree/master/node-socketio-hybriddebug&quot; class=&quot;uri&quot;&gt;https://github.com/dailc/node-server-examples/tree/master/node-socketio-hybriddebug&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Tue, 28 Nov 2017 08:58:00 +0000</pubDate>
<dc:creator>撒网要见鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dailc/p/7910900.html</dc:identifier>
</item>
<item>
<title>Asp.Net MVC 捆绑（Bundle） - JoeSnail</title>
<link>http://www.cnblogs.com/JoeSnail/p/7910875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JoeSnail/p/7910875.html</guid>
<description>&lt;p&gt;大多数浏览器会对同一域名的请求限制请求数量，一般是在8个以内。每次最多可以同时请求8个，要是资源多于8个，那么剩下的就要排队等待请求了。所以为了提高首次加载页面的速度。提高请求并发请求数量，降低请求次数就是一个很重要的点。&lt;/p&gt;
&lt;h2 id=&quot;bundle&quot;&gt;Bundle&lt;/h2&gt;
&lt;p&gt;Asp.Net MVC4和.NET Framework4.5提供了支持捆绑和压缩的新类库&lt;code&gt;System.Web.Optimization&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该类库提供了如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;捆绑-将多个资源文件（javascript,css）合并成一个单独的文件，但是合并成的单独文件必须是相同类型，要么都是JavaScript要么都是CSS。&lt;/li&gt;
&lt;li&gt;压缩资源文件-清理空格，换行等，压缩文件大小。&lt;/li&gt;
&lt;li&gt;自动清理缓存-服务端更新资源时，客户端不再使用缓存资源，而是重新从服务端缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;定义bundle&quot;&gt;1. 定义Bundle&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;App_Start&lt;/code&gt;文件中新增一个&lt;code&gt;BundleConfig.cs&lt;/code&gt;文件。实现静态&lt;code&gt;RegisterBundles&lt;/code&gt;方法。该方法用来创建，注册和配置bundle。（&lt;em&gt;在该目录下代码最好把他们的命名空间去掉 &quot;.App_Start&quot;，保持一个统一的高等级的命名空间&lt;/em&gt;）。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;调用&lt;code&gt;BundleCollection.Add()&lt;/code&gt;方法添加捆绑资源，该方法参数为&lt;code&gt;ScriptBundle&lt;/code&gt;或&lt;code&gt;StyleBundle&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;ScriptBundle&lt;/code&gt;和&lt;code&gt;StyleBundle&lt;/code&gt;需要传递一个虚拟路径给构造函数。该虚拟路径其实就是该捆绑的名称或者标识符。所以该虚拟路径可以任意设置，并不需要匹配物理路径。&lt;code&gt;Bundle&lt;/code&gt;的&lt;code&gt;Include&lt;/code&gt;方法包含一个或者多个脚本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过引用该虚拟路径就可以使用这些捆绑的资源&lt;code&gt;@Script.Render(&quot;~/bundles/jquery&quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Debug模式下默认没有开启捆绑和压缩，发布模式下默认是开启的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static void RegisterBundles(BundleCollection bundles)
{
     //该值为true，在任何模式下都使用捆绑和压缩。
     //BundleTable.EnableOptimizations = true;
     
     //添加名称为“~/bundles/jquery”脚本捆绑
     bundles.Add(new ScriptBundle(&quot;~/bundles/jquery&quot;).Include(&quot;~/Scripts/jquery-{version}.js&quot;));
     //添加名称为“~/Content/css”样式捆绑
     bundles.Add(new StyleBundle(&quot;~/Content/css&quot;).Include(&quot;~/Content/Site.css&quot;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;{version}&lt;/code&gt;占位符可以在使用NuGet更新Jquery版本时，不需要更新Bundle的引用，自动使用最新的Jquery版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScriptBundle&lt;/code&gt;和&lt;code&gt;StyleBundle&lt;/code&gt;的&lt;code&gt;Include&lt;/code&gt;方法参数是一个字符串类型的数组，所以一个Bundle实例可以添加多个文件。&lt;/p&gt;
&lt;p&gt;如&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;bundles.Add(new StyleBundle(&quot;~/Content/css&quot;).Include(
    &quot;~/Content/themes/base/jquery.ui.core.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.resizable.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.selectable.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.accordion.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.autocomplete.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.button.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.dialog.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.slider.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.tabs.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.datepicker.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.progressbar.css&quot;,
    &quot;~/Content/themes/base/jquery.ui.theme.css&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是Bundle类也提供了&lt;code&gt;IncludeDirectory&lt;/code&gt;方法，可以添加指定目录下的指定文件。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//添加Content/themes/base目录下的所有css文件
bundles.Add(new StyleBundle(&quot;~/Content/css&quot;&quot;).IncludeDirectory(&quot;~/Content/themes/base&quot;, &quot;*.css&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用通配符要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用通配符添加资源时。这些资源文件是按照名称来排序的。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;启用bundle&quot;&gt;2. 启用Bundle&lt;/h3&gt;
&lt;p&gt;在Global.asax的Appliaction_Start方法中调用之前的定义的方法，&lt;code&gt;BundleConfig.RegisterBundles(BundleTable.Bundles)&lt;/code&gt;&lt;br/&gt;启用Bundle。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MvcApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        BundleConfig.RegisterBundles(BundleTable.Bundles);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;使用bundle&quot;&gt;3. 使用Bundle&lt;/h3&gt;
&lt;p&gt;如果我们需要在页面中使用这些资源时。可以通过Styles和Scripts来引入。如果要使用捆绑的Style，可以在页面中添加&lt;code&gt;@Styles.Render(&quot;~/Content/css&quot;)&lt;/code&gt;。如果要使用捆绑的Script，可以在页面中添加&lt;code&gt;@Script.Render(&quot;~/bundles/jquery&quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; http-equiv=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;utf-8&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;viewport&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;@ViewBag.Title - 我的 ASP.NET 应用程序&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    //引入样式捆绑
    @Styles.Render(&quot;~/Content/css&quot;)    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;container body-content&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        @RenderBody()
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;hr&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;footer&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;&amp;amp;copy;&lt;/span&gt; @DateTime.Now.Year - 我的 ASP.NET 应用程序&lt;span class=&quot;kw&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/footer&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    //引入js捆绑
    @Scripts.Render(&quot;~/bundles/jquery&quot;)
    @RenderSection(&quot;scripts&quot;, required: false)
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;可以把CSS样式文件置顶，JavaScript文件置底，来优化网页。但是&lt;code&gt;modernizr.js&lt;/code&gt;文件要放在页面顶部，因为有些样式文件需要。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;使用cdn&quot;&gt;使用CDN&lt;/h2&gt;
&lt;p&gt;Bundle对CDN也提供了很好的支持。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static void RegisterBundles(BundleCollection bundles)
{
    //bundles.Add(new ScriptBundle(&quot;~/bundles/jquery&quot;).Include(
    //            &quot;~/Scripts/jquery-{version}.js&quot;));

    bundles.UseCdn = true;   //启用cdn
    //添加地址
    var jqueryCdnPath = &quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.1.min.js&quot;;
    bundles.Add(new ScriptBundle(&quot;~/bundles/jquery&quot;,jqueryCdnPath).Include(&quot;~/Scripts/jquery-{version}.js&quot;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用CDN时，要应对没有获取到资源的情况。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
        @Scripts.Render(&quot;~/bundles/jquery&quot;)
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            if (typeof jQuery == 'undefined') {
                var e = document.createElement('script');
                e.src = '@Url.Content(&quot;~/Scripts/jquery-1.7.1.js&quot;)';
                e.type = 'text/javascript';
                document.getElementsByTagName(&quot;head&quot;)[0].appendChild(e);

            }
        &amp;lt;/script&amp;gt;   &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;bundle缓存&quot;&gt;Bundle缓存&lt;/h2&gt;
&lt;p&gt;浏览器是根据URL来缓存数据的。浏览器无论何时请求资源，都会根据URL来检查缓存里是否包含了该资源文件。如果包含了，浏览器就不会再去请求，而是使用缓存的文件，来渲染。&lt;/p&gt;
&lt;p&gt;Bundle机制使我们每次修改资源文件时都会在URL后自动添加一个哈希值,从而避免浏览器缓存，不能及时更新资源的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/691772/201711/691772-20171128165339097-121190337.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;v=******，后面的值就是哈希值。&lt;code&gt;Bundle&lt;/code&gt; 在Debug模式下默认是没有开启的。在发布模式下才会开启。但是我们可以在BundleConfig下添加&lt;code&gt;BundleTable.EnableOptimizations = true;&lt;/code&gt;开启捆绑模式。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;bundle注意事项&quot;&gt;Bundle注意事项&lt;/h2&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个&lt;code&gt;Bundle&lt;/code&gt;一般包含多个文件，如果我们只是修改了其中的一个文件，那么&lt;code&gt;Bundle&lt;/code&gt;的哈希值也会改变，就会更新&lt;code&gt;Bundle&lt;/code&gt;的所有文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;捆绑和缩小主要降低了第一次访问页面时加载的时间。此时静态资源就会被缓存起来（js,css，图片）。当访问其他页面，且该页面的资源地址和第一次访问的地址相同时，就会从缓存里获取，不再向服务端获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果资源过多，使用CDN，比使用&lt;code&gt;Bundle&lt;/code&gt;更有效。当然&lt;code&gt;Bundle&lt;/code&gt;也可以结合CDN使用。 通过使用CDN，可以减轻每个主机名8个并发连接的浏览器限制。因为CDN的主机名与您的主机站点不同，CDN上的资产请求不会与您的主机环境的8个并发连接数计数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Bundle&lt;/code&gt;最好按照功能来区分捆绑。例如，默认的ASP.Net应用程序的NET MVC模板创建了一个与jQuery分离的jQuery验证包。因为所创建的默认视图输入输出值，所以它们需要验证包。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;如有不对，请多多指教。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
</description>
<pubDate>Tue, 28 Nov 2017 08:57:00 +0000</pubDate>
<dc:creator>JoeSnail</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JoeSnail/p/7910875.html</dc:identifier>
</item>
</channel>
</rss>