<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何优雅地使用 rm 防止误删除？ - hoxis</title>
<link>http://www.cnblogs.com/hoxis/p/9737239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoxis/p/9737239.html</guid>
<description>&lt;p&gt;IT 界的有一个老梗，一次某论坛的数据库管理员抱怨自己老板一直虐待他，结果他一气之下就删库跑路了......&lt;/p&gt;
&lt;p&gt;于是...&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;据新华社北京 8 月 20 日电 ，北京一软件工程师徐某离职后因公司未能如期结清工资，便利用其在所设计的网站中安插的后门文件将网站源代码全部删除。记者 20 日从北京市丰台区人民法院获悉，徐某破坏计算机信息系统罪成立，获刑五年。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68057-848322b3651e1ddd.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;压力不大&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在服务器维护的时候不小心执行了 &lt;code&gt;rm -rf&lt;/code&gt; 命令......现在整台服务器被我删光了肿么办？？？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68057-77f6e09faa7c4dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;所以程序员喜欢跑步锻炼&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好吧，现在先来介绍一下 &lt;code&gt;rm&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rm&lt;/code&gt; 是 linux 系统下删除文件的命令，&lt;code&gt;-r&lt;/code&gt; 代表删除这个下面的一切，一切的一切那种的一切。&lt;code&gt;f&lt;/code&gt; 表示不需要用户确认，直接执行。&lt;/p&gt;
&lt;p&gt;通常这个命令都是指定文件夹用的，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm -rf /home/test/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是删除 /home/test/ 这个文件夹下面的所有东西。&lt;/p&gt;
&lt;p&gt;但是如果后面的文件夹路径没有加对，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rm -rf /&lt;/code&gt; 在服务器上也就意味着...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68057-292b09ce166fd564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;解脱了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;俗话说的好：常在河边走， 哪能不湿鞋。 那该怎么避免这种悲剧的发生呢？&lt;/p&gt;

&lt;p&gt;一个方案就是重定向 &lt;code&gt;rm&lt;/code&gt; 命令以嫁接为 &lt;code&gt;mv&lt;/code&gt; 命令， 相当于给 Linux 系统定制了一个回收站。&lt;/p&gt;
&lt;p&gt;实现方式如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;### 重定义rm命令 ###

# 定义回收站目录
trash_path='~/.trash'

# 判断 $trash_path 定义的文件是否存在，如果不存在，那么就创建 $trash_path.
if [ ! -d $trash_path ]; then
    mkdir -p $trash_path
fi

# 定义别名：使用 rm 就调用 trash
alias rm=trash

# 使用 rl 就调用 'ls ~/.trash' 
# 如果更改上面的回收站目录这里的目录也需要修改
alias rl='ls ~/.trash'

# 使用 unrm 就调用 restorefile，需要在删除目录的父目录下执行
alias unrm=restorefile

# 使用 rmtrash 就调用 claearteash
alias rmtrash=cleartrash

# 恢复文件的函数
restorefile()
{
    mv -i ~/.trash/$@  ./
}
 
# 删除文件的函数
trash()
{  
    mv $@  ~/.trash/
}
 
# 清空回收站的函数
cleartrash()
{
    read -p &quot;确定要清空回收站吗?[y/n]&quot; confirm
    [ $confirm == 'y' ] || [ $confirm == 'Y' ]  &amp;amp;&amp;amp; /bin/rm -rf  ~/.trash/*
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后将上述脚本写入 &lt;code&gt;/etc/bashrc&lt;/code&gt;，并立即执行命令 &lt;code&gt;source /etc/bashrc&lt;/code&gt; 即刻生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68057-19619b586a5905d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;大神果然厉害&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个脚本定义了几个命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;rl&lt;/code&gt;：查看回收站下的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unrm 文件名或目录&lt;/code&gt;：恢复到当前的路径下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rmtrash&lt;/code&gt;：清空回收站，不过会友好提示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行 rm 不会真正删除，而是使用 mv 移动到我们指定的回收站。&lt;/p&gt;
&lt;p&gt;实在真的想删除可以 &lt;code&gt;/bin/rm&lt;/code&gt; 来进行删除。&lt;/p&gt;
&lt;p&gt;另外，需要注意的时，之前 &lt;code&gt;rm&lt;/code&gt; 指令的一些参数可能不再使用，因为 &lt;code&gt;rm&lt;/code&gt; 现在其实是 &lt;code&gt;mv&lt;/code&gt; 了。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# touch hoxistest
# touch 1
# mkdir haha
# ls
1  haha  hoxistest
# rm 1
# ls
haha  hoxistest

# 查看回收站文件
# rl
1  myftp1

# 恢复已删除文件
# unrm 1
[root@CESHI-CLM-10-254-4-48 test]# ls
1  haha  hoxistest

# rm haha/
# rm hoxistest
# rl
haha  hoxistest

# 情况回收站
# rmtrash
确定要清空回收站吗?[y/n]y
# rl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果看着应该还可以吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/68057-f5ec7508647fccd7.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;很牛的样子&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看着是还可以，但是也有一些问题，比如删除文件不能重名，若重名了会提示你是否进行覆盖。那就需要再进行特殊处理了，比如删除时加个时间戳什么的，有兴趣的动手实现下吧。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;via：https://www.cloudbility.com/club/6981.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;如果觉得有用，欢迎关注我的微信，一起学习，共同进步，不定期推出赠书活动~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hoxis-image.oss-cn-hangzhou.aliyuncs.com/18-8-15/74882453.jpg&quot; alt=&quot;你的关注是对我最大的鼓励！&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最近搜集到慕课网视频，视频内容涵盖 Python、Java、PHP、前端、小程序、算法、架构、数据库等等！关注本公众号，后台回复「慕课网」即可获取下载地址。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 02 Oct 2018 07:40:00 +0000</pubDate>
<dc:creator>hoxis</dc:creator>
<og:description>IT 界的有一个老梗，一次某论坛的数据库管理员抱怨自己老板一直虐待他，结果他一气之下就删库跑路了......</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoxis/p/9737239.html</dc:identifier>
</item>
<item>
<title>每日质量NPM包事件绑定_bindme(详解React的this) - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9737234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9737234.html</guid>
<description>&lt;h3&gt;一、bindme&lt;/h3&gt;
&lt;p&gt;官方定义: &lt;strong&gt;is a helper to bind a list of methods to an object reference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解: 因为&lt;strong&gt;不推荐在render()里构建函数&lt;/strong&gt;,作者就用了6行代码封装了函数绑定事件的代码.&lt;br/&gt;bindme的npm包实际上由6行ES5代码组成,但是确实方便了很多.这个包值得一用&lt;/p&gt;
&lt;h3&gt;二、用法&lt;/h3&gt;
&lt;h4&gt;代替箭头函数和多层bind&lt;/h4&gt;
&lt;p&gt;有时候我们并不会直接在创建事件的时候&lt;code&gt;bind&lt;/code&gt;,而是统一在constructor上绑定事件,如果一个模块大起来,就会出现好几十行绑定事件的代码,用&lt;code&gt;bindme&lt;/code&gt;可以很好解决.例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//原写法
this.clickEvent1 = this.clickEvent1.bind(this)
this.clickEvent2 = this.clickEvent2.bind(this)
this.clickEvent3 = this.clickEvent3.bind(this)
this.clickEvent4 = this.clickEvent4.bind(this)
this.clickEvent5 = this.clickEvent5.bind(this)

//bindme写法
bindme(this, 'clickEvent1', 'clickEvent2', 'clickEvent3', 'clickEvent4', 'clickEvent5')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又好看又方便&lt;/p&gt;
&lt;p&gt;也可以在&lt;code&gt;super&lt;/code&gt;构建实例的时候绑定&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bindme(super(props),
    'clickEvent1',
    'clickEvent2',
    'clickEvent3',
    'clickEvent4',
    'clickEvent5',
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这么简单的用法, 我们可以看看它的源码转换成ES6是怎么样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const bindme = (self, ...funcs) =&amp;gt; {
  funcs.forEach(func =&amp;gt; {
    if (self[func]) {
      self[func] = self[func].bind(self)
    } else {
      console.error(`Method ${func} is not defined`)
    }
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也就是收集所有的事件,再统一bind,如果不存在的抛出异常.我们在平时也会经常封装一些类似这些小的便捷操作&lt;/p&gt;
&lt;h3&gt;结合React&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import React,{ PureComponent } from 'react'

import bindme from 'bindme'
import './style.css'
export default class BindmeComp extends PureComponent{
    constructor(props){
        bindme(super(props),
            'bindmeOnMouseOver'
        )

        this.initClickMode = this.initClickMode.bind(this)
        
        bindme(this, 'bindmeFirClickMode', 'bindmeSecClickMode')
    }

    noThisClickMode(){
        console.log('未绑定this事件 =========&amp;gt;', this)
    }

    initClickMode(){
        console.log('普通bind事件 ===========&amp;gt;', this)
    }

    arrowClickMode = () =&amp;gt; {
        console.log('箭头函数bind事件 ===========&amp;gt;', this)
    }

    bindmeFirClickMode(){
        console.log('bindme事件1 ===========&amp;gt;', this)
    }

    bindmeSecClickMode(){
        console.log('bindme事件2 ===========&amp;gt;', this)
    }

    bindmeOnMouseOver(){
        console.log('bindme事件3 ===========&amp;gt;', this)
    }

    render(){
        return(
            &amp;lt;div&amp;gt;
                &amp;lt;div className=&quot;list&quot;&amp;gt;
                    &amp;lt;span&amp;gt;未绑定this事件&amp;lt;/span&amp;gt;
                    &amp;lt;button onClick={ this.noThisClickMode }&amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div className=&quot;list&quot;&amp;gt;
                    &amp;lt;span&amp;gt;普通bind事件&amp;lt;/span&amp;gt;
                    &amp;lt;button onClick={ this.initClickMode }&amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div className=&quot;list&quot;&amp;gt;
                    &amp;lt;span&amp;gt;箭头函数事件&amp;lt;/span&amp;gt;
                    &amp;lt;button onClick={ this.arrowClickMode}&amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div className=&quot;list&quot;&amp;gt;
                    &amp;lt;span&amp;gt;bindme&amp;lt;/span&amp;gt;
                    &amp;lt;button onClick={ this.bindmeFirClickMode }&amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div className=&quot;list&quot;&amp;gt;
                    &amp;lt;span&amp;gt;bindme2&amp;lt;/span&amp;gt;
                    &amp;lt;button onClick={ this.bindmeSecClickMode } &amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;

                &amp;lt;div className=&quot;list&quot;&amp;gt;
                    &amp;lt;span&amp;gt;bindme3&amp;lt;/span&amp;gt;
                    &amp;lt;button onMouseOver={ this.bindmeOnMouseOver } &amp;gt;滑过&amp;lt;/button&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181002151152656-431142478.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面基本覆盖了常用的事件绑定情况.我们看看都会输出什么?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181002151326789-2063352033.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,除了第一个this为undefined外,其他都是正常绑定在了组件上&lt;/p&gt;
&lt;h3&gt;扩展一下React的this&lt;/h3&gt;
&lt;p&gt;我们先从我们最熟悉js的&lt;code&gt;this&lt;/code&gt;说起;&lt;/p&gt;
&lt;p&gt;面试官经常会问,什么是this?this指向什么?&lt;br/&gt;一般来说:&lt;br/&gt;&lt;strong&gt;谁调用该&lt;code&gt;function&lt;/code&gt;,该函数的this就指向这个调用方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个特殊的情况,ES6的箭头函数,也是面试官特别喜欢的一个东西(但它确实好用),由于箭头函数不存在this,所以它的this是由上一层继承而来的.所以可以得出结论&lt;strong&gt;箭头函数的this始终指向构造时的对象,而不是使用时的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外箭头函数还有一些不同于普通函数的特性,比如: 不可以当作构造函数使用,即不可以&lt;code&gt;new&lt;/code&gt;. 不可以使用&lt;code&gt;arguments&lt;/code&gt;属性等等&lt;/p&gt;
&lt;p&gt;总结一句话就是:&lt;br/&gt;&lt;strong&gt;普通函数this是动态的,而箭头函数的this是静态的&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;我们细说一下React的this.&lt;/h4&gt;
&lt;p&gt;因为React组件是通过&lt;code&gt;class&lt;/code&gt;构造的,所以组件里的所有属性,所有方法都可以通过this来获取,例如我们经常使用的属性state.就可以通过&lt;code&gt;this.state.xxx&lt;/code&gt;获取&lt;/p&gt;
&lt;p&gt;所以我们只需要保证this永远指向该构造对象(组件)即可,所以我们一般不会通过function来创建函数(会使得this动态指向调用function的对象), 并且:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React组件类的方法没有默认绑定this到组件实例，需要手动绑定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以就衍生出了绑定this的方法;常用的有四种,我们一般会使用在constructor里面bind&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//优先级最高
constructor(props){
    super(props);
    
    this.handleEvent = this.handleEvent.bind(this)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种和直接在构建事件中绑定很像对吧?&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input onChange={this.handleEvent.bind(this)} /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理虽然是一样的,但是性能却差了一大截.为什么?&lt;/p&gt;
&lt;p&gt;我们知道只要&lt;code&gt;state&lt;/code&gt;值改变了,就会导致render重新渲染,如果直接在创建事件绑定,那每一次渲染的时候都需要重新绑定一次,会大大降低性能.相反,只要在构造的时候绑定,无论渲染多少次,绑定都还是一次&lt;/p&gt;
&lt;p&gt;此外还有比较常用的箭头函数绑定法和&lt;code&gt;::&lt;/code&gt;绑定法&lt;br/&gt;前面也介绍了箭头函数this的知识,所以在React出现也是蛮高的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;handleEvent = () =&amp;gt; {
    ...
}

&amp;lt;input onChange={this.handleEvent} /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;::&lt;/code&gt;虽然也可以绑定this,但是因为不能传参数,所以不经常使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;handleEvent = () =&amp;gt; {
    ...
}

&amp;lt;input onChange={::this.handleEvent} /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 02 Oct 2018 07:39:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、bindme 官方定义: is a helper to bind a list of methods to an object reference 理解: 因为不推荐在render()里构建函数,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9737234.html</dc:identifier>
</item>
<item>
<title>解决：Setting property 'source' to 'org.eclipse.jst.jee.server 的问题 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9737226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9737226.html</guid>
<description>&lt;p&gt;当你用Eclipse运行web项目的时候，你就会看到控制台出现：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　警告: [SetContextPropertiesRule]{Context} Setting property 'source' to 'org.eclipse.jst.jee.server:bos19' did not find a matching property.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样的字样，说的是server.xml的Service标签里的Engine标签里的Host标签里的Context标签配置了一个'source'属性，属性值是'org.eclipse.jst.jee.server:firstProject'&lt;/p&gt;
&lt;p&gt;但问题是Context标签是不支持source这个属性的，所以弹出了警告，所以大家也发现的是，尽管有警告，但是大部分人的程序是依然可以运行没有问题的，但少部分人的不能够运行。&lt;/p&gt;
&lt;p&gt;也许你已经在网上查到很多像这样的问题，而且也给出了解决办法，但是你照着解决的方法去做了，警告依然存在！&lt;/p&gt;

&lt;p&gt;那现在你就可以跟着我的步骤来做了：&lt;/p&gt;
&lt;p&gt;我先说一下网上别人所说的步骤，埋个伏笔&lt;/p&gt;
&lt;p&gt;1、双击Servers里的Tomcat v8.5 Server at localhost&lt;br/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201810/841693-20181002150323390-102122819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、然后弹出如下界面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201810/841693-20181002150454627-426155331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到没，在Server Options 选项里有个 Publish module contexts to separate XML files 的选项，到这里我们也一样把勾勾上，不过问题不是这样就一定解决了，我说过有的朋友这样做了，问题依然没有解决，把勾勾上以后记得保存，如果警告依然存在的朋友们跟着我继续往下看。&lt;/p&gt;
&lt;p&gt;3、&lt;br/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201810/841693-20181002150542861-1597211575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201810/841693-20181002152251409-1190189414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　大家仔细对比下你自己的和我图片上的，你会发现你默认的选项应该是&lt;strong&gt;Use workspace metadata&lt;/strong&gt;这个选项，只不过是笔者我改为了&lt;strong&gt;tomcat的安装路径&lt;/strong&gt;罢了，&lt;/p&gt;
&lt;p&gt;　　因为Use workspace的路径文件夹不方便后面的讲解中要找的文件，所以笔者使用第2个tomcat安装目录来操作，而&lt;strong&gt;Deploy path&lt;/strong&gt;：你如果没有改过的话，应该是叫wtpwebapps，所以此处读者根据自己的Deploy path的值进行下面的操作。&lt;/p&gt;
&lt;p&gt;　　好了准备工作差不多了，现在是重点来了，为什么好多人做了1.2步操作以后就好了而你自己的没好呢？&lt;/p&gt;
&lt;p&gt;　　原因是：在做1、2 步操作之前你们已经运行过程序，而运行以后程序就会在tomcat文件夹下多了一个backup文件夹&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201810/841693-20181002153208029-702065156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面的目录结构如图：&lt;br/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/841693/201810/841693-20181002153251454-1002849151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有没有很熟悉的感觉，没错这就是从tomcat目录里conf文件夹下拷贝过来的文件&lt;br/&gt;接下来直接说操作好了：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;4、删除掉刚才的backup文件夹[backup所在位置根据第3步所说的，因为笔者使用的时tomcat安装目录所以就在目录下就直接发现了，&lt;/p&gt;
&lt;p&gt;　　但如果你用的是&lt;strong&gt;Use workspace metadata&lt;/strong&gt;这个选项的话，你就在 &lt;strong&gt;D:\learn\Java\MyEclipse&lt;span&gt;\Workspaces\MyEclipse 2017 CI\.metadata\.plugins\org.eclipse.wst.server.core&lt;/span&gt; &lt;/strong&gt;路径下可以看到里面有很多的文件，&lt;/p&gt;
&lt;p&gt;　　Eclipse就把项目发布到了这里，里面的目录结构和tomcat里面的差不多，总之把 &lt;span&gt;&lt;strong&gt;\Workspace\.metadata\.plugins\org.eclipse.wst.server.core &lt;/strong&gt;&lt;/span&gt;里面的文件全删除掉，然后重启tomcat就可以了！！！&lt;/p&gt;
&lt;p&gt;5、找到tomcat目录里的conf目录里的Catalina目录里有个localhost文件夹，把文件夹里面的文件全删除掉。&lt;/p&gt;
&lt;p&gt;6、此处告诉大家3、4、5步骤纯属告诉你们Eclipse发布的一个细节，删除上面的文件其实不用那么麻烦：&lt;/p&gt;
&lt;p&gt;　　在Tomcat v8.5 Server at localhost里，首先 右键 --&amp;gt; 移除里面已经添加的所有工程，然后 右键 --&amp;gt; Clean清空项目虚拟目录里的文件，然后重新运行你们的程序就可以了。&lt;/p&gt;
&lt;p&gt;　　注意：如果有人想和我一样在第3步Server Locations里修改项目发布目录的话，只要发布过一次项目你会发现，Server Locations里面的选项是灰色的，不可以改，怎么办呢，这就需要你照着第6步里面的移除项目，清空文件，然后你就惊奇的发现，Server Locations可以修改了，OK，累了，我去，写了3个小时，希望能帮到你们解决你们的问题，See You！！！&lt;/p&gt;
&lt;p&gt;　　参考链接：&lt;a href=&quot;https://blog.csdn.net/z69183787/article/details/19911935&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/z69183787/article/details/19911935&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 02 Oct 2018 07:37:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>当你用Eclipse运行web项目的时候，你就会看到控制台出现： 警告: [SetContextPropertiesRule]{Context} Setting property 'sourc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9737226.html</dc:identifier>
</item>
<item>
<title>工作五年总结——以及两年前曾提出问题的回答 - 受戒人</title>
<link>http://www.cnblogs.com/qixingduanyan/p/9737139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixingduanyan/p/9737139.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好久没来博客园了，上次来博客园还是写这篇帖子：&lt;/p&gt;
&lt;h4 class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qixingduanyan/p/6248095.html&quot; target=&quot;_blank&quot;&gt;《年终总结》工作三年多，来来回回，跌跌撞撞，总结批评一下自己这三年半。&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;那还是两年前，当时工作经验三年，处于人生迷茫期，人生有过多次抉择，到如今，工作五年，距离当时已然两载。&lt;/p&gt;
&lt;p&gt;如今再度翻开之前博客，体味到当时那懵懂、冲动、浮躁和迷茫的自己，心里不由有感而发。&lt;/p&gt;
&lt;p&gt;两年前最后的询问是，路在何方？&lt;/p&gt;
&lt;p&gt;这件事，在两年后的今天，或许我能稍微解答。&lt;/p&gt;
&lt;p&gt;先来说说最近这两年近况。&lt;/p&gt;

&lt;p&gt;现如今是程序员，前端、移动端工程师，技术栈IONIC2、React、React Native。&lt;br/&gt;对Node感兴趣，私下里面自学一点儿nodejs。&lt;/p&gt;

&lt;p&gt;当时我处于懵懂的状态，从发表文章的时候17年初，到17年3月份，我当时的状态并未有多大的提升。&lt;br/&gt;还是懵懂和迷茫居多，当时写完文章或许要下定决心搞点什么，但却在两三个月间一直拖拖拉拉，并没有太大的改观。&lt;br/&gt;所以，到了17年3月中旬的时候，我突然就意识到，我不能一直都以这种状态度日，身为技术人，最关心的应该是提升。不管是经济上的提升还是技术上的提升，都需要如此。&lt;/p&gt;
&lt;p&gt;纷乱的技术已经在16年过了一个遍，我当时公司的环境也并不好，周围的人都很浮躁，因为老板就很浮躁，最后移动端技术也束之高阁，我却突然松了一口气。&lt;br/&gt;搞技术虽然要走马观花，但却有时候也需要直见本质，当时公司的环境已经阻碍了我的人生发展，再待下去心态会出问题，信心也可能会受到影响。&lt;br/&gt;当时公司有人工作5年以上，在一个水平很一般的公司工作如此长的时间，他已经很怕接触外面的公司了，也不敢寻找新的工作机会，这件事让我感触很深，我联想到当时的迷茫状态，感觉在这样的公司继续下去也可能最终浑浑噩噩，遂决定离职。&lt;/p&gt;

&lt;p&gt;提出离职到办理完离职手续，已经是5月份，在离职期间，我确定了下家，也就是我现在呆的公司。&lt;br/&gt;当时面试的时候和公司技术官聊的问题涉及的技术问题并不太多，更多的是从我自身出发，我陈述了我想要的东西：&lt;br/&gt;1、技术能力的提升=====前端技术栈&lt;br/&gt;2、技术在公司不边缘化=====不是可有可无&lt;br/&gt;3、最好是公司核心产品=====产品受公司重视&lt;/p&gt;
&lt;p&gt;技术官确保以上条件都满足，并且热情地邀请我来公司。我几乎是没做过多思考，当天就应下这份工作，等到离职手续办完，第二个周一，我就来公司上班。&lt;br/&gt;然后我才明白，为什么公司对我说的技术要求都满足。因为有下面两点。&lt;br/&gt;1、公司规划的核心产品要完全重做，有第一版，但要废弃，新技术开始第二版。&lt;br/&gt;2、当前公司移动端做此技术的只有我一个。我将会从产品的从无到有，全流程开发参与。&lt;/p&gt;
&lt;p&gt;这份工作是一个坑还是一个提升的机会呢？我初次知道的时候，是懵逼的，一时间翻转不过来思想和逻辑。&lt;br/&gt;因为曾经一直作为小弟，在某技术带头人的领导和指导下去研究去开发，或者是在成熟产品基础上写代码。完全从零开始负责一个项目，对我来说是个极大的挑战。&lt;br/&gt;怎么突然间就要从小弟晋升到大佬？&lt;/p&gt;
&lt;p&gt;所以，当时的决定就是，我要去找个新的工作，或者逼自己一把，将公司的产品接起来？&lt;/p&gt;

&lt;p&gt;我的决定是接起来！&lt;/p&gt;
&lt;p&gt;第一，我已经工作三年，虽然研究过angularjs，并且从零开始做过移动端项目，但是却也离不开领导的指点和指导，所以并不算真正的把控到产品的每个角落。不过已经有了一些技术的积累。这次从零开始，完全是对自己更高层次的考验。&lt;br/&gt;第二，移动端技术日新月异，新的技术对我有着极大的吸引，那就是在IONIC2和React上进行选型。&lt;/p&gt;
&lt;p&gt;当时并未想要利用RN来做，因为还有一种想要基于全平台都可用的想法，所以就是用Angular2或者React做，如果要打包成不同平台，则需要更改少许代码便可。&lt;/p&gt;
&lt;p&gt;公司当时的前端团队（web）端已经着手开始利用react进行网页开发，于是从公司技术栈的统一性考虑，我开始研究用react来写移动端项目。&lt;br/&gt;项目的web端初期进行的异常顺利，web端后台管理系统在任务管理的帮助下大家都完成的很快，但是移动端只有我在慢慢的从入门到开发，两个月的时间，只作出了很粗糙的部分功能页面。&lt;br/&gt;web端5人团队其实是从地方分公司来京支持，两个月时间完成后端管理系统的开发之后，便离开了京城。&lt;br/&gt;于是公司北京前端团队再度剩下我一个，由于web端其实来支持做的只是后台管理，那么用户端的功能其实一点儿也没做，而我又是做的用户端的移动App，所以他们的两个月，也只是让我对业务融会贯通而已。&lt;br/&gt;不过所幸，业务的清晰明了，让我不至于对产品做不下去，还是有许多的新的研究和实现要在接下来的研发工作中进行。&lt;/p&gt;

&lt;p&gt;项目忽然间着急了。&lt;br/&gt;作为创业公司，虽然公司有分公司，但是主分公司人加起来也是不到50人，公司也来京不久，项目要在10月份上线。&lt;br/&gt;时间紧，任务忽然就重了，我初接触react并且不是用RN来写移动端，中间每个项目的功能可能都要去调研一下各种组件的优劣，甚至有的功能组件实现不了，还需要自己在js端写组件自行实现。&lt;br/&gt;面对各式各样的需求自己重新开发新组件也大大的拖慢了开发节奏，按照我一个人这样的节奏来，在10月铁定是上不了线的。&lt;/p&gt;
&lt;p&gt;于是，执着于追寻前端技术统一性的建议得到了商讨，虽然说技术选型统一，以后再前端方面的工作可以给予很好的支持，人人可改Web或者移动端项目，但现在显然短期内很难做到。&lt;br/&gt;所以，为了快速的将产品做出，商讨之后，还利用我已经具备的IONIC知识进行产品的技术变更。&lt;/p&gt;
&lt;p&gt;IONIC1正是我给上个公司做App用的技术，因为从零开始过成熟些（卖得出去）的产品，所以对于技术变更也没太大的抵触，并且IONIC提供了各式各样的组件，可以简化我用react开发拼命寻找各种各样组件的流程（当时react移动端框架是用的还不成熟的antdesign-mobile，现在看依旧是有些不成熟，蚂蚁技术人似乎只是为了开发一个框架而开发，更多地关注还是在antdesignweb版）&lt;br/&gt;如果公司的技术是用的IONIC1，那么我来到公司紧锣密鼓的用已经熟练掌握的技术做产品，其实成长性还是不够的，那么就遇到了一个问题，用IONIC1还是IONIC2。&lt;br/&gt;也就是说，核心用Angularjs还是用Angular2.&lt;/p&gt;
&lt;p&gt;公司很快意识到我一个移动端研发工程师的捉襟见肘之难，于是从分公司请来另一位hybrid研发工程师，想要在8-10这短短的两个多月的时间将项目作出。&lt;br/&gt;新来的工程师初步接触hybrid开发的时候，便已经赶上了Angular2的打好年头，所以他的技术方向肯定是IONIC2和Angular2。&lt;br/&gt;于是我觉得技术提升的时候来了，遂和领导商定，要用IONIC2，这样还可以对Angular2做一番研究。&lt;/p&gt;
&lt;p&gt;其实IONIC项目已经尽量避免你去知道Angular，不过加上之前对angularjs的了解和对Angular2文档的浏览，让我觉得从IONIC1到IONIC2并不是一个错误的决定。&lt;br/&gt;并且我发现之前研究两个月的react其实和Angular2大同小异，更别说听小道消息Angular2正是Google看到了React的实现重写了Angular1，所以两者都是ES6语法，从js端来说，除了jsx之外，几乎是一套东西。&lt;/p&gt;
&lt;p&gt;如此我用2代技术开发也能很快进入到角色，更别说新来的帮手是一名IONIC2的研发工程师。&lt;br/&gt;我和帮手在一周的互相讨论和研究中，我将项目中所涉及到的业务点和可能是技术难点的地方和他做了深入的探讨。并且一周时间，他也将IONIC2技术大体的给我过了一遍，万事俱备，只欠开搞！&lt;/p&gt;
&lt;p&gt;开搞！&lt;br/&gt;项目异常的顺利，顺利到让人有些难以想象，IONIC2在开发效率上要比IONIC1有了一个质的提升，并且在性能上要较上一代IONIC1有了巨大的提升，虽然还比不上纯RN项目，但是在手机端和Pad端逐渐配置走高的时代，这些都不是问题。&lt;br/&gt;这个项目从零到有，从技术选型到技术变更，中间我都经历了一小段时间的阵痛期，但是阵痛期过去，便是坦途。&lt;br/&gt;由于业务吃透，技术确定，双方都十分熟悉，两个月的时间，项目也终于是成功上线，并且得到了不错的反馈。公司和项目组都是松了一口气，别的不说，我自己也感觉整体得到了提升，整个人感觉不一样了。&lt;/p&gt;
&lt;p&gt;支持的同事离开公司，项目后期的工作我来维护和开发，虽然再度移动端只剩下一人的情况下，但做维护来说也是游刃有余。更别说，项目还只是涉及到iPad端的实现，单项目维护对我来说不是问题，毕竟在上个公司就负责并且维护过一个手机端项目。&lt;br/&gt;起初，对于没有利用React来做项目或者用RN来做项目还会感觉有些遗憾，毕竟React概念大火特火，前端工程师不搞这个，貌似都不好意思说自己是前端。&lt;br/&gt;不过等到项目完成，加上两个月对于React的了解和作出一版粗糙产品涉及到的痛苦学习和实现流程，让我并没有感觉到太多失落。&lt;br/&gt;并且我也明白了一个私人认为技术人看待问题的一个该有的态度：&lt;br/&gt;技术并不重要，重要的是用技术去得到最优的实现。&lt;br/&gt;在当时情况下，毫无疑问，作出一个合格线以上的产品才是第一需求。&lt;/p&gt;

&lt;p&gt;其实前端技术说到底还是js，不管是React、Angular、TypeScript还是CoffeeScript亦或者VUE，其实都是js。&lt;br/&gt;在我理解下，为什么会有这些新兴的感觉和技术，就是因为前端的不确定性和开放性，以及大公司的竞争性。&lt;br/&gt;毫无疑问，当Angularjs刚出道的时候，Facebook不可能没红过眼，总不能总让Google抢占技术领域，自己也要发声才是，于是推出了react。&lt;br/&gt;有了ionic，于是FB又推出了RN，没办法，就是刚。&lt;br/&gt;从技术上我给予更优秀的实现来达到笼络技术人的目的。&lt;/p&gt;
&lt;p&gt;任何一种新技术的诞生和发展，都是因为有的人觉得现今的某种技术不酷，或者不欣赏，想要自己搞事情搞出来的。&lt;/p&gt;
&lt;p&gt;前端更是如此。&lt;/p&gt;
&lt;p&gt;所以，对于前端工程师来讲，最本质要掌握的还是老三样的发展，HTML、CSS、JS。其他的前端技术，其实都是在js的基础上老瓶装新旧而已，掌握了最根本的东西，不管技术如何变，始终都不会失去核心竞争力。&lt;/p&gt;
&lt;p&gt;从我职业生涯到这个项目完毕，我几乎是从桌面前端技术到移动端技术都接触了一遍。&lt;br/&gt;WinForm、WPF、jsp、React、Angular，私下里对比React和Angular的时候我还研究了一下Vue，还真有吾等宅男阅片一千便啥都一样的感觉。&lt;/p&gt;
&lt;p&gt;从离职到新公司的发展，是在我期待之内，更别说接下来的一年，也就是从去年十月到如今十月，公司除了维护项目之外，也有野心在手机端占领业务领域，我相继又是参与到了Web端业务前端的React项目和手机端RN为主导的手机端项目的开发之中。&lt;br/&gt;一年时间，已然是一个前端老鸟，虽然美感并不好，但是根据原型和产品设计做出来的东西也并不太差，React和RN也归纳成为了我技术栈的一部分，我私下里也在看一些Node相关的知识，为公司的项目写过几个nodejs的小工具，前端技术算是开花结果。&lt;br/&gt;前端技术，没有优劣，不管是JQuery时代还是如今的React时代，其实对于当时的技术发展来说，都是有推动作用，都有优秀的东西在其中。就算现如今JQuery看起来并不流行，但是我们在生活中还是时常用到。&lt;br/&gt;这些框架的设计给予了前端一种新的活力，大家更欣赏的还是日新月异的新型设计和实现所代表的思想变更，只有在前端思潮变更中，抓住前端变更的本质，并且保持对前端的热情和持续学习的能力，那么，你永远都不会过时。&lt;/p&gt;
&lt;p&gt;时至如今，再回到开头的话题。&lt;br/&gt;两年前路在何方，到如今也不用多说，道路自然已经确定，没有回避做技术的现实，没有做程序员死路一条的悲观观念，要有的，只是对自我的提升的一种追求。&lt;br/&gt;路在何方？提升自己，丰富人生，便是一条永远适用的康庄大道。&lt;/p&gt;

&lt;p&gt;那么这两年我明白了什么？&lt;br/&gt;新公司一年多，感触颇深，但是却没有了两年前的浮躁和不沉稳，也懂得活在当下，学在当下，并且计划在当下的重要，迷茫和彷徨或许是必经的职场之路的一个阶段，但是迷茫和彷徨之后，是为了让我们变得更好。&lt;br/&gt;如果你变得更差了？或许是迷茫之后的选择并不正确，或许你依旧停留在不思进取的氛围中，请逃避这样的自己，积极的面对新的改变，或许才能真正的找到人生的真谛。&lt;/p&gt;
&lt;p&gt;以上一家之言，是对两年前那篇文章的解读，如果能帮到您，感激不尽，如果有什么有失偏驳和欠妥的地方，还请指出，探讨交流您的看法。&lt;br/&gt;总之，放弃傲慢和偏见、摒弃浮躁和恍惚、坚定信念和追求，奋斗吧！&lt;/p&gt;
</description>
<pubDate>Tue, 02 Oct 2018 07:01:00 +0000</pubDate>
<dc:creator>受戒人</dc:creator>
<og:description>前言 好久没来博客园了，上次来博客园还是写这篇帖子： 《年终总结》工作三年多，来来回回，跌跌撞撞，总结批评一下自己这三年半。 那还是两年前，当时工作经验三年，处于人生迷茫期，人生有过多次抉择，到如今，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qixingduanyan/p/9737139.html</dc:identifier>
</item>
<item>
<title>urllib爬虫（流程+案例） - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/9733502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/9733502.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;网络爬虫是一种按照一定规则自动抓取万维网信息的程序。在如今网络发展，信息爆炸的时代，信息的处理变得尤为重要。而这之前就需要获取到数据。有关爬虫的概念可以到网上查看详细的说明，今天在这里介绍一下使用urllib进行网络爬虫的方法使用，在最后的一个案例中把最基本的爬虫要素运用进去，可以作为初学者的一个模板，读懂它进行适当修改就可以使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以我的经验来看，在编程上对于陌生的简单的东西，最快的学习方法就是从代码入手了。当然有些很厉害的兄弟，可以完全忽略我这篇博客了。下面的内容我尽量将注释写在代码当中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;final-path&quot;&gt;&lt;span&gt;　　下面是通过urllib的request函数来获取网页信息，现在的request库也很方便，不过原理都是一样的。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向指定的url地址发送请求并返回服务器响应的数据（文件的对象）&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; response = urllib.request.urlopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件的全部内容，会把读到的东西赋值给一个字符串变量&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; data =&lt;span&gt; response.read()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(data)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取得到的数据&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(type(data))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看数据类型&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取一行&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; data =&lt;span&gt; response.readline()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件的全部内容，赋值给一个列表变量，优先选择&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; data =&lt;span&gt; response.readlines()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(data)&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(type(data[100&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(type(data[100].decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转字符串&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(data))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将爬取到的网页写入文件&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/python_note/爬虫/file/file1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    f.write(data)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; response 属性&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前环境的有关信息&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.info())
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回状态码&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.getcode())
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 200为正常，304位为有缓存&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前正在爬取的url地址&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.geturl())
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.sogou.com/sgo?query=凯哥学堂&amp;amp;hdq=sogou-wsse-16bda725ae44af3b-0099&amp;amp;lxod=0_16_1_-1_0&amp;amp;lxea=2-1-D-9.0.0.2502-3-CN1307-0-0-2-E96F3D19F4C66A477CE71FD168DD223D-62&amp;amp;lxoq=kaigexuetang&amp;amp;lkx=0&amp;amp;ie=utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; url2 = r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https%3A//www.sogou.com/sgo%3Fquery%3D%E5%87%AF%E5%93%A5%E5%AD%A6%E5%A0%82%26hdq%3Dsogou-wsse-16bda725ae44af3b-0099%26lxod%3D0_16_1_-1_0%26lxea%3D2-1-D-9.0.0.2502-3-CN1307-0-0-2-E96F3D19F4C66A477CE71FD168DD223D-62%26lxoq%3Dkaigexuetang%26lkx%3D0%26ie%3Dutf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; newurl = urllib.request.quote(url)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将含汉字的编码&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(newurl)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; newurl2 = urllib.request.unquote(url2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解码&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(newurl2)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口号，http  80&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; https  443&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;将网页信息写入文件可以通过上面的读取然后再写入文件，还有更简便的方法，就是爬取页面的同时写入文件，这个也不难，只是一个函数而已。相信应该可以明白下面的内容，filename后面的内容就是需要存储网页信息的文件路径。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; urllib.request.urlretrieve(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                            filename=r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/python_note/爬虫/file/file2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; urlretrieve在执行过程中，会产生一些缓存&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 清除缓存&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; urllib.request.urlcleanup()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;我们都知道，进行爬虫的时候，很在乎它的效率，计算机进行获取数据当然会比手动来的快。但是这样一来，你就占用了该网站的大部分带宽，导致其他人上网会很卡。因此，很多网站会有自己的反爬机制，有些只是简单的预防一下。通过网络爬虫进行访问时会有一个爬虫的请求头，那么，可以模拟一下浏览器来访问，也就是把请求头中的信息换成浏览器信息。网上可以找到很多，随便粘贴一个就好了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;# 模拟请求头 （这是一种方法，下面使用另一种方法）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;headers = {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3493.3 Safari/537.36&quot;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;# 设置一个请求体
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;req = urllib.request.Request(url, headers=headers)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 发起请求
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;response = urllib.request.urlopen(req)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;data = response.read()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print(data)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; agentsList =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Opera/8.0 (Windows NT 5.1; U; en)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; agentStr =&lt;span&gt; random.choice(agentsList)  # 这里是从列表中随机取出一个浏览器信息来改写请求头，避免被网站发现同一个地址快速持续的访问它而被封掉
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; req = urllib.request.Request(url)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 里面添加头要写成键值对&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向请求体里添加了User-Agent&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; req.add_header(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, agentStr)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里添加时传入两个字符串，自动组合&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; response =&lt;span&gt; urllib.request.urlopen(req)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(response.read())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;当访问一直没有被响应时，我们需要让它继续往下进行而不是卡在那里。通过异常捕获来实现。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果网页长时间未响应，系统判断超时，无法爬取&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         response = urllib.request.urlopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, timeout=0.1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(response.read()))
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　当然有些网站还需要先登录之类的，也就是不仅仅从上面获取信息，还需要上传一些东西，下面介绍一下发送请求的两种方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;使用场景：进行客户端与服务端之间的消息传递时使用
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;GET: 通过url网址传递信息，可以直接在url网址上添加要传递的信息（不安全）
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;POST: 可以向服务器提交数据，是一种比较流行，安全的数据传递方式
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;PUT: 请求服务器存储一个资源，通常要指定存储的位置
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;DELETE: 请求服务器删除一个资源
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;HEAD: 请求获取对应的http报头信息
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;OPTIONS: 可以获取当前url所支持的请求类型
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;get请求：
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;特点：把数据拼接到请求路径后面传递给服务器
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;优点：速度快
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;缺点：承载的数据量小，不安全
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;post请求：
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;特点：把参数进行打包，单独传输
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;优点：数量大，安全（当对服务器数据进行修改时建议使用post）
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;缺点：速度慢
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; urllib.parse  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对请求打包的库&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将要发送的数据合成一个字典&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 字典的键去网址里找，一般为input标签的name属性的值&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaoxiao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对要发送的数据进行打包&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; postdata = urllib.parse.urlencode(data).encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 请求体&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; req = urllib.request.Request(url, data=&lt;span&gt;postdata)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 请求&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; response =&lt;span&gt; urllib.request.urlopen(req)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(response.data())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;概念：一种保存数据的格式
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;作用：可以保存本地的json文件，也可以将json串进行传输，通常将json称为轻量级的传输方式
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;xml可读性更强，但是有很多没有用的标签
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;json文件组成：
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{}       代表对象（字典）
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;[]       代表列表
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;:        代表键值对
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;,        分隔两个部分
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将json格式的字符串转换为Python数据类型的对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; jsonStr = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;name&quot;:&quot;xiaoxiao&quot;, &quot;age&quot;:18, &quot;hobby&quot;:[&quot;money&quot;, &quot;power&quot;, &quot;english&quot;], &quot;parames&quot;:{&quot;a&quot;:1, &quot;b&quot;:2}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; jsonData =&lt;span&gt; json.loads(jsonStr)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(jsonData)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(jsonData))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(jsonData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hobby&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; jsonData2 = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaoxiao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 18, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hobby&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;money&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;power&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;english&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parames&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 2&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; python类型的数据就是比json格式少个引号&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将Python数据类型的对象转换为json格式的字符串&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; jsonStr2 =&lt;span&gt; json.dumps(jsonData2)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(jsonStr2)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(type(jsonStr2))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;经常浏览一些网页会有这种情况，就是首先加载出一个页面的内容，向下滚动还有内容，在最下面会有一个提示下拉获取更多内容这类的东西。这个可以让加载网页的速度更快，毕竟内容少了嘛，再我们想要看到更多信息时候再加载。对于这样的一部分页面爬取其实也很简单，细心观察一下每次多加载一块的页面时，这时候上方的网址变化可以发现，有些是有数字变化的。可以根据里面的具体规律来修改每次请求的信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ssl
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ajaxCrawler(url):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     req = urllib.request.Request(url, headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用ssl创建未验证的上下文&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     context = ssl._create_unverified_context()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 访问的是HTTPS&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     response = urllib.request.urlopen(req, context=&lt;span&gt;context)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     jsonStr = response.read().decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(type(response.read()))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; byte型&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(type(response.read().decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; json字符串型&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     jsonData =&lt;span&gt; json.loads(jsonStr)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; jsonData
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; url = &quot;https://movie.douban.com/j/chart/top_list?type=17&amp;amp;interval_id=100%3A90&amp;amp;action=&amp;amp;start=0&amp;amp;limit=20&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; info = ajaxCrawler(url)&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(info)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 11&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://movie.douban.com/j/chart/top_list?type=17&amp;amp;interval_id=100%3A90&amp;amp;action=&amp;amp;start=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         str(i * 20) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;limit=20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     info =&lt;span&gt; ajaxCrawler(url)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(len(info))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; https://www.qiushibaike.com/text/page/2/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; jokeCrawler(url):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     req = urllib.request.Request(url, headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     response =&lt;span&gt; urllib.request.urlopen(req)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     html = response.read().decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(type(html))&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     pat = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div class=&quot;author clearfix&quot;&amp;gt;(.*?)&amp;lt;span class=&quot;stats-vote&quot;&amp;gt;&amp;lt;i class=&quot;number&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     re_joke = re.compile(pat, re.S)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; re.S 使可以匹配换行&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     divsList =&lt;span&gt; re_joke.findall(html)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(divsList)&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(len(divsList))&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     dic =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; div &lt;span&gt;in&lt;/span&gt;&lt;span&gt; divsList:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户名&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         re_u = re.compile(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;h2&amp;gt;(.*?)&amp;lt;/h2&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, re.S)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         username =&lt;span&gt; re_u.findall(div)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         username =&lt;span&gt; username[0].rstrip()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(username)&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 段子&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         re_d = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div class=&quot;content&quot;&amp;gt;\n&amp;lt;span&amp;gt;(.*?)&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.S)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         duanzi =&lt;span&gt; re_d.findall(div)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         duanzi =&lt;span&gt; duanzi[0].strip()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(type(duanzi))&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         dic[username] =&lt;span&gt; duanzi
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dic
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; with open(r&quot;F:/python_note/爬虫/file/file2.html&quot;, &quot;w&quot;) as f:&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     f.write(html)&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.qiushibaike.com/text/page/1/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; info =&lt;span&gt; jokeCrawler(url)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; info.items():
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(k + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + v)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 02 Oct 2018 06:23:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<og:description>网络爬虫是一种按照一定规则自动抓取万维网信息的程序。在如今网络发展，信息爆炸的时代，信息的处理变得尤为重要。而这之前就需要获取到数据。有关爬虫的概念可以到网上查看详细的说明，今天在这里介绍一下使用ur</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/9733502.html</dc:identifier>
</item>
<item>
<title>查找数组中重复的唯一元素+时间复杂度O（n）+空间复杂度O（1） - 偶人儿</title>
<link>http://www.cnblogs.com/ourener/p/9736935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ourener/p/9736935.html</guid>
<description>&lt;p&gt;这是我BIGO前端面试时，面试官给我出的一道题，题目是长度为N的数组，元素大小范围在[1，N-1]，只有一个重复的元素，用O（n）的时间复杂度和O（1）的空间复杂度找出来这个重复的元素，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大致思路&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;1、因为总共有N个数，每个数的范围是1到N-1，只有一个重复的数，所以这些数肯定是连续的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;          2、把对应的数放到与之对应的位置上去&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　   3、因为这些书不包含0，所以可以一直操作arr[0]，把arr[0]上的数字放到对应的位置上去，再把那个位置上的数字放到arr[0]上去&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　   4、如此循环操作，当arr[0]上的数字与对应位置上的数字相等时，就找到了重复的元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　   5、最坏的情况下循环N次一定能找出来重复的元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面是我整理后的JavaScript代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 var&lt;/span&gt; arr = [8,1,3,10,11,12,13,14,4,2,6,15,7,16,5,9,17,24,18,19,20,21,22,23,31,25,26,27,28,29,30,5&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count=0&lt;span&gt;;//用来统计循环的次数，可以去掉
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(1&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[0]==arr[arr[0&lt;span&gt;]])//判断第0位元素与该元素值指向的元素是否相等，如果相等了，就找到重复的了，退出循环
        {
            alert(arr[&lt;/span&gt;0&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[0]!=arr[arr[0&lt;span&gt;]]){ //如果不相等，就交换位置，把第0位置的元素送到与它对应的位置上去   
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp = arr[0&lt;span&gt;];
            arr[&lt;/span&gt;0]=arr[arr[0&lt;span&gt;]];
            arr[temp]&lt;/span&gt;=&lt;span&gt;temp;    
        }
        count&lt;/span&gt;++&lt;span&gt;;//循环一次，计数+1
 &lt;/span&gt;&lt;span&gt;    }console.log(count&lt;/span&gt;]);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 02 Oct 2018 06:20:00 +0000</pubDate>
<dc:creator>偶人儿</dc:creator>
<og:description>查找重复元素，时间复杂度O（n），空间复杂度O（1）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ourener/p/9736935.html</dc:identifier>
</item>
<item>
<title>【博客美化】评论带头像，且支持旋转 - 落花四月</title>
<link>http://www.cnblogs.com/lxz-1263030049/p/9736885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxz-1263030049/p/9736885.html</guid>
<description>&lt;h2 id=&quot;博客美化评论带头像且支持旋转&quot;&gt;【博客美化】评论带头像，且支持旋转&lt;/h2&gt;
&lt;p&gt;好久没有更新关于博客园页面美化的文章了，这一次主要是写一下关于&lt;strong&gt;评论带头像，且支持旋转&lt;/strong&gt;的内容，希望各位小伙伴能够喜欢！！！&lt;/p&gt;
&lt;h3 id=&quot;效果图&quot;&gt;1.效果图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/e1pUeQ9.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加css代码&quot;&gt;2.添加CSS代码&lt;/h3&gt;
&lt;p&gt;设置-页面定制CSS代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.feedbackCon img:hover {
-webkit-transform: rotateZ(360deg);
-moz-transform: rotateZ(360deg);
-ms-transform: rotateZ(360deg);
-o-transform: rotateZ(360deg);
transform: rotateZ(360deg);
}
 
.feedbackCon img {
border-radius: 40px;
-webkit-transition: all 0.6s ease-out;
-moz-transition: all 0.5s ease-out;
-ms-transition: all 0.5s ease-out;
-o-transition: all 0.5s ease-out;
transition: all 0.5s ease-out;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/KWytu36.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;上传javascript文件&quot;&gt;3.上传JavaScript文件&lt;/h3&gt;
&lt;p&gt;文件地址：&lt;a href=&quot;https://blog-static.cnblogs.com/files/jackson0714/Comments.js&quot; class=&quot;uri&quot;&gt;https://blog-static.cnblogs.com/files/jackson0714/Comments.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是参考农码一生的JavaScript脚本。&lt;/p&gt;
&lt;p&gt;** Comments.js**&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function customTimer(inpId, fn) {
if ($(inpId).length) {
fn();
}
else {
var intervalId = setInterval(function () {
if ($(inpId).length) {  //如果存在了
clearInterval(intervalId);  // 则关闭定时器
customTimer(inpId, fn);  //执行自身
}
}, 100);
}
}
//添加 评论区的 形象照
function addImage() {
var spen_html = &quot;&amp;lt;span class='bot' &amp;gt;&amp;lt;/span&amp;gt;\
 &amp;lt;span class='top'&amp;gt;&amp;lt;/span&amp;gt;&quot;;
$(&quot;.blog_comment_body&quot;).append(spen_html);

$(&quot;.blog_comment_body&quot;).before(&quot;&amp;lt;div class='body_right' style='float: left;'&amp;gt;&amp;lt;a target='_blank'&amp;gt;&amp;lt;img  /&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&quot;);
var feedbackCon = $(&quot;.feedbackCon&quot;).addClass(&quot;clearfix&quot;);
for (var i = 0; i &amp;lt; feedbackCon.length; i++) {
var span = $(feedbackCon[i]).find(&quot;span:last&quot;)[0].innerHTML || &quot;http://pic.cnitblog.com/face/sample_face.gif&quot;;
$(feedbackCon[i]).find(&quot;.body_right img&quot;).attr(&quot;src&quot;, span);
var href = $(feedbackCon[i]).parent().find(&quot;.comment_date&quot;).next().attr(&quot;href&quot;);
$(feedbackCon[i]).find(&quot;.body_right a&quot;).attr(&quot;href&quot;, href);

}
}

//页面加载完成是执行
$(function () {

 //添加 评论区的 形象照
customTimer(&quot;.blog_comment_body&quot;, addImage);

});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;引入javascript文件&quot;&gt;4.引入JavaScript文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/HijSrv9.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;页脚html代码&quot;&gt;5：页脚Html代码&lt;/h3&gt;
&lt;p&gt;引入第二步上传的JavaScript文件Comments.js：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://files.cnblogs.com/files/自己的博客名称/Comments.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：我的就是：&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/K9WX86G.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：总的来说还是比较简单的，希望能够帮助到各位小伙伴！！&lt;/p&gt;
</description>
<pubDate>Tue, 02 Oct 2018 05:41:00 +0000</pubDate>
<dc:creator>落花四月</dc:creator>
<og:description>【博客美化】评论带头像，且支持旋转 好久没有更新关于博客园页面美化的文章了，这一次主要是写一下关于 评论带头像，且支持旋转 的内容，希望各位小伙伴能够喜欢！！！ 1.效果图 2.添加CSS代码 设置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxz-1263030049/p/9736885.html</dc:identifier>
</item>
<item>
<title>kyo酱的博客--回溯法 - kyo酱</title>
<link>http://www.cnblogs.com/jiangnan-0817/p/9736880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangnan-0817/p/9736880.html</guid>
<description>&lt;p&gt;欢迎阅读kyo酱的博客！&lt;/p&gt;
&lt;p&gt;emmm欢迎所有的认识的，不认识的大家来阅读我的博客！其实在这篇博客之前写过好几篇解leetcode的博客，无奈功力不够深厚，代码写得不好都没有什么人看。。。&lt;/p&gt;
&lt;p&gt;于是不知是从什么时候开始，我就在想，怎么才能写一些有内容，有参考价值的博客呢，至少发给男盆友他也不至于一眼不看，能好好读一读，当然要是能把某一页加入收藏那我就再感激不过！想了很久，我决定在成为网红之前，先不断积累自己，多读一读别人家的博客，多做一些题，所以决定做一个为大家推送好的博文的一个博客吧！没人看至少我自己需要的时候还能翻一翻[捂脸]之前写的那些代码，过一阵子自己都不想再打开看...对了，万一我要是红了很多人看我的博客呢是吧，所以我先把名字改的网红一点[黑脸]！&lt;/p&gt;

&lt;p&gt;一下根据Leet的题进行分类介绍一些比较经典的题与算法：&lt;/p&gt;
&lt;p&gt;这一篇先介绍回溯法！！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;回溯法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.回溯的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回溯法，说起来很简单就像这个名字一样，当路走不下去了，遇到墙了就回头。。但是用代码实现起来就真的是十分艰难呀！！！回头要怎么办？？要递归！！反正听到递归我是很绝望。。&lt;/p&gt;
&lt;p&gt;先找了一篇简单说一下回溯是什么意思的博客看了一下：&lt;a href=&quot;https://www.jianshu.com/p/acb3d9126a9d&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.jianshu.com/p/acb3d9126a9d&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面说的剪枝呀这些看不懂暂时都没什么，就看明白回溯是要干嘛的就可以了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.回溯的范式（模板）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板嘛。。为了凸显学术性就叫范式，其实大学阶段学到的，以及面试要用到的很多算法都是有通用模板的，你自己也可以回去翻一翻自己从前做过的算法题，写过的代码，就会惊奇的发现好多题之间是没有什么关系的但是写出来的代码的基本格式都是一样的，在同样的地方有着类似的循环与判断语句，就比如BST中查找节点与二分查找的代码就十分相似，其实原理上也是有关联的。&lt;/p&gt;
&lt;p&gt;有关回溯模板的具体实现见 &lt;a href=&quot;https://blog.csdn.net/jarvischu/article/details/16067319&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://blog.csdn.net/jarvischu/article/details/16067319&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客我觉得是写的很好呀，反正我是看了有了巨大升华，于是后来找了个小本本把里面的东西都抄了一遍。&lt;/p&gt;
&lt;p&gt;这篇博客将回溯分为递推和递归两类。其中递推通常是指可以根据数学公式进行推导，由前一个函数值推导下一个函数值的类型，这篇文章里面没有过多叙说，多的说的是递归形式的回溯并且给出了经典算法的例子如N皇后，背包问题一一可以与上面的模板进行比较，都看完一定会有很大收获！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.回溯的练习题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于回溯的习题，本篇博客里主要介绍的是Leetcode上点赞量很高，也很经典的习题。当然也可以搜索backtracking的标签，将看到所有关于回溯的练习题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b3b56045188251abe49f738&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://juejin.im/post/5b3b56045188251abe49f738&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇博客里面有六道我个人认为非常经典的习题和详细的解析，每一道后面都还有和例题差不多的，让各位读者自己去实现的几道习题。&lt;/p&gt;
&lt;p&gt;我也是从一道题没有做过开始慢慢把里面的几道题都做了出来！！！所以呀，慢慢来，不要伤心，不要迷茫。不一定要每天都做题，但是尽求每天都能有学到的一点东西吧，总会有一天自己回顾自己之前写的代码，你会发现自己原来可以这么强&lt;/p&gt;
&lt;p&gt;首先这篇博客里提及的几道题，个人觉得最简单，Acceptance最高的是&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;leetcode 17. 电话号码的字母组合&lt;/h3&gt;
&lt;p&gt; 所以建议最开始做回溯的题先从这一道开始&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;leetcode 46：组合问题(Permutations)&lt;/h3&gt;
&lt;p&gt;这道题和17的难度基本相同，唯一不太一样的就是每次都要循环但是已经包含的元素不可以再次包含，Permutations是一个系列的题，还有Permutations I，PermutationsII都是回溯系列的，难度逐渐递增&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-12&quot;&gt;leetcode 77. 组合&lt;/h3&gt;
&lt;p&gt;个人认为，和46难度一样两个里面做出一个另一个同理也能做出来，将46与77结合起来就是&lt;strong&gt;&lt;span&gt;78题，Subsets&lt;/span&gt;&lt;/strong&gt;要是巩固回溯基础的话这几道题可以都做一下&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-23&quot;&gt;leetcode 200. 岛屿的个数&lt;/h3&gt;
&lt;p&gt;这个题真的是太经典了！！！十分经典！！只要是学图的DFS之后基本都会涉及到的一道题，强烈建议做一下，这个题不止在leetcode上面有，poj上UVA上面都有！DFS入门必做&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-28&quot;&gt;leetcode 51. N皇后&lt;/h3&gt;
&lt;p&gt;这个问题自从上了大学，学了程序设计语言就会一直讲的题！就是回溯的判断条件写起来比较费事，照着模板写就能写出来~而且最近上人工智能课上又探讨了这个问题。。。这么经典的题，可能写一遍都不够了，需要背下来或者深深刻在脑子里吧&lt;/p&gt;

&lt;p&gt;以上就是有关回溯的本期内容~由于学业繁忙，新内容将不定期更新~祝大家国庆假期愉快！&lt;/p&gt;


&lt;p&gt;---恢复内容结束---&lt;/p&gt;
</description>
<pubDate>Tue, 02 Oct 2018 05:39:00 +0000</pubDate>
<dc:creator>kyo酱</dc:creator>
<og:description>欢迎阅读kyo酱的博客！ emmm欢迎所有的认识的，不认识的大家来阅读我的博客！其实在这篇博客之前写过好几篇解leetcode的博客，无奈功力不够深厚，代码写得不好都没有什么人看。。。 于是不知是从什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangnan-0817/p/9736880.html</dc:identifier>
</item>
<item>
<title>jqgrid 上移下移单元格 - zhengwei_cq</title>
<link>http://www.cnblogs.com/zhengwei-cq/p/9736844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengwei-cq/p/9736844.html</guid>
<description>&lt;p&gt;在表格中常常需要调整表格中数据的显示顺序，我用的是jqgrid,实现原理就是将表中的行数保存到数据库中，取数据时按行进行排序&lt;/p&gt;
&lt;p&gt;1、上移，下移按钮&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:void(0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operateWithOneRowById(up)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linkButton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;上移&amp;lt;/a&amp;gt;
 &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:void(0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operateWithOneRowById(down)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linkButton&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;下移&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、上移下移 功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function operateWithOneRowById(callback) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; selected = tableObj.jqGrid(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;getGridParam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;selrow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selected == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请用鼠标点击选择一行后再执行操作!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; callback(selected);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、这里的callback是up和down 函数的合并，那么我们再看看这两个函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function up(selected) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selected == &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                gridHelper.moveRow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tableObj);
            }
        }

        function down(selected) {
            gridHelper.moveRow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tableObj);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、在这个函数中，我们都调用了一个函数movRow() 让我们来看看这个函数，这个函数的原理就是把当前选中的行和我要移到至的行进行交换就行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动一行&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.moveRow =&lt;span&gt; function(moveMethod, grid) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grid) tableObj =&lt;span&gt; grid;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if(selRow)    id=selRow;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    else id = getSelRow();&lt;/span&gt;
        id = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getSelRow();
        tableObj.restoreRow(id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; targetId = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getTargetId(id, moveMethod)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetId == -&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp1 =&lt;span&gt; tableObj.getRowData(id);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp2 =&lt;span&gt; tableObj.getRowData(targetId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对调行号&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; tempRn =&lt;span&gt; temp1.rn;
        temp1.rn &lt;/span&gt;=&lt;span&gt; temp2.rn;
        temp2.rn &lt;/span&gt;=&lt;span&gt; tempRn;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对调数据&lt;/span&gt;
&lt;span&gt;        tableObj.setRowData(id, temp2);
        tableObj.setRowData(targetId, temp1);
        tableObj.setSelection(targetId);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、在4中调用了getTargetId（）方法，我们再来看看这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得上移时的上一行的id，或下移时的下一行的id&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.getTargetId =&lt;span&gt; function(selId, method, grid) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grid) tableObj =&lt;span&gt; grid;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ids =&lt;span&gt; tableObj.getDataIDs();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ids.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selId == ids[i] &amp;amp;&amp;amp; method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; ids[i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (selId == ids[i] &amp;amp;&amp;amp; method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == ids.length - &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; ids[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、增加数据库字段Sequence  我用的nhibernate 还要在配置文件中进行修改，增加一行&amp;lt;property name=&quot;Order&quot; column=&quot;Sequence&quot;&amp;gt;&amp;lt;/property&amp;gt;  实体类中增加字段 order，在保存表时保存表中的行号&lt;br/&gt;      保存数据说明：保存时是保存表中的所有数据，有已经在数据库中的数据，有没有存在数据库中的数据，根据IDj是否为0来判断的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UpdatePlan(PlanToReport plan, List&amp;lt;PlanPerson&amp;gt;&lt;span&gt; list)
        {
            NHibernate.ISession session &lt;/span&gt;=&lt;span&gt; NHibernateSessionManager.Instance.GetSession();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                PlanToReportService.UpdatePlan(plan);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.Count; i++&lt;span&gt;)
                {
                    PlanPerson item &lt;/span&gt;=&lt;span&gt; list[i];
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.ID != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        PlanPerson itemnew &lt;/span&gt;=&lt;span&gt; PlanToReportService.GetPlanPersonById(item.ID);
                        itemnew.JobName &lt;/span&gt;=&lt;span&gt; item.JobName;
                        itemnew.ApprovalResults &lt;/span&gt;=&lt;span&gt; item.ApprovalResults;
                        itemnew.Attachments &lt;/span&gt;=&lt;span&gt; item.Attachments;
                        itemnew.CountryCode &lt;/span&gt;=&lt;span&gt; item.CountryCode;
                        itemnew.CountryName &lt;/span&gt;=&lt;span&gt; item.CountryName;
                        itemnew.MissionType &lt;/span&gt;=&lt;span&gt; item.MissionType;
                        itemnew.Position &lt;/span&gt;=&lt;span&gt; item.Position;
                        itemnew.Remark &lt;/span&gt;=&lt;span&gt; item.Remark;
                        itemnew.StartDate &lt;/span&gt;=&lt;span&gt; item.StartDate;
                        itemnew.Status &lt;/span&gt;=&lt;span&gt; item.Status;
                        itemnew.Explain &lt;/span&gt;=&lt;span&gt; item.Explain;
                        itemnew.Order &lt;/span&gt;=&lt;span&gt; i;
                        PlanToReportService.AddNewPlanPerson(itemnew);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        item.PlanID &lt;/span&gt;=&lt;span&gt; plan.ID;
                        item.Order &lt;/span&gt;=&lt;span&gt; i;
                        PlanToReportService.AddNewPlanPerson(item);
                    }
                        
                }
                session.Transaction.Commit();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ep)
            {
                session.Transaction.Rollback();
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ep;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、取数据时根据 Order 字段进行排序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; List&amp;lt;PlanPersonShowInGrid&amp;gt; GetShowPersonInPlan(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; planID)
        {
            ISession session &lt;/span&gt;=&lt;span&gt; NHibernateSessionManager.Instance.GetSession();
            ICriteria criteria &lt;/span&gt;= session.CreateCriteria(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(PlanPersonShowInGrid));
            criteria.Add(Expression.Eq(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PlanID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, planID)).AddOrder(Order.Asc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            List&lt;/span&gt;&amp;lt;PlanPersonShowInGrid&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;PlanPersonShowInGrid&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                IList l &lt;/span&gt;=&lt;span&gt; criteria.List();
                list &lt;/span&gt;= PlanToReportDao.IListToList&amp;lt;PlanPersonShowInGrid&amp;gt;&lt;span&gt;(l);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; { }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      至此，表格中数据的上移下移就完成了。&lt;/p&gt;

</description>
<pubDate>Tue, 02 Oct 2018 05:16:00 +0000</pubDate>
<dc:creator>zhengwei_cq</dc:creator>
<og:description>在表格中常常需要调整表格中数据的显示顺序，我用的是jqgrid,实现原理就是将表中的行数保存到数据库中，取数据时按行进行排序 1、上移，下移按钮 2、上移下移 功能 3、这里的callback是up和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhengwei-cq/p/9736844.html</dc:identifier>
</item>
<item>
<title>rsync+inotify实现全网自动化数据备份-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9736650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9736650.html</guid>
<description>&lt;h2&gt;1.rsync简介&lt;/h2&gt;
&lt;p&gt;“rsync是linux系统下的数据镜像&lt;a href=&quot;https://baike.so.com/doc/2129230-2252791.html&quot; target=&quot;_blank&quot;&gt;备份&lt;/a&gt;工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步”&lt;/p&gt;
&lt;h2&gt;2.rsync&lt;span&gt;的功能和特点&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;可以实现服务器各种资源的备份（可以夸文件系统）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. linux-rsync&lt;span&gt;，&lt;/span&gt;&lt;span&gt;windows-cwrsync&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;可以做全量备份，也可以做增量备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;在做备份的时候，可以排除一些特定的文件不做备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;可以结合&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt;实现加密传输&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. rsync&lt;span&gt;支持工作在后台的模式（守护进程模式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. rsync&lt;span&gt;可以结合&lt;/span&gt;&lt;span&gt;inotify/sersync&lt;/span&gt;&lt;span&gt;实现自动实时备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. rsync&lt;span&gt;在传输文件的过程中可做限速&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.&lt;/span&gt;&lt;strong&gt;rsync&lt;span&gt;的工作模式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;命令行模式（&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;模式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似于&lt;/span&gt;cp&lt;span&gt;、&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;命令，实现备份文件的复制（备份）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;远程模式（远程&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;模式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用&lt;/span&gt;ssh&lt;span&gt;实现数据的远程传输，类似于&lt;/span&gt; &lt;span&gt;scp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;列表模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似于执行&lt;/span&gt;ls&lt;span&gt;命令，仅仅用于列出文件内容列表（不是做复制操作）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;后台模式（守护进程模式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rsync&lt;span&gt;是工作在后台的&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.rsync实现自动备份&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;rsync&lt;span&gt;实时自动备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合&lt;/span&gt;inotify/sersync&lt;/p&gt;
&lt;p&gt;inotify/sersync&lt;span&gt;：监控文件和目录中的文件是否发生更改（找出新文件）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rsync&lt;span&gt;：将找出的文件备份过去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rsync&lt;span&gt;的用法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;本地使用（&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;远程使用（&lt;/span&gt;&lt;span&gt;scp&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;守护进程（&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5.&lt;/span&gt;&lt;strong&gt;rsync&lt;/strong&gt;&lt;strong&gt;选项详解&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;选项
&lt;/span&gt;-&lt;span&gt;p：保持文件的权限属性不变
&lt;/span&gt;-&lt;span&gt;v：显示执行过程信息
&lt;/span&gt;-&lt;span&gt;r：目录做递归
&lt;/span&gt;-&lt;span&gt;a：归档(包含r)
&lt;/span&gt;-&lt;span&gt;z：压缩
&lt;/span&gt;-&lt;span&gt;l：仅仅传输软链接自身
&lt;/span&gt;-&lt;span&gt;L：传输软连接所指向的原始文件
&lt;/span&gt;-&lt;span&gt;b：在备份文件的时候，如果备份文件已经存在，会将目标位置下旧的文件重命名，然后生成新的备份
&lt;/span&gt;--suffix=&lt;span&gt;xxx        指定旧备份文件的后缀名
&lt;/span&gt;--backup-dir=&lt;span&gt;xxxx   指定将旧备份文件移动到哪个位置下
&lt;/span&gt;-&lt;span&gt;e：结合ssh实现加密传输
&lt;/span&gt;-e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ssh -p 22&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
组合：&lt;/span&gt;-avz
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.&lt;strong&gt;rsync&lt;span&gt;配置文件参数详解&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;模块：其实就是一个目录，这个模块用于保存客户端所传递过来的文件
    参数：
        pid file：指定rsync的pid文件的保存位置
        uid：指定运行rsync进程的用户id
        gid：指定运行rsync进程的用户组id
        port：指定rsync所监听的端口（默认端口873）
        path：指定模块所对应的目录的位置
        use chroot：指定将用户锁定在家目录中
        max connections：最大连接数（指定最多同时有多少个客户端在传输文件）
        log file：指定日志文件的位置
        log format：指定日志格式
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; file：指定rsync进程的锁文件的位置
        read only：指定模块是否为只读状态
        write only：指定模块是否为只写状态
        list：指定用用户是否可以查看模块所对应的路径下的文件列表
        exclude：指定排除不做传输的文件
        exclude &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;：通过读取一个文件，来获取不对哪些文件做传输
        auth users：指定用于连接这个模块所要使用的匿名用户名
        secrets file：指定保存虚拟用户和密码文件
        hosts allow：指定可以做文件传输的主机
        hosts deny：黑名单
        timeout：指定客户端的超时时间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.inotify简介&lt;/h2&gt;
&lt;p&gt;inotify&lt;span&gt;：&lt;/span&gt;查找发送了改变的文件或者新文件，可以持续检测一个目录中的文件是否发生更改。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件&lt;/span&gt;inotify-tools&lt;span&gt;有两个组件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;inotifywait&lt;span&gt;：检测一个目录下的文件所发生事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;inotifywatch&lt;span&gt;：统计所触发的事件的次数&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;8.&lt;/span&gt;&lt;strong&gt;inotifywait&lt;span&gt;的选项&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    -&lt;span&gt;r：递归目录
    &lt;/span&gt;-&lt;span&gt;q：仅仅打印监控的事件信息
    &lt;/span&gt;-m：一直处于监控状态[组合使用-&lt;span&gt;mqr]
    &lt;/span&gt;--&lt;span&gt;excludei：排除文件或目录（不区分大小写）
    &lt;/span&gt;--&lt;span&gt;exclude：排除文件或目录（区分大小写）
    &lt;/span&gt;--&lt;span&gt;format：指定输出格式
        &lt;/span&gt;%w：显示触发监控的事件的所在路径.[%w%&lt;span&gt;f组合使用就能得到文件名]
        &lt;/span&gt;%&lt;span&gt;f：显示触发监控的事件的文件名
        &lt;/span&gt;%&lt;span&gt;e：显示所触发的事件
        &lt;/span&gt;%&lt;span&gt;T：显示事件的触发时间
    &lt;/span&gt;--&lt;span&gt;timefmat：指定输出的时间的格式
    &lt;/span&gt;-e：指定要监控的事件
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9.inotify监控的事件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    access              file or directory contents were read
    modify              file or directory contents were written
    attrib              file or directory attributes changed
    close_write          file or directory closed, after being opened &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; writeable mode
    close_nowrite      file or directory closed, after being opened &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; read-&lt;span&gt;only mode
    close              file or directory closed, regardless of read&lt;/span&gt;/&lt;span&gt;write mode
    open              file or directory opened
    moved_to          file or directory moved to watched directory
    moved_from          file or directory moved &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; watched directory
    move              file or directory moved to or &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; watched directory
    create              file or directory created within watched directory
    delete              file or directory deleted within watched directory
    delete_self          file or directory was deleted
    unmount              file system containing file or directory unmounted&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;10.rsync+inotify全网自动化备份实战案例&lt;/h2&gt;
&lt;h3&gt;1.环境准备&lt;/h3&gt;
&lt;p&gt;centos7.5&lt;/p&gt;
&lt;p&gt;rsync服务端IP:172.20.10.7/28&lt;/p&gt;
&lt;p&gt;inotify服务端IP:172.20.10.8/28&lt;/p&gt;
&lt;h4&gt;2.关闭安全服务&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl stop firewalld 
[root@ken &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[root@ken &lt;/span&gt;~]# iptables -F
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 配置rsync服务端&lt;/h3&gt;
&lt;p&gt;创建共享目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[root@ken ~]# mkdir /ken
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建用于运行rsync进程的用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# useradd -r -s /sbin/nologin -u &lt;span&gt;333&lt;/span&gt; kenken
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改属主和数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# chown -R kenken.kenken /ken
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看rsync的文件，/etc/rsyncd.conf，此文件默认不存在，需要自己手工写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# rpm -&lt;span&gt;ql rsync 
&lt;/span&gt;/etc/&lt;span&gt;rsyncd.conf
&lt;/span&gt;/etc/sysconfig/&lt;span&gt;rsyncd
&lt;/span&gt;/usr/bin/&lt;span&gt;rsync
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建rsync配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/&lt;span&gt;rsyncd.conf 
pid file&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;lock&lt;/span&gt;/subsys/&lt;span&gt;pidfile
&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; file=/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;lock&lt;/span&gt;/subsys/&lt;span&gt;rsync
log file&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;rsync
uid&lt;/span&gt;=&lt;span&gt;333&lt;/span&gt;&lt;span&gt;
gid&lt;/span&gt;=&lt;span&gt;333&lt;/span&gt;&lt;span&gt;
timeout&lt;/span&gt;=&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
max connections&lt;/span&gt;=&lt;span&gt;199&lt;/span&gt;&lt;span&gt;
[ken]
path&lt;/span&gt;=/&lt;span&gt;ken
list&lt;/span&gt;=&lt;span&gt;yes
use chroot&lt;/span&gt;=&lt;span&gt;yes
read only&lt;/span&gt;=&lt;span&gt;no
auth users&lt;/span&gt;=&lt;span&gt;user1
secrets file&lt;/span&gt;=/etc/&lt;span&gt;rsyncd.pwd
hosts allow&lt;/span&gt;=&lt;span&gt;172.20&lt;/span&gt;.&lt;span&gt;10.8&lt;/span&gt;/&lt;span&gt;28&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建虚拟用户文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user1:123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;gt;/etc/rsyncd.pwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改权限为600&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# chmod &lt;span&gt;600&lt;/span&gt; /etc/rsyncd.pwd 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动rsync服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# rsync --&lt;span&gt;daemon
[root@ken &lt;/span&gt;~]# ss -tnl | grep &lt;span&gt;873&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;5&lt;/span&gt;            *:&lt;span&gt;873&lt;/span&gt;                      *:*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;5&lt;/span&gt;           :::&lt;span&gt;873&lt;/span&gt;                     :::*                  
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 4.配置inotify服务端&lt;/h3&gt;
&lt;p&gt; 下载inotify需要配置epel仓库,复制如下代码到你的yum配置文件里面即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[ken]
name&lt;/span&gt;=&lt;span&gt;ken
enabled&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
baseurl&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/epel/7Server/x86_64/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载inotify&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install rsync inotify-tools -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建需要备份数据的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# mkdir /kenken
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个保存rsync虚拟用户和密码的文件并更改权限为600&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;/etc/&lt;span&gt;rsync.pwd
[root@ken &lt;/span&gt;~]# chmod &lt;span&gt;600&lt;/span&gt; /etc/rsync.pwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 创建自动化监控备份脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# vim authbak.sh
#&lt;/span&gt;!/bin/&lt;span&gt;bash
prog&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inotifywait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
events&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create,delete,close_write&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
opt&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-mrq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/kenken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
remote_host&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.20.10.7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
anon_user&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
mod_name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
pwd_file&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/rsync.pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$prog $opt &lt;/span&gt;-e $events --format &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%w%f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $dir | &lt;span&gt;while&lt;/span&gt;&lt;span&gt; read line
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
     rsync &lt;/span&gt;-rz --delete $dir $anon_user@$remote_host::$mod_name --password-file=&lt;span&gt;$pwd_file
done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端运行脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# nohup bash authbak.sh &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.在客户端进行测试&lt;/h3&gt;
&lt;p&gt;客户端创建文件测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken kenken]# touch {&lt;span&gt;1&lt;/span&gt;..&lt;span&gt;10&lt;/span&gt;&lt;span&gt;}.txt
[root@ken kenken]# ls
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;.txt  1.txt  &lt;span&gt;2&lt;/span&gt;.txt  &lt;span&gt;3&lt;/span&gt;.txt  &lt;span&gt;4&lt;/span&gt;.txt  &lt;span&gt;5&lt;/span&gt;.txt  &lt;span&gt;6&lt;/span&gt;.txt  &lt;span&gt;7&lt;/span&gt;.txt  &lt;span&gt;8&lt;/span&gt;.txt  &lt;span&gt;9&lt;/span&gt;.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在rsync服务器端查看是否有相同文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@ken ken]# ls
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;.txt  &lt;span&gt;1&lt;/span&gt;.txt  &lt;span&gt;2&lt;/span&gt;.txt  &lt;span&gt;3&lt;/span&gt;.txt  &lt;span&gt;4&lt;/span&gt;.txt  &lt;span&gt;5&lt;/span&gt;.txt  &lt;span&gt;6&lt;/span&gt;.txt  &lt;span&gt;7&lt;/span&gt;.txt  &lt;span&gt;8&lt;/span&gt;.txt  &lt;span&gt;9&lt;/span&gt;.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;客户端删除文件测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken kenken]# rm -rf &lt;span&gt;1&lt;/span&gt;.txt &lt;span&gt;4&lt;/span&gt;.txt &lt;br/&gt;[root@ken kenken]# ls&lt;br/&gt;10.txt  2.txt  3.txt  5.txt  6.txt  7.txt  8.txt  9.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在rsync服务器端查看文件是否也已经被删除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@ken kenken]# ls
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;.txt  &lt;span&gt;2&lt;/span&gt;.txt  &lt;span&gt;3&lt;/span&gt;.txt  &lt;span&gt;5&lt;/span&gt;.txt  &lt;span&gt;6&lt;/span&gt;.txt  &lt;span&gt;7&lt;/span&gt;.txt  &lt;span&gt;8&lt;/span&gt;.txt  &lt;span&gt;9&lt;/span&gt;.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;至此我们已经可以实现全网自动化, 无差异化数据备份了。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Oct 2018 05:15:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>1.rsync简介 “rsync是linux系统下的数据镜像备份工具。使用快速增量备份工具Remote Sync可以远程同步，支持本地复制，或者与其他SSH、rsync主机同步” 2.rsync的功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9736650.html</dc:identifier>
</item>
</channel>
</rss>