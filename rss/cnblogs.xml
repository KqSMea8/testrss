<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>keepalived深度结合lvs_dr模式 - 陈浩然MC</title>
<link>http://www.cnblogs.com/irockcode/p/8411144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/irockcode/p/8411144.html</guid>
<description>&lt;p&gt;keepalived与dr模式结合&lt;/p&gt;
&lt;h3 id=&quot;keepalived介绍&quot;&gt;keepalived介绍&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;keepalived可提供vrrp以及health-check功能，可以只用它提供双机浮动的vip（vrrp虚拟路由功能），
这样可以简单实现一个双机热备高可用功能；
keepalived是以VRRP虚拟路由冗余协议为基础实现高可用的，
可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，
这个组里面有一个master和多个backup，
master上面有一个对外提供服务的vip
（该路由器所在局域网内其他机器的默认路由为该vip），
master会发组播，当backup收不到VRRP包时就认为master宕掉了，
这时就需要根据VRRP的优先级来选举一个backup当master。
这样的话就可以保证路由器的高可用了。
keepalived可提供vrrp以及health-check功能，可以只用它提供双机浮动的vip（vrrp虚拟路由功能），
这样可以简单实现一个双机热备高可用功能；
keepalived是以VRRP虚拟路由冗余协议为基础实现高可用的，
可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，
这个组里面有一个master和多个backup，
master上面有一个对外提供服务的vip
（该路由器所在局域网内其他机器的默认路由为该vip），
master会发组播，当backup收不到VRRP包时就认为master宕掉了，
这时就需要根据VRRP的优先级来选举一个backup当master。
这样的话就可以保证路由器的高可用了。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;keepalived实验&quot;&gt;keepalived实验&lt;/h3&gt;
&lt;h4 id=&quot;实验环境-4台虚拟机&quot;&gt;实验环境 4台虚拟机&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;dr1     192.168.1.135
dr2     192.168.1.106
rs1     192.168.1.190
rs2     192.168.1.187
VIP     192.168.1.180
为方便实验，建议关闭iptables，或者开通80端口

dr1和dr2安装ipvsadm和keepalived
yum install -y ipvsadm keepalived

real_server1和real_server2上安装nginx
开启80端口访问，区分两个real_server&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;实验操作&quot;&gt;实验操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;修改dr1的keepalived配置文件&quot;&gt;1.修改dr1的keepalived配置文件&lt;/h5&gt;
&lt;p&gt;vim /etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;! Configuration File for keepalived

global_defs {
   notification_email {    # 配置邮箱报警
     acassen@firewall.loc    # （如果要开启邮件报警，需要开启相应的sendmail服务）
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1    # 邮箱的服务器
   smtp_connect_timeout 30    # 邮箱连接设置
   router_id LVS_DEVEL    # 表示keepalived服务器的一个标识，是发邮件时显示在邮件主题中的信息
}

vrrp_instance VI_1 {    #定义一个vrrp组，组名唯一
    state MASTER        #定义改主机为keepalived的master主机
    interface eth0      #监控eth0号端口
    virtual_router_id 58   #虚拟路由id号为58，id号唯一，这个id决定了多播的MAC地址
    # （一组keepalived相同，多组不能相同）
    priority 150         #设置本节点的优先级，master的优先级 要比backup的优先级别高，数值要大
    # （一组中keepalived会检查此选项然后选举出一台服务器作为路由，配置vip）
    advert_int 1         #检查间隔，默认为1秒
    authentication {
        auth_type PASS    #认证方式，密码认证
        auth_pass 1111    #认证的密码，这个密码必须和backup上的一致
    }
    virtual_ipaddress {    #设置虚拟的ip， 这个ip是以后对外提供服务的ip。如果有多个VIP，继续换行填写.
        192.168.1.180
    }
}

virtual_server 192.168.1.180 80 {    #虚拟主机设置，ip同上。
    delay_loop 2                  #每隔2秒查询realserver状态
    lb_algo rr                    #lvs的调度算法
    lb_kind DR                    #lvs的集群模式
    nat_mask 255.255.255.0
    # persistence_timeout 50        #同一IP的连接50秒内被分配到同一台realserver
    # 测试的时候可以不用开
    protocol TCP                  #用TCP协议检查realserver状态

    real_server 192.168.1.187 80 {    #后端真实主机1
        weight 100                #每台机器的权重，0表示不给该机器转发请求，直到它恢复正常。
        TCP_CHECK {                #健康检查项目，以下
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
            connect_port  80
        }
    }

    real_server 192.168.1.190 80 {        #后端真实主机2
        weight 100                    #每台机器的权重，0表示不给该机器转发请求，直到它恢复正常。
        TCP_CHECK {                    #健康检查项目，以下
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
            connect_port  80
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;修改dr2上的keepalived配置文件&quot;&gt;2.修改dr2上的keepalived配置文件&lt;/h5&gt;
&lt;p&gt;vim /etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;只要修改dr1上的配置内容
backup主机的配置和master的基本一样，只有以下地方需要修改。
state BACKUP        #定义改主机为keepalived的backup主机，监控主master
priority 100         #设置本节点的优先级，数值要比master主机上的小&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置real_server的dr脚本同dr模式脚本&quot;&gt;3.配置real_server的dr脚本（同dr模式脚本）&lt;/h5&gt;
&lt;p&gt;vim /usr/local/sbin/lvs_dr.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
vip=192.168.1.180
ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up
/sbin/route add -host $vip lo:0
echo &quot;1&quot; &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_ignore
echo &quot;2&quot; &amp;gt;/proc/sys/net/ipv4/conf/lo/arp_announce
echo &quot;1&quot; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore
echo &quot;2&quot; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce
echo &quot;1&quot; &amp;gt; /proc/sys/net/ipv4/conf/eth0/arp_ignore
echo &quot;2&quot; &amp;gt; /proc/sys/net/ipv4/conf/eth0/arp_announce
echo &quot;1&quot; &amp;gt; /proc/sys/net/ipv4/conf/default/arp_ignore
echo &quot;2&quot; &amp;gt; /proc/sys/net/ipv4/conf/default/arp_announce&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动执行&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;将2台dr上的keepalived启动&quot;&gt;1.将2台dr上的keepalived启动&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;/etc/init.d/keepalived start&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;执行脚本&quot;&gt;2.执行脚本&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;sh /usr/local/sbin/lvs_dr.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;检查是否搭建成功&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;查看vip和ipvsadm&quot;&gt;查看VIP和ipvsadm&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;通过检查网卡信息看vip绑定在哪台机器的网卡上
ip addr

[root@localhost ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:46:c8:ae brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.106/24 brd 192.168.1.255 scope global eth0
    inet 192.168.1.180/32 scope global eth0
    inet6 fe80::20c:29ff:fe46:c8ae/64 scope link 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不要跟dr模式混乱，这里启动keepalived后不需要再执行dr模式下的lvs_dr.sh脚本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（注：如果发现rs没有轮询，注释掉keepalived.conf中persistence_timeout 50即可）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A：dr1存活（正常轮询）
[root@151 ~]# curl 192.168.1.180
rs2 nginx
[root@151 ~]# curl 192.168.1.180
rs1 nginx
[root@151 ~]# curl 192.168.1.180
rs2 nginx

此时vip在135上

[root@localhost ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:46:c8:ae brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.106/24 brd 192.168.1.255 scope global eth0
    inet 192.168.1.180/32 scope global eth0
    inet6 fe80::20c:29ff:fe46:c8ae/64 scope link 
       valid_lft forever preferred_lft forever

B：dr1挂掉

停掉dr1的keepalived，vip自动绑定到dr2，keepalived搭建完成
[root@localhost ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:5a:c3:48 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.135/24 brd 192.168.1.255 scope global eth1
    inet 192.168.1.180/32 scope global eth0
    inet6 fe80::20c:29ff:fe5a:c348/64 scope link 
       valid_lft forever preferred_lft forever


因为给192.168.1.106配置的priority优先级为150
而192.168.1.135的优先级是100
所以，当keepalived连接通信时（主从同时存在时），vip会在106上
而当106宕机时，vip会飘到135上
当重新启动106（启动106上的keepalived）等于重新做了keepalived主从
106因为优先级为150，所以又会重新获得vip&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;脑裂问题主从模式&quot;&gt;脑裂问题（主从模式）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;上述主从配置方式存在脑裂的可能，
即两个节点实际都处于正常工作状态，但是无法接收到彼此的组播通知，
这时两个节点均强行绑定虚拟IP，导致不可预料的后果。 &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这就是我刚刚实验中说不需要执行dr模式下的lvs_dr.sh脚本，因为执行脚本后，主从同时获得vip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;这时就需要设置仲裁，即每个节点必须判断自身的状态（应用服务状态及自身网络状态），
要实现这两点可使用自定义shell脚本实现，通过周期性地检查自身应用服务状态，
并不断ping网关（或其它可靠的参考IP）均可。
当自身服务异常、或无法ping通网关，
则认为自身出现故障，就应该移除掉虚拟IP(停止keepalived服务即可）。
主要借助keepalived提供的vrrp_script及track_script实现：
（实验中没有添加这个）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在keepalived的配置文件最前面加入以下代码，定义一个跟踪脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vrrp_script check_local { #定义一个名称为check_local的检查脚本    
    script &quot;/usr/local/keepalived/bin/check_local.sh&quot; #shell脚本的路径    
    interval 5  #运行间隔    
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再在vrrp_instance配置中加入以下代码使用上面定义的检测脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;track_script {    
  check_local    
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;我们在/usr/local/keepalived/bin/check_local.sh定义的检测规则可以是： 
（以上的路径及文件是自己定义的。）

a.自身web服务故障（超时，http返回状态不是200）

b.无法ping通网关

c.产生以上任何一个问题，均应该移除本机的虚拟IP(停止keepalived实例即可)

但这里有个小问题，如果本机或是网关偶尔出现一次故障，那么我们不能认为是服务故障。
更好的做法是如果连续N次检测本机服务不正常或连接N次无法ping通网关，
才认为是故障产生，才需要进行故障转移。
另一方面，如果脚本检测到故障产生，并停止掉了keepalived服务，
那么当故障恢复后，keepalived是无法自动恢复的。
我觉得利用独立的脚本以秒级的间隔检查自身服务及网关连接性，
再根据故障情况控制keepalived的运行或是停止。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里提供一个思路，具体脚本内容请大家根据自己的需要编写即可。&lt;/p&gt;
&lt;h6 id=&quot;脚本-usrlocalnginxcheck_nginx.sh内容&quot;&gt;脚本 /usr/local/nginx/check_nginx.sh&quot;内容：&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash    
if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]    
    then    
    /usr/local/nginx/sbin/nginx    
    sleep 5    
    if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]    
    then    
        killall keepalived    
    fi    
fi    &lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;vi-etckeepalivedkeepalived.conf&quot;&gt;vi /etc/keepalived/keepalived.conf&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;global_defs {    
   router_id nginx_backup    
}
#监控服务.NGINX mysql等

vrrp_script chk_nginx {    
    script &quot;/usr/local/nginx/check_nginx.sh&quot;    
    interval 2    
    weight 2    
}    
    
vrrp_instance VI_1 {    
    state BACKUP    
    interface eth0    
    virtual_router_id 51    
    priority 99    
    advert_int 1    
    authentication {    
        auth_type PASS    
        auth_pass 1111    
    }    
    virtual_ipaddress {    
 192.168.xx.xx    #VIP（虚拟ip）  
 192.168.xx.xx    #主服务器IP  
 192.168.xx.xx    #从服务器IP  
 }   
track_script {   
chk_nginx #检测脚本 上面配置的   
}  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;keepalived健康检查方式&quot;&gt;keepalived健康检查方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;keepalived对后端realserver的健康检查方式主要有以下几种

TCP_CHECK：工作在第4层，keepalived向后端服务器发起一个tcp连接请求，
如果后端服务器没有响应或超时，那么这个后端将从服务器池中移除。

HTTP_GET：工作在第5层，向指定的URL执行http请求，
将得到的结果用md5加密并与指定的md5值比较看是否匹配，不匹配则从服务器池中移除；
此外还可以指定http返回码来判断检测是否成功。
HTTP_GET可以指定多个URL用于检测，这个一台服务器有多个虚拟主机的情况下比较好用。

SSL_GET：跟上面的HTTP_GET相似，不同的只是用SSL连接

MISC_CHECK：用脚本来检测，脚本如果带有参数，
需将脚本和参数放入双引号内。脚本的返回值需为：

0）  检测成功

1）  检测失败，将从服务器池中移除

2－255）检测成功；如果有设置misc_dynamic，权重自动调整为 退出码-2，
如退出码为200，权重自动调整为198=200-2。

SMTP_CHECK：用来检测邮件服务的smtp的&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当把nginx与keepalived部署在同一台服务器上时&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;nginx做反向代理，keepalived做vip（重点还是nginx的反向代理）&lt;/p&gt;
&lt;h3 id=&quot;nginxkeepalived双主模式&quot;&gt;nginx+keepalived双主模式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;注意：
配置中的虚拟路由标识virtual_router_id在MASTER和BACKUP处配置不能一样（但在主从模式下配置是一样的）

1）master负载机上的keepalived配置：
（注意，这里是双主配置，MASTER-BACKUP和BACKUP-MASTER;
如果是多主，比如三主，
就是MATER-BACKUP-BACKUP、BACKUP-MASTER-BACKUP和BACKUP-BACKUP-MASTER）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;! Configuration File for keepalived  
  
global_defs {  
   notification_email {  
     acassen@firewall.loc  
     failover@firewall.loc  
     sysadmin@firewall.loc  
   }  
   notification_email_from Alexandre.Cassen@firewall.loc  
   smtp_server 192.168.200.1  
   smtp_connect_timeout 30  
   router_id LVS_DEVEL  
}  
  
vrrp_script chk_http_port {  
  
   script &quot;/usr/local/src/check_nginx_pid.sh&quot;  
  
   interval 2      #（检测脚本执行的间隔）  
  
   weight 2  
  
}  
  
vrrp_instance VI_1 {  
    state MASTER  
    interface eth0
    virtual_router_id 51  
    priority 100  
    advert_int 1  
    authentication {  
        auth_type PASS  
        auth_pass 1111  
    }  
    virtual_ipaddress {  
        192.168.96.138  
    }  
}  
  
vrrp_instance VI_2 {  
    state BACKUP  
    interface eth0
    virtual_router_id 52  
    priority 90  
    advert_int 1  
    authentication {  
        auth_type PASS  
        auth_pass 1111  
    }  
    virtual_ipaddress {  
        192.168.96.139
    }  
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;注意：
这里将VI_1设置为MASTER
VI_2设置为BACKUP

在另一台机器上
VI_1 BACKUP
VI_2 MASTER&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将nginx中配置的域名解析到这两个VIP地址上：(万网DNS解析配置)&lt;br/&gt;192.168.96.138 www.chenhaoran.com&lt;br/&gt;192.168.96.139 www.chenhaoran.com&lt;/p&gt;
&lt;p&gt;参考链接&lt;br/&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-10480699-id-5179873.html&quot; class=&quot;uri&quot;&gt;http://blog.chinaunix.net/uid-10480699-id-5179873.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qiandublog/article/details/52474450&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qiandublog/article/details/52474450&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.keepalived.org/doc/introduction.html&quot; class=&quot;uri&quot;&gt;http://www.keepalived.org/doc/introduction.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐阅读&lt;br/&gt;&lt;a href=&quot;http://www.361way.com/keepalived-health-check/5218.html&quot; class=&quot;uri&quot;&gt;http://www.361way.com/keepalived-health-check/5218.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/6248941.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/kevingrace/p/6248941.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;双主模式参考&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/6146031.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/kevingrace/p/6146031.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 15:02:00 +0000</pubDate>
<dc:creator>陈浩然MC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/irockcode/p/8411144.html</dc:identifier>
</item>
<item>
<title>Spring依赖注入 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/8411097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/8411097.html</guid>
<description>&lt;p&gt;&lt;span&gt;无论是基于注解的ApplicationContext（org.springframework.context.annotation.AnnotationConfigApplicationContext）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是基于XML的ApplicationContext（org.springframework.context.support.ClassPathXmlApplicationContext）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它们在启动过程中都会调用org.springframework.context.support.AbstractApplicationContext#refresh方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实例化Spring容器的核心方法是org.springframework.context.support.AbstractApplicationContext#refresh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个refresh方法中会获取BeanFactory，默认的BeanFactory是org.springframework.beans.factory.support.DefaultListableBeanFactory&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203203626984-1286995754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在AbstractApplicationContext#refresh()方法的最后会实例化容器中所有非懒加载的单例bean，它是通过调用getBean()方法来做的，下面从getBean()开始分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getBean方法是在AbstractBeanFactory中定义的，而所有的getBean方法最终都是调的doGetBean方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;AbstractBeanFactory#getBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、调用doGetBean方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;AbstractBeanFactory#doGetBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、检查singleton缓存中是否有这个bean，如果有直接返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、检查父级BeanFactory中是否有这个bean，如果有直接返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、检查这个BeanDefinition是否有依赖，如果有，则递归的获取这些依赖的bean（PS：通过getBean方法）直到没有依赖为止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、通过createBean方法创建bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;AbstractAutowireCapableBeanFactory#createBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如果设置了BeanPostProcessor，则返回一个代理对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、调用doCreateBean方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;AbstractAutowireCapableBeanFactory#doCreateBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个方法中调用了两个特别重要的方法createBeanInstance和populateBean，前者用于实例化Bean，后者用于初始化Bean实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203204334984-1026882873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203204341859-1664992891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203210518109-1593648520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如果指定了工厂方法的话，则用指定的工厂方法实例化Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果构造函数使用了自动装配的话，则使用autowireConstructor实例化Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、决定以使用带参数的构造方法实例化Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、使用默认的构造方法实例化Bean&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、autowire constructor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203213118234-1620507878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、用默认的构造方法实例化的时候涉及到实例化策略，默认的策略是使用cglib，还有一种是使用反射&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203212931218-2046996278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203213224625-1145154273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203214118734-441319458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203220602296-1562690765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一步所做的事情就是找到那些需要注入的属性和它所对应的实例，然后将它设置到相应的属性上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一点是属性的类型可能有多种，每一种的取值方式都不一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180203224359015-1935824541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 参考 &lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/hotdust/article/details/52613221&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/lisongjia123/article/details/52134396&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 14:48:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/8411097.html</dc:identifier>
</item>
<item>
<title>python并发编程之多进程（理论） - 人生不如戏</title>
<link>http://www.cnblogs.com/fu-yong/p/8411083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fu-yong/p/8411083.html</guid>
<description>&lt;h2&gt;一、什么是进程&lt;/h2&gt;
&lt;p&gt;进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。&lt;/p&gt;
&lt;h2&gt;二、进程与程序的区别&lt;/h2&gt;
&lt;p&gt;程序：仅仅是一堆代&lt;/p&gt;
&lt;p&gt;进程：是指打开程序运行的过程&lt;/p&gt;
&lt;h2&gt;三、并发与并行&lt;/h2&gt;
&lt;p&gt;并发与并行是指cpu运行多个程序的方式&lt;/p&gt;
&lt;p&gt;不管是并行与并发，在用户看起来都是‘同时’运行的，他们都只是一个任务而已，正在干活的是cpu，而一个cpu只能执行一个任务。&lt;/p&gt;
&lt;p&gt;并行就相当于有好多台设备，可以同时供好多人使用。&lt;/p&gt;
&lt;p&gt;而并发就相当于只有一台设备，供几个人轮流用，每个人用一会就换另一个人。&lt;/p&gt;
&lt;p&gt;所以只有多个cpu才能实现并行，而一个cpu只能实现实现并发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1299859/201802/1299859-20180203215453218-343170229.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：&lt;/p&gt;
&lt;p&gt;串行：执行完A，再执行B，再执行C&lt;/p&gt;
&lt;p&gt;并行：同时执行ABC&lt;/p&gt;
&lt;p&gt;并发：交替执行ABC&lt;/p&gt;
&lt;h2&gt;四、同步\异步&lt;/h2&gt;
&lt;p&gt;并发与并行是指cpu运行多个程序的方式，而同步和异步是指一个程序的执行过程&lt;/p&gt;
&lt;p&gt; 同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不会返回。&lt;/p&gt;
&lt;p&gt;            按照这个定义，其实大部分函数都是同步调用，但是一般而言，我们说同步和异步的时候，&lt;/p&gt;
&lt;p&gt;            特指哪些需要其他部件协作或者需要一定时间完成的任务&lt;/p&gt;
&lt;p&gt;异步：异步的概念和同步相对，当一个异步功能调用发出后，调用者不能立即得到结果&lt;/p&gt;
&lt;p&gt;当该异步功能完成后，通过状态。通知或回调来通知调用者。如果异步功能用状态来通知，那么&lt;/p&gt;
&lt;p&gt;调用者就需要每隔一定时间检查一次，效率就回很低，如果使用通知的方式，效率就回很高，&lt;/p&gt;
&lt;p&gt;因为异步功能几乎不需要做额外的操作，至于回调函数，其实和通知没太大区别。&lt;/p&gt;
&lt;h2&gt;五、阻塞\非阻塞&lt;/h2&gt;
&lt;p&gt;阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到IO操作）。&lt;/p&gt;
&lt;p&gt;　　　函数只有得到结果之后才会被阻塞的线程激活。&lt;/p&gt;
&lt;p&gt;非阻塞：非阻塞和阻塞的概念相对，指在不能立即得到结果之前也会立即返回，同时该函数不会阻塞当前线程&lt;/p&gt;

&lt;p&gt;小结：同步与异步针对的是函数\任务的调用方式：同步就是当一个进程发起一个函数调用的时候，一直等到函数\任务完成，&lt;/p&gt;
&lt;p&gt;而进程继续处于激活状态。而异步情况下是当一个进程发起一个函数|任务调用的时候，不会等函数返回，而继续往下执行，&lt;/p&gt;
&lt;p&gt;函数返回的时候通过状态、通知、时间等方式通知进程任务完成&lt;/p&gt;
&lt;p&gt;　　　而阻塞和非阻塞是针对进程或者线程，阻塞是当请求不能满足的时候就挂起，而非阻塞则不会阻塞当前的进程&lt;/p&gt;
&lt;h2&gt;六、进程的创建与终止（了解）&lt;/h2&gt;
&lt;p&gt;进程的创建：&lt;/p&gt;
&lt;p&gt;　　但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。&lt;/p&gt;
&lt;p&gt;　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程&lt;/p&gt;
&lt;p&gt;　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）&lt;/p&gt;
&lt;p&gt;　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）&lt;/p&gt;
&lt;p&gt;　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）&lt;/p&gt;
&lt;p&gt;　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）&lt;/p&gt;

&lt;p&gt;　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的：&lt;/p&gt;
&lt;p&gt;　　1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）&lt;/p&gt;
&lt;p&gt;　　2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。&lt;/p&gt;

&lt;p&gt;　　关于创建的子进程，UNIX和windows&lt;/p&gt;
&lt;p&gt;　　1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（&lt;strong&gt;多道技术要求物理层面实现进程之间内存的隔离&lt;/strong&gt;），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。&lt;/p&gt;
&lt;p&gt;　　2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。&lt;/p&gt;
&lt;p&gt;进程的终止：&lt;/p&gt;
&lt;p&gt;　　1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）&lt;/p&gt;
&lt;p&gt;　　2. 出错退出（自愿，python a.py中a.py不存在）&lt;/p&gt;
&lt;p&gt;　　3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try...except...）&lt;/p&gt;
&lt;p&gt;　　4. 被其他进程杀死（非自愿，如kill -9）&lt;/p&gt;
&lt;h2&gt;七、进程的层次结构&lt;/h2&gt;
&lt;p&gt;无论UNIX还是windows，进程只有一个父进程，不同的是：&lt;/p&gt;
&lt;p&gt;　　1. 在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。&lt;/p&gt;
&lt;p&gt;　　2. 在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（&lt;strong&gt;称为句柄&lt;/strong&gt;）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。&lt;/p&gt;
&lt;h2&gt;八、进程的状态&lt;/h2&gt;
&lt;p&gt;　其实在两种情况下会导致一个进程在逻辑上不能运行，&lt;/p&gt;
&lt;p&gt;　　1. 进程挂起是自身原因，遇到I/O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作&lt;/p&gt;
&lt;p&gt;　　2. 与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。&lt;/p&gt;
&lt;p&gt;　　因而一个进程由三种状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1299859/201802/1299859-20180203224341359-364060087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Sat, 03 Feb 2018 14:45:00 +0000</pubDate>
<dc:creator>人生不如戏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fu-yong/p/8411083.html</dc:identifier>
</item>
<item>
<title>DNS服务器解析域名的过程 - tele</title>
<link>http://www.cnblogs.com/tele-share/p/8411041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tele-share/p/8411041.html</guid>
<description>&lt;p&gt;最近在读许令波老师的《深入分析Java Web技术内幕》,算是对DNS服务器域名解析有个大体的理解,以下的内容来自个人对书中内容的整理&lt;/p&gt;
&lt;p&gt;1.什么是域名解析?&lt;/p&gt;
&lt;p&gt;当我们在浏览器的地址栏输入一个地址时,如www.xxxx.com,之后就可以跳转到对应的页面,但是为什么呢?要知道机器是只认识IP地址的,&lt;/p&gt;
&lt;p&gt;他并不理解我们输入的www这种格式是什么意思,这个时候时候就要用到域名解析了&lt;/p&gt;
&lt;p&gt;2.域名解析的步骤&lt;/p&gt;
&lt;p&gt;首先粗略的说,域名解析就是通过DNS把www.xxxx.com这种格式的域名解析成一个IP地址,之后通过IP地址找到对应的服务器,当然后面就是浏览器请求数据了,&lt;/p&gt;
&lt;p&gt;这不是咱们的关注点.接下来详细的讲解具体的解析过程&lt;/p&gt;
&lt;p&gt;①用户输入一个域名,浏览器去自己的缓存中寻找是否有对应的解析过的IP地址(这个缓存有大小和时间限制,),没有转入下一步&lt;/p&gt;
&lt;p&gt;②浏览器检查操作系统的缓存(有大小和时间限制)中是否有这个域名解析过的结果,在我们常说的host文件(c:/windows/system32/etc)中可以看到&lt;/p&gt;
&lt;p&gt;localhost被解析成127.0.0.1,这也是为什么你用tomcat部署web项目后,用浏览器访问总是要输入localhost,当然我更习惯直接输入&lt;/p&gt;
&lt;p&gt;127.0.0.1:端口/项目名/xxx这种,因为你的host文件有时会被恶意更改(拓展点说叫做域名劫持),这样你输入localhost就无法被解析了&lt;/p&gt;
&lt;p&gt;如果这一步还没有找到域名对应的IP,转入下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161886/201802/1161886-20180203220500593-366672417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③浏览器向LDNS发送请求,L代表local,所以LDNS也就是本地的域名解析器,同样的在自己的缓存里找,没找到向根域名服务器(Root Server)发送请求&lt;/p&gt;
&lt;p&gt;④根域名服务器返回给LDNS一个主域名服务器地址(gTLD Server),比如我们输入的含有.com的域名,那么返回的这个就是com的主域名服务器地址&lt;/p&gt;
&lt;p&gt;⑤接下来LDNS向gTLD Server发送请求,后者返回给前者此域名对应的Name Server域名服务器的地址&lt;/p&gt;
&lt;p&gt;⑥然后LDNS向Name Server发送请求,Name Server对此域名进行解析(查询域名与IP地址的映射表.一个IP地址可能对应多个域名)&lt;/p&gt;
&lt;p&gt;⑦NameServer返回解析结果给LDNS,LDNS将结果反馈给浏览器&lt;/p&gt;
&lt;p&gt;⑧浏览器通过此IP地址与默认的80端口与服务器建立连接,进行数据交互&lt;/p&gt;
&lt;p&gt;总结:可以看到在域名解析的过程中,LDNS处于一个中心节点的位置,对根服务器发送请求后获得数据再向主域名服务器发送数据.......&lt;/p&gt;
&lt;p&gt;贴下书中的图吧&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1161886/201802/1161886-20180203223249875-797485294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Feb 2018 14:34:00 +0000</pubDate>
<dc:creator>tele</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tele-share/p/8411041.html</dc:identifier>
</item>
<item>
<title>如何用Python爬虫实现百度图片自动下载？ - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8410903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8410903.html</guid>
<description>&lt;p&gt;Github：&lt;a href=&quot;https://github.com/nnngu/LearningNotes&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu/LearningNotes&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;制作爬虫的步骤&quot;&gt;制作爬虫的步骤&lt;/h2&gt;
&lt;p&gt;制作一个爬虫一般分以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分析需求&lt;/li&gt;
&lt;li&gt;分析网页源代码，配合开发者工具&lt;/li&gt;
&lt;li&gt;编写正则表达式或者XPath表达式&lt;/li&gt;
&lt;li&gt;正式编写 python 爬虫代码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;效果预览&quot;&gt;效果预览&lt;/h2&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517624440357.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存放图片的文件夹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517624588214.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;需求分析&quot;&gt;需求分析&lt;/h2&gt;
&lt;p&gt;我们的爬虫至少要实现两个功能：一是搜索图片，二是自动下载。&lt;/p&gt;
&lt;p&gt;搜索图片：最容易想到的是爬百度图片的结果，我们就上百度图片看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517624851741.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随便搜索几个关键字，可以看到已经搜索出来很多张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517625097976.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析网页&quot;&gt;分析网页&lt;/h2&gt;
&lt;p&gt;我们点击右键，查看源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517625636570.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开源代码之后，发现一堆源代码比较难找出我们想要的资源。&lt;/p&gt;
&lt;p&gt;这个时候，就要用开发者工具！我们回到上一页面，调出开发者工具，我们需要用的是左上角那个东西：(鼠标跟随)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517626066422.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择你想看源代码的地方，就可以发现，下面的代码区自动定位到了相应的位置。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517626276983.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517626329451.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们复制这个地址，然后到刚才的一堆源代码里搜索一下，发现了它的位置，但是这里我们又疑惑了，这个图片有这么多地址，到底用哪个呢？我们可以看到有thumbURL，middleURL，hoverURL，objURL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517626739154.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过分析可以知道，前面两个是缩小的版本，hoverURL 是鼠标移动过后显示的版本，objURL 应该是我们需要的，可以分别打开这几个网址看看，发现 objURL 的那个最大最清晰。&lt;/p&gt;
&lt;p&gt;找到了图片地址，接下来我们分析源代码。看看是不是所有的 objURL 都是图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517627100214.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现都是以.jpg格式结尾的图片。&lt;/p&gt;
&lt;h2 id=&quot;编写正则表达式&quot;&gt;编写正则表达式&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pic_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.findall(&lt;span class=&quot;st&quot;&gt;'&quot;objURL&quot;:&quot;(.*?)&quot;,'&lt;/span&gt;,html,re.S)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;编写爬虫代码&quot;&gt;编写爬虫代码&lt;/h2&gt;
&lt;p&gt;这里我们用了2个包，一个是正则，一个是 requests 包&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; requests&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复制百度图片搜索的链接，传入 requests ，然后把正则表达式写好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517627638515.jpg&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'https://image.baidu.com/search/index?tn=baiduimage&amp;amp;ie=utf-8&amp;amp;word=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%E&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;6%A0&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%97%&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;E5%B1%B1&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%E&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;6%9C%AA&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%E&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;6%9D%A5&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%E&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;5%A4%B4&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%E&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%83%&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;8F&amp;amp;ct=201326592&amp;amp;ic=0&amp;amp;lm=-1&amp;amp;width=&amp;amp;height=&amp;amp;v=index'&lt;/span&gt;

html &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(url).text
pic_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.findall(&lt;span class=&quot;st&quot;&gt;'&quot;objURL&quot;:&quot;(.*?)&quot;,'&lt;/span&gt;,html,re.S)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为有很多张图片，所以要循环，我们打印出结果来看看，然后用 requests 获取网址，由于有些图片可能存在网址打不开的情况，所以加了10秒超时控制。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pic_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.findall(&lt;span class=&quot;st&quot;&gt;'&quot;objURL&quot;:&quot;(.*?)&quot;,'&lt;/span&gt;,html,re.S)
i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; each &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; pic_url:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt; each
    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        pic&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(each, timeout&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; requests.exceptions.&lt;span class=&quot;pp&quot;&gt;ConnectionError&lt;/span&gt;:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'【错误】当前图片无法下载'&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;continue&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着就是把图片保存下来，我们事先建立好一个 images 目录，把图片都放进去，命名的时候，以数字命名。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;        &lt;span class=&quot;bu&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'../images/'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; keyword &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'_'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(i) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'.jpg'&lt;/span&gt;
        fp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;dir&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'wb'&lt;/span&gt;)
        fp.write(pic.content)
        fp.close()
        i &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;完整的代码&quot;&gt;完整的代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; requests


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; dowmloadPic(html, keyword):
    pic_url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.findall(&lt;span class=&quot;st&quot;&gt;'&quot;objURL&quot;:&quot;(.*?)&quot;,'&lt;/span&gt;, html, re.S)
    i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'找到关键词:'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; keyword &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'的图片，现在开始下载图片...'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; each &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; pic_url:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'正在下载第'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(i) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'张图片，图片地址:'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(each))
        &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
            pic &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(each, timeout&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; requests.exceptions.&lt;span class=&quot;pp&quot;&gt;ConnectionError&lt;/span&gt;:
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'【错误】当前图片无法下载'&lt;/span&gt;)
            &lt;span class=&quot;cf&quot;&gt;continue&lt;/span&gt;

        &lt;span class=&quot;bu&quot;&gt;dir&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'../images/'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; keyword &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'_'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(i) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'.jpg'&lt;/span&gt;
        fp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;dir&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'wb'&lt;/span&gt;)
        fp.write(pic.content)
        fp.close()
        i &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;


&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    word &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Input key word: &quot;&lt;/span&gt;)
    url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'http://image.baidu.com/search/flip?tn=baiduimage&amp;amp;ie=utf-8&amp;amp;word='&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; word &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'&amp;amp;ct=201326592&amp;amp;v=flip'&lt;/span&gt;
    result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(url)
    dowmloadPic(result.text, word)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517629256979.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517629346426.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到有的图片没显示出来，打开网址看，发现确实没了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/2/3/1517629377850.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为百度有些图片它缓存到百度的服务器上，所以我们在百度上还能看见它，但它的实际链接已经失效了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;enjoy 我们的第一个图片下载爬虫吧！当然它不仅能下载百度的图片，依葫芦画瓢，你现在应该能做很多事情了，比如爬取头像，爬淘宝展示图等等。&lt;/p&gt;
&lt;p&gt;完整代码已经放到Githut上 &lt;a href=&quot;https://github.com/nnngu/BaiduImageDownload&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu/BaiduImageDownload&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 14:03:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8410903.html</dc:identifier>
</item>
<item>
<title>小白的Python之路 day5 re正则表达式模块 - 钱多多的妖孽人生</title>
<link>http://www.cnblogs.com/ManyQian/p/8410826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/8410826.html</guid>
<description>&lt;h2&gt;一、概述　　&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;就其本质而言，正则表达式（或 RE）是一种小型的、高度专业化的编程语言，要讲他的具体用法要讲一本书！它内嵌在Python中，并通过 re 模块实现。你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、e-mail地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE 以各种方式来修改或分割字符串。今天就来讲讲re模块的最常用的用法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;二、常用的正在表达式符号&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div id=&quot;highlighter_845844&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;30&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;67&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'.'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'^'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;^a&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;\nabc\neee&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,flags&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;re.MULTILINE)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'$'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配字符结尾，或e.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;foo$&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;bfoo\nsdfsf&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,flags&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;re.MULTILINE).group()也可以&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'*'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;*&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;号前的字符&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;次或多次，re.findall(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;ab*&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;cabb3abcbbac&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)  结果为[&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'abb'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'ab'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'+'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配前一个字符&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;次或多次，re.findall(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;ab+&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;ab+cd+abb+bba&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;) 结果[&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'ab'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'abb'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'?'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配前一个字符&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;次或&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;次&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'{m}'&lt;/code&gt;   &lt;code class=&quot;python plain&quot;&gt;匹配前一个字符m次&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'{n,m}'&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;匹配前一个字符n到m次，re.findall(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;ab{1,3}&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;abb abc abbcbbb&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;) 结果&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'abb'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'ab'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'abb'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'|'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配|左或|右的字符，re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;abc|ABC&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;ABCBabcCD&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;).group() 结果&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'ABC'&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;line number10 index9 alt1&quot; readability=&quot;9&quot;&gt;&lt;code class=&quot;python string&quot;&gt;'(...)'&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;分组匹配 re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;(?P&amp;lt;province&amp;gt;\d{4})(?P&amp;lt;city&amp;gt;\d{2})(?P&amp;lt;birthday&amp;gt;\d{4})&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;320922199306143242&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;).groupdict(&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;)&lt;/code&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;结果:{&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'province'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;: &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'3209'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'city'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;: &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'22'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'birthday'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;: &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'1993'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;转义&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;[a&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;z]   匹配[a&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;z]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;[A&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;Z]   匹配[A&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;Z]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;[&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;]   匹配数字&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\A'&lt;/code&gt;    &lt;code class=&quot;python plain&quot;&gt;只从字符开头匹配，re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;\Aabc&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;alexabc&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;) 是匹配不到的&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\Z'&lt;/code&gt;    &lt;code class=&quot;python plain&quot;&gt;匹配字符结尾，同$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\d'&lt;/code&gt;    &lt;code class=&quot;python plain&quot;&gt;匹配数字&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\D'&lt;/code&gt;    &lt;code class=&quot;python plain&quot;&gt;匹配非数字&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\w'&lt;/code&gt;    &lt;code class=&quot;python plain&quot;&gt;匹配[A&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;Za&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;z0&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'\W'&lt;/code&gt;    &lt;code class=&quot;python plain&quot;&gt;匹配非[A&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;Za&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;z0&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;python value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'s'&lt;/code&gt;     &lt;code class=&quot;python plain&quot;&gt;匹配空白字符、\t、\n、\r , re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;\s+&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;ab\tc1\n3&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;).group() 结果 &lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'\t'&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;三、常用的匹配方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、re.match(pattern, string, flags=0)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：在string的开始处匹配模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203141536375-1480073332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;2、re.search(pattern, string, flags=0)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：在string中寻找模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203151335093-1721068813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;3、re.findall(pattern, string, flags=0)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：把匹配到的字符以列表的形式返回&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203151748640-226531990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、re.split(pattern, string, maxsplit=0, flags=0)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：匹配到的字符被当做列表分割符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203152640281-536150463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、re.sub(pattern, repl, string, count=0, flags=0)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 说明：匹配字符并替换&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203154254250-971574221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、常用方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、group([group1, ...])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203202835593-104307076.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、groups(default=None)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。这个要跟分组匹配结合起来使用'(...)'&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203205812343-1644609361.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、groupdict(default=None)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。这个是跟另外一个分组匹配结合起来用的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203210125250-1543152233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;4、span([group])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：返回(start(group), end(group))&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203211058906-837434203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、start([group])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引），group默认值为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、end([group])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1），group默认值为0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203211213171-1120729067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、compile(pattern[, flags])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：根据包含正则表达式的字符串创建模式对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203211617406-1965366949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、反斜杠的困扰&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;与大多数编程语言相同，正则表达式里使用&quot;\&quot;作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符&quot;\&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠&quot;\\\\&quot;：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r&quot;\\&quot;表示。同样，匹配一个数字的&quot;\\d&quot;可以写成r&quot;\d&quot;。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1274477/201802/1274477-20180203212928375-2021246562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、其他匹配模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、re.I(&lt;code class=&quot;python plain&quot;&gt;re.IGNORECASE&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：忽略大小写(括号内是完整的写法，下同)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_373375&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;import&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;re&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'addr'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;inet Addr:10.161.146.134&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,flags&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;re.I)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a.group()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'Addr'&lt;/code&gt;  &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;2、re.M(&lt;code class=&quot;python plain&quot;&gt;MULTILINE&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：多行模式，改变'^'和'$'的行为，详细请见第2点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_435679&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;import&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;re&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'^a'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;inet\naddr:10.161.146.134&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,flags&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;re.M)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a.group()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'a'&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;3、re.S(&lt;code class=&quot;python plain&quot;&gt;DOTALL&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明：点任意匹配模式，改变'.'的行为&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter sh-gutter&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_581875&quot; class=&quot;syntaxhighlighter python&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;import&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;re&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a &lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt; &lt;code class=&quot;python plain&quot;&gt;re.search(&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;'.+'&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;python string&quot;&gt;&quot;inet\naddr:10.161.146.134&quot;&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;,flags&lt;/code&gt;&lt;code class=&quot;python keyword&quot;&gt;=&lt;/code&gt;&lt;code class=&quot;python plain&quot;&gt;re.S)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python plain&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a.group()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;python string&quot;&gt;'inet\naddr:10.161.146.134'&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 注意：上面这三种匹配模式，知道就行。&lt;/p&gt;
&lt;h2&gt;七、总结&lt;/h2&gt;
&lt;p&gt;1、用r''的方式表示的字符串叫做&lt;span&gt;raw字符串&lt;/span&gt;，&lt;span&gt;用于抑制转义&lt;/span&gt;。&lt;br/&gt;2、正则表达式使用反斜杆（\）来转义特殊字符，&lt;span&gt;使其可以匹配字符本身，而不是指定其他特殊的含义&lt;/span&gt;。&lt;br/&gt;3、这可能会和python字面意义上的字符串转义相冲突，这也许有些令人费解，比如，要匹配&lt;span&gt;一个反斜杆&lt;/span&gt;本身，你也许要用&lt;span&gt;'\\\\'&lt;/span&gt;来做为正则表达式的字符串，而字符串里，每个反斜杆都要写成\\。&lt;br/&gt;4、你也可以在字符串前加上 r 这个前缀来避免部分疑惑，因为 r 开头的python字符串是 raw 字符串，所以里面的所有字符都不会被转义，比如r'\n'这个字符串就是一个反斜杆加上一字母n，而'\n'我们知道这是个换行符。因此，上面的&lt;span&gt;'\\\\'你也可以写成r'\\'&lt;/span&gt;，这样，应该就好理解很多了。&lt;/p&gt;

</description>
<pubDate>Sat, 03 Feb 2018 13:36:00 +0000</pubDate>
<dc:creator>钱多多的妖孽人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/8410826.html</dc:identifier>
</item>
<item>
<title>机器学习--线性回归与梯度算法 - 北言</title>
<link>http://www.cnblogs.com/beiyan/p/8404817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beiyan/p/8404817.html</guid>
<description>&lt;p&gt;线性回归(Linear Regression)，亦称为直线回归，即用直线表示的回归，与曲线回归相对。若因变量Y对自变量X&lt;sub&gt;1&lt;/sub&gt;、X&lt;sub&gt;2&lt;/sub&gt;…、Xm的回归方程是线性方程，即μ&lt;sub&gt;y&lt;/sub&gt;＝β&lt;sub&gt;0&lt;/sub&gt; +β&lt;sub&gt;1&lt;/sub&gt;X&lt;sub&gt;1&lt;/sub&gt; +β&lt;sub&gt;2&lt;/sub&gt;X&lt;sub&gt;2&lt;/sub&gt; +…β&lt;sub&gt;m&lt;/sub&gt;X&lt;sub&gt;m&lt;/sub&gt;，其中β&lt;sub&gt;0&lt;/sub&gt;是常数项，β&lt;sub&gt;i&lt;/sub&gt;是自变量X&lt;sub&gt;i&lt;/sub&gt;的回归系数，M为任何自然数。这时就称Y对X&lt;sub&gt;1&lt;/sub&gt;、X&lt;sub&gt;2&lt;/sub&gt;、…、X&lt;sub&gt;m&lt;/sub&gt;的回归为线性回归。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单回归：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只有一个自变量的线性回归称为简单回归，如下面示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;X表示某商品的数量，Y表示这些不同数量商品的总价格&lt;/p&gt;
&lt;p&gt;x=[0, 1, 2, 3, 4, 5]&lt;/p&gt;
&lt;p&gt;y=[0, 17, 45, 55, 85, 99]&lt;/p&gt;
&lt;p&gt;二维坐标中绘图如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202160024500-691633145.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在当商品数量 X = 6时，估计商品总价是多少？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以很明显的看到，商品总价随商品的数量上升而上升，这是一个典型的线性回归。&lt;/p&gt;
&lt;p&gt;因为只有一个自变量X，我们假设线性回归模型： Y = a * X + b&lt;/p&gt;
&lt;p&gt;我们需要求出最合适的a，b值，使得直线：Y = a * X + b 与上图的趋势相拟合，这时候才能去预测不同商品数量X下的总价Y。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最小二乘法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 为了求出最合适的a b ，我们引入最小二乘法。&lt;/p&gt;
&lt;p&gt;最小二乘法，亦称最小二乘法估计。由样本观测值估计总体参数的一种常用方法。它用于从n对观测数据(x&lt;sub&gt;1&lt;/sub&gt;，y&lt;sub&gt;1&lt;/sub&gt;)，(x&lt;sub&gt;2&lt;/sub&gt;，y&lt;sub&gt;2&lt;/sub&gt;)，……，(xn，yn)确定x与y之间对应关系y=f(x)的一种最佳估计，使得观测值与估计值之差(即偏差)的平方和 H为最小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202153748015-1322678838.png&quot; alt=&quot;&quot; width=&quot;186&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最小二乘法能尽量消除偶然误差的影响，从而由一组观测数据求出最可靠、最可能出现的结果。&lt;/p&gt;
&lt;p&gt;由上图我们可以很明显的看出直线Y = a * X + b过原点，即 b = 0&lt;/p&gt;
&lt;p&gt;我们尝试不同的a值 得到的结果如下：  &lt;/p&gt;
&lt;p&gt;a = 19 时 H = 154&lt;/p&gt;
&lt;p&gt;a = 20 时 H = 85&lt;/p&gt;
&lt;p&gt;a = 21 时 H = 126&lt;/p&gt;
&lt;p&gt; 图像分别如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202133523031-1316623741.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;335&quot;/&gt;  &lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202133425437-899510598.png&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;335&quot;/&gt;   &lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202133647625-2000049367.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们可以粗略得出结论 a = 20，b = 0 时，线性模型 Y = 20 * X 与样本数据拟合的比较好。&lt;/p&gt;
&lt;p&gt;所以当商品数量 X = 6 时，我们可以粗略估计总价Y = 20 * 6 = 120&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;多元回归：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大于一个自变量的线性回归叫做多元回归。&lt;/p&gt;
&lt;p&gt;上面的例子只是一个自变量，处理起来比较简单，但是若自变量有很多，假设自变量有m个，为 [ x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;,x&lt;sub&gt;3&lt;/sub&gt;,x&lt;sub&gt;4.....&lt;/sub&gt;x&lt;sub&gt;m ]&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;这时候我们假设的回归系数（即权重）也需要有m个，即我们假设的线性模型是 Y =  X&lt;sub&gt;0&lt;/sub&gt; +  X&lt;sub&gt;1&lt;/sub&gt;*W&lt;sub&gt;1 +&lt;/sub&gt; X&lt;sub&gt;2&lt;/sub&gt;*W&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;+&lt;/sub&gt; X&lt;sub&gt;3&lt;/sub&gt;*W&lt;sub&gt;3&lt;/sub&gt; + ....... + X&lt;sub&gt;m&lt;/sub&gt;*W&lt;sub&gt;m&lt;/sub&gt;&lt;sub&gt; &lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;为了计算方便，我们去W&lt;sub&gt;0&lt;/sub&gt; = 1&lt;/p&gt;
&lt;p&gt;这样：Y =  X&lt;sub&gt;0&lt;/sub&gt;*W&lt;sub&gt;0&lt;/sub&gt; +  X&lt;sub&gt;1&lt;/sub&gt;*W&lt;sub&gt;1 +&lt;/sub&gt; X&lt;sub&gt;2&lt;/sub&gt;*W&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;+&lt;/sub&gt; X&lt;sub&gt;3&lt;/sub&gt;*W&lt;sub&gt;3&lt;/sub&gt; + ....... + X&lt;sub&gt;m&lt;/sub&gt;*W&lt;sub&gt;m&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;写成向量形式：&lt;/p&gt;
&lt;p&gt;W = [W&lt;sub&gt;0&lt;/sub&gt;,W&lt;sub&gt;1 ,&lt;/sub&gt; W&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;,&lt;/sub&gt;W&lt;sub&gt;3 ,&lt;/sub&gt; .... ,W&lt;sub&gt;m&lt;/sub&gt;]&lt;sup&gt; &lt;/sup&gt;  &lt;/p&gt;
&lt;p&gt;X = [ X&lt;sub&gt;0,&lt;/sub&gt; X&lt;sub&gt;1&lt;/sub&gt; , X&lt;sub&gt;2&lt;/sub&gt; , X&lt;sub&gt;3 &lt;/sub&gt; , .... , X&lt;sub&gt;m&lt;/sub&gt;]&lt;/p&gt;
&lt;p&gt;Y = W&lt;sup&gt;T&lt;/sup&gt; * X （W&lt;sup&gt;T&lt;/sup&gt;为向量W的转置）&lt;/p&gt;
&lt;p&gt;观测值与估计值之差(即偏差)的平方和：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202142235953-2122804347.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了方便后面计算，我们在H的左边乘上二分之一，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202160445453-212848989.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面公式中 n 表示训练样本的数目，m 表示每条训练样本 的特征(自变量)个数，&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202160945921-1878283072.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;23&quot;/&gt;上标表示属于第 j 个 样本，下标表示第 i 个特征(自变量值)，&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203205253687-1761065308.png&quot; alt=&quot;&quot; width=&quot;27&quot; height=&quot;26&quot;/&gt;表示第 j 个样本总价观测值&lt;/p&gt;
&lt;p&gt;现在H是关于W0,W1,W2....Wm的函数，我们需要通过合适的方法求出最适合的W值，才能得出一个比较好的线性回归方程。与简单回归相比，这里我们很难通过观察与尝试不同的w值来求解，我们需要采用最优化算法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;梯度算法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;常见的最优化算法有梯度下降法（Gradient Descent）、牛顿法和拟牛顿法（Newton's method &amp;amp; Quasi-Newton Methods）、共轭梯度法（Conjugate Gradient）、 启发式优化方法等，本文详细介绍梯度算法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;明确下我们现在的目标&lt;/span&gt;：我们需要通过梯度算法求出---当在H取得最小的情况下，W&lt;sub&gt;0&lt;/sub&gt; ,W&lt;sub&gt;1 ,&lt;/sub&gt;W&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;,&lt;/sub&gt;W&lt;sub&gt;3 ,&lt;/sub&gt; ....... ,W&lt;sub&gt;m&lt;/sub&gt;的值，从而写出回归方程。&lt;/p&gt;
&lt;p&gt;梯度算法分为梯度上升算法 和 梯度下降算法。梯度下降算法的基本思想是：要找到某函数的最小值，最好的方法是沿着该函数的梯度方向探寻，梯度上升则相反。对于一个有两个未知数x,y的函数f(x,y)，梯度表示为：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202161914296-1123521482.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于Z = f(x,y)，使用梯度下降算法的意味着 沿X轴方向移动&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202162055078-1854343573.png&quot; alt=&quot;&quot; width=&quot;45&quot; height=&quot;26&quot;/&gt;，沿Y的方向移动&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202164502796-1473110262.png&quot; alt=&quot;&quot; width=&quot;51&quot; height=&quot;29&quot;/&gt;，函数f(x,y)必须要在待计算的点上有定义并且可微。&lt;/p&gt;
&lt;p&gt;可以通俗理解为：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;梯度实际上是函数值变化最快的方向。比如说，你站在一个山上，梯度所指示的方向是高度变化最快的方向。你沿着这个方向走，能最快的改变（增加或是减小）你所在位置的高度，但是如果你乱走，可能走半天所在位置高度也没有变化多少。也就是说，如果你一直沿着梯度走，你就能最快的到达山的某个顶峰或低谷。所以实际上，梯度算法是用来搜索局部极小值或极大值的，它是实际应用中一种非常高效，高速且可靠的方法。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用梯度下降法找出最小H&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们前面看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180202160445453-212848989.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;H是关于W = [W&lt;sub&gt;0&lt;/sub&gt; ,W&lt;sub&gt;1 ,&lt;/sub&gt;W&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;,&lt;/sub&gt;W&lt;sub&gt;3 ,&lt;/sub&gt; ....... ,W&lt;sub&gt;m&lt;/sub&gt;]的函数，H的梯度如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203144012406-1347993569.png&quot; alt=&quot;&quot; width=&quot;377&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候对于每一个Wi的梯度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203144437359-1079551123.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;89&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203150642625-758132642.png&quot; alt=&quot;&quot; width=&quot;849&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203150735437-785319309.png&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203150833656-241422628.png&quot; alt=&quot;&quot; width=&quot;325&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们假设每次沿着梯度方向更新的步长为 α，所以W的值更新公式可写为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203151247421-1564277000.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;33&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 所以梯度下降算法的伪代码如下：&lt;/p&gt;
&lt;p&gt;每个回归系数(即每个W值)的每个值都为1&lt;/p&gt;
&lt;p&gt;重复R次：&lt;/p&gt;
&lt;p&gt;　　计算整个数据集的梯度&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203151129406-323518075.png&quot; alt=&quot;&quot; width=&quot;24&quot; height=&quot;13&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     使用&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203151247421-1564277000.png&quot; alt=&quot;&quot; width=&quot;107&quot; height=&quot;15&quot;/&gt; 更新回归系数W&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;用梯度下降 算法求下面商品数据的线性回归方程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203200449281-1177748214.png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;362&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们假设线性回归模型为总价Y = a + b * X&lt;sub&gt;1&lt;/sub&gt; + c * X&lt;sub&gt;2 &lt;/sub&gt;（X1 X2 分别表示商品1，2的数量）&lt;/p&gt;
&lt;p&gt;我们需要求出回归系数W = [ a, b, c]&lt;/p&gt;
&lt;p&gt;梯度下降算法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; grad_desc(train_data, train_labels):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;梯度下降&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     data_mat =&lt;span&gt; np.matrix(train_data)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     label_mat =&lt;span&gt; np.matrix(train_labels).transpose()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     n = np.shape(data_mat)[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 步长&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     alpha = 0.001
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大循环次数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     max_cycles = 100
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化回归系数weights&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     weights = np.ones((n, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(max_cycles):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         h = data_mat * weights-&lt;span&gt;label_mat
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         weights = weights - alpha * data_mat.transpose() *&lt;span&gt; h
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回压平的系数数组&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; np.asarray(weights).flatten()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们用上面算法得到的回归系数为&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;span&gt;[ 1.7218815 4.24881047 5.28838946]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;随机梯度算法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上述梯度算法中，循环R = 100次，每一次更新回归系数都需要遍历整个数据集，如果数据样本很大，那么计算时间复杂度将会非常高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以一般每次使用一个样本点来更新回归系数，称为随机梯度算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随机梯度下降算法伪代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有回归系数初始化为1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　重复R次：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　循环每一个样本：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　计算该样本的梯度&lt;/span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203151129406-323518075.png&quot; alt=&quot;&quot; width=&quot;24&quot; height=&quot;13&quot;/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;     　　　　&lt;span&gt;使用&lt;img src=&quot;https://images2017.cnblogs.com/blog/631769/201802/631769-20180203151247421-1564277000.png&quot; alt=&quot;&quot; width=&quot;107&quot; height=&quot;12&quot;/&gt; 更新回归系数&lt;/span&gt;W&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 修改后的算法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; advanced_random_grad_desc(train_data, train_labels):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;随机梯度下降改进&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     data_mat =&lt;span&gt; np.asarray(train_data)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     label_mat =&lt;span&gt; np.asarray(train_labels)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     m, n =&lt;span&gt; np.shape(data_mat)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 步长&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     alpha = 0.001
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化回归系数weights&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     weights =&lt;span&gt; np.ones(n)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     max_cycles = 500
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(max_cycles):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         data_index =&lt;span&gt; list(range(m))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             random_index =&lt;span&gt; int(np.random.uniform(0, len(data_index)))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             h = sum(data_mat[random_index] * weights)-&lt;span&gt;label_mat[random_index]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             weights = weights - alpha * h *&lt;span&gt; data_mat[random_index]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;del&lt;/span&gt;&lt;span&gt; data_index[random_index]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; weights
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算得到的回归系数为：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;[ 1.27137416 4.31393524 5.2757683 ]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 我们可以得到线性回归方程为：&lt;/p&gt;
&lt;p&gt;Y = 1.27 + 4.31 * X&lt;sub&gt;1&lt;/sub&gt; + 5.28 * X&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在后面的话：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文的完整代码已上传：&lt;a href=&quot;https://gitee.com/beiyan/machine_learning/tree/master/gradient&quot; target=&quot;_blank&quot;&gt;https://gitee.com/beiyan/machine_learning/tree/master/gradient&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 随机梯度下降(上升)算法使用非常广泛，效果也非常好，后续文章将使用梯度算法来解决一些问题。不例外，梯度算法也是有缺点的，如靠近极小值时收敛速度减慢、直线搜索时可能会产生一些问题、可能会“之字形”地下降等，另外下降或上升步长的选择也会影响最后得到的回归系数，我们可以通过改变一些参数来测试回归的效果。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 13:08:00 +0000</pubDate>
<dc:creator>北言</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/beiyan/p/8404817.html</dc:identifier>
</item>
<item>
<title>达尔稳usb转RJ45的接口转换器（usb2.0接口）在ubuntu16.04中驱动（r8152）编译安装与使用 - eternalwanglu</title>
<link>http://www.cnblogs.com/eternalwanglu/p/8410737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eternalwanglu/p/8410737.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;我就是单纯的觉得网线接口插拔太麻烦，所以在淘宝买了usb转RJ45的接口转换器：&lt;a href=&quot;https://detail.tmall.com/item.htm?id=524808012954&amp;amp;ali_refid=a3_430582_1006:1105586579:N:USB%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%20%E7%AC%94%E8%AE%B0%E6%9C%AC:eb696d88976cbb7272321d0ffa0bb488&amp;amp;ali_trackid=1_eb696d88976cbb7272321d0ffa0bb488&amp;amp;spm=a230r.1.14.1&quot;&gt;https://detail.tmall.com/item.htm?id=524808012954&amp;amp;ali_refid=a3_430582_1006:1105586579:N:USB%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%20%E7%AC%94%E8%AE%B0%E6%9C%AC:eb696d88976cbb7272321d0ffa0bb488&amp;amp;ali_trackid=1_eb696d88976cbb7272321d0ffa0bb488&amp;amp;spm=a230r.1.14.1&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1233320/201802/1233320-20180203205324640-333135444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;就是这货，ubuntu中使用还没有驱动~问了客服，表示可以自己下载驱动：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;驱动链接：&lt;a href=&quot;http://www.realtek.com.tw/downloads/downloadsView.aspx?Langid=3&amp;amp;PNid=13&amp;amp;PFid=56&amp;amp;Level=5&amp;amp;Conn=4&amp;amp;DownTypeID=3&amp;amp;GetDown=false&quot;&gt;http://www.realtek.com.tw/downloads/downloadsView.aspx?Langid=3&amp;amp;PNid=13&amp;amp;PFid=56&amp;amp;Level=5&amp;amp;Conn=4&amp;amp;DownTypeID=3&amp;amp;GetDown=false&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;但是，直接make后ismod模块还报错！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;安装驱动时报错&lt;strong&gt;Unknown symbol in module解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
root@ubuntu:/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;# &lt;span&gt;make&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译&lt;/span&gt;
&lt;span&gt;make&lt;/span&gt; -C /lib/modules/&lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;109&lt;/span&gt;-generic/build SUBDIRS=/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt; modules
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;]: Entering directory &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/src/linux-headers-4.4.0-109-generic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  CC [M]  &lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;r8152.o
  Building modules, stage &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;]: Warning: File &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-2.09.0/r8152.o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; has modification &lt;span&gt;time&lt;/span&gt; &lt;span&gt;1.5&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the future
  MODPOST &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; modules
  CC      &lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;r8152.mod.o
  LD [M]  &lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;r8152.ko
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]: warning:  Clock skew detected.  Your build may be incomplete.
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;]: Leaving directory &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/src/linux-headers-4.4.0-109-generic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
root@ubuntu:&lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;# &lt;span&gt;insmod&lt;/span&gt; r8152.ko  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;
&lt;span&gt;insmod&lt;/span&gt;: ERROR: could not insert module r8152.ko: Unknown symbol &lt;span&gt;in&lt;/span&gt; module
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;参考：&lt;a href=&quot;http://blog.csdn.net/zhang_danf/article/details/17758669&quot;&gt;http://blog.csdn.net/zhang_danf/article/details/17758669&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dmesg | tail 看输出信息中的Unknown symbol，加载上这些模块就好。我的输出信息是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
root@ubuntu:/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;#  dmesg | &lt;span&gt;tail&lt;/span&gt;&lt;span&gt; 
[&lt;/span&gt;&lt;span&gt;38227.073922&lt;/span&gt;&lt;span&gt;] IPv6: ADDRCONF(NETDEV_UP): ens33: link is not ready
[&lt;/span&gt;&lt;span&gt;38227.073934&lt;/span&gt;&lt;span&gt;] IPv6: ADDRCONF(NETDEV_CHANGE): ens33: link becomes ready
[&lt;/span&gt;&lt;span&gt;38448.591972&lt;/span&gt;] r8152: Unknown symbol mii_nway_restart (err &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;&lt;span&gt;39883.931152&lt;/span&gt;] xhci_hcd &lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt;: Error: Failed finding new dequeue state
[&lt;/span&gt;&lt;span&gt;39886.445089&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: USB disconnect, device number &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;39886.445375&lt;/span&gt;] pl2303 ttyUSB0: pl2303_set_control_lines - failed: -&lt;span&gt;19&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;39886.445379&lt;/span&gt;] pl2303 ttyUSB0: error sending break = -&lt;span&gt;19&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;39886.446493&lt;/span&gt;&lt;span&gt;] pl2303 ttyUSB0: pl2303 converter now disconnected from ttyUSB0
[&lt;/span&gt;&lt;span&gt;39886.446509&lt;/span&gt;] pl2303 &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;: device disconnected
[&lt;/span&gt;&lt;span&gt;40375.871882&lt;/span&gt;] r8152: Unknown symbol mii_nway_restart (err &lt;span&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;估计是由于模块依赖的其他模块没有加载导致的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;直接用modinfo  ./r8152.ko | grep depend命令查找模块的依赖，结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@ubuntu:/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;# modinfo  ./r8152.ko | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; depend
depends:        mii
root@ubuntu:&lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;#  &lt;span&gt;modprobe&lt;/span&gt;&lt;span&gt; mii
root@ubuntu:&lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;# &lt;span&gt;insmod&lt;/span&gt;&lt;span&gt; r8152.ko
root@ubuntu:&lt;/span&gt;/mnt/hgfs/share/LinuxDriver/download/r8152-&lt;span&gt;2.09&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;#
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;模块加载成功了~&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果这样就能用，似乎太简单了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1233320/201802/1233320-20180203205611515-58452328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;结果还是不能用：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1233320/201802/1233320-20180203205623625-1799355412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;然后，重启虚拟机，再拔出usb转RJ45转接器重新插上，Vmware就可以识别了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1233320/201802/1233320-20180203205643093-614230613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;关于dmesg命令，这个写的很清楚：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://linux.cn/article-3587-1.html&quot;&gt;https://linux.cn/article-3587-1.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;问题又出现了，虽然驱动安装成功，但是实际测试并不能用啊：通过dmesg | grep usb 查看内核打印信息错误是device descriptor read/64, error -110：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
root@ubuntu:/lib/modules# dmesg | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; usb
No command &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dmesh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; found, did you mean:
 Command &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admesh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; from package &lt;span&gt;'&lt;/span&gt;&lt;span&gt;admesh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; (universe)
 Command &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dmesg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; from package &lt;span&gt;'&lt;/span&gt;&lt;span&gt;util-linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; (main)
dmesh: command not found
root@ubuntu:&lt;/span&gt;/lib/modules# dmesg | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; usb
[    &lt;/span&gt;&lt;span&gt;0.272527&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver usbfs
[    &lt;/span&gt;&lt;span&gt;0.272532&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver hub
[    &lt;/span&gt;&lt;span&gt;0.272549&lt;/span&gt;&lt;span&gt;] usbcore: registered new device driver usb
[    &lt;/span&gt;&lt;span&gt;0.993902&lt;/span&gt;] usb usb1: New USB device found, idVendor=1d6b, idProduct=&lt;span&gt;0002&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.993903&lt;/span&gt;] usb usb1: New USB device strings: Mfr=&lt;span&gt;3&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.993904&lt;/span&gt;&lt;span&gt;] usb usb1: Product: EHCI Host Controller
[    &lt;/span&gt;&lt;span&gt;0.993905&lt;/span&gt;] usb usb1: Manufacturer: Linux &lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;109&lt;/span&gt;-&lt;span&gt;generic ehci_hcd
[    &lt;/span&gt;&lt;span&gt;0.993905&lt;/span&gt;] usb usb1: SerialNumber: &lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;03.0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.994658&lt;/span&gt;] usb usb2: New USB device found, idVendor=1d6b, idProduct=&lt;span&gt;0001&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.994659&lt;/span&gt;] usb usb2: New USB device strings: Mfr=&lt;span&gt;3&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.994660&lt;/span&gt;&lt;span&gt;] usb usb2: Product: UHCI Host Controller
[    &lt;/span&gt;&lt;span&gt;0.994660&lt;/span&gt;] usb usb2: Manufacturer: Linux &lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;109&lt;/span&gt;-&lt;span&gt;generic uhci_hcd
[    &lt;/span&gt;&lt;span&gt;0.994661&lt;/span&gt;] usb usb2: SerialNumber: &lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.996260&lt;/span&gt;] usb usb3: New USB device found, idVendor=1d6b, idProduct=&lt;span&gt;0002&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.996262&lt;/span&gt;] usb usb3: New USB device strings: Mfr=&lt;span&gt;3&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.996262&lt;/span&gt;&lt;span&gt;] usb usb3: Product: xHCI Host Controller
[    &lt;/span&gt;&lt;span&gt;0.996263&lt;/span&gt;] usb usb3: Manufacturer: Linux &lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;109&lt;/span&gt;-generic xhci-&lt;span&gt;hcd
[    &lt;/span&gt;&lt;span&gt;0.996264&lt;/span&gt;] usb usb3: SerialNumber: &lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.996655&lt;/span&gt;] usb usb4: We don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t know the algorithms for LPM for this host, disabling LPM.&lt;/span&gt;
[    &lt;span&gt;0.996664&lt;/span&gt;] usb usb4: New USB device found, idVendor=1d6b, idProduct=&lt;span&gt;0003&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.996665&lt;/span&gt;] usb usb4: New USB device strings: Mfr=&lt;span&gt;3&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;0.996666&lt;/span&gt;&lt;span&gt;] usb usb4: Product: xHCI Host Controller
[    &lt;/span&gt;&lt;span&gt;0.996666&lt;/span&gt;] usb usb4: Manufacturer: Linux &lt;span&gt;4.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;109&lt;/span&gt;-generic xhci-&lt;span&gt;hcd
[    &lt;/span&gt;&lt;span&gt;0.996667&lt;/span&gt;] usb usb4: SerialNumber: &lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.305723&lt;/span&gt;] usb &lt;span&gt;2&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: new full-speed USB device number &lt;span&gt;2&lt;/span&gt;&lt;span&gt; using uhci_hcd
[    &lt;/span&gt;&lt;span&gt;1.305732&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: new full-speed USB device number &lt;span&gt;2&lt;/span&gt;&lt;span&gt; using xhci_hcd
[    &lt;/span&gt;&lt;span&gt;1.433287&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: New USB device found, idVendor=&lt;span&gt;0e0f&lt;/span&gt;, idProduct=&lt;span&gt;0003&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.433290&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;1&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.433291&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;: Product: VMware Virtual USB Mouse
[    &lt;/span&gt;&lt;span&gt;1.433292&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;: Manufacturer: VMware
[    &lt;/span&gt;&lt;span&gt;1.453700&lt;/span&gt;] usb &lt;span&gt;2&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device found, idVendor=&lt;span&gt;0e0f&lt;/span&gt;, idProduct=&lt;span&gt;0002&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.453702&lt;/span&gt;] usb &lt;span&gt;2&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;0&lt;/span&gt;, Product=&lt;span&gt;1&lt;/span&gt;, SerialNumber=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.453703&lt;/span&gt;] usb &lt;span&gt;2&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: Product: VMware Virtual USB Hub
[    &lt;/span&gt;&lt;span&gt;1.560991&lt;/span&gt;] usb &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: new SuperSpeed USB device number &lt;span&gt;2&lt;/span&gt;&lt;span&gt; using xhci_hcd
[    &lt;/span&gt;&lt;span&gt;1.621634&lt;/span&gt;] usb &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: New USB device found, idVendor=0bda, idProduct=&lt;span&gt;0316&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.621636&lt;/span&gt;] usb &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;1&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.621638&lt;/span&gt;] usb &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: Product: USB3.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;CRW
[    &lt;/span&gt;&lt;span&gt;1.621639&lt;/span&gt;] usb &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;: Manufacturer: Generic
[    &lt;/span&gt;&lt;span&gt;1.621639&lt;/span&gt;] usb &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;: SerialNumber: &lt;span&gt;20120501030900000&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.634811&lt;/span&gt;] usb-storage &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;: USB Mass Storage device detected
[    &lt;/span&gt;&lt;span&gt;1.656746&lt;/span&gt;] scsi host3: usb-storage &lt;span&gt;4&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.656927&lt;/span&gt;] usbcore: registered new interface driver usb-&lt;span&gt;storage
[    &lt;/span&gt;&lt;span&gt;1.657906&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver uas
[    &lt;/span&gt;&lt;span&gt;1.705334&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;: new full-speed USB device number &lt;span&gt;3&lt;/span&gt;&lt;span&gt; using xhci_hcd
[    &lt;/span&gt;&lt;span&gt;1.835739&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;: New USB device found, idVendor=&lt;span&gt;0e0f&lt;/span&gt;, idProduct=&lt;span&gt;0002&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.835743&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;0&lt;/span&gt;, Product=&lt;span&gt;1&lt;/span&gt;, SerialNumber=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;1.835746&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: Product: VMware Virtual USB Hub
[    &lt;/span&gt;&lt;span&gt;1.835881&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt;: ep &lt;span&gt;0x81&lt;/span&gt; - rounding interval to &lt;span&gt;1024&lt;/span&gt; microframes, ep desc says &lt;span&gt;2040&lt;/span&gt;&lt;span&gt; microframes
[    &lt;/span&gt;&lt;span&gt;1.949234&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;: new high-speed USB device number &lt;span&gt;4&lt;/span&gt;&lt;span&gt; using xhci_hcd
[    &lt;/span&gt;&lt;span&gt;2.078074&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;: New USB device found, idVendor=&lt;span&gt;0e0f&lt;/span&gt;, idProduct=&lt;span&gt;0002&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;2.078078&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;0&lt;/span&gt;, Product=&lt;span&gt;1&lt;/span&gt;, SerialNumber=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[    &lt;/span&gt;&lt;span&gt;2.078079&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;: Product: VMware Virtual USB Hub
[    &lt;/span&gt;&lt;span&gt;2.087762&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver usbhid
[    &lt;/span&gt;&lt;span&gt;2.087764&lt;/span&gt;&lt;span&gt;] usbhid: USB HID core driver
[    &lt;/span&gt;&lt;span&gt;2.089529&lt;/span&gt;] input: VMware VMware Virtual USB Mouse as /devices/pci0000:&lt;span&gt;00&lt;/span&gt;/&lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;15.0&lt;/span&gt;/&lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;/usb3/&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;0003&lt;/span&gt;:&lt;span&gt;0E0F&lt;/span&gt;:&lt;span&gt;0003.0001&lt;/span&gt;/input/&lt;span&gt;input5
[    &lt;/span&gt;&lt;span&gt;2.089833&lt;/span&gt;] hid-generic &lt;span&gt;0003&lt;/span&gt;:&lt;span&gt;0E0F&lt;/span&gt;:&lt;span&gt;0003.0001&lt;/span&gt;: input,hidraw0: USB HID v1.&lt;span&gt;10&lt;/span&gt; Mouse [VMware VMware Virtual USB Mouse] on usb-&lt;span&gt;0000&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;input0
[  &lt;/span&gt;&lt;span&gt;454.875729&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: new high-speed USB device number &lt;span&gt;5&lt;/span&gt;&lt;span&gt; using xhci_hcd
[  &lt;/span&gt;&lt;span&gt;455.121350&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device found, idVendor=0bda, idProduct=&lt;span&gt;8152&lt;/span&gt;&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;455.121355&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;1&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;455.121357&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: Product: USB &lt;span&gt;10&lt;/span&gt;/&lt;span&gt;100&lt;/span&gt;&lt;span&gt; LAN
[  &lt;/span&gt;&lt;span&gt;455.121358&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: Manufacturer: Realtek
[  &lt;/span&gt;&lt;span&gt;455.121360&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: SerialNumber: 00E04C360026
[  &lt;/span&gt;&lt;span&gt;455.295699&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver r8152
[  &lt;/span&gt;&lt;span&gt;455.327002&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver cdc_ether
[  &lt;/span&gt;&lt;span&gt;455.447177&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;5&lt;/span&gt;&lt;span&gt; using xhci_hcd
[  &lt;/span&gt;&lt;span&gt;460.675029&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;476.309164&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;476.640902&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;5&lt;/span&gt;&lt;span&gt; using xhci_hcd
[  &lt;/span&gt;&lt;span&gt;481.862679&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;497.193094&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[  &lt;/span&gt;&lt;span&gt;497.525851&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;5&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5086.911092&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: USB disconnect, device number &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5109.766695&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: new high-speed USB device number &lt;span&gt;6&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5110.024144&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device found, idVendor=0bda, idProduct=&lt;span&gt;8152&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5110.024147&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;1&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5110.024148&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: Product: USB &lt;span&gt;10&lt;/span&gt;/&lt;span&gt;100&lt;/span&gt;&lt;span&gt; LAN
[ &lt;/span&gt;&lt;span&gt;5110.024149&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: Manufacturer: Realtek
[ &lt;/span&gt;&lt;span&gt;5110.024150&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: SerialNumber: 00E04C360026
[ &lt;/span&gt;&lt;span&gt;5110.322767&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;6&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5115.546457&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5130.876795&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5131.209396&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;6&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5136.436428&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5151.767965&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5152.099224&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;6&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5156.378454&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: USB disconnect, device number &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5166.382326&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: new full-speed USB device number &lt;span&gt;7&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5166.640807&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device found, idVendor=067b, idProduct=&lt;span&gt;2303&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5166.640809&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;1&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5166.640811&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;: Product: USB-&lt;span&gt;Serial Controller D
[ &lt;/span&gt;&lt;span&gt;5166.640812&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: Manufacturer: Prolific Technology Inc. 
[ &lt;/span&gt;&lt;span&gt;5167.090180&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: new high-speed USB device number &lt;span&gt;8&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5167.298556&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: New USB device found, idVendor=0bda, idProduct=&lt;span&gt;8152&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5167.298564&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: New USB device strings: Mfr=&lt;span&gt;1&lt;/span&gt;, Product=&lt;span&gt;2&lt;/span&gt;, SerialNumber=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5167.298569&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: Product: USB &lt;span&gt;10&lt;/span&gt;/&lt;span&gt;100&lt;/span&gt;&lt;span&gt; LAN
[ &lt;/span&gt;&lt;span&gt;5167.298572&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;&lt;span&gt;: Manufacturer: Realtek
[ &lt;/span&gt;&lt;span&gt;5167.298575&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;&lt;span&gt;: SerialNumber: 00E04C360026
[ &lt;/span&gt;&lt;span&gt;5167.517881&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;8&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5167.717060&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver usbserial
[ &lt;/span&gt;&lt;span&gt;5167.717291&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver usbserial_generic
[ &lt;/span&gt;&lt;span&gt;5167.717367&lt;/span&gt;] usbserial: USB Serial support registered &lt;span&gt;for&lt;/span&gt;&lt;span&gt; generic
[ &lt;/span&gt;&lt;span&gt;5167.720502&lt;/span&gt;&lt;span&gt;] usbcore: registered new interface driver pl2303
[ &lt;/span&gt;&lt;span&gt;5167.720590&lt;/span&gt;] usbserial: USB Serial support registered &lt;span&gt;for&lt;/span&gt;&lt;span&gt; pl2303
[ &lt;/span&gt;&lt;span&gt;5167.728177&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;: pl2303 converter now attached to ttyUSB0
[ &lt;/span&gt;&lt;span&gt;5172.705723&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5187.996724&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5188.284646&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;8&lt;/span&gt;&lt;span&gt; using xhci_hcd
[ &lt;/span&gt;&lt;span&gt;5193.471942&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5208.762799&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: device descriptor read/&lt;span&gt;64&lt;/span&gt;, error -&lt;span&gt;110&lt;/span&gt;&lt;span&gt;
[ &lt;/span&gt;&lt;span&gt;5209.055444&lt;/span&gt;] usb &lt;span&gt;3&lt;/span&gt;-&lt;span&gt;4.1&lt;/span&gt;: reset high-speed USB device number &lt;span&gt;8&lt;/span&gt;&lt;span&gt; using xhci_hcd
root@ubuntu:&lt;/span&gt;/lib/modules#
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;查看内核错误码发现问题是连接超时：为啥会连接超时？？这也不算是找到根源啊，没法解决~&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1233320/201802/1233320-20180203205749562-676835430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;经过一番百度，受文章启示（如下图说明）(问题链接：&lt;a href=&quot;http://www.ceus-now.com/ubuntu-can-t-read-my-usb-device-descriptor-read-64-error-110/&quot;&gt;http://www.ceus-now.com/ubuntu-can-t-read-my-usb-device-descriptor-read-64-error-110/&lt;/a&gt;)感觉有可能是硬件问题，电压问题还是啥的反正没搞明白，按照他说的操作，把虚拟机和笔记本电脑都重启了同时把usb转RJ45的接口转换器插到usb扩展接口的另外一个接口，然后就可以正常使用了~&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1233320/201802/1233320-20180203205822703-894049844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Feb 2018 13:01:00 +0000</pubDate>
<dc:creator>eternalwanglu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eternalwanglu/p/8410737.html</dc:identifier>
</item>
<item>
<title>python异步加协程获取比特币市场信息 - 半夜打老虎</title>
<link>http://www.cnblogs.com/xiaxuexiaoab/p/8410682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaxuexiaoab/p/8410682.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;选取几个比特币交易量大的几个交易平台，查看对应的API，获取该市场下货币对的ticker和depth信息。我们从&lt;a href=&quot;https://coinmarketcap.com/zh/currencies/volume/24-hour/&quot; target=&quot;_blank&quot;&gt;网站&lt;/a&gt;上选取4个交易平台：bitfinex、okex、binance、gdax。对应的交易对是BTC/USD，BTC/USDT，BTC/USDT，BTC/USD。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188959/201802/1188959-20180203192918906-2055171781.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一&lt;/span&gt;、ccxt&lt;span&gt;库&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;开始想着直接请求市场的API，然后再解析获取下来的数据，但到github上发现一个比较好得python库，里面封装好了获取比特币市场的相关函数，这样一来就省掉分析API的时间了。因此我只要传入市场以及对应的货币对，利用库里面的函数 &lt;/span&gt;&lt;/span&gt;fetch_ticker &lt;span&gt;&lt;span&gt;和 &lt;/span&gt;&lt;/span&gt;fetch_order_book &lt;span&gt;&lt;span&gt;就可以获取到市场的ticker和depth信息（具体的使用方法可以查看&lt;a href=&quot;https://github.com/ccxt/ccxt&quot; target=&quot;_blank&quot;&gt;ccxt手册&lt;/a&gt;）。接下来以市场okex为例，利用ccxt库获取okex的ticker和depth信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 引入库
import ccxt

# 实例化市场
exchange = ccxt.okex()
# 交易对
symbol = 'BTC/USDT'

# 获取ticker信息
ticker = exchange.fetch_ticker(symbol)
# 获取depth信息
depth = exchange.fetch_order_book(symbol)

print('ticker:%s, depth:%s' % (ticker, depth))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;运行后会得到结果如下图，从此可以看出已经获取到了ticker和depth信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1188959/201802/1188959-20180203194320734-662663401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二、获取四个市场的信息（for循环）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;接下来我们获取四个市场的信息，深度里面有asks和bids，数据量稍微有点儿多，这里depth信息我只去前面五个，对于ticker我也只提取里面的info信息（具体代表什么含义就要参考一下对应市场的API啦）。将其简单的封装后，最开始我想的是for循环。想到啥就开始吧：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 引入库
import ccxt
import time

now = lambda: time.time()
start = now()

def getData(exchange, symbol):
    data = {}  # 用于存储ticker和depth信息
    # 获取ticker信息
    tickerInfo = exchange.fetch_ticker(symbol)
    # 获取depth信息
    depth = {}
    # 获取深度信息
    exchange_depth = exchange.fetch_order_book(symbol)
    # 获取asks,bids 最低5个，最高5个信息
    asks = exchange_depth.get('asks')[:5]
    bids = exchange_depth.get('bids')[:5]
    depth['asks'] = asks
    depth['bids'] = bids

    data['ticker'] = tickerInfo
    data['depth'] = depth

    return data

def main():
    # 实例化市场
    exchanges = [ccxt.binance(), ccxt.bitfinex2(), ccxt.okex(), ccxt.gdax()]
    # 交易对
    symbols = ['BTC/USDT', 'BTC/USD', 'BTC/USDT', 'BTC/USD']

    for i in range(len(exchanges)):
        exchange = exchanges[i]
        symbol = symbols[i]
        data = getData(exchange, symbol)
        print('exchange: %s data is %s' % (exchange.id, data))

if __name__ == '__main__':
    main()
    print('Run Time: %s' % (now() - start))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　&lt;span&gt;运行后会发现虽然每个市场的信息都获取到了，执行完差不多花掉5.7秒，因为这是同步的，也就是按顺序执行的，要是要想每隔一定时间同时获取四个市场的信息，很显然这种结果不符合我们的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1188959/201802/1188959-20180203201056578-84759396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、异步加协程（coroutine）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;前面讲的循环虽然可以输出结果，但耗时长而且达不到想要的效果，接下来采用异步加协程（参考知乎上的一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25228075&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;），要用到异步首先得引入asyncio库，这个库是3.4以后才有的，它提供了一种机制，使得你可以用协程（coroutines）、IO复用（multiplexing I/O）在单线程环境中编写并发模型。这里python&lt;a href=&quot;https://docs.python.org/3/library/asyncio-task.html&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;有个小例子。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import asyncio

async def compute(x, y):
    print(&quot;Compute %s + %s ...&quot; % (x, y))
    await asyncio.sleep(1.0)
    return x + y

async def print_sum(x, y):
    result = await compute(x, y)
    print(&quot;%s + %s = %s&quot; % (x, y, result))

loop = asyncio.get_event_loop()
loop.run_until_complete(print_sum(1, 2))
loop.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188959/201802/1188959-20180203202539250-1533602142.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　当事件循环开始运行时，它会在Task中寻找coroutine来执行调度，因为事件循环注册了&lt;em&gt;print_sum()&lt;/em&gt;，因此&lt;em&gt;print_sum()&lt;/em&gt;被调用，执行&lt;em&gt;result = await compute(x, y)&lt;/em&gt;这条语句（等同于&lt;em&gt;result = yield from compute(x, y)&lt;/em&gt;），因为&lt;em&gt;compute()&lt;/em&gt;自身就是一个coroutine，因此&lt;em&gt;print_sum()&lt;/em&gt;这个协程就会暂时被挂起，&lt;em&gt;compute()&lt;/em&gt;被加入到事件循环中，程序流执行&lt;em&gt;compute()&lt;/em&gt;中的print语句，打印”Compute %s + %s …”，然后执行了&lt;em&gt;await asyncio.sleep(1.0)&lt;/em&gt;，因为&lt;em&gt;asyncio.sleep()&lt;/em&gt;也是一个coroutine，接着&lt;em&gt;compute()&lt;/em&gt;就会被挂起，等待计时器读秒，在这1秒的过程中，事件循环会在队列中查询可以被调度的coroutine，而因为此前&lt;em&gt;print_sum()&lt;/em&gt;与&lt;em&gt;compute()&lt;/em&gt;都被挂起了，因此事件循环会停下来等待协程的调度，当计时器读秒结束后，程序流便会返回到&lt;em&gt;compute()&lt;/em&gt;中执行return语句，结果会返回到&lt;em&gt;print_sum()&lt;/em&gt;中的result中，最后打印result，事件队列中没有可以调度的任务了，此时&lt;em&gt;loop.close()&lt;/em&gt;把事件队列关闭，程序结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;接下来我们采用异步和协程（ps:ccxt库也有对应的异步），运行后发现时间只用了1.9秒，比之前快了好多倍。　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
Run Time: 1.9661316871643066 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相关代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 引入库
import ccxt.async as ccxt
import asyncio
import time

now = lambda: time.time()
start = now()

async def getData(exchange, symbol):
    data = {}  # 用于存储ticker和depth信息
    # 获取ticker信息
    tickerInfo = await exchange.fetch_ticker(symbol)
    # 获取depth信息
    depth = {}
    # 获取深度信息
    exchange_depth = await exchange.fetch_order_book(symbol)
    # 获取asks,bids 最低5个，最高5个信息
    asks = exchange_depth.get('asks')[:5]
    bids = exchange_depth.get('bids')[:5]
    depth['asks'] = asks
    depth['bids'] = bids

    data['ticker'] = tickerInfo
    data['depth'] = depth

    return data

def main():
    # 实例化市场
    exchanges = [ccxt.binance(), ccxt.bitfinex2(), ccxt.okex(), ccxt.gdax()]
    # 交易对
    symbols = ['BTC/USDT', 'BTC/USD', 'BTC/USDT', 'BTC/USD']

    tasks = []
    for i in range(len(exchanges)):
        task = getData(exchanges[i], symbols[i])
        tasks.append(asyncio.ensure_future(task))

    loop = asyncio.get_event_loop()
    loop.run_until_complete(asyncio.wait(tasks))

if __name__ == '__main__':
    main()
    print('Run Time: %s' % (now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;三、定时爬取并用mongodb保存数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;在前面的基础上，添加一个定时任务，实现每隔一段时间爬取一次数据，并将数据保存到mongodb数据库。只需再前面的代码上稍微改改就可以啦，代码和运行结果如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import asyncio
import ccxt.async as ccxt
import time
import pymongo

# 获取ticker和depth信息
async def get_exchange_tickerDepth(exchange, symbol):  # 其中exchange为实例化后的市场
    # print('start get_ticker')
    while True:
        print('%s is run %s' % (exchange.id, time.ctime()))

        # 获取ticher信息
        tickerInfo = await exchange.fetch_ticker(symbol)
        ticker = tickerInfo.get('info')

        if type(ticker) == type({}):
            ticker['timestamp'] = tickerInfo.get('timestamp')
            ticker['high'] = tickerInfo.get('high')
            ticker['low'] = tickerInfo.get('low')
            ticker['last'] = tickerInfo.get('last')
        else:
            ticker = tickerInfo
        # print(ticker)

        # 获取深度信息
        depth = {}
        exchange_depth = await exchange.fetch_order_book(symbol)
        # 获取asks,bids 最低5个，最高5个信息
        asks = exchange_depth.get('asks')[:5]
        bids = exchange_depth.get('bids')[:5]
        depth['asks'] = asks
        depth['bids'] = bids
        # print('depth:{}'.format(depth))
        data = {
            'exchange': exchange.id,
            'countries': exchange.countries,
            'symbol': symbol,
            'ticker': ticker,
            'depth': depth
        }

        # 保存数据
        save_exchangeDate(exchange.id, data)
        print('********* %s is finished, time %s *********' % (exchange.id, time.ctime()))

        # 等待时间
        await asyncio.sleep(2)


# 存库
def save_exchangeDate(exchangeName, data):
    # 链接MongoDB
    connect = pymongo.MongoClient(host='localhost', port=27017)
    # 创建数据库
    exchangeData = connect['exchangeDataAsyncio']
    # 创建表
    exchangeInformation = exchangeData[exchangeName]
    # print(table_name)
    # 数据去重后保存
    count = exchangeInformation.count()
    if not count &amp;gt; 0:
        exchangeInformation.insert_one(data)
    else:
        for item in exchangeInformation.find().skip(count - 1):
            lastdata = item
        if lastdata['ticker']['timestamp'] != data['ticker']['timestamp']:
            exchangeInformation.insert_one(data)

def main():
    exchanges = [ccxt.binance(), ccxt.bitfinex2(), ccxt.okex(),
                  ccxt.gdax()]
    symbols = ['BTC/USDT', 'BTC/USD', 'BTC/USDT', 'BTC/USD']
    tasks = []
    for i in range(len(exchanges)):
        task = get_exchange_tickerDepth(exchanges[i], symbols[i])
        tasks.append(asyncio.ensure_future(task))

    loop = asyncio.get_event_loop()

    try:
        # print(asyncio.Task.all_tasks(loop))
        loop.run_forever()

    except Exception as e:
        print(e)
        loop.stop()
        loop.run_forever()
    finally:
        loop.close()

if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188959/201802/1188959-20180203210755265-1482658473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;使用协程可以实现高效的并发任务。Python在3.4中引入了协程的概念，可是这个还是以生成器对象为基础，3.5则确定了协程的语法。这里只简单的使用了asyncio。当然实现协程的不仅仅是asyncio，tornado和gevent都实现了类似的功能。这里我有一个问题，就是运行一段时间后，里面的市场可能有请求超时等情况导致协程停止运行，我要怎样才能获取到错误然后重启对应的协程。如果有大神知道的话请指点指点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、参考链接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Python黑魔法 --- 异步IO（ asyncio） 协程  &lt;a href=&quot;http://python.jobbole.com/87310/&quot; target=&quot;_blank&quot;&gt;http://python.jobbole.com/87310/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;Python并发编程之协程/异步IO  &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://www.ziwenxie.site/2016/12/19/python-asyncio/&quot; target=&quot;_blank&quot;&gt;https://www.ziwenxie.site/2016/12/19/python-asyncio/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;从0到1，Python异步编程的演进之路  &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25228075&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/25228075&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. &lt;/span&gt;&lt;span&gt;Tasks and coroutines  &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://docs.python.org/3/library/asyncio-task.html&quot; target=&quot;_blank&quot;&gt;https://docs.python.org/3/library/asyncio-task.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;























&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Feb 2018 12:42:00 +0000</pubDate>
<dc:creator>半夜打老虎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaxuexiaoab/p/8410682.html</dc:identifier>
</item>
<item>
<title>Protobuf 从入门到实战 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/8410589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/8410589.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;      从第一次接触Protobuf到实际使用已经有半年多，刚开始可能被它的名字所唬住，&lt;span&gt;其实就它是一种轻便高效的数据格式，平台无关、语言无关、可扩展，可用于&lt;strong&gt;通讯协议&lt;/strong&gt;和&lt;strong&gt;数据存储&lt;/strong&gt;等领域。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;
&lt;h2&gt;优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;平台无关，语言无关，可扩展；&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供了友好的动态库，使用简单；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解析速度快，比对应的XML快约20-100倍；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列化数据非常简洁、紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;使用详解&lt;/h2&gt;
&lt;h3&gt;1、服务器安装&lt;/h3&gt;
&lt;p&gt;安装依赖的库：     autoconf automake libtool curl make g++ unzip&lt;/p&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; $ ./autogen.sh
&lt;span&gt;  2&lt;/span&gt; $ ./configure
&lt;span&gt;  3&lt;/span&gt; $ make
&lt;span&gt;  4&lt;/span&gt; $ make check
&lt;span&gt;  5&lt;/span&gt; $ sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、 安卓客户端安卓&lt;/h3&gt;
&lt;p&gt;               下载相应版本jar包即可&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/&quot;&gt;。（csdn上上传了nano版本的jar包和exe文件）&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、 项目实战&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;       首先举一个服务端和客户端按照Protobuf协议进行数据数据传输的例子，工作流程如下图：（图下方深色部分为服务端部分，上方浅色部分为客户端部分）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/918077/201802/918077-20180203201730859-1335036836.png&quot;&gt;&lt;img width=&quot;765&quot; height=&quot;373&quot; title=&quot;PB协议工作流程 (2)&quot; alt=&quot;PB协议工作流程 (2)&quot; src=&quot;https://images2017.cnblogs.com/blog/918077/201802/918077-20180203201731109-1539557596.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、服务端和客户端约定他们使用PB协议作为数据传输和存储的工具，并约定传输信息的字段，如下：里面定义支付传输的字段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; syntax = &quot;&lt;span&gt;proto2&lt;/span&gt;&quot;;          &lt;span&gt;// PB协议版本&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &quot;&lt;span&gt;Common.proto&lt;/span&gt;&quot;;      &lt;span&gt;// 引入Common.proto，位于Protobuf sdk中&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; option optimize_for = LITE_RUNTIME;
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; option java_package = &quot;&lt;span&gt;com.xxxx.entity.pb&lt;/span&gt;&quot;;    &lt;span&gt;// 生成类的包名&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; option java_outer_classname = &quot;&lt;span&gt;PayInfo&lt;/span&gt;&quot;;       &lt;span&gt;// 生成类的类名&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; message PayInfo{
&lt;span&gt; 10&lt;/span&gt;        required string payid = 1;             &lt;span&gt;// 支付相关的字段信息&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;        optional string goodinfo = 2;          &lt;span&gt;// optional 为可选参数&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;        required string prepayid = 3;          &lt;span&gt;// required为必填参数&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;        optional string mode = 4;
&lt;span&gt; 14&lt;/span&gt;        optional &lt;span&gt;int&lt;/span&gt;  userid = 5;
&lt;span&gt; 15&lt;/span&gt;        repeated string  extra = 6;           &lt;span&gt;// repeated 为数组&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、通过Protobuf源码编译得到可运行程序（也可以在网上查找下载，注意PB协议的版本）。得到exe程序中可在windows下命令行窗口通过如下命令生成上述文件中定义的PayInfo.java文件。（protoc 为可执行的exe文件）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; protoc --java_out ./ ./PayInfo.proto
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、将生成PayInfo文件集成到项目代码中，同时需要引入 ProtoBuf的sdk（因为生成的Java类中引入了sdk中的类），可以在github上下载：&lt;a href=&quot;https://github.com/google/protobuf&quot;&gt;https://github.com/google/protobuf&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;4、服务端通过支付信息初始化PayInfo类，并调用ProtoBufSDK中 com.google.protobuf.nano 类的 toByteArray方法将PayInfo转化为字节数组，通过网络传输给客户端（可以进行加密和压缩操作，注意顺序）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] toByteArray(MessageNano msg) {
&lt;span&gt;  2&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[msg.getSerializedSize()];
&lt;span&gt;  3&lt;/span&gt;         toByteArray(msg, result, 0, result.length);
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; result;
&lt;span&gt;  5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5、客户端拿到字节数据后，通过集成的PayInfo.java文件对字节数据解析成PayInfo对象（通过程序生成的java文件都会自动生成这个函数）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; PayInfo parseFrom(&lt;span&gt;byte&lt;/span&gt;[] data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自此：客户端就顺利拿到了服务端发送的支付信息，可以通过他们调起支付宝或者微信客户端发起支付了。&lt;/p&gt;
&lt;p&gt;由此可以看出ProtoBuf只是一种协议，一种存储数据的格式&lt;span&gt;对应上面生成的字节数据的格式&lt;/span&gt;，任何语言的程序都可以通过本地类和jar包将字节数据解析成对象（语言/平台无关）。&lt;/p&gt;
&lt;p&gt;使用建议：&lt;/p&gt;
&lt;p&gt;1、通过编译程序生成.java文件有不同的版本，建议使用nano版本（3.0之后的PB协议才发布该版本），这种版本生成的java文件方法数较少（没有set，get等函数），对APK的体积影响更小。命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; protoc_3.1.0.exe  --javanano_out ./ ./GetConfig.proto
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、不管用2.0还是3.0还是nano版本还是非精简版最终生成的字节数据文件是相同的，不影响前后端的交互。&lt;/p&gt;
&lt;h2&gt;与其它数据格式比较&lt;/h2&gt;
&lt;p&gt;     Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。&lt;/p&gt;
&lt;p&gt;     和其它数据协议的比较如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/918077/201802/918077-20180203210241125-2020580326.png&quot;&gt;&lt;img width=&quot;689&quot; height=&quot;339&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://images2017.cnblogs.com/blog/918077/201802/918077-20180203210241328-2108721771.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;        作为开发者使用protobuf简单高效，至于里面具体如何实现深层次的东西我们还不如花点时间学一下数据结构。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://developers.google.com/protocol-buffers/&quot; href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;https://developers.google.com/protocol-buffers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Feb 2018 12:02:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/8410589.html</dc:identifier>
</item>
</channel>
</rss>