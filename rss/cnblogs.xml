<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Zookeeper系列四：Zookeeper在大型分布式系统中的应用、Zookeeper实现分布式锁 - 小不点啊</title>
<link>http://www.cnblogs.com/leeSmall/p/9588533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leeSmall/p/9588533.html</guid>
<description>&lt;p&gt;1. 有些分布式系统是master-slave模式的，master是一个单节点，一旦master挂掉了整个集群就挂掉了，所以一般master都会有一个备份master-back，一旦master挂掉了，备份master就会顶上去&lt;/p&gt;
&lt;p&gt;那么ZK是如何实现的呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;前置条件：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;统一的一个临时节点：TemporaryNode（/ds/TemporaryNode仅仅这样一个节点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一步：zk有这样一个持久节点/ds&lt;/p&gt;
&lt;p&gt;第二步：master1和master2同时启动，同时向/ds这个持久节点申请创建临时子节点TemporaryNode（同一时间只有一个请求能够创建成功）。&lt;/p&gt;
&lt;p&gt;如果master1创建成功，这个节点（TemporaryNode）就不允许master2创建（锁的机制）&lt;/p&gt;
&lt;p&gt;master1的状态变为active，真正的master。路径：/ds/TemporaryNode&lt;/p&gt;
&lt;p&gt;master2的状态变为standby（master-back）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master2同时对节点/ds/TemporaryNode注册事件监听。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三步：master1挂掉或者超过一定时间没有响应。TemporaryNode节点会被删除（master2注册的事件机制就会起作用），就会通知master2，master2就会创建临时节点/ds/TemporaryNode，同时修改状态为active。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假如master1并没有挂掉，只有由于网络延时导致，当网络顺畅的时候就会出现&lt;strong&gt;&lt;span&gt;“脑裂”&lt;/span&gt;&lt;/strong&gt;状态。都认为自己是active。出现两个master&lt;/p&gt;
&lt;p&gt;解决脑裂的办法：对/ds/TemporaryNode加一个权限ACL控制（节点删除以后，权限同时也不在了）。master1对于这个节点/ds/TemporaryNode没有权限。自己把状态改成standby。&lt;/p&gt;
&lt;p&gt;实际的案例1：Hadoop（NameNode、ResourceManager），普通的部署NameNode、ResourceManager仅仅是单节点。Hadoop HA（NameNode和ResourceManager有多个备份）&lt;/p&gt;

&lt;p&gt;分布式锁主要用于在分布式环境中包括跨主机、跨进程、跨网络，导致共享资源不一致的问题，保证数据的一致性。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1. 分布式锁的实现思路&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1227483/201809/1227483-20180904210313049-1730833494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这种实现会有一个缺点，即当有很多进程在等待锁的时候，在释放锁的时候会有很多进程就过来争夺锁，这种现象称为 &lt;strong&gt;&lt;span&gt;“惊群效应”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2. 分布式锁优化后的实现思路&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1227483/201809/1227483-20180904222105722-328998635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. Zookeeper分布式锁的代码实现&lt;/h2&gt;
&lt;p&gt;准备工作：&lt;/p&gt;
&lt;p&gt;1）安装Zookeeper，具体参考我前面的我文章&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/leeSmall/p/9563547.html&quot;&gt;Zookeeper系列一：Zookeeper介绍、Zookeeper安装配置、ZK Shell的使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2）新建一个maven项目ZK-Demo,然后在pom.xml里面引入相关的依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.101tec&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;zkclient&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.1 Zookeeper分布式锁的核心代码实现&lt;/h3&gt;
&lt;p&gt;实现逻辑参考“&lt;strong&gt;2. 分布式锁优化后的实现思路&lt;/strong&gt;”中的流程图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.study.demo.lock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.I0Itec.zkclient.IZkDataListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.I0Itec.zkclient.ZkClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.I0Itec.zkclient.serialize.SerializableSerializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 
* @Description: Zookeeper分布式锁的核心代码实现
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; leeSmall
* @date 2018年9月4日
*
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DistributedLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Lock {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(DistributedLock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ZOOKEEPER_IP_PORT = &quot;192.168.152.130:2181&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String LOCK_PATH = &quot;/LOCK&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ZkClient client = &lt;span&gt;new&lt;/span&gt; ZkClient(ZOOKEEPER_IP_PORT, 4000, 4000, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SerializableSerializer());

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountDownLatch cdl;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String beforePath;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前请求的节点前一个节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String currentPath;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前请求的节点

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断有没有LOCK目录，没有则创建&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DistributedLock() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.exists(LOCK_PATH)) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.createPersistent(LOCK_PATH);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试去获取分布式锁失败&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tryLock()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对次小节点进行监听&lt;/span&gt;
&lt;span&gt;            waitForLock();
            lock();
        } 
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            logger.info(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 获得分布式锁！&quot;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; tryLock() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果currentPath为空则为第一次尝试加锁，第一次加锁赋值currentPath&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (currentPath == &lt;span&gt;null&lt;/span&gt; || currentPath.length() &amp;lt;= 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个临时顺序节点&lt;/span&gt;
            currentPath = &lt;span&gt;this&lt;/span&gt;.client.createEphemeralSequential(LOCK_PATH + '/', &quot;lock&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;----------------------------&amp;gt;&quot; +&lt;span&gt; currentPath);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有临时节点并排序，临时节点名称为自增长的字符串如：0000000400&lt;/span&gt;
        List&amp;lt;String&amp;gt; childrens = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.getChildren(LOCK_PATH);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由小到大排序所有子节点&lt;/span&gt;
&lt;span&gt;        Collections.sort(childrens);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断创建的子节点/LOCK/Node-n是否最小,即currentPath,如果当前节点等于childrens中的最小的一个就占用锁&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (currentPath.equals(LOCK_PATH + '/' + childrens.get(0&lt;span&gt;))) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出比创建的临时顺序节子节点/LOCK/Node-n次小的节点,并赋值给beforePath&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wz = Collections.binarySearch(childrens, currentPath.substring(6&lt;span&gt;));
            beforePath &lt;/span&gt;= LOCK_PATH + '/' + childrens.get(wz - 1&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待锁,对次小节点进行监听&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; waitForLock() {
        IZkDataListener listener &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IZkDataListener() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDataDeleted(String dataPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                logger.info(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:捕获到DataDelete事件！---------------------------&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cdl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    cdl.countDown();
                }
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDataChange(String dataPath, Object data) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

            }
        };

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对次小节点进行监听,即beforePath-给排在前面的的节点增加数据删除的watcher&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.subscribeDataChanges(beforePath, listener);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.exists(beforePath)) {
            cdl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CountDownLatch(1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                cdl.await();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client.unsubscribeDataChanges(beforePath, listener);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成业务逻辑以后释放锁&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除当前临时节点&lt;/span&gt;
&lt;span&gt;        client.delete(currentPath);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ==========================================&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lockInterruptibly() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Condition newCondition() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.2 在业务里面使用分布式锁&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.study.demo.lock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 
* @Description: 在业务里面使用分布式锁
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; leeSmall
* @date 2018年9月4日
*
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OrderCodeGenerator ong = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderCodeGenerator();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(OrderServiceImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同时并发的线程数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NUM = 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照线程数初始化倒计数器,倒计数器&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CountDownLatch cdl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(NUM);

    &lt;/span&gt;&lt;span&gt;&lt;strong&gt;private Lock lock = new DistributedLock();

    &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建订单接口&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createOrder() {
        String orderCode &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备获取锁&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取订单编号&lt;/span&gt;
            orderCode =&lt;span&gt; ong.getOrderCode();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
        } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成业务逻辑以后释放锁&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;            lock.unlock();&lt;/span&gt;&lt;/strong&gt;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ……业务代码&lt;/span&gt;
&lt;span&gt;
        logger.info(&lt;/span&gt;&quot;insert into DB使用id：=======================&amp;gt;&quot; +&lt;span&gt; orderCode);
    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待其他线程初始化&lt;/span&gt;
&lt;span&gt;            cdl.await();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建订单&lt;/span&gt;
&lt;span&gt;        createOrder();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= NUM; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照线程数迭代实例化线程&lt;/span&gt;
            &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderServiceImpl()).start();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个线程，倒计数器减1&lt;/span&gt;
&lt;span&gt;            cdl.countDown();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.study.demo.lock;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderCodeGenerator {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自增长序列&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照“年-月-日-小时-分钟-秒-自增长序列”的规则生成订单编号&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getOrderCode() {
        Date now &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        SimpleDateFormat sdf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sdf.format(now) + ++&lt;span&gt;i;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 08 Sep 2018 07:33:00 +0000</pubDate>
<dc:creator>小不点啊</dc:creator>
<og:description>一、Zookeeper在大型分布式系统中的应用 1. 有些分布式系统是master-slave模式的，master是一个单节点，一旦master挂掉了整个集群就挂掉了，所以一般master都会有一个备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leeSmall/p/9588533.html</dc:identifier>
</item>
<item>
<title>一统江湖的大前端(1)——PPT制作库impress.js - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9609301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9609301.html</guid>
<description>&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;《一统江湖的大前端》系列是自己的学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，前端能做的事情已经太多了, &lt;code&gt;手机app开发&lt;/code&gt; , &lt;code&gt;桌面应用开发&lt;/code&gt; , &lt;code&gt;用于神经网络人工智能的库&lt;/code&gt; , &lt;code&gt;页面游戏&lt;/code&gt; , &lt;code&gt;数据可视化&lt;/code&gt; , 甚至 &lt;code&gt;嵌入式开发&lt;/code&gt; ，什么火就搞什么,绝对是专业的&lt;strong&gt;蹭热点小能手&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/03/7d9c4c007f2c23a5979c3243e26d61a8.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;impress.js是什么&quot;&gt;impress.js是什么&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;impress.js&lt;/code&gt; 是一款基于 &lt;code&gt;css-3D&lt;/code&gt; 和 &lt;code&gt;css动画&lt;/code&gt; 、受到高逼格PPT原型工具 &lt;code&gt;prezi&lt;/code&gt; 启发而开发的&lt;strong&gt;演示文稿制作库&lt;/strong&gt;,github上星星高达&lt;strong&gt;33k&lt;/strong&gt;个,如果你已经厌烦了使用PowerPoint制作&lt;em&gt;连自己都觉得丑&lt;/em&gt;的PPT，那么 &lt;code&gt;impress.js&lt;/code&gt; 是一个非常好的选择，简洁高效逼格高。&lt;/p&gt;
&lt;p&gt;获取impress.js库文件及官方示例请点击&lt;a href=&quot;https://github.com/impress/impress.js&quot;&gt;impress.js地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关键api&quot;&gt;关键API&lt;/h2&gt;
&lt;p&gt;下述api用于HTML标签属性，学习时直接对照官方代码仓中的example走一遍，看一遍示例代码，基本都能学会。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;data-x = 幻灯片的x坐标&lt;/li&gt;
&lt;li&gt;data-y = 幻灯片的y坐标&lt;/li&gt;
&lt;li&gt;data-scale = 通过指定一个值来进行缩放，data-scale为5则将会在你幻灯片原始尺寸基础放大5倍&lt;/li&gt;
&lt;li&gt;data-rotate = 通过一个数字度数来确定旋转你的幻灯片&lt;/li&gt;
&lt;li&gt;data-rotate-x = 为3D用，这个数字度数是它应该相对x轴旋转多少度。（前倾/后仰）&lt;/li&gt;
&lt;li&gt;data-rotate-y = 为3D用，这个数字度数是它应该相对y轴旋转多少度。 （左摆/右摆）&lt;/li&gt;
&lt;li&gt;data-rotate-z = 为3D用，这个数字度数是它应该相对z轴旋转多少度。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实战示例&quot;&gt;实战示例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/03/776f91e8a31ca2b32bffb92b27cc9ca8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附件中的 &lt;code&gt;CSS-presentation&lt;/code&gt; 可通过双击文件中的index.html直接打开，是自己以前在做团队内部分享时使用 &lt;code&gt;impress.js&lt;/code&gt;制作的幻灯片，时间较短，直接套用了官方示例并对个别细节进行了调整，放出来方便大家参考交流.&lt;/p&gt;
&lt;h2 id=&quot;相关原理&quot;&gt;相关原理&lt;/h2&gt;
&lt;p&gt;impress.js的框架原理并不复杂，写在html标签上的属性可以通过 &lt;code&gt;document.querySelector('元素名').dataset[&quot;属性名&quot;]&lt;/code&gt;的方式取得其值,然后将每一张幻灯片相关的值赋值给CSS3D相关的属性，并为其设定过渡时的渐变动画即可。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CSS3D是指transition渐变，animation动画以及transform变形&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 08 Sep 2018 07:24:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>《一统江湖的大前端》系列是自己的学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，前端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9609301.html</dc:identifier>
</item>
<item>
<title>归纳与递归 - VisualGMQ</title>
<link>http://www.cnblogs.com/learn-program/p/9605584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learn-program/p/9605584.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p id=&quot;1&quot;&gt;&lt;span&gt;数学归纳法介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数学归纳法是一种强有力的证明工具。数学归纳法是用来证明定理的工具，但是却不能发现定理。也就是说数学归纳法是一种证明手段。&lt;/p&gt;
&lt;p&gt;数学归纳法高中我们也曾学习过，那个时候学习的是不完全归纳法。在离散数学中，我们会学习三种数学归纳法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不完全归纳法（即高中说明的归纳法）&lt;/li&gt;
&lt;li&gt;强归纳法&lt;/li&gt;
&lt;li&gt;结构归纳法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里还会有一些关于递归的知识以及数学归纳法的一些有趣的应用。&lt;/p&gt;
&lt;p&gt;本章的参考书籍是《离散数学及其应用》。&lt;/p&gt;
&lt;hr/&gt;&lt;p id=&quot;2&quot;&gt;&lt;span&gt;不完全归纳法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先来看看我们都熟悉的不完全归纳法，一般我们就称其为数学归纳法。&lt;/p&gt;
&lt;p&gt;关于不完全归纳法，虽然名字有“不完全”三个字，但是这种归纳法恰恰不是不完全的。这种命名只是出于无奈：因为强归纳法也被称为完全归纳法，所以这里的归纳法就被称为不完全归纳法了😊。&lt;/p&gt;
&lt;p&gt;对于不完全归纳法，大多书上都是以多米诺骨牌来说明的。我们这里使用爬梯子的方式来说明一下：&lt;/p&gt;
&lt;p&gt;对于有n节的梯子，我们想要从第一节爬到第n节，可以使用如下的方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以爬到第一节&lt;/li&gt;
&lt;li&gt;如果可以爬到第k节，那么我们可以爬到第k+1节&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在我们先假设以上两句都成立，这样可以使用递归的方式来爬到第n节楼梯：首先可以爬到第1节楼梯，然后令k=1，由第二句可知我们可以爬到第2节，再令k=2，则可以爬到第3节。以此类推就可以爬到第n节了。&lt;/p&gt;

&lt;p id=&quot;3&quot;&gt;&lt;span&gt;不完全归纳法定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上两个爬楼梯的步骤其实就是使用数学归纳法描述的。不完全归纳法的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了证明对所有的正整数n，P(n)为真，其中P(n)为一个命题函数，需要完成两个步骤的证明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：证明P(1)为真&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归纳步骤：证明对每个整数k来说，蕴含式P(k)→P(K+1)成立。其中P(k)为归纳假设。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个定义想必大家都很熟悉啦，就是将高中的归纳法定义用离散的语言叙述了一下呗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于上面的楼梯问题来说，P(n)就是“能够爬到第n节楼梯”。那么首先证明能够爬到第一节楼梯，即P(1)，然后证明在可以达到P(k)的情况下，可以达到P(k+1)节阶梯。完成以上两个证明就可以达到任意节楼梯啦。&lt;/p&gt;
&lt;p&gt;上面的例子是个抽象的生活实例，下面我们给出一些数学上使用不完全归纳法的证明题目：&lt;/p&gt;

&lt;p id=&quot;4&quot;&gt;&lt;span&gt;不完全归纳法实例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于求和公式的证明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不完全归纳的一个用途广泛的地方就是在对求和公式的证明。不过需要注意的是，由于数学归纳法只能用来证明，而不是用来发现定理的，所以想要通过数学归纳法来获得公式是不可能的。只能证明现有公式的正确性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1：&lt;/span&gt;证明求和公式1+2+3+...+n=n(n+1)/2是正确的&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_61b2b49e-7af8-48c0-8fd4-e800389bd195&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61b2b49e-7af8-48c0-8fd4-e800389bd195&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61b2b49e-7af8-48c0-8fd4-e800389bd195&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
　　首先命题函数P(n)是“&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;+...+n=n(n+&lt;span&gt;1&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;”，那么首先是基础步骤：

　　　　基础步骤：证明P(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)为真

　　　　　　由于P(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)为1=&lt;span&gt;1&lt;/span&gt;*(&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;，等式左右两边相等，命题得证。

　　　　归纳步骤：证明在P(k)成立的时候，P(k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)为真

　　　　　　P(k)为:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;+...+k=k(k+&lt;span&gt;1&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;

　　　　　　P(k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)为:&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;+..+k+&lt;span&gt;1&lt;/span&gt;=(k+&lt;span&gt;1&lt;/span&gt;)(k+&lt;span&gt;2&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;

　　　这里需要想办法将P(k)变成P(k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)，很简单，在P(k)左右两边加上k+&lt;span&gt;1即可，那么就是：

　　　　P(k)&lt;/span&gt;+k+&lt;span&gt;1&lt;/span&gt;=k(k+&lt;span&gt;1&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;+k+&lt;span&gt;1&lt;/span&gt;=(k+&lt;span&gt;1&lt;/span&gt;)(k+&lt;span&gt;2&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;=P(k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

　　　由于P(k)变成P(k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)之后右式等于P(k+&lt;span&gt;1&lt;/span&gt;)的右式。又由于P(k)是真的，所以P(k+&lt;span&gt;1&lt;/span&gt;)为真，命题得证。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;证明&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;证明求和公式的题目还有很多，这里先列举一个，其他的题目和这个差不多，只是可能会多一些技巧。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于不等式的证明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：&lt;span&gt;证明n&amp;lt;2^n对所有正整数成立&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_fc463eff-fd38-49a9-9910-282814ff8384&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fc463eff-fd38-49a9-9910-282814ff8384&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fc463eff-fd38-49a9-9910-282814ff8384&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
P(n)为&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&amp;lt;2^n对所有正整数成立&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

　　基础步骤：P(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)为1&amp;lt;&lt;span&gt;2&lt;/span&gt;^&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;2成立

　　归纳步骤：P(k)为k&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;^k；P(k+&lt;span&gt;1&lt;/span&gt;)为 k+&lt;span&gt;1&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;^(k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

　　　　将P(k)转化为P(k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)，两边加上1，则

　　　　P(k)&lt;/span&gt;+1为k+&lt;span&gt;1&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;^k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

　　　　又由于2&lt;/span&gt;^k+&lt;span&gt;1&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;(k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

　　　　所以k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;^k+&lt;span&gt;1&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;^(k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

　　　即k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&amp;lt;&lt;span&gt;2&lt;/span&gt;^(k+&lt;span&gt;1&lt;/span&gt;)成立，P(k+&lt;span&gt;1&lt;/span&gt;)成立，命题得证。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;证明&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对于整除问题的证明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种整除问题高中也是难倒了我一段时间啊，这里我们来看看这种题怎么解吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例3：&lt;span&gt;当n为整数时，证明n^3-n可被3整除&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7cb18d97-4b03-45b4-8d92-1c8443a015be&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7cb18d97-4b03-45b4-8d92-1c8443a015be&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7cb18d97-4b03-45b4-8d92-1c8443a015be&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
基础步骤：P(&lt;span&gt;1&lt;/span&gt;)为1^&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0可以被3整除
归纳步骤：P(k)为k&lt;/span&gt;^&lt;span&gt;3&lt;/span&gt;-k,P(k+&lt;span&gt;1&lt;/span&gt;)为(k+&lt;span&gt;1&lt;/span&gt;)^&lt;span&gt;3&lt;/span&gt;-(k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
               展开(k&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)^&lt;span&gt;3&lt;/span&gt;-(k+&lt;span&gt;1&lt;/span&gt;)得k^&lt;span&gt;3&lt;/span&gt;+3k^&lt;span&gt;2&lt;/span&gt;+3k+&lt;span&gt;1&lt;/span&gt;-k-&lt;span&gt;1&lt;/span&gt;=（k^&lt;span&gt;3&lt;/span&gt;-k)+&lt;span&gt;3&lt;/span&gt;*(k^&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;k)
可知这个式子能被3整除，证毕。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;证明&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 归纳法的奇特应用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数学归纳法有时候可以在一些意想不到的场合使用，来看看下面的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例4：&lt;span&gt;使用右三联骨牌可以覆盖一个2^n × 2^n棋盘并且让棋盘只留下一个空格&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908130505996-1745652447.png&quot; alt=&quot;&quot;/&gt;　　这个就是右三联骨牌，进行旋转的话还可以得到另外三种：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908130604632-1838667927.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908130635468-1175976075.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908130841818-548798850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 那么首先来证明P(1)的情况&lt;/p&gt;
&lt;p&gt;基础步骤：当k=1的时候，棋盘为2 × 2的，那么只需要上面任何一个骨牌就可以覆盖，命题的证。&lt;/p&gt;
&lt;p&gt;归纳步骤：在2^k × 2^k的棋盘下满足条件，那么2^(k+1) × 2^(k+1)也可以满足条件&lt;/p&gt;
&lt;p&gt;　　我们将整个棋盘分为四份： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908131619015-1038744393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 由P(k)知，右下角的子棋盘一定可以使用骨牌的只剩下一个空格：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908131712687-856012183.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们这样放上一个骨牌： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1471835/201809/1471835-20180908131919454-1891496704.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的话剩下的三个棋盘中多出的空格就被填满了，这样由P(k)知可以全部填满。所以最后整个棋盘只会剩下有下家一块空格，命题得证。&lt;/p&gt;

&lt;hr/&gt;&lt;p id=&quot;5&quot;&gt;&lt;span&gt;强归纳法（完全归纳法）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有些时候使用不完全归纳法不容易证明一些命题，这个时候我们可以考虑强归纳法来证明。&lt;/p&gt;

&lt;p id=&quot;6&quot;&gt;&lt;span&gt;强归纳法的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要证明对于所有的正整数n而言，都有P(n)为真，其中P(n)为命题函数，我们需要证明以下两个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　P(1)成立&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归纳步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于所有的正整数 n来说，蕴含式[P(1)∧P(2)∧P(3)∧...∧P(k)]→P(k+1)成立。其中P(1)∧P(2)∧P(3)∧...∧P(k)为归纳假设。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意到强归纳法和不完全归纳法只在归纳步骤上有区别。不完全归纳法是从P(k)推导到P(k+1)。而强归纳法则是从前P(k)个条件推导到P(k+1)个条件。&lt;/p&gt;
&lt;p&gt;有些时候强归纳法毕不完全归纳法更好用。所以我们使用归纳法的顺序是先想到强归纳法，再想到不完全归纳法。&lt;/p&gt;

&lt;p id=&quot;7&quot;&gt;&lt;span&gt;强归纳法的一些实例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例1：&lt;span&gt;证明若n是大于1的整数，则n可以写成素数之积&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_102d863e-dd4e-44b5-a26e-6e30745a36fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_102d863e-dd4e-44b5-a26e-6e30745a36fa&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_102d863e-dd4e-44b5-a26e-6e30745a36fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;基本步骤：

　　对于2来说，显然其本身就是素数

归纳步骤：

　　如果k&lt;/span&gt;+&lt;span&gt;1是素数，那么显然其本身就是素数，命题成立。

　　如果k&lt;/span&gt;+1是合数，那么一定存在i，j满足2&amp;lt;=i&amp;lt;=j&amp;lt;k+1且k+&lt;span&gt;1&lt;/span&gt;=i*j。因为i，j都小于等于k，所以由P(k)的正确性知道i，j都可以写成素数之积。那么k+1可以写成素数之积，那么P(k+&lt;span&gt;1&lt;/span&gt;)成立
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;证明&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;也可以使用强归纳法来证明一些生活中的问题&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例2：&lt;span&gt;考虑一个取火柴的游戏，其中两名选手轮流从两堆火柴中的一对取出任意数目整数的火柴，取走最后一根火柴的人获胜。求证：当每堆开始有n根火柴的时候，后手一定会赢。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个题目的意思就是说，有两堆数量一样的火柴，有两名选手从其中取火柴，但是一次只能在一个火柴堆中取。最后将所有火柴都取走的人获胜。要求证明第二步走的人一定会获胜。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4d59f4a9-995b-4cde-8489-a960e3800fd8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4d59f4a9-995b-4cde-8489-a960e3800fd8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4d59f4a9-995b-4cde-8489-a960e3800fd8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;基础步骤：

　　当n&lt;/span&gt;=&lt;span&gt;1的时候，先手只有一种选择：从两个火柴堆里面选一个拿完（因为每个火柴堆只有一根火柴）。这个时候后手就可以将另外一根火柴拿走了。命题得证。

归纳步骤：

　　首先归纳假设是当一堆火柴有i个火柴（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;=i&amp;lt;=k）的时候命题得证。现在需要证明每堆有k+1根火柴的时候命题的证。这个时候假如先手拿了r根火柴，后手可以在另外一堆例同样拿r根火柴。这样两堆的火柴数就是k+&lt;span&gt;1&lt;/span&gt;-r(&lt;span&gt;1&lt;/span&gt;&amp;lt;=k+&lt;span&gt;1&lt;/span&gt;-r&amp;lt;=k)，这个时候条件就变成了归纳假设的条件。由归纳假设可知命题为真。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;证明&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p id=&quot;8&quot;&gt;&lt;span&gt;递归定义和结构归纳法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓递归定义，相信每个学计算机的都知道，就是在定义自己的时候在自己的定义里面再次使用自己的定义。&lt;/span&gt;&lt;/p&gt;

&lt;p id=&quot;9&quot;&gt;&lt;span&gt;递归定义函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：规定这个函数在0处的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递归步骤：给出从较小值求出当前值的规则&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在数学里面其实就是复合函数啦。最最有名的递归定义函数就是裴波那契数列啦：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;裴波那契数f0,f1,f2...是用方程组f0=0,f1=1,fn=fn-1+fn-2来递归定义的函数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;递归定义结构和集合：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;像是递归定义函数一样，递归定义集合和结构也是有基础步骤和递归步骤的。看看下面三个递归定义：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定义1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考虑如下定义的整数集合的子集S：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：3∈S&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递归步骤：若x∈S且y∈S，那么x+y∈S&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个递归定义定义了一个数集，其中包括3，6，9，12等等数。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;定义2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字母表A上的字符串集合A'递归的定义成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：空串λ∈A'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递归步骤：如果ω∈A'且x∈A，那么ωx∈A。这里ωx为字符串的连接，指将x串连接在ω串后面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里递归的定义了字符串。&lt;/p&gt;

&lt;p&gt;在数据结构中有很多递归的定义，包括链表的结构体定义，二叉树的结构体定义和图的邻接表定义。可以看出递归定义在计算机中还是有重要的地位的。&lt;/p&gt;

&lt;p id=&quot;10&quot;&gt;&lt;span&gt;结构归纳法的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构归纳法是专门用于证明递归结构定义的一种归纳法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基础步骤：证明对于递归定义的基础步骤所规定的属于该集合的所有元素来说，结果成立&lt;/p&gt;
&lt;p&gt;归纳步骤：证明如果对于定义的递归步骤中用来构造新元素的每个元素来说命题为真，那么对于这些新元素来说结果成立。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;结构归纳法的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里举个例子来说明结构归纳法如何证明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先来看一下关于满二叉树的一些递归定义：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;满二叉树：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：存在一个只有单个定点的满二叉树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归纳步骤：如果T1，T2都是满二叉树，则存在一个表示为T1 • T2的满二叉树，它包含树根r和连接从r到左子树T1和右子树T2的边&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;满二叉树高度h(T&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：只含有树根r的满二叉树T的高度是h(T)=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;归纳步骤：如果T1，T2都是满二叉树，则满二叉树T=T1 • T2有高度h(T)=1+max(h(T1),h(T2))&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;定义满二叉树节点数目n(T)：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础步骤：只含有树根r的满二叉树T的高度h(T)=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;递归步骤：如果T1，T2都是满二叉树，则满二叉树T1 • T2的节点数是n(T)=1+n(T1)+n(T2)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果T为满二叉树，那么证明n(T)&amp;lt;=2^[h(T)+1]-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_0679763b-81d7-44af-858b-c302eff5a7ee&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0679763b-81d7-44af-858b-c302eff5a7ee&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0679763b-81d7-44af-858b-c302eff5a7ee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
基础步骤：当T只有树根时，n(T)=&lt;span&gt;1&lt;/span&gt;&amp;lt;=&lt;span&gt;2&lt;/span&gt;^(&lt;span&gt;0&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)-&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;1成立

归纳步骤：对于归纳假设，当T1和T2都是满二叉树的时候，n(T1)&lt;/span&gt;&amp;lt;=&lt;span&gt;2&lt;/span&gt;^[h(T1)+&lt;span&gt;1&lt;/span&gt;]-1且n(T2)&amp;lt;=&lt;span&gt;2&lt;/span&gt;^[h(T2)+&lt;span&gt;1&lt;/span&gt;]-1成立。根据n(T)和h(T)的递归公式知道n(T)=&lt;span&gt;1&lt;/span&gt;+n(T1)+n(T2)，h(T)=&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;max(h(T1),h(T2))。带入公式知道：

n(T)&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;+n(T1)+&lt;span&gt;n(T2)

　　&lt;/span&gt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;+(&lt;span&gt;2&lt;/span&gt;^[h(T1)+&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;)+(&lt;span&gt;2&lt;/span&gt;^[h(T2)+&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

　　&lt;/span&gt;&amp;lt;=&lt;span&gt;2&lt;/span&gt;*max(&lt;span&gt;2&lt;/span&gt;^[h(T1)+&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;^[h(T2)+&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;) -&lt;span&gt;1&lt;/span&gt;

　　&amp;lt;=&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;^max(&lt;span&gt;2&lt;/span&gt;^[h(T1)+&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;^[h(T2)+&lt;span&gt;1&lt;/span&gt;]-&lt;span&gt;1&lt;/span&gt;) -&lt;span&gt;1&lt;/span&gt;

　　=&lt;span&gt;2&lt;/span&gt;^[h(T)+&lt;span&gt;1&lt;/span&gt;] -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

命题成立&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;证明&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 08 Sep 2018 07:24:00 +0000</pubDate>
<dc:creator>VisualGMQ</dc:creator>
<og:description>对于离散数学——归纳与递归的学习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learn-program/p/9605584.html</dc:identifier>
</item>
<item>
<title>洛谷P4774 BZOJ5418 LOJ2721 [NOI2018]屠龙勇士（扩展中国剩余定理） - ATS_nantf</title>
<link>http://www.cnblogs.com/1000Suns/p/9608901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1000Suns/p/9608901.html</guid>
<description>&lt;p&gt;题目链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4774&quot; target=&quot;_blank&quot;&gt;洛谷&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=5418&quot; target=&quot;_blank&quot;&gt;BZOJ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/2721&quot; target=&quot;_blank&quot;&gt;LOJ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：&lt;span&gt;这么长的题面，就饶了我吧&lt;/span&gt;emmm&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这题第一眼看上去没法列出同余方程组。为什么？好像不知道用哪把剑杀哪条龙……&lt;/p&gt;
&lt;p&gt;仔细一看，要&lt;strong&gt;按顺序&lt;/strong&gt;杀龙，所以获得的剑出现的顺序也是固定的。&lt;/p&gt;
&lt;p&gt;那么如果能把所有龙杀死，就能模拟出哪把剑杀那条龙了。&lt;/p&gt;
&lt;p&gt;（以下设所有除 $n,m$ 外的数的最大值为 $v$）&lt;/p&gt;
&lt;p&gt;$O(nm)$？&lt;/p&gt;
&lt;p&gt;不，发现这里用剑的限制实际上是给出一个上界，来用lower_bound的。&lt;/p&gt;
&lt;p&gt;插入也不要太暴力。我们想到什么？&lt;span&gt;手写平衡树&lt;/span&gt;multiset！&lt;/p&gt;
&lt;p&gt;这一部分复杂度是 $O(n\log m)$。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接下来就成了一个同余方程组：$atk_ix\equiv hp_i(\operatorname{mod}\ rec_i)$。&lt;/p&gt;
&lt;p&gt;（$atk_i$ 表示攻击第 $i$ 条龙的攻击力，$hp_i$ 表示第 $i$ 条龙的血量，$rec_i$ 表示第 $i$ 条龙的恢复能力）&lt;/p&gt;
&lt;p&gt;但是好像没那么简单！有一些神奇的情况……要特判！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在考场上的话我肯定想不到特判任何东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先大家应该都知道，$x\equiv a_i(\operatorname{mod}\ b_i)$ 等价于 $x\equiv a_i\ \operatorname{mod}\ b_i(\operatorname{mod}\ b_i)$。&lt;/p&gt;
&lt;p&gt;但是在这题中不行！你总不能把一头龙的血量凭空减少吧！&lt;/p&gt;
&lt;p&gt;所以 $hp_i&amp;gt;rec_i$ 时（题目描述中的特性1不满足时）怎么办？&lt;/p&gt;
&lt;p&gt;我们发现不满足特性1的点都满足 $rec_i=1$……也就是只要把他的血量打到小于0就赢了！&lt;/p&gt;
&lt;p&gt;此时答案是 $\max\limits_{1\le i\le n}(\lceil\frac{hp_i}{atk_i}\rceil)$。&lt;/p&gt;
&lt;p&gt;另外在所有 $hp_i=rec_i$ 时我们解出来的解是0！什么神奇的气功？&lt;/p&gt;
&lt;p&gt;所以这是答案是所有 $\lceil\frac{hp_i}{atk_i}\rceil$ 的 $\operatorname{lcm}$。&lt;/p&gt;
&lt;p&gt;至此所有特判结束。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们一般的EXCRT同余方程组的形式是 $x\equiv a_i(\operatorname{mod}\ b_i)$。&lt;/p&gt;
&lt;p&gt;但是这里有讨厌的 $atk_i$！更讨厌的是可能没有逆元，不能直接除过去！&lt;/p&gt;
&lt;p&gt;我们来看看如何变形：&lt;/p&gt;
&lt;p&gt;$atk_ix\equiv hp_i(\operatorname{mod}\ rec_i)$&lt;/p&gt;
&lt;p&gt;$atk_ix+rec_iy=hp_i$&lt;/p&gt;
&lt;p&gt;此时可以EXGCD解出 $x$ 的最小正整数解 $x_0$。&lt;/p&gt;
&lt;p&gt;根据某定理（什么定理来着？）可得通解为 $x=x_0+\frac{rec_i}{\gcd(atk_i,rec_i)}k(k\in N^+)$。&lt;/p&gt;
&lt;p&gt;于是就变成了 $x\equiv x_0(\operatorname{mod}\ \frac{rec_i}{\gcd{atk_i},rec_i})$。&lt;/p&gt;
&lt;p&gt;这一部分复杂度为 $O(n\log v)$。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接下来就是裸的EXCRT了！&lt;/p&gt;
&lt;p&gt;这一部分复杂度为 $O(n\log v)$。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;等一下，还有一句提示没看到：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你所用到的中间结果可能很大，注意保存中间结果的变量类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;突然慌张&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;冷静分析一下，我们在各种算法中模数都有可能超过int范围，要是一乘……&lt;/p&gt;
&lt;p&gt;那……只能上龟速乘了。时间复杂度是没变，但是常数的话……&lt;/p&gt;
&lt;p&gt;&lt;span&gt;幸好不是wys的题，不然时限就是1s了&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好吧，都说完了，上代码吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;&lt;img id=&quot;code_img_closed_70d9ef6c-bec3-4837-8d27-a95ba0e7ae44&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_70d9ef6c-bec3-4837-8d27-a95ba0e7ae44&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_70d9ef6c-bec3-4837-8d27-a95ba0e7ae44&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;113&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; typedef &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ll;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn=&lt;span&gt;100010&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; multiset&amp;lt;ll&amp;gt; mts;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟拿剑&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t,n,m;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; spec,exist,same;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; ll hp[maxn],rec[maxn],a[maxn],b[maxn];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a，b表示最后方程组是x=a_i(mod\ b_i)&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; award[maxn],atk[maxn];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;award是奖励的剑&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; ll qmul(ll a,ll b,ll mod){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;*速乘&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     ll ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(;b;b&amp;gt;&amp;gt;=&lt;span&gt;1&lt;/span&gt;,a=(a+a)%mod) &lt;span&gt;if&lt;/span&gt;(b&amp;amp;&lt;span&gt;1&lt;/span&gt;) ans=(ans+a)%&lt;span&gt;mod;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; ll exgcd(ll a,ll b,ll &amp;amp;x,ll &amp;amp;y){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模板&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!b){x=&lt;span&gt;1&lt;/span&gt;;y=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     ll d=exgcd(b,a%b,y,x);y-=a/b*x;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; ll gcd(ll a,ll b){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（不要问我为什么有这个）&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!b) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; gcd(b,a%&lt;span&gt;b);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;t);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(t--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         spec=&lt;span&gt;false&lt;/span&gt;;same=exist=&lt;span&gt;true&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;spec是rec=1，same是hp=rec，exist是有没有解&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        mts.clear();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++) scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hp+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++){scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,rec+i);&lt;span&gt;if&lt;/span&gt;(rec[i]&amp;lt;hp[i]) spec=&lt;span&gt;true&lt;/span&gt;;}    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;rec&amp;lt;hp？&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++) scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,award+&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             mts.insert(x);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全部进去&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             multiset&amp;lt;ll&amp;gt;&lt;span&gt;::iterator it;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(hp[i]&amp;lt;*mts.begin()) it=mts.begin();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有比血量小的剑，则用第一把（最小的）&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; it=mts.upper_bound(hp[i]),it--;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则用第一个大于它的-1（即最后一个小于等于它的）&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             atk[i]=*&lt;span&gt;it;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            mts.erase(it);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             mts.insert(award[i]);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿走再选&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(spec){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;特判hp&amp;gt;rec&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             ll ans=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++) ans=max(ans,ll(ceil(&lt;span&gt;1.0&lt;/span&gt;*hp[i]/&lt;span&gt;atk[i])));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!atk[i]){puts(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);exist=&lt;span&gt;false&lt;/span&gt;;&lt;span&gt;break&lt;/span&gt;;}    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无法攻击？无解&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(hp[i]!=rec[i]) same=&lt;span&gt;false&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hp=rec?&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             ll x,y,d=exgcd(atk[i],rec[i],x,y);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解x0&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(hp[i]%d){puts(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);exist=&lt;span&gt;false&lt;/span&gt;;&lt;span&gt;break&lt;/span&gt;;}    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无解&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;             x=(x+rec[i])%rec[i];b[i]=rec[i]/d;a[i]=qmul(x,hp[i]/d,b[i]);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;真的x0推出b=rec/gcd(atk,rec)，a=x0&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(same){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;特判hp=rec&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;             ll ans=ll(ceil(&lt;span&gt;1.0&lt;/span&gt;*hp[&lt;span&gt;1&lt;/span&gt;]/atk[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 ll x=ceil(&lt;span&gt;1.0&lt;/span&gt;*hp[i]/atk[i]),d=&lt;span&gt;gcd(ans,x);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 ans=ans/d*&lt;span&gt;x;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ans);&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!exist) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         ll ans=a[&lt;span&gt;1&lt;/span&gt;],mod=b[&lt;span&gt;1&lt;/span&gt;];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始EXCRT（以下模板，不解释，可以去我的另一个博客看）&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             ll x,y,d=exgcd(mod,b[i],x,y),r=((a[i]-ans)%b[i]+b[i])%b[i],tmp=mod/d*&lt;span&gt;b[i];
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(r%d){puts(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);exist=&lt;span&gt;false&lt;/span&gt;;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             x=(x+b[i])%b[i];x=qmul(x,r/&lt;span&gt;d,b[i]);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             ans=(qmul(mod,x,tmp)+ans)%&lt;span&gt;tmp;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             mod=&lt;span&gt;tmp;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!exist) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,ans);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;终于没了&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;NOI2018D2T1_dragon（EXCRT）&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;终于啊……&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 05:56:00 +0000</pubDate>
<dc:creator>ATS_nantf</dc:creator>
<og:description>题目链接： 洛谷 BZOJ LOJ 题目大意：这么长的题面，就饶了我吧emmm 这题第一眼看上去没法列出同余方程组。为什么？好像不知道用哪把剑杀哪条龙…… 仔细一看，要按顺序杀龙，所以获得的剑出现的顺</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1000Suns/p/9608901.html</dc:identifier>
</item>
<item>
<title>Java并发编程(2) AbstractQueuedSynchronizer的内部结构 - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/9608666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/9608666.html</guid>
<description>&lt;p&gt;　　虽然已经有很多前辈已经分析过AbstractQueuedSynchronizer（简称AQS）类，但是感觉那些点始终是别人的，看一遍甚至几遍终不会印象深刻。所以还是记录下来印象更深刻，还能和大家一起探讨（这就是重复造轮子的好处，另外也主要是这篇篇幅太长了，犹豫了好久才决定写作）。既然有很多前辈都分析过这个类说明它是多么的重要，下面我们看下concurrent包的实现示意图就清楚AQS的所占有的地位了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201809/690169-20180908103419104-79983452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　个人习惯喜欢先看其内部结构，因为内部结果是一个类实现的核心。经过分析得知：AQS类底层的数据结构是使用双向链表，包括head结点和tail结点，head结点主要用作后续的调度。另外还包含一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition 链表（其中链表是队列的一种具体表现，所以也可称作队列）。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201809/690169-20180908112113747-1468053314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.1 类的继承关系&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/690169/201809/690169-20180908113118704-1180423798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1、说明它是一个抽象类，就说明它可能存在抽象方法需要子类去重写实现（具体有哪些方法需要重写后续会说明）。&lt;/p&gt;
&lt;p&gt;　　2、它还继承了AbstractOwnableSynchronizer(简称AOS)类可以设置独占资源线程和获取独占资源线程（独占锁会涉及到，AOS的源码自己可以进去看看）。&lt;/p&gt;
&lt;p&gt;　　另外建议各位多看看类上的注释，其实还蛮有作用的。&lt;/p&gt;
&lt;h3&gt;3.2 类的内部类&lt;/h3&gt;
&lt;p&gt; 　　先分析内部类中的结构再看AQS是怎么引用它的。下面先看Node.class，主要分析都在注释上了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Wait queue node class.
 * 注意看类上的注释，上面是原注释的第一行，表示等待队列节点类（虽然实际上是一个双向链表）。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 总共分为两者模式：共享和独占
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 在共享模式中等待的节点 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node SHARED = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 在独占模式中等待的节点 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 下面几个表示节点状态，也就是waitStatus所具有可能的值。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 标记线程处于取消状态
     * 节点进入该状态就不会变化。
     * /
    static final int CANCELLED =  1;
    /**
     * 标记后继节点的线程处于等待状态，需要被取消停放（即被唤醒unpark）。
     * 变化情况：当当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL    = -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 标记线程正在等待条件（Condition）,也就是该节点处于等待队列中。
     * 变化情况：当其他线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONDITION = -2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 表示下一次共享式同步状态获取将会无条件的被传播下去。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PROPAGATE = -3&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 节点状态，包含上面四种状态（另外还有一种初始化状态0）
     * 特别注意：它是volatile关键字修饰的，保证对其线程可见性，但是不保证原子性。
     * 所以更新状态时，采用CAS方式去更新, 如：compareAndSetWaitStatus
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; waitStatus;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node prev;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 后继节点。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node next;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 入队列时的当前线程。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Thread thread;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 存储condition队列中的后继节点。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Node nextWaiter;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断是否共享模式
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isShared() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextWaiter ==&lt;span&gt; SHARED;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取前置节点，如果前置节点为空就抛出异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Node predecessor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NullPointerException {
        Node p &lt;/span&gt;=&lt;span&gt; prev;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略三个构造函数&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结下：当每个线程被阻塞时都会封装成一个Node节点，放入队列中。每个节点都包含了当前节点对应的线程、状态、前置节点引用、后继节点引用以及下一个等待者。&lt;/p&gt;
&lt;p&gt;　　其中还需要注意的是waitStatus对应的各个状态代表着什么意思，另外不清楚&lt;a href=&quot;https://www.cnblogs.com/yuanfy008/p/9335168.html&quot; target=&quot;_blank&quot;&gt;volatile关键字&lt;/a&gt;作用的请前去阅读下。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;属性名称&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;int waitStatus&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;表示节点的状态。其中包含的状态有：
&lt;ol&gt;&lt;li&gt;CANCELLED，值为1，表示当前的线程被取消；节点进入该状态就不会变化。&lt;/li&gt;
&lt;li&gt;SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；变化情况：当当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行。&lt;/li&gt;
&lt;li&gt;CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；变化情况：当其他线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中。&lt;/li&gt;
&lt;li&gt;PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；&lt;/li&gt;
&lt;li&gt;值为0，表示当前节点在sync队列中，等待着获取锁。&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;&lt;strong&gt;Node prev&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;pre&gt;
前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Node next&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;
&lt;pre&gt;
后继节点。
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;Thread thread&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;pre&gt;
入队列时的当前线程。
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;pre&gt;
&lt;strong&gt;Node nextWaiter&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;pre&gt;
存储condition队列中的后继节点。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　接下来简单看看ConditionObject的源码，后续我们会单独分析下这个类的作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 实现Condition接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConditionObject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Condition, java.io.Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1173984872572414699L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 条件队列的第一个节点。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer.Node firstWaiter;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 条件队列的最后一个节点。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer.Node lastWaiter;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从中可以看它还是实现了Condition接口，而Condition接口又定义了什么规范呢？自己去看：），你会不会发现有点跟Object中的几个方法类似呢。&lt;/p&gt;
&lt;h3&gt;3.3 主要内部成员&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node head;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾结点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node tail;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步状态&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　通过上述分析就很清楚其内部结构是什么了吧。总结下：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;节点(Node)是成为sync队列和condition队列构建的基础，在同步器中就包含了sync队列（Node双向链表）。&lt;/strong&gt;&lt;strong&gt;同步器拥有三个成员变量：sync队列的头结点head、sync队列的尾节点tail和状态state。对于锁的获取，请求形成节点，将其挂载在尾部，而锁资源的转移（释放再获取）是从头部开始向后进行。对于同步器维护的状态state，多个线程对其的获取将会产生一个链式的结构。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 05:10:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一 前言 虽然已经有很多前辈已经分析过AbstractQueuedSynchronizer（简称AQS）类，但是感觉那些点始终是别人的，看一遍甚至几遍终不会印象深刻。所以还是记录下来印象更深刻，还能和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/9608666.html</dc:identifier>
</item>
<item>
<title>anu小程序快速入门 - 司徒正美</title>
<link>http://www.cnblogs.com/rubylouvre/p/9608922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rubylouvre/p/9608922.html</guid>
<description>&lt;p&gt;众所周知，微信推出小程序以来，可谓火遍大江南北，就像当前互联网兴起时，大家忙着抢域名与开私人博客一样。小程序之所以这么火，是因为微信拥有庞大的用户量，并且腾讯帮你搞定后台问题及众多功能问题（如分享，支付，视频播放，文件上传），相当于你一个人也能做一个公司的事情。在手机上，每个人不可能装超过100个以上的APP，因此这么多小公司想生存下来很不容易，但傍上微信这个大平台，个人也能出一个有上千万人玩的爆款游戏，也能搞一些小商城，避开淘宝京东的锋芒。对于大公司，这也是一个赚钱导流的新途径。相信今后，小程序会越来越火。&lt;br/&gt;但是，小程序对开发人员来说，则不怎么给力。它的API非常原始，没有类继承，npm支持滞后，不能使用CSS预处理器。于是市面上出现各种转译框架。转译框架与我们常用的框架不太大一样，转译框架是将我们写的代码翻译成小程序支持的各种文件形式，比如说wxml, wxss。而转译框架在编写业务时，允许我们使用更为流行的框架形式来写（之所以说形式，因为以vue方式写，它实际不是跑一个真正的vue，以react方式写，也不是跑一个真正的react）。由于小程序不存在DOM，因此流行那几个框架是无法跑在微信中，但可以用它们的仿造品。&lt;br/&gt;转译框架的最高目标是统一公司的技术栈，让以react为技术栈的公司不用再搞vue，为vue为技术栈的公司不用学react。这在招聘与维护上有很大优势。&lt;br/&gt;目前，市面上的转译框架有wepy, mpvue, taro。前两者是vue风格，使用的是vue1的语法，但还是有这么多vue语法无法支持。taro是京东近半年出品的，react风格，目前还不够稳定，最大的问题是组件不包含组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908120015709-891231071.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到本文的主角出场。anu原本是一个迷你React框架，对react16的兼容程度非常高，能跑react-router, react-redux, antd， rematch等等。而anu小程序只是在其上面的一个扩展，为它添加了一个cli及一个新的render.cli用在编译期，将JSX转换成wxml等，而miniapp render用在运行期，让它跑在微信内部。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/RubyLouvre/anu/tree/master/packages/cli&quot; class=&quot;uri&quot;&gt;https://github.com/RubyLouvre/anu/tree/master/packages/cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于小程序的限制，一切涉及DOM的API都不能用，即findDOMNode, dangerouslySetInnerHTML及refs.dom。目前也不支持使用render props时，因为wxml里面不能运行函数。其他，都可以正常使用，包括&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;各种生命周期钩子，页面组件还有componentDidShow, componentDidHide两个新钩子&lt;/li&gt;
&lt;li&gt;div, h1, span, b等html标签&lt;/li&gt;
&lt;li&gt;用户已经用小程序方式写好的各种组件&lt;/li&gt;
&lt;li&gt;事件里面可以传参，多次bind this(这是一个重大特殊，其他转译框架做不到)&lt;/li&gt;
&lt;li&gt;多重循环支持&lt;/li&gt;
&lt;li&gt;es6, es7语法糖支持&lt;/li&gt;
&lt;li&gt;组件标签包含组件标签（solt机制）&lt;/li&gt;
&lt;li&gt;无状态组件的支持&lt;/li&gt;
&lt;li&gt;onClick属性自动映射成bindtap&lt;/li&gt;
&lt;li&gt;React.wx对象拥有原wx对象的所有方法，并且对所有请求接口进行Promise化&lt;br/&gt;11 提供两个通用别名@components与@react，方便用户import React与通用组件目录的内容&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说了这么多，我们看一下如何使用。&lt;/p&gt;
&lt;p&gt;1.到https://github.com/RubyLouvre/anu 下载anu&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git clone https://github.com/RubyLouvre/anu.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.进入anu/packages/cli目录， 执行&lt;code&gt;npm link&lt;/code&gt;命令 （如果之前执行过，需要npm unlink）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908120039116-1228336897.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.回到anu目录，这时可以使用&lt;code&gt;mpreact &amp;lt;projectname&amp;gt;&lt;/code&gt;创建一个小程序项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908120057505-1076613497.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.执行npm start命令，构建工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908120110392-11250413.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.然后使用微信开发工具，打开&lt;code&gt;&amp;lt;projectname&amp;gt;&lt;/code&gt;下面的dist目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908120123320-1009281029.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为一个演示项目。去哪儿网模板包含一些简单的使用演示。大家可以用 vs code打 &lt;code&gt;&amp;lt;projectname&amp;gt;&lt;/code&gt;。src目录是源码，dist目录是最终生成给微信运行的代码。&lt;/p&gt;
&lt;p&gt;根据微信小程序的要求，src 主要分为三大块， app.js， pages目录的页面组件， components目录的通用组件。&lt;/p&gt;
&lt;p&gt;app.js会import所有用到的页面组件的JS文件&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125756234-621408338.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面组件的源码与生成代码大概如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from '@react';
import Dog from '@components/Dog/index';
class P extends React.Component {
    render() {
        return (
            &amp;lt;div&amp;gt;
                &amp;lt;div&amp;gt;类继承的演示&amp;lt;/div&amp;gt;
                &amp;lt;Dog age={12} /&amp;gt;
            &amp;lt;/div&amp;gt;
        );
    }
}

export default P;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会生成两个文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, {
    value: true
});
var _ReactWX = require(&quot;../../../../ReactWX&quot;);
var _ReactWX2 = _interopRequireDefault(_ReactWX);
var _index = require(&quot;../../../../components/Dog/index&quot;);
var _index2 = _interopRequireDefault(_index);
function _interopRequireDefault(obj) {
    return obj &amp;amp;&amp;amp; obj.__esModule ? obj : { default: obj };
}
function P() {}
P = _ReactWX2.default.miniCreateClass(
    P,
    _ReactWX2.default.Component,
    {
        render: function() {
            var h = _ReactWX2.default.createElement;

            return h(
                &quot;view&quot;,
                null,
                h(&quot;view&quot;, null, &quot;\u7C7B\u7EE7\u627F\u7684\u6F14\u793A&quot;),
                h(_ReactWX2.default.template, {
                    age: 12,
                    templatedata: &quot;data09558693&quot;,
                    is: _index2.default
                })
            );
        },
        classUid: &quot;c70258&quot;
    },
    {}
);
Page(_ReactWX2.default.createPage(P, &quot;pages/demo/syntax/extend/index&quot;));

exports.default = P;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wxml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;import src=&quot;../../../../components/Dog/index.wxml&quot; /&amp;gt;
&amp;lt;view&amp;gt;
   &amp;lt;view&amp;gt;类继承的演示&amp;lt;/view&amp;gt;
   &amp;lt;template is=&quot;Dog&quot; data=&quot;{{...data}}&quot; wx:for=&quot;{{data09558693}}&quot; wx:for-item=&quot;data&quot; wx:for-index=&quot;index&quot; wx:key=&quot;*this&quot;&amp;gt;&amp;lt;/template&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125818027-375455047.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125829928-1334854551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再来看一下另一个拼多多商城模板。那是使用sass做预处理器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125838796-933671323.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于用到https请求数据，因此需要大家打开右上角进行一个设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125901377-406667648.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125910179-1586518930.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的全貌如下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125918832-288045571.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125926203-1617637599.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125935473-1405557709.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125947688-339378457.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908125956321-563870638.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/65123/201809/65123-20180908130004941-234135566.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里三个示例来看，anu小程序是能hold住非常复杂的应用。&lt;/p&gt;
&lt;p&gt;如果想了解 anu小程序的进度或一些注意事项，大家可以访问这里&lt;/p&gt;
&lt;p&gt;https://github.com/RubyLouvre/anu/issues/133&lt;/p&gt;
&lt;p&gt;也欢迎大家试用与提PR！&lt;/p&gt;
</description>
<pubDate>Sat, 08 Sep 2018 05:02:00 +0000</pubDate>
<dc:creator>司徒正美</dc:creator>
<og:description>众所周知，微信推出小程序以来，可谓火遍大江南北，就像当前互联网兴起时，大家忙着抢域名与开私人博客一样。小程序之所以这么火，是因为微信拥有庞大的用户量，并且腾讯帮你搞定后台问题及众多功能问题（如分享，支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rubylouvre/p/9608922.html</dc:identifier>
</item>
<item>
<title>二叉堆 - 仪式黑刃</title>
<link>http://www.cnblogs.com/hongshijie/p/9607461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshijie/p/9607461.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;二叉堆是一种典型的优先队列实现策略，广义而言，堆是优先队列的实现方式，在此之下又分为二叉堆，左式堆，斜堆，二项队列等具体形态。但第一个用得太普遍了，所以我们平时一说到堆&lt;span lang=&quot;en-US&quot;&gt;(Heap)指的就是二叉堆&lt;span lang=&quot;zh-CN&quot;&gt;。基本模型如下，基本操作就这两个，其他的都是扩展。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223258958-1449905593.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;173&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以后我们讨论的堆，如果不特殊说明，那都以小顶堆为例，堆顶元素为最小的值，但优先级上却是最高的。我们从二叉堆的起源谈起，如何根据之前已经掌握的数据结构来实现优先级队列，在这里，既要考虑效率还要兼顾成本，那最佳的实现方式应该是这两个因素的综合与兼顾，这就要求我们设计模型的时候发挥统筹兼顾、总揽全局的领导核心作用。&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;第一种实现方式是基于此前的向量或链表，这样的话，实现方便而且能保证某种情况下的效率。它可以在表头以$O\left( 1 \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;的时间插入元素，如果要查询最小元素，那需要耗费$\theta(N )$&lt;span lang=&quot;en-US&quot;&gt;时间&lt;span lang=&quot;zh-CN&quot;&gt;。如果删除最小元素，不仅要遍历整个表来查到优先级最小的，而且需要在摘除之后将它的所有后继顺次前移，两项工作的成本累计$\Theta(n)+O(N)=\theta(N)$&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;span lang=&quot;en-US&quot;&gt;这就有点慢了&lt;span lang=&quot;zh-CN&quot;&gt;，那另一种方法就是始终让表保持有序，构成有序向量，这往往会让算法性能有实质提高。这时候查找和删除最小元素只需要$O\left( 1 \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;时间，如果要插入一个元素，我们要先找到他所在的位置，花费$O\left( \log N \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;,然后将它的所有后继元素后移一个单位留出空位&lt;span lang=&quot;zh-CN&quot;&gt;，在最坏和平均情况都需要耗费$O\left( N \right)$，所以总代价是$O\left( N \right)$。因此将向量有序化也不是一个行之有效的策略。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样，借助链表也不能高效地实现优先级队列。&lt;/p&gt;
&lt;p&gt;以上方法都各有缺陷，那或许我们会求诸之前学过的BBST，没错，无论是用AVL树、伸展树或者红黑树实现优先队列，三个标准接口（增、删、查）的效率都可以达到$O\left( \log N \right)$，而且只需作一点优化，其中的$getMin\left(  \right)$接口效率还可以进一步提高到$O\left( 1 \right)$。但是就优先队列所要求的功能来说，BBST的功能就过于强大了。因为我们在优先队列里查找和删除都仅限于堆顶，而难以找到某个确切元素，并没有完全用上BBST的完整功能。也就是说，我们实际上是使用了一个非常高级的数据结构来实现一个功能更为简单的结构，而且BBST的开销也是比较大的，这简直杀鸡用牛刀。那有没有成本更低的实现方式呢？我们注意到对于优先队列而言，矛盾都集中在优先级最高的那个极值元素。这就意味着，我们只需要维护所有元素之间的一个偏序关系，就足以确定这个极值元素，而不必像BBST那样，始终都不折不扣地维护一个所有元素之间的全序关系。根据这一分析，我们确信一定存在某种形式上更简单，而且维护成本更低的实现方式。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;总结一下：采用基本的向量结构不够，而采用更高级的树形结构，却有杀鸡用牛刀之嫌。我们要找一个中庸之道，为此我们需要以向量为形，以树形结构为神，形成二者之间的有机结合。就是逻辑上用树组织，但物理上用数组实现。为此，我们需要借助完全二叉树，可以认为是AVL树的一个特例，它的平衡因子处处非负，这也是二叉堆名字的来由。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223505044-1980787486.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和BST一样，堆也有两个性质：结构性和堆序性。如同AVL树一样，对堆的任何一次操作都有可能破坏这些性质，所以我们要时时维护这两个性质。下面来仔细分析一下这两个性质究竟为何物。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;h2&gt;结构性质&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;堆是一颗被完全填满的二叉树，底层可能有空缺，但至少要保证从左到右填充，这样的树被称为完全二叉树（&lt;span lang=&quot;en-US&quot;&gt;complete binary tree&lt;span lang=&quot;zh-CN&quot;&gt;）。比如这样&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223525542-972307610.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;一颗高度为&lt;span lang=&quot;en-US&quot;&gt;h的CBT有 $2^{h}$ &lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;到 $2^{h+1}\; -\; 1$ &lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;个节点&lt;span lang=&quot;zh-CN&quot;&gt;，这就意味着CBT的高度是$\left\lfloor \log N \right\rfloor$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。之前说物理上可以用数组实现是因为，CBT很有规律，可以用一个数组表示而不用指针。下图的数组对应图&lt;span lang=&quot;en-US&quot;&gt;6.2中的堆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223548242-1240541883.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;对于每一个位置为&lt;span lang=&quot;en-US&quot;&gt;i的元素&lt;span lang=&quot;zh-CN&quot;&gt;，左孩子在 $2i\;$ &lt;span lang=&quot;en-US&quot;&gt;上&lt;span lang=&quot;zh-CN&quot;&gt;，右孩子在 $2i\; +\; 1$ &lt;span lang=&quot;en-US&quot;&gt;的位置&lt;span lang=&quot;zh-CN&quot;&gt;，父亲则在$\left\lfloor \frac{i}{2} \right\rfloor$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;上&lt;span lang=&quot;zh-CN&quot;&gt;，所以不用指针而可以按下标访问。这种方法的唯一问题在于我们要事先估计堆的规模，从而确定开多大空间，不过这个也好解决。因此，堆这种结构将由一个数组、代表最大值的数、指示当前堆的最大规模的数字组成。下面先给出相关类型声明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef BinHeap_h
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BinHeap_h
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HeapStruct;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; HeapStruct *&lt;span&gt;PriorityQueue;
PriorityQueue Init(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxValue);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Insert(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; X,PriorityQueue H);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Delete(PriorityQueue H);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; PercolateDown(&lt;span&gt;int&lt;/span&gt; *a,&lt;span&gt;int&lt;/span&gt; root,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Display(PriorityQueue H);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; BuildHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N,PriorityQueue H);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; /* BinHeap_h */

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HeapStruct {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; capacity; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总空间&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; size;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已有元素的规模&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *&lt;span&gt;Element;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;堆序性质（重点）&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这个性质是保证动态操作高效率的关键，这个性质是说：任何一颗子树的树根都应该小于所有后代。也就是对于任何一个节点X，X父亲的关键字&lt;span lang=&quot;zh-CN&quot;&gt;$\leq $&lt;span lang=&quot;en-US&quot;&gt;X&lt;span lang=&quot;en-US&quot;&gt;的关键字&lt;span lang=&quot;zh-CN&quot;&gt;，根节点除外。比如下面就是一个典型的堆。根据堆序性，最小元素可以在根处找到，所以可以用$O\left( 1 \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;时间完成$getMin\left(  \right)$&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223720956-1711962582.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;堆的初始化如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以小根堆为例&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; MinPQSize 5
&lt;span&gt;#define&lt;/span&gt; MinData (-2)

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个新的空堆&lt;/span&gt;
PriorityQueue Init(&lt;span&gt;int&lt;/span&gt; maxValue){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是堆的最大规模&lt;/span&gt;
&lt;span&gt;    PriorityQueue H;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(maxValue &amp;lt;&lt;span&gt; MinPQSize){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could you give more space?\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }
    H&lt;/span&gt;=(PriorityQueue)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(HeapStruct));
    
    H&lt;/span&gt;-&amp;gt;Element=(&lt;span&gt;int&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;((maxValue+&lt;span&gt;1&lt;/span&gt;)*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保持一定冗余&lt;/span&gt;
    H-&amp;gt;capacity=&lt;span&gt;maxValue;
    H&lt;/span&gt;-&amp;gt;size=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    H&lt;/span&gt;-&amp;gt;Element[&lt;span&gt;0&lt;/span&gt;]=MinData; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一句后面会解释其用途&lt;/span&gt;
&lt;span&gt;    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; H;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后续我们任何的操作都必须保持这两条性质，因此也可以猜测到，插入和删除的核心都是在于维护这两点，他们是堆所有操作算法的循环不变量。&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;现在我们来讨论基本的堆操作，插入和删除。其实都很容易实现，只需要始终保持堆序性。插入的时候可以直接把元素放在数组的末尾这样一来首先保持了结构性，接下来看满不满足堆序性，如果也满足，那插入过程就完成了。但往往是插入过程会破坏堆序，这时候要通过循环不变式使新元素推进到正确位置，然后再进行数据装填，可不能直接放到末尾。做法就是找到下一个空位置，然后把新节点的父亲放到这个空位里，腾出来的位置就是新节点当前的位置，形象上看就像他们”互换位置“。如此循环往复，这样一来新元素会逐渐向根上浮，直到抵达一个“新元素与其父满足堆序”的位置。举个例子吧，我们要插入&lt;span lang=&quot;en-US&quot;&gt;14&lt;span lang=&quot;zh-CN&quot;&gt;，先找到下一个位置，画个圈，如果&lt;span lang=&quot;en-US&quot;&gt;14直接放进去&lt;span lang=&quot;zh-CN&quot;&gt;，就破坏堆序，所以把&lt;span lang=&quot;en-US&quot;&gt;31移动过来&lt;span lang=&quot;zh-CN&quot;&gt;，那这个空圈就上浮一层。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223823953-2131955529.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;249&quot;/&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;不断持续这个过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907223840993-2085630046.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;直到找到放置14的正确位置&lt;span lang=&quot;zh-CN&quot;&gt;。这种策略叫做上滤（&lt;span lang=&quot;en-US&quot;&gt;percolate up&lt;span lang=&quot;zh-CN&quot;&gt;），是插入的核心步骤。前面说了这好像父子互换位置，可能初学者会直接上去就&lt;span lang=&quot;en-US&quot;&gt;swap两个数&lt;span lang=&quot;zh-CN&quot;&gt;，但我们要注意的是，一次交换要三条赋值语句。如果一个元素上滤$d$&lt;span lang=&quot;en-US&quot;&gt;层&lt;span lang=&quot;zh-CN&quot;&gt;，由于交换而进行的赋值语句就需要执行$3d$&lt;span lang=&quot;en-US&quot;&gt;次&lt;span lang=&quot;zh-CN&quot;&gt;，这……不太明智。现在这里有一个办法，只需要$d\; +\; 1$&lt;span lang=&quot;en-US&quot;&gt;次赋值&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; Insert(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; X,PriorityQueue H) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行上滤&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i=++(H-&amp;gt;size); H-&amp;gt;Element[i/&lt;span&gt;2&lt;/span&gt;]&amp;gt;X; i/=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取CBT的下一个空闲位置，如果满足heap order则进行插入，否则接收父节点数值&lt;/span&gt;
        H-&amp;gt;Element[i]=H-&amp;gt;Element[i/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    }
    H&lt;/span&gt;-&amp;gt;Element[i]=&lt;span&gt;X;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这个循环直到满足父节点$\leq $&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;X&lt;span lang=&quot;en-US&quot;&gt;的时候种植&lt;span lang=&quot;zh-CN&quot;&gt;，这时候再把数据放进去，就是正确的位置了。这里再解释一些初始化程序里的一句话，第&lt;span lang=&quot;en-US&quot;&gt;11行&lt;span lang=&quot;zh-CN&quot;&gt;，这句话和链表的头节点起到了类似的作用。如果要插入的元素是新的最小值，那这个圆圈会一直被推向顶端，这样的话在某个时刻$i\; =\; 1$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;，我们需要终止循环。也可以用一个&lt;span lang=&quot;en-US&quot;&gt;if完成&lt;span lang=&quot;zh-CN&quot;&gt;，但我们采用的是放一个标记在&lt;span lang=&quot;en-US&quot;&gt;i=0的位置&lt;span lang=&quot;zh-CN&quot;&gt;，这个值必须&lt;span lang=&quot;en-US&quot;&gt;$&lt;span lang=&quot;zh-CN&quot;&gt;\leq &lt;span lang=&quot;en-US&quot;&gt;$堆中的所有制&lt;span lang=&quot;zh-CN&quot;&gt;。通过添加一个哑节点，避免了每个循环都要执行一次的测试，就节省了一些时间，像下面这个样子，这就保证了新插入的最小元素不会上浮得突破天际，到这就被拦住了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907224017222-300300314.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;364&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;如果新插入元素是最小元，那就会一直上滤到根，耗时高达$O\left( \log N \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。但平均情况会结束的早，大量数据证明，执行一次插入平均需要&lt;span lang=&quot;en-US&quot;&gt;2.607次比较&lt;span lang=&quot;zh-CN&quot;&gt;，因此插入操作会将新元素平均上移&lt;span lang=&quot;en-US&quot;&gt;1.607层&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;再说删除，这里的删除可不是像BST一样随意，你不能点菜，只能给你删除最小元素。删除的时候会 在根节点处产生一个空位，由于缺少了元素，就必须把最后一个元素放在合适位置，其余元素必须依照堆序性逐层补充上去，把当前这个空位两个儿子中较小的那个移入该空位。&lt;span lang=&quot;en-US&quot;&gt;那其实这个修复过程是自上而下进行的&lt;span lang=&quot;zh-CN&quot;&gt;，因此称为下滤。最后我们要把堆中末尾元素放到合适位置，比如说在下图左边的原始堆里删除&lt;span lang=&quot;en-US&quot;&gt;13&lt;span lang=&quot;zh-CN&quot;&gt;，整个流程就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;删除堆顶元素后，把较小的儿子放在空位，然后空位下滑一层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907224053337-1256950555.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;接着把当前空位的小儿子放进来，继续下滑一层，直到最终把&lt;span lang=&quot;en-US&quot;&gt;31放在底层的空位上&lt;span lang=&quot;zh-CN&quot;&gt;，删除宣告完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907224117949-1480314078.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不过这里有个疑点在于，刚开始的时候乍看之下“必须把最后一个元素放在合适位置”这话有点无厘头，为什么删除堆顶后还要顾及末尾元素？其实这是为了满足结构性质。我们也不妨换种思路理解这个过程，之前是逐层下滤，最后安置末尾元素，这个思考方式不太直观。现在这样想：删除堆顶后，在逻辑上就不是一颗结构完整的完全二叉树了，为了尽快恢复结构性，可以先把末尾元素送到堆顶（拆东墙补西墙，其他的事以后再说）。这一步之后结构性是恢复了，但是堆序性又破坏了，为了恢复堆序性，我们从堆顶开始执行下滤，走一轮就行了。整体过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907224212581-668487941.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这两种方法是殊归同途的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;由此我们也可以得到一个启示：对于堆的任何动态操作，脑海里时刻考虑&lt;span lang=&quot;en-US&quot;&gt;1.结构性 2.堆序性两者如何维护&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;在堆的实现过程中经常发生的错误是当堆里存在偶数个元素时&lt;span lang=&quot;zh-CN&quot;&gt;，此时会遇到某个节点只有一个儿子。所以要考虑到节点不总是有双子的情况，这会涉及到一个附加的测试，在下面的第14行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; DeleteMin(PriorityQueue H){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,child;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; MinElement,last;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     MinElement=H-&amp;gt;Element[&lt;span&gt;1&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出树根的值，根据heap order它是最小元素&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     last=H-&amp;gt;Element[H-&amp;gt;size--];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出末尾元素以便后续安置
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; H-&amp;gt;Element[1]=last;  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行下滤，搜索每个膝下有子的父节点
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体做法是：把last放在沿着从根开始包含最小儿子的一条路径的某个恰当位置，这是步进条件的由来&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;1&lt;/span&gt;; i*&lt;span&gt;2&lt;/span&gt;&amp;lt;=H-&amp;gt;size; i=&lt;span&gt;child) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先确定下滤的孩子索引（找到更小的那个）&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         child=i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先取左孩子&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (child!=H-&amp;gt;size &amp;amp;&amp;amp; H-&amp;gt;Element[child+&lt;span&gt;1&lt;/span&gt;] &amp;lt; H-&amp;gt;&lt;span&gt;Element[child])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             child++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后下滤一层&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (last &amp;gt; H-&amp;gt;&lt;span&gt;Element[child])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             H-&amp;gt;Element[i]=H-&amp;gt;&lt;span&gt;Element[child];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     H-&amp;gt;Element[i]=last; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把最后一个元素放在合适的空穴里&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MinElement;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是第一种办法，如果采用第二种办法，只需要把第7行的注释取消，然后23行打上注释即可。删除堆顶的&lt;span lang=&quot;zh-CN&quot;&gt;最坏情况的运行时间是$O\left( \log N \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;，因为平均而言，末尾元素被提上去之后，经过下滤几乎总是又到达底层（他原来的那一层）的另一个合理位置，故几乎和堆深度的复杂度一致。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;另外堆还有其他的操作，我们来一一端详，并简要介绍下在实际工程中的应用。比如求最小值，直接返回堆顶元素即可。但是求最大值就很难了，因为不确定在哪一片树叶上，而半数元素都在树叶上，这光靠堆自己去检索就心有余而力不足了。正因此，如果我们想要知道每个元素具体的位置，那么除了堆这种结构之外，还必须用到诸如散列表等其他的数据结构。那假如说我们通过某种绝妙的方法知道了具体位置，那么还有几种操作的开销会变小，最坏情况都是$O\left( \log N \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;$Dec\mbox{re}aseKey\left( pos\; ,\; \Delta \; ,\; H \right)$，语义是降低在位置pos处元素的值，减幅为&lt;span lang=&quot;en-US&quot;&gt;$&lt;span lang=&quot;zh-CN&quot;&gt;\Delta&lt;span lang=&quot;en-US&quot;&gt;$&lt;span lang=&quot;zh-CN&quot;&gt;，H是指向该堆的指针（下同），由于这个操作可能破坏堆序性，因此要通过上滤进行调整。这个操作有什么用？操作系统管理程序可以使用这个函数保证下属运行的程序以最高优先级运行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;$Inc\mbox{re}aseKey\left( pos\; ,\; \Delta \; ,\; H \right)$，语义是增加在位置pos处元素的值，增幅为&lt;span lang=&quot;en-US&quot;&gt;$&lt;span lang=&quot;zh-CN&quot;&gt;\Delta&lt;span lang=&quot;en-US&quot;&gt;$&lt;span lang=&quot;zh-CN&quot;&gt;，用下滤完成，用处在于：系统调度程序可以用其自动降低正在过多消耗CPU资源的进程优先级。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;$Delete\left( pos\; ,\; H \right)$，语义是删除堆中位置&lt;span lang=&quot;en-US&quot;&gt;pos的节点&lt;span lang=&quot;zh-CN&quot;&gt;。这通过先调用$Dec\mbox{re}aseKey\left( pos\; ,\; \Delta \; ,\; H \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;，然后调用$DeleteMin\left( H \right)$来完成。用处在于：当一个进程被用户强制中止时，就从系统的调度队列里删除。比如这个时候&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201809/1262741-20180907224643780-676738431.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;

&lt;p&gt;$BulidHeap\left( N\; ,\; H \right)$，批量建堆。把N个元素作为输入然后放入空堆中，以线性平均时间运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; PercolateDown(&lt;span&gt;int&lt;/span&gt; *a,&lt;span&gt;int&lt;/span&gt; root,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l,r,min;
    l&lt;/span&gt;=root&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    r&lt;/span&gt;=(root&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到局部子堆最小值的索引&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (l&amp;lt;=size &amp;amp;&amp;amp; a[l]&amp;gt;a[root] ) min=root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先比较lChild &amp;amp; root&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; min=&lt;span&gt;l;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r&amp;lt;size &amp;amp;&amp;amp; a[r]&amp;lt;a[min]) min=&lt;span&gt;r;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(min!=root){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相等时意味已经满足最小堆的性质&lt;/span&gt;
        swap(&amp;amp;a[root],&amp;amp;a[min]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行下滤&lt;/span&gt;
        PercolateDown(a,min,size);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续处理下一子堆&lt;/span&gt;
&lt;span&gt;    }
    
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; BuildHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N,PriorityQueue H) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=N/&lt;span&gt;2&lt;/span&gt;;i&amp;gt;&lt;span&gt;0&lt;/span&gt;;i--&lt;span&gt;)
        PercolateDown(H&lt;/span&gt;-&amp;gt;Element, i, H-&amp;gt;&lt;span&gt;size);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总的代码如下，头文件就不在这里显示了，和上面的完全一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;time.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BinHeap.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以小根堆为例&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; MinPQSize 5
&lt;span&gt;#define&lt;/span&gt; MinData (-2)


&lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; *a,&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;b) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t=*&lt;span&gt;a;
    &lt;/span&gt;*a=*&lt;span&gt;b;
    &lt;/span&gt;*b=&lt;span&gt;t;
}



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个新的空堆&lt;/span&gt;
PriorityQueue Init(&lt;span&gt;int&lt;/span&gt; maxValue){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是堆的最大规模&lt;/span&gt;
&lt;span&gt;    PriorityQueue H;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(maxValue &amp;lt;&lt;span&gt; MinPQSize){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could you give more space?\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }
    H&lt;/span&gt;=(PriorityQueue)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(HeapStruct));
    
    H&lt;/span&gt;-&amp;gt;Element=(&lt;span&gt;int&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;((maxValue+&lt;span&gt;1&lt;/span&gt;)*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保持一定冗余&lt;/span&gt;
    H-&amp;gt;capacity=&lt;span&gt;maxValue;
    H&lt;/span&gt;-&amp;gt;size=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    H&lt;/span&gt;-&amp;gt;Element[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;MinData;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; H;
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Insert(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; X,PriorityQueue H) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行上滤&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i=++(H-&amp;gt;size); H-&amp;gt;Element[i/&lt;span&gt;2&lt;/span&gt;]&amp;gt;X; i/=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取CBT的下一个空闲位置，如果满足heap order则进行插入，否则和父节点交换数值&lt;/span&gt;
        H-&amp;gt;Element[i]=H-&amp;gt;Element[i/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    }
    H&lt;/span&gt;-&amp;gt;Element[i]=&lt;span&gt;X;
}


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; DeleteMin(PriorityQueue H){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,child;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; MinElement,last;
    
    MinElement&lt;/span&gt;=H-&amp;gt;Element[&lt;span&gt;1&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出树根的值，根据heap order它是最小元素&lt;/span&gt;
    last=H-&amp;gt;Element[H-&amp;gt;size--];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出末尾元素以便后续安置&lt;/span&gt;
    H-&amp;gt;Element[&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;last;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行下滤，搜索每个膝下有子的父节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体做法是：把last放在沿着从根开始包含最小儿子的一条路径的某个恰当位置，这是步进条件的由来&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;1&lt;/span&gt;; i*&lt;span&gt;2&lt;/span&gt;&amp;lt;=H-&amp;gt;size; i=&lt;span&gt;child) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先确定下滤的孩子索引（找到更小的那个）&lt;/span&gt;
        child=i&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先取左孩子&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (child!=H-&amp;gt;size &amp;amp;&amp;amp; H-&amp;gt;Element[child+&lt;span&gt;1&lt;/span&gt;] &amp;lt; H-&amp;gt;&lt;span&gt;Element[child])
            child&lt;/span&gt;++&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后下滤一层&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (last &amp;gt; H-&amp;gt;&lt;span&gt;Element[child])
            H&lt;/span&gt;-&amp;gt;Element[i]=H-&amp;gt;&lt;span&gt;Element[child];
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把最后一个元素放在合适的空穴里&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; MinElement;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; PercolateDown(&lt;span&gt;int&lt;/span&gt; *a,&lt;span&gt;int&lt;/span&gt; root,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l,r,min;
    l&lt;/span&gt;=root&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    r&lt;/span&gt;=(root&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到局部子树最小值的索引&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (l&amp;lt;=size &amp;amp;&amp;amp; a[l]&amp;gt;a[root] ) min=root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先比较lChild &amp;amp; root&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; min=&lt;span&gt;l;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r&amp;lt;size &amp;amp;&amp;amp; a[r]&amp;lt;a[min]) min=&lt;span&gt;r;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(min!=root){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相等时意味已经满足最小堆的性质&lt;/span&gt;
        swap(&amp;amp;a[root],&amp;amp;a[min]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行下滤&lt;/span&gt;
        PercolateDown(a,min,size);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续处理下一棵树&lt;/span&gt;
&lt;span&gt;    }
    
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Display(PriorityQueue H){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=H-&amp;gt;size;i++&lt;span&gt;)
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,H-&amp;gt;&lt;span&gt;Element[i]);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; BuildHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N,PriorityQueue H) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=N/&lt;span&gt;2&lt;/span&gt;;i&amp;gt;&lt;span&gt;0&lt;/span&gt;;i--&lt;span&gt;)
        PercolateDown(H&lt;/span&gt;-&amp;gt;Element, i, H-&amp;gt;&lt;span&gt;size);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    srand(time(nullptr));
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
    PriorityQueue pq&lt;/span&gt;=&lt;span&gt;Init(n);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++) Insert(rand()%&lt;span&gt;988&lt;/span&gt;&lt;span&gt;, pq);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    BuildHeap(n, pq);&lt;/span&gt;
&lt;span&gt;    Display(pq);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The min is %d.\n After deletion the heap is:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,DeleteMin(pq));
    Display(pq);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下一篇是优先队列里的又一变种，你猜猜是哪个？&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 03:51:00 +0000</pubDate>
<dc:creator>仪式黑刃</dc:creator>
<og:description>二叉堆是一种典型的优先队列实现策略，广义而言，堆是优先队列的实现方式，在此之下又分为二叉堆，左式堆，斜堆，二项队列等具体形态。但第一个用得太普遍了，所以我们平时一说到堆(Heap)指的就是二叉堆。基本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongshijie/p/9607461.html</dc:identifier>
</item>
<item>
<title>Nginx（三）------nginx 反向代理 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9392908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9392908.html</guid>
<description>&lt;p&gt;　　Nginx 服务器的反向代理服务是其最常用的重要功能，由反向代理服务也可以衍生出很多与此相关的 Nginx 服务器重要功能，比如后面会介绍的负载均衡。本篇博客我们会先介绍 Nginx 的反向代理，当然在了解反向代理之前，我们需要先知道什么是代理以及什么是正向代理。&lt;/p&gt;
&lt;h3&gt;1、代理&lt;/h3&gt;
&lt;p&gt;　　在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。&lt;/p&gt;
&lt;p&gt;　　可能大家不太明白这句话，在举一个现实生活中的例子：比如我们要买一间二手房，虽然我们可以自己去找房源，但是这太花费时间精力了，而且房屋质量检测以及房屋过户等一系列手续也都得我们去办，再说现在这个社会，等我们找到房源，说不定房子都已经涨价了，那么怎么办呢？最简单快捷的方法就是找二手房中介公司（为什么？别人那里房源多啊），于是我们就委托中介公司来给我找合适的房子，以及后续的质量检测过户等操作，我们只需要选好自己想要的房子，然后交钱就行了。&lt;/p&gt;
&lt;p&gt;　　代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。那么这个例子里面的中介公司就是给我们做代理服务的，我们委托中介公司帮我们找房子。&lt;/p&gt;
&lt;p&gt;　　Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180905232339438-913760288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、正向代理&lt;/h3&gt;
&lt;p&gt;　　弄清楚什么是代理了，那么什么又是正向代理呢？&lt;/p&gt;
&lt;p&gt;　　这里我再举一个例子：大家都知道，现在国内是访问不了 Google的，那么怎么才能访问 Google呢？我们又想，美国人不是能访问 Google吗（这不废话，Google就是美国的），如果我们电脑的对外公网 IP 地址能变成美国的 IP 地址，那不就可以访问 Google了。你很聪明，VPN 就是这样产生的。我们在访问 Google 时，先连上 VPN 服务器将我们的 IP 地址变成美国的 IP 地址，然后就可以顺利的访问了。&lt;/p&gt;
&lt;p&gt;　　这里的 VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。&lt;/p&gt;
&lt;p&gt;　　PS：这里介绍一下什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的 LOL，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的LOL就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。&lt;/p&gt;
&lt;p&gt;　　可能听到这里大家还是很抽象，没关系，和下面的反向代理对比理解就简单了。&lt;/p&gt;
&lt;h3&gt;3、反向代理&lt;/h3&gt;
&lt;p&gt;　　反向代理和正向代理的区别就是：&lt;strong&gt;正向代理代理客户端，反向代理代理服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。&lt;/p&gt;
&lt;p&gt;　　下面我们通过两张图来对比正向代理和方向代理：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180730224449157-560730759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180730224512924-952923331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。&lt;/p&gt;
&lt;p&gt;　　总结起来还是一句话：&lt;strong&gt;正向代理代理客户端，反向代理代理服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4、Nginx 反向代理&lt;/h3&gt;
&lt;p&gt;　　范例：使用 nginx 反向代理 www.123.com 直接跳转到127.0.0.1:8080&lt;/p&gt;
&lt;p&gt;　　①、启动一个 tomcat，浏览器地址栏输入 127.0.0.1:8080，出现如下界面&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180905235823351-2004614694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　②、通过修改本地 host 文件，将 www.123.com 映射到 127.0.0.1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; www.&lt;span&gt;123&lt;/span&gt;.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将上面代码添加到 Windows 的host 文件中，该文件位置在：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180905235941289-1726293918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　配置完成之后，我们便可以通过 www.123.com:8080 访问到第一步出现的 Tomcat初始界面。&lt;/p&gt;
&lt;p&gt;　　那么如何只需要输入 www.123.com 便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。&lt;/p&gt;
&lt;p&gt;　　③、在 nginx.conf 配置文件中增加如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         listen       80&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         server_name  www.123&lt;span&gt;.com;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8080;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            index  index.html index.htm index.jsp;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上配置，我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。&lt;/p&gt;
&lt;p&gt;　　我们在浏览器端输入 www.123.com 结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201809/1120165-20180906073551600-75534434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　④、总结&lt;/p&gt;
&lt;p&gt;　　其实这里更贴切的说是通过nginx代理端口，原先访问的是8080端口，通过nginx代理之后，通过80端口就可以访问了。&lt;/p&gt;
&lt;h3&gt;5、Nginx 反向代理相关指令介绍&lt;/h3&gt;
&lt;h4&gt;①、listen&lt;/h4&gt;
&lt;p&gt;　　该指令用于配置网络监听。主要有如下三种配置语法结构：&lt;/p&gt;
&lt;p&gt;　　一、配置监听的IP地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=&lt;span&gt;size] [deferred]
    [accept_filter&lt;/span&gt;=filter] [bind] [ssl];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　二、配置监听端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
listen port[default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=&lt;span&gt;filter] 
    [deferred] [bind] [ipv6only&lt;/span&gt;=on|off] [ssl];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　三、配置 UNIX Domain Socket&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
listen unix:path [default_server]  [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=&lt;span&gt;filter] 
    [deferred] [bind] [ssl];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的配置看似比较复杂，其实使用起来是比较简单的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; listen *:80 | *:8080&lt;span&gt; #监听所有80端口和8080端口
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;listen  IP_address:port   #监听指定的地址和端口号
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;listen  IP_address     #监听指定ip地址所有端口
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; listen port     #监听该端口的所有IP连接
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面分别解释每个选项的具体含义：&lt;/p&gt;
&lt;p&gt;　　1、address:IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。&lt;/p&gt;
&lt;p&gt;　　2、port:端口号，如果只定义了IP地址，没有定义端口号，那么就使用80端口。&lt;/p&gt;
&lt;p&gt;　　3、path:socket文件路径，如 var/run/nginx.sock等。&lt;/p&gt;
&lt;p&gt;　　4、default_server:标识符，将此虚拟主机设置为 address:port 的默认主机。（在 nginx-0.8.21 之前使用的是 default 指令）&lt;/p&gt;
&lt;p&gt;　　5、 setfib=number:Nginx-0.8.44 中使用这个变量监听 socket 关联路由表，目前只对 FreeBSD 起作用，不常用。&lt;/p&gt;
&lt;p&gt;　　6、backlog=number:设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在 FreeBSD 中默认为 -1,其他平台默认为511.&lt;/p&gt;
&lt;p&gt;　　7、rcvbuf=size:设置监听socket接收缓存区大小。&lt;/p&gt;
&lt;p&gt;　　8、sndbuf=size:设置监听socket发送缓存区大小。&lt;/p&gt;
&lt;p&gt;　　9、deferred:标识符，将accept()设置为Deferred模式。&lt;/p&gt;
&lt;p&gt;　　10、accept_filter=filter:设置监听端口对所有请求进行过滤，被过滤的内容不能被接收和处理，本指令只在 FreeBSD 和 NetBSD 5.0+ 平台下有效。filter 可以设置为 dataready 或 httpready 。&lt;/p&gt;
&lt;p&gt;　　11、bind:标识符，使用独立的bind() 处理此address:port，一般情况下，对于端口相同而IP地址不同的多个连接，Nginx 服务器将只使用一个监听指令，并使用 bind() 处理端口相同的所有连接。&lt;/p&gt;
&lt;p&gt;　　12、ssl:标识符，设置会话连接使用 SSL模式进行，此标识符和Nginx服务器提供的 HTTPS 服务有关。&lt;/p&gt;
&lt;h4&gt;②、server_name&lt;/h4&gt;
&lt;p&gt;　　该指令用于虚拟主机的配置。通常分为以下两种：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、基于名称的虚拟主机配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
server_name   name ...;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一、对于name 来说，可以只有一个名称，也可以有多个名称，中间用空格隔开。而每个名字由两段或者三段组成，每段之间用“.”隔开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
server_name 123.com www.123.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　二、可以使用通配符“*”，但通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
server_name *.123.com www.123.*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三、还可以使用正则表达式，用“~”作为正则表达式字符串的开始标记。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
server_name ~^www\d+\.123\.com$;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该表达式“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，在紧跟“.123.co”，最后跟着“m”($表示结尾)&lt;/p&gt;
&lt;p&gt;　　以上匹配的顺序优先级如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;①、准确匹配 server_name
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;②、通配符在开始时匹配 server_name 成功
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;③、通配符在结尾时匹配 server_name 成功
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; ④、正则表达式匹配 server_name 成功
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2、基于 IP 地址的虚拟主机配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　语法结构和基于域名匹配一样，而且不需要考虑通配符和正则表达式的问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
server_name 192.168.1.1
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;③、location&lt;/h4&gt;
&lt;p&gt;　　该指令用于匹配 URL。&lt;/p&gt;
&lt;p&gt;　　语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; location [ = | ~ | ~* | ^~&lt;span&gt;] uri {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。&lt;/p&gt;
&lt;p&gt;　　2、~：用于表示 uri 包含正则表达式，并且区分大小写。&lt;/p&gt;
&lt;p&gt;　　3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。&lt;/p&gt;
&lt;p&gt;　　4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。&lt;/p&gt;
&lt;p&gt;　　注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。&lt;/p&gt;
&lt;h4&gt;④、proxy_pass&lt;/h4&gt;
&lt;p&gt;　　该指令用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。&lt;/p&gt;
&lt;p&gt;　　语法结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
proxy_pass URL;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　URL 为被代理服务器的地址，可以包含传输协议、主机名称或IP地址加端口号，URI等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
proxy_pass  http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.123.com/uri;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;⑤、index&lt;/h4&gt;
&lt;p&gt;　　该指令用于设置网站的默认首页。&lt;/p&gt;
&lt;p&gt;　　语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
index  filename ...;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　后面的文件名称可以有多个，中间用空格隔开。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
index  index.html index.jsp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通常该指令有两个作用：第一个是用户在请求访问网站时，请求地址可以不写首页名称；第二个是可以对一个请求，根据请求内容而设置不同的首页。&lt;/p&gt;
&lt;p&gt;参考文档：苗泽老师的《Nginx高性能Web服务器详解》&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 03:29:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Nginx（三）------nginx 反向代理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9392908.html</dc:identifier>
</item>
<item>
<title>netcore编程之后面对不习惯的xshell黑屏部署，是时候使用jenkins自动化发布工具了 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/9608410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/9608410.html</guid>
<description>
&lt;p&gt;　  在很久之前net还只能在windows上部署的时候，或许很多创业公司的朋友发布项目还都是人肉部署，反正windows都是可视化的界面，拖拖拉拉，开开关关还不&lt;/p&gt;
&lt;p&gt;是特别麻烦。。。现如今你的项目需要在linux上部署，可惜的是再也没有什么可视化的界面给你，全在xshell上操作，如果在xshell上部署个位数的项目大家或许还可&lt;/p&gt;
&lt;p&gt;以接受，如果要部署10+以上的服务呢，估计很多人在xshell上敲的头都大了。。。这就是为什么docker会有dockerfile，会有容器编排的docker-compose，所以找&lt;/p&gt;
&lt;p&gt;一款自动化发布工具迫在眉睫了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一： Jenkins部署&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　它的官方网址是：https://jenkins.io/download/  ，使用docker模式部署的话太简单了，本篇就不用Docker部署，而是直接部署到宿主机Centos上，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908094040745-79878261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 导入jenkins的key&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;wget&lt;/span&gt; -O /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/jenkins.repo https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pkg.jenkins.io/redhat-stable/jenkins.repo&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; rpm --import https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pkg.jenkins.io/redhat-stable/jenkins.io.key&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2. 使用yum安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; jenkins
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3. 启动jenkins&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; service jenkins start&lt;/span&gt;
Starting jenkins (via systemctl):                          [  OK  ]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4. 然后在浏览器中输入你的虚拟机IP：  http://192.168.23.173:8080,看到下面的界面就算成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908100154507-1144863009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后大家就可以按照步骤一步一步下去就可以了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二：构建你的netcore程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　 先提供一个简单的test程序，供后续做自动化部署只用。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bgtask = Task.Run(() =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
                {
                    Log.Info($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i={i}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                }
            });

            AppDomain.CurrentDomain.ProcessExit &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                Log.Info($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} 恭喜，TestService服务程序已准备退出！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Environment.Exit(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            };

            bgtask.Wait();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;三：jenkins配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  点击新建任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908100956364-2131467977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. 选择构建一个自由风格的软件项目，然后点击确定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908101132605-2126700204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.   这里的“源码管理”tab页是非常重要的，默认支持git和svn，这里就选择svn了，把你生成svn的地址贴上去，因为后续&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      执行shell脚本的时候，会在jenkins&lt;/span&gt;&lt;span&gt;的workspace文件夹中执行dotnet publish 的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908101326604-1935749049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. 在“构建” tab页中，最最重要的就是里面的shell脚本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908101956941-361321315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ps&lt;/span&gt; -ef | &lt;span&gt;grep&lt;/span&gt; MemSql.Test.dll | &lt;span&gt;grep&lt;/span&gt; -v &lt;span&gt;grep&lt;/span&gt; | &lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $2}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | &lt;span&gt;xargs&lt;/span&gt; --no-run-&lt;span&gt;if&lt;/span&gt;-empty &lt;span&gt;kill&lt;/span&gt;&lt;span&gt;
cd .&lt;/span&gt;/&lt;span&gt;MemSql.Test
&lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; -p /data/output/MemSql.Test/&lt;span&gt;v${BUILD_NUMBER}
dotnet publish &lt;/span&gt;-o /data/output/MemSql.Test/v${BUILD_NUMBER} -&lt;span&gt;c Release
cd &lt;/span&gt;/data/output/MemSql.Test/&lt;span&gt;v${BUILD_NUMBER}
BUILD_ID&lt;/span&gt;=dontKillMe nohup dotnet MemSql.Test.dll &amp;amp;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   这里要关心的几处是：&lt;/p&gt;
&lt;p&gt;  &lt;span&gt; 《1》 在kill pid的时候，如果pid不存在，你的默认脚本会报pid不存在的错误的，所以加上 --no-run-if-empty  的if判断，没有就&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             不执行kill。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;《2》 使用了一个Jenkins的一个环境变量 {BUILD_NUMBER} , 也就是下图中的这个位置，用这个编译版本号作为文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908102348382-493431966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  《3》 因为我是用nohup生成后台进程的，所以要使用dotKillMe命令让jenkins不要在生成完后kill 它。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;然后点击保存，这个Test项目的自动化部署就搞定了。。。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四：操作流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       在操作之前，一定要记得让 jenkins用户提升一下权限，否则你的 copy，mkdir可能权限不足，这里我就提升成root权限。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1： 把jenkins用户加入到root组中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gpasswd -a root jenkins
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2：修改/etc/sysconfig/jenkins文件， 把原来的 users= jenkins 改成root。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Unix user account that runs the Jenkins daemon
# Be careful when you change this, as you need to update
# permissions of $JENKINS_HOME and /var/log/&lt;span&gt;jenkins.
#
JENKINS_USER=&quot;root&quot;&lt;span&gt;
JENKINS_GROUP=&quot;root&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3：重启Jenkins即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service Jenkins restart
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4. 然后你的步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   《1》 在svn中提交代码。&lt;/p&gt;
&lt;p&gt;  《2》 找到你的所属项目，点击“立即构建”。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908110239187-692571074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    当然也可以让jenkins自动化构建，但是考虑到生成项目，最好还是加上手工发布这个按钮，安全可靠， 构建完之后，大家可以看看 jenkins的 “控制台输出”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908103428001-2045880199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后你可以通过ftp去生产看一下，果然都跑起来了，v21就是我的编译版本号，而且你的日志果然就是我的业务逻辑输出，对吧，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908104411040-564547312.png&quot; alt=&quot;&quot; width=&quot;919&quot; height=&quot;384&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这时候，你觉得代码有问题，需要修改一下，把i 改成 m ，接下来的步骤也就是 “提交代码” -&amp;gt; “可视化立即编译”  -&amp;gt;  &quot;查看结果&quot; 这样的流水线作业而已啦。。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/214741/201809/214741-20180908105224074-1387031508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了，本篇就说到这里，希望对你有帮助。&lt;/p&gt;

</description>
<pubDate>Sat, 08 Sep 2018 03:04:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>在很久之前net还只能在windows上部署的时候，或许很多创业公司的朋友发布项目还都是人肉部署，反正windows都是可视化的界面，拖拖拉拉，开开关关还不 是特别麻烦。。。现如今你的项目需要在lin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangxincheng/p/9608410.html</dc:identifier>
</item>
<item>
<title>[详细实例]MicroPython拼插编程实战：DIY一台会思考的壁障车 - 小五义</title>
<link>http://www.cnblogs.com/xiaowuyi/p/9608317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaowuyi/p/9608317.html</guid>
<description>&lt;p&gt;（转载请注明文章来源，更多教程可自助参考www.tpyboard.com，QQ技术交流群：157816561，公众号：MicroPython玩家汇）&lt;/p&gt;
&lt;p&gt;在日常生活中，大家会经常见到各种各样的遥控车，它需要我们人为的操作，控制它的前进、后退和转弯。今天就带大家认识一个不一样的新朋友--“会思考的避障车”。“会思考的避障车”和我们平时的遥控车最主要的区别就是智能化，它可以不需要我们去操控，自己就能行走。同时它还会实时检测前方是否有障碍物，思考自己是否要前进或者转弯。看到这里，是不是已经跃跃欲试了呢。话不多说，动起手来吧！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104213394-1508604005.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;一、 所需器材：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、TurnipBit开发板 1块（TB上可以买到）&lt;br/&gt;2、下载数据线 1条&lt;br/&gt;3、智能小车套件 1套（底盘、车轮、电机等）&lt;br/&gt;4、超声波模块（HC-SR04）1个（用作小车的“眼睛”）&lt;br/&gt;5、L298N电机驱动模块 1个&lt;br/&gt;6、接入互联网的电脑 1台（推荐使用Google Chome或者Firefox浏览器）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、壁障车的组装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步，先把小车底板、紧固件、码盘的黄色保护纸撕掉，然后把紧固件插入小车底板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104231409-1341316684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步，安装码盘，并把电机固定于底板。码盘轴心一面大一面小，大的一面往电机轴插（注意：电机引线铜片朝向内侧，即码盘一端）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104250605-1103373401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步，插入螺丝，把电机固定到小车底板，并拧上螺帽。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104303740-1098478339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第四步，插入螺丝，固定电池盒。本实验中这一步可以省略，我们使用充电宝进行供电。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104314490-968943540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第五步，放入铜柱，拧紧8个螺丝固定万向轮，手捏住电机（保护紧固件），并往里面插入轮子，组装完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104324617-1928990015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后，我们来看一下组装完成的效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104336327-1012216764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、电机驱动和超声波的安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;硬件的连接，主要是各引脚间的连接。具体为（详见下表）：超声波模块共4个引脚，分别是VCC、GND、Trig和Echo。VCC接TurnipBit扩展板的+5V引脚，GND接TurnipBit扩展板的GND引脚，Trig触发引脚接P5，Echo回传引脚接P8。L298N电机驱动模块左侧OUT3、OUT4接线端子对应接入左轮电机的下侧、上侧侧铜片，右侧也是。L298N的输入端IN1、IN2、IN3、IN4分别接入扩展板的P19、P13、P12、P11。最后，本实验利用充电宝进行供电，只需将充电板通过usb线连接TurnipBit开发板的microusb口即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104402784-1654828477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104413751-210161097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104429217-1727748794.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;四、拼插编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;步骤1：因为P11和P12控制一个车轮，P13和P19控制一个车轮，只需要给相应车轮的P12和P19高电平，另外两个引脚低高平，避障车两个车轮就会转动，如果此时转动方向两个轮子不同或者是向后，说明你在连线时没有注意连接的L298N的引脚，只需要调换一下，避障车就会向前走，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104504858-278599300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤2：添加一个死循环，使程序一直运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104526873-660581624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤3：接下来就需要完成检测障碍物的功能，这部分需要超声波模块来实现。我们需要在死循环内添加障碍物检测的内容，让避障车一直不断的检测与前方障碍物的距离。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104614462-757901885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;步骤4：为了更简单、方便、快捷的实现功能，我们采用计数的方式，测量一个大概的距离，然后进行判定是否进行避障。细心的同学可能会发现我们在程序一开始的时候定义了一个num的变量，我们就用num来计数。当引脚8为高电平时，表示超声波模块的echo进入接收模式，我们就不断的让num自加1，一直等到超声波模块接收到返回的信号，即引脚8为低电平时，停止计数。这里的num就能反映出当前小车与障碍物之间的距离。这里以25厘米为安全距离进行测试，发现num的数值为8。于是说明，如果小车与障碍物之间的距离小于25厘米时，num就小于8。所以程序中判断如果num的值小于或等于8时，就进行转向避障。&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104628564-1487384145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;步骤5：到此，会思考的避障车已经完成了。为了让避障车更加炫酷，我们可以使用LED屏来动态显示当前避障车行驶的方向。方法是在小车做出转向动作前，先用箭头来显示转向的方向，然后再做动作。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104643582-1647522463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤6：将程序名修改成turnipbit-car，点击【下载hex】按钮将程序保存到电脑里。把保存的turnipbit- car.hex文件拖入TurnipBit磁盘中，我们会看到TurnipBit板子上的灯在闪烁，说明正在下载到控制板中。下载成功后，将TurnipBit正确插入TurnipBit扩展板的金手指卡槽内，开始启动避障车吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/383503/201809/383503-20180908104716339-700546952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;（转载请注明文章来源，更多教程可自助参考www.tpyboard.com，QQ技术交流群：157816561，公众号：MicroPython玩家汇）&lt;/p&gt;
</description>
<pubDate>Sat, 08 Sep 2018 02:49:00 +0000</pubDate>
<dc:creator>小五义</dc:creator>
<og:description>在日常生活中，大家会经常见到各种各样的遥控车，它需要我们人为的操作，控制它的前进、后退和转弯。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaowuyi/p/9608317.html</dc:identifier>
</item>
</channel>
</rss>