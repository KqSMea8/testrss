<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java集合（4）一 红黑树、TreeMap与TreeSet（下） - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/7894499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/7894499.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/konck/p/7739471.html&quot;&gt;Java集合（1）一 集合框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/konck/p/7758265.html&quot;&gt;Java集合（2）一 ArrayList 与 LinkList&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/konck/p/7894493.html&quot;&gt;Java集合（3）一 红黑树、TreeMap与TreeSet（上）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/konck/p/7894499.html&quot;&gt;Java集合（4）一 红黑树、TreeMap与TreeSet（下）&lt;/a&gt;&lt;br/&gt;Java集合（5）一 HashMap与HashSet&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/konck/p/7894493.html&quot;&gt;Java集合（3）一 红黑树、TreeMap与TreeSet（上）&lt;/a&gt;中从二叉树的遍历、添加和删除引申到了红黑树的遍历、添加和删除。对二叉树结构有了一定的了解，在这篇文章中将会对红黑树进行详细的说明。&lt;/p&gt;
&lt;h2 id=&quot;红黑树&quot;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;二叉树在理想情况下时间复杂度是O(logn)，最坏情况下当插入的数据由小到大或者由大到小排列的时候，二叉树就变成了一个链表，而我们知道链表检索的时间复杂度是O(n)，效率非常差，所以出现了AVL树和红黑树来改变这种状况。同时由于AVL树的极端平衡特性，导致添加和删除数据后需要过多的旋转操作来保证AVL树平衡的特征，所以TreeMap中会使用红黑树来存储数据。&lt;br/&gt;最好情况下的二叉树：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182020323-1213473551.png&quot;/&gt;&lt;br/&gt;最差情况下的二叉树：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182029386-601615686.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;树旋转&quot;&gt;树旋转&lt;/h2&gt;
&lt;p&gt;当AVL树在添加或者删除节点时出现不平衡后通过什么操作来保证树的平衡性呢？这种操作就叫做书旋转。红黑树也是如此，不过红黑树更复杂，这点我们后面再说，先来看看AVL树的旋转操作。&lt;br/&gt;树旋转操作是由于二叉树在添加节点时为了避免出现平衡失效的情况而做的一种操作，操作的基本原则是操作后不影响二叉树中序遍历的结果。&lt;br/&gt;这里我们用AVL树来说明这个问题。AVL树是一种高度平衡的二叉树，他的任何两个节点的子树的高度最大差别为1，这样他的查找、插入和删除的时间复杂度都是O(logn)，当出现不平衡情况的时候，就需要执行树旋转。&lt;/p&gt;
&lt;h2 id=&quot;旋转操作&quot;&gt;旋转操作&lt;/h2&gt;
&lt;p&gt;树的旋转操作分为两种，左旋转和右旋转，这两种旋转是相对的。通过右旋或者左旋操作我们可以使一棵树继续保持平衡状态，并不会改变中序遍历的结果，但同时也要付出相应的代价。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182036011-902047122.png&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;//右旋&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(Entry&amp;lt;K,V&amp;gt; p) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        Entry&amp;lt;K,V&amp;gt; l = p.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;;
        p.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = l.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (l.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) l.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = p;
        l.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            root = l;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; == p)
            p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = l;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = l;
        l.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = p;
        p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = l;
    }
}
&lt;span class=&quot;co&quot;&gt;//左旋&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(Entry&amp;lt;K,V&amp;gt; p) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        Entry&amp;lt;K,V&amp;gt; r = p.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;;
        p.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = r.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (r.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            r.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = p;
        r.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            root = r;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; == p)
            p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = r;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = r;
        r.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = p;
        p.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt; = r;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;avl树旋转的几种情况&quot;&gt;AVL树旋转的几种情况&lt;/h2&gt;
&lt;p&gt;当树的任何两个节点的子树的高度差大于1的时候，就需要进行旋转以保证任何两个节点的子树的高度最大差别为1。哪几种情况下需要进行树旋转操作？&lt;br/&gt;1.左左情况，左节点比右节点多两个节点，并且多出的节点都在左子树；&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182045167-1379871123.png&quot;/&gt;&lt;br/&gt;2.右右情况，右节点比左节点多两个节点，并且多出的节点都在右子树；&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182056339-915968708.png&quot;/&gt;&lt;br/&gt;3.左右情况，左节点或者右节点多出两个节点，多出的第一个节点在左子树，第二个节点在右子树；&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182111761-1782855971.png&quot;/&gt;&lt;br/&gt;4.右左情况，左节点或者右节点多出两个节点，多出的第一个节点在右子树，第二个节点在左子树；&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182104229-341130627.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;红黑树的特性&quot;&gt;红黑树的特性&lt;/h2&gt;
&lt;p&gt;明白了AVL树的旋转操作，再来看红黑树就简单多了，红黑树就是一颗满足一定条件的，相对平衡的二叉树，是二叉树和AVL树的一种折中。&lt;br/&gt;红黑树的添加删除操作同二叉树一样，但是当添加删除等操作后使红黑树失去了他的特性后，就需要进行旋转操作来恢复红黑树的特性。&lt;br/&gt;红黑树需要满足以下几点性质：&lt;br/&gt;1.每个节点要么是红色，要么是黑色。&lt;br/&gt;2.根节点永远是黑色的。&lt;br/&gt;3.所有的叶节点都是空节点（即 null），并且是黑色的。&lt;br/&gt;4.每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）&lt;br/&gt;5.从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。&lt;br/&gt;性质1和性质2很好理解。性质3在Java里面指的是空节点，一般不用考虑。性质4保证了从根到叶子节点的最长路径最多只能是最短路径的两倍，根据性质5建立一颗黑色节点为3的红黑树，最短路径为黑-黑-黑，最长路径为黑-红-黑-红-黑-红（因为每个红色节点的两个子节点都是黑色，红色则不可连续）。&lt;br/&gt;下图是一颗标准的红黑树：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182119636-1016410750.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;红黑树添加后修复&quot;&gt;红黑树添加后修复&lt;/h2&gt;
&lt;p&gt;在上一篇文章中的添加操作后调用了fixAfterInsertion(e)方法用来修复被破坏的红黑树性质。&lt;br/&gt;一般默认每个添加的节点都为红色，因为添加的节点如果为黑色，那就一定会破坏性质5，而且很难修复。但如果添加的是红色节点，有可能就不会破坏任何性质，也可能会破坏性质4导致连续的红色节点，可以通过变色和旋转来修复。&lt;br/&gt;在添加红色节点时可能会遇到以下几种情况：&lt;br/&gt;1.新节点为根节点，父节点为空，破坏性质2，修复红色为黑色即可。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182127620-962426513.png&quot;/&gt;&lt;br/&gt;2.新节点的父节点为黑色，添加的新节点为红色，不破坏任何性质。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182136323-1004305207.png&quot;/&gt;&lt;br/&gt;3.新节点的父节点为红色，同时父节点的兄弟节点也为红色（根据性质4，父节点的父节点为黑色），添加的新节点也为红色，破坏了性质4，修复父节点和父节点的兄弟节点为黑色，同时父节点的父节点为红色，保证性质5不被破坏。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182145042-1437022653.png&quot;/&gt;&lt;br/&gt;4.新节点的父节点为红色，同时父节点的兄弟节点为黑色或为空（空也为黑色）。如果新节点为父节点的左节点，但新节点的父节点为祖父节点的右节点；或者新节点为父节点的右节点，但新节点的父节点为祖父节点的左节点，就需要先右旋或者左旋，然后转换成情况5，再进行一次着色和旋转。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182152292-1177987021.png&quot;/&gt;&lt;br/&gt;5.新节点的父节点为红色，同时父节点的兄弟节点为黑色或为空（空也为黑色）。如果新节点为父节点的左节点，同时新节点的父节点也为祖父节点的左节点；或者新节点为父节点的右节点，同时新节点的父节点也为祖父节点的右节点。设置新节点的父节点为黑色，设置新节点的祖父节点为红色，然后左旋或者右旋即可。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182201542-2061750553.png&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fixAfterInsertion&lt;/span&gt;(Entry&amp;lt;K,V&amp;gt; x) {
    x.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = RED;
    &lt;span class=&quot;co&quot;&gt;//情况2 x.parent.color == BLACK&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (x != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; x != root &amp;amp;&amp;amp; x.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; == RED) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x) == &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)))) {
            Entry&amp;lt;K,V&amp;gt; y = &lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)));
            &lt;span class=&quot;co&quot;&gt;//情况3 父节点的兄弟节点也为红色 不需要旋转&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(y) == RED) {
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(y, BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)), RED);
                x = &lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//情况4 父节点的兄弟节点为黑色 父节点为祖父节点的左节点 x为父节点的右节点 先左旋变为情况5&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x == &lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x))) {
                    x = &lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x);
                    &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(x);
                }
                &lt;span class=&quot;co&quot;&gt;//情况5 父节点的兄弟节点为黑色 父节点为祖父节点的左节点 x也为父节点的左节点 改变父节点为黑色 祖父节点为红色 然后祖父节点右旋&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)), RED);
                &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)));
            }
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            Entry&amp;lt;K,V&amp;gt; y = &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)));
            &lt;span class=&quot;co&quot;&gt;//情况3&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(y) == RED) {
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(y, BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)), RED);
                x = &lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//情况4 父节点的兄弟节点为黑色 父节点为祖父节点的右节点 x为父节点的左节点 先右旋变为情况5&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x == &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x))) {
                    x = &lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x);
                    &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(x);
                }
                &lt;span class=&quot;co&quot;&gt;//情况5 父节点的兄弟节点为黑色 父节点为祖父节点的右节点 x也为父节点的右节点 改变父节点为黑色 祖父节点为红色 然后祖父节点左旋&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)), RED);
                &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)));
            }
        }
    }
    &lt;span class=&quot;co&quot;&gt;//情况1&lt;/span&gt;
    root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = BLACK;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;红黑树删除后修复&quot;&gt;红黑树删除后修复&lt;/h2&gt;
&lt;p&gt;红黑树在删除后调用了fixAfterDeletion(p)用来修复被破坏的红黑树性质。&lt;br/&gt;由于在删除时我们采用后继节点替换的方法，替换之后只需要删除替换的节点即可。这样删除节点的问题就可以转换为删除至多只有1个孩子节点的问题（因为后继节点至多只有右孩子，或者没有孩子）。&lt;br/&gt;删除时有以下几种情况：&lt;br/&gt;1.删除的节点为红色，根据红色节点不可连续，则他的父节点和子节点都为黑色，直接用他的黑色子节点替换即可，删除了红色节点不会破坏性质5。&lt;br/&gt;2.删除的节点为黑色，但是儿子为红色，直接用红色节点替换，替换后变红色节点为黑色即可。&lt;br/&gt;3.删除的节点为黑色，同时儿子也为黑色，这种情况比较复杂，又可以分为几种情况：&lt;br/&gt;将儿子命名为S，儿子替换后的父亲命名为F，儿子替换后的兄弟命名为B，兄弟的左节点命名为BL，兄弟的右节点命名为BR，情况3又可以分为以下几种情况：&lt;br/&gt;4.F为任意色，B为红色，将F左旋转，并交换F和B的颜色，则通过各自路径的黑色节点数目不变，但S现在有了一个红色的父节点F，一个黑色的兄弟节点B，则情况可以变成5、6或者7。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182210839-2092278809.png&quot;/&gt;&lt;br/&gt;5.F为任意色，B为黑色，BL和BR也为黑色，只需要将B的颜色设置为红色，则通过B的路径少了一个黑色节点和通过S的黑色节点相等了，但通过F的路径少了一个黑色节点，可以重新从第一种情况进行迭代。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182219214-1437047759.png&quot;/&gt;&lt;br/&gt;6.F为任意色，B为黑色，BL为红色，BR为黑色，将B右旋，这样就变成了情况7。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182227526-515988141.png&quot;/&gt;&lt;br/&gt;7.F为任意色，B为黑色，BL为黑色，BR为红色，将F左旋，同时交换F和B和颜色即可。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/368583/201711/368583-20171130182235511-1067061366.png&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;30&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fixAfterDeletion&lt;/span&gt;(Entry&amp;lt;K,V&amp;gt; x) {
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (x != root &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(x) == BLACK) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x == &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x))) {
            Entry&amp;lt;K,V&amp;gt; sib = &lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
            &lt;span class=&quot;co&quot;&gt;//情况4 F为任意色，B为红色 情况可以变成5、6或者7&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(sib) == RED) {
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), RED);
                &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
                sib = &lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
            }
            &lt;span class=&quot;co&quot;&gt;//情况5 F为任意色，B为黑色，BL和BR也为黑色&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(sib))  == BLACK &amp;amp;&amp;amp;
                &lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(sib)) == BLACK) {
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, RED);
                x = &lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//情况6 F为任意色，B为黑色，BL为红色，BR为黑色&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(sib)) == BLACK) {
                    &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(sib), BLACK);
                    &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, RED);
                    &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(sib);
                    sib = &lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
                }
                &lt;span class=&quot;co&quot;&gt;//情况7 F为任意色，B为黑色，BL为黑色，BR为红色&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, &lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)));
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(sib), BLACK);
                &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
                x = root;
            }
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;co&quot;&gt;// symmetric&lt;/span&gt;
            Entry&amp;lt;K,V&amp;gt; sib = &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
            &lt;span class=&quot;co&quot;&gt;//情况4 F为任意色，B为红色 情况可以变成5、6或者7&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(sib) == RED) {
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), RED);
                &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
                sib = &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
            }
            &lt;span class=&quot;co&quot;&gt;//情况5 F为任意色，B为黑色，BL和BR也为黑色&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(sib)) == BLACK &amp;amp;&amp;amp;
                &lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(sib)) == BLACK) {
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, RED);
                x = &lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;//情况6 F为任意色，B为黑色，BL为红色，BR为黑色 旋转着色后变为情况7&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(sib)) == BLACK) {
                    &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;rightOf&lt;/span&gt;(sib), BLACK);
                    &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, RED);
                    &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(sib);
                    sib = &lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
                }
                &lt;span class=&quot;co&quot;&gt;//情况7 F为任意色，B为黑色，BL为黑色，BR为红色&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(sib, &lt;span class=&quot;fu&quot;&gt;colorOf&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x)));
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x), BLACK);
                &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;leftOf&lt;/span&gt;(sib), BLACK);
                &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;parentOf&lt;/span&gt;(x));
                x = root;
            }
        }
    }

    &lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(x, BLACK);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;理解了红黑树遍历，删除添加等操作的分析，再理解TreeMap&amp;lt;K,V&amp;gt;实现逻辑就会很容易。TreeMap&amp;lt;K,V&amp;gt;所有的操作都是在红黑树的基础上执行的，红黑树的每一个节点对应为TreeMap&amp;lt;K,V&amp;gt;的一个Entry&amp;lt;K,V&amp;gt;。&lt;br/&gt;TreeSet&amp;lt;E&amp;gt;由于在实现上完全使用了TreeMap&amp;lt;K,V&amp;gt;的key来实现，所以TreeSet&amp;lt;E&amp;gt;的所有操作一样是建立在红黑树的基础上。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Dec 2017 23:36:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/7894499.html</dc:identifier>
</item>
<item>
<title>CS:APP3e 深入理解计算机系统_3e CacheLab实验 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/8026100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/8026100.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;strong&gt;详细的题目要求和资源可以到 &lt;a href=&quot;http://csapp.cs.cmu.edu/3e/labs.html&quot; class=&quot;uri&quot;&gt;http://csapp.cs.cmu.edu/3e/labs.html&lt;/a&gt; 或者 &lt;a href=&quot;http://www.cs.cmu.edu/&quot; class=&quot;uri&quot;&gt;http://www.cs.cmu.edu/&lt;/a&gt;~./213/schedule.html 获取。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本次实验难点在Part B的64 * 64部分，主要介绍这一部分。&lt;/p&gt;
&lt;h2 id=&quot;part-a-编写缓存模拟器&quot;&gt;&lt;span&gt;Part A: 编写缓存模拟器&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;前期准备&quot;&gt;&lt;span&gt;&lt;strong&gt;前期准备：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;getopt&lt;/code&gt;和&lt;code&gt;fscanf&lt;/code&gt;系列库函数对于这次实验很重要，不太明白的可以&lt;code&gt;man&lt;/code&gt;一下，或者参考这两篇文章：&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;&lt;span&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.由于我们的模拟器必须适应不同的s, E, b，所以数据结构必须动态申请（malloc系列），注意初始化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.测试数据中以“I”开头的行是对指令缓存（i-cache）进行读写，我们编写的是数据缓存（d-cache），这些行直接忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.这次实验假设内存全部对齐，即数据不会跨越block，所以测试数据里面的数据大小也可以忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.为了使得评分程序正常运行，&lt;code&gt;main&lt;/code&gt;函数最后需要加上：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;printSummary(hit_count, miss_count, eviction_count);&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.建议把&lt;code&gt;-v&lt;/code&gt;这个选项也实现了，这样自己debug的时候也方便一些。另外，可以先从规模小的测试数据开始，然后用大的。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;思路要点及其实现&quot;&gt;&lt;span&gt;&lt;strong&gt;思路要点及其实现：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.这次实验只要求我们测试hit/miss/eviction的次数，&lt;strong&gt;并没有实际的数据存储&lt;/strong&gt; ，&lt;strong&gt;所以我们不用实现line中的block部分。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.这次实验要求使用LRU（least recently used），即没有空模块（valid为0）时替换最早使用的那一个line。所以&lt;strong&gt;我们应该在line中实现一个能够记录当前line最后一次写入的时间参量，每次”写入“line的时候就更新一下该参量。&lt;/strong&gt;（这一点csapp上没有详细说）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.综上，结合书上对cache的描述，我们可以得到如下数据结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212071938665-1796968879.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意到cache（sets的入口）和set（lines的入口）都是用指针实现的，sets构成一个指针数组，因为它们不含任何数据，&lt;strong&gt;唯一的用处就是通过偏移量寻找到指定的line&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面结合代码执行的顺序对我实现的程序进行解释，由于写了很多注释，就不详细的说了（我的sublime写不了中文，就用的英文注释的，语法有错还请指出）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新：一航介绍了一个插件，可以解决Ubuntu下sublime中文输入的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--&amp;gt; &lt;a href=&quot;https://github.com/lyfeyaj/sublime-text-imfix&quot;&gt;sublime-text-imfix&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;头文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &quot;cachelab.h&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;  &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* fopen freopen perror */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdint.h&amp;gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* uintN_t */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;unistd.h&amp;gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* getopt */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;getopt.h&amp;gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* getopt -std=c99 POSIX macros defined in &amp;lt;features.h&amp;gt; prevents &amp;lt;unistd.h&amp;gt; from including &amp;lt;getopt.h&amp;gt;*/&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdlib.h&amp;gt; &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* atol exit*/&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;errno.h&amp;gt;  &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;/* errno */&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为什么要包含该头文件的原因在右侧注释中写出来了。由于我们实验使用的64位地址，所以将tag和set的索引用64位保存就足够了，我这里使用了C99中的固定长度类型uintN_t，可移植性好一些。另外要注意的是，C99必须包含unistd.h和getopt.h两个头文件才能正常使用&lt;code&gt;getopt&lt;/code&gt; 。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;宏定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define false 0&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define true 1&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我喜欢用_Bool+宏定义true和false，你也可以使用stdbool.h。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;数据结构类型定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;
{
    &lt;span class=&quot;dt&quot;&gt;_Bool&lt;/span&gt; valid;    &lt;span class=&quot;co&quot;&gt;/* flag whether this line/block is valid, zero at first*/&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; tag;   &lt;span class=&quot;co&quot;&gt;/* identifier to choose line/block */&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; time_counter;  &lt;span class=&quot;co&quot;&gt;/* LRU strategy counter, we should evict the block who has the min time_counter, zero at first */&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;/* We don't need to simulate the block, since we just requested to count hit/miss/eviction */&lt;/span&gt;
}line;
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; line *entry_of_lines;
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; entry_of_lines *entry_of_sets;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;time_counter初始化的时候都是0，&lt;strong&gt;其值越大代表这个line最近刚刚被写入——我们不应该替换它——所以valid为0的line的time_counter一定也是0（最小值）&lt;/strong&gt;，因为他们连使用都没有被使用过，即我们一定会先替换valid为0的line，这符合书上的策略。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt;
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hit;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; miss;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; eviction;
}result;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我将结果设计成了一个结构体，这样函数方便返回一些。（少用全局变量）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;main函数的数据类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;result Result = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *help_message = &lt;span class=&quot;st&quot;&gt;&quot;Usage: &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Your complied program&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; [-hv] -s &amp;lt;s&amp;gt; -E &amp;lt;E&amp;gt; -b &amp;lt;b&amp;gt; -t &amp;lt;tracefile&amp;gt;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; \
                     &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;s&amp;gt; &amp;lt;E&amp;gt; &amp;lt;b&amp;gt; should all above zero and below 64.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; \
                     &lt;span class=&quot;st&quot;&gt;&quot;Complied with std=c99&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *command_options = &lt;span class=&quot;st&quot;&gt;&quot;hvs:E:b:t:&quot;&lt;/span&gt;;
FILE* tracefile = NULL;
entry_of_sets cache = NULL;
&lt;span class=&quot;dt&quot;&gt;_Bool&lt;/span&gt; verbose = false;  &lt;span class=&quot;co&quot;&gt;/* flag whether switch to verbose mode, zero for default */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; s = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/* number of sets ndex's bits */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; b = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/* number of blocks index's bits */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; S = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/* number of sets */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; E = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/* number of lines */&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注释已经写的很清楚了，我解释一下help_message的写法，有的同学可能不知道C中字符串的写法：两个字符串中间只有空格，C编译器会自动将它们合并。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* test_string = &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;   &lt;span class=&quot;st&quot;&gt;&quot; world&quot;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么test_string就会是“hello world”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，在C中，一行写不下的时候可以使用\字符隔开，编译器会自动合并的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;main函数读取参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; ch;    &lt;span class=&quot;co&quot;&gt;/* command options */&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((ch = getopt(argc, argv, command_options)) != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    {
        &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt;(ch)
        {
            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; 'h':
            {
                printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, help_message);
                exit(EXIT_SUCCESS);
            }

            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; 'v':
            {
                verbose = true;
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }

            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; 's':
            {

                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (atol(optarg) &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;/* We assume that there are at least two sets */&lt;/span&gt;
                {
                    printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, help_message);
                    exit(EXIT_FAILURE);
                }
                s = atol(optarg);
                S = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; s;
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }

            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; 'E':
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (atol(optarg) &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                {
                    printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, help_message);
                    exit(EXIT_FAILURE);
                }
                E = atol(optarg);
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }

            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; 'b':
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (atol(optarg) &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;/* We assume that there are at least two sets */&lt;/span&gt;
                {
                    printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, help_message);
                    exit(EXIT_FAILURE);
                }
                b = atol(optarg);
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }

            &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; 't':
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tracefile = fopen(optarg, &lt;span class=&quot;st&quot;&gt;&quot;r&quot;&lt;/span&gt;)) == NULL)
                {
                    perror(&lt;span class=&quot;st&quot;&gt;&quot;Failed to open tracefile&quot;&lt;/span&gt;);
                    exit(EXIT_FAILURE);
                }
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }

            &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
            {
                printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, help_message);
                exit(EXIT_FAILURE);
            }
        }
    }&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于&lt;code&gt;getopt&lt;/code&gt;的用法可以参考文章开头的文章；&lt;code&gt;perror&lt;/code&gt;和&lt;code&gt;fopen&lt;/code&gt;的用法请&lt;code&gt;man&lt;/code&gt;一下，fopen失败后会设置errno的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || b ==&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || E == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || tracefile == NULL)
    {
        printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, help_message);
        exit(EXIT_FAILURE);
    }&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果读取的参数中没有s或者b或者E或者文件，那么那他们将会是对应的初始值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;main函数调用函数并结束程序：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;    cache = InitializeCache(S, E);
    Result = ReadAndTest(tracefile, cache, S, E, s, b, verbose);
    RealseMemory(cache, S, E);   &lt;span class=&quot;co&quot;&gt;/* Don't forget this in C/C++, and do not double release which causes security problem */&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//printf(&quot;hits:%d misses:%d evictions:%d\n&quot;, Result.hit, Result.miss, Result.eviction);&lt;/span&gt;
    printSummary(Result.hit, Result.miss, Result.eviction);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;InitializeCache&lt;/code&gt;是用来动态申请数据结构的，&lt;code&gt;ReadAndTest&lt;/code&gt;是本程序的核心，用来测试hit/miss/eviction的次数。另外不要忘记或者重复释放内存。下面分别介绍这三个函数。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;entry_of_sets InitializeCache(&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; S, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; E)
{
    entry_of_sets cache;

    &lt;span class=&quot;co&quot;&gt;/* use calloc instead of malloc to match the default situation we designed */&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((cache = calloc(S, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(entry_of_lines))) == NULL) &lt;span class=&quot;co&quot;&gt;/* initialize the sets */&lt;/span&gt;
    {
        perror(&lt;span class=&quot;st&quot;&gt;&quot;Failed to calloc entry_of_sets&quot;&lt;/span&gt;);
        exit(EXIT_FAILURE);
    }

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; S; ++i)  &lt;span class=&quot;co&quot;&gt;/* initialize the lines in set */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((cache[i] = calloc(E, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(line))) == NULL)
        {
            perror(&lt;span class=&quot;st&quot;&gt;&quot;Failed to calloc line in sets&quot;&lt;/span&gt;);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; cache;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们首先根据S（set的数目）申请一个数组，该数组元素是lines的入口的指针。接着循环S次每次申请E个line数据结构，并让刚刚的指针数组的元素指向它们：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;                                                             +-----+
                                                +-----+   +--&amp;gt;Valid|
                                           +----&amp;gt;line0+---+  +-----+
                                           |    +-----+   |
                         +---------------+ |              |  +---+
                         | set0          | |    +-----+   +--&amp;gt;Tag|
                      +--&amp;gt; entry_of_lines+------&amp;gt;line1|   |  +---+
                      |  +---------------+ |    +-----+   |
                      |                    |              |  +-------+
                      |  +---------------+ |    +-----+   +--&amp;gt;Counter|
                      |  | set1          | +----&amp;gt;line2|      +-------+
                      +--&amp;gt; entry_of_lines| |    +-----+
+--------------+      |  +---------------+ |
| cache0       +------+                    |    +-----+
| entry_of_sets|      |  +---------------+ +----&amp;gt;lineX|
+--------------+      |  | set2          |      +-----+
                      +--&amp;gt; entry_of_lines|
                      |  +---------------+
                      |
                      |  +---------------+
                      |  | setX          |
                      +--&amp;gt; entry_of_lines|
                         +---------------+&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;释放之前申请的内存：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; RealseMemory(entry_of_sets cache, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; S, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; E)
{
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; S; ++i)
    {
        free(cache[i]);
    }
    free(cache);
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不解释。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;核心部分，测试hit/miss/eviction的次数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;result ReadAndTest(FILE *tracefile, entry_of_sets cache, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; S, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; E, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; s, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; b, &lt;span class=&quot;dt&quot;&gt;_Bool&lt;/span&gt; verbose)
{
    result Result = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; ch;
    &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; address;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;((fscanf(tracefile, &lt;span class=&quot;st&quot;&gt;&quot; %c %lx%*[^&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]&quot;&lt;/span&gt;, &amp;amp;ch, &amp;amp;address)) == &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)    &lt;span class=&quot;co&quot;&gt;/* read instruction and address from tracefile and ignore the size */&lt;/span&gt;
                                                                        &lt;span class=&quot;co&quot;&gt;/* address is represented by hexadecimal, use %lx instead of %lu */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ch == 'I')
        {
            &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;/* we don't care about 'I' */&lt;/span&gt;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        {
            &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; set_index_mask = (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; s) - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
            &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; set_index = (address &amp;gt;&amp;gt; b) &amp;amp; set_index_mask;
            &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; tag = (address &amp;gt;&amp;gt; b) &amp;gt;&amp;gt; s;
            entry_of_lines search_line = cache[set_index];


            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ch == 'L' || ch == 'S') &lt;span class=&quot;co&quot;&gt;/* load/store can cause at most one cache miss */&lt;/span&gt;
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (verbose)    printf(&lt;span class=&quot;st&quot;&gt;&quot;%c %lx &quot;&lt;/span&gt;, ch, address);
                Result = HitMissEviction(search_line, Result, E, tag, verbose);
            }

            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ch == 'M') &lt;span class=&quot;co&quot;&gt;/* data modify (M) is treated as a load followed by a store to the same address.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;                                   Hence, an M operation can result in two cache hits, or a miss and a hit plus an possible eviction. */&lt;/span&gt;
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (verbose)    printf(&lt;span class=&quot;st&quot;&gt;&quot;%c %lx &quot;&lt;/span&gt;, ch, address);
                Result = HitMissEviction(search_line, Result, E, tag, verbose);  &lt;span class=&quot;co&quot;&gt;/* load, hit/miss(+eviction) */&lt;/span&gt;
                Result = HitMissEviction(search_line, Result, E, tag, verbose);  &lt;span class=&quot;co&quot;&gt;/* store, must hit */&lt;/span&gt;
            }

            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;/* ignore other cases */&lt;/span&gt;
            {
                &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Result;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果命令是“L”或者“M”，我们就进入&lt;code&gt;HitMissEviction&lt;/code&gt;一次判断其是否hit或者miss以及是否发生替换，&lt;strong&gt;如果是M就相当于一次“L”和一次“M”，&lt;/strong&gt;需要进入&lt;code&gt;HitMissEviction&lt;/code&gt;两次，其结果可能为两次hit，也可能为一次miss+(eviction）一次hit。我们在&lt;code&gt;ReadAndTest&lt;/code&gt;里通过一些位运算找到对应的set（即entry_of_lines），然后以此作为参数调用&lt;code&gt;HitMissEviction&lt;/code&gt; 判断到底是miss（有没有eviction）还是hit。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;result HitMissEviction(entry_of_lines search_line, result Result, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; E, &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; tag, &lt;span class=&quot;dt&quot;&gt;_Bool&lt;/span&gt; verbose)
{
    &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; oldest_time = UINT64_MAX;
    &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; youngest_time = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; oldest_block = UINT64_MAX;
    &lt;span class=&quot;dt&quot;&gt;_Bool&lt;/span&gt; hit_flag = false;

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; E; ++ i)
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (search_line[i].tag == tag &amp;amp;&amp;amp; search_line[i].valid) &lt;span class=&quot;co&quot;&gt;/* hit */&lt;/span&gt;
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (verbose)    printf(&lt;span class=&quot;st&quot;&gt;&quot;hit&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            hit_flag = true;
            ++Result.hit;
            ++search_line[i].time_counter; &lt;span class=&quot;co&quot;&gt;/* update the time counter */&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
        }
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!hit_flag)  &lt;span class=&quot;co&quot;&gt;/* miss */&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (verbose)    printf(&lt;span class=&quot;st&quot;&gt;&quot;miss&quot;&lt;/span&gt;);
        ++Result.miss;
        &lt;span class=&quot;dt&quot;&gt;uint64_t&lt;/span&gt; i;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; E; ++i)    &lt;span class=&quot;co&quot;&gt;/* search for the oldest modified block (invalid blocks are oldest as we designed) */&lt;/span&gt;
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (search_line[i].time_counter &amp;lt; oldest_time)
            {
                oldest_time = search_line[i].time_counter;
                oldest_block = i;
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (search_line[i].time_counter &amp;gt; youngest_time)    &lt;span class=&quot;co&quot;&gt;/* search for the youngest modified block to update the new block's time counter */&lt;/span&gt;
            {
                youngest_time = search_line[i].time_counter;
            }
        }

        search_line[oldest_block].time_counter = youngest_time + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        search_line[oldest_block].tag = tag;

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (search_line[oldest_block].valid) &lt;span class=&quot;co&quot;&gt;/* It's a valid block, ++eviction */&lt;/span&gt;
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (verbose)    printf(&lt;span class=&quot;st&quot;&gt;&quot; and eviction&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            ++Result.eviction;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
        {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (verbose)    printf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
            search_line[oldest_block].valid = true;
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Result;
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;HitMissEviction&lt;/code&gt;里面需要注意的地方是时间参量的更新，&lt;strong&gt;我们既要找到最“老”的line，也要同时记住最“新”的line的时间参量&lt;/strong&gt;（我这里是遍历搜索，也可以在设计set的数据类型时设计为结构体，其中放一个最新的时间参量），以此来更新时间参量。如果我们要替换的line的valid为1，则发生了一次eviction。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;完整代码：&lt;a href=&quot;https://paste.ubuntu.com/26163546/&quot; class=&quot;uri&quot;&gt;https://paste.ubuntu.com/26163546/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072037180-2020080021.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;part-b-优化矩阵转置&quot;&gt;&lt;span&gt;Part B: 优化矩阵转置&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;前期准备-1&quot;&gt;&lt;span&gt;&lt;strong&gt;前期准备：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;最简单的转置实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)
{
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; ++j)
    {
        dst[j][i] = src[i][j]
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;注意事项-1&quot;&gt;&lt;span&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.最多只能定义12个局部变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.不允许使用位运算，不允许使用数组或者malloc。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.不能改变原数组A，&lt;strong&gt;但是可以修改转置数组B&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;思路要点及其实现-1&quot;&gt;&lt;span&gt;&lt;strong&gt;思路要点及其实现：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.block的大小为32byte，即可以放下8个int，即&lt;strong&gt;miss的最低限度是1/8&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.cache的大小为32*32，即32个block，128个int。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;strong&gt;blocking是一种很好的优化技术，这次实验基本就靠他了；）&lt;/strong&gt;其大致概念为以数据块的形式读取数据，完全利用后丢弃，然后读取下一个，这样防止block利用的不全面。可以参考卡耐基梅隆的一篇文章：&lt;a href=&quot;http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf&quot;&gt;waside-blocking&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.&lt;strong&gt;尽量将一个block读入完全或者写入完全&lt;/strong&gt;，例如假设一个block可以放两个数，进行如下转置操作，其读取时“尽力”读取，完全利用了一个block，但是在写入的时候浪费了1/2的空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://www.cnblogs.com/home/frank/Pictures/Selection_105.png&quot; alt=&quot;Selection_105&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;strong&gt;尽量使用刚刚使用的block&lt;/strong&gt;（还是“热乎的”），因为它们很可能还没有被替换，hit的概率会很大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.读出和写入的时候&lt;strong&gt;注意判断这两个位置映射在cache中的位置是否相同&lt;/strong&gt;，（我们这个cache是直接映射，一个set只有一个block，所以绝大部分的miss伴随着替换），也可以说，我们要尽量避免替换的发生。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面我结合实验要求的三个例子具体讲。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;32 × 32 (M = 32, N = 32)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于我们的block能存8个int，所以blocking的数据块最好是以它为单位的，这样能尽可能利用block，例如8 * 8或者16 * 16。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在32*32的情况中，一行是32个int，也就是4个block，所以cache可以存8行，由此可以推出映射冲突的情况：&lt;strong&gt;只要两个int之间相差8行的整数倍，那么读取这两个元素所在的block就会发生替换&lt;/strong&gt;，再读后面连续的元素也会不断发生替换（thrashing，csapp中文版上面翻译的是“抖动”，感觉一点也不形象。。。）下图中标出了与一个元素冲突的位置（&lt;strong&gt;包括他自己本身的位置，因为我们A，B两个数组在内存中是相邻的，而32*32又是cache的整数倍。&lt;/strong&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072107118-1650199352.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是转置的过程中这样的情况会发生吗？&lt;strong&gt;图中的BCD三点对于A来说仅仅是行差了8K，这在转置中是不可能发生的！&lt;/strong&gt;因为转置是将A[i][j]送到B[j][i]，不会有B[i][j+8k]的情况出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是对于A点而言，如果A[i][j]中i = j，那么B也会是B[i][j]，即映射遇到同一个block中，&lt;strong&gt;而当i = j的时候，就是对角线的情况：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072115759-884605207.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以现在我们只要单独处理对角线的情况就可以啦，这里有两种处理方法：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;由于我们可以使用12个局部变量，所以我们可以用8个局部变量一次性将包含对角线int的block全部读出，这样即使写入的时候替换了之前的block也不要紧，因为我们已经全部读出了。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我们用一个局部变量暂时先保存这个对角线元素，并用另一个变量记录它的位置，待block的其他7个元素写完以后，我们再将这个会引起替换的元素写到目的地。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面的代码使用第一种方法，另外，&lt;strong&gt;由于相差8行就会有冲突，所以我们blocking的时候用8*8的数据块。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i += &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
{
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j += &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
    {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = i; k &amp;lt; i + &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;; ++k)
        {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value0 = A[k][j];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value1 = A[k][j&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value2 = A[k][j&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value3 = A[k][j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value4 = A[k][j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value5 = A[k][j&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value6 = A[k][j&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value7 = A[k][j&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;];
          
            B[j][k] = temp_value0;
            B[j&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;][k] = temp_value1;
            B[j&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;][k] = temp_value2;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;][k] = temp_value3;
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;][k] = temp_value4;
            B[j&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;][k] = temp_value5;
            B[j&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;][k] = temp_value6;
            B[j&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;][k] = temp_value7;
        }
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072126259-1753004177.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;64 × 64 (M = 64, N = 64)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，数组一行有64个int，即8个block，&lt;strong&gt;所以每四行就会填满一个cache，即两个元素相差四行就会发生冲突。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们使用4*4的blocking，这样固然可以成功，但是每次都会有1/2的损失，优化不够。如果使用刚刚的8*8的blocking，那么在写入的时候就会发生冲突：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072209446-1049088229.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候可以使用一下“divide and conquer”的思想，我们先将8*8的块分成四部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072215384-1287765770.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本来我们是要将右上角的2移动到左下角的3的（转置），但是为了防止冲突我们先把他们移动到2的位置，以后再来处理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072221321-1977425340.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于3和4，我们采取一样的策略，就可以得到如下结果，&lt;strong&gt;在这个过程中没有抖动的发生&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072229321-548421086.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候再将23互换就可以啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，测试以后并不能满足优化的要求，说明我们将23转换的时候（或是之后）又发生很多miss，所以我们应该在将右上角的34转换的过程中将2的位置复原，&lt;strong&gt;这里的复原是整个实验中最具技巧性的&lt;/strong&gt;，由前面的要点5：&lt;strong&gt;尽量使用刚刚使用的block&lt;/strong&gt;（还是“热乎的”），因为它们很可能还没有被替换，hit的概率会很大。我们在转换2的时候逆序转换：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072237321-829205344.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同时在读取右上角34的时候按列来读，这样的好处就是把2换到3的过程中是从下到上按行换的，因为这样可以先使用“最热乎”的block：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072243446-705145577.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着转换：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072248305-1715944235.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072254212-1469791451.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i += &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
{
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j += &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
    {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = i; k &amp;lt; i + &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;; ++k)
        {
        &lt;span class=&quot;co&quot;&gt;/* 读取1 2，暂时放在左下角1 2 */&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value0 = A[k][j];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value1 = A[k][j&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value2 = A[k][j&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value3 = A[k][j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value4 = A[k][j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value5 = A[k][j&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value6 = A[k][j&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value7 = A[k][j&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;];
          
            B[j][k] = temp_value0;
            B[j&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;][k] = temp_value1;
            B[j&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;][k] = temp_value2;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;][k] = temp_value3;
          &lt;span class=&quot;co&quot;&gt;/* 逆序放置 */&lt;/span&gt;
            B[j][k&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;] = temp_value7;
            B[j&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;][k&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;] = temp_value6;
            B[j&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;][k&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;] = temp_value5;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;][k&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;] = temp_value4;
        }
         &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; l = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; l &amp;lt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;; ++l)
        {
           &lt;span class=&quot;co&quot;&gt;/* 按列读取 */&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value0 = A[i&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value1 = A[i&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value2 = A[i&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value3 = A[i&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value4 = A[i&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value5 = A[i&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value6 = A[i&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l];
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value7 = A[i&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;][j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l];
           
           &lt;span class=&quot;co&quot;&gt;/* 从下向上按行转换2到3 */&lt;/span&gt;
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i] = B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;];
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;] = B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;];
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+2&lt;/span&gt;] = B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;];
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;] = B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;];
           &lt;span class=&quot;co&quot;&gt;/* 将3 4放到正确的位置 */&lt;/span&gt;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;] = temp_value0;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;] = temp_value1;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;] = temp_value2;
            B[j&lt;span class=&quot;dv&quot;&gt;+3&lt;/span&gt;-l][i&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;] = temp_value3;
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;] = temp_value4;
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+5&lt;/span&gt;] = temp_value5;
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+6&lt;/span&gt;] = temp_value6;
            B[j&lt;span class=&quot;dv&quot;&gt;+4&lt;/span&gt;+l][i&lt;span class=&quot;dv&quot;&gt;+7&lt;/span&gt;] = temp_value7;
        } 
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;frank@under: ~-tmp-csim_109&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;61 × 67 (M = 61, N = 67)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个题只要求miss &amp;lt; 2000，比较宽松。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候由于不对称，所以也不存在相差4行就必定冲突的情况，我们可以试一下16 * 16这种blocking。但是“对角线”的元素（横坐标等于纵坐标）肯定还是会冲突的（其实这个时候不是对角线了，因为不是正方形）。我们在这里用32*32分析中的第二种方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;span&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i += &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
{
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j += &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)
    {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = i; k &amp;lt; i + &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; &amp;amp;&amp;amp; k &amp;lt; N; ++k)
        {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_position = -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp_value = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; l;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (l = j; l &amp;lt; j + &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; &amp;amp;&amp;amp; l &amp;lt; M; ++l)
            {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (l == k) &lt;span class=&quot;co&quot;&gt;/* 横坐标等于纵坐标，局部变量暂存，整个block读完再处理 */&lt;/span&gt;
                {
                    temp_position = k;
                    temp_value = A[k][k];
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                {
                    B[l][k] = A[k][l];
                }
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (temp_position != -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;/* 遇到了冲突元素 */&lt;/span&gt; 
            {
                B[temp_position][temp_position] = temp_value;
            }
        }
    }
}&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;完整代码：&lt;a href=&quot;https://paste.ubuntu.com/26163546/&quot; class=&quot;uri&quot;&gt;https://paste.ubuntu.com/26163546/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072311446-698358318.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;最终结果为满分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201712/1072319-20171212072320915-1583587530.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Dec 2017 23:28:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/8026100.html</dc:identifier>
</item>
<item>
<title>深入理解javascript函数进阶系列第一篇——高阶函数 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8026038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8026038.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　前面的&lt;a href=&quot;http://www.cnblogs.com/xiaohuochai/p/5702813.html&quot; target=&quot;_blank&quot;&gt;函数系列&lt;/a&gt;中介绍了函数的基础用法。从本文开始，将介绍javascript函数进阶系列，本文将详细介绍高阶函数&lt;/p&gt;

&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;　　高阶函数(higher-order function)指操作函数的函数，一般地，有以下两种情况&lt;/p&gt;
&lt;p&gt;　　1、函数可以作为参数被传递&lt;/p&gt;
&lt;p&gt;　　2、函数可以作为返回值输出&lt;/p&gt;
&lt;p&gt;　　javascript中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景。下面将对这两种情况进行详细介绍&lt;/p&gt;

&lt;h3&gt;参数传递&lt;/h3&gt;
&lt;p&gt;　　把函数当作参数传递，代表可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个常见的应用场景就是回调函数&lt;/p&gt;
&lt;p&gt;【回调函数】&lt;/p&gt;
&lt;p&gt;　　在ajax异步请求的应用中，回调函数的使用非常频繁。想在ajax请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把callback函数当作参数传入发起ajax请求的方法中，待请求完成之后执行callback函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getUserInfo =&lt;span&gt; function( userId, callback ){
  $.ajax( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://xx.com/getUserInfo?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; userId, function( data ){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;typeof&lt;/span&gt; callback === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){
      callback( data );
    }
  });
}
getUserInfo( &lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;, function( data ){ 
  alert ( data.userName );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行&lt;/p&gt;
&lt;p&gt;　　比如，想在页面中创建100个div节点，然后把这些div节点都设置为隐藏。下面是一种编写代码的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; appendDiv =&lt;span&gt; function(){
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt; ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    div.innerHTML &lt;/span&gt;=&lt;span&gt; i;
    document.body.appendChild( div );
    div.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  }
};
appendDiv();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把div.style.display = 'none'的逻辑硬编码在appendDiv里显然是不合理的，appendDiv未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏&lt;/p&gt;
&lt;p&gt;　　于是把div.style.display = 'none'这行代码抽出来，用回调函数的形式传入appendDiv方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; appendDiv =&lt;span&gt; function( callback ){
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt; ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.createElement( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ); 
    div.innerHTML &lt;/span&gt;=&lt;span&gt; i;
    document.body.appendChild( div );
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( &lt;span&gt;typeof&lt;/span&gt; callback === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){
      callback( div );
    }
  }
};
appendDiv(function( node ){ 
  node.style.display &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，“委托”给appendDiv方法。appendDiv方法当然知道节点什么时候创建好，所以在节点创建好的时候，appendDiv会执行之前客户传入的回调函数&lt;/p&gt;
&lt;p&gt;【数组排序】&lt;/p&gt;
&lt;p&gt;　　函数作为参数传递的另一个常见场景是数组排序函数sort()。Array.prototype.sort接受一个函数当作参数，这个函数里面封装了数组元素的排序方法。目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入Array.prototype.sort，使Array.prototype.sort方法成为了一个非常灵活的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从小到大排列，输出: [ 1, 3, 4 ]&lt;/span&gt;
[ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ].sort( function( a, b ){ 
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a -&lt;span&gt; b;
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从大到小排列，输出: [ 4, 3, 1 ]&lt;/span&gt;
[ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ].sort( function( a, b ){ 
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; b -&lt;span&gt; a;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;返回值输出&lt;/h3&gt;
&lt;p&gt;　　相比把函数当作参数传递，函数当作返回值输出的应用场景也有很多。让函数继续返回一个可执行的函数，意味着运算过程是可延续的&lt;/p&gt;
&lt;p&gt;　　下面是使用Object,prototype.toString方法判断数据类型的一系列的isType函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; isString =&lt;span&gt; function( obj ){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.prototype.toString.call( obj ) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[object String]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isArray =&lt;span&gt; function( obj ){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.prototype.toString.call( obj ) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[object Array]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isNumber =&lt;span&gt; function( obj ){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.prototype.toString.call( obj ) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[object Number]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实际上，这些函数的大部分实现都是相同的，不同的只是Object.prototype.toString.call(obj)返回的字符串。为了避免多余的代码，可以把这些字符串作为参数提前传入isType函数。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; isType =&lt;span&gt; function( type ){ 
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function( obj ){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.prototype.toString.call( obj ) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[object &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+ type +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isString = isType( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ); 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isArray = isType( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Array&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ); 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isNumber = isType( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );

console.log( isArray( [ &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ] ) );    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然，还可以用循环语句，来批量注册这些 isType 函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Type =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, type; type = [ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Array&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ][ i++&lt;span&gt; ]; ){ 
  (function( type ){
    Type[ &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + type ] =&lt;span&gt; function( obj ){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.prototype.toString.call( obj ) === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[object &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+ type +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    }
  })( type )
};
Type.isArray( [] );    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：true &lt;/span&gt;
Type.isString( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;AOP&lt;/h3&gt;
&lt;p&gt;　　AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块&lt;/p&gt;
&lt;p&gt;　　通常，在javascript中实现AOP，都是指把一个函数“动态织入”到另外一个函数之中。下面通过扩展Function.prototype来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  Function.prototype.before =&lt;span&gt; function (beforefn) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存原函数的引用&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; function () {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回包含了原函数和新函数的&quot;代理&quot;函数 &lt;/span&gt;
      beforefn.apply(&lt;span&gt;this&lt;/span&gt;, arguments);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先执行新函数，修正this &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; _this.apply(&lt;span&gt;this&lt;/span&gt;, arguments);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再执行原函数&lt;/span&gt;
&lt;span&gt;    }
  };
  Function.prototype.after &lt;/span&gt;=&lt;span&gt; function (afterfn) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = _this.apply(&lt;span&gt;this&lt;/span&gt;, arguments); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先执行原函数&lt;/span&gt;
      afterfn.apply(&lt;span&gt;this&lt;/span&gt;, arguments); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再执行新函数&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }
  };

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; func =&lt;span&gt; function () {
    console.log(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
  };

  func &lt;/span&gt;=&lt;span&gt; func.before(function () {
    console.log(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  }).after(function () {
    console.log(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
  });

  func();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把负责打印数字1和打印数字3的两个函数通过AOP的方式动态植入func函数。通过执行上面的代码，控制台顺利地返回了执行结果1、2、3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;其他应用&lt;/h3&gt;
&lt;p&gt;【not】&lt;/p&gt;
&lt;p&gt;　　下面的not函数用于返回参数的返回值的逻辑非&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  function not(f) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !(f.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments));
    };
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;偶数时，返回true；奇数时，返回false&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; even =&lt;span&gt; function (x) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;偶数时，返回false；奇数时，返回true&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; odd =&lt;span&gt; not(even);
  [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;].every(odd);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【mapper】&lt;/p&gt;
&lt;p&gt;　　下面的mapper()函数，返回的新函数将一个数组映射到另一个使用这个函数的数组上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所返回的函数的参数应当是一个实参数组，并对每个数组元素执行函数f()，并返回所有计算结果组成的数组&lt;/span&gt;
&lt;span&gt;function mapper(f){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(a){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Array.prototype.map.call(a,f);
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; increment =&lt;span&gt; function(x){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; incrementer =&lt;span&gt; mapper(increment);
increment([&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[2,3,4]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【squareofsum】&lt;/p&gt;
&lt;p&gt;　　下面的函数接收两个函数f()和g()，并返回一个新函数用以计算f(g())&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个新的可以计算f(g(...))的函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的函数h()将它所有的实参传入g()，然后将g()的返回值传入f()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用f()和g()时的this值和调用h()时的this值是同一个this&lt;/span&gt;
&lt;span&gt;function compose(f,g){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要给f()传入一个参数，所以使用f()的call()方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要给g()传入很多参数，所以使用g()的apply()方法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; f.call(&lt;span&gt;this&lt;/span&gt;,g.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,arguments));
    };
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; square =&lt;span&gt; function(x){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x*&lt;span&gt;x;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sum =&lt;span&gt; function(x,y){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; squareofsum =&lt;span&gt; compose(square,sum);
squareofsum(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码中，首先执行compose(square,sum)。square传给f，sum传给g。然后执行f(g())。g作为f函数的参数，首先执行。即先执行sum(2,3)，结果为5。再执行square(5)，最终结果为25&lt;/p&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;　　本文介绍了高阶函数的基础使用，主要包括参数传递和返回值输出两种形式。其中，高阶函数的一个重要应用是函数柯里化(currying)，将在下篇博文中详细介绍&lt;/p&gt;

</description>
<pubDate>Mon, 11 Dec 2017 22:12:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8026038.html</dc:identifier>
</item>
<item>
<title>node.js入门（express和superagent的使用）爬博客园和知乎数据，并实时显示到前端 - 辉子t1</title>
<link>http://www.cnblogs.com/huizit1/p/8025816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huizit1/p/8025816.html</guid>
<description>&lt;p&gt;先来看一下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/692074/201712/692074-20171211223517524-970126605.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/692074/201712/692074-20171211223525743-1737921181.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/692074/201712/692074-20171212010941462-143714788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用到的东西：前端（H5盒子模型+vue+jquery）后端node.js（express+superagent），这里没有用到数据库和其他存储数据的文件。前端发送ajax请求，后端用express接收请求，然后通过superagent去请求博客园或者知乎的网站，拿到数据之后看情况对数据进行处理，然后再将数据返回给前端。&lt;/p&gt;
&lt;p&gt;之前做过快半年的前端实习，主要是做H5方面的。毕业之后在新的公司里面主要是写java的爬虫，用的是htmlunit。这个东西相当于是用代码模拟浏览器来访问网站，可以模拟点击按钮的操作，用起来还是非常方便的。后来就想学一下node.js，看看用它是怎么来写后端，怎么写爬虫的。&lt;/p&gt;
&lt;p&gt;首先是下载并安装node.js，新建一个文件夹作为一个新项目，进入这个文件夹，按住Shift键然后点击鼠标右键，点击“在此处打开命令窗口”。这样省去了切换目录的麻烦。然后在命令窗口里面输入npm init，回车，看情况填写信息，也可以一路回车默认。然后安装这里用到的几个模块：express、superagent、querystring、cheerio、eventproxy，比如在命令窗口输入npm install express --save，然后回车就可以在当前项目内安装express模块。安装完这几个模块之后，在当前目录下新建一个js文件：server.js，里面存放后台的代码，然后在当前目录下新建一个文件夹webapp，里面存放前端的东西：html、css、js、图片、还有其他用到的vue、jquery。&lt;/p&gt;
&lt;p&gt;express的作用是可以创建一个后台的服务器，接收来自前端的请求，并且发送数据给前端。&lt;/p&gt;
&lt;p&gt;用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();
app.use(express.static(&lt;/span&gt;'webapp'&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = app.listen(8081, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; server.address().address
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port =&lt;span&gt; server.address().port

  console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port)

})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;app.use(express.static('webapp'&lt;span&gt;));加上这句代码，浏览器里面就可以访问webapp这个文件夹里面的内容了。在命令窗口里面输入node server.js然后回车，在浏览器里面输入http://localhost:8081/webapp里面的内容就可以访问了。&lt;br/&gt;接下来看一下前后端通信的代码是怎样的：&lt;br/&gt;前端的请求如下所示：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
    url: &lt;/span&gt;'http://你的ip地址:8081/getData'&lt;span&gt;,
    type: &lt;/span&gt;'POST'&lt;span&gt;,
    data: {
        num: $&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.num,
    },
    success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; data.ret;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; tempData.length; i++&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempItem =&lt;span&gt; {
                img: tempData[i].itemCover,
                hasImg: tempData[i].itemCover&lt;/span&gt;==undefined?&lt;span&gt;false&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                text: tempData[i].itemText,
                num: &lt;/span&gt;&quot;139&quot;&lt;span&gt;,
                title: tempData[i].itemTitle,
                url: tempData[i].itemLink
            }
            $&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items.push(tempItem);
        }
        $&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.num++&lt;span&gt;;
        $&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.working = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        $&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loading = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; localStorage.items=JSON.stringify($this.items);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; localStorage.num=$this.num;&lt;/span&gt;
&lt;span&gt;    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;server.js里面对应接收这个请求的方法如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
app.post('/getData', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    req.on(&lt;/span&gt;'data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentData = &quot;&quot;+&lt;span&gt;data;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; qs.parse(currentData);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index =&lt;span&gt; tempData.num;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; {
            value: &lt;/span&gt;&quot;s&quot;&lt;span&gt;
        };
        postData.push(tempData);
        res.header(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);
        res.json({
            success: &lt;/span&gt;1&lt;span&gt;,
            ret: postData
        })
    });
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用req.on('data',function(data){...})就可以接收到前端post过来的数据，然后用querystring的parse方法可以将数据解析成json格式，这样就能读取相应的数据。然后用res.json({...})就可以将数据返回给前端。res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)这句代码可以解决跨域的问题，比如说如果没有这句代码的话，在浏览器里面用localhost访问页面，前端的ajax请求是不会成功的，因为他会提示跨域的错误，加上这句代码之后就可以访问成功。&lt;/p&gt;
&lt;p&gt;接下来看一下怎样用superagent来爬数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
superagent.get(&quot;https://www.cnblogs.com/&quot;).end(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,pre){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $ =&lt;span&gt; cheerio.load(pre.text);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; $(&quot;.post_item_body&quot;).length; i++&lt;span&gt; ){
     　　...&lt;/span&gt;&lt;span&gt;
    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用superagent来请求博客园首页的网址，然后pre.text就是博客园首页的html内容了，但是由于它是字符串，所以这里需要用到cheerio.load方法。然后这个$就和jquery里面的$一样了，可以直接用jquery里面的方法来获取页面的元素。在这里呢，推荐看https://www.cnblogs.com/coco1s/p/4954063.html这篇博客，这里面详细的描述了怎样用superagent来爬取博客园的数据。&lt;/p&gt;
&lt;p&gt;爬取博客园的数据是成功了，但是我还想试一下其他的网站，平时看知乎比较多，就爬知乎吧。但是我发现用之前爬取博客园的方法去爬知乎的话，返回的是一个登陆的页面。所以这里就需要把cookie添加进去了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
superagent.get(&quot;https://www.zhihu.com/&quot;&lt;span&gt;)
.set(&lt;/span&gt;'Cookie': '...'&lt;span&gt;)
.end(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,obj){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err){&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; {
        value: obj.text,
    };
    res.header(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);
    res.json({
        success: &lt;/span&gt;1&lt;span&gt;,
        ret: tempData
    })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话，首页是进去了，但是在浏览器里面下滑的话还会有很多条目出来的，要想爬到这部分后来加载出来的条目，就需要分析网页的请求了。在浏览器里面打开知乎，然后按F12进入控制台，点击network，然后在网页里面下滑，就会发现network里面有很多请求，其中有一条请求是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/692074/201712/692074-20171212002844430-1675204000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这条请求返回的数据是很多的，它应该就是我们需要的请求了。点击上面的Headers,然后找到请求头，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/692074/201712/692074-20171212003036774-1181339357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将请求头里面的这些信息塞到superagent的set函数里面，并且将Headers下面的Request URL替换之前的url，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
superagent.get(&quot;https://www.zhihu.com/api/v3/feed/topstory?action_feed=True&amp;amp;limit=10&amp;amp;session_token=a28a2fdc4537d7d14cbd46bcaf16912a&amp;amp;action=down&amp;amp;after_id=9&amp;amp;desktop=true&quot;&quot;&lt;span&gt;)
.set({
    'Cookie': '_zap=67cf877b-b4c4-4798-9e23-d3ef6553d2f9; q_c1=fae7f35742874cd2b0356a5c321d085f|1501321325000|1501321325000; aliyungf_tc=AQAAAPsawBFU6QgABtBbcXShs11WbLol; q_c1=fae7f35742874cd2b0356a5c321d085f|1512744706000|1501321325000; _xsrf=51039ae2b79b7ba81f1da8eba41f2b62; r_cap_id=&lt;/span&gt;&quot;MDc0MTM0MWZlNWY2NDc2Mzk1YTdhOWE0MWFkZDQzYjA=|1512744706|b5b2a49f82637c6408347fe8941ea3315f5f5be3&quot;; cap_id=&quot;NjI5ZDM3YTIzY2ZjNDhhOWJlZWM2MjIxNjQ0MjNmOTE=|1512744706|210d6f4e2c44900b25afebff79b79d9aac13dda0&quot;; d_c0=&quot;ABBCbcS6zQyPTk28d91f51hdLtLQ1xQPe3s=|1512744707&quot;&lt;span&gt;; l_n_c=1; z_c0=Mi4xRDVobkFRQUFBQUFBRUVKdHhMck5EQmNBQUFCaEFsVk5JUFVYV3dBaC1ZVktoUjFoRExNMEI1Mkp5a1BWSHpUaERn|1512744736|1d19657b025b92339fecc550c2fc8606f0f5ba48; __utma=155987696.856620421.1512833230.1512833230.1512833230.1; __utmc=155987696; __utmz=155987696.1512833230.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _xsrf=51039ae2b79b7ba81f1da8eba41f2b62',
    'Host': 'www.zhihu.com',
    'Referer': 'https://www.zhihu.com/',
    'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',
    'x-api-version': '3.0.53',
    'x-udid': 'ABBCbcS6zQyPTk28d91f51hdLtLQ1xQPe3s=',
    'Connection': 'keep-alive',
    'authorization': 'Bearer Mi4xRDVobkFRQUFBQUFBRUVKdHhMck5EQmNBQUFCaEFsVk5JUFVYV3dBaC1ZVktoUjFoRExNMEI1Mkp5a1BWSHpUaERn|1512744736|1d19657b025b92339fecc550c2fc8606f0f5ba48'
})
.end(function(err,obj){
    if(err){
        return;
    }
    var tempData = {
        value: obj.text,
    };
    res.header(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);
    res.json({
        success: 1,
        ret: tempData
    })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实看代码可以发现我并没有把accept、Accept-Encoding、Accept-Language这三项加进去，因为我发现把请求头里面所有的信息塞进去之后，会返回错误信息，然后我试着删除掉一些请求信息，结果发现把这三项删除之后就可以请求成功。不清楚原因是什么。&lt;/p&gt;
&lt;p&gt;这样的请求返回的结果和浏览器里面看到的返回的结果是一样的，中文字符是是经过转义的，使用JSON.parse函数可以将这个经过转义的字符串变为可用的json对象。然后分析这个json对象，从里面取我们需要的数据。&lt;/p&gt;
&lt;p&gt;完整的server.js代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; superagent = require('superagent'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; qs = require(&quot;querystring&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cheerio = require('cheerio'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eventproxy = require('eventproxy'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ep = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; eventproxy();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();

app.use(express.static(&lt;/span&gt;'webapp'&lt;span&gt;));

app.post(&lt;/span&gt;'/getData', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    req.on(&lt;/span&gt;'data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentData = &quot;&quot;+&lt;span&gt;data;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; qs.parse(currentData);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index =&lt;span&gt; tempData.num;
        console.log(tempData.num);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; urlArr =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = index*2-1; i &amp;lt;= index*2; i++&lt;span&gt; ){
             &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &quot;http://www.cnblogs.com/?CategoryId=808&amp;amp;CategoryType=%22SiteHome%22&amp;amp;ItemListActionName=%22PostList%22&amp;amp;PageIndex=&quot;+i+&quot;&amp;amp;ParentCategoryId=0&quot;&lt;span&gt;;
            urlArr.push(url);
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; urlArr.length; j++&lt;span&gt; ){
            superagent.get(urlArr[j]).end(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,pre){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; $ =&lt;span&gt; cheerio.load(pre.text);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; $(&quot;.post_item_body&quot;).length; i++&lt;span&gt; ){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; titleElement = $(&quot;.post_item_body&amp;gt;h3&amp;gt;a&quot;&lt;span&gt;).eq(i);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; title =&lt;span&gt; titleElement.text();
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sourceUrl = titleElement.attr(&quot;href&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; textElement = $(&quot;.post_item_summary&quot;&lt;span&gt;).eq(i);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text =&lt;span&gt; textElement.text();
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Element = $(&quot;.post_item_summary&quot;&lt;span&gt;).eq(i);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; coverElement = Element.find('img'&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cover = &quot;&quot;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( coverElement!=undefined&amp;amp;&amp;amp;coverElement!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt; ){
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( coverElement.attr(&quot;src&quot;)==&lt;span&gt;undefined ){
                            cover &lt;/span&gt;=&lt;span&gt; undefined;
                        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                            cover &lt;/span&gt;= &quot;https:&quot;+coverElement.attr(&quot;src&quot;&lt;span&gt;);
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; {
                        itemTitle: title,
                        itemLink: sourceUrl,
                        itemText: text,
                        itemCover: cover
                    }
                    postData.push(tempData);
                }
                ep.emit(&lt;/span&gt;&quot;dataEvent&quot;&lt;span&gt;);
            })
        }
        ep.after(&lt;/span&gt;'dataEvent',2,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            res.header(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);
            res.json({
                success: &lt;/span&gt;1&lt;span&gt;,
                ret: postData
            })
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; endTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; time = endTime-&lt;span&gt;startTime;
            console.log(time);
        });
    });
})

app.post(&lt;/span&gt;'/getZhihuData', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    req.on(&lt;/span&gt;'data', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentData = &quot;&quot;+&lt;span&gt;data;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; qs.parse(currentData);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index =&lt;span&gt; tempData.num;
        console.log(tempData.num);
        
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; afterId = index*10-1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &quot;https://www.zhihu.com/api/v3/feed/topstory?action_feed=True&amp;amp;limit=10&amp;amp;session_token=a28a2fdc4537d7d14cbd46bcaf16912a&amp;amp;action=down&amp;amp;after_id=&quot;+afterId+&quot;&amp;amp;desktop=true&quot;&lt;span&gt;;
        superagent.get(url)
        .set({
            &lt;/span&gt;'Cookie': '_zap=67cf877b-b4c4-4798-9e23-d3ef6553d2f9; q_c1=fae7f35742874cd2b0356a5c321d085f|1501321325000|1501321325000; aliyungf_tc=AQAAAPsawBFU6QgABtBbcXShs11WbLol; q_c1=fae7f35742874cd2b0356a5c321d085f|1512744706000|1501321325000; _xsrf=51039ae2b79b7ba81f1da8eba41f2b62; r_cap_id=&quot;MDc0MTM0MWZlNWY2NDc2Mzk1YTdhOWE0MWFkZDQzYjA=|1512744706|b5b2a49f82637c6408347fe8941ea3315f5f5be3&quot;; cap_id=&quot;NjI5ZDM3YTIzY2ZjNDhhOWJlZWM2MjIxNjQ0MjNmOTE=|1512744706|210d6f4e2c44900b25afebff79b79d9aac13dda0&quot;; d_c0=&quot;ABBCbcS6zQyPTk28d91f51hdLtLQ1xQPe3s=|1512744707&quot;; l_n_c=1; z_c0=Mi4xRDVobkFRQUFBQUFBRUVKdHhMck5EQmNBQUFCaEFsVk5JUFVYV3dBaC1ZVktoUjFoRExNMEI1Mkp5a1BWSHpUaERn|1512744736|1d19657b025b92339fecc550c2fc8606f0f5ba48; __utma=155987696.856620421.1512833230.1512833230.1512833230.1; __utmc=155987696; __utmz=155987696.1512833230.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _xsrf=51039ae2b79b7ba81f1da8eba41f2b62'&lt;span&gt;,
            &lt;/span&gt;'Host': 'www.zhihu.com'&lt;span&gt;,
            &lt;/span&gt;'Referer': 'https://www.zhihu.com/'&lt;span&gt;,
            &lt;/span&gt;'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'&lt;span&gt;,
            &lt;/span&gt;'x-api-version': '3.0.53'&lt;span&gt;,
            &lt;/span&gt;'x-udid': 'ABBCbcS6zQyPTk28d91f51hdLtLQ1xQPe3s='&lt;span&gt;,
            &lt;/span&gt;'Connection': 'keep-alive'&lt;span&gt;,
            &lt;/span&gt;'authorization': 'Bearer Mi4xRDVobkFRQUFBQUFBRUVKdHhMck5EQmNBQUFCaEFsVk5JUFVYV3dBaC1ZVktoUjFoRExNMEI1Mkp5a1BWSHpUaERn|1512744736|1d19657b025b92339fecc550c2fc8606f0f5ba48'&lt;span&gt;
        })
        .end(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err,obj){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; X =&lt;span&gt; JSON.parse(err);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Y =&lt;span&gt; JSON.stringify(X);
                console.log(Y);
                console.log(&lt;/span&gt;&quot;err&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tempData =&lt;span&gt; {
                value: obj.text,
            };
            res.header(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);
            res.json({
                success: &lt;/span&gt;1&lt;span&gt;,
                ret: tempData
            })
        })
        
    });
})

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = app.listen(8081, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; server.address().address
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port =&lt;span&gt; server.address().port

  console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port)

})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里面还用到了eventproxy这个东西，因为node.js可以异步执行，所以在一个循环里面使用的superagent也是异步执行的，它不会等当前循环执行完之后再执行下一个循环，所以在这种情况下，我们不知道这个for循环里面的所有的superagent什么时候可以执行完。所以就有了eventproxy这个东西。它相当于是一个监听器，在一个循环的末尾使用ep.emit(&quot;dataEvent&quot;);这个函数，然后就可以触发ep.after函数，在触发的次数达到设定的次数之后，after函数里面的代码就会执行。&lt;/p&gt;
&lt;p&gt;这里前端的细节就不再赘述了，主要实现的功能就是前端请求数据的时候，后端就去爬取数据并返回给前端，没有用到数据库或者是存储数据的文件。前端也实现了上划加载，loading动画的功能是我之前写过的一个loading动画，突然想到可以用到这里就搬来了。loading动画可以看这里：http://www.cnblogs.com/huizit1/p/5470587.html&lt;/p&gt;
&lt;p&gt;前端除了vue和jquery就没有使用其他的插件或者库了。完整的代码在这里:https://github.com/swang23/NodeWebParser&lt;/p&gt;
&lt;p&gt;项目代码克隆到本地之后，要想跑起来需要在home.js里面把ajax请求的url里面的ip地址换成自己电脑的ip地址（命令窗口里面：ipconfig回车查看ipv4地址），然后node server.js，在浏览器里面输入http://localhost:8081/html/home.html即可查看结果。&lt;/p&gt;
&lt;p&gt;觉得不错的github里面点个星：https://github.com/swang23/NodeWebParser&lt;/p&gt;
</description>
<pubDate>Mon, 11 Dec 2017 17:12:00 +0000</pubDate>
<dc:creator>辉子t1</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huizit1/p/8025816.html</dc:identifier>
</item>
<item>
<title>数据结构(一) - xiaoyouPrince</title>
<link>http://www.cnblogs.com/xiaoyouPrince/p/8025810.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyouPrince/p/8025810.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据结构定义:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器(内存)中,以及在此基础上为实现某个功能(如元素的CURD、排序等)而执行的相应操作，这个相应的操作也叫算法。&lt;/p&gt;
&lt;p&gt;数据结构 = 元素 + 元素的关系&lt;br/&gt;算法 = 对数据结构的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法就是：解决问题的方法和步骤&lt;/p&gt;
&lt;p&gt;衡量算法有如下标准:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;时间复杂度&lt;br/&gt;程序要执行的次数，并非执行时间&lt;/li&gt;
&lt;li&gt;空间复杂度&lt;br/&gt;算法执行过程中大概要占用的最大内存&lt;/li&gt;
&lt;li&gt;难易程度(可读性)&lt;/li&gt;
&lt;li&gt;健壮性&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toc_2&quot;&gt;2. 数据结构的特点和地位&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;地位:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据结构处于软件中核心的地位。&lt;/p&gt;
&lt;p&gt;如计算机内存中栈和堆的区别，不懂数据结构的人可能会认为内存就是分两大部分，一块叫栈，一块叫堆，显然这是非常肤浅且不正确的结论。&lt;/p&gt;
&lt;p&gt;实际上如果一块内存是以压栈出栈的方式分配的内存，那么这块内存就叫栈内存，如果是以堆排序的方式分配的内存，那么这块内存就叫堆内存，其最根本的区别还是其内存分配算法的不同。&lt;/p&gt;
&lt;p&gt;例如，函数的调用方式也是通过&lt;code&gt;压栈出栈&lt;/code&gt;的方式来调用的，或者操作系统中多线程操作有&lt;code&gt;队列&lt;/code&gt;的概念，&lt;code&gt;队列&lt;/code&gt;用于保证多线程的操作顺序，这也是数据结构里面的内容、或者计算机编译原理里面有&lt;code&gt;语法树&lt;/code&gt;的概念，这实际上就是数据结构里面的&lt;code&gt;树&lt;/code&gt;，比如软件工程、数据库之类都有数据结构的影子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据结构修炼的是内功，并不能直接立竿见影的可以解决现实问题，但是有了这门内功会在其他方面的学习中对你大有益处。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;3. 预备知识（C语言）&lt;/h2&gt;
&lt;p&gt;学习数据结构应该具备如下知识：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指针&lt;/li&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;动态内存的分配和释放&lt;/li&gt;
&lt;li&gt;跨函数使用内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本小节主要介绍学习数据结构应该有的基础，并对相关知识稍作讲解。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;指针&lt;/h3&gt;
&lt;p&gt;指针是 C语言 的灵魂，重要性不需多言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;br/&gt;　　地址是内存单元的编号&lt;br/&gt;　　其编号是从 0 开始的非负整数&lt;br/&gt;　　范围： 0 -- 0xFFFFFFFF (2&lt;sup&gt;32&lt;/sup&gt; - 1) &lt;strong&gt;注：此指x86平台，x64平台下最大内存地址为 (2&lt;sup&gt;64&lt;/sup&gt; - 1)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针：&lt;br/&gt;　　指针就是地址，地址就是指针。&lt;br/&gt;　　指针变量是存放内存单元地址的变量,它内部保存的值是对应的地址,地址就是内存单元的编号(如内存地址值：0xffc0)。&lt;br/&gt;　　指针的本质是一个操作受限的非负整数&lt;br/&gt;　　&lt;br/&gt;在计算机系统中，CPU 可以直接操作内存，关于 CPU 对内存的操作与控制原理可以简单理解如下图&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171212004515696-1159230820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地址线 ： 确定操作哪个地址单元&lt;br/&gt;控制线 ： 控制该数据单元的读写属性&lt;br/&gt;数据线 ： 传输 CPU 和内存之间的数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;基本类型的指针&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;int i = 10;  // 定义一个 整形变量 i 初始值 10

int *p = i;  // 定义一个 整形的指针变量 p , 变量 p 指向 i 的地址    

int *p;      // 这两行等价于上面一行
p = &amp;amp;i;

1. p 存放了 i 的地址，我们就可以说“ p 指向了 i” ，但 p 和 i 是两个不同的变量，修改一方不会影响另一个的值。
2. *p 等价于 i ，i 等价于 *p;两者是一块内存空间，里面的值一变具变。
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;指针和函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;// 修改外部实参的值
void func(int * p)
{
    *p = 100;   // 函数内修改外部变量的值   
}

// 修改外部实参的值，二级指针的值
void func2(int ** p)
{
    *p = 100;   
    // 函数内修改外部变量的值 ，这里实际修改的是指针的内部的地址，这里直接自己修改并不严谨也不安全，只是为了表达意思  
}

int main(void)
{
    // 修改外部实参
   int i = 10;
   func(&amp;amp;i);
   printf(&quot;i = %d&quot;,i);

   // 修改外部二级指针
   int *p = i; // 等价于 int *p; p = &amp;amp;i;
   func(&amp;amp;p);
   printf(&quot;i = %d&quot;,i);

   return 0;
}

// 通过函数调用，改变函数外部变量（实参）的值

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;指针和数组&lt;/p&gt;
&lt;p&gt;【指针】 和 【一维数组】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt; int a[5] = {1,2,3,4,5 };

 a[3] == *(a + 3)  
 // 等价于 a[3] == *(3 + a) == 3[a];
 // 3[a] 这种写法只是不常用，从原理上来说是正确的 a 等价于 a[0];
 // a 是数组中第一个元素，每个元素占用内存单位长度相同，
 // a[i] 中的 i 实际代表的是单位长度的倍数
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;数组名:&lt;br/&gt;　　一维数组名是个指针常量(它的值不可变)&lt;br/&gt;　　它存放的是该一维数组的第一个元素的地址(一维数组名指向其第一个元素) 　　&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;下标和指针的关系:&lt;br/&gt;　　(1)、 &lt;code&gt;a[i]&lt;/code&gt; 等价于 &lt;code&gt;*(a + i)&lt;/code&gt;&lt;br/&gt;　　(2)、假设指针变量的名字为 p,&lt;br/&gt;　　则 &lt;code&gt;p + i&lt;/code&gt; 的值为 &lt;code&gt;p + i * (p 所指向的变量所占字节数)&lt;/code&gt;&lt;br/&gt;　　(3)、每个下标表示的是第 i+1 个元素，根据元素类型分配的字节长度不同(int 类型4个字节)，每个字节都有对应的内存地址编号，指针变量 p 保存的是该元素首字节的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;指针变量的运算:　&lt;br/&gt;　　指针变量不能相加、相乘、相除&lt;br/&gt;　　如果两指针变量属于同一数组，则可以相减&lt;br/&gt;　　指针变量可以加减一个整数，前提是最终结果不能超过指针最大可访问范围&lt;br/&gt;　　 　　&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;// 指针变量的运算
p + i 的值是 p + i*(所指向的变量所占字节数)
p - i 的值是 p - i*(所指向的变量所占字节数)
p++   等价于 p + 1
p--   等价于 p - 1

// 下面是一个通过函数修改数组内部元素
void my_Array(int *a , int length)
{
    for(int i = 0; i &amp;lt; length; i++)
    {
        *a[i]++;  // 给每个元素加 1
    }
}

int main(void){

    int a[5] = {1,2,3,4,5};
    my_Array(a , 5); // 调用
}

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_5&quot;&gt;结构体&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么会出现结构体&lt;/strong&gt;、&lt;/p&gt;
&lt;p&gt;为了表示一些复杂的数据，而普通的基本数据无法满足要求.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么叫结构体&lt;/strong&gt;&lt;br/&gt;结构体是用户根据实际需要，自己定义的复合数据类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;// 如学生类型
struct Student{
   int age;
   char * name; // name 不同，赋值方法不同
   char name2[100]; // 这个只能 strcpy(s.name2, &quot;zhangwangdsd&quot;); 字符串拷贝
   double height;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如何使用结构体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结起来有两种结构体的使用方式：直接使用 &amp;amp;&amp;amp; 通过指针使用&lt;br/&gt;struct Student ss = {12,&quot;xiaoyou&quot;,1.73,&quot;xiaozhang&quot;};&lt;br/&gt;struct Student *pst = &amp;amp;ss;&lt;/p&gt;
&lt;p&gt;ss.name ; 这里直接操作结构体本身&lt;br/&gt;pst -&amp;gt; name ; 这里通过指针地址操作，更加节省空间&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct Student{ // 自定义结构体
    int age;
    char * name;
    double height;
    char name2[100];
};

int main(void) {

   struct Student s = {12,&quot;xiaoyou&quot;,1.73,&quot;xiaozhang&quot;};

// 直接使用
   printf(&quot; age = %d \n name = %s \n height = %.2f \n&quot;,s.age,s.name,s.height);

   s.age = 21;
   s.name = &quot;xiaozhu&quot;;
   strcpy(s.name2, &quot;zhangwangdsd&quot;);  // 字符串拷贝
   s.height = 1.70;

   printf(&quot; age = %d \n name = %s \n height = %.2f \n %s \n&quot;,s.age,s.name,s.height,s.name2);

   // 以指针的方式使用
   struct Student *pst = &amp;amp;ss;
   pst -&amp;gt; name = &quot;my new name&quot;;
   
   printf(&quot; name = %s\n&quot;,pst-&amp;gt;name);
   printf(&quot; name = %s\n&quot;,(*pst)-&amp;gt;name);
   
// pst -&amp;gt; name 等价于 (*pst).name ,
// 而(*pst).name 又等价于 ss.name
// 所以 pst -&amp;gt; name 等价于 ss.name

   return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;br/&gt;结构体变量的类型为： struct Student&lt;br/&gt;结构体变量不能加减乘除，但是能够相互赋值&lt;br/&gt;普通结构体变量和结构体指针变量作为函数传参的问题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct Student{ // 结构体定义
    int age;
    char * name;
    char name2[100];
    double height;
}myStudent;

// 直接传递整个结构体数据，耗时 &amp;amp;&amp;amp; 浪费内存空间
void func(struct Student st);
// 直接传递 只占用 4 byte 的指针，省时效率也高 &amp;lt;推荐用法&amp;gt;
void func2(struct Student * pst);

int main(void){

    myStudent ss = {12,&quot;xiaoyou&quot;,1.73};
    func(ss);
    func2(&amp;amp;ss);
    return 0;
}

void func(struct Student st){
    
    printf(&quot;age = %d \n name = %s&quot;,st.age,st.name);
}

void func2(struct Student * pst){
    
    printf(&quot;age = %d \n name = %s&quot;,(*pst).age,(*pst).name);
    printf(&quot;age = %d \n name = %s&quot;,pst-&amp;gt;age,pst-&amp;gt;name);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;动态内存分配和释放&lt;/h3&gt;
&lt;p&gt;平时直接创建数组的写法都是静态创建，创建完毕之后在整个程序的运行过程中，会固定占用对应的内存，不仅会造成内存空间浪费，还无法动态添加元素，所以局限性很大，而程序中我们为了避免这种情况，应该使用动态的方式创建和销毁数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 静态创建数组
int a[5] = {1,2,3,4,5};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动态构造一维数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态构造一个 &lt;code&gt;int 型&lt;/code&gt;的一维数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int *p = (int *)malloc(int length);

1. void * malloc(size_t __size) 函数,只有一个 int 类型的形参，表示要求系统分配的字节数
2. malloc 函数的功能是请求系统 length 个字节的内存空间，如果请求完成则返回的是第一个字节的地址，
    如果请求不成功，则返回NULL
3. malloc 函数能且只能返回第一个字节的地址，所以我们需要把没有实际意义的第一个字节地址（干地址）转化为一个有实际意义的地址，
    所以 malloc 前面必须加(数据类型 *)，表示把这个无意义的地址转化为对应类型的地址
    
    实例：
        int *p = (int *)malloc(50);
        表示将系统分配的 50 个字节的第一个字节的地址转化为 int 类型的地址，准确的说是转化为 4 个一组的地址的首地址，
        这样 p 就指向了第一个四个字节··· p+i 就指向了第 i+1 个四个字节，p[0],p[i]也就分别是第一个，第i+1个元素。
        
        double *p = (double *)malloc(80);
        表示将系统分配的 80 个字节的第一个字节的地址转化为 double 类型的地址，准确的说是转化为 8 个一组的地址的首地址，
        这样 p 就指向了第一个八个字节··· p+i 就指向了第 i+1 个八个字节，p[0],p[i]也就分别是第一个，第i+1个元素。
        
4. free(p);
    释放 p 所指向的内存，而不是释放 p 本身所占用的内存
        
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void test2(void)
{
    int len;
    printf(&quot;请输入你要动态创建的数组长度:&quot;);
    scanf(&quot;%d&quot;,&amp;amp;len);
    
    int *pArr = (int *)malloc(len); // 动态创建数组
    *pArr = 4;      // 相当于 a[0] = 4;  这里 pArr 就等于数组首地址，等于数组名
    pArr[2] = 5;    // 相当于 a[2] = 5;
    
    printf(&quot;pArr[0] = %d \npArr[2] = %d\n&quot;,pArr[0],pArr[2]);
    
    free(pArr);     // 使用完毕，释放对应的数组空间 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;跨函数使用内存&lt;/h3&gt;
&lt;p&gt;在函数内部分配的局部变量，在函数调用完成之后就会被系统回收，其内存也会消失。但是程序中常常需要定义一块内存，当我们用完之后再会回收。如 OC 语言中对象。所以需要保存住分配的内存，应该用动态分配内存，当用完之后再手动释放。这也是C语言的一个不足之处：内存需要我们手动创建和手动释放，这也是 OC 语言在开发 iOS 程序时候，我们所讲的MRC。【苹果也发现了这个不足，于 iOS 5 的时候推出了ARC 】&lt;/p&gt;
&lt;p&gt;下面是一个跨函数使用内存的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 这个例子已经非常有面向对象的味道了

typedef struct Student{     // 自定义 student 结构体
    int age;
    char * name;
}myStudent;

myStudent * createStudent(void); // 创建 student 
void showStudent(myStudent *);   // 输出 student

int main(void) {

    myStudent *p = createStudent();  // 创建 student 
    showStudent(p);                  // 输出 student
    
    return 0;
}

myStudent * createStudent(void)
{
    myStudent *p = (myStudent *)malloc(sizeof(myStudent));
    p-&amp;gt;age = 20;
    p-&amp;gt;name = &quot;xiaoyou&quot;;
    return p;
}

void showStudent(myStudent *p)
{
    printf(&quot;student.age = %d \nstudent.name = %s\n&quot;,p-&amp;gt;age,p-&amp;gt;name);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_8&quot;&gt;4. 小结&lt;/h2&gt;
&lt;p&gt;本文主要讲解了数据结构的定义和简介。&lt;br/&gt;回顾了学习数据结构应该具备的一些 C语言 的基础知识，如指针、结构体、和内存等。&lt;/p&gt;
&lt;p&gt;后面会继续开始对数据结构的讲解。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Dec 2017 16:48:00 +0000</pubDate>
<dc:creator>xiaoyouPrince</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyouPrince/p/8025810.html</dc:identifier>
</item>
<item>
<title>C++反汇编第四讲,反汇编中识别继承关系,父类,子类,成员对象 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8025789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8025789.html</guid>
<description>&lt;p&gt;&lt;strong&gt;讲解目录:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　1.各类在内存中的表现形式   备注: 主要复习开发知识,和反汇编没有关系,但是是理解反汇编的前提.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　    2.子类继承父类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　2.1 子类中有虚函数,父类中有虚函数　　　　: 都有的情况下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　   2.2 子类中没有虚函数,父类中有虚函数　　　: 子类没有,父类有的情况 2.1 2.2的情况都是一样的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　　　  2.3   子类中有虚函数,父类中没有虚函数　 : 子有父没有的的情况下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　   2.4 子类父类都没有虚函数的情况下&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　第二专题大总结.　　　　熟悉反汇编可以直接看这个总结,&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　3.结合第二专题的成员对象有无虚表行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　3.1成员对象有虚表的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　3.2成员对象没有虚表的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　第三专题大总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　  4.重载运算符的识别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 5.纯虚函数的反汇编　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 6.模版识别.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;一丶各类在内存中的表现形式(复习开发知识)&lt;/h2&gt;
&lt;p&gt;讲解之前,我们首先要明白C/C++中的类的内存结构.继承之后的内存结构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通类的内存结构:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　高级代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyTest
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyTest();
    &lt;/span&gt;~&lt;span&gt;MyTest();
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_int;
};

MyTest::MyTest(){}

MyTest::&lt;/span&gt;~&lt;span&gt;MyTest(){}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyTest test;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应内存结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211223426321-1714182800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是普通的一个类的内存结构图,因为我们只有一个成员,大小是一个4字节的,所以初始化为CC&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结: 普通类根据成员进行申请内存.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带有虚关键字的类(可能有虚函数或者虚构造)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS: &lt;/strong&gt;类声明同上,但是析构前边加上了virtual 关键字,变为了虚析构&lt;/p&gt;
&lt;p&gt;内存结构图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211224444243-2142312897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,申请了八个字节,启动前4个字节是虚表指针,指向了虚表&lt;/p&gt;
&lt;p&gt;后四个字节才是真正的为成员申请的内存.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结: 带有虚函数(虚关键字)的时候,内存中会把前4个字节当做虚表指针,并且在构造的时候初始化.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子类继承父类,(都有虚函数的情况下)重要:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级代码:&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyFather&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyFather();
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;MyFather();
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_int;
};

MyFather::MyFather(){}

MyFather::&lt;/span&gt;~&lt;span&gt;MyFather(){}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyChild : public MyFather //继承
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyChild();
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;MyChild();&lt;br/&gt;　　float m_flt;&lt;br/&gt;};

MyChild::MyChild(){}

MyChild::&lt;/span&gt;~&lt;span&gt;MyChild(){}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyChild test;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内存结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211225026555-1020611338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总共申请了12个字节,前4个字节是虚表指针,后4个字节是父类的m_int成员,在后面才是子类的真正的成员.&lt;/p&gt;
&lt;p&gt;说到这里我们就要说下复写虚表指针的操作.&lt;/p&gt;
&lt;p&gt;首先我们知道:  子类构造的时候,会先构造父类,也就是说,父类的内存会先申请,并且把虚表指针填写到前4个字节位置,  而构造完毕父类之后,构造自己的时候,这时候虚表指针又写入子类的虚表指针了.产生了覆盖了.&lt;/p&gt;
&lt;p&gt;流程图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211225716962-137070242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 看上面图可以知道,我们子类继承父类,并且填写了虚表指针为子类的,此时 则可以写成  父类指针指向子类   例如:  Myfather *pFa = new MyChild;  pfa指向的位置就是父类区域的起始位置,&lt;/p&gt;
&lt;p&gt;而且不会超过父类区域,所以是安全的,此时因为构造完毕,虚表指针是子类的,所以调用虚函数的时候,则是调用子类的虚函数了.&lt;/p&gt;
&lt;p&gt;而且也说明了 为什么子类指针不能指向父类.这样会产生越界问题.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　子类继承父类时候,有虚函数的时候,会先把头4字节申请出来填写为虚表指针, 而且会产生复写(重复写入). 第一次, 构造父类,填写为父类指针,第二次 构造完父类则会填写为子类的虚表指针.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;二丶子类继承父类反汇编中的结构&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;2.1 子类中有虚函数,父类中有虚函数　　　　: 都有的情况下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyFather
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyFather();
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;MyFather();
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_int;
};

MyFather::MyFather(){}

MyFather::&lt;/span&gt;~&lt;span&gt;MyFather(){}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyChild : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyFather
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyChild();
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;MyChild();
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; m_flt;
};

MyChild::MyChild(){}

MyChild::&lt;/span&gt;~&lt;span&gt;MyChild(){}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyChild test;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的反汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PS: 代码太多,只说明这个反汇编在哪个函数中&lt;/p&gt;
&lt;p&gt;1.main函数中找到构造&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211231040477-1184838140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.构造中生成的反汇编&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211231130118-914856524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,构造中又有一个Call,这个Call是构造父类的,构造完毕之后填写自己的虚表指针.&lt;/p&gt;
&lt;p&gt;3.父类构造&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211231228399-577643087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父类构造填写虚表指针,也就是对象的前4个字节修改为父类的虚表指针.而后通过第二步,得出,当构造完父类之后,其前4个字节会被子类重新写入.也就产生了复写过程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.子类构造的时候会先构造父类,父类构造中先填写虚表指针.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.父类构造完成之后,子类会重新写入虚表指针.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3..子类继承父类,都有虚函数的情况下,会产生复写行为, 对象首地址4个字节处填写虚表.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt; 2.2 子类中没有虚函数,父类中有虚函数　　　: 子类没有,父类有的情况&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;PS: 高级代码中,子类类声明去掉了虚函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Debug下的反汇编代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;1.main函数下构造的反汇编&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211231842618-829014136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　2.构造内部反汇编&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211231915712-1082439366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这一步我们明白了,首先构造父类,因为父类有虚函数,所以肯定会有虚表指针填写,而下方也填写了一次虚表指针.由此得出&lt;/p&gt;
&lt;p&gt;父类有虚函数,子类没有虚函数则子类也会有虚表.也会产生复写行为.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　父有,子没有,子类也会有虚表,而且也会产生虚表指针复写行为.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　且只要父类有虚函数,不管子类有没有虚函数,子类都会产生虚表,且会复写虚表指针.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.3 子类有虚函数,父类没有虚函数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高级代码: &lt;/strong&gt;子类中定义了虚函数,父类则把虚函数去掉了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Debug下的反汇编代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.main函数下构造&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211232617134-813300095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.构造内部&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211232655024-525118068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看其内部得出,父类没有虚函数的情况下,其对象 +4位置,跳过前边的4个字节,来构造父类,构造完毕之后填写子类虚表指针.&lt;/p&gt;
&lt;p&gt;　　3.父类构造内部&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211232801977-1397775794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父类构造内部没有产生虚表指针填写行为&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　子类有虚表,父类没有,则会跳过虚表指针的位置来构造父类,当构造完毕父类之后前4个字节填写子类的虚表指针.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.4 子类,父类都没有虚函数的情况下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 直接构造内存,没有虚表,也不会产生虚表指针复写,可以当做结构体还原.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二专题大总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;　1.父类有虚函数,子类不管有没有虚函数,都会有虚表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　2.父类有虚函数构造的时候会填写虚表指针,且子类也会填写虚表指针,两者会产生虚表指针复写行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　3.子类中有虚函数,父类没有,则会跳过虚表指针来构造父类,其子类会在构造完毕父类之后填写虚表指针,不会产生虚表指针复写行为.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三丶结合第二专题的成员对象有无虚表行为&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3.1成员对象没有虚表的情况下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MyMemberObj           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员对象&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyMemberObj(){}
    &lt;/span&gt;~&lt;span&gt;MyMemberObj(){}
};

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyFather              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyFather();
     &lt;/span&gt;~&lt;span&gt;MyFather();
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_int;
};

MyFather::MyFather(){}

MyFather::&lt;/span&gt;~&lt;span&gt;MyFather(){}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyChild : &lt;span&gt;public&lt;/span&gt; MyFather &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类继承父类&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyChild();
     &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;MyChild();
    MyMemberObj m_memberobj;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员对象&lt;/span&gt;
    &lt;span&gt;float&lt;/span&gt;&lt;span&gt; m_flt;
};

MyChild::MyChild(){}

MyChild::&lt;/span&gt;~&lt;span&gt;MyChild(){}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyChild test;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的反汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1.main函数下的构造&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211234008540-1570437353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.构造内部&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211234046477-947968203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.构造父类,因为父类没有虚函数,所以+4构造一下,且父类有一个成员,所以申请了4个字节空间&lt;/p&gt;
&lt;p&gt;2.成员变量的构造+8的位置开始构造,父类构造完毕之后构造,且此时成员对象没有虚函数.&lt;/p&gt;
&lt;p&gt;3.子类在自己的头4个字节位置处填写虚表指针.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;3.成员对象构造内部&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211234315805-1323446194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成员对象内部不会产生写虚表的行为.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　成员对象没有虚函数的情况下,会在合适偏移位置处进行构造,注意合适位置处的用语,如果你是子类的成员对象,肯定会先构造父类,父类成员很多,则你的偏移位置则不固定.&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;3.2成员对象有虚表的情况下.&lt;/h3&gt;
&lt;p&gt;Debug下的汇编代码:&lt;/p&gt;
&lt;p&gt;　　因为其类之加了一个虚关键字,析构变为了虚析构,产生了虚表的动作.所以其汇编代码1,2步没有改变,同上.&lt;/p&gt;
&lt;p&gt;　　不同的是构造的时候,成员对象有了虚函数,构造的时候则会填写虚表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211234806305-1065079212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.有成员对象的时候其成员对象内部没有虚表产生,则会在合适位置构造成员对象.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.有成员对象的时候,其成员对象内部有虚表产生,则在合适位置填写虚表指针,并且构造成员对象.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;四丶反汇编中重载运算符的识别&lt;/h2&gt;
&lt;p&gt;在说重载运算符的时候,我们首先熟悉一下运算符重载的高级代码:&lt;/p&gt;
&lt;p&gt;简单的运算符重载&lt;/p&gt;
&lt;p&gt;函数类型 operator 运算符名称 (形参表列)&lt;br/&gt;    {&lt;br/&gt;        // 对运算符的重载处理&lt;br/&gt;    }&lt;/p&gt;
&lt;p&gt;高深一点的可以参考博客,这里不再重复讲解.复习开发知识可以参考博客链接 &lt;a href=&quot;http://c.biancheng.net/cpp/biancheng/view/215.html&quot; target=&quot;_blank&quot;&gt;http://c.biancheng.net/cpp/biancheng/view/215.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;+(MyChild&amp;amp; a,MyFather&amp;amp;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)a.m_flt +&lt;span&gt; b.m_int;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyChild a;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
&lt;span&gt;    MyFather b;
    cout &lt;/span&gt;&amp;lt;&amp;lt; a + b &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在反汇编中,其实运算符重载就是调用函数.只不过换了一种函数的认知方式.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171211235738446-1855183337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实不难.当做函数还原就好.&lt;/p&gt;
&lt;p&gt;说道这里,我们可以说下运算符重载的额外认知.&lt;/p&gt;
&lt;p&gt;比如我们熟悉的&lt;/p&gt;
&lt;p&gt;1.数学中的中缀式   a + b / c - d * e 这种表达式就是中缀表达式&lt;/p&gt;
&lt;p&gt;2.波兰式　　　　 -+a/bc*de  中缀转化为了波兰式,我们学习数据结构的树的时候就学习过这种方式,这个是编译原理中的.适用于计算机的识别.&lt;/p&gt;
&lt;p&gt;怎么转换的&lt;/p&gt;
&lt;p&gt;Sub(add(a,Div(b,c),Imul(d,e); 转为汇编代码,比如a + b /c 我们则写成  add(a,div(b,c),然后转为汇编表达式即可.最终的结果则是上面写的波兰式.只不过按照语义,变为符号化了.&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;五丶纯虚函数的反汇编　&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我们知道,纯虚函数是为了子类实现了,自己不能实现,但是反汇编代码中其实实现了,只不过里面调用了提示错误的API.就是为了你不小心调用的时候提示不能创建xxx对象的实例.等等一些列的错误.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MyFather              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyFather();
     &lt;/span&gt;~&lt;span&gt;MyFather();
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; show() = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;纯虚函数&lt;/span&gt;
&lt;span&gt;};

MyFather::MyFather(){}

MyFather::&lt;/span&gt;~&lt;span&gt;MyFather(){}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyChild : &lt;span&gt;public&lt;/span&gt; MyFather &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类继承父类&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    MyChild();
     &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;MyChild();
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show();
};

MyChild::MyChild(){}

MyChild::&lt;/span&gt;~&lt;span&gt;MyChild(){}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyChild::show()
{
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyChild a;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
&lt;span&gt;    a.show();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Debug下反汇编&lt;/p&gt;
&lt;p&gt;我们直接看纯虚函数内部了,在子类构造的时候父类会构造,父类构造自己的时候会填写虚表指针,我们直接找父类的虚表指针即可.然后定位虚表中的第二项.&lt;/p&gt;
&lt;p&gt;第一项是父类的虚析构,第二项才是我们的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171212001053587-1700762527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;纯虚函数在低版本就是19h,并且调用__amsg_exit,且如果弄了签名,则是__purecall&lt;/p&gt;
&lt;p&gt;高版本不太一样,高版本不是简单的这样调用了(vs系列)它会保存当时的寄存器信息啊,什么的,然后写日志用的.反正结果是一样的.&lt;/p&gt;
&lt;p&gt;高版本自己可以试试看一看有什么不同.&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;六丶模版识别.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;模版和运算符重载一样,都是函数,编译为反汇编的代码都是函数调用.而且函数和函数的重载不同,它生成的反汇编代码有多处.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
template &amp;lt;typename T&amp;gt;&lt;span&gt;
T MySub(T a,T b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a  -&lt;span&gt; b;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    printf(&quot;%d\r\n&quot;,&lt;/span&gt;MySub(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;))&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　 　printf(&quot;%f\r\n&quot;,MySub(3.0f,1.0f))&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　printf(&quot;%lf\r\n&quot;,MySub(8.3,4.3))&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;   return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171212002019243-1565481777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Debug下反汇编.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171212002126493-2007824598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然都是一样调用,但是其内部是不同的.每个函数都有自己的汇编代码.&lt;/p&gt;

</description>
<pubDate>Mon, 11 Dec 2017 16:23:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8025789.html</dc:identifier>
</item>
<item>
<title>echarts 点击方法总结，点任意一点获取点击数据，举例说明:在多图联动中点击绘制标线 - 漠北桑海</title>
<link>http://www.cnblogs.com/mobeisanghai/p/8025448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mobeisanghai/p/8025448.html</guid>
<description>&lt;p&gt;关于点击（包括左击，双击，右击等）echarts图形任意一点，获取相关的图形数据，尤其是多图，我想部分人遇到这个问题一直很头大。下面我用举例说明，如何在多图联动基础上，我们点击任意一个图上任意一点，在点击处绘制一条标注线。&lt;br/&gt;多图联动的用法，我就不详细解释，不明白或者感兴趣的同学可以看我上一篇：&lt;a title=&quot;多图联动&quot; href=&quot;http://www.cnblogs.com/mobeisanghai/p/7683158.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/mobeisanghai/p/7683158.html&lt;/a&gt; ，虽然最近很忙，很久没更新，但是基本清晰。&lt;br/&gt;关于引入样式和js,以及初始元素如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/colpick/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/echarts.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        .main&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
         overflow-y&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1px #000 solid&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #mainf&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 30px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #70787b&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        #come&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 80px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        .startmian&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;come&quot;&lt;/span&gt;&lt;span&gt;  style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;数据进入 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;startmian&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;startmian&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次 初始化的方法和 假数据如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;147&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; a=[{&quot;F_X&quot;:[&quot;2017-3-1&quot;,&quot;2017-3-15&quot;,&quot;2017-4-1&quot;,&quot;2017-4-12&quot;,&quot;2017-5-21&quot;,&quot;2017-6-5&quot;,&quot;2017-8-12&quot;,&quot;2017-9-1&quot;,&quot;2017-10-11&quot;],&quot;F_Y&quot;:[{&quot;name&quot;:&quot;TT&quot;,&quot;type&quot;:&quot;line&quot;,&quot;symbol&quot;:&quot;emptycircle&quot;,&quot;data&quot;:[&quot;23&quot;,&quot;56&quot;,&quot;32&quot;,&quot;41&quot;,&quot;32&quot;,&quot;45&quot;,&quot;39&quot;,&quot;47&quot;,&quot;58&quot;]},{&quot;name&quot;:&quot;KK&quot;,&quot;type&quot;:&quot;line&quot;,&quot;symbol&quot;:&quot;emptycircle&quot;,&quot;data&quot;:[&quot;233&quot;,&quot;345&quot;,&quot;322&quot;,&quot;251&quot;,&quot;342&quot;,&quot;350&quot;,&quot;233&quot;,&quot;279&quot;,&quot;228&quot;]}],&quot;F_Z&quot;:&quot;温度&quot;},{&quot;F_X&quot;:[&quot;2017-3-1&quot;,&quot;2017-3-15&quot;,&quot;2017-4-1&quot;,&quot;2017-4-12&quot;,&quot;2017-5-21&quot;,&quot;2017-6-5&quot;,&quot;2017-8-12&quot;,&quot;2017-9-1&quot;,&quot;2017-10-11&quot;],&quot;F_Y&quot;:[{&quot;name&quot;:&quot;TT&quot;,&quot;type&quot;:&quot;line&quot;,&quot;symbol&quot;:&quot;emptycircle&quot;,&quot;data&quot;:[&quot;34&quot;,&quot;45&quot;,&quot;32&quot;,&quot;25&quot;,&quot;57&quot;,&quot;45&quot;,&quot;39&quot;,&quot;47&quot;,&quot;58&quot;]},{&quot;name&quot;:&quot;KK&quot;,&quot;type&quot;:&quot;line&quot;,&quot;symbol&quot;:&quot;emptycircle&quot;,&quot;data&quot;:[&quot;345&quot;,&quot;345&quot;,&quot;322&quot;,&quot;251&quot;,&quot;373&quot;,&quot;350&quot;,&quot;290&quot;,&quot;279&quot;,&quot;228&quot;]}],&quot;F_Z&quot;:&quot;水压&quot;},{&quot;F_X&quot;:[&quot;2017-3-1&quot;,&quot;2017-3-15&quot;,&quot;2017-4-1&quot;,&quot;2017-4-12&quot;,&quot;2017-5-21&quot;,&quot;2017-6-5&quot;,&quot;2017-8-12&quot;,&quot;2017-9-1&quot;,&quot;2017-10-11&quot;],&quot;F_Y&quot;:[{&quot;name&quot;:&quot;TT&quot;,&quot;type&quot;:&quot;line&quot;,&quot;symbol&quot;:&quot;emptycircle&quot;,&quot;data&quot;:[&quot;23&quot;,&quot;56&quot;,&quot;32&quot;,&quot;25&quot;,&quot;57&quot;,&quot;45&quot;,&quot;39&quot;,&quot;47&quot;,&quot;58&quot;]},{&quot;name&quot;:&quot;KK&quot;,&quot;type&quot;:&quot;line&quot;,&quot;symbol&quot;:&quot;emptycircle&quot;,&quot;data&quot;:[&quot;33&quot;,&quot;45&quot;,&quot;32&quot;,&quot;51&quot;,&quot;73&quot;,&quot;50&quot;,&quot;90&quot;,&quot;79&quot;,&quot;48&quot;]}],&quot;F_Z&quot;:&quot;气压&quot;&lt;span&gt;}];

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataGoz=[], &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总数据&lt;/span&gt;
         mdataeahars=[]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;echarts集合 ，用于联动使用&lt;/span&gt;
&lt;span&gt;        require.config({
            paths: {
                echarts: &lt;/span&gt;'js/echarts-2.2.7/src'&lt;span&gt;
            }
        }); 
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $.each(a,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(i,t){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加标线样式，这里是绘制多条标线&lt;/span&gt;
            $.each(t.F_Y,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(m,n){
                n.markLine&lt;/span&gt;=&lt;span&gt;{itemStyle:{
                    normal:{lineStyle:{type:&lt;/span&gt;'solid',color:'#000'},label:{show:&lt;span&gt;true&lt;/span&gt;,position:'left'&lt;span&gt;}}
                    },large:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,silent:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,data:[]}
        });})
        dataGoz&lt;/span&gt;=a; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到赋值&lt;/span&gt;
    startmiandiv();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始制图&lt;/span&gt;
&lt;span&gt;    } 
)();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始方法&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; startmiandiv(){
    mdataeahars&lt;/span&gt;=&lt;span&gt;[];
    $(&lt;/span&gt;&quot;#come&quot;).click(&lt;span&gt;function&lt;/span&gt;(){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击数据进入&lt;/span&gt;
        $(&quot;#come&quot;&lt;span&gt;).hide();
        nstart(dataGoz);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始入口&lt;/span&gt;
&lt;span&gt;        });   
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是给数据“数据进入&quot;元素一个点击事件，用于后面绘图;下面展示绘图方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心绘图方法  &lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt;  nstart(dataGoz){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  mainheight=0&lt;span&gt;,
    bodyheight&lt;/span&gt;=document.body.clientHeight,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取总高度&lt;/span&gt;
    mainheight=(bodyheight-40),      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配高度&lt;/span&gt;
    startmiandiv=$('#startmian'&lt;span&gt;);
    startmiandiv.empty();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maindiv='&amp;lt;div  class=&quot;main&quot;  style=&quot;height:'+mainheight+'px;max-height:'+mainheight+'px&quot;&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;; 
    startmiandiv.append(maindiv);
    mainFn(dataGoz,mdataeahars); 
    linkFn(dataGoz,dataGoz.length);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;联动方法&lt;/span&gt;
&lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;charts画图入口方法&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt;  mainFn(data,mdataeahars){ 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jing_class='jing'&lt;span&gt;,
    sv&lt;/span&gt;=&quot;&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态生成名称&lt;/span&gt;
    main0=$(&quot;.main&quot;)[0&lt;span&gt;];
       $.each(data,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i,t){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  div1='&amp;lt;div class=&quot;'+jing_class+'&quot; style=&quot;height:150px;width:100%;&quot;&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;;
                $(main0).append(div1);
                sv&lt;/span&gt;=jing_class+&lt;span&gt;i;
                youjin(i,t,sv,mdataeahars,data.length,jing_class);             
        });        
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;油井封装数据&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; youjin(item,t,tempmyech,mdataeahars,alength,jin_cid){  
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  legendshow=&lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只让第一个lengend显示&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(item==0&lt;span&gt;){
        legendshow&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    require(
            [
                &lt;/span&gt;'echarts'&lt;span&gt;,
                &lt;/span&gt;'echarts/chart/bar', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用柱状图就加载bar模块，按需加载&lt;/span&gt;
                'echarts/chart/line'&lt;span&gt;
            ],
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ec){ 
   tempmyech &lt;/span&gt;= ec.init($(&quot;.&quot;+jin_cid)[item]);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于准备好的dom，初始化echarts实例 &lt;/span&gt;
    $($(&quot;.&quot;+&lt;span&gt;jin_cid)[item]).contextmenu(
       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
            e.preventDefault();
            chartcontextmenu()
       }
    );
      $($(&lt;/span&gt;&quot;.&quot;+jin_cid)[item]).bind(&quot;dblclick.a&quot;&lt;span&gt;, chartDbck);  &lt;span&gt;//双击方法，防止事件冲突
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sj=[]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称集合&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; f_y=&lt;span&gt;t.F_Y;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colors=&lt;span&gt;[
                     &lt;/span&gt;'#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed'&lt;span&gt;,
                     &lt;/span&gt;'#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0'&lt;span&gt;,
                     &lt;/span&gt;'#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700'&lt;span&gt;,
                     &lt;/span&gt;'#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'&lt;span&gt;
                    ];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;f_y.length;i++&lt;span&gt;){
                sj.push(f_y[i].name);
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; forstr+= &quot;&amp;lt;br/&amp;gt;&amp;lt;font color=&quot;+colors[i]+&quot;&amp;gt;&amp;amp;nbsp;●&amp;amp;nbsp;&amp;lt;/font&amp;gt;{a&quot;+i+&quot;} : {c&quot;+i+&quot;}&quot;&lt;/span&gt;
&lt;span&gt;            }   
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; option =&lt;span&gt; {
                    tooltip: {
                        trigger: &lt;/span&gt;'axis', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;坐标轴触发提示框，多用于柱状、折线图中&lt;/span&gt;
                        formatter:  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (param){
                         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; forstr=&quot;&quot;+param[0&lt;span&gt;].name;
                         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0, h=param.length;i&amp;lt;h;i++&lt;span&gt;){
                        forstr&lt;/span&gt;+= &quot;&amp;lt;br/&amp;gt;&amp;lt;font color=&quot;+colors[i]+&quot;&amp;gt;&amp;amp;nbsp;●&amp;amp;nbsp;&amp;lt;/font&amp;gt;&quot;+param[i].seriesName+&quot; : &quot;+param[i].value+&quot;&quot;&lt;span&gt;
                                    }
                          Fmtresult(param[&lt;/span&gt;0].name,);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过它传递值&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;   forstr;         
                  },
                        axisPointer: {
                            type: &lt;/span&gt;'cross'&lt;span&gt;
                        },        
                    },
                    grid: {
                        y:&lt;/span&gt;25&lt;span&gt;,
                        left: &lt;/span&gt;'3%'&lt;span&gt;,
                        right: &lt;/span&gt;'4%'&lt;span&gt;,
                        height:&lt;/span&gt;&quot;64%&quot;&lt;span&gt;,
                        containLabel: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                    },
                    dataZoom : {
                        y:&lt;/span&gt;130&lt;span&gt;,
                        show : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,    &lt;span&gt;//
&lt;/span&gt;                        realtime: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        height:&lt;/span&gt;15&lt;span&gt;,
                        start : &lt;/span&gt;0&lt;span&gt;,
                        end : &lt;/span&gt;100&lt;span&gt;
                    },
            toolbox: {    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具栏显示             &lt;/span&gt;
                        show: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                         x:&lt;/span&gt;900&lt;span&gt;,
                        feature: { 
                            dataZoom : {
                                show : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;legendshow&lt;/span&gt;
&lt;span&gt;                                title : {
                                    dataZoom : &lt;/span&gt;'区域缩放'&lt;span&gt;,
                                    dataZoomReset : &lt;/span&gt;'区域缩放后退'&lt;span&gt;
                                }
                            },
                             restore : {
                                show : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
                                title : &lt;/span&gt;'还原'&lt;span&gt;
                            },           
                        }
                    },
                    xAxis: {
                        type: &lt;/span&gt;'category'&lt;span&gt;,
                        position:&lt;/span&gt;'bottom'&lt;span&gt;,
                        boundaryGap : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        axisTick: {onGap:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;},
                        splitLine: {show:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;},
                        data: t.F_X ,     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填入X轴数据&lt;/span&gt;
&lt;span&gt;                    },
                    color:colors,
                    legend: {    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图表上方的类别显示           &lt;/span&gt;
&lt;span&gt;                        show:legendshow,
                        data:sj
                    },
                    series: f_y, 
                    yAxis : [   
                        {
                             type : &lt;/span&gt;'value'&lt;span&gt;,
                             name : t.F_Z                 
                         }                
                    ]
                };   
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ecConfig = require('echarts/config'&lt;span&gt;)
                tempmyech.showLoading();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据加载完之前先显示一段简单的loading动画&lt;/span&gt;
                tempmyech.hideLoading();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏加载动画&lt;/span&gt;
&lt;span&gt;                tempmyech.resize();
                tempmyech.setOption(option);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;载入图表&lt;/span&gt;
                tempmyech.on(ecConfig.EVENT.CLICK, eConsole);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;网上经典方法&lt;/span&gt;
                tempmyech.on('click',  conck);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;精简版方法&lt;/span&gt;
&lt;span&gt;                mdataeahars.push(tempmyech);
          }
    )}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我想有眼睛亮的同学已经看到某些微妙的点了，例如 右键阻止和绑定方法，以及双击绑定方法，因为浏览自身有右键属性，所以这里先禁用，后添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
   tempmyech = ec.init($(&quot;.&quot;+jin_cid)[item]);  // 基于准备好的dom，初始化echarts实例 
    $($(&quot;.&quot;+jin_cid)[item]).contextmenu(
       function(e){
            e.preventDefault();
            chartcontextmenu()
       }
    );
      $($(&quot;.&quot;+jin_cid)[item]).bind(&quot;dblclick.a&quot;, chartDbck);  //双击方法，防止事件冲突
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后我们继续把联动的相关方法补进来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成静态控制图形&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt;  mainFactory(mdataeahars){
     require(
        [  &lt;/span&gt;'echarts'&lt;span&gt;,
                &lt;/span&gt;'echarts/chart/bar',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用柱状图就加载bar模块，按需加载&lt;/span&gt;
&lt;span&gt;                ],
     &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ec){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fmian='&amp;lt;div id=&quot;mainf&quot;&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;
        $(&lt;/span&gt;&quot;#startmian&quot;&lt;span&gt;).append(fmian); 
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sf=document.getElementById('mainf'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; main0_ec=&lt;span&gt;ec.init(sf); 
             main0_ec.setTheme(&lt;/span&gt;&quot;macarons&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  option=&lt;span&gt;{
                    grid: {
                        y:&lt;/span&gt;300&lt;span&gt;,
                        left: &lt;/span&gt;'3%'&lt;span&gt;,
                        right: &lt;/span&gt;'4%'&lt;span&gt;,
                        height:&lt;/span&gt;&quot;0%&quot;&lt;span&gt;,
                        containLabel: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                    },
                    dataZoom : {
                        y:&lt;/span&gt;2&lt;span&gt;,
                        show : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                        height:&lt;/span&gt;20&lt;span&gt;,
                        start : &lt;/span&gt;0&lt;span&gt;,
                        end : &lt;/span&gt;100&lt;span&gt;,
                        backgroundColor:&lt;/span&gt;&quot;#fff&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景色&lt;/span&gt;
                        dataBackground :&quot;#5285b3&quot;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据阴影的样式&lt;/span&gt;
                        fillerColor :&quot;#5285b3&quot;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选中范围的填充颜色。&lt;/span&gt;
&lt;span&gt;                    },     
                    xAxis : [
                        {
                            type : &lt;/span&gt;'category', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴为类目类型&lt;/span&gt;
                            data : ['',''&lt;span&gt;]
 
                    }],
                    yAxis : [
                        {
                            type : &lt;/span&gt;'value'  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴为值类型&lt;/span&gt;
&lt;span&gt;                        }
                    ],
                    series : [{  
                        name:&lt;/span&gt;'ctroller'&lt;span&gt;,
                        type:&lt;/span&gt;'line'&lt;span&gt;,
                        data:[&lt;/span&gt;'',''&lt;span&gt;]
                    }]
            };
                main0_ec.setOption(option);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;载入图表&lt;/span&gt;
&lt;span&gt;                mdataeahars.push(main0_ec);
     })
    }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有图表集合&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; linkFn(adata,adatalength){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; time2= setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mdataeahars.length==&lt;span&gt;adatalength){ 
        clearInterval(time2) ;
        mainFactory(mdataeahars);            
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  sokf; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接临时删除的数据&lt;/span&gt;
          $.each(mdataeahars,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i,t){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mdataeahars.length==adatalength+1&lt;span&gt;){
                sokf&lt;/span&gt;=mdataeahars[0&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  em=arydlt(mdataeahars[0&lt;span&gt;],mdataeahars);
                 mdataeahars.push(sokf);
                linkage(mdataeahars[mdataeahars.length&lt;/span&gt;-1&lt;span&gt;],em); 
            }                            
          }); 
         }
    },&lt;/span&gt;500&lt;span&gt;) 
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;联动数组&lt;/span&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  linkage(mit ,em){
    mit.connect(em);
 }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除元素&lt;/span&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  arydlt(item,arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dtemparr=arr||&lt;span&gt;[];
         dtemparr.remove(item);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  dtemparr;
 }
Array.prototype.remove&lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(val) {
 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.length; i++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;[i] ==&lt;span&gt; val) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.splice(i, 1&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
  } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你们会发现，怎么多了一个静态的echart图形，不要急，这是在多图联动基础上把 滚动条功能独立出来，用grid定位和压缩方式，让这个静态图变成一个滚动条控制所有图，部分人或许能用到这样的方式；给大家看看效果怎么吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1229612/201712/1229612-20171211230302618-358390962.png&quot; alt=&quot;&quot; width=&quot;1101&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，估计一部分人已经有点不耐烦了，叫嚣着”给本大人拿出点干货来“；哈哈，不罗嗦，我们继续下面的点击事件为核心进行讲解；&lt;/p&gt;
&lt;p&gt;首先我们先看看网上常用，两种经典点击事件案例说到一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常用单击曲线方法&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法一&lt;/span&gt;
   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; conck (param) {
      console.log(param);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  dataxtime=&lt;span&gt;  param.name;
      alert(dataxtime);
    }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法二&lt;/span&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; eConsole (param) {
      console.log(param);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  dataxtime=&lt;span&gt;  param.name;
      alert(dataxtime);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这两种，方法一是精简版的：只需要在上面使用&lt;strong&gt;&lt;span&gt;tempmyech.on('click',  conck);  //精简版方法。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;给一个回调就可以了。用法很简洁，我就称其精简版方法吧。第二种需要&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;var&lt;/span&gt; ecConfig = require('echarts/config'&lt;span&gt;);
   tempmyech.on(ecConfig.EVENT.CLICK, eConsole);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网上经典方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样申明回调才可以使用，这是最常见的2种，二者性质一样，但是有一个缺点：&lt;strong&gt;&lt;span&gt;都是需要点击折线图的亮点（其他图如柱状图，堆叠等不影响），所谓有亮点，就有隐藏点（亮点之间的点），因折线图大量数据时，上面两种方法就很无语了，因为获取不到隐藏点的数据；&lt;/span&gt;&lt;/strong&gt;需要不断放大才能变成亮点来获取。而右键点击在3.0以下版本是没有的，我的版本2.2.7，所以我在在上面那么搞，当然我也有改过echarts源码，给其添加一个右键方法，效果和上面一样，不太好用。所以我才有下面方案去解决这个问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
ar fmtresult=&quot;&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随时接收format数据中x轴来源&lt;/span&gt;
      dataxtimeArr=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标线的data数组&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;formatter 回掉函数&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Fmtresult(fmtres){
      fmtresult&lt;/span&gt;=&lt;span&gt;fmtres;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;双击echart地图&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt;  chartDbck(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataxtime=&lt;span&gt;fmtresult;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dataxtimeArr.length==0|(dataxtimeArr.length!=0 &amp;amp;&amp;amp;!&lt;span&gt;checkformat(dataxtime))){
            dataxtimeArr.push([
          {name: &lt;/span&gt;&quot;标线&quot;+dataxtime+'起点', xAxis: dataxtime,y: 35&lt;span&gt;},   
          {name: &lt;/span&gt;&quot;标线&quot;+dataxtime+'终点',xAxis: dataxtime, y: 450&lt;span&gt;}          
          ]);
       }
    $.each(dataGoz,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i,t){
         $.each(t.F_Y,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(m,n){
            n.markLine.data&lt;/span&gt;=&lt;span&gt;dataxtimeArr;
         });
    })  
    nstart(dataGoz);  
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测并删除已有标线&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkformat(dataxtime){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  fls=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = dataxtimeArr.length - 1; i &amp;gt;= 0; i--) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除已有的标线&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;(dataxtimeArr[i][0].xAxis==&lt;span&gt;dataxtime){
        dataxtimeArr.splice(i,&lt;/span&gt;1&lt;span&gt;); 
        fls&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
      }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  fls;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;echarts右击事件&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; chartcontextmenu(){
    checkformat(fmtresult);
   $.each(dataGoz,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i,t){
        $.each(t.F_Y,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(m,n){
            n.markLine.data&lt;/span&gt;=&lt;span&gt;dataxtimeArr;
         });
   })  
    nstart(dataGoz);  
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们讲解双击方法：双击功能如下：双击任意一个图上任一点，在鼠标处绘制出一条平行Y轴的标线。再次双击则删除标线；&lt;br/&gt;其中通过定义一个全局变量fmtresult接收tooltip 中&lt;strong&gt;&lt;span&gt;formatter&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的&lt;/span&gt;回调函数&lt;strong&gt;&lt;span&gt;Fmtresult（）的X轴值；这个&lt;strong&gt;formatter的回调函数中有我们想要的鼠标点击的数据。&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;部分人看到这样，估计已然豁然开朗了。双击事件中需要说明的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1229612/201712/1229612-20171211232813134-730006338.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个作用是：&lt;strong&gt;&lt;span&gt;1.当标线数据为空则双击添加，2.若不为空，且不重复，则添加；3.若重复则删除。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;若是有人问为什么这样格式去添加标线，其实添加多条标线方式不止种，网上有很多案例，常用定义起始点的2种是 ：1.xAxis和yAxis 数据定义范围；2:x,y位置定位；这里就不再多说了。右键点击功能就是删除标线；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 我们通过双击几条数据画标线和单击所打印的数据展示效果图看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1229612/201712/1229612-20171211233903837-1052307388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，本期就讲解到这里，属作者原创，如有转载，请表明出处：&lt;a title=&quot;echarts点击绘图&quot; href=&quot;http://www.cnblogs.com/mobeisanghai/p/8025448.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/mobeisanghai/p/8025448.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Dec 2017 15:44:00 +0000</pubDate>
<dc:creator>漠北桑海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mobeisanghai/p/8025448.html</dc:identifier>
</item>
<item>
<title>ViewPager使用记录3——循环展示 - ChardLau</title>
<link>http://www.cnblogs.com/developerdaily/p/8025592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/developerdaily/p/8025592.html</guid>
<description>&lt;p&gt;ViewPager是v4支持库中的一个控件，相信几乎所有接触Android开发的人都对它不陌生。之所以还要在这里翻旧账，是因为我在最近的项目中有多个需求用到了它，觉得自己对它的认识不够深刻。我计划从最简单的使用场景出发，记录我到目前为止所对ViewPager的使用情况以及有关它的一些知识点。&lt;/p&gt;
&lt;p&gt;这个系列的代码将存放在&lt;a href=&quot;https://github.com/chardlau/viewpager-usage&quot;&gt;Github仓库&lt;/a&gt;中，每篇文章对应一个分支或几个分支。&lt;/p&gt;
&lt;p&gt;这是第三篇文章，将讨论集中有关如何使用ViewPager展示无限循环视图的方法。&lt;/p&gt;

&lt;p&gt;这是最简单的实现方法。关键在于重写&lt;code&gt;PagerAdapter.getCount&lt;/code&gt;方法，将其返回值设置为&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，然后通通过取模&lt;code&gt;position%count&lt;/code&gt;的方式获取得对应的数据进行视图渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
...
@Override
public int getCount() {  
    return Integer.MAX_VALUE;
}

@Override
public Object instantiateItem(ViewGroup container, int position) {  
    int index = position % 3;
    String text = texts.get(index);
    TextView textView = new TextView(container.getContext());
    textView.setText(text);
    container.addView(textView);
    return textView;
}
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法毕竟不是真实的无限循环，只是虚拟了一个极大的页数，让用户翻页的时候很触及到“世界的尽头”。所以在初始化的时候需要完成一个关键初始化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
viewPager.setCurrentItem(Integer.MAX_VALUE / 2, false);  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把初始化页面定位到世界的中央。&lt;/p&gt;
&lt;p&gt;相关代码在&lt;a href=&quot;https://github.com/chardlau/viewpager-usage/tree/03-fake-infinite-cycle&quot;&gt;分支：03-fake-infinite-cycle&lt;/a&gt;可以获取。&lt;/p&gt;
&lt;h5 id=&quot;2&quot;&gt;方法2：在数据源首尾添加重复节点&lt;/h5&gt;
&lt;p&gt;这是实现&lt;code&gt;ViewPager&lt;/code&gt;无限循环的另一种方案：通过在数据源的首尾处添加重复的数据（在源数据前插入最后一个数据，其后插入原来的第一个数据），这两个重复数据的作用是在滚动过程中作为中间视图，当滚动停止时立刻切换到最终的视图，进入下一个滚动循环。&lt;/p&gt;
&lt;p&gt;相关代码见&lt;a href=&quot;https://github.com/chardlau/viewpager-usage/tree/03-infinite-cycle-with-additional-views&quot;&gt;分支：03-infinite-cycle-with-additional-views&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先在往PagerAdapter插入数据的时候对数据进行一下处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void setTexts(List&amp;lt;String&amp;gt; texts) {  
    this.texts.clear();
    if (texts == null) {
        notifyDataSetChanged();
        return;
    }

    // 只有一个数据时不循环
    if (texts.size() == 1) {
        this.texts.addAll(texts);

    // 多个数据，插入重复数据
    } else if (texts.size() &amp;gt; 1) {
        this.texts.add(texts.get(texts.size() - 1));
        this.texts.addAll(texts);
        this.texts.add(texts.get(0));
    }

    notifyDataSetChanged();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次让ViewPager实现&lt;code&gt;ViewPager.OnPageChangeListener&lt;/code&gt;接口，监听滚动状态。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override
public void onPageSelected(int position) {  
    int realCount = getCount() - 2;
    // 多于1，才会循环跳转
    if ( getCount() &amp;gt; 1) {
        // 首位之前，跳转到末尾（N）
        if ( position &amp;lt; 1) {
            position = realCount;
            viewPager.setCurrentItem(position,false);
        }
        // 末位之后，跳转到首位（1）
        else if ( position &amp;gt; realCount) {
            position = 1;
            viewPager.setCurrentItem(position,false);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后组装一下&lt;code&gt;ViewPager&lt;/code&gt;和&lt;code&gt;PagerAdapter&lt;/code&gt;即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
viewPager.setAdapter(adapter);  
viewPager.addOnPageChangeListener(adapter);  
if (adapter.getCount() &amp;gt; 1) {  
    viewPager.setCurrentItem(1, false);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意最后的&lt;code&gt;if&lt;/code&gt;语句，它让ViewPager默认显示第一页。否则页面将展示最后一个源数据的内容且无法向右滑动。&lt;/p&gt;
&lt;p&gt;实际上这种方法也是有缺陷的。当用户滑动&lt;code&gt;ViewPager&lt;/code&gt;到源数据的最后一个节点（下标：getCount()-2）并且先要继续滑动显示下一个节点时，这期间&lt;code&gt;ViewPager&lt;/code&gt;首先随用户手指一动正常展示我们插入的重复内容(下标：getCount()-1)，当滚动停止且触发了&lt;code&gt;onPageSelected&lt;/code&gt;回调，ViewPager立即切换到源数据的第一页（下标：1）进入下一个循环。这会导致几个不协调的现象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;切换到下一个循环的时候会破坏&lt;code&gt;ViewPager&lt;/code&gt;的滚动动画（如：滚动惯性动画）。&lt;/li&gt;
&lt;li&gt;切换前展示的缓存视图在切换时被销毁，切换后的视图需要重新生成。如果这里有需要延迟加载的内容也会导致展示不协调。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;32&quot;&gt;方法3：改进方法2&lt;/h5&gt;
&lt;p&gt;针对上述方法2提出的两个缺点，在此将着重解决缺点1出现的动画不连贯的现象，作为第三种方案进行介绍。至于缺点2可以通过缓存视图的方式解决，就不在此赘述。&lt;/p&gt;
&lt;p&gt;方法3的代码见&lt;a href=&quot;https://github.com/chardlau/viewpager-usage/tree/03-infinite-cycle-better-practise&quot;&gt;分支：03-infinite-cycle-better-practise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该方案已经满足我目前的需求。它的关键点如下：&lt;/p&gt;
&lt;p&gt;首先，如方法2一样在数据源头尾插入重复节点，用于过渡。这里我重新写了&lt;code&gt;setTexts&lt;/code&gt;方法，让只有一个数据的场景也可以循环：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void setTexts(List&amp;lt;String&amp;gt; texts) {  
    this.count = 0;
    this.texts.clear();
    if (texts != null &amp;amp;&amp;amp; texts.size() &amp;gt; 0) {
        this.count = texts.size();
        for (int i = 0; i &amp;lt;= count + 1; i++) {
            if (i == 0) {
                this.texts.add(texts.get(count - 1));
            } else if (i == count + 1) {
                this.texts.add(texts.get(0));
            } else {
                this.texts.add(texts.get(i - 1));
            }
        }
    }
    notifyDataSetChanged();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来解决方法2的动画不连贯的问题。注意到在方法2中在&lt;code&gt;OnPageChangeListener&lt;/code&gt;的&lt;code&gt;onPageSelected&lt;/code&gt;方法中处理了循环的跳转逻辑。然后&lt;code&gt;onPageSelected&lt;/code&gt;是&lt;code&gt;ViewPager&lt;/code&gt;处理&lt;code&gt;ACTION_UP&lt;/code&gt;事件时回调的。也就是说，当用户的手指时快速拖动后离开&lt;code&gt;ViewPager&lt;/code&gt;时，&lt;code&gt;ViewPager&lt;/code&gt;回调了该方法，然后还会继续后续的衰减动画。在这个时间点使用&lt;code&gt;setCurrentItem&lt;/code&gt;跳转到指定视图必然会造成动画停顿的问题。&lt;/p&gt;
&lt;p&gt;把切换循环改在&lt;code&gt;ViewPager&lt;/code&gt;的滚动状态发生变化时进行。怎么做呢？见代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// count为源数据的条目
// currentItem为PagerAdapter当前选中项
@Override
public void onPageSelected(int position) {  
    currentItem = position;
}
@Override
public void onPageScrollStateChanged(int state) {  
    switch (state) {
        case ViewPager.SCROLL_STATE_IDLE://No operation
            if (currentItem == 0) {
                viewPager.setCurrentItem(count, false);
            } else if (currentItem == count + 1) {
                viewPager.setCurrentItem(1, false);
            }
            break;
        case ViewPager.SCROLL_STATE_DRAGGING: //start Sliding
            if (currentItem == 0) {
                viewPager.setCurrentItem(count, false);
            } else if (currentItem == count + 1) {
                viewPager.setCurrentItem(1, false);
            }
            break;
        case ViewPager.SCROLL_STATE_SETTLING://end Sliding
            break;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中在状态变为停止“&lt;code&gt;SCROLL_STATE_IDLE&lt;/code&gt;”或状态变为开始滚动“&lt;code&gt;SCROLL_STATE_DRAGGING&lt;/code&gt;”时处理了循环切换的逻辑。&lt;/p&gt;
&lt;p&gt;这里描述一下整个流程。如果用户处于第一页且继续向右滑动手指，或者处于最后一页且继续向左滑动手指时，在状态由空闲变为开始滚动“&lt;code&gt;SCROLL_STATE_DRAGGING&lt;/code&gt;”进行切换。第一种情况，如果最终成功切换到目标页面，那么在状态变为空闲时由于&lt;code&gt;currentItem&lt;/code&gt;已经发生变化，所以不会重复切换。第二种情况，如果没有成功切换到目标页面，&lt;code&gt;ViewPager&lt;/code&gt;需要在状态变为“&lt;code&gt;SCROLL_STATE_IDLE&lt;/code&gt;”时再次切换回原来的视图。&lt;/p&gt;
&lt;p&gt;注意在初始化&lt;code&gt;ViewPager&lt;/code&gt;时调用一下&lt;code&gt;setCurrentItem(1)&lt;/code&gt;，让它正确显示第一个视图。&lt;/p&gt;
&lt;h5 id=&quot;&quot;&gt;小结&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;ViewPager&lt;/code&gt;循环展示数据的方法目前就介绍到这里。我认为方法1和方法3根据不同场景考虑是否使用。出于某种情结，我更倾向于使用方法3，毕竟方法三是查看了github中的banner库之后总结出来的。&lt;/p&gt;

&lt;p&gt;本文来自作者同步&lt;a href=&quot;http://www.chardlau.com/2017/12/11/infinite-cycle-display/&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;&lt;a href=&quot;http://www.chardlau.com/2017/10/24/display-dynamic-data/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Dec 2017 15:31:00 +0000</pubDate>
<dc:creator>ChardLau</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/developerdaily/p/8025592.html</dc:identifier>
</item>
<item>
<title>CSS书写规范与理论 - GuJinYu</title>
<link>http://www.cnblogs.com/jinyuGu/p/8025587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuGu/p/8025587.html</guid>
<description>[unable to retrieve full-text content]前端体系的变化可谓是日新月异，短短一年时间，从理论、框架、构建工具、甚至开发语言都发生非常大的变化。 随着新项目就即将启动，我抽时间回顾了一下以往项目的前端架构，零零散散产生了许多想法，尽量一一记录下来，为新的框架搭建做点准备。 首先来聊聊CSS的的各种规范与理论。回顾过去的代码，首先让我头痛不已的</description>
<pubDate>Mon, 11 Dec 2017 15:30:00 +0000</pubDate>
<dc:creator>GuJinYu</dc:creator>
<dc:identifier>http://www.cnblogs.com/jinyuGu/p/8025587.html</dc:identifier>
</item>
<item>
<title>FastDFS教程Ⅲ-文件服务器扩容 - 无涯Ⅱ</title>
<link>http://www.cnblogs.com/wlandwl/p/fastdfsAdd.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlandwl/p/fastdfsAdd.html</guid>
<description>&lt;h3 class=&quot;para&quot;&gt;1.简介&lt;/h3&gt;
&lt;p&gt;    FastDFS文件服务器在设计时，为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。FastDFS中的文件标识分为两个部分：卷名和文件名，二者缺一不可。&lt;/p&gt;
&lt;p&gt;   基于FastDFS文件服务器的特性，在做文件扩充容量时，可采取如下两种方案：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;扩充group的存储空间，配置多个存储文件目录地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩充存储节点，新加服务器配置多个storage。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;20.295863653772&quot;&gt;
&lt;div class=&quot;para&quot; readability=&quot;35.641516660283&quot;&gt;
&lt;h3&gt;2.storage文件存储原理介绍&lt;/h3&gt;
&lt;p&gt;  在处理文件服务器扩充容量的时候，首先需要了解文件服务器存储的关键机制和一些重要参数。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一般设置一个storage属于一个分组group,一个分组group对应的数据存储目录地址可一个或多个。（这一点保证了group的文件地址容量扩展）&lt;/li&gt;
&lt;li&gt;一个group的一个目录存储地址最多可存储的文件个数为：256*256*1000=65536000。storage文件存储机制中，有小文件合并存储到一个大文件的机制。&lt;/li&gt;
&lt;li&gt;一个storage可以配置多个tracker地址，同理一个tracker可以分配文件存储到多个storage上面。（这一点保证了服务器storage容量扩展）&lt;/li&gt;
&lt;li&gt;当一个storage中有多个文件目录地址时，通过tracker.conf中的关键参数&lt;strong&gt;store_path，&lt;/strong&gt;可以配置一个文件在存储时，多个对应存储目录地址的存储机制，如轮询或选择剩余空间大的文件目录。&lt;/li&gt;
&lt;li&gt;当一个tracker对应的存储storage具有多个时，通过tracker.conf中的&lt;strong&gt;store_lookup，store_server，&lt;/strong&gt;可以配置当文件上传时，对应多个storage服务器的存储机制，如轮询或选择空间大的服务器。&lt;/li&gt;
&lt;li&gt;storage文件服务器默认存储空间配置时，当达到文件目录空间的10%时，便不可以在存储文件，可通过tracker.conf中的&lt;strong&gt;reserved_storage_space&lt;/strong&gt;参数，修改默认值。&lt;/li&gt;
&lt;li&gt;多个storage可以属于一个组或多个组，当两个或多个storage属于一个组时，各个storage中的文件相互备份。这种机制的优点是保证了文件服务器的备份和负载均衡，缺点是两个storage的存储容量是两个中较小storage的存储容量。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;2.基于group模式的文件存储扩容&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;     group模式扩容是通过给group的机器添加硬盘的方式，实现某个group的扩容。fastdfs在一台服务器支持多个store_path，每个store_path指向一个存储路径。如：url “M00/3F/E1/oYYBAFXfyuOABOf5AAAHoDwhqE0491.txt”中M00表示使用store_path0，如果没有配置store_path，就使用base_path的路径。添加了硬盘后，通过把新的store_path指向新硬盘的挂载点，再修改配置文件，就能实现group的扩容。扩容后的地址如：url “M01/3F/E3/oYYBAFXfyuOABOf5AAAHoDwhqE0591.txt”中M01表示使用store_path1。group模式扩容主要步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.停止现有的tracker服务，storage服务，操作指令如：/etc/init.d/fdfs_trackerd stop ,/etc/init.d/fdfs_storaged stop ；&lt;/li&gt;
&lt;li&gt;2.修改/etc/fdfs/&lt;strong&gt;storage.conf&lt;/strong&gt;配置文件，修改字段store_path_count,新增store_path1文件存储路径，新建store_path1的文件目录；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;              &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211204547118-2032853231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 3.修改/etc/fdfs/storage.conf/&lt;strong&gt;mod_fastdfs.conf&lt;/strong&gt;配置文件，修改字段store_path_count,新增store_path1文件存储路径，设置group1的配置信息；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;           &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211205350727-1855607908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4.修改/application/nginx/conf/nginx.conf配置文件，增加store_path1的访问代理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211220435712-2033620118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;5.重新启动tracker,storage,nginx服务，通过命令&lt;strong&gt; /usr/bin/fdfs_monitor /etc/fdfs/storage.conf&lt;/strong&gt;（ /usr/bin/fdfs_monitor为f调用astdfs的命令，根据安装目录而定）可查看文件服务器的运行状态和配置信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211221120212-1298012130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;结果展示&lt;/strong&gt;：调用文件clent.conf配置文件，通过文件上传命令上传文件，查看文件的存储地址信息如下：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211221621665-1401582851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.基于storage模式的文件存储扩容&lt;/h3&gt;
&lt;p&gt;   storage扩容主要是通过新增服务器的模式，在一台电脑上安装多个storage的模式不推荐。新增一台服务器的目的是为了扩容，便不能让新加的storage与原来存在的storage属于同一个组，设置为同一个组并不能扩容，只是备份的效果。已有文件系统信息为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   单节点文件服务器：&lt;/strong&gt;ip:10.63.0.155  部署tracer,storage,nginx服务；&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;扩容信息为：&lt;/strong&gt;在服务器10.63.0.154上面新建storage存储文件。具体操作步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;   1.在新的服务器上，安装单节点文件服务器，具体安装教程参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/wlandwl/p/fastdfs.html&quot;&gt;FastDFS教程Ⅰ-文件服务器安装与Nginx配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;   2.安装好文件服务器，nginx等相关软件后，设置配置文件storage.conf的tracker地址为10.63.0.155上面的tracker地址；&lt;/li&gt;
&lt;li&gt;   3.配置storage.conf，mod_fastdfs.conf文件中的group名字，如已经存在的storage属于group2,新加的设置为group1;&lt;/li&gt;
&lt;li&gt;   4.修改已经存在的tracker服务器配置信息，修改文件有mod_fastdfs.conf，nginx.conf,storage_ids.conf文件；&lt;/li&gt;
&lt;li&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211224944821-2008845785.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;5.重新启动tracker,storage,nginx服务，通过命令&lt;strong&gt; /usr/bin/fdfs_monitor /etc/fdfs/storage.conf&lt;/strong&gt;（ /usr/bin/fdfs_monitor为f调用astdfs的命令，根据安装目录而定）可查看文件服务器的运行状态和配置信息。  &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211230510837-1038045801.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; 结果展示&lt;/strong&gt;：调用文件clent.conf配置文件，通过文件上传命令上传文件，查看文件的存储地址信息如下：&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171211231609446-2039606722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.fastDFS文件系统扩容方案总结&lt;/h3&gt;
&lt;p&gt;    通过上述两种方式均可以达到文件扩容的目的，对于在服务器上面添加硬盘的模式，建议采用方案1，直接在group新加文件存储地址；在具有新的服务器时，可采用方案2处理。在服务器和硬盘信息都有的情况下，可同时采用这两种模式扩充容量。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 11 Dec 2017 15:26:00 +0000</pubDate>
<dc:creator>无涯Ⅱ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wlandwl/p/fastdfsAdd.html</dc:identifier>
</item>
</channel>
</rss>