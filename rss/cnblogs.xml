<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HBuilder的快捷操作 - 凹凸霞</title>
<link>http://www.cnblogs.com/aotuboke/p/10026753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aotuboke/p/10026753.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.通过&lt;span&gt;！&lt;/span&gt;感叹号&lt;span&gt;单击tab&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;zh&quot;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;&lt;br/&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;&lt;br/&gt;&amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.通过&lt;span&gt;meta:utf&lt;/span&gt;单击&lt;span&gt;tab&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;通过&lt;span&gt;&lt;strong&gt;&lt;strong&gt;meta:ut&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;单击&lt;span&gt;tab&lt;/span&gt; 就可以快速生成：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;strong&gt;通过&lt;span&gt;&lt;strong&gt;&lt;strong&gt;meta:compat&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;单击&lt;span&gt;tab&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&amp;gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;通过&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;p.info&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;单击&lt;span&gt;tab&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&amp;lt;p class=&quot;info&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;6.&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;通过&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;p#info&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;单击&lt;span&gt;tab&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;lt;p id=&quot;info&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;6.&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;通过&lt;span&gt;a:link&lt;/span&gt;单击&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;tab&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&quot;http://&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;6.&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;通过&lt;span&gt;a:mail&lt;/span&gt;单击&lt;span&gt;tab&lt;/span&gt; 就可以快速生成：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&quot;mailto:&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;通过&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;h2.header+p.info&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;单击&lt;span&gt;tab &lt;/span&gt;就可以快速生成：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;h2 class=&quot;header&quot;&amp;gt;&amp;lt;/h2&amp;gt;&lt;br/&gt;&amp;lt;p class=&quot;info&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!--ul&amp;gt;li--&amp;gt;&lt;br/&gt;&amp;lt;ul&amp;gt;&lt;br/&gt;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;br/&gt;&amp;lt;/ul&amp;gt;&lt;br/&gt;&amp;lt;!--上一级标签 h2&amp;gt;span^p--&amp;gt;&lt;br/&gt;&amp;lt;h2&amp;gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/h2&amp;gt;&lt;br/&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;!--a{点我啊}--&amp;gt;&lt;br/&gt;&amp;lt;a href=&quot;&quot;&amp;gt;点我啊&amp;lt;/a&amp;gt;&lt;br/&gt;&amp;lt;!--p[title=&quot;title&quot;]--&amp;gt;&lt;br/&gt;&amp;lt;p title=&quot;title&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;!--a[href=&quot;www.baidu.com&quot;]{百度}--&amp;gt;&lt;br/&gt;&amp;lt;a href=&quot;www.baidu.com&quot;&amp;gt;百度&amp;lt;/a&amp;gt;&lt;br/&gt;&amp;lt;!--ul.list&amp;gt;li.item*8&amp;gt;a{导航}--&amp;gt;&lt;br/&gt;&amp;lt;!--ul.list&amp;gt;li.item*8&amp;gt;a{导航$$$@50} 从五十开始 序号--&amp;gt;&lt;br/&gt;&amp;lt;!--ul.list&amp;gt;li.item*8&amp;gt;a{导航$$@-}倒序 8 7 6 5 --&amp;gt;&lt;br/&gt;&amp;lt;!--ul.list&amp;gt;li.item*8&amp;gt;a{导航$$}1 2 3--&amp;gt;&lt;br/&gt;&amp;lt;!--ul.list&amp;gt;li.item*8&amp;gt;a{导航$$}01 02 03--&amp;gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 07:44:00 +0000</pubDate>
<dc:creator>凹凸霞</dc:creator>
<og:description>1.通过！感叹号单击tab 就可以快速生成： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta ch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aotuboke/p/10026753.html</dc:identifier>
</item>
<item>
<title>Vue一个案例引发「动画」的使用总结 - Modenng</title>
<link>http://www.cnblogs.com/beevesnoodles/p/10026738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beevesnoodles/p/10026738.html</guid>
<description>&lt;p&gt;项目开发中动画有着很重要的作用，而且也是用到的地方非常多，例如：鼠标的进入离开，弹窗效果，组件的显示隐藏，列表的切换等等，可以说我们网页上的动画无处不在，也有人说了，这些东西也可以不使用动画。&lt;/p&gt;
&lt;p&gt;对，你说的没错可以不使用，但是，首先你要说服你的产品经理咱能不能简单点，不搞这么多虚的来点实际的，说完之后我估计你们俩得立马干起来，其次，在你的网页上不使用动画不够逼格啊，而且咱们的网页也不够生动，没有活力，由此可见动画的不可或缺性。&lt;/p&gt;
&lt;p&gt;上面只是开个玩笑，下面咱们进入主题，看看 Vue 中如何更好更简单的添加动画。&lt;/p&gt;
&lt;p&gt;首先，Vue 在插入，修改或者移除 DOM 时，提供了多种不同的添加动画的方法，在 Vue 中我们使用 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 组件时，Vue 会给我们提供一些内置的 CSS 类与 JS 钩子函数。&lt;/p&gt;
&lt;p&gt;先来看看我们要实现一个什么样子的案例效果&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog-1257601889.cos.ap-shanghai.myqcloud.com/vue/animate/animate-list.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的例子是一个非常常见的图片切换效果，不过在这个例子中我们只是单纯的实现图片的切换，看起来非常的生硬，没有任何的过渡效果，下面我们来给图片加一点动画的效果，让它看起来非常的有逼格。&lt;/p&gt;
&lt;h5 id=&quot;hcss&quot;&gt;CSS 过渡&lt;/h5&gt;
&lt;p&gt;被 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 包裹的组件，在组件的不同阶段会产生不同的 class 类名进行切换&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v-enter/v-leave：动画的第一帧&lt;/li&gt;
&lt;li&gt;v-enter-acive/v-leave-active：动画运行的阶段，一些过渡属性会放置在这里，如：时间，延迟等&lt;/li&gt;
&lt;li&gt;v-enter-to/v-leave-to：动画结束，最后一帧&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官网上的一张图片非常友好的展示了这个切换的过程。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://cn.vuejs.org/images/transition.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v-&lt;/code&gt; 是 Vue 中默认的类名前缀，我们在使用的过程中如果一直使用默认的命名方式的话，必然会导致一些冲突，所以 Vue 给我们提供了一个自定义命名的方案，我们只需要给 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 添加一个 name 属性即可。&lt;/p&gt;
&lt;p&gt;既然我们知道了方法，我们就来给它加一个简单的动画。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;template&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ul &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tabs-list&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;li &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;v-for=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tab in tabs&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;:key=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tab.id&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;:class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{active: tabOn === tab.id}&quot; &lt;br/&gt;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;a&lt;br/&gt;@&lt;span class=&quot;hljs-attr&quot;&gt;mouseover=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tabOn = tab.id&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tab.url&quot; &lt;span class=&quot;hljs-attr&quot;&gt;target=&lt;span class=&quot;hljs-string&quot;&gt;&quot;_blank&quot;&lt;br/&gt;&amp;gt;&lt;br/&gt;{{tab.name}}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;transition &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;flip&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-show=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tabOn === tab.id&quot; &lt;span class=&quot;hljs-attr&quot;&gt;:src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tab.imgUrl&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;transition&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;a&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;li&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ul&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;template&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;style &lt;span class=&quot;hljs-attr&quot;&gt;lang=&lt;span class=&quot;hljs-string&quot;&gt;&quot;scss&quot; &lt;span class=&quot;hljs-attr&quot;&gt;scoped&amp;gt;&lt;span class=&quot;css&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flip-enter-active {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transition: transform &lt;span class=&quot;hljs-number&quot;&gt;1s;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flip-leave-active {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transition: transform &lt;span class=&quot;hljs-number&quot;&gt;1s;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flip-enter,&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flip-leave-to {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transform: &lt;span class=&quot;hljs-built_in&quot;&gt;scaleY(0);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;style&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog-1257601889.cos.ap-shanghai.myqcloud.com/vue/animate/animate-list-transition.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;hcss-1&quot;&gt;CSS 动画&lt;/h5&gt;
&lt;p&gt;与上面 CSS 过渡不同的是，我们这里说的 CSS 动画是利用 @keyframes 来创建与上面类似的动画效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;style &lt;span class=&quot;hljs-attr&quot;&gt;lang=&lt;span class=&quot;hljs-string&quot;&gt;&quot;scss&quot; &lt;span class=&quot;hljs-attr&quot;&gt;scoped&amp;gt;&lt;span class=&quot;css&quot;&gt;&lt;br/&gt;@&lt;span class=&quot;hljs-keyword&quot;&gt;keyframes scaleY-in {&lt;br/&gt;0% {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transform: &lt;span class=&quot;hljs-built_in&quot;&gt;scaleY(0);&lt;br/&gt;}&lt;br/&gt;50% {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transform: &lt;span class=&quot;hljs-built_in&quot;&gt;scaleY(0.5);&lt;br/&gt;}&lt;br/&gt;100% {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transform: &lt;span class=&quot;hljs-built_in&quot;&gt;scaleY(1);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flip-enter-active {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot; readability=&quot;1&quot;&gt;animation: scaleY-in &lt;span class=&quot;hljs-number&quot; readability=&quot;2&quot;&gt;1s;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.flip-leave-active {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;animation: scaleY-in &lt;span class=&quot;hljs-number&quot;&gt;1s reverse;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;style&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;h&quot;&gt;使用第三方动画库&lt;/h5&gt;
&lt;p&gt;Vue 中给我们提供了自定义 CSS 类名的方法，非常好的支持了与第三方动画库的结合。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;enter-class / leave-class&lt;/li&gt;
&lt;li&gt;enter-active-class / leave-active-class&lt;/li&gt;
&lt;li&gt;enter-to-class / leave-to-class&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面两个动画都是我们自己动手写出来的，但是有些时候我们自己手写的并不是那么完美，或者项目的时间比较紧张，这个时候选择第三方库就是一个比较好的方案。我们继续利用 Animate.css 动画库修改我们上面的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&amp;lt;transition &lt;br/&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;flip&quot;&lt;br/&gt;enter-active-&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;animated rotateIn&quot;&lt;br/&gt;leave-active-&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;animated rotateOut&quot;&lt;br/&gt;&amp;gt;&lt;br/&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-show=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tabOn === tab.id&quot; &lt;span class=&quot;hljs-attr&quot;&gt;:src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tab.imgUrl&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;transition&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog-1257601889.cos.ap-shanghai.myqcloud.com/vue/animate/animate-list-animate.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;hjavascript&quot;&gt;JavaScript 动画&lt;/h5&gt;
&lt;p&gt;Vue 中还给我们提供了一些钩子函数，我们可以使用 JavaScript 钩子函数构建动画。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&amp;lt;transition&lt;br/&gt;@before-enter=&lt;span class=&quot;hljs-string&quot;&gt;&quot;beforeEnter&quot;&lt;br/&gt;@enter=&lt;span class=&quot;hljs-string&quot;&gt;&quot;enter&quot;&lt;br/&gt;@after-enter=&lt;span class=&quot;hljs-string&quot; readability=&quot;1.5&quot;&gt;&quot;afterEnter&quot;&lt;br/&gt;@enter-cancelled=&lt;span class=&quot;hljs-string&quot; readability=&quot;3&quot;&gt;&quot;enterCancelled&quot;&lt;p&gt;@before-leave=&lt;span class=&quot;hljs-string&quot;&gt;&quot;beforeLeave&quot;&lt;br/&gt;@leave=&lt;span class=&quot;hljs-string&quot;&gt;&quot;leave&quot;&lt;br/&gt;@after-leave=&lt;span class=&quot;hljs-string&quot;&gt;&quot;afterLeave&quot;&lt;br/&gt;@leave-cancelled=&lt;span class=&quot;hljs-string&quot;&gt;&quot;leaveCancelled&quot;&lt;br/&gt;:css=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;lt;/transition&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有钩子都会传入一个 el（元素）参数，enter/leave 函数还会传入一个 done 函数作为参数。它会告知我们的动画完成，我们绑定了 css 为 false，告诉组件跳过 CSS 的检测，使用 JavaScript。&lt;/p&gt;
&lt;p&gt;我们结合 Velocity.js 动画，来修改完成我们的动画效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;transition &lt;br/&gt;@&lt;span class=&quot;hljs-attr&quot;&gt;enter=&lt;span class=&quot;hljs-string&quot;&gt;&quot;enter&quot;&lt;br/&gt;@&lt;span class=&quot;hljs-attr&quot;&gt;leave=&lt;span class=&quot;hljs-string&quot;&gt;&quot;leave&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;:css=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;br/&gt;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-show=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tabOn === tab.id&quot; &lt;span class=&quot;hljs-attr&quot;&gt;:src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tab.imgUrl&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;transition&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&amp;gt;&lt;span class=&quot;javascript&quot;&gt;&lt;br/&gt;methods: {&lt;br/&gt;enter(el, done) {&lt;br/&gt;Velocity(el, { &lt;span class=&quot;hljs-attr&quot;&gt;scaleY: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0&quot; });&lt;br/&gt;Velocity(el, { &lt;span class=&quot;hljs-attr&quot;&gt;scaleY: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0.5&quot; }, { &lt;span class=&quot;hljs-attr&quot;&gt;duration: &lt;span class=&quot;hljs-number&quot;&gt;1000 });&lt;br/&gt;Velocity(el, { &lt;span class=&quot;hljs-attr&quot;&gt;scaleY: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot; }, { &lt;span class=&quot;hljs-attr&quot;&gt;complete: done });&lt;br/&gt;},&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;leave: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function(&lt;span class=&quot;hljs-params&quot;&gt;el, done) {&lt;br/&gt;Velocity(el, { &lt;span class=&quot;hljs-attr&quot;&gt;scaleY: &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot; });&lt;br/&gt;Velocity(el, { &lt;span class=&quot;hljs-attr&quot;&gt;scaleY: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0.5&quot; }, { &lt;span class=&quot;hljs-attr&quot;&gt;duration: &lt;span class=&quot;hljs-number&quot;&gt;1000 });&lt;br/&gt;Velocity(el, { &lt;span class=&quot;hljs-attr&quot;&gt;scaleY: &lt;span class=&quot;hljs-string&quot;&gt;&quot;0&quot; }, { &lt;span class=&quot;hljs-attr&quot;&gt;complete: done });&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;h-1&quot;&gt;过渡模式&lt;/h5&gt;
&lt;p&gt;我们再来回头看看上面的例子，不管我们使用何种方式实现的动画，你会发现一个问题就是，动画在切换的时候两者（进入/离开）是同时进行的，有些时候，我们并不希望产生这种效果，对我们的动画效果非常的不友好，比如我们看看下面的这个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;template&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;div &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;translate-container&quot; @&lt;span class=&quot;hljs-attr&quot;&gt;click=&lt;span class=&quot;hljs-string&quot;&gt;&quot;clickHandler&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;transition &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;slide&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-if=&lt;span class=&quot;hljs-string&quot;&gt;&quot;isShow&quot; &lt;span class=&quot;hljs-attr&quot;&gt;src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;./feature/03.jpg&quot; &lt;span class=&quot;hljs-attr&quot;&gt;key=&lt;span class=&quot;hljs-string&quot;&gt;&quot;first&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-else &lt;span class=&quot;hljs-attr&quot;&gt;src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;./feature/04.jpg&quot; &lt;span class=&quot;hljs-attr&quot;&gt;key=&lt;span class=&quot;hljs-string&quot;&gt;&quot;second&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;transition&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;div&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;template&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;script&amp;gt;&lt;span class=&quot;javascript&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;export &lt;span class=&quot;hljs-keyword&quot;&gt;default {&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;methods: {&lt;br/&gt;clickHandler() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.isShow = !&lt;span class=&quot;hljs-keyword&quot;&gt;this.isShow;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;script&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;style &lt;span class=&quot;hljs-attr&quot;&gt;lang=&lt;span class=&quot;hljs-string&quot;&gt;&quot;scss&quot; &lt;span class=&quot;hljs-attr&quot;&gt;scoped&amp;gt;&lt;span class=&quot;css&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.slide-enter-active,&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.slide-leave-active {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transition: all &lt;span class=&quot;hljs-number&quot;&gt;0.5s;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.slide-leave-to,&lt;br/&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.slide-enter {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;transform: &lt;span class=&quot;hljs-built_in&quot;&gt;scaleY(0);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;style&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog-1257601889.cos.ap-shanghai.myqcloud.com/vue/animate/animate-list-mode.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然，这种是非常不好的效果，值得高兴的是 Vue 中给我们提供了一个解决方案-- &lt;strong&gt;过渡模式&lt;/strong&gt;，我们不需要增加额外的代码，只需要修改下特性即可。&lt;/p&gt;
&lt;p&gt;Vue 给我们提供了两种过渡模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;in-out：新元素先进行过渡，完成之后当前元素过渡离开。&lt;/li&gt;
&lt;li&gt;out-in：当前元素先进行过渡，完成之后新元素过渡进入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;过渡模式只会在相互切换的元素中才会生效&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;transition &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;fade&quot; &lt;span class=&quot;hljs-attr&quot;&gt;mode=&lt;span class=&quot;hljs-string&quot;&gt;&quot;out-in&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot; readability=&quot;1&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot; readability=&quot;2&quot;&gt;transition&amp;gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;transition &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;fade&quot; &lt;span class=&quot;hljs-attr&quot;&gt;mode=&lt;span class=&quot;hljs-string&quot;&gt;&quot;in-out&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;transition&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们就用过渡模式修改我们上面的案例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;transition &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;slide&quot; &lt;span class=&quot;hljs-attr&quot;&gt;mode=&lt;span class=&quot;hljs-string&quot;&gt;&quot;out-in&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-if=&lt;span class=&quot;hljs-string&quot;&gt;&quot;isShow&quot; &lt;span class=&quot;hljs-attr&quot;&gt;src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;./feature/03.jpg&quot; &lt;span class=&quot;hljs-attr&quot;&gt;key=&lt;span class=&quot;hljs-string&quot;&gt;&quot;first&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img &lt;span class=&quot;hljs-attr&quot;&gt;v-else &lt;span class=&quot;hljs-attr&quot;&gt;src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;./feature/04.jpg&quot; &lt;span class=&quot;hljs-attr&quot;&gt;key=&lt;span class=&quot;hljs-string&quot;&gt;&quot;second&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;transition&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://blog-1257601889.cos.ap-shanghai.myqcloud.com/vue/animate/animate-list-mode-set.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;h-2&quot;&gt;总结&lt;/h5&gt;
&lt;p&gt;Vue 给我们提供了比较直观灵活的 API，方便我们在项目中添加动画的效果。&lt;/p&gt;
&lt;p&gt;Vue 中除了这些单元素的动画以外还提供了&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 给我的列表（使用v-for 时的场景）添加动画，喜欢动画的小伙伴可以动手去尝试绘制一些自己喜欢的动画。&lt;/p&gt;
&lt;p&gt;文中如有不足之处，欢迎留言指正，如果本文对你有帮助，欢迎转发点赞。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 07:42:00 +0000</pubDate>
<dc:creator>Modenng</dc:creator>
<og:description>项目开发中动画有着很重要的作用，而且也是用到的地方非常多，例如：鼠标的进入离开，弹窗效果，组件的显示隐藏，列表的切换等等，可以说我们网页上的动画无处不在，也有人说了，这些东西也可以不使用动画。 对，你</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/beevesnoodles/p/10026738.html</dc:identifier>
</item>
<item>
<title>记录：TensorFlow 中的 padding 方式 - 买白菜不用券</title>
<link>http://www.cnblogs.com/mbcbyq-2137/p/10026708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mbcbyq-2137/p/10026708.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

input_7 &lt;/span&gt;= tf.constant([[1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7&lt;span&gt;],
                                 [&lt;/span&gt;2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7&lt;span&gt;],
                                 [&lt;/span&gt;3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7&lt;span&gt;],
                                 [&lt;/span&gt;4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7&lt;span&gt;],
                                 [&lt;/span&gt;5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7&lt;span&gt;],
                                 [&lt;/span&gt;6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7&lt;span&gt;],
                                 [&lt;/span&gt;7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7&lt;span&gt;]])  

input_7 &lt;/span&gt;= tf.reshape(input_7, [1, 7, 7, 1&lt;span&gt;])
filter &lt;/span&gt;=   tf.constant(np.ones([4, 4, 1, 1]), dtype=&lt;span&gt;tf.float32)
stride &lt;/span&gt;= [1, 3, 3, 1&lt;span&gt;]
conv_output &lt;/span&gt;= tf.nn.conv2d(input_7, filter=filter, strides=stride, padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

with tf.Session() as sess:
    output &lt;/span&gt;=&lt;span&gt; sess.run(conv_output)
    shape &lt;/span&gt;= output.shape[1], output.shape[2&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(output.reshape(shape))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本测试中，W=7, s=3, w=4&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 27 Nov 2018 07:38:00 +0000</pubDate>
<dc:creator>买白菜不用券</dc:creator>
<og:description>TensorFlow 中卷积操作和池化操作中都有一个参数 padding，其可选值有 ['VALID', 'SAME']。 在 TensorFlow 文档中只是给出了输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mbcbyq-2137/p/10026708.html</dc:identifier>
</item>
<item>
<title>记一次服务器被植入挖矿脚本的解决过程 - 21Java</title>
<link>http://www.cnblogs.com/peterpoker/p/10026697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peterpoker/p/10026697.html</guid>
<description>&lt;h3 id=&quot;删除挖矿脚本和对应的进程&quot;&gt;删除挖矿脚本和对应的进程&lt;/h3&gt;
&lt;p&gt;找出并删除对应挖矿脚本文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543223663997.png&quot; alt=&quot;1543223663997&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找出进程pid，并且kill掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543223719352.png&quot; alt=&quot;1543223719352&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无法kill掉的是原进程的守护进程，原进程不在它也会自动关闭，所以不用管它&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543223830109.png&quot; alt=&quot;1543223830109&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kill掉后cpu恢复正常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543223913146.png&quot; alt=&quot;1543223913146&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;需要检查是否有定时任务&quot;&gt;需要检查是否有定时任务&lt;/h3&gt;
&lt;p&gt;防止挖矿脚本重新下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543224143669.png&quot; alt=&quot;1543224143669&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里没有，如果有可以使用以下命令删除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crontab -r&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;检查docker是否也有挖矿的容器在运行&quot;&gt;检查docker是否也有挖矿的容器在运行&lt;/h3&gt;
&lt;h5 id=&quot;检查创建的docker容器&quot;&gt;检查创建的docker容器&lt;/h5&gt;
&lt;p&gt;我这里发现了很多不是我自己创建的容器，截图的都不是我自己的，需要全部删除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543224665856.png&quot; alt=&quot;1543224665856&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用以下命令删除全部不运行的容器（因为目前正在运行的只有我自己的容器，故不用担心自己的容器也被删掉）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543225988507.png&quot; alt=&quot;1543225988507&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;检查docker镜像&quot;&gt;检查docker镜像。&lt;/h5&gt;
&lt;p&gt;发现两个镜像是别人下载的，删除掉这两个镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543224799656.png&quot; alt=&quot;1543224799656&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;用非root用户重启docker服务&quot;&gt;用非root用户重启docker服务&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543254907900.png&quot; alt=&quot;1543254907900&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;修复redis漏洞&quot;&gt;修复redis漏洞&lt;/h3&gt;
&lt;h5 id=&quot;修改-redis.conf-文件&quot;&gt;修改 redis.conf 文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543229880990.png&quot; alt=&quot;1543229880990&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主要改端口和绑定访问ip，还有设置日志文件及其级别（用于查看访问的ip），设置访问密码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;bind x.x.x.x 
port 56331
logfile &quot;56331.log&quot;
loglevel verbose
requirepass xxx &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;bind 允许访问的ip&lt;/p&gt;
&lt;p&gt;requirepass 验证登录的密码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;禁用远程修改 DB 文件地址，禁用lua脚本命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;rename-command FLUSHALL &quot;&quot;
rename-command CONFIG &quot;&quot;
rename-command EVAL &quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;Redis Config Set 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。&lt;/p&gt;
&lt;p&gt;Redis Eval 命令使用 Lua 解释器执行脚本。&lt;/p&gt;
&lt;h5 id=&quot;切换非root用户不使用root用户启动redis&quot;&gt;切换非root用户，不使用root用户启动redis&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;su hzk&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;保证root用户-authorized_keys-文件的安全&quot;&gt;保证root用户 authorized_keys 文件的安全&lt;/h3&gt;
&lt;h5 id=&quot;查看root用户ssh免密登录保存的公钥是否已经添加了别人的公钥&quot;&gt;查看root用户ssh免密登录保存的公钥是否已经添加了别人的公钥。&lt;/h5&gt;
&lt;p&gt;如果里面存放了别人的公钥，那它就可以直接ssh登录我们的系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543224483309.png&quot; alt=&quot;1543224483309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现果然有别人的公钥，需要把它们都删除掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543224533329.png&quot; alt=&quot;1543224533329&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;为了保证安全您应该阻止其他用户添加新的公钥&quot;&gt;为了保证安全，您应该阻止其他用户添加新的公钥。&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;chmod 400 ~/.ssh/authorized_keys&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;chattr +i ~/.ssh/authorized_keys&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然而，用户还可以重命名 ~/.ssh，然后新建新的 ~/.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 权限：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;chattr +i ~/.ssh&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改后的文件可以lsattr查看属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@study ~]# lsattr [-adR] 檔案或目錄
選項與參數：
-a ：將隱藏檔的屬性也秀出來；
-d ：如果接的是目錄，僅列出目錄本身的屬性而非目錄內的檔名；
-R ：連同子目錄的資料也一併列出來！&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置防火墙策略&quot;&gt;设置防火墙策略　　&lt;/h3&gt;
&lt;p&gt;如果正常业务中Redis服务需要被其他服务器来访问，可以通过redis日志找出对方ip，然后通过设置iptables或者firewalld策略把该ip禁止访问。&lt;/p&gt;
&lt;h3 id=&quot;修改ssh默认端口&quot;&gt;修改ssh默认端口&lt;/h3&gt;
&lt;h5 id=&quot;检查sshd_config文件&quot;&gt;检查sshd_config文件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543248134440.png&quot; alt=&quot;1543248134440&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现sshd_config文件被修改，添加了多个ssh访问的端口，把它们删除掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543248764938.png&quot; alt=&quot;1543248764938&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;修改ssh访问端口&quot;&gt;修改ssh访问端口&lt;/h5&gt;
&lt;p&gt;将Port改为50000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543248179221.png&quot; alt=&quot;1543248179221&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;重启ssh服务&quot;&gt;重启ssh服务&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;systemctl restart sshd.service&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;检查家目录是否有别人新创的用户&quot;&gt;检查家目录是否有别人新创的用户&lt;/h3&gt;
&lt;p&gt;除红色外均不是我创建的用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543249802799.png&quot; alt=&quot;1543249802799&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问其中一个别人创建的用户家目录（frank），发现其.ssh目录下的authorized_keys已保存了对方的公钥，即对方可通过frank用户进行免密码登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543251851772.png&quot; alt=&quot;1543251851772&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除该用户frank数据和家目录&quot;&gt;删除该用户（frank）数据和家目录&lt;/h5&gt;
&lt;p&gt;而用户的数据有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户账号/密码相关参数：/etc/passwd, /etc/shadow&lt;/li&gt;
&lt;li&gt;使用者群组相关参数：/etc/group, /etc/gshadow&lt;/li&gt;
&lt;li&gt;用户个人文件数据： /home/username, /var/spool/mail/usernam&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用如下命令即可删除上述所有。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@study ~]#  userdel -r frank
选项与参数：
-r ：连同用户的家目录也一起删除&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改系统所有用户的密码包括root&quot;&gt;修改系统所有用户的密码（包括root）&lt;/h3&gt;
&lt;p&gt;建议不用root直接修改，因为root会忽略密码安全校验。&lt;/p&gt;
&lt;h5 id=&quot;切换用户直接用passwd命令即可修改当前用户的密码&quot;&gt;切换用户，直接用passwd命令即可修改当前用户的密码。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://repo-1253355096.cos.ap-guangzhou.myqcloud.com/1543251064708.png&quot; alt=&quot;1543251064708&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://www.freebuf.com/column/158065.html【Redis未授权访问详解】&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/huyuyang6688/article/details/78994909【记一次服务器被挖矿木马攻击的经历】&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 07:36:00 +0000</pubDate>
<dc:creator>21Java</dc:creator>
<og:description>记一次服务器被植入挖矿脚本的解决过程 删除挖矿脚本和对应的进程 找出并删除对应挖矿脚本文件 找出进程pid，并且kill掉 无法kill掉的是原进程的守护进程，原进程不在它也会自动关闭，所以不用管它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peterpoker/p/10026697.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 轻松学-项目目录和文件作用介绍 - Ron.liang</title>
<link>http://www.cnblogs.com/viter/p/10026517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/10026517.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;    上一章介绍了 Asp.Net Core 的前世今生，并创建了一个控制台项目编译并运行成功，本章的内容介绍 .NETCore 的各种常用命令、Asp.Net Core MVC 项目文件目录等信息，通过对命令的学习和操作，对项目结构的认识，进一步理解 Asp.Net Core 的运行机制和项目框架。&lt;/p&gt;
&lt;h3 id=&quot;创建项目的命令&quot;&gt;创建项目的命令&lt;/h3&gt;
&lt;p&gt;    首先来认识一下创建项目可使用的各种命令，.NETCore 的命令都以 dotnet 打头，这很好理解，输入 dotnet xxx，就是执行环境变量指向的 C:\Program Files\dotnet\dotnet.exe 程序，然后给 dotnet.exe 提供参数运行。建议初学者以下命令逐个执行一遍，加深记忆和理解，如果实在记不住也没有关系，可以通过在控制台中输入命令&lt;/p&gt;
&lt;h5 id=&quot;帮助命令&quot;&gt;1.帮助命令&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet --help 
// 或者
dotnet optional --help
//  如
dotnet new --help // 了解创建项目的帮助文档&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;dotnet-new-创建各种类型的项目&quot;&gt;2. dotnet new 创建各种类型的项目&lt;/h5&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;控制台应用程序&lt;/td&gt;
&lt;td&gt;console&lt;/td&gt;
&lt;td&gt;[C#]、F#、VB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;类库&lt;/td&gt;
&lt;td&gt;classlib&lt;/td&gt;
&lt;td&gt;[C#]、F#、VB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;单元测试项目&lt;/td&gt;
&lt;td&gt;mstest&lt;/td&gt;
&lt;td&gt;[C#]、F#、VB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;xUnit 测试项目&lt;/td&gt;
&lt;td&gt;xunit&lt;/td&gt;
&lt;td&gt;[C#]、F#、VB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Razor 页&lt;/td&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MVC ViewImports&lt;/td&gt;
&lt;td&gt;viewimports&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MVC ViewStart&lt;/td&gt;
&lt;td&gt;viewstart&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ASP.NET Core 空&lt;/td&gt;
&lt;td&gt;web&lt;/td&gt;
&lt;td&gt;[C#]，F#&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ASP.NET Core Web应用程序(Model - View - Controller)&lt;/td&gt;
&lt;td&gt;mvc&lt;/td&gt;
&lt;td&gt;[C#]，F#&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ASP.NET Core Web 应用程序&lt;/td&gt;
&lt;td&gt;razor&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;含 Angular 的 ASP.NET Core&lt;/td&gt;
&lt;td&gt;angular&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;含 React.js 的 ASP.NET Core&lt;/td&gt;
&lt;td&gt;react&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;含 React.js 和 Redux 的 ASP.NET Core&lt;/td&gt;
&lt;td&gt;reactredux&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ASP.NET Core Web API&lt;/td&gt;
&lt;td&gt;webapi&lt;/td&gt;
&lt;td&gt;[C#]，F#&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Razor 类库&lt;/td&gt;
&lt;td&gt;razorclasslib&lt;/td&gt;
&lt;td&gt;[C#]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;global.json 文件&lt;/td&gt;
&lt;td&gt;globaljson&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;NuGet 配置&lt;/td&gt;
&lt;td&gt;nugetconfig&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Web 配置&lt;/td&gt;
&lt;td&gt;webconfig&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;解决方案文件&lt;/td&gt;
&lt;td&gt;sln&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;更多命令，见&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;https://docs.microsoft.com/zh-cn/dotnet/core/tools/dotnet-new?tabs=netcore21&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最最常用的命令有-4-个这些命令需要在项目根目录执行&quot;&gt;最最常用的命令有 4 个，这些命令需要在项目根目录执行&lt;/h3&gt;
&lt;h5 id=&quot;创建一个-asp.net-core-mvc-项目指定项目名称为-mymvc&quot;&gt;1. 创建一个 asp.net core mvc 项目，指定项目名称为 MyMvc&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new mvc  -o MyMvc&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;还原项目引用包&quot;&gt;2. 还原项目引用包&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet restore&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;编译项目&quot;&gt;3. 编译项目&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet build&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;运行项目&quot;&gt;4. 运行项目&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;asp.net-core-项目结构介绍&quot;&gt;Asp.Net Core 项目结构介绍&lt;/h3&gt;
&lt;h5 id=&quot;首先使用上面的命令创建一个-asp.net-core-mvc-项目&quot;&gt;1. 首先使用上面的命令创建一个 Asp.Net Core MVC 项目&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new mvc -o MyMvc&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建成功得到一个新的-asp.net-core-mvc-项目&quot;&gt;2. 创建成功，得到一个新的 Asp.Net Core MVC 项目&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181127145516468-885190146.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开项目文件夹，进入项目，看到一个标准的 Asp.Net Core MVC 项目结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181127145527607-1174700914.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍各个目录和文件的作用&quot;&gt;介绍各个目录和文件的作用&lt;/h3&gt;
&lt;h5 id=&quot;三层架构目录&quot;&gt;1. 三层架构目录&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;/Models
/ViewS
/Controllers&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个和 Asp.Net MVC 相同的三层架构 MVC 项目，包含了 模型（Models）、视图（Views）、控制器（Controllers），简单来说就是 Models 内可以定义视图（Views）通过 html 传递到 Controllers 内控制器的实体对象&lt;/p&gt;
&lt;h5 id=&quot;obj-目录&quot;&gt;2. obj 目录&lt;/h5&gt;
&lt;p&gt;该目录用于存放相关配置文件暂存项，包引用项目配置说明&lt;/p&gt;
&lt;h5 id=&quot;properties-目录&quot;&gt;3. Properties 目录&lt;/h5&gt;
&lt;p&gt;该目录用于存放程序集信息，运行配置文件、内部资源等文件，该目录在创建之初，会默认创建一个 launchSettings.json ，该文件包含了一些程序启动时的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;iisSettings&quot;: {
    &quot;windowsAuthentication&quot;: false, 
    &quot;anonymousAuthentication&quot;: true, 
    &quot;iisExpress&quot;: {
      &quot;applicationUrl&quot;: &quot;http://localhost:23090&quot;,
      &quot;sslPort&quot;: 44351
    }
  },
  &quot;profiles&quot;: {
    &quot;IIS Express&quot;: {
      &quot;commandName&quot;: &quot;IISExpress&quot;,
      &quot;launchBrowser&quot;: true,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    },
    &quot;MyMvc&quot;: {
      &quot;commandName&quot;: &quot;Project&quot;,
      &quot;launchBrowser&quot;: true,
      &quot;applicationUrl&quot;: &quot;https://localhost:5001;http://localhost:5000&quot;,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;无需理解太多直接在项目根目录下输入命令启动-mvc-项目&quot;&gt;4. 无需理解太多，直接在项目根目录下输入命令启动 MVC 项目&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你将会得到如下窗口输出信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181127145539949-711746980.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重点关注控制台输出的一个信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Now listening on: https://localhost:5001
Now listening on: http://localhost:5000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该信息表示 Asp.Net Core MVC 项目已成功运行于 5001/5000 端口下，在浏览器中打开该连接地址&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://localhost:5001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再图看看 launchSettings.json 中的信息，找到下面的信息，你就了解了这个文件的作用是配置项目运行端口等信息的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;applicationUrl&quot;: &quot;https://localhost:5001;http://localhost:5000&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;wwwwroot&quot;&gt;5. wwwwroot&lt;/h5&gt;
&lt;p&gt;该目录存放视图层（Views） html 页面引用的静态资源，如图片、样式表、脚本文件（js）等&lt;/p&gt;
&lt;h5 id=&quot;appsettings.json-和-appsettings.development.json&quot;&gt;6. appsettings.json 和 appsettings.Development.json&lt;/h5&gt;
&lt;p&gt;项目主配置文件，两个文件格式完全相同，实际上 appsettings.Development.json 表示 开发时运行程序的配置文件，使用 appsettings.{env}.json，可以很方便进行运行环境的切换，以加载不同的配置文件&lt;/p&gt;
&lt;h5 id=&quot;mymvc.csproj-项目描述文件用记事本打开它看看&quot;&gt;7. MyMvc.csproj 项目描述文件，用记事本打开它，看看&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.1&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.App&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Razor.Design&quot; Version=&quot;2.1.2&quot; PrivateAssets=&quot;All&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行表示项目是一个 web 应用程序，当前使用的 SDK 版本为 netcoreapp2.1，配置节点 ItemGroup 包含了项目引用的 Nuget 包，如有新的包引用，可以加入该 ItemGroup 配置节&lt;/p&gt;
&lt;h5 id=&quot;program.cs-文件程序运行主入口main-方法所在&quot;&gt;8.Program.cs 文件，程序运行主入口，Main 方法所在&lt;/h5&gt;
&lt;h5 id=&quot;startup.cs&quot;&gt;9.Startup.cs&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;该文件是默认文件，不可随意删除，在此文件中可以以包含服务配置、定义请求处理管道的重要操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;     总的来说，这是一篇小白入门答疑，简单的介绍了一个标准的 Asp.Net Core MVC 项目都包含了哪些文件和目录，以及各自的作用，希望对未入门的同学有点帮助&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;努力为开源社区作贡献，推荐一个自己开发的基于 .netcore+pgsql 的快速开发脚手架，内置 ORM框架，github地址：&lt;a href=&quot;https://github.com/lianggx/mystaging&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/mystaging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文中如有疏漏之处，欢迎指正。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 27 Nov 2018 07:15:00 +0000</pubDate>
<dc:creator>Ron.liang</dc:creator>
<og:description>前言     上一章介绍了 Asp.Net Core 的前世今生，并创建了一个控制台项目编译并运行成功，本章的内容介绍 .NETCore 的各种常用命令、Asp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viter/p/10026517.html</dc:identifier>
</item>
<item>
<title>Flutter中打造多行列列表GridView组件的使用 - 雨吻蝶</title>
<link>http://www.cnblogs.com/zengfp/p/10026541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengfp/p/10026541.html</guid>
<description>&lt;p&gt;GridView组件。一个可滚动的二维空间数组。&lt;/p&gt;
&lt;p&gt;在使用无限加载滚动列表的时候，最先使用的还是ListView组件。但若是要一行显示2列或者更多列的滚动列表，GridView组件更为方便。如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201811/1475852-20181127143918655-1201027200.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在向服务器请求数据后，服务器往往会返回一段json字符串。而我们要想更加灵活的使用数据的话需要把json字符串转化成对象。由于flutter只提供了json to Map。而手写反序列化在大型项目中极不稳定，很容易导致解析失败。所有最好使用json_serializable 自动反序列化。&lt;/p&gt;
&lt;p&gt;首先在pubspec.yaml文件中dependencies添加json_annotation，dev_dependencies添加json_serializable&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use &lt;/span&gt;&lt;span&gt;with&lt;/span&gt; the CupertinoIcons class &lt;span&gt;for&lt;/span&gt;&lt;span&gt; iOS style icons.
  cupertino_icons: &lt;/span&gt;^0.1.2&lt;span&gt;
  json_annotation: &lt;/span&gt;^2.0.0&lt;span&gt;
  cached_network_image: &lt;/span&gt;^0.5.1&lt;span&gt;
  transparent_image: &lt;/span&gt;^0.1.0&lt;span&gt;
  dio: &lt;/span&gt;^1.0.9&lt;span&gt;
  video_player: &lt;/span&gt;^0.7.2&lt;span&gt;
  flutter_spinkit: &lt;/span&gt;^2.1.0&lt;span&gt;

dev_dependencies:
  build_runner: &lt;/span&gt;^1.0.0&lt;span&gt;
  json_serializable: &lt;/span&gt;^2.0.0&lt;span&gt;
  flutter_test:
    sdk: flutter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;以json_serializable的方式创建model类&quot;&gt;以json_serializable的方式创建model类&lt;/h3&gt;
&lt;p&gt;创建一个模型picmodel.dart&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import 'package:json_annotation/json_annotation.dart'&lt;span&gt;;
part &lt;/span&gt;'picmodel.g.dart'&lt;span&gt;;

@JsonSerializable()
class PicModel {
  PicModel(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.createdAt,&lt;span&gt;this&lt;/span&gt;.publishedAt,&lt;span&gt;this&lt;/span&gt;.type,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.url);

  String createdAt;
  String publishedAt;
  String type;
  String url;

  factory PicModel.fromJson(Map&lt;/span&gt;&amp;lt;String,dynamic&amp;gt; json) =&amp;gt;&lt;span&gt; _$PicModelFromJson(json);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时这个picmodel.g.dart文件是不存在的，必须运行代码生成器来为我们生成序列化模板。通过在我们的项目根目录下运行&lt;code class=&quot;highlighter-rouge&quot;&gt;flutter packages pub run build_runner build&lt;/code&gt;，我们可以在需要时为我们的model生成json序列化代码。 这触发了一次性构建，它通过我们的源文件，挑选相关的并为它们生成必要的序列化代码。&lt;/p&gt;
&lt;p&gt;然后建立find.dart文件，搭建基础构架。引入相关的库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import 'package:flutter/material.dart'&lt;span&gt;;
import &lt;/span&gt;'dart:io'&lt;span&gt;;
import &lt;/span&gt;'dart:convert'&lt;span&gt;;
import &lt;/span&gt;'package:flutter_yuan/models/picmodel.dart'&lt;span&gt;;
import &lt;/span&gt;'package:cached_network_image/cached_network_image.dart'&lt;span&gt;;

class FindPage extends StatefulWidget{
  FindPage({Key key}):super(key:key);
  @override
  createState() &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; _FindPageState();
}

class _FindPageState extends State&lt;/span&gt;&amp;lt;FindPage&amp;gt;&lt;span&gt; {
  List&lt;/span&gt;&amp;lt;PicModel&amp;gt; picList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; List();
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; page = 1&lt;span&gt;;
  @override
  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; initState() {
    super.initState();
    _getPicList();
  }
  @override
  Widget build(BuildContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
      &lt;/span&gt;&lt;span&gt;
    );
  }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们需要通过_getPicList来异步请求数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;_getPicList() async{
    String url &lt;/span&gt;= 'https://www.apiopen.top/meituApi?page=$page'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; req =&lt;span&gt; await httpClient.getUrl(Uri.parse(url));
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; await req.close();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; print(res);&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(res.statusCode ==&lt;span&gt; HttpStatus.OK) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jsonString = await res.transform(utf8.decoder).join();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将结果转换成字符串拼接&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; print(jsonString);&lt;/span&gt;
        Map data = jsonDecode(jsonString);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;格式化成Map对象&lt;/span&gt;
&lt;span&gt;        print(data);
        List pics &lt;/span&gt;= data['data'&lt;span&gt;];
        List&lt;/span&gt;&amp;lt;PicModel&amp;gt; items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; List();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pics) {
          items.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PicModel.fromJson(value));
        };
        setState(() {         &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.picList.addAll(items);          
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.page ++&lt;span&gt;;
        });
      }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
      
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后构建Widget：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Widget build(BuildContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
      appBar: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppBar(
        title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text('美图'&lt;span&gt;),
        centerTitle: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      ),
      body: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GridView.builder(
        padding: const EdgeInsets.all(&lt;/span&gt;10.0&lt;span&gt;),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: &lt;/span&gt;3&lt;span&gt;,
          mainAxisSpacing: &lt;/span&gt;10.0&lt;span&gt;,
          crossAxisSpacing: &lt;/span&gt;10.0&lt;span&gt;,
        ),
        itemCount: picList.length,
        itemBuilder: (BuildContext context, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index == picList.length - 1&lt;span&gt; ){
            _getPicList();
          }
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buildItem(picList[index]);
        },
      ),
    );
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用GridView.builder组件来构建列表，通过gridDelegate属性来对列表样式进行丰富。crossAxisCount属性可以设置每行的列数，打造你的瀑布流布局。&lt;/p&gt;
&lt;p&gt;buidItem方法对图片的样式布局。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;buildItem(item) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GestureDetector(
      onTap: () {
        Navigator.push(
          context, 
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MaterialPageRoute(
            builder: (context) &lt;/span&gt;=&amp;gt; 
            &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scaffold(
              appBar: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppBar(
                title: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text('图片详情'&lt;span&gt;),
              ),
              body: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Center(
                child: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Container(
                  width: &lt;/span&gt;300.0&lt;span&gt;,
                  child: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CachedNetworkImage(
                    imageUrl: item.url,
                    fit: BoxFit.fitWidth,
                  ),
                )
              ),
            )
          )
        );
      },
      child: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CachedNetworkImage(
        errorWidget: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Icon(Icons.error),
        imageUrl: item.url,
        fadeInDuration: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duration(seconds: 3&lt;span&gt;),
        fadeOutDuration: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Duration(seconds: 1&lt;span&gt;),
      ),
    );
  }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 27 Nov 2018 07:14:00 +0000</pubDate>
<dc:creator>雨吻蝶</dc:creator>
<og:description>GridView组件。一个可滚动的二维空间数组。 在使用无限加载滚动列表的时候，最先使用的还是ListView组件。但若是要一行显示2列或者更多列的滚动列表，GridView组件更为方便。如下 在向服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengfp/p/10026541.html</dc:identifier>
</item>
<item>
<title>JUnit测试 - 999.感冒灵</title>
<link>http://www.cnblogs.com/SunHuaJ/p/9566861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunHuaJ/p/9566861.html</guid>
<description>&lt;p&gt;环境：idea&lt;/p&gt;
&lt;p&gt;通过maven管理jar包，导入：JUnit依赖（百度：mvn JUnit）&lt;/p&gt;
&lt;p&gt;首先，对测试的内容要有一个规范的管理和命令。&lt;/p&gt;
&lt;p&gt;　　0、新建一个源代码目录来存放我们的测试代码，即将测试代码和项目业务代码分开&lt;/p&gt;
&lt;p&gt;　　1、测试类所在的包名应该和被测试类所在的包名保持一致 、&lt;/p&gt;
&lt;p&gt;　　2、测试类使用Test作为类名的后缀&lt;/p&gt;
&lt;p&gt;　　3、测试方法使用test作为方法名的前缀&lt;/p&gt;

&lt;p&gt;对于测试的方法中，要求统一写为：public void不带返回参数的方法标签。重要注解：&lt;/p&gt;
&lt;p&gt;　　@Test:测试方法&lt;/p&gt;
&lt;p&gt;　　　　a、@Test(expected=XXException.class)：如果程序的异常和XXException.class一样，则测试通过;否则报错&lt;/p&gt;
&lt;p&gt;　　　　b、@Test(timeout=100):如果程序的执行能在100毫秒之内完成，则测试通过；否则报错&lt;/p&gt;
&lt;p&gt;　　@Ignore: 忽略该测试方法，暂不运行此段代码&lt;/p&gt;
&lt;p&gt;　　@Before: 再每一个测试方法之前运行（如果有多个，则每个测试方法之前都会首先执行该方法）&lt;/p&gt;
&lt;p&gt;　　@After: 每一个测试方法之后运行，与@Before相反&lt;/p&gt;
&lt;p&gt;　　@BeforeClass: 方法必须要是静态方法（static 声明），在before之前执行，只会执行一次（如果有多个测试方法）。&lt;/p&gt;
&lt;p&gt;　　@AfterClass: 方法必须要是静态方法（static 声明），在after之后执行，只会执行一次（如果有多个测试方法）。&lt;/p&gt;

&lt;p&gt;JUnit提供了一些方法，帮助我们判断某个单元测试是否异常。我们把所有这些方法统称为断言（assert）。断言是单元测试最基本的组成部分。（下面都是常用的，具体语法可参考JUnitAPI文档）&lt;/p&gt;
&lt;p&gt;　　1、assertEquals（[String message],expected,actual）：比较两个基本类型或对象是否相等（expected和actual是原始类型数值(primitive value)或者必须为实现比较而具有equal方法,message是选项，如果不相等时会打印message内容。测试时有一点疑惑：Integer在这里不能通过java自动装包拆包隐性转为int型,还是通过指定int型才可。pin！）&lt;/p&gt;
&lt;p&gt;　　2、assertFalse（[String message],boolean condition）：断言为假，即condition条件为假时，返回success，反之failure&lt;/p&gt;
&lt;p&gt;　　3、assertTrue（[String message],boolean condition）：断言为真，即condition条件为真时，返回success，反之failure&lt;/p&gt;
&lt;p&gt;　　4、assertNull([String message],java.lang.Object object)：检查是否为空；【对比：assertNotNull】&lt;/p&gt;
&lt;p&gt;　　5、assertSame([String message],expected,actual)：检查两个对象是否为同一实例【对比：assertNotSame】&lt;/p&gt;
&lt;p&gt;　　6、fail( String message )：使测试立即失败，其中 message 参数使可选的。这种断言通常被用于标记某个不应该到达的分支（例如，在一个预期发生的异常之后）&lt;/p&gt;

&lt;p&gt;示例，如我们在编写接口时，需要Service层进行Test（Controller层一般不用，如果要用的话，使用Mockio）。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @SpringBootTest(webEnvironment =&lt;span&gt; SpringBootTest.WebEnvironment.RANDOM_PORT)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueMetaServiceTest {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ValueMetaService valueMetaService;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; before() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;测试开始！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; valueMetaControllerTest() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         PageValueMeta pageValueMeta = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageValueMeta();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         pageValueMeta.setId(&quot;jhhefsdf23423kdfs&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        valueMetaService.insert(pageValueMeta);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        System.out.println(pageValueMeta);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 27 Nov 2018 07:10:00 +0000</pubDate>
<dc:creator>999.感冒灵</dc:creator>
<og:description>环境：idea 通过maven管理jar包，导入：JUnit依赖（百度：mvn JUnit） 首先，对测试的内容要有一个规范的管理和命令。 0、新建一个源代码目录来存放我们的测试代码，即将测试代码和项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SunHuaJ/p/9566861.html</dc:identifier>
</item>
<item>
<title>Net core 2.x - docker(for windows)-linux配置及项目+SqlServer发布 - esoftor</title>
<link>http://www.cnblogs.com/Tmc-Blog/p/10026488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tmc-Blog/p/10026488.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将.net core2.x+sqlserver项目发布到docker.呵呵,操作很自如,如下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1.罗嗦几句&lt;/h3&gt;
&lt;p&gt;在跑起来之前浪费了不少时间和精力,起初是将docker for windows的环境转换成了 window(安装docker for windows之后,右下角的小鲸鱼右击之后转换),但是很操蛋,也做了随笔但是没有发布之保存了草稿,记录了很多的问题以及问题的解决方式,浪费了一天时间.跑起来之后感觉幸福来之不易所以拿出来分享下.下面看我们的效果图;&lt;/p&gt;

&lt;h3&gt;2.效果预览&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127141454415-991040985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;...其他内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127141529556-1552641597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们的项目成功跑起来并完成了在sql server数据库的迁移操作.&lt;/p&gt;
&lt;p&gt;我们看下我们的项目是否可以正常访问,(我这里映射的docker expose端口60000到外部端口 8089)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127141701392-1008739225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;毫无悬念的可以访问到我们的界面了.和前几篇写的随笔的时候 熟悉的界面又回来了.下面就说下配置以及操作.&lt;/p&gt;
&lt;h3&gt; 3.环境及配置&lt;/h3&gt;
&lt;h4&gt;3.1环境&lt;/h4&gt;
&lt;p&gt;我们要将项目发布到docker,那么我们首要解决的就是docker的获取,是的,我们也就是用我们惯用的windwos环境,安装docker for widnows,&lt;/p&gt;
&lt;p&gt;获取: https://www.docker.com/products/docker-desktop&lt;/p&gt;
&lt;p&gt;选取您需要的版本即可.安装直接下一步下一步就行,安装完成之后,我们要看下我们的容器是windows还是linux,因为这里我们使用的是 linux container ,查看如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127142243040-337323707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击settings-&amp;gt;Shared Drives,选择你要和docker 共享的磁盘,然后点击Advanced 分配你的CPU和内存即可,参考如下,,,我是默认的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127142433844-108553571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好的,docker我们就简单的配置完了.下面,就到了重要环节了,此时如果你看过其他的入门的文章的话,你可能绝的下一步骤就是创建项目 直接丢docker就可以泡起来了,或者,顶多在创建一个Dockerfile就行了.我告诉你,低俗....你被骗了,单纯跑一个项目是没任何问题的,但是我们还要连接数据库(sql server),还要连接redis,mongodb,,,等等...所以,这里还没有配置完.要做的还不少呢.&lt;/p&gt;
&lt;h4&gt; 3.2配置&lt;/h4&gt;
&lt;p&gt;首先先确保我们的docker环境是有效的,可以在cmd或者powershell中输入docker info,如果不提示docker无效即可.不多说.&lt;/p&gt;
&lt;p&gt;下面我们先获取下发布必须的相关镜像 (复制到cmd或者powershell直接回撤),,,当然这一步不是必需的,因为我们一会儿在build我们项目对应的镜像的时候使用到的 相关镜像会自己下载安装:&lt;/p&gt;
&lt;p&gt;docker pull microsoft/dotnet&lt;/p&gt;
&lt;p&gt;docker pull microsoft/mssql-server-linux&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127143543495-1793767050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将我们的core项目发布文件复制到指定的文件夹,并cd到这个 文件夹中 ,在其中创建一个 Dockerfile的文件,无后缀!!,内容如下(参考):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# 基于microsoft/dotnet:2.1&lt;span&gt;-sdk or dotnet:latest 默认latest 来创建我们的镜像
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; microsoft/dotnet

#指定docker的工作目录为 esoftor-master文件夹,也就是容器的默认的文件夹
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /usr/local/src/esoftor-api-master

# docker对外暴露的端口
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt; 60000&lt;span&gt;

# 将当前文件夹下的所有文件全部复制到工作目录
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . /usr/local/src/esoftor-api-master

#&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt; dotnet ESoftor.WebApi.dll 这里自行百度 CMD和ENTRYPOINT的区别
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;, &quot;ESoftor.WebApi.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候我们的基础工作就完成了.Dockerfile在我们文件夹中位置如下(参考):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127144011763-149666694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里我们哈需要继续配置另一个东西. docker-compose.yaml,,,,,,,docker compose ,,,,,docker ......Docker Compose是Docker三剑客之一，用于定义和运行多个Docker容器应用，负责实现对 Docker 容器集群的快速编排。我们可以通过Dockerfile定义一个单独的应用容器。然而在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器等。Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 配置板文件（YAML 格式）来定义一组相关联的应用容器。然后使用使用单个命令，就可以根据配置中创建并启动所有服务。但是值得我们庆幸的事情是,官方很明确的有说明了,docker for windows默认内置了Docker compose,否则的话我们还需要单独安装.&lt;/p&gt;
&lt;p&gt;我们cd到 上面截图的 上一层文件夹,也就是Temp文件夹中.创建 一个名称为 docker-compose.yml 的文件.内容参考如下:(这里我只配置了sqlserver),只是为了掩饰core+sql server 在docker中可以跑起来:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: &quot;3&quot;&lt;span&gt;

services:

  esoftor.api:
    image: esoftor.api:v1.&lt;/span&gt;0&lt;span&gt;
    environment:
      - ASPNETCORE_URLS=http:&lt;/span&gt;//0.0.0.0:60000
&lt;span&gt;      - ConnectionString=Server=sql.data;User=sa;Password=520Tmc1314!;Database=esoftor.source.novel2;    
    build:
      context: ./netcoreapp2.&lt;/span&gt;1&lt;span&gt;
      dockerfile: Dockerfile
    ports: 
      - &lt;/span&gt;&quot;8089:60000&quot;&lt;span&gt;
    volumes: 
      - ./netcoreapp2.&lt;/span&gt;1&lt;span&gt;/:/usr/local/src/esoftor-api-master
    container_name: esoftor.api
    depends_on:
      - sql.data

  sql.data:
    image: microsoft/mssql-server-linux:&lt;/span&gt;2017&lt;span&gt;-latest
    environment:
      - SA_PASSWORD=520Tmc1314!
      - ACCEPT_EULA=Y
    ports:
      - &lt;/span&gt;&quot;14333:1433&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置说明:&lt;/p&gt;
&lt;p&gt;　version:不解释,自行百度 docker compose 然后看官方解释,,,看了也太大意义&lt;/p&gt;
&lt;p&gt;　services:服务,我们这里的服务就是esoftor.api和sql.data,当然这个词是复数形式,也就是说可以配置多个&lt;/p&gt;
&lt;p&gt;　　 esoftor.api 和 sql.data 就是我们自定义的服务名称,随便写&lt;/p&gt;
&lt;p&gt;　　 image:生成的镜像名&lt;/p&gt;
&lt;p&gt;　　 environment:服务环境的变量  ASPNETCORE_URLS=http://0.0.0.0:60000 即:监听的60000的端口,这个和我们的Dockerfile中的EXPOSE是对应起来的.  ConnectionString:不解释,但是要注意的是,这里的 Server=的是我们配置的第二个服务的名称,也就是sqlserver的服务名称.&lt;/p&gt;
&lt;p&gt;　　 build:context:及Dockerfile所在的目录(因为上面我们已经cd到了项目的所在目录的上一级文件夹)  dockerfile:即dockerfile的文件名称&lt;/p&gt;
&lt;p&gt;　　 ports:格式 外部端口:内部端口 这里的内部端口就是我们上面使用的 60000,也是和dockerfile中是对应起来的.&lt;/p&gt;
&lt;p&gt;　　 volumes:格式 项目路径:docker的运行目录,---这里也是和Dockerfile中设置的 WORKDIR是对应的&lt;/p&gt;
&lt;p&gt;        container_name:生成的容器的名称&lt;/p&gt;
&lt;p&gt;        depends_on:顾名思义,依赖项;这里我们依赖了我们的另一个服务也就是访问数据库用的&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;　 数据库配置:这里如果你的机器安装了Sql server数据库,你会遇到一个问题就是 在执行的时候会发现1433(sqlserver)使用的被占用了,,,,不是废话吗,所以上面参考配置中,我是用的14333不是1433,我是将14333映射到docker的1433端口,并在 SQL SERVER 的网络配 MSSQLSERVER的TCP/IP的IP中修改了127.0.0.1的1433的默认配置为14333,并设置为启用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　以上我们呢的基础工作就完成了,下面开始愉快的玩耍起来吧.&lt;/p&gt;

&lt;h3&gt;4.创建镜像并运行项目&lt;/h3&gt;
&lt;p&gt;此时我们在cmd或者powershell中输入:docker-compose build&lt;/p&gt;
&lt;p&gt;默默的等待执行完成吧.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181127150515876-777556655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成之后继续输入:&lt;/p&gt;
&lt;p&gt;docker-compose up&lt;/p&gt;
&lt;p&gt;然后如果没有错误的话就可以看到我们开篇时候的截图了.&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 07:07:00 +0000</pubDate>
<dc:creator>esoftor</dc:creator>
<og:description>将.net core2.x+sqlserver项目发布到docker.呵呵,操作很自如,如下. 1.罗嗦几句 在跑起来之前浪费了不少时间和精力,起初是将docker for windows的环境转换成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tmc-Blog/p/10026488.html</dc:identifier>
</item>
<item>
<title>区块链公链，私链漫谈 - 唐玮</title>
<link>http://www.cnblogs.com/wtang/p/10026427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtang/p/10026427.html</guid>
<description>&lt;p&gt;最近比特币价格一泻千里，其他的加密货币们也随着币王一起下跌，由加密货币掀起的加密经济生态（矿工，交易所，ICO等）也岌岌可危，但是由比特币衍生出来的区块链技术却一枝独秀，收到各国政府的支持和欢迎。&lt;/p&gt;

&lt;p&gt;区块链技术，区别于分布式数据库或者分布式账本在于它能在不信任的各方通过共识算法建立一个信任的平台系统，链上存有的数据是被参与各方认可的，有点类似审计的功能。&lt;/p&gt;

&lt;p&gt;笼统来讲，区块链分为公链和私链，或者还是有什么联盟链。但是我觉得对应的英文更能指出技术的实质，公链（Permissionless Blockchain）和私链（Permissioned Blockchain）。即公链的分布式网络是无需允许的，任何人（节点）都能加入网络，所有加入者是匿名的，节点靠hash power（计算hash函数的算力）来提供自己的权威性。私链的分布式网络相反，是被控制住的，不是任何人（节点）都能加入，但所有的加入者是实名的，节点靠面子（大家都是实名的，有头有脸的人，做了什么篡改数据，攻击网络的事情大家就会把它投出去）来提供自己的权威性。&lt;/p&gt;

&lt;p&gt;对于一个理想世界来说，公链当然是最好的，它的开放性提供了一个最广泛的公正性，即它上面的数据是所有节点都认可的数据，而它的节点又是理论上包括所有（开放性的）电脑。但是它的性能是个硬伤，区块链作为一个分布式账本网络，它的性能是由网络节点上性能最差的节点决定的。所以作为区块链的重要指标的TPS（每秒交易数），在公链上是饱受诟病的。私链，因为不需要靠算力来提供自己的权威性，它就不需要挖坑，不需要PoW共识算法，通过一系列的私链共识算法（这是同事跟我的总结&lt;a href=&quot;https://medium.com/@arigatodl/private-blockchain-consensus-mechanisms-8e6fc48c8fb&quot; target=&quot;_blank&quot;&gt;Private blockchain consensus mechanisms&lt;/a&gt;）来达到很高的TPS。但是私链的问题在哪里呢？私链的问题在私链中的数据只是私链的成员认可的数据，即它没有公链的最广泛的公正性，只有小圈子的公正性。&lt;/p&gt;

&lt;p&gt;我们再谈谈经济模型，即公链私链都可以如何服务社会（赚钱）。公链，目前最大的经济模型就是ICO，上交易所，我这么说可能有点消极，每个公链提出的时候也是有自己的项目抱负的吧，比如最大的目的就是在线支付，跨国转账等，然后有些提供数据存储等等。而私链用在一些行业内部的数据审计，数据存储。一个行业的几个公司，大家都知道谁是谁，但是基本上因为竞争关系，谁也不信谁，所以需要这么个平台来处理一些公共的数据问题。或者一个公司的不同部门等也可以搭建一个私链，来处理点审计的信息。目前HyperLedger，Ethereum有个自己的私链产品。&lt;/p&gt;

&lt;p&gt;通过上面的分析，是不是会觉得区块链有点穷途末路了。其实不然，目前来看，公链是有点式微，私链在蓬勃发展，最重要的是有个叫做混合链的已经开始初出茅庐了。上面讲公链能提供最广泛的公正性，私链能提供性能。那么通过分层架构，即公链作为基础层，提供公正性，公链不面向终端客户，它只面向第二层链，即私链。私链上的数据通过Merkel Hash Tree压缩，登上基础层。这样解决了公链的性能问题，即不需要公链有高的性能了，通过把数据量做小了。而最终有私链来面向终端客户来提供具体服务。那么即兼有了公正性和性能，能让区块链技术广泛应用起来。这个项目&lt;a href=&quot;https://www.nervos.org/&quot; target=&quot;_blank&quot;&gt;Nervos Network&lt;/a&gt;目前看起来就是在做这件事情，可以关注下。说明下，这篇文章不是软文，只是觉得好的东西跟大家分享下。&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 06:58:00 +0000</pubDate>
<dc:creator>唐玮</dc:creator>
<og:description>最近比特币价格一泻千里，其他的加密货币们也随着币王一起下跌，由加密货币掀起的加密经济生态（矿工，交易所，ICO等）也岌岌可危，但是由比特币衍生出来的区块链技术却一枝独秀，收到各国政府的支持和欢迎。 区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wtang/p/10026427.html</dc:identifier>
</item>
<item>
<title>ES2015 中的函数式Mixin - AveryBy</title>
<link>http://www.cnblogs.com/averyby/p/10026365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/averyby/p/10026365.html</guid>
<description>&lt;p&gt;&lt;span&gt;原文链接&lt;/span&gt;：&lt;a href=&quot;http://raganwald.com/2015/06/17/functional-mixins.html&quot;&gt;http://raganwald.com/2015/06/17/functional-mixins.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在“&lt;a href=&quot;https://www.cnblogs.com/averyby/p/10021383.html&quot;&gt;原型即对象&lt;/a&gt;”中，我们看到可以对原型使用 Object.assign 来模拟 mixin，原型是 JavaScript 中类概念的基石。现在我们将回顾这个概念，并进一步探究如何将功能糅合进类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，简单回顾一下：在 JavaScript 中，类是通过一个构造函数和它的原型来定义的，无论你是用 ES5 语法，还是使用 class 关键字。类的实例是通过 new 调用构造器的方式创建的。实例从构造器的 prototype 属性上继承共享的方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;对象 mixin 模式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果多个类共享某些行为，或者希望对庞杂的原型对象进行功能提取，这时候就可以使用 mixin 来对原型进行扩展。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如这里的 Todo 类&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Todo {
  constructor (name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name || 'Untitled'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
  undo () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;用于颜色编码的 mixin 如下&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const Coloured =&lt;span&gt; {
  setColourRGB ({r, g, b}) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colourCode =&lt;span&gt; {r, g, b};
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  },
  getColourRGB () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.colourCode;
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;将颜色编码功能糅合到 Todo 原型上是简而易行的&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Object.assign(Todo.prototype, Coloured);

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Todo('test'&lt;span&gt;)
  .setColourRGB({r: &lt;/span&gt;1, g: 2, b: 3&lt;span&gt;})
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; {&quot;name&quot;:&quot;test&quot;,&quot;done&quot;:false,&quot;colourCode&quot;:{&quot;r&quot;:1,&quot;g&quot;:2,&quot;b&quot;:3}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;我们还可以升级为使用私有属性&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const colourCode = Symbol(&quot;colourCode&quot;&lt;span&gt;);

const Coloured &lt;/span&gt;=&lt;span&gt; {
  setColourRGB ({r, g, b}) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[colourCode]=&lt;span&gt; {r, g, b};
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  },
  getColourRGB () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[colourCode];
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，非常简单明了。我们将这称为一种 “模式”，像菜谱一样，是解决某种问题的独特的代码组织方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;函数式 mixin&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面的对象 mixin 功能完好，但用它来解决问题要分两步走：定义 mixin 然后扩展类的原型。Angus Croll 指出将 mixin 定义成函数而不是对象会是更优雅的做法，并称之为函数式 mixin。再次以 Coloured 为例，将它改写成函数的形式&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const Coloured = (target) =&amp;gt;&lt;span&gt;
  Object.assign(target, {
    setColourRGB ({r, g, b}) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colourCode =&lt;span&gt; {r, g, b};
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },
    getColourRGB () {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.colourCode;
    }
  });

Coloured(Todo.prototype);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;我们可以定义一个工厂函数，并从命名上体现该模式&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const FunctionalMixin = (behaviour) =&amp;gt;&lt;span&gt;
  target &lt;/span&gt;=&amp;gt; Object.assign(target, behaviour);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;现在我们可以精要地定义函数式 mixin&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const Coloured =&lt;span&gt; FunctionalMixin({
  setColourRGB ({r, g, b}) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colourCode =&lt;span&gt; {r, g, b};
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  },
  getColourRGB () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.colourCode;
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;可枚举性&lt;/strong&gt; &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果我们探究 class 声明类的方式下对 prototype 的操作，可以发现声明的方法默认是不可枚举的。这可以避免一个常见问题——遍历实例的 key 时程序员有时忘记检测 .hasOwnProperty。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而我们的对象 mixin 模式无法做到这点，定义在 mixin 中的方法默认是可枚举的。如果我们故意将其设置为不可枚举，Object.assign 就不会将它们糅合到目标原型了，因为 Object.assign 只会将可枚举的属性赋值到目标对象上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这将导致以下情形&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Coloured(Todo.prototype)

const urgent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Todo(&quot;finish blog post&quot;&lt;span&gt;);
urgent.setColourRGB({r: &lt;/span&gt;256, g: 0, b: 0&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urgent) console.log(property);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt;&lt;/span&gt;
&lt;span&gt;    name
    done
    colourCode
    setColourRGB
    getColourRGB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;正如所见，setColourRGB 和 getColourRGB 方法被枚举出来了，而 do 和 undo 方法却没有。这对于不健壮的代码会是个问题，因为我们不可能每次都重写别处的代码，处处加上 hasOwnProperty 检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;该问题使用函数式 mixin 便可迎刃而解，我们可以神乎其神地让 mixin 表现得和 class 声明类似，这是函数式 mixin 的好处之一&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const FunctionalMixin = (behaviour) =&amp;gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (target) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let property of Reflect.ownKeys(behaviour))
      Object.defineProperty(target, property, { value: behaviour[property] })
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将上面 mixin 的主体部分作为一种代码模板一遍遍写出来不但累人而且容易出错，而将其封装到函数里则是一种小进步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;mixin 的职责&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;和类一样，mixin 是元对象：它们给实例定义行为。除了以方法的形式定义对象的行为，类还负责初始化实例。有的时候，类和元对象还会具有其他的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如，有时某个概念涉及到一组人尽皆知的常量。如果使用类，那么将这些常量定义在 class 本身上则非常方便，这时 class 本身充当了命名空间的作用&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Todo {
  constructor (name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name ||&lt;span&gt; Todo.DEFAULT_NAME;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
  undo () {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  }
}

Todo.DEFAULT_NAME &lt;/span&gt;= 'Untitled'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we are sticklers for read-only constants, we could write:&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; Object.defineProperty(Todo, 'DEFAULT_NAME', {value: 'Untitled'});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们无法使用 “简单 mixin” 做同样的事，因为默认情况下，“简单 mixin” 的所有属性最终都被糅合到实例的 prototype 上。例如，我们想定义 Coloured.RED, Coloured.GREEN, Coloured.BLUE，但我们并不想在任何实例个体上定义 RED, GREEN, BLUE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;同样，我们可以借助函数式 mixin 来解决该问题。FunctionalMixin 工厂函数将接收一个可选的字典，该字典包含只读的 mixin 属性，该字典通过一个特殊的键给出&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const shared = Symbol(&quot;shared&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; FunctionalMixin (behaviour) {
  const instanceKeys &lt;/span&gt;=&lt;span&gt; Reflect.ownKeys(behaviour)
    .filter(key &lt;/span&gt;=&amp;gt; key !==&lt;span&gt; shared);
  const sharedBehaviour &lt;/span&gt;= behaviour[shared] ||&lt;span&gt; {};
  const sharedKeys &lt;/span&gt;=&lt;span&gt; Reflect.ownKeys(sharedBehaviour);

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mixin (target) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let property of instanceKeys)
      Object.defineProperty(target, property, { value: behaviour[property] });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let property of sharedKeys)
    Object.defineProperty(mixin, property, {
      value: sharedBehaviour[property],
      enumerable: sharedBehaviour.propertyIsEnumerable(property)
    });
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mixin;
}

FunctionalMixin.shared &lt;/span&gt;= shared;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;现在我们便可以这样写&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
const Coloured =&lt;span&gt; FunctionalMixin({
  setColourRGB ({r, g, b}) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.colourCode =&lt;span&gt; {r, g, b};
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  },
  getColourRGB () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.colourCode;
  },
  [FunctionalMixin.shared]: {
    RED:   { r: &lt;/span&gt;255, g: 0,   b: 0&lt;span&gt;   },
    GREEN: { r: &lt;/span&gt;0,   g: 255, b: 0&lt;span&gt;   },
    BLUE:  { r: &lt;/span&gt;0,   g: 0,   b: 255&lt;span&gt; },
  }
});

Coloured(Todo.prototype)

const urgent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Todo(&quot;finish blog post&quot;&lt;span&gt;);
urgent.setColourRGB(Coloured.RED);

urgent.getColourRGB()
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; {&quot;r&quot;:255,&quot;g&quot;:0,&quot;b&quot;:0}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;mixin 本身的方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;JavaScript 中属性未必是值（和函数相对）。有时候，类也具有方法。同样，有时 mixin 具有自己的方法也是合理的，比如当涉及到 instanceof 时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在 ECMAScript 的之前版本中，instanceof 操作符检查实例的 prototype 是否和构造函数的 prototype 相匹配。它和“类”配合使用没啥问题，但却无法直接和 mixin 协同工作&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
urgent &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Todo
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; true&lt;/span&gt;
&lt;span&gt;
urgent &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Coloured
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是 mixin 存在的问题。另外，程序员可能根据需要创建动态类型，或者直接使用 Object.create 和 Object.setPrototypeOf 管理原型，它们都可能导致 instanceof 工作不正常。ECMAScript 2015 提供了一种方式来覆写内置的 instanceof 的行为，即对象可以定义一个特殊的方法，该方法属性的名字是一个既定的符号——Symbol.hasInstance。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们可以简单测试一下&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Object.defineProperty(Coloured, Symbol.hasInstance, {value: (instance) =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;});
urgent &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Coloured
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; true&lt;/span&gt;
{} &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Coloured
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，上面的例子在语义上是不对的。然而借助该技术，我们可以这样做&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const shared = Symbol(&quot;shared&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; FunctionalMixin (behaviour) {
  const instanceKeys &lt;/span&gt;=&lt;span&gt; Reflect.ownKeys(behaviour)
    .filter(key &lt;/span&gt;=&amp;gt; key !==&lt;span&gt; shared);
  const sharedBehaviour &lt;/span&gt;= behaviour[shared] ||&lt;span&gt; {};
  const sharedKeys &lt;/span&gt;=&lt;span&gt; Reflect.ownKeys(sharedBehaviour);
  const typeTag &lt;/span&gt;= Symbol(&quot;isA&quot;&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mixin (target) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let property of instanceKeys)
      Object.defineProperty(target, property, { value: behaviour[property] });
    target[typeTag] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let property of sharedKeys)
    Object.defineProperty(mixin, property, {
      value: sharedBehaviour[property],
      enumerable: sharedBehaviour.propertyIsEnumerable(property)
    });
  Object.defineProperty(mixin, Symbol.hasInstance, {value: (instance) &lt;/span&gt;=&amp;gt; !!&lt;span&gt;instance[typeTag]});
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mixin;
}

FunctionalMixin.shared &lt;/span&gt;=&lt;span&gt; shared;

urgent &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Coloured
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; true&lt;/span&gt;
{} &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Coloured
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你需要为了照顾 instanceof 而专门做此实现吗？很可能不需要，因为自己实现一套多态机制是不得已而为之的做法。但这一点使得编写测试用例很顺手，并且一些激进的框架开发者可能在函数的多分派和模式匹配上求索，或许会用上这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对象 mixin 的迷人之处在于简单：它不需要在对象字面值和 Object.assign 之上做一层抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，通过 mixin 模式定义的行为和通过 class 关键字定义的行为存在些许差异。体现差异的两个例子分别是可枚举性以及 mixin 自身的属性（如常量和类似于 [Symbol.hasInstance] 的 mixin 自身方法）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数式 mixin 使得实现上述功能成为可能，不过生成函数式 mixin 的 FunctionalMixin 函数引入了一定复杂性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一般来说，最好保持同一个问题域下的代码表现尽可能相似，而这有时不可避免地增加基础代码的复杂性。但这一点更多的是一种指导思想，而非需要恪守的万能教条。出于此，对象 mixin 模式和函数式 mixin 在 JavaScript 中都有各自的一席之地&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 27 Nov 2018 06:55:00 +0000</pubDate>
<dc:creator>AveryBy</dc:creator>
<og:description>一般来说，最好保持同一个问题域下的代码表现尽可能相似，而这有时不可避免地增加基础代码的复杂性。但这一点更多的是一种指导思想，而非需要恪守的万能教条。出于此，对象 mixin 模式和函数式 mixin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/averyby/p/10026365.html</dc:identifier>
</item>
</channel>
</rss>