<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>上周热点回顾（4.23-4.29） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8975563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8975563.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · 一个普通程序员眼中的「技术」（陈宏鸿）· Qone 正式开源，使 javascript 支持 .NET LINQ（【当耐特】）· 【原创】分布式之缓存击穿（孤独烟）· 如何为分布式系统优雅的更换RPC（haolujun）· C#+HtmlAgilityPack+Dapper走一波爬虫</description>
<pubDate>Mon, 30 Apr 2018 23:31:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8975563.html</dc:identifier>
</item>
<item>
<title>Java不走弯路教程（3.用户验证与文件内容查询） - java123.vip</title>
<link>http://www.cnblogs.com/java123vip/p/8975517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java123vip/p/8975517.html</guid>
<description>&lt;p&gt;&lt;strong&gt;3.用户验证与文件内容查询&lt;/strong&gt;&lt;br/&gt;在上一章中，我们完成了对指定文件内容的输出操作。&lt;br/&gt;我们现在有如下格式的文件product.db&lt;br/&gt;id,product_name,product_detail&lt;br/&gt;1,notebook,mac notebook&lt;br/&gt;2,fruit,apple&lt;br/&gt;我们想输出此文件的内容，可以把product.db放入c:\work\001下，然后运行&lt;br/&gt;java main.MyNotepad product.db&lt;/p&gt;&lt;p&gt;但是，这个文件为企业的机密文件，不希望所有人都能查看到。于是，首先想到的就是加入用户名密码的校验功能。&lt;br/&gt;后续章节中将不再使用MyNotepad.java&lt;br/&gt;我们在MyNotepad.java所在的目录下建立MyDataBase.java，内容如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201805/1302871-20180501030713670-886876502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;符号//后面的内容为注释内容，便于程序的阅读，程序编译运行时将自动忽略注释内容。&lt;br/&gt;其他的注释规则请大家自行查阅。&lt;br/&gt;修改程序，能接受传入的代码，验证通过后再输出文件内容：&lt;br/&gt;调用方法为：java main.MyDataBase product.db root 123&lt;br/&gt;其中root为用户名，123为密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201805/1302871-20180501030739676-776637349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;if else 可以理解为如果，否则&lt;br/&gt;其中if语句括号中的条件只能有两种值：真，假。即true,false&lt;br/&gt;符号&amp;amp;&amp;amp;表示 并且关系,符号 ||表示 或者关系&lt;br/&gt;对于String类型的比较用equals方法,基本类型的比较用两个等于号==,若相同则为true,否则为false&lt;/p&gt;&lt;p&gt;上述语句可以理解为&lt;br/&gt;如果 （用户名等于&quot;root&quot; 并且 密码等于&quot;123&quot;）{&lt;br/&gt;输出文件内容；&lt;br/&gt;}否则{&lt;br/&gt;输出&quot;Access Denied.&quot;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;对于并且，或者的逻辑运算规则如下：&lt;br/&gt;对于A并且B，只有在A和B都为true的时候，结果为true。否则结果为false;&lt;br/&gt;对于A或者B，只要A，B有一个为true,结果就为true,否则为false;&lt;/p&gt;&lt;p&gt;例：&lt;br/&gt;true &amp;amp;&amp;amp; true == true&lt;br/&gt;true &amp;amp;&amp;amp; false == false&lt;br/&gt;false &amp;amp;&amp;amp; true == false&lt;br/&gt;false &amp;amp;&amp;amp; false == false&lt;/p&gt;&lt;p&gt;true || true == true&lt;br/&gt;true || false == true&lt;br/&gt;false || true == true&lt;br/&gt;false || false == false&lt;/p&gt;&lt;p&gt;编译后运行：java main.MyDataBase product.db root 123&lt;br/&gt;输出：文件内容&lt;/p&gt;&lt;p&gt;运行：java main.MyDataBase product.db root xxx&lt;br/&gt;输出：Access Denied.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201805/1302871-20180501030810022-1281211549.png&quot; alt=&quot;&quot; width=&quot;440&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201805/1302871-20180501030817399-142290107.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需求变更：我想在验证用户通过后，输入SQL语句来查询文件，并且输入exit来退出程序。&lt;br/&gt;效果如下：&lt;br/&gt;c:\work\001&amp;gt;java main.MyDataBase root 123&lt;br/&gt;Login OK, Please intput SQL to query, or type exit to exit.&lt;br/&gt;mydb&amp;gt;select * from product&lt;br/&gt;文件内容&lt;br/&gt;mydb&amp;gt;exit&lt;br/&gt;c:\work\001&amp;gt;&lt;/p&gt;&lt;p&gt;修改程序如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201805/1302871-20180501030916780-1944752261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译运行。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1302871/201805/1302871-20180501030928735-651153501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在MyUtil.java中增加了下面三个方法：&lt;br/&gt;public static void print(String message); //输出传入的字符串，不换行。&lt;br/&gt;public static String readln(); //读取DOS中输入的一行字符串。&lt;br/&gt;public static String getFileContentBySql(String sql); //根据传入的SQL查询文件（目前只支持select xxx from xxx where xxx=xxx格式）&lt;/p&gt;
&lt;p&gt;while为循环控制语句，满足括号内条件，则进入循环体。&lt;br/&gt;其中break语句退出循环体，continue语句返回到循环体头部。&lt;/p&gt;
&lt;p&gt;MyUtil.java代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44.5&quot;&gt;&lt;img id=&quot;code_img_closed_49c8a2a2-226f-4e48-86ee-d9426fb07e8a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_49c8a2a2-226f-4e48-86ee-d9426fb07e8a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_49c8a2a2-226f-4e48-86ee-d9426fb07e8a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; util;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyUtil {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(String param) {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        System.out.print(param);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; println(String param) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        System.out.println(param);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String readln() {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; readln(System.in);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     
&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String readln(InputStream is) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             InputStreamReader isr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(is);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             BufferedReader br = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             String line =&lt;span&gt; br.readLine();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; line;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getFileContent(String fileName) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         StringBuffer content = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         InputStream fis = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         InputStreamReader isr = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         BufferedReader br = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             fis = MyUtil.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/&quot;+&lt;span&gt;fileName);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fis == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 System.out.println(&quot;File not found:[&quot; + fileName + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; content.toString();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             isr = &lt;span&gt;new&lt;/span&gt; InputStreamReader(fis, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             br = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             String line = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;                content.append(line);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 content.append(&quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;                    br.close();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                    isr.close();
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;                    fis.close();
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; content.toString();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getFileContentBySql(String command) {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             command = command.replaceAll(&quot;;&quot;, &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             StringBuffer result = &lt;span&gt;new&lt;/span&gt; StringBuffer(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; select username, password from person where username = 'aaa'&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; selectPos = command.indexOf(&quot;select&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; fromPos = command.indexOf(&quot;from&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; wherePos = command.indexOf(&quot;where&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (selectPos == -1 || fromPos == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;incorrect SQL.&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             String columnStr = command.substring(selectPos + &quot;select&quot;&lt;span&gt;.length(), fromPos).trim();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            String tableStr;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            String whereStr;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (wherePos == -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 tableStr = command.substring(fromPos + &quot;from&quot;&lt;span&gt;.length()).trim();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 whereStr = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 tableStr = command.substring(fromPos + &quot;from&quot;&lt;span&gt;.length(), wherePos).trim();
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 whereStr = command.substring(wherePos + &quot;where&quot;&lt;span&gt;.length()).trim();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             List&amp;lt;String&amp;gt; fileHeader = getFileHeaderList(tableStr + &quot;.db&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileHeader.size() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.toString();
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; fileContent = getFileContentList(tableStr + &quot;.db&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             String[] columnArray = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; print header&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (columnStr.equals(&quot;*&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 columnArray = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[fileHeader.size()];
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String column : fileHeader) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                    result.append(column);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (i != fileHeader.size() - 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                         result.append(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                     columnArray[i++] =&lt;span&gt; column;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                 result.append(&quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; check&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; checkSelect = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 columnArray = columnStr.split(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; columnArray.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                     checkSelect = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; fileHeader.size(); j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (columnArray[i].trim().equals(fileHeader.get(j))) {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                             checkSelect = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;checkSelect) {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                         String falseColumn =&lt;span&gt; columnArray[i].trim();
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                         result.append(&quot;Unknow column:&quot; + falseColumn + &quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;checkSelect) {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.toString();
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                 } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; print header&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; columnArray.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                    result.append(columnArray[i]);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (i != columnArray.length - 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                         result.append(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                         result.append(&quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; print content&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!whereStr.equals(&quot;&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 String[] whereExp = whereStr.split(&quot;and&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for each row check where condition&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (Map&amp;lt;String, String&amp;gt;&lt;span&gt; rowMap : fileContent) {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; checkRow = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; whereExp.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                         String key = whereExp[i].split(&quot;=&quot;)[0&lt;span&gt;].trim();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                         String value = whereExp[i].split(&quot;=&quot;)[1&lt;span&gt;].trim();
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                         String fileContentValue =&lt;span&gt; rowMap.get(key);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;value.equals(fileContentValue)) {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                             checkRow = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (checkRow) {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; columnArray.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;                            result.append(rowMap.get(columnArray[i]));
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (i != columnArray.length - 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                                 result.append(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;                                 result.append(&quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (Map&amp;lt;String, String&amp;gt;&lt;span&gt; rowMap : fileContent) {
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; columnArray.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;                        result.append(rowMap.get(columnArray[i]));
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (i != columnArray.length - 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;                             result.append(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;                             result.append(&quot;\r\n&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.toString();
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;Incorrect SQL.&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getFileHeaderList(String fileName) {
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;         List&amp;lt;String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         InputStream fis = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;         InputStreamReader isr = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         BufferedReader br = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;             fis = MyUtil.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/&quot;+&lt;span&gt;fileName);
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fis == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                 System.out.println(&quot;File not found:[&quot; + fileName + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;             isr = &lt;span&gt;new&lt;/span&gt; InputStreamReader(fis, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;             br = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;             String line = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                 String[] rowInfo = line.split(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; rowInfo.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;                    result.add(rowInfo[i]);
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;                    br.close();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                    isr.close();
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;                    fis.close();
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; 
&lt;span&gt;221&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt; getFileContentList(String fileName) {
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;         List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         InputStream fis = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;         InputStreamReader isr = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;         BufferedReader br = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;             fis = MyUtil.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/&quot;+&lt;span&gt;fileName);
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fis == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;                 System.out.println(&quot;File not found:[&quot; + fileName + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;             isr = &lt;span&gt;new&lt;/span&gt; InputStreamReader(fis, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             br = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(isr);
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;             String[] headerInfo = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             String line = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; ((line = br.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (headerInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;                     headerInfo = line.split(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;                     String[] rowInfo = line.split(&quot;,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (rowInfo.length !=&lt;span&gt; headerInfo.length) {
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;                         System.out.println(&quot;Parse file error:[&quot; + fileName + &quot;]&quot; +&lt;span&gt; line);
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;                     Map&amp;lt;String, String&amp;gt; rowInfoMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; rowInfo.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;                        rowInfoMap.put(headerInfo[i], rowInfo[i]);
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; &lt;span&gt;                    result.add(rowInfoMap);
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;                    br.close();
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (isr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; &lt;span&gt;                    isr.close();
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; &lt;span&gt;                    fis.close();
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyUtil.java&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;总结&lt;br/&gt;本章中我们学习了if，while语句，和数组的读取。&lt;br/&gt;请大家自己完成if，while的学习和switch,for等流程控制语句的用法，以及一维数组，二维数组的创建和读取。&lt;/p&gt;&lt;p&gt;为什么要自己学？&lt;br/&gt;Java的任何单独的知识点，大家用很短的时间都可以很快自学掌握，所以这部分没有必要花时间做逐一的介绍。&lt;br/&gt;Java学习的最大困难在于知识点太多，太散，不知道核心在哪，怎么用。&lt;br/&gt;所以本教程的目的是解决上述问题，用一个简单的例子不断扩展，进而达到主干分明的学习目的，同时培养了大家的自学能力和对主干的深化认识。&lt;br/&gt;从而达到对自己的路有个明确的把握和在主干的基础上不断的适应新环境的学习能力。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;版权声明：本教程版权归java123.vip所有，禁止任何形式的转载与引用。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 19:10:00 +0000</pubDate>
<dc:creator>java123.vip</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java123vip/p/8975517.html</dc:identifier>
</item>
<item>
<title>【封装型坏味】 泄露的封装 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8975354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8975354.html</guid>
<description>&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180430/hlFKAlhh5F.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;抽象通过公有接口（方法）暴露或泄露实现细节时，将导致这种坏味。需要注意的是，即使抽象不存在“&lt;a href=&quot;http://www.cnblogs.com/songwenjie/p/8974296.html&quot;&gt;不充分的封装&lt;/a&gt;”坏味，其公有接口也有可能泄露实现细节。&lt;/p&gt;
&lt;h2 id=&quot;为什么不能泄露封装&quot;&gt;为什么不能泄露封装？&lt;/h2&gt;
&lt;p&gt;为实现有效封装，必须将抽象的接口（即抽象的内容）和实现（即抽象的方式）分离。为遵循隐藏原则，必须对客户程序隐藏抽象的实现方面。&lt;/p&gt;
&lt;p&gt;如果通过公有接口暴露了实现细节（违反了隐藏原则）可能会造成:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对实现进行修改时，可能会影响客户程序&lt;/li&gt;
&lt;li&gt;暴露的实现细节可能会让客户程序能够通过公有接口访问内部数据结构，进而有意或无意地损坏抽象的内部状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;泄露的封装的潜在原因&quot;&gt;泄露的封装的潜在原因&lt;/h2&gt;
&lt;h3 id=&quot;不知道该隐藏哪些东西&quot;&gt;不知道该隐藏哪些东西&lt;/h3&gt;
&lt;p&gt;开发人员通常会在无意之间泄露实现细节。&lt;/p&gt;
&lt;h3 id=&quot;使用细粒度接口&quot;&gt;使用细粒度接口&lt;/h3&gt;
&lt;p&gt;类的公有接口直接提供了细粒度的方法，这些细粒度的方法通常会向客户程序暴露不必要的实现细节。更好的做法是在类的公有接口提供粗粒度的方法，在粗粒度方法内部使用细粒度的私有方法。&lt;/p&gt;
&lt;h2 id=&quot;示例分析一&quot;&gt;示例分析一&lt;/h2&gt;
&lt;p&gt;我们用程序来维护一个待办事项列表。在ToDoList类中，公有方法GetListEntries()返回对象存储的待办事项列表。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ToDoList
{
    private List&amp;lt;string&amp;gt; listEntries = new List&amp;lt;string&amp;gt;();

    public List&amp;lt;string&amp;gt; GetListEntries()
    {
        return listEntries;
    }

    public void AddListEntry(string entry)
    {
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题出在方法的返回类型上，它暴露了一个内部细节，ToDoList内部使用List来存储待办事项列表。&lt;/p&gt;
&lt;p&gt;现在问题来了，如果待办事项列表程序主要执行插入和删除操作，那么选择使用List没啥问题；但是后来发现查找频率比修改频率高，那么使用HashTable可能更合适。然而GetListEntries()的返回类型是List，如果修改这个方法的返回类型，可能破坏依赖于这个方法的客户程序。如果要支持未来数据结构的变更，方法返回类型可以使用IEnumerable（C#中的集合类型都实现的接口类型），这样可以做到在不改变方法签名的条件下(里氏替换原则)，替换存储待办事项列表的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重构后的代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用List数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ToDoList
{
    private List&amp;lt;string&amp;gt; listEntries = new List&amp;lt;string&amp;gt;();

    public IEnumerable GetListEntries()
    {
        return listEntries;
    }

    public void AddListEntry(string entry)
    {
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Hashtable数据结构：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ToDoList
{
    private Hashtable listEntries = new Hashtable();

    public IEnumerable GetListEntries()
    {
        return listEntries;
    }

    public void AddListEntry(string entry)
    {
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法GetListEntries()存在另一个严重的问题是，它返回一个指向内部数据结构的引用，通过这个引用，客户程序可以绕过AddListEntry()方法直接修改数据结构。当然如果使用IEnumerable这个问题也就迎刃而解了，因为IEnumerable接口没有相应的针对于某一种数据集合的操作。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IEnumerable
{
    //
    // 摘要:
    //     返回循环访问集合的枚举数。
    //
    // 返回结果:
    //     一个可用于循环访问集合的 System.Collections.IEnumerator 对象。
    [DispId(-4)]
    IEnumerator GetEnumerator();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例分析二&quot;&gt;示例分析二&lt;/h2&gt;
&lt;p&gt;假设显式图像包含4个步骤，这些步骤必须按照特定顺序执行，图形才可以正常显式。&lt;/p&gt;
&lt;p&gt;现在在Image类中提供4个公有方法Load(),Process(),Validate(),Show()供客户程序使用，但是这样有一个很麻烦的问题是写客户程序的开发人员不一定会按照正确顺序调用方法使用（永远不要给客户选择的权利）。而且客户程序只是想要显式图像，我们为什么要向它们暴露4个内部步骤呢？这就是泄露的封装的潜在原因——使用细粒度接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Image
{
    public void Load()
    {
    }
    public void Process()
    {
    }
    public void Validate()
    {
    }
    public void Show()
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要解决这个问题，可以让Image类只向客户程序暴露一个方法Display()，然后在这个方法内部按照特定顺序调用4个步骤方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Image
{
    private void Load()
    {
    }
    private void Process()
    {
    }
    private void Validate()
    {
    }
    private void Show()
    {
    }

    public void Display()
    {
        Load();
        Process();
        Validate();
        Show();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;抽象通过公有接口暴露或泄露了实现细节时，客户程序可能直接依赖于实现细节吗，这种直接依赖性使得难以在不破坏既有客户代码的情况下对设计进行修改或扩展。&lt;/li&gt;
&lt;li&gt;抽象泄露了内部数据结构时，抽象的完整性遭到了破坏。增加了代码运行阶段发生问题的可能性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考：《软件设计重构》&lt;/p&gt;

&lt;div class=&quot;content&quot; readability=&quot;26.253521126761&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Mon, 30 Apr 2018 17:17:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8975354.html</dc:identifier>
</item>
<item>
<title>JSONP跨域 - qfstudy</title>
<link>http://www.cnblogs.com/qfstudy/p/8975444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qfstudy/p/8975444.html</guid>
<description>&lt;p&gt;1.浏览器的同源策略&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;2.一个源的定义&lt;br/&gt;如果两个页面的协议，端口和域名都相同，则两个页面具有相同的源，这就是同源。&lt;br/&gt;&lt;code&gt;http://www.example.com/dir/page.html&lt;/code&gt;这个网址，协议是&lt;code&gt;http://&lt;/code&gt;，域名是&lt;code&gt;www.example.com&lt;/code&gt;，端口是&lt;code&gt;80&lt;/code&gt;（默认端口可以省略）。它的同源情况如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;http://www.example.com/dir2/other.html：&lt;/code&gt;同源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://example.com/dir/other.html：&lt;/code&gt;不同源（域名不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://v2.www.example.com/dir/other.html：&lt;/code&gt;不同源（域名不同）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://www.example.com:81/dir/other.html：&lt;/code&gt;不同源（端口不同）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;参考文章&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;同源政策规定，AJAX请求只能发给同源的网址，否则就报错。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JSONP实现跨域访问数据&lt;/p&gt;
&lt;p&gt;JSONP(JSON with Padding)是JSON的一种“使用模式”&lt;br/&gt;由于同源策略，一般来说位于 &lt;code&gt;server1.example.com&lt;/code&gt; 的网页无法与不是&lt;code&gt;server1.example.com&lt;/code&gt;的服务器沟通，而 &lt;code&gt;HTML&lt;/code&gt; 的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素是一个例外。&lt;/p&gt;
&lt;p&gt;ajax请求受同源策略影响，不允许进行跨域请求&lt;/p&gt;
&lt;p&gt;而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。&lt;/p&gt;
&lt;p&gt;JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。&lt;/p&gt;
&lt;p&gt;JSONP的基本思想是，动态创建一个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素，script元素发送请求不熟同源政策的限制，只能发送get请求。服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;//SRL server rendered javascript
        button.addEventListener('click', (e) =&amp;gt; {
            //动态创建script
            var script = document.createElement('script')
            let functionName='blog1'+parseInt(Math.random()*100000,10)
            
            //callback
            window[functionName]=function(result){
                if(result==='success'){
                    amount.innerText=amount.innerText-1
                }else{} 
            }
            //发送请求
            script.src = 'http://feile.com/pay?callback='+functionName
            document.body.appendChild(script)
            
            script.onload = function (e) {
                // debugger
                e.currentTarget.remove()
                delete window[functionName]
            }
            script.onerror = function (e) {
                alert('fail')
                e.currentTarget.remove()
                delete window[functionName]
            }
        })
    &amp;lt;/script&amp;gt;
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码通过动态创建添加script元素，向服务器发送请求，查询字符串必须有callback参数，用来指定回调函数的名字。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;response.write(`${query.callback}.call(undefined,'success')`)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。这时只要浏览器定义了对应的回调函数，该函数就会立即被调用。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/qfstudy/JSONP&quot;&gt;源码下载链接:Github&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Mon, 30 Apr 2018 17:03:00 +0000</pubDate>
<dc:creator>qfstudy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qfstudy/p/8975444.html</dc:identifier>
</item>
<item>
<title>第一次作业：基于Linux操作系统深入源码进程模型分析 - 麦氏</title>
<link>http://www.cnblogs.com/maishistar/p/8974598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maishistar/p/8974598.html</guid>
<description>&lt;h3&gt;1.Linux操作系统的简易介绍&lt;/h3&gt;
&lt;p&gt;　　Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。　　　　&lt;/p&gt;
&lt;p&gt;（1）内核&lt;/p&gt;
&lt;p&gt;　　内核是操作系统的核心，具有很多最基本功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP/IP网络功能。Linux内核的模块分为以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等。&lt;/p&gt;
&lt;p&gt;（2）shell&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;　　shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;（3）文件系统&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;　　文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、EXT3、FAT、FAT32、VFAT和ISO9660。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;（4）应用程序&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt;　　标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、XWindow、办公套件、Internet工具和数据库等。&lt;/p&gt;
&lt;p class=&quot;best-text mb-10&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;best-text mb-10&quot;&gt;2.Linux操作系统的进程组织&lt;/h3&gt;
&lt;p&gt;（1）什么是进程&lt;/p&gt;
&lt;p&gt;　　进程是处于执行期的程序以及它所包含的所有资源的总称，包括虚拟处理器，虚拟空间，寄存器，堆栈，全局数据段等。&lt;/p&gt;
&lt;p&gt;　　在Linux中，每个进程在创建时都会被分配一个数据结构，称为进程控制（Process Control Block，简称PCB）。PCB中包含了很多重要的信息，供系统调度和进程本身执行使用。所有进程的PCB都存放在内核空间中。PCB中最重要的信息就是进程PID，内核通过这个PID来唯一标识一个进程。PID可以循环使用，最大值是32768。init进程的pid为1，其他进程都是init进程的后代。&lt;/p&gt;
&lt;p&gt;　　除了进程控制块（PCB）以外，每个进程都有独立的内核堆栈（8k），一个进程描述符结构，这些数据都作为进程的控制信息储存在内核空间中；而进程的用户空间主要存储代码和数据。&lt;/p&gt;
&lt;p&gt;查看进程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235810/201804/1235810-20180430223100344-1862436725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）进程创建&lt;/p&gt;
&lt;p&gt;　　进程是通过调用::fork()，::vfork()【&lt;em&gt;只复制task_struct和内核堆栈，所以生成的只是父进程的一个线程（无独立的用户空间）。&lt;/em&gt;】和::clone()【&lt;em&gt;功能强大，带了许多参数。::clone()可以让你有选择性的继承父进程的资源，既可以选择像::vfork()一样和父进程共享一个虚拟空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。&lt;/em&gt;】系统调用创建新进程。在内核中，它们都是调用do_fork实现的。传统的fork函数直接把父进程的所有资源复制给子进程。而Linux的::fork()使用写时拷贝页实现，也就是说，父进程和子进程共享同一个资源拷贝，只有当数据发生改变时，数据才会发生复制。通常的情况，子进程创建后会立即调用exec()，这样就避免复制父进程的全部资源。&lt;/p&gt;
&lt;p&gt;　　　　#fork()：父进程的所有数据结构都会复制一份给子进程（写时拷贝页）。当执行fork()函数后，会生成一个子进程，子进程的执行从fork()的返回值开始，且代码继续往下执行&lt;/p&gt;
&lt;p&gt;以下代码中，使用fork()创建了一个子进程。返回值pId有两个作用：一是判断fork()是否正常执行；二是判断fork()正常执行后如何区分父子进程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #&lt;span&gt;代码示例：
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;  
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;  
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;  
&lt;span&gt; 5&lt;/span&gt;   
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **&lt;span&gt; argv) {  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; flag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     pid_t pId =&lt;span&gt; fork();  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pId == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        exit(EXIT_FAILURE);  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pId == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; myPid =&lt;span&gt; getpid();  
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; parentPid =&lt;span&gt; getppid();  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;           
&lt;span&gt;16&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child:SelfID=%d ParentID=%d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, myPid, parentPid);  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         flag = &lt;span&gt;123&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child:flag=%d %p \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, flag, &amp;amp;&lt;span&gt;flag);  
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {  
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             count++&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child count=%d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, count);  
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }  
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; EXIT_SUCCESS;  
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {  
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Parent:SelfID=%d MyChildPID=%d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getpid(), pId);  
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         flag = &lt;span&gt;456&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Parent:flag=%d %p \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, flag, &amp;amp;flag); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连地址都一样,说明是真的完全拷贝,但值已经是不同的了..  &lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {  
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             count++&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Parent count=%d \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, count);  
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }  
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         } &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;       
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; EXIT_SUCCESS;  
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）进程撤销&lt;/p&gt;
&lt;p&gt;　　进程通过调用exit()退出执行，这个函数会终结进程并释放所有的资源。父进程可以通过wait4()查询子进程是否终结。进程退出执行后处于僵死状态，直到它的父进程调用wait()或者waitpid()为止。父进程退出时，内核会指定线程组的其他进程或者init进程作为其子进程的新父进程。当进程接收到一个不能处理或忽视的信号时，或当在内核态产生一个不可恢复的CPU异常而内核此时正代表该进程在运行，内核可以强迫进程终止。&lt;/p&gt;

&lt;p&gt;（4）进程管理&lt;/p&gt;
&lt;p&gt;　　内核把进程信息存放在叫做任务队列（task list）的双向循环链表中（内核空间）。链表中的每一项都是类型为task_struct，称为进程描述符结构（process descriptor），包含了一个具体进程的所有信息，包括打开的文件，进程的地址空间，挂起的信号，进程的状态等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235810/201804/1235810-20180430220213357-1539761746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Linux通过slab分配器分配task_struct，这样能达到对象复用和缓存着色（通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235810/201804/1235810-20180430220312296-1195003528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; task_struct 
{
&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; state;
pid_t pid;
unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timestamp;
unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; rt_priority;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; mm_struct *mm, *&lt;span&gt;active_mm
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于向下增长的栈来说，只需要在栈底(对于向上增长的栈则在栈顶)创建一个新的结构struct thread_info，使得在汇编代码中计算其偏移量变得容易。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#在x86上，thread_info结构在文件&amp;lt;asm/thread_info.h&amp;gt;中定义如下：&lt;br/&gt;struct&lt;/span&gt;&lt;span&gt; thread_info{
             &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; task_struct              *&lt;span&gt;任务
             &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; exec_domain              *&lt;span&gt;exec_domain;
             unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;                   flags;
             unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;                   status;
             __u32                           cpu;
             __s32                           preempt_count;
             mm_segment_t                    addr_limit;
             &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; restart_block            restart_block;
             unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;                   previous_esp;
             _u8                             supervisor_stack[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　内核把所有处于TASK_RUNNING状态的进程组织成一个可运行双向循环队列。调度函数通过扫描整个可运行队列，取得最值得执行的进程投入执行。避免扫描所有进程，提高调度效率。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#进程调度使用schedule()函数来完成，下面我们从分析该函数开始，代码如下：
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; asmlinkage __visible &lt;span&gt;void&lt;/span&gt; __sched schedule(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; task_struct *tsk =&lt;span&gt; current;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;&lt;span&gt;     sched_submit_work(tsk);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;     __schedule();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; EXPORT_SYMBOL(schedule);&lt;br/&gt;#在第4段进程调度中将具体讲述功能实现
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（5）进程内核堆栈&lt;/p&gt;
&lt;p&gt;　　Linux为每个进程分配一个8KB大小的内存区域，用于存放该进程两个不同的数据结构：thread_info和进程的内核堆栈。&lt;/p&gt;
&lt;p&gt;　　进程处于内核态时使用不同于用户态堆栈，内核控制路径所用的堆栈很少，因此对栈和描述符来说，8KB足够了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235810/201804/1235810-20180430220636199-1749319156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.Linux操作系统的进程状态转换&lt;/h3&gt;
&lt;p&gt;有以下进程状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235810/201804/1235810-20180430222123398-216386487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进程状态的转换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1235810/201804/1235810-20180430180237625-165652732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体转换分析：&lt;/p&gt;
&lt;p&gt;（1）进程的初始状态&lt;/p&gt;
&lt;p&gt;进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。）那么既然调用进程处于TASK_RUNNING状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于TASK_RUNNING状态。另外，在系统调用调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。&lt;/p&gt;

&lt;p&gt;（2）进程状态变迁&lt;/p&gt;
&lt;p&gt;进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入 TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。&lt;/p&gt;
&lt;p&gt;而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；&lt;/li&gt;
&lt;li&gt;执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit 系统调用）；或由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4.Linux操作系统的进程调度&lt;/h3&gt;
&lt;p&gt; 　毋庸置疑，我们使用schedule()函数来完成进程调度，接下来就来看看进程调度的代码以及实现过程吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; asmlinkage __visible &lt;span&gt;void&lt;/span&gt; __sched schedule(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; task_struct *tsk =&lt;span&gt; current;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;&lt;span&gt;     sched_submit_work(tsk);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;     __schedule();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; EXPORT_SYMBOL(schedule);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　第3行获取当前进程描述符指针，存放在本地变量tsk中。第6行调用__schedule()，代码如下（kernel/sched/core.c）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_7f1a8d85-1af9-4071-ace6-3955b3087333&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7f1a8d85-1af9-4071-ace6-3955b3087333&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7f1a8d85-1af9-4071-ace6-3955b3087333&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __sched __schedule(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; task_struct *prev, *&lt;span&gt;next;
 &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; *&lt;span&gt;switch_count;
 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; rq *&lt;span&gt;rq;
 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cpu;
 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
 &lt;span&gt;8&lt;/span&gt;&lt;span&gt; need_resched:
 &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;     preempt_disable();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     cpu =&lt;span&gt; smp_processor_id();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     rq =&lt;span&gt; cpu_rq(cpu);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;     rcu_note_context_switch(cpu);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     prev = rq-&amp;gt;&lt;span&gt;curr;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;&lt;span&gt;     schedule_debug(prev);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sched_feat(HRTICK))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;         hrtick_clear(rq);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
21      * Make sure that signal_pending_state()-&amp;gt;signal_pending() below
22      * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
23      * done by the caller to avoid the race with signal_wake_up().
24      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;&lt;span&gt;     smp_mb__before_spinlock();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     raw_spin_lock_irq(&amp;amp;rq-&amp;gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     switch_count = &amp;amp;prev-&amp;gt;&lt;span&gt;nivcsw;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (prev-&amp;gt;state &amp;amp;&amp;amp; !(preempt_count() &amp;amp;&lt;span&gt; PREEMPT_ACTIVE)) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (unlikely(signal_pending_state(prev-&amp;gt;&lt;span&gt;state, prev))) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             prev-&amp;gt;state =&lt;span&gt; TASK_RUNNING;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;             deactivate_task(rq, prev, DEQUEUE_SLEEP);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             prev-&amp;gt;on_rq = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
37              * If a worker went to sleep, notify and ask workqueue
38              * whether it wants to wake up a task to maintain
39              * concurrency.
40              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (prev-&amp;gt;flags &amp;amp;&lt;span&gt; PF_WQ_WORKER) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;struct&lt;/span&gt; task_struct *&lt;span&gt;to_wakeup;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;                 to_wakeup =&lt;span&gt; wq_worker_sleeping(prev, cpu);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (to_wakeup)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;&lt;span&gt;                     try_to_wake_up_local(to_wakeup);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;&lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         switch_count = &amp;amp;prev-&amp;gt;&lt;span&gt;nvcsw;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (prev-&amp;gt;on_rq || rq-&amp;gt;skip_clock_update &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;&lt;span&gt;         update_rq_clock(rq);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     next =&lt;span&gt; pick_next_task(rq, prev);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;&lt;span&gt;     clear_tsk_need_resched(prev);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;&lt;span&gt;     clear_preempt_need_resched();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     rq-&amp;gt;skip_clock_update = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (likely(prev !=&lt;span&gt; next)) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         rq-&amp;gt;nr_switches++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         rq-&amp;gt;curr =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         ++*&lt;span&gt;switch_count;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         context_switch(rq, prev, next); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; unlocks the rq &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
67          * The context switch have flipped the stack from under us
68          * and restored the local variables which were saved when
69          * this task called schedule() in the past. prev == current
70          * is still correct, but it can be moved to another cpu/rq.
71          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;         cpu =&lt;span&gt; smp_processor_id();
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         rq =&lt;span&gt; cpu_rq(cpu);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;         raw_spin_unlock_irq(&amp;amp;rq-&amp;gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;&lt;span&gt;     post_schedule(rq);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;&lt;span&gt;     sched_preempt_enable_no_resched();
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (need_resched())
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; need_resched;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;static void __sched __schedule(void)&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　第9行禁止内核抢占。第10行获取当前的cpu号。第11行获取当前cpu的进程运行队列。第13行将当前进程的描述符指针保存在prev变量中。第55行将下一个被调度的进程描述符指针存放在next变量中。第56行清除当前进程的内核抢占标记。第60行判断当前进程和下一个调度的是不是同一个进程，如果不是的话，就要进行调度。第65行，对当前进程和下一个进程的上下文进行切换（调度之前要先切换上下文）。下面看看该函数（kernel/sched/core.c）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_181f3cdf-ca1b-4fdc-ace3-3cf2a7fa5096&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_181f3cdf-ca1b-4fdc-ace3-3cf2a7fa5096&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_181f3cdf-ca1b-4fdc-ace3-3cf2a7fa5096&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;1&lt;/span&gt; context_switch(&lt;span&gt;struct&lt;/span&gt; rq *rq, &lt;span&gt;struct&lt;/span&gt; task_struct *&lt;span&gt;prev,
 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;            &lt;span&gt;struct&lt;/span&gt; task_struct *&lt;span&gt;next)
 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; mm_struct *mm, *&lt;span&gt;oldmm;
 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
 &lt;span&gt;6&lt;/span&gt;&lt;span&gt;     prepare_task_switch(rq, prev, next);
 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
 &lt;span&gt;8&lt;/span&gt;     mm = next-&amp;gt;&lt;span&gt;mm;
 &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     oldmm = prev-&amp;gt;&lt;span&gt;active_mm;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
11      * For paravirt, this is coupled with an exit in switch_to to
12      * combine the page table reload and the switch backend into
13      * one hypercall.
14      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;&lt;span&gt;     arch_start_context_switch(prev);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mm) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         next-&amp;gt;active_mm =&lt;span&gt; oldmm;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         atomic_inc(&amp;amp;oldmm-&amp;gt;&lt;span&gt;mm_count);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;         enter_lazy_tlb(oldmm, next);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;&lt;span&gt;         switch_mm(oldmm, mm, next);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!prev-&amp;gt;&lt;span&gt;mm) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         prev-&amp;gt;active_mm =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         rq-&amp;gt;prev_mm =&lt;span&gt; oldmm;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
29      * Since the runqueue lock will be released by the next
30      * task (which is an invalid locking op but in the case
31      * of the scheduler it's an obvious special-case), so we
32      * do an early lockdep release here:
33      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;&lt;span&gt; #ifndef __ARCH_WANT_UNLOCKED_CTXSW
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     spin_release(&amp;amp;rq-&amp;gt;&lt;span&gt;lock&lt;/span&gt;.dep_map, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, _THIS_IP_);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;&lt;span&gt;     context_tracking_task_switch(prev, next);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Here we just switch the register state and the stack. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;&lt;span&gt;     switch_to(prev, next, prev);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;&lt;span&gt;     barrier();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
44      * this_rq must be evaluated again because prev may have moved
45      * CPUs since it called schedule(), thus the 'rq' on its stack
46      * frame will be invalid.
47      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;&lt;span&gt;     finish_task_switch(this_rq(), prev);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;context_switch(struct rq *rq, struct task_struct *prev, struct task_struct *next)&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　上下文切换一般分为两个，一个是硬件上下文切换（指的是cpu寄存器，要把当前进程使用的寄存器内容保存下来，再把下一个程序的寄存器内容恢复），另一个是切换进程的地址空间（说白了就是程序代码）。进程的地址空间（程序代码）主要保存在进程描述符中的struct mm_struct结构体中，因此该函数主要是操作这个结构体。第17行如果被调度的下一个进程地址空间mm为空，说明下个进程是个线程，没有独立的地址空间，共用所属进程的地址空间，因此第18行将上个进程所使用的地址空间active_mm指针赋给下一个进程的该域，下一个进程也使用这个地址空间。第22行，如果下个进程地址空间不为空，说明下个进程有自己的地址空间，那么执行switch_mm切换进程页表。第40行切换进程的硬件上下文。 switch_to函数代码如下（arch/x86/include/asm/switch_to.h）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_9ea62d95-9b20-421d-91fb-ab147fdea777&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9ea62d95-9b20-421d-91fb-ab147fdea777&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9ea62d95-9b20-421d-91fb-ab147fdea777&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;1&lt;/span&gt; __visible __notrace_funcgraph &lt;span&gt;struct&lt;/span&gt; task_struct *
 &lt;span&gt;2&lt;/span&gt; __switch_to(&lt;span&gt;struct&lt;/span&gt; task_struct *prev_p, &lt;span&gt;struct&lt;/span&gt; task_struct *&lt;span&gt;next_p)
 &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; thread_struct *prev = &amp;amp;prev_p-&amp;gt;&lt;span&gt;thread,
 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                  *next = &amp;amp;next_p-&amp;gt;&lt;span&gt;thread;
 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; cpu =&lt;span&gt; smp_processor_id();
 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; tss_struct *tss = &amp;amp;&lt;span&gt;per_cpu(init_tss, cpu);
 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;     fpu_switch_t fpu;
 &lt;/span&gt;&lt;span&gt;9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; never put a printk in __switch_to... printk() calls wake_up*() indirectly &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     fpu =&lt;span&gt; switch_fpu_prepare(prev_p, next_p, cpu);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
15      * Reload esp0.
16      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;&lt;span&gt;     load_sp0(tss, next);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
20      * Save away %gs. No need to save %fs, as it was saved on the
21      * stack on entry.  No need to save %es and %ds, as those are
22      * always kernel segments while inside the kernel.  Doing this
23      * before setting the new TLS descriptors avoids the situation
24      * where we temporarily have non-reloadable segments in %fs
25      * and %gs.  This could be an issue if the NMI handler ever
26      * used %fs or %gs (it does not today), or if the kernel is
27      * running inside of a hypervisor layer.
28      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     lazy_save_gs(prev-&amp;gt;&lt;span&gt;gs);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
32      * Load the per-thread Thread-Local Storage descriptor.
33      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;&lt;span&gt;     load_TLS(next, cpu);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
37      * Restore IOPL if needed.  In normal use, the flags restore
38      * in the switch assembly will handle this.  But if the kernel
39      * is running virtualized at a non-zero CPL, the popf will
40      * not restore flags, so it must be done in a separate step.
41      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (get_kernel_rpl() &amp;amp;&amp;amp; unlikely(prev-&amp;gt;iopl != next-&amp;gt;&lt;span&gt;iopl))
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         set_iopl_mask(next-&amp;gt;&lt;span&gt;iopl);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
46      * If it were not for PREEMPT_ACTIVE we could guarantee that the
47      * preempt_count of all tasks was equal here and this would not be
48      * needed.
49      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     task_thread_info(prev_p)-&amp;gt;saved_preempt_count =&lt;span&gt; this_cpu_read(__preempt_count);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     this_cpu_write(__preempt_count, task_thread_info(next_p)-&amp;gt;&lt;span&gt;saved_preempt_count);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
54      * Now maybe handle debug registers and/or IO bitmaps
55      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (unlikely(task_thread_info(prev_p)-&amp;gt;flags &amp;amp; _TIF_WORK_CTXSW_PREV ||
&lt;span&gt;57&lt;/span&gt;              task_thread_info(next_p)-&amp;gt;flags &amp;amp;&lt;span&gt; _TIF_WORK_CTXSW_NEXT))
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;&lt;span&gt;         __switch_to_xtra(prev_p, next_p, tss);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
61      * Leave lazy mode, flushing any hypercalls made here.
62      * This must be done before restoring TLS segments so
63      * the GDT and LDT are properly updated, and must be
64      * done before math_state_restore, so the TS bit is up
65      * to date.
66      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;&lt;span&gt;     arch_end_context_switch(next_p);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;&lt;span&gt;     this_cpu_write(kernel_stack,
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;           (unsigned &lt;span&gt;long&lt;/span&gt;)task_stack_page(next_p) +
&lt;span&gt;71&lt;/span&gt;           THREAD_SIZE -&lt;span&gt; KERNEL_STACK_OFFSET);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
74      * Restore %gs if needed (which is common)
75      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (prev-&amp;gt;gs | next-&amp;gt;&lt;span&gt;gs)
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         lazy_load_gs(next-&amp;gt;&lt;span&gt;gs);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;&lt;span&gt;     switch_fpu_finish(next_p, fpu);
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;&lt;span&gt;     this_cpu_write(current_task, next_p);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; prev_p;
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;__visible __notrace_funcgraph struct task_struct * __switch_to(struct task_struct *prev_p, struct task_struct *next_p)&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　该函数主要是对刚切换过来的新进程进一步做些初始化工作。比如第34将该进程使用的线程局部存储段（TLS）装入本地cpu的全局描述符表。第84行返回语句会被编译成两条汇编指令，一条是将返回值prev_p保存到eax寄存器，另外一个是ret指令，将内核栈顶的元素弹出eip寄存器，从这个eip指针处开始执行，也就是上个函数第17行所压入的那个指针。一般情况下，被压入的指针是上个函数第20行那个标号1所代表的地址，那么从__switch_to函数返回后，将从标号1处开始运行。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，对于已经被调度过的进程而言，从__switch_to函数返回后，将从标号1处开始运行；但是对于用fork(),clone()等函数刚创建的新进程（未调度过），将进入ret_from_fork()函数，因为do_fork()函数在创建好进程之后，会给进程的thread_info.ip赋予ret_from_fork函数的地址，而不是标号1的地址，因此它会跳入ret_from_fork函数。后边我们在分析fork系统调用的时候，就会看到。&lt;/p&gt;

&lt;h3&gt;5.对于Linux操作系统进程模型的一些个人看法&lt;/h3&gt;
&lt;p&gt;　　有一个形象的比喻：想象一位知识渊博、经验丰富的工程建筑设计师正在为一个公司设计总部。他有公司建筑的设计图，有所需的建筑材料和工具：水泥、钢筋、木板、挖掘机、吊升机、石钻头等。在这个比喻中，设计图就是程序（即用适当形式描述的算法），工程建筑师就是处理器（CPU），而建筑的各种材料就是输入数据。进程就是建筑工程设计师阅读设计图、取来各种材料和工具以及管理工人员工和分配资源、最后施工等一系列动作的总和，在过程中工程建筑师还需要遵循许多设计的规范和理念（模型），最后完成的公司总部就是软件或者可以实现某种功能的源代码。&lt;/p&gt;
&lt;p&gt;　　这里说明的是进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。那么Linux操作系统进程模型就是活动的规范，规范的出现创新让许多实现过程更加系统完整、安全可靠、速度效率等。&lt;/p&gt;
&lt;p&gt;　　就像人类基于理论实践伟大的工程设计智慧经验结晶，Linux操作系统是系统、效率、安全的，而且通过商业公司、庞大的社区群体、操作系统爱好者是在往前改善的，但如果有一天Linux操作系统闭源了，只有国内开放了源代码，还尚未掌握核心技术，卡住脖子怎么办？我们不能拥有完完全全拿来即用的心态，还需扎实掌握基础知识，提高自我创新意识。对于Linux操作系统进程模型，深入理解它，你会发现在Linux操作系统的应用实践上会愈加效率，同时通过它你可以实现更多好玩的操作。&lt;/p&gt;
&lt;h3&gt;6.参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-9112803-id-2978041.html&quot;&gt;Contiki学习笔记：目录&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://elixir.bootlin.com/linux/v4.6/source&quot; target=&quot;_blank&quot;&gt;源码地址&lt;/a&gt;&lt;/strong&gt;（https://elixir.bootlin.com/linux/v4.6/source）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jb51.net/&quot; target=&quot;_blank&quot;&gt;脚本之家&lt;/a&gt;（http://www.jb51.net/）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/&quot; target=&quot;_blank&quot;&gt;CSDN博客&lt;/a&gt;（https://blog.csdn.net/）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhidao.baidu.com/&quot; target=&quot;_blank&quot;&gt;百度知道&lt;/a&gt;（https://zhidao.baidu.com/）&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 16:30:00 +0000</pubDate>
<dc:creator>麦氏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maishistar/p/8974598.html</dc:identifier>
</item>
<item>
<title>URL重定向漏洞，python打造URL重定向漏洞检测脚本 - 东京$</title>
<link>http://www.cnblogs.com/haq5201314/p/8975380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haq5201314/p/8975380.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天学习了重定向漏洞，这个漏洞比较好理解&lt;/p&gt;
&lt;p&gt;漏洞名：URL重定向漏洞&lt;/p&gt;
&lt;p&gt;威胁：低&lt;/p&gt;
&lt;p&gt;漏洞的来源：开发者对head头做好对应的过滤和限制&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;有漏洞的网站：http://a.com/x.php?url=http://a.com/login.php&lt;/p&gt;
&lt;p&gt;这时我们通过写个url后面的链接让其跳转到指定的页面。例：http;//a.com/x.php?url=http://www.baidu.com&lt;/p&gt;
&lt;p&gt;可搭配使用的漏洞：&lt;/p&gt;
&lt;p&gt;CSRF  当一个网站存在CSRF漏洞的时候，而你知道了创建后台管理员的链接。修改链接，运用URL重定向漏洞。在进行短链生成&lt;/p&gt;
&lt;p&gt;储存型XSS 当一个网站存在储存型XSS漏洞的时候，你插入了一个盗取cookie的js。配合URL重定向漏洞，让受害者直接跳转到该页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用BWAPP这个漏洞网站来进行URL重定向测试。&lt;/p&gt;
&lt;p&gt;http://192.168.3.41/bWAPP/unvalidated_redir_fwd_1.php&lt;/p&gt;
&lt;p&gt;未过滤的重定向与转发&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430234939475-1550024406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Beam按钮跳转到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235134463-164328981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开Burpsuite抓包一看&lt;/p&gt;
&lt;p&gt;发现参数是这样的url=xxxx&amp;amp;form=submit&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235218191-1682462081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发送到repeater&lt;/p&gt;
&lt;p&gt;修改url=http://www.baidu.com&lt;/p&gt;
&lt;p&gt;产生302跳转。跳转页面为http://www.baidu.com&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235349299-334550132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到刚刚的位置放包一看，跳转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235459688-1804189516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;中级尝试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235543233-418253410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一样抓包&lt;/p&gt;
&lt;p&gt;直接进行改链，发现跳回到登录页面。仔细对比发现，中级防御通过cookie的设置来判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235732722-789914809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将其改为0在改其url后面的参数，直接跳转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235807477-1333059374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201804/1174022-20180430235901906-381571351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;高级尝试&lt;/p&gt;
&lt;p&gt;高级和中级防御没区别。只是将cookie后面的值改为2。直接改0，将其链接设置跳转成博客园的链接&lt;/p&gt;
&lt;p&gt;博客园这里要经过两次跳转&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180501000259682-23287394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180501000050200-368504907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180501000222370-1814359159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 验证URl重定向的漏洞脚的本代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests,time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; poc():
    user&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please enter the web site to be tested:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    user2&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please enter the parameters you want to bring in:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    values&lt;/span&gt;=user2.strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[-1&lt;span&gt;]
    params&lt;/span&gt;=&lt;span&gt;{}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; values.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        key,value&lt;/span&gt;=line.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1&lt;span&gt;)
        params[key]&lt;/span&gt;=&lt;span&gt;value
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;URL:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,user)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The parameters you have taken are:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,params)
    time.sleep(&lt;/span&gt;0.2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;If you want to change the parameters, please enter y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Do not need to change to enter n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    user3&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Do you want to change your parameters[y/n]:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user3 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please enter the name of the parameter you want to change{name: value}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(params)
          user4&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please fill in the name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          user5&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please enter the value you want to change:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          params[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(user4)]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(user5)
          &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The change is done, and your current parameter is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,params)
          user6&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Do you want to continue to love the parameters more[y/n]?:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user6 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
              &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
          &lt;span&gt;elif&lt;/span&gt; user6 == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
          &lt;span&gt;elif&lt;/span&gt; user6 == &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

    url&lt;/span&gt;=&lt;span&gt;user.strip()
    headers&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
    rest&lt;/span&gt;=requests.get(url=url,headers=headers,timeout=6,params=params, allow_redirects=&lt;span&gt;False)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Http_code:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,rest.status_code)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(rest.headers)
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(rest.headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rest.headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[*]There is a URL redirection vulnerability in this link&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[+]There is no URL redirection vulnerability in this link&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[-]not Location head&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
poc()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174022/201805/1174022-20180501000440849-1559390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;虽然漏洞威胁不高但还是要防御。防御方法有以下几种：&lt;/p&gt;
&lt;p&gt;可利用state参数进行防跨站攻击，验证302跳转回来带code参数的这个请求是否是攻击者伪造的，防止攻击者伪造请求。&lt;/p&gt;
&lt;p&gt;对于外链攻击，可在支持HTML5浏览器的环境下给所有外部链接加上&lt;code&gt;rel=noreferrer&lt;/code&gt;属性；对于老版本IE的处理方案是利用一个HTTPS进行跳转达到抹去referer的效果&lt;/p&gt;
&lt;p&gt;PHP获取retferer判断来路防止非法访问：http://www.90tec.com/iwork/20.html &lt;/p&gt;
&lt;p&gt;第二种我不喜欢，其他都还好&lt;/p&gt;

</description>
<pubDate>Mon, 30 Apr 2018 16:09:00 +0000</pubDate>
<dc:creator>东京$</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haq5201314/p/8975380.html</dc:identifier>
</item>
<item>
<title>作业 - 粉红猪</title>
<link>http://www.cnblogs.com/dbb99/p/8975329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dbb99/p/8975329.html</guid>
<description>[unable to retrieve full-text content]&gt;&gt;&gt; import turtle &gt;&gt;&gt; turtle.circle(10) &gt;&gt;&gt; turtle.circle(20) &gt;&gt;&gt; turtle.circle(30) &gt;&gt;&gt; turtle.circle(40) &gt;&gt;&gt; turtle.circle(50) &gt;&gt;&gt;</description>
<pubDate>Mon, 30 Apr 2018 15:53:00 +0000</pubDate>
<dc:creator>粉红猪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dbb99/p/8975329.html</dc:identifier>
</item>
<item>
<title>记录一些移动端H5，小程序视觉还原问题及方法 - leung_blog</title>
<link>http://www.cnblogs.com/leungUwah/p/8665637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leungUwah/p/8665637.html</guid>
<description>&lt;p&gt;前端，特别是移动端如果对视觉还原要求比较高的时候。功能测试和性能测试完成之后。UI真的是一个像素一个像素的给你抠出来哪里还原不到位&lt;/p&gt;
&lt;p&gt;之前项目要求还原度要达到98%以上。所以每到视觉还原的时候真的是挺痛苦的，这里记录一些视觉还原不同机型上的一些显示问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;小程序iOS端1rpx显示2px宽度&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个视觉问题这真的是很痛苦的。我们想到针对iOS端单位1rpx，然后transform：scale(0.5);但是会导致个别安卓机型显示特别细，所以这个方案否决了。&lt;/p&gt;
&lt;p&gt;最后使用的是&lt;a href=&quot;http://www.cnblogs.com/leungUwah/p/8519759.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/leungUwah/p/8519759.html&lt;/a&gt;上一篇博文写的方案，后面完美解决&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;明明设置了对应的font-size大小但是还是高度的还原还是对不上&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解决办法：检查一下最外层元素有没有设置font-size:0;取消元素之间的间隙&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;小程序元素高度较小的时候安卓机显示字体偏上问题&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解决办法：不要因为总共20px的高就设置line-height:20px;要设置line-height:1;然后其他的高度用padding撑开；这种情况如果对应有前面跟有icon的话icon的display:inline-block;vertical-align:top;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;数字字体行高与中文不在一个高度上的问题&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解决办法：这就江郎才尽了。数字本来就别中文矮难道每个数字都单独包起来吗，这治标不治本。UI在设计的时候工具弄的多好看多好看都是建立在某个较好状态数字下的或者其他显示，前端做出来&lt;/p&gt;
&lt;p&gt;之后显示肯定是动态的这还真没办法。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;小程序icon图片background-image显示rpx单位显示边缘有较细微显示不完整问题&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解决办法：有两种1.如果还是用rpx单位，那icon整合成雪碧图的时候对应icon周围留1-2个像素的空白。2.用px单位&lt;a href=&quot;http://www.cnblogs.com/leungUwah/p/8519759.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/leungUwah/p/8519759.html&lt;/a&gt;还是上一篇博文写的方案。&lt;/p&gt;

&lt;p&gt;多用弹性布局，这对视觉还原效果较好可以减少后面不少的麻烦。还有一个就是我很少几乎不用float，脱离文档流还要清除浮动，不然对其他的元素有影响，说不定还会有什么意想不到的bug。还有一个就是&lt;/p&gt;
&lt;p&gt;拿到视觉或者ue搞的时候心里就该先想清除怎么布局了；当然了你这个要根据你的需求显示来的。&lt;/p&gt;

&lt;p&gt;好了，暂时想到的就这么多后面如果后面遇到的话会持续更新。&lt;/p&gt;
&lt;p&gt;4月的最后一天了，抽点时间来写写博客，记录一些自己遇到的疑难杂症，有写得不对的地方希望大家多多指正。&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 15:51:00 +0000</pubDate>
<dc:creator>leung_blog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leungUwah/p/8665637.html</dc:identifier>
</item>
<item>
<title>Android查缺补漏（线程篇）-- IntentService的源码浅析 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/8975114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/8975114.html</guid>
<description>&lt;p&gt;本文作者：&lt;a href=&quot;http://www.cnblogs.com/codingblock/&quot;&gt;CodingBlock&lt;/a&gt; 文章链接：&lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8975114.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/codingblock/p/8975114.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Android中有两个比较容易弄混的概念，Service和Thread，我们都知道这两个东西都可以执行后台任务，但要注意的是Service是跑在主线程中的，如果不做特殊处理是会阻塞主线程的，而IntentService正好弥补了这一点，在&lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8034072.html&quot;&gt;《Android查缺补漏--Service和IntentService》&lt;/a&gt;这篇博文中已经简单介绍过了IntentService的基本用法，本篇博文会将对IntentService的原理做一个简单的分析。&lt;/p&gt;
&lt;h3 id=&quot;一intentservice的初始化分析&quot;&gt;一、IntentService的初始化分析&lt;/h3&gt;
&lt;p&gt;IntentService是一种服务，可以很方便的执行后台异步任务，采用HandlerThread执行任务，当任务执行完毕后，IntentService自动退出。&lt;/p&gt;
&lt;p&gt;相比于普通的Service，IntentService继承了Service，并在其内部创建了HandlerThread和Handler，其中HandlerThread用于执行耗时任务，可以查看IntentService的onCreate方法的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onCreate() {
    // TODO: It would be nice to have an option to hold a partial wakelock
    // during processing, and to have a static startService(Context, Intent)
    // method that would launch the service &amp;amp; hand off a wakelock.

    super.onCreate();
    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
    thread.start();

    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码可以看到，IntentService在onCreate()方法中创建了一个HandlerThread，并为这个HandlerThread绑定了一个Handler（ServiceHandler）。&lt;/p&gt;
&lt;p&gt;注：HandlerThread 是一种具有消息循环的线程，在其内部可以使用handler，其底层实现是内部创建了Looper的线程。&lt;/p&gt;
&lt;h3 id=&quot;二intentservice启动任务过程分析&quot;&gt;二、IntentService启动任务过程分析&lt;/h3&gt;
&lt;p&gt;外界首次调用startService方法来启动IntentService时，就会触发onCreate()方法，完成上面操作。&lt;/p&gt;
&lt;p&gt;当外界每次触发onStart方法时，就会在此方法里面通过ServiceHandler向HandlerThread线程发送消息，onStart方法的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onStart(@Nullable Intent intent, int startId) {
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    msg.obj = intent;
    mServiceHandler.sendMessage(msg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当上面源码中的mServiceHandler.sendMessage方法发送完消息后，在ServiceHandler的handlerMessage方法中就会调用onHandleIntent方法来执行我们创建的异步任务，当执行完onHandleIntent中的代码就会使用stopSelf(msg.arg1)尝试关闭Service。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final class ServiceHandler extends Handler {
    public ServiceHandler(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        onHandleIntent((Intent)msg.obj);
        stopSelf(msg.arg1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于HandlerThread只是一个单线程，所以是串行处理任务。&lt;/p&gt;
&lt;p&gt;（stopSelf():立即停止服务。stopSelf(int startId):尝试停止服务，当还有其他消息未处理，会等待其他消息处理完后再关闭）&lt;/p&gt;
&lt;h3 id=&quot;三intentservice优势&quot;&gt;三、IntentService优势&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;由于IntentService是一个服务，所以在执行后台任务时不容易被杀死，想比而言单纯的开启一个线程来执行后台任务，由于这个进程中没有活动的四大组件，所以非常容易被系统杀死。&lt;/li&gt;
&lt;li&gt;其实在普通的Service中开启一个线程也能达到IntentService的效果，只是这样我们用起来更方便，那么在Service中开启线程或者使用IntentService相比在Activity中开启线程有什么优势呢？在Activity中开启了线程后，当退出了Activity时如果线程中的任务没有执行完毕，线程是不会退出的。而此时再打开同一个Activity又会创建一个新的线程，就是说在Activity中创建的线程不会随着Activity的销毁而销毁，是不可控的。而如果我们在Service中创建了线程，然后如果线程中的任务没有执行完毕，我们可以让Service一直运行在后台去承载这个线程，这样的话我们以后在想操作这个线程的话就可以在外界通过bindService的方式再绑定这个Service，从而可以控制运行在这个Service中的线程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文作者：&lt;a href=&quot;http://www.cnblogs.com/codingblock/&quot;&gt;CodingBlock&lt;/a&gt; 文章链接：&lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8975114.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/codingblock/p/8975114.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文为博客园首发并已同步授权给腾讯云·云+社区！&lt;/p&gt;
</description>
<pubDate>Mon, 30 Apr 2018 15:39:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/8975114.html</dc:identifier>
</item>
<item>
<title>CRM客户关系管理系统（六） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8974063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8974063.html</guid>
<description>&lt;h2&gt;第六章、排序和搜索功能开发&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 6.1.排序功能开发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_sorted_column(column,sorted_column,forloop):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; column &lt;span&gt;in&lt;/span&gt; sorted_column:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果这一列被排序了&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;要判断上一次排序是按什么顺序，本次取反&lt;/span&gt;
        last_sort_index =&lt;span&gt; sorted_column[column]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; last_sort_index.startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用切片，去掉‘-’&lt;/span&gt;
            this_time_sort_index = last_sort_index.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加上 '-'&lt;/span&gt;
            this_time_sort_index = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt; last_sort_index
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; this_time_sort_index
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; forloop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）kingadmin/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_orderby_result(request,querysets,admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

    current_ordered_column &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过前端获取到要排序的字段的索引（是个字符串）&lt;/span&gt;
    orderby_index = request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; orderby_index:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过索引找到要排序的字段,因为索引有可能是负数也有可能是负数，要用绝对值，否则负值的时候取到了其它字段了&lt;/span&gt;
        orderby_key =&lt;span&gt; admin_class.list_display[abs(int(orderby_index))]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;记录下当前是按什么排序字段的&lt;/span&gt;
        current_ordered_column[orderby_key] =&lt;span&gt; orderby_index
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; orderby_index.startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            orderby_key &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; orderby_key

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; querysets.order_by(orderby_key),current_ordered_column
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; querysets,current_ordered_column
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430171616377-249370290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（3）table_obj_list.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;?_o={% get_sorted_column column sorted_column forloop.counter0 %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ column }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430172226316-250395123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （4）添加正序倒序的图标&lt;/p&gt;
&lt;p&gt;Boorstrap组件：https://v3.bootcss.com/components/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430172657386-1021785452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;把bootstrap的fonts静态文件放到kingadmin/staic/fonts下面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430175539498-2080089077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; render_sorted_arrow(column,sorted_column):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;排序的图标&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; column &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sorted_column:
        last_sort_index &lt;/span&gt;=&lt;span&gt; sorted_column[column]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; last_sort_index.startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
            arrow_direction &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bottom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            arrow_direction &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        ele &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;&amp;lt;span class=&quot;glyphicon glyphicon-triangle-%s&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;%&lt;span&gt; arrow_direction
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mark_safe(ele)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）table_obj_list.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;?_o={% get_sorted_column column sorted_column forloop.counter0 %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                {{ column }}{% render_sorted_arrow column sorted_column %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430175050058-918018263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430175140258-1319959456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6.2.分页、排序和过滤组合使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;（1）排序和过滤组合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;table_obj_list.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430205329004-60424957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （2）kingamdin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; render_filtered_args(admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;拼接过滤的字段&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; admin_class.filter_conditions:
        ele &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; k,v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; admin_class.filter_conditions.items():
            ele &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;%s=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(k,v)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mark_safe(ele)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在过滤和排序的组合没有问题，但是分页还没有组合到一起&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; （3）过滤和分页组合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;table_obj_list.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430205609453-1142546932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; kingadmin_tags.py&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430211340310-918991826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;def render_paginator先添加一个参数&lt;span&gt;admin_class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430211425122-541909122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（4）分页、排序、过滤组合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;table_obj_list.py&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430213641978-895572086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; kingadmin_tag.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_current_sorted_column_index(sorted_column):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;三元运算，如果为True执行左边的，为False，执行右边的（''）&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; list(sorted_column.values())[0] &lt;span&gt;if&lt;/span&gt; sorted_column &lt;span&gt;else&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; table_obj_list.py&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430213811237-2131596605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; kingadmin_tag.py&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430214558553-2071735822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在排序、过滤和分页组合就没有问题了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430214652173-698889379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6.3.搜索功能开发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;全局搜索 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）table_obj_list.html&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430220713238-736290820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （2）kingadmin/views.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430220430250-1913166841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Q

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_searched_result(request,querysets,admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;搜索&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

    search_key &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; search_key:
        q &lt;/span&gt;=&lt;span&gt; Q()
        q.connector &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; search_field &lt;span&gt;in&lt;/span&gt;&lt;span&gt; admin_class.search_fields:
            q.children.append((&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s__contains&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;search_field,search_key))

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; querysets.filter(q)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; querysets
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430222457362-437631844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;现在实现的是全局搜索功能（不能过滤的同时搜索）， 下面添加 过滤+搜索的功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;span&gt;过滤+搜索&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 只需要添加一个隐藏标签就可以&lt;/p&gt;
&lt;p&gt;kingadmin/vies.py&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430224129697-593105694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; table_obj_list.html&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430224240171-1205367135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430224341137-1468797068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;功能优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）用户并不知道可以通过哪些字段去搜索，在搜索框里添加提示（placeholder）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430225000030-764385674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;{% for s in admin_class.search_fields %}{{ s }},{% endfor %}&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;_q&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{{ admin_class.search_key }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Search&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {% for k,v in admin_class.filter_conditions.items %}
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;{{ k }}&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{{ v }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {% endfor %}
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; （2）添加Bootstrap样式&lt;/p&gt;
&lt;p&gt; 过滤字段提示和美化&lt;/p&gt;
&lt;p&gt;table_obj_list.html&lt;/p&gt;
&lt;p&gt;“过滤”按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430232812919-1534643399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kingadmin_tags.py&lt;/p&gt;
&lt;p&gt;过滤字段提示+添加框的美化样式&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430233143800-802309758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;末尾要加&amp;lt;/div&amp;gt;闭合&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430233235654-1309686861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180430234339685-1506305235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;代码已同步github &lt;/span&gt; &lt;a href=&quot;https://github.com/derek-zhang123/PerfectCRM&quot;&gt;&lt;span&gt;num6 排序功能开发；分页、排序、筛选组合使用；搜索功能开发&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 30 Apr 2018 15:38:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8974063.html</dc:identifier>
</item>
</channel>
</rss>