<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于Microsoft Graph打造自己的Timeline应用 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/9033990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/9033990.html</guid>
<description>&lt;h4&gt;原文链接：&lt;a title=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/timeline.md&quot; href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/timeline.md&quot;&gt;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/timeline.md&lt;/a&gt; &lt;/h4&gt;

&lt;p&gt;前不久微软正式放出了Windows 10 春季更新（1803），其中有一个非常有特色的应用，就是Windows 10 新增了一个Timeline（时间线）的应用，这个应用可以让用户一目了然地看到最近一段时间所有在Windows中的活动，包括浏览过什么网页，打开过什么文档，设置过什么选项等。下图是一个示范的效果图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-22-16-10.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-22-16-10.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请注意，这里看到的信息不是一个静态的图片，每一个卡片都是可以点击的，而且点击之后会通过调用对应的应用程序自动打开这些活动（恢复到之前的状态），就好像时光倒流了一样。&lt;/p&gt;
&lt;p&gt;看起来很酷，不是吗？那么，这样一个应用到底是怎么实现的呢？我们如果也想实现类似的场景，有什么样的思路呢？答案在上周的Microsoft Build 大会上做了揭晓：其实Timeline是一个基于Microsoft Graph实现的应用，只不过他读取的数据，不仅限于Office 365的文档历史，还包括了Windows 10 上面的活动，这也是近年来一个重大的变化：微软已经把Office 365、Windows 10、EMS这三个产品合并为一个——Microsoft 365，将为最终用户提供最佳的体验，他们的能力也将统一通过Microsoft Graph向开发者提供服务。&lt;/p&gt;

&lt;p&gt;首先，从技术上说，要实现这个Timeline应用，用户需要允许相关的活动源将有关信息发送给Microsoft Graph。这里所谓的&lt;code&gt;活动源&lt;/code&gt;，可以是Office客户端，也可以是Windows 10的应用程序。微软一直致力于保护用户的隐私，所以这个Timeline的功能，默认是不开启的，只有用户在被明确告知上述行为并且选择接受的情况下，才会开始收集数据并进行展现。&lt;/p&gt;
&lt;p&gt;其次，除了Windows 10自带的Timeline应用，其实只要几行代码，就能实现一个类似的时间线应用。那么问题就来了，这些&lt;strong&gt;应用之间的数据是不是隔离的&lt;/strong&gt;呢？答案是肯定的，也就是说Windows 10这个Timeline应用只能读取到它在经用户同意的前提下收集的那部分活动数据，而我们自定义的应用也是如此。&lt;/p&gt;
&lt;p&gt;最后，这里面还有一个有意思的概念。一个活动（Activity）可以对应一个或者多个历史记录（History Items）。历史纪录相当于是活动在某个时间点的快照。&lt;/p&gt;
&lt;blockquote readability=&quot;4.6842105263158&quot;&gt;
&lt;p&gt;据说这个技术，最早在内部有一个代码叫做“Project Rome”，现在合并到了Microsoft Graph中，并且已经在V1.0中提供。相关官方文档请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/concepts/activity-feed-concept-overview&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/concepts/activity-feed-concept-overview&lt;/a&gt; .&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了如上概念，我们就闲话少说，撸起袖子加油干吧。因为要访问Microsoft Graph，所以你就必须要注册一个AAD的应用程序。注册这样一个应用程序没有什么特别的，唯一要了解的是，要支持用户活动的读写，需要申请一个UserActivity.ReadWrite.CreatedByApp的委派权限（Delegated Permission），如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-22-47-02.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-22-47-02.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家可以看到，这个权限并不需要管理员认可就能工作。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;请注意，目前UserActivity.ReadWrite.CreatedByApp这个权限，仅在国际版的环境中可以用，而且必须在AAD 1.0的环境中实现。AAD 2.0还不支持,国内版（Gallatin）也暂时不支持。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Windows 10自带的Timeline其实是一个UWP应用，不过你可以用你最熟悉的方式来实现自定义的Timeline应用。但抛开这些具体的界面，我们可以快速了解一下如何创建和更新用户活动（Activity）。&lt;/p&gt;
&lt;p&gt;创建或更新Activity的API，请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_put_activity&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_put_activity&lt;/a&gt;, 大体上说，这里的关键是用PUT方法操作，同时我们既可以单独创建Activity，也可以在创建Activity的时候同时创建History Item，后者也称为“Deep Insert”。&lt;/p&gt;
&lt;p&gt;为了给大家直观演示效果，我这里简化一下步骤。我将采用官方的Microsoft Graph Explorer来模拟一个客户端，并且直接用REST API来进行操作。如果你对Microsoft Graph Explorer不太熟悉，你可能需要先阅读一下&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/graphexplorer.md&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;正如上一节提到的，你需要确保授予了UserActivity.ReadWrite.CreatedByApp这个权限，请参考下图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-22-54-13.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-22-54-13.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我直接用官方给的例子，为当前用户新增一个网络文章浏览的活动，请注意下面的&lt;code&gt;appActivityId&lt;/code&gt;、&lt;code&gt;activitySourceHost&lt;/code&gt;、&lt;code&gt;activationUrl&lt;/code&gt;、&lt;code&gt;visualElements&lt;/code&gt; 是必须的。这个例子的意思是指定义了用户这个活动是浏览了 &lt;code&gt;&lt;a href=&quot;http://www.contoso.com/article?id=12345&quot; class=&quot;uri&quot;&gt;http://www.contoso.com/article?id=12345&lt;/a&gt;&lt;/code&gt; 这个Url所指向的一篇文章。&lt;/p&gt;
&lt;pre&gt;
{&lt;br/&gt;&quot;appActivityId&quot;: &quot;/article?12345&quot;,&lt;br/&gt;&quot;activitySourceHost&quot;: &quot;&lt;a href=&quot;https://www.contoso.com&quot; class=&quot;uri&quot;&gt;https://www.contoso.com&lt;/a&gt;&quot;,&lt;br/&gt;&quot;userTimezone&quot;: &quot;Africa/Casablanca&quot;,&lt;br/&gt;&quot;appDisplayName&quot;: &quot;Contoso, Ltd.&quot;,&lt;br/&gt;&quot;activationUrl&quot;: &quot;&lt;a href=&quot;http://www.contoso.com/article?id=12345&quot; class=&quot;uri&quot;&gt;http://www.contoso.com/article?id=12345&lt;/a&gt;&quot;,&lt;br/&gt;&quot;contentUrl&quot;: &quot;&lt;a href=&quot;http://www.contoso.com/article?id=12345&quot; class=&quot;uri&quot;&gt;http://www.contoso.com/article?id=12345&lt;/a&gt;&quot;,&lt;br/&gt;&quot;fallbackUrl&quot;: &quot;&lt;a href=&quot;http://www.contoso.com/article?id=12345&quot; class=&quot;uri&quot;&gt;http://www.contoso.com/article?id=12345&lt;/a&gt;&quot;,&lt;br/&gt;&quot;contentInfo&quot;: {&lt;br/&gt;&lt;a href=&quot;mailto:%22@context%22&quot;&gt;&quot;@context&quot;&lt;/a&gt;: &quot;&lt;a href=&quot;http://schema.org&quot; class=&quot;uri&quot;&gt;http://schema.org&lt;/a&gt;&quot;,&lt;br/&gt;&lt;a href=&quot;mailto:%22@type%22&quot;&gt;&quot;@type&quot;&lt;/a&gt;: &quot;Article&quot;,&lt;br/&gt;&quot;author&quot;: &quot;Jennifer Booth&quot;,&lt;br/&gt;&quot;name&quot;: &quot;How to Tie a Reef Knot&quot;&lt;br/&gt;},&lt;br/&gt;&quot;visualElements&quot;: {&lt;br/&gt;&quot;attribution&quot;: {&lt;br/&gt;&quot;iconUrl&quot;: &quot;&lt;a href=&quot;http://www.contoso.com/icon&quot; class=&quot;uri&quot;&gt;http://www.contoso.com/icon&lt;/a&gt;&quot;,&lt;br/&gt;&quot;alternateText&quot;: &quot;Contoso, Ltd.&quot;,&lt;br/&gt;&quot;addImageQuery&quot;: &quot;false&quot;,&lt;br/&gt;},&lt;br/&gt;&quot;description&quot;: &quot;How to Tie a Reef Knot. A step-by-step visual guide to the art of nautical knot-tying.&quot;,&lt;br/&gt;&quot;backgroundColor&quot;: &quot;#ff0000&quot;,&lt;br/&gt;&quot;displayText&quot;: &quot;Contoso How-To: How to Tie a Reef Knot&quot;,&lt;br/&gt;&quot;content&quot;: {&lt;br/&gt;&quot;$schema&quot;: &quot;&lt;a href=&quot;http://adaptivecards.io/schemas/adaptive-card.json&quot; class=&quot;uri&quot;&gt;http://adaptivecards.io/schemas/adaptive-card.json&lt;/a&gt;&quot;,&lt;br/&gt;&quot;type&quot;: &quot;AdaptiveCard&quot;,&lt;br/&gt;&quot;body&quot;:&lt;br/&gt;[{&lt;br/&gt;&quot;type&quot;: &quot;TextBlock&quot;,&lt;br/&gt;&quot;text&quot;: &quot;Contoso MainPage&quot;&lt;br/&gt;}]&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;在Microsoft Graph Explorer 中用PUT方法，将上述数据，发送到&lt;code&gt;&lt;a href=&quot;https://graph.microsoft.com/v1.0/me/activities/%2Farticle%3F12345&quot;&gt;https://graph.microsoft.com/v1.0/me/activities/%2Farticle%3F12345&lt;/a&gt;&lt;/code&gt;, 同时记得设置Content-Type为application/json&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-23-01-36.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-23-01-36.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果一切正常的话，你将收到一个回复，里面包含了在Microsoft Graph中创建的Activity的信息，这里会返回全局唯一的&lt;code&gt;id&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-23-03-20.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-23-03-20.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请注意，如果要更新，也是使用同样的一个命令。而如果要进行删除，则需要用 DELETE 方法，请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_delete_activity&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_delete_activity&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有两个接口用来查询用户活动（Activity），分别是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取用户活动（可以获取全部，也可以获取指定筛选条件的活动），如果需要同时包含历史信息，则需要添加查询参数 $expand=historyitems。 详细的API说明，请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_get_activities&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_get_activities&lt;/a&gt; 。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;获取用户最近的活动。可以理解为上一种的简化版本，Microsoft Graph会查询最近的一个History Items，然后找到它们对应的活动条目。详细的API说明，请参考 &lt;a href=&quot;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_get_recent_activities&quot;&gt;https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/api/projectrome_get_recent_activities&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是一个简单的查询例子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-23-15-40.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/e9b5a59cb827841d36692cc4ec52c11d43062e04/docs/images/2018-05-13-23-15-40.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这一篇文章带领大家了解了Windows 10最新版本中Timeline这个功能的实现原理，并且用实例演示了如何使用Microsoft Graph来实现自定义的类似应用，我用Microsoft Graph Explorer做了演示，大家可以一目了然地看到接口的调用和返回值。&lt;/p&gt;
&lt;p&gt;因为这个功能比较新，Microsoft Graph的SDK中，还没有完全包含这个功能，我还发现.NET SDK中存在一点小问题，已经跟产品团队反馈了。所以，如果你现在开始做实践，建议还使用REST API的方式。&lt;/p&gt;
</description>
<pubDate>Sun, 13 May 2018 15:30:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/9033990.html</dc:identifier>
</item>
<item>
<title>Java多线程问题 - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/9033973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/9033973.html</guid>
<description>&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;一. Java多线程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;Java给多线程编程提供了内置的支持。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;这里定义和线程相关的另一个术语--进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;多线程能满足程序员编写高效率的程序来达到充分利用CPU的目的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;二. 线程的生命周期：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;线程是一个动态的执行过程，它也有从产生到死亡的过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;a) 新建状态:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;使用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序start()这个线程。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;b) 就绪状态:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;c) 运行状态:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;d) 阻塞状态:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：&lt;/span&gt;&lt;/strong&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;e) 死亡状态:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;三. 线程的优先级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;四. 创建一个线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;a) 通过继承Thread类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;b) 通过实现Runnable接口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;c) 通过Callable和Future创建线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;使用FutureTask对象作为Thread对象的target创建并启动新线程。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;五. 线程的常见方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public void start()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;使该线程开始执行；Java虚拟机调用该线程的 run 方法。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public void run()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public final void setName(String name)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;改变线程名称，使之与参数 name 相同。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public final void setPriority(int priority)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 更改线程的优先级。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public final void setDaemon(boolean on)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;将该线程标记为守护线程或用户线程。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public final void join(long millisec)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;等待该线程终止的时间最长为 millis 毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public void interrupt()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;中断线程。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public final boolean isAlive()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;测试线程是否处于活动状态。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public static void yield()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;暂停当前正在执行的线程对象，并执行其他线程。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public static void sleep(long millisec)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public static boolean holdsLock(Object x)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;75&quot;&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;461&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public static Thread currentThread()&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;返回对当前正在执行的线程对象的引用。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;六. 线程的几个主要概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;a) 线程同步&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;b) 线程安全&lt;/span&gt;：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;不可变：像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;绝对线程安全：不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;相对线程安全：相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;线程非安全：这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;a) 线程间通信&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;b) 线程死锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;c) 线程控制：挂起、停止和恢复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;七. 多线程中的常见问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;a) Run()和start()之间的区别？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;b) Runnable接口和Callable接口的区别？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;c) Sleep()方法和wait()方法的区别？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;15&quot;&gt;&lt;strong&gt;&lt;span&gt;sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器（监视对象同步），sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器，并且wait()只能在同步中使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 13 May 2018 15:25:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/9033973.html</dc:identifier>
</item>
<item>
<title>浏览器中打开摄像头 - Zz喵</title>
<link>http://www.cnblogs.com/zzmiaow/p/9033894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzmiaow/p/9033894.html</guid>
<description>&lt;p&gt;　　本文是讲述如何在浏览器中打开摄像头，并且实时显示在页面上。想要实现这一功能，需要依赖&lt;strong&gt;WebRTC&lt;/strong&gt; (Web Real-Time Communications) 这一实时通讯技术，它允许浏览器之间视频流和音频流或者其他任意数据的传输，当然其中包含了大量的API和协议，这些在这里都不做介绍，具体的标准还在完善之中，所以使用的方法有时候也需要考虑到兼容问题，那么回到主题，怎样使用webRTC获取视频流。&lt;/p&gt;
&lt;p&gt;　　首先对于html，我们需要一个video标签来播放视频（JS中添加也可以），当然画布也是能够实现的。使用video有些属性必须要配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;video &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;video&quot;&lt;/span&gt;&lt;span&gt; autoplay playsinline&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;video&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上面两个属性必须要添加，autoplay设置video自动播放，否则通信成功后页面将会保留第一张静止的画面。playsinline是由于有些浏览器默认会开启全屏播放，而全屏可能是画面变成黑屏。&lt;/p&gt;
&lt;p&gt;　　webRTC大部分浏览器支持，IE(Edge)15+， Safari 11+， IOS Safari 11.2+, Android 64+,  QQ、百度部分支持，对于IOS必须系统在11以上，并且只有Safari支持，UC 浏览器不支持。&lt;/p&gt;
&lt;p&gt;　　对于webRTC支持情况，可以采用以下代码判断。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices === undefined ||&lt;span&gt;
  navigator.mediaDevices.enumerateDevices &lt;/span&gt;=== undefined ||&lt;span&gt;
  navigator.mediaDevices.getUserMedia &lt;/span&gt;===&lt;span&gt; undefined) {&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices ===&lt;span&gt; undefined) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fctName = 'navigator.mediaDevices'&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices.enumerateDevices ===&lt;span&gt; undefined) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fctName = 'navigator.mediaDevices.enumerateDevices'&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices.getUserMedia ===&lt;span&gt; undefined) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fctName = 'navigator.mediaDevices.getUserMedia'&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    console.assert(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
  }
  alert(&lt;/span&gt;'WebRTC issue-! ' + fctName + ' not present in your browser'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　获取video元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let video = document.querySelector('#video');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如果支持webRTC，那么就调用mediaDevice的方法来遍历媒体对象，该方法返回一个promise对象，在第一个then方法的回调函数里面默认接收返回的媒体信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
navigator.mediaDevices.enumerateDevices().then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (sourceInfos) {
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　获取sourceInfos，要拿到后置摄像头的信息并不是通用的，PC、IOS、Android以及不同浏览器，处理方法都不同，这里只做IOS和Android区分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/&lt;span&gt;)) {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果不是IOS，那么就需要遍历sourceinfos，获取后置摄像头再获取视频流。声明一个exArray用来存放不同媒体设备的id，再通过id获取摄像头信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let exArray =&lt;span&gt; [];  
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; sourceInfos.length; ++&lt;span&gt;i) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sourceInfos[i].kind == 'videoinput'&lt;span&gt;) {
    exArray.push(sourceInfos[i].deviceId);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这样数组里面存放的都是摄像头的id，而我们需要的是后置摄像头，再调用获取媒体信息的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (navigator.getUserMedia) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该方法可以传递3个参数，分别为获取媒体信息的配置，成功的回调函数和失败的回调函数&lt;/span&gt;
&lt;span&gt;  navigator.getUserMedia({
    audio: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表明是否获取音频&lt;/span&gt;
    video: {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对视频信息进行配置&lt;/span&gt;
&lt;span&gt;      optional: [{
        &lt;/span&gt;'sourceId': exArray[1] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下标为0是前置摄像头，1为后置摄像头，所以PC不能进入该判断，否则画面会保持在第一帧不动&lt;/span&gt;
&lt;span&gt;      }]
    },
  }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; successFunc(stream) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对FireFox进行兼容，这里对返回流数据的处理不同&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (video.mozSrcObject !==&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Firefox中，video.mozSrcObject最初为null，而不是未定义的，我们可以靠这个来检测Firefox的支持  &lt;/span&gt;
      video.mozSrcObject =&lt;span&gt; stream;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一般的浏览器需要使用createObjectURL对流数据进行处理，再交给video元素的src&lt;/span&gt;
      video.src = window.URL &amp;amp;&amp;amp; window.URL.createObjectURL(stream) ||&lt;span&gt; stream;
    }
  }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; errorFunc(e) {
    alert(&lt;/span&gt;'Error！' +&lt;span&gt; e);
  }); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;success是获取成功的回调函数  &lt;/span&gt;
} &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  alert(&lt;/span&gt;'Native device media streaming (getUserMedia) not supported in this browser.'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在成功的回调函数中，将返回的视频流交给html中的video元素，这里src的方式实际是通过blob64的格式来传输的。&lt;/p&gt;
&lt;p&gt;　　// =============================  IOS&lt;/p&gt;
&lt;p&gt;　　在IOS中获取视频流现实的方式又不一样了，我们需要调用mediaDevice的获取媒体的方法，这也是最新的标准。首先需要些小小的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对生成视频进行配置&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; userMediaConstraints =&lt;span&gt; {
  audio: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否获取音频&lt;/span&gt;
&lt;span&gt;  video: {
    facingMode: &lt;/span&gt;'environment',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 环境表示后置摄像头，使用user表示采用前置&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 宽高的配置比较灵活，由于video一般都会显示固定宽高比，所以使用ideal理想值即可&lt;/span&gt;
&lt;span&gt;    width: {
      ideal: &lt;/span&gt;1024&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; min: 1024,&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; max: 1920&lt;/span&gt;
&lt;span&gt;    },
    height: {
      ideal: &lt;/span&gt;768&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; min: 776,&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; max: 1080&lt;/span&gt;
&lt;span&gt;    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再调用方法获取视频就很简单了，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
navigator.mediaDevices.getUserMedia(userMediaConstraints).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; success(stream) {
  video.srcObject &lt;/span&gt;=&lt;span&gt; stream;
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
  alert(error.name &lt;/span&gt;+&lt;span&gt; error.message)
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　整体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;web RTC&amp;lt;/title&amp;gt;

&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;!-- 这里必须设置autoplay，否则视频画面静止为第一张 --&amp;gt;
  &amp;lt;!-- 必须设置为playsinline，默认全屏播放可能会导致黑屏 --&amp;gt;
  &amp;lt;video id=&quot;video&quot; autoplay playsinline&amp;gt;&amp;lt;/video&amp;gt;
  &amp;lt;script&amp;gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 习惯性写在函数中，控制变量&lt;/span&gt;
   ;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  由于IOS必须在版本11以上才能使用webrtc，并且只有Safari支持，所以做一个小小的判断，限定在&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(/(iPhone|iPad|iPod|iOS)/&lt;span&gt;i.test(window.navigator.userAgent) &amp;amp;&amp;amp; navigator.vender.indexOf(&quot;apple&quot;) &amp;gt; -1) {
　　　　return;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * =============实现在浏览器中打开摄像头，并且将摄像头内容显示在页面中
     * 想要实现这一功能，需要了解webRTC（Web Real-Time Communication）网络实时通话技术，它允许浏览器实现视频、音频、P2P文件分享等功能。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启视频功能，依赖window的navigator对象，采用getUserMedia方法，有版本差异，所以需要判断区分&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要IE(Edge)15+， Safari 11+， IOS Safari 11.2+, Android 64+, UC 不支持， QQ、百度部分支持&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以首先需要对浏览器支持情况进行判断&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先判断浏览器是否支持&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices === undefined ||&lt;span&gt;
      navigator.mediaDevices.enumerateDevices &lt;/span&gt;=== undefined ||&lt;span&gt;
      navigator.mediaDevices.getUserMedia &lt;/span&gt;===&lt;span&gt; undefined) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再判断具体是那个方法不支持，并向用户显示&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices ===&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fctName = 'navigator.mediaDevices'&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices.enumerateDevices ===&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fctName = 'navigator.mediaDevices.enumerateDevices'&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (navigator.mediaDevices.getUserMedia ===&lt;span&gt; undefined) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fctName = 'navigator.mediaDevices.getUserMedia'&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.assert(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
      }
      alert(&lt;/span&gt;'WebRTC issue-! ' + fctName + ' not present in your browser'&lt;span&gt;)
    }
    const video &lt;/span&gt;= document.querySelector('#video'&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果浏览器支持，该方法的更新是向后兼容，新版将所有功能都使用navigator.mediaDevices进行了封装&lt;/span&gt;
    navigator.mediaDevices.enumerateDevices().then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (sourceInfos) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果支持新的方法，那么就使用新的方法来获取，当然这是一种比较主流的判断方法&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是想旧的方法兼容，可以使用下面作为判断条件，除IOS和PC以外，均使用旧的获取方式&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; !(navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/) || !/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent))&lt;/span&gt;
      
      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
       * 无论是旧的写法还是新的标准，思路都是通过设备信息，获取摄像头的视频流，通过转换变成blob的格式交给video的src
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;navigator.mediaDevices.getUserMedia) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明一个数组，用于装载设备媒体设备的相关信息，由于回调中sourceInfos对象中携带有所有媒体对象的相关信息&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对信息进行遍历筛选，只选出摄像头的Id并保存在数组中&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; exArray =&lt;span&gt; [];  
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; sourceInfos.length; ++&lt;span&gt;i) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sourceInfos[i].kind == 'videoinput'&lt;span&gt;) {
            exArray.push(sourceInfos[i].deviceId);
          }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过navigator的getUserMedia获取摄像头的视频流，并在成功的回调中将视频流交给video&lt;/span&gt;
&lt;span&gt;        getMedia();

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMedia() {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (navigator.getUserMedia) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该方法可以传递3个参数，分别为获取媒体信息的配置，成功的回调函数和失败的回调函数&lt;/span&gt;
&lt;span&gt;            navigator.getUserMedia({
              audio: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表明是否获取音频&lt;/span&gt;
              video: {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对视频信息进行配置&lt;/span&gt;
&lt;span&gt;                optional: [{
                  &lt;/span&gt;'sourceId': exArray[1] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下标为0是前置摄像头，1为后置摄像头，所以PC不能进入该判断，否则画面会保持在第一帧不动&lt;/span&gt;
&lt;span&gt;                }]
              },
            }, successFunc, errorFunc); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;success是获取成功的回调函数  &lt;/span&gt;
          } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            alert(&lt;/span&gt;'Native device media streaming (getUserMedia) not supported in this browser.'&lt;span&gt;);
          }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是获取媒体信息成功的回调函数&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; successFunc(stream) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对FireFox进行兼容，这里对返回流数据的处理不同&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (video.mozSrcObject !==&lt;span&gt; undefined) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Firefox中，video.mozSrcObject最初为null，而不是未定义的，我们可以靠这个来检测Firefox的支持  &lt;/span&gt;
            video.mozSrcObject =&lt;span&gt; stream;
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一般的浏览器需要使用createObjectURL对流数据进行处理，再交给video元素的src&lt;/span&gt;
            video.src = window.URL &amp;amp;&amp;amp; window.URL.createObjectURL(stream) ||&lt;span&gt; stream;
          }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取媒体信息失败的回调&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; errorFunc(e) {
          alert(&lt;/span&gt;'Error！' +&lt;span&gt; e);
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当采用最新的标准方式获取视频时&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对生成视频进行配置&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; userMediaConstraints =&lt;span&gt; {
          audio: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否获取音频&lt;/span&gt;
&lt;span&gt;          video: {
            facingMode: &lt;/span&gt;'environment'  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 环境表示后置摄像头，使用user表示采用前置&lt;/span&gt;&lt;span&gt;
          }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就采用新的方法来获取视频&lt;/span&gt;
        navigator.mediaDevices.getUserMedia(userMediaConstraints).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; success(stream) {
          video.srcObject &lt;/span&gt;=&lt;span&gt; stream;
 
        }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (error) {
          alert(error.name &lt;/span&gt;+&lt;span&gt; error.message)
        });
      }
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
      alert(error.name &lt;/span&gt;+&lt;span&gt; error.message)
    })&lt;/span&gt;
&lt;span&gt;   })();
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后提供一个将视频全屏显示的方法，对于PC和要求不高的手机已经可以实现全屏&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* &lt;/span&gt;{&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}&lt;span&gt;
body &lt;/span&gt;{&lt;span&gt;
   overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
}&lt;span&gt;
#video &lt;/span&gt;{&lt;span&gt;
    min-width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
    min-height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
    transform&lt;/span&gt;:&lt;span&gt; translate(-50%, -50%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在手机上，这个还有一点点横向滚动条，要想完全去掉，需要改动html，让video自动适用全屏的div&lt;/p&gt;
&lt;p&gt;　　html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div id=&quot;wrapper&quot;&amp;gt;
  &amp;lt;video id=&quot;video&quot; autoplay playsinline&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* &lt;/span&gt;{&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}&lt;span&gt;

#wrapper &lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 13 May 2018 15:09:00 +0000</pubDate>
<dc:creator>Zz喵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzmiaow/p/9033894.html</dc:identifier>
</item>
<item>
<title>读《现代前端技术解析》有感 - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8983006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8983006.html</guid>
<description>&lt;p&gt;&lt;span&gt;这本书标榜的是现在前端技术，但是里面设计到的部分技术还是相对比较落后的，但不妨碍这本书成为一本好的查漏补缺的指南，如果是在实际的工作中这本书可以说是起不到什么的效果，但是对于即将毕业，或者刚刚出来工作，又或者是求职找工作的人来说可以起到极好的引导作用，日常面试的各个方面都有涉及(仅针对小公司的面试)，但是不深刻。里面重点展示的是技术的应用层面上的东西，所以也比较好理解，一些像设计模式，算法，数据结构，JS语法深入部分这本书不曾提及，所以如果为了全面了解，为了找工作，建议读一读这本书；为了更好地工作，还是建议大家抽空看看经典的读物。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; 2.1 web Component&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一种原生的支持模块化的方法，但是目前仅仅在chrome新版得到全面的支持，其他浏览器暂时不支持此特性，这个特性的好处是可以直接将模块与页面进行解耦操作，目前虽然原生没有全面的支持，但是通过webpack打包等形式都已经可以实现了，例如vue中的模块化开发就是基于这个思想。目前虽然不是主流，但是未来可能会成为一种标准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用法是通过document.registerElement接口来注册。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，我们注册一个插件名为X-foo，那么我们这样操作&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
document.registerElement('x-foo'&lt;span&gt;, {
  prototype: Object.create(HTMLElement.prototype, {
    createdCallback: {      
      value: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { ... }
    },
    ...
  })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如下形式去调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;x-foo&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;x-foo&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.2 怎样加快页面的显示&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 使用异步的方式来加载页面，先让一部分的内容先展示出来，再根据用户的操作加载更多的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 将图片替换成为压缩比更高的webp格式图片&lt;br/&gt;3. 打开重复的页面使用304状态码，达到利用浏览器缓存&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.3 页面是怎样从请求发起到展现出来的&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 1.  用户输入一个网址，浏览器开启一个线程处理请求，对用户输入的URL进行分析处理，如果是使用了HTT协议的话，那么会用HTTP来处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.  调用JavaScript引擎的方法，例如，webview调用loadUrl方法，分析并加载这个URL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.  连同浏览器的cookie,userAgent等信息向网站目的地IP发起GET请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4.  进入后台web服务器处理请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 5.  进入部署好的后台应用，找到对应的处理逻辑，这期间可能会读取服务器缓存或者读取数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 6.  服务器处理请求并返回响应报文，浏览器的缓存资源的时间会跟服务器的最后修改记录时间做对比，一致返回304，否则返回200&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 7.  如果为200的时候，下载对应的HTML文档，304直接读取缓存&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.4 浏览器的组成结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;示意图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/728493/201805/728493-20180507003037260-1524408507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  如图我们可以知道浏览器引擎和JavaScript引擎不是同一回事，这个也就说明了为什么JavaScript是单线程但是浏览器可以异步发起请求的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.  我们重点关注的是渲染引擎和一些存储，因为其他部分开发者无法操作&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.5 各个浏览器渲染引擎之间的差异与渲染引擎是怎样工作的&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 以webkit内核和Gecko内核为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/728493/201805/728493-20180507230625212-857953878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/728493/201805/728493-20180507230719912-1842562913.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对比之后我们可以发现Gecko内核是需要先解析HTML然后再解析CSS，webkit内核是并行执行的。所以webkit内核在解析CSS这方面会相对高效&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.6 CSS的权重问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; !important(最高权重) &amp;gt; 内联样式规则(权重1000) &amp;gt; id选择器(权重100) &amp;gt; 类选择器(权重10) &amp;gt; 元素选择器&lt;/p&gt;

&lt;h2&gt;2.7  cookie的种类与区别&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; cookie一般是有两种:session cookie和持久型 cookie&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. session cookie一般未设置过期时间，只要关闭浏览器&lt;strong&gt;窗口&lt;/strong&gt;，cookie就会消失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 持久型cookie一般会设置cookie过期时间，关闭后再次打开浏览器窗口都有效&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.8 前端开发工具&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 1. 前端高效开发工具：vscode、webstorm、sublime&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. 前端调试工具: chrome devtool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3. 网络辅助工具:fiddler charles wireshark&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4. 前端远程调试工具：vorlon.js weinre VConsole&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.9 web安全知识有哪些？大致介绍一下？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;主要的web安全有XSS,SQL注入，CSRF&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;XSS:通常是由页面可解析的内容未经过处理就直接插入到页面导致。例如插入document.cookie来获取cookie&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL注入：输入框的内容未经过处理就直接传给数据库，导致SQL插入到数据库中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSRF：举一个例子，假设有一个假冒网站，用户向其中提交用户名和密码，这个时候假冒网站就会向真实的网站发起请求，跳转到真实的网站，但是这个时候假冒网站已经就记录下了用户的用户名和密码。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.10 网络劫持&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;前端主要的网络劫持有DNS劫持和HTTP劫持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. DNS劫持：DNS被篡改解析的路径导致网站解析出错，目前这种劫持较少，这要发生这种劫持是运营商所为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. HTTP劫持：一般来说这种劫持的HTML，CSS ,JS都是正常的。但是在网站response的时候，网络运营商会劫持添加一些脚本，主要表现在使用HTTP请求有时候会莫名其妙的出现一些小广告之类的。解决的方法是HTTP换成HTTPS&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.11 native交互协议&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;web调用native&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/728493/201805/728493-20180513200831053-994676319.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要web调用native的流程是通过uri和addJavascriptInterface接口来实现的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要的途径是uri，是通过url向native发起请求，native调用系统的底层来实现的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;native协议调用web&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原理是:HTML5编写的Javascript暴露到全局中，然后在native中调用loadUrl方法来实现调用javascript&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.12 怎样提交元素的加载解析？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 直接通过懒加载来实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 通过使用AMP来实现HTML元素的懒加载（对于video,table等耗时的元素这样做会加快页面的加载速度，但是目前这些方案并不是前端的主流解决方法【博主观点】）&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.13 HTML5中新增了哪些新的标签或者属性？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;header&amp;gt; &amp;lt;video&amp;gt; &amp;lt;source /&amp;gt; &amp;lt;article&amp;gt;  &amp;lt;time&amp;gt; &amp;lt;datalist&amp;gt; &amp;lt;command /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;input&amp;gt;新增了 autocomplete，placeholder，autofocus,required属性，新增了email,number,color,range,search,date&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;这本书说不上好，也说不上特别的不好，总体上就是用来查漏补缺的，面试可用。书中的内容越往后越稀薄，建议读读前几章就好了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 13 May 2018 13:30:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8983006.html</dc:identifier>
</item>
<item>
<title>构建具有用户身份认证的 Ionic 应用 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/9010206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/9010206.html</guid>
<description>&lt;blockquote readability=&quot;8.758389261745&quot;&gt;
&lt;p&gt;序言：本文主要介绍了使用 Ionic 和 Cordova 开发混合应用时如何添加用户身份认证。教程简易，对于 Ionic 入门学习有一定帮助。因为文章是去年发表，所以教程内关于 Okta 的一些使用步骤不太准确，但是通过 Okta 的官网也可以找到对应的内容。另外，使用 npm 安装 Ionic starter 模板可能会有安装失败的情况，建议不要在这方面浪费太多时间，可以直接在 Ionic 的 &lt;a href=&quot;https://github.com/ionic-team/starters&quot;&gt;GitHub 仓库&lt;/a&gt; 中下载 starter 模板。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://scotch.io/tutorials/build-an-ionic-app-with-user-authentication&quot;&gt;How to Sprinkle ReactJS into an Existing Web Application&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者：&lt;a href=&quot;http://www.cnblogs.com/nzbin/&quot;&gt;nzbin&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/jsdqruBQWieGudDEZGBA_Build_an_app_in_Ionic.png.jpg&quot; alt=&quot;Banner&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Okta 和 OpenID Connect (OIDC)，可以很轻松的在 Ionic 应用中添加身份认证，完全不需要自己实现。 OIDC 允许你直接使用 &lt;a href=&quot;https://synd.co/2rVdJuO&quot;&gt;Okta Platform API&lt;/a&gt; 进行认证，本文的目的就是告诉你如何在一个 Ionic 应用中使用这些 API。我将演示如何使用 OIDC 重定向、Okta 的 Auth SDK 以及基于 Cordova 内嵌浏览器的 OAuth 进行登录； 由于功能还在开发中，所以省略了用户注册。&lt;/p&gt;
&lt;h2 id=&quot;为什么使用-ionic&quot;&gt;为什么使用 Ionic？&lt;/h2&gt;
&lt;p&gt;Ionic 是一个用于开发原生及先进 web 应用的开源的移动端 SDK。它使用 Angular 和 &lt;a href=&quot;https://cordova.apache.org/&quot;&gt;Apache Cordova&lt;/a&gt; ，可以用 HTML、CSS、和 JavaScript 来开发移动应用。Apache Cordova 将 HTML 代码嵌入到一个设备上的原生 WebView 中， 通过外部功能接口来访问原生资源。你可能听说过 &lt;a href=&quot;http://phonegap.com/&quot;&gt;PhoneGap&lt;/a&gt; —— 这是 Adobe Cordova 的商业版本。&lt;/p&gt;
&lt;p&gt;Cordova 和 PhoneGap 允许你使用一套代码开发多个平台的应用 (比如 Android 和 iOS) 。除此之外，应用程序和原生程序相差无尽并且和原生体验一样好。如果你需要开发原生功能，使用 web 技术是无法实现的，但是有些原生插件可以实现。 &lt;a href=&quot;https://ionicframework.com/docs/native/&quot;&gt;Ionic Native&lt;/a&gt; 是这些插件的精选集。&lt;/p&gt;
&lt;p&gt;我第一次使用 Ionic 是在 2013 年底。当时我做的项目是开发一款原生应用，但是打算使用 HTML 来开发适配多个屏幕的应用，这样 web 开发者也可以参与开发。我在 &lt;a href=&quot;https://raibledesigns.com/rd/entry/developing_an_ios_native_app&quot;&gt;2014 年的三月写了我的经历&lt;/a&gt;。我喜欢使用 Ionic，我发现使用 Ionic 移植现有的应用程序更多的就是修改 HTML 和调整 CSS。&lt;/p&gt;
&lt;p&gt;Ionic 2 在 &lt;a href=&quot;http://blog.ionic.io/announcing-ionic-2-0-0-final/&quot;&gt;一月份发布&lt;/a&gt;， 可以使用 Angular 开发 Ionic 应用。 Ionic 3 在 &lt;a href=&quot;http://blog.ionic.io/ionic-3-0-has-arrived/&quot;&gt;四月份发布&lt;/a&gt;，允许使用 Angular 4 进行开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; &quot;Angular&quot; 是 Angular 2+ 的通用名称。AngularJS 是 1.x 版本的名称。之所以用 Angular 命名是因为在 2017 年的三月发布了 Angular 4 。可以查看 &lt;a href=&quot;https://angularjs.blogspot.com/2017/01/branding-guidelines-for-angular-and.html&quot;&gt;Branding Guidelines for Angular and AngularJS&lt;/a&gt; 了解更多信息。&lt;/p&gt;
&lt;p&gt;本文会演示如何创建一个简单的 Ionic 应用以及如何添加用户身份认证。大多数的应用都需要身份认证，这样才能知道用户是谁。一旦 app 知道你的身份，它就可以保存你的信息及个性化的功能。&lt;/p&gt;
&lt;h2 id=&quot;开始使用-ionic&quot;&gt;开始使用 Ionic&lt;/h2&gt;
&lt;p&gt;为了设置 Ionic 的开发环境，需要完成以下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装 &lt;a href=&quot;https://nodejs.org&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用 npm 安装 Ionic 和 Cordova： &lt;code&gt;npm install -g cordova ionic&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;创建一个-ionic-应用&quot;&gt;创建一个 Ionic 应用&lt;/h2&gt;
&lt;p&gt;在 terminal 窗口中，使用以下命令创建一个新的应用程序：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ionic&lt;/span&gt; start ionic-auth&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行会提示选择一个 starter 项目并且可以选择是否将应用连接到 Ionic Dashboard。对于本教程，选择 &lt;strong&gt;tabs&lt;/strong&gt; starter 项目，不需要将项目连接到 Ionic Dashboard。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5957446808511&quot;&gt;
&lt;p&gt;相关教程：&lt;a href=&quot;https://bit.ly/2rECTAS&quot;&gt;Getting Started with Angular v2+&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目创建需要花费一到两分钟，这取决于你的网络连接速度。运行以下命令来打开你的 Ionic 应用。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ionic-auth
&lt;span class=&quot;kw&quot;&gt;ionic&lt;/span&gt; serve&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令默认打开浏览器的 &lt;a href=&quot;http://localhost:8100&quot; class=&quot;uri&quot;&gt;http://localhost:8100&lt;/a&gt;。你可以使用 Chrome 的设备模式查看应用程序在 iPhone 6 中的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/poz8sc2CSoGT0wzCOX1k_welcome-to-ionic.png&quot; alt=&quot;Welcome to Ionic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Ionic &lt;code&gt;serve&lt;/code&gt; 命令的特点是它会在浏览器中显示编译错误，而不是（有时会隐藏）在开发控制台。比如，给 &lt;code&gt;app.component.ts&lt;/code&gt; 组件中的 &lt;code&gt;rootPage&lt;/code&gt; 变量设置一个非法类型，你将看到以下错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/dtZNYdrvQnS8lIb9TenM_typescript-error.png&quot; alt=&quot;Welcome to Ionic&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;添加用户身份认证&quot;&gt;添加用户身份认证&lt;/h2&gt;
&lt;p&gt;Ionic Cloud 提供了免费的 &lt;a href=&quot;https://docs.ionic.io/services/auth/&quot;&gt;Auth&lt;/a&gt; 服务。它允许使用邮箱及密码验证身份，也可以使用社交提供商比如 Facebook、Google 和 Twitter 登录。你可以使用 &lt;code&gt;@ionic/cloud-angular&lt;/code&gt; 依赖中提供的类创建身份认证。它也支持 &lt;a href=&quot;https://docs.ionic.io/services/auth/custom-auth.html&quot;&gt;自定义身份认证&lt;/a&gt;，但是 &quot;需要你自己的服务器处理身份认证&quot;。&lt;/p&gt;
&lt;p&gt;目前还没有太多关于这方面的教程，不过从去年开始有了一些。&lt;/p&gt;
&lt;p&gt;你可能注意到所有的教程都需要很多的代码。另外，关于如何在后端的 Auth 服务中验证用户身份的文档也不多。&lt;/p&gt;
&lt;h2 id=&quot;在-okta-中创建-openid-connect-应用&quot;&gt;在 Okta 中创建 OpenID Connect 应用&lt;/h2&gt;
&lt;p&gt;OpenID Connect (OIDC) 基于 OAuth 2.0 协议。它允许客户端验证用户的身份并获得他们的基本配置文件信息。为了将 Okta 的身份认证平台整合到用户身份认证中，需要以下步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.okta.com/developer/signup/&quot;&gt;注册&lt;/a&gt; 并创建一个 OIDC 应用&lt;/li&gt;
&lt;li&gt;登录 Okta 账户，然后导航到 &lt;strong&gt;Admin &amp;gt; Add Applications&lt;/strong&gt; 并点击 &lt;strong&gt;Create New App&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择 &lt;strong&gt;Single Page App (SPA)&lt;/strong&gt; 以及 &lt;strong&gt;OpenID Connect&lt;/strong&gt; 作为登录方式&lt;/li&gt;
&lt;li&gt;点击 &lt;strong&gt;Create&lt;/strong&gt; 并给你的应用起个名字 (比如 &quot;Ionic OIDC&quot;)&lt;/li&gt;
&lt;li&gt;在下一页上，添加 &lt;code&gt;http://localhost:8100&lt;/code&gt; 作为重定向的 URI 并点击 &lt;strong&gt;Finish&lt;/strong&gt;。你会看到以下设置信息：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/h8AoHSHzTISJE44riOGi_oidc-settings.png&quot; alt=&quot;Welcome to Ionic&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击 &lt;strong&gt;Assignments&lt;/strong&gt; 标签，然后选择 &lt;strong&gt;Assign&lt;/strong&gt; &amp;gt; &lt;strong&gt;Assign to People&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;给自己分配一个用户，或者其它你授权的人。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建登录页&quot;&gt;创建登录页&lt;/h2&gt;
&lt;p&gt;为了创建身份认证的登录页，先创建 &lt;code&gt;src/pages/login.ts&lt;/code&gt; 和 &lt;code&gt;src/pages/login.html&lt;/code&gt;。在 &lt;code&gt;login.html&lt;/code&gt;中，添加一个具有 username 和 password 的表单。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-header&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-navbar&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-title&amp;gt;&lt;/span&gt;
      Login
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-navbar&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-header&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-content&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; padding&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;#loginForm&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;ngForm&quot;&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;(ngSubmit)&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;login()&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; autocomplete=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;off&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-row&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-col&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-list&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; inset&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-item&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; placeholder=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Email&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;loginField&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                       type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; required&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;[(ngModel)]&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;#email&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/ion-input&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-item&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-item&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; placeholder=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;passwordField&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                       type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; required&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;[(ngModel)]&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/ion-input&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-item&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-list&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-col&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-row&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-row&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-col&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;*ngIf&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;alert alert-danger&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;{{error}}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;button&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ion-button class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit-btn&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; full type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;submit&quot;&lt;/span&gt;
                &lt;span class=&quot;er&quot;&gt;[disabled]&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;!loginForm.form.valid&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;Login
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-col&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-row&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-content&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以利用几个开源库来完成实际的身份验证。第一个是 &lt;a href=&quot;https://github.com/manfredsteyer&quot;&gt;Manfred Steyer's&lt;/a&gt; &lt;a href=&quot;https://github.com/manfredsteyer/angular-oauth2-oidc&quot;&gt;angular-oauth2-oidc&lt;/a&gt;. 这个库可以很容易的与 identity tokens 和 access tokens 交互。第二个是 &lt;a href=&quot;https://developer.okta.com/code/javascript/okta_auth_sdk&quot;&gt;Okta Auth SDK&lt;/a&gt;。由于 &lt;a href=&quot;https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth&quot;&gt;OIDC 和 OAuth 不是身份认证协议&lt;/a&gt;，所以这是使用 JavaScript 完成身份验证所必需的，不必重定向到 Okta 。&lt;/p&gt;
&lt;p&gt;使用 npm 安装 &lt;code&gt;angular-oauth2-oidc&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install angular-oauth2-oidc  --save&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okta Auth SDK 目前不支持 TypeScript，可以将以下代码添加到 &lt;code&gt;src/index.html&lt;/code&gt;底部。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;https://ok1static.oktacdn.com/assets/js/sdk/okta-auth-js/1.5.0/OktaAuth.min.js&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;src/pages/login/login.ts&lt;/code&gt; 中， 添加 &lt;code&gt;LoginPage&lt;/code&gt; 类的基本结构，在构造器函数中使用 &lt;code&gt;OAuthService&lt;/code&gt; （来自于 angular-oauth2-oidc） 配置了 OIDC 的设置。 你需要使用 Okta OIDC 设置中的 Client ID 替换 &quot;[client-id]&quot; 以及你账户的当前 URI 替换 &quot;[dev-id]&quot;。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import { Component, ViewChild } from '@angular/core';
import { NavController } from 'ionic-angular';
import { OAuthService } from 'angular-oauth2-oidc';
declare const OktaAuth: any;

@Component({
  selector: 'page-login',
  templateUrl: 'login.html'
})
export class LoginPage {
  @ViewChild('email') email: any;
  private username: string;
  private password: string;
  private error: string;

  constructor(private navCtrl: NavController, private oauthService: OAuthService) {
    oauthService.redirectUri = window.location.origin;
    oauthService.clientId = '[client-id]';
    oauthService.scope = 'openid profile email';
    oauthService.oidc = true;
    oauthService.issuer = 'https://dev-[dev-id].oktapreview.com';
  }

  ionViewDidLoad(): void {
    setTimeout(() =&amp;gt; {
      this.email.setFocus();
    }, 500);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 &lt;code&gt;src/app/app.component.ts&lt;/code&gt; 验证用户是否登录。如果没有，将 &lt;code&gt;LoginPage&lt;/code&gt; 设置为 rootPage。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import { OAuthService } from 'angular-oauth2-oidc';
import { LoginPage } from '../pages/login/login';

@Component({
  templateUrl: 'app.html'
})
export class MyApp {
  rootPage: any = TabsPage;

  constructor(platform: Platform, statusBar: StatusBar, splashScreen: SplashScreen,
              oauthService: OAuthService) {
    if (oauthService.hasValidIdToken()) {
      this.rootPage = TabsPage;
    } else {
      this.rootPage = LoginPage;
    }

    platform.ready().then(() =&amp;gt; {
      statusBar.styleDefault();
      splashScreen.hide();
    });
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新 &lt;code&gt;src/app/app.module.ts&lt;/code&gt;，在 &lt;code&gt;declarations&lt;/code&gt; 和 &lt;code&gt;entryComponents&lt;/code&gt; 中添加 &lt;code&gt;LoginPage&lt;/code&gt;。你也要将 &lt;code&gt;OAuthService&lt;/code&gt; 添加到 &lt;code&gt;providers&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;@NgModule({
  declarations: [
    ...
    LoginPage
  ],
  ...
  entryComponents: [
    ...
    LoginPage
  ],
  providers: [
    OAuthService,
    ...
  ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 &lt;code&gt;ionic serve&lt;/code&gt;，确认 &lt;code&gt;LoginPage&lt;/code&gt;在 app 首次加载后可以展示出来。app 加载时会有以下报错：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;No&lt;/span&gt; provider for Http!&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现这个错误是因为 &lt;code&gt;OAuthService&lt;/code&gt; 需要依赖 Angular 的 &lt;code&gt;Http&lt;/code&gt; 模块，但是还没有将该模块导入到项目中。在 &lt;code&gt;src/app/app.module.ts&lt;/code&gt; 中导入 &lt;code&gt;HttpModule&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import { HttpModule } from '@angular/http';

@NgModule({
  ...
  imports: [
    BrowserModule,
    HttpModule,
    IonicModule.forRoot(MyApp)
  ],
  ...
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在登录页已经展示出来了。你可以使用 Chrome 的设备模式查看在 iPhone 6 上的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/a0Oq3pobRhGISEPDOLGf_login-page.png&quot; alt=&quot;Welcome to Ionic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决缺少 TypeScript 支持的问题，你需要在 &lt;code&gt;src/app/pages/login/login.ts&lt;/code&gt; 的顶部添加以下代码。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;declare const OktaAuth: any;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TIP:&lt;/strong&gt; 要了解更多关于在 TypeScript 项目引用外部 JavaScript 库的知识，可以阅读 &lt;a href=&quot;https://www.thepolyglotdeveloper.com/2016/01/include-external-javascript-libraries-in-an-angular-2-typescript-project/&quot;&gt;Nic Raboy 写的关于这方面的文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;src/app/pages/login/login.ts&lt;/code&gt; 中添加一个 &lt;code&gt;login()&lt;/code&gt; 方法，它使用 Okta Auth SDK 进行： 1) 登录； 2) 将 session token 转换成 identity 和 access token。 一个 &lt;a href=&quot;https://openid.net/specs/openid-connect-core-1_0.html#IDToken&quot;&gt;ID token&lt;/a&gt; 类似于身份证，它是标准的 JWT 格式，由 OpenID 提供者签名。Access tokens 是 OAuth 规范的一部分。一个 access token 可以是一个 JWT。它们用于访问被保护的资源，通常是在发送请求时将它们添加到 &lt;code&gt;Authentication&lt;/code&gt; 请求头中。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;login(): void {
  this.oauthService.createAndSaveNonce().then(nonce =&amp;gt; {
    const authClient = new OktaAuth({
      clientId: this.oauthService.clientId,
      redirectUri: this.oauthService.redirectUri,
      url: this.oauthService.issuer
    });
    authClient.signIn({
      username: this.username,
      password: this.password
    }).then((response) =&amp;gt; {
      if (response.status === 'SUCCESS') {
        authClient.token.getWithoutPrompt({
          nonce: nonce,
          responseType: ['id_token', 'token'],
          sessionToken: response.sessionToken,
          scopes: this.oauthService.scope.split(' ')
        })
          .then((tokens) =&amp;gt; {
            // oauthService.processIdToken doesn't set an access token
            // set it manually so oauthService.authorizationHeader() works
            localStorage.setItem('access_token', tokens[1].accessToken);
            this.oauthService.processIdToken(tokens[0].idToken, tokens[1].accessToken);
            this.navCtrl.push(TabsPage);
          })
          .catch(error =&amp;gt; console.error(error));
      } else {
        throw new Error('We cannot handle the ' + response.status + ' status');
      }
    }).fail((error) =&amp;gt; {
      console.error(error);
      this.error = error.message;
    });
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 identity token 你可以了解用户的更多信息。通过 access token 你可以访问需要 Bearer token 的受保护的 API。比如， 在 &lt;a href=&quot;https://developer.okta.com/blog/2017/06/13/add-authentication-angular-pwa&quot;&gt;在 Angular PWA 中添加身份认证&lt;/a&gt;中，有一个 &lt;code&gt;BeerService&lt;/code&gt; ，它用于在发送 API 请求时携带 access token 。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import { Injectable } from '@angular/core';
import { Http, Response, Headers, RequestOptions } from '@angular/http';
import 'rxjs/add/operator/map';
import { Observable } from 'rxjs';
import { OAuthService } from 'angular-oauth2-oidc';

@Injectable()
export class BeerService {

  constructor(private http: Http, private oauthService: OAuthService) {
  }

  getAll(): Observable&amp;lt;any&amp;gt; {
    const headers: Headers = new Headers();
    headers.append('Authorization', this.oauthService.authorizationHeader());

    let options = new RequestOptions({ headers: headers });

    return this.http.get('http://localhost:8080/good-beers', options)
      .map((response: Response) =&amp;gt; response.json());
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以（可选）在表单上方添加图标来美化登录页。下载 &lt;a href=&quot;https://www.okta.com/sites/all/themes/Okta/images/blog/Logos/Okta_Logo_BrightBlue_Medium.png&quot;&gt;这张图片&lt;/a&gt;，将它拷贝到 &lt;code&gt;src/assets/image/okta.png&lt;/code&gt;，在 &lt;code&gt;login.html&lt;/code&gt; 的 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标签中添加以下代码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-row&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-col&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; text-center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;assets/image/okta.png&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; width=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;300&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-col&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-row&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你尝试使用 Okta 的用户证书登录应用程序，你将在浏览器的控制台看到跨域报错。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;XMLHttpRequest cannot load https://dev-158606.oktapreview.com/api/v1/authn. Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:8100' is therefore not allowed access.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了修复这一问题，在 Okta 修改 Trusted Origins (在 &lt;strong&gt;Security&lt;/strong&gt; &amp;gt; &lt;strong&gt;API&lt;/strong&gt; 下面)， 将你的 client's URL 添加进去 (比如 &lt;code&gt;http://localhost:8100&lt;/code&gt;)。检查 CORS 和重定向的 origin 类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/oPkgv8aASQegqfdzFKAA_add-origin.png&quot; alt=&quot;Welcome to Ionic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在登录可以正常工作了，但是 UI 界面并没有提示。在首页的右上角添加一个 &quot;Logout&quot; 按钮。用以下 HTML 替换 &lt;code&gt;src/pages/home/home.html&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;ion-header&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-header&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-navbar&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-title&amp;gt;&lt;/span&gt;Home&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-buttons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; end&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;button&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ion-button&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;(click)&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;logout()&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        Logout
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-buttons&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-navbar&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-header&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;src/pages/home/home.ts&lt;/code&gt; 中，添加一个 &lt;code&gt;logout()&lt;/code&gt; 方法， 用于在 identity token 中获取姓名及 claims 。ID token 中的 claims 是关于颁发者、用户、目标受众、过期时间及颁发时间的信息。你可以阅读 &lt;a href=&quot;https://openid.net/specs/openid-connect-core-1_0.html#IDToken&quot;&gt;OIDC 规范中的标准 claims&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import { Component } from '@angular/core';
import { NavController } from 'ionic-angular';
import { LoginPage } from '../login/login';
import { OAuthService } from 'angular-oauth2-oidc';

@Component({
  selector: 'page-home',
  templateUrl: 'home.html'
})
export class HomePage {

  constructor(public navCtrl: NavController, public oauthService: OAuthService) {
  }

  logout() {
    this.oauthService.logOut();
    this.navCtrl.setRoot(LoginPage);
    this.navCtrl.popToRoot();
  }

  get givenName() {
    const claims = this.oauthService.getIdentityClaims();
    if (!claims) {
      return null;
    }
    return claims.name;
  }

  get claims() {
    return this.oauthService.getIdentityClaims();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了在 home 标签页上展示信息，将以下 HTML 添加到 &lt;code&gt;src/app/home/home.html&lt;/code&gt; 文件的第二段之后。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;*ngIf&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;givenName&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;hr&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;You are logged in as: &lt;span class=&quot;kw&quot;&gt;&amp;lt;b&amp;gt;&lt;/span&gt;{{ givenName }}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;claims&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;strong&amp;gt;&lt;/span&gt;Claims from Identity Token JWT:&lt;span class=&quot;kw&quot;&gt;&amp;lt;/strong&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;pre&amp;gt;&lt;/span&gt;{{claims | json}}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新 &lt;code&gt;src/app/home/home.scss&lt;/code&gt;，添加一些 CSS 让原始的 JSON 看起来舒服一点。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;page-home &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;.claims&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
  }
  pre &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;silver&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#eee&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;padding:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在登录之后你会看到你的姓名及声明信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/2htYdztvTT2lDPprXnjp_home-claims.png&quot; alt=&quot;Home claims&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以退出之后看一下带标识的登录页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/iRNQkyvBTd6GhslsPtoO_login-with-logo.png&quot; alt=&quot;Login with logo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 你可能注意到退出之后标签页并没有消失。我正在查找 &lt;a href=&quot;https://forum.ionicframework.com/t/go-back-to-the-root-page-ionic-2-typescript/49861/9&quot;&gt;没有正常工作&lt;/a&gt; 的原因。&lt;/p&gt;
&lt;h2 id=&quot;发布到移动设备&quot;&gt;发布到移动设备&lt;/h2&gt;
&lt;p&gt;使用 Ionic 在浏览器中开发移动应用是非常酷的事情。很高兴你能看到自己的劳动成果以及优秀的手机应用。但是它的外观和表现还不是原生应用。&lt;/p&gt;
&lt;p&gt;为了查看应用程序在不同设备上的效果，你可以运行 &lt;code&gt;ionic serve --lab&lt;/code&gt;。&lt;code&gt;--lab&lt;/code&gt; 标识会在浏览器中打开一个页面让你查看在不同设备中的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/7T4kY5e1QeqerVh38zr1_ionic-labs.png&quot; alt=&quot;Ionic labs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LoginPage&lt;/code&gt; 在加载时会自动聚焦到 &lt;code&gt;email&lt;/code&gt; 输入框。为了自动激活键盘，你需要告诉 Cordova 没有用户交互的情况下显示键盘是可以的。你可以在根路径的 &lt;code&gt;config.xml&lt;/code&gt; 中添加以下代码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;preference&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;KeyboardDisplayRequiresUserAction&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;ios&quot;&gt;iOS&lt;/h3&gt;
&lt;p&gt;为了模拟或者部署到 iOS 设备上，你需要一个 Mac 以及一个新安装的 &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode&lt;/a&gt;。如果你喜欢在 Windows 中创建 iOS 应用，Ionic 提供了一个 &lt;a href=&quot;http://ionic.io/cloud#packaging&quot;&gt;Ionic Package&lt;/a&gt; 服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确保打开 Xcode 完成安装&lt;/strong&gt; ，然后运行 &lt;code&gt;ionic cordova emulate ios&lt;/code&gt; 在模拟器中打开应用。&lt;/p&gt;
&lt;p&gt;可能会提示你安装 &lt;code&gt;@ionic/cli-plugin-cordova&lt;/code&gt; 插件。当出现提示时输入 &quot;y&quot;，按回车。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIP:&lt;/strong&gt; 我发现在模拟器中运行应用程序时的最大问题是键盘很难弹出。为了解决这一问题，当我需要在输入框输入文本时，我使用 &lt;strong&gt;Hardware&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard&lt;/strong&gt; &amp;gt; &lt;strong&gt;Toggle Software Keyboard&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;如果你在登录页输入凭证，可能什么也不会发生。打开 Safari 转到 &lt;strong&gt;Develop&lt;/strong&gt; &amp;gt; &lt;strong&gt;Simulator&lt;/strong&gt; &amp;gt; MyApp / &lt;strong&gt;Login&lt;/strong&gt;，你会看到控制台有一条错误信息。如果你看不到开发菜单，重新执行 &lt;a href=&quot;https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html&quot;&gt;这篇文章&lt;/a&gt; 中的方法使其生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/HkmwCXDsRxKlJkI1qMQU_webinspector-error.png&quot; alt=&quot;Web Inspector Error&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果打开 Network 标签，你会看到只发送了一条请求 (to &lt;code&gt;/authn&lt;/code&gt;)，它和在浏览器中发送的两条请求 (to &lt;code&gt;/authn&lt;/code&gt; and &lt;code&gt;/authorize&lt;/code&gt;) 有所不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.scotch.io/22364/xElfZbFQjCiQsW1LykSa_devtools-network-requests.png&quot; alt=&quot;DevTools Network Requests&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我相信使用 Cordova 打包 app 之后并不会正常工作，因为通过内嵌的 iframe 向服务端发送请求，然后使用 postMessage 将结果返回当前窗口。Ionic/Cordova 似乎并不支持这种方式。为了解决这个问题，你可以使用 Cordova 提供的 in-app 浏览器直接与 Okta 的 OAuth 服务通信。&lt;a href=&quot;https://twitter.com/nraboy&quot;&gt;Nic Raboy&lt;/a&gt; 演示了在 Facebook 中的操作方法，他在 &lt;a href=&quot;https://www.thepolyglotdeveloper.com/2016/01/using-an-oauth-2-0-service-within-an-ionic-2-mobile-app/&quot;&gt;Ionic 2 移动 App 中使用了 OAuth 2.0 服务&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用以下命令安装 &lt;a href=&quot;https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/&quot;&gt;Cordova In-App Browser plugin&lt;/a&gt; ：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ionic&lt;/span&gt; cordova plugin add cordova-plugin-inappbrowser&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开 &lt;code&gt;src/app/pages/login/login.html&lt;/code&gt;，用一个 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 包裹 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;，为了只在浏览器中运行时显示登录表单。添加一个新的 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;，它会在模拟器或设备上运行时显示。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-content&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; padding&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;ion-row&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- optional logo --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-row&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; showWhen=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;core&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;form&amp;gt;&lt;/span&gt;
     ...
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; hideWhen=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;core&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;button&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ion-button full&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;(click)&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redirectLogin()&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;Login with Okta&lt;span class=&quot;kw&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ion-content&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开 &lt;code&gt;src/pages/login/login.ts&lt;/code&gt; ，在 imports 下面添加一个 &lt;code&gt;window&lt;/code&gt; 的引用。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;declare const window: any;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更容易的使用 OAuth 登录，可以添加以下方法。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;redirectLogin() {
    this.oktaLogin().then(success =&amp;gt; {
      localStorage.setItem('access_token', success.access_token);
      this.oauthService.processIdToken(success.id_token, success.access_token);
      this.navCtrl.push(TabsPage);
    }, (error) =&amp;gt; {
      this.error = error;
    });
  }

  oktaLogin(): Promise&amp;lt;any&amp;gt; {
    return this.oauthService.createAndSaveNonce().then(nonce =&amp;gt; {
      let state: string = Math.floor(Math.random() * 1000000000).toString();
      if (window.crypto) {
        const array = new Uint32Array(1);
        window.crypto.getRandomValues(array);
        state = array.join().toString();
      }
      return new Promise((resolve, reject) =&amp;gt; {
        const oauthUrl = this.buildOAuthUrl(state, nonce);
        const browser = window.cordova.InAppBrowser.open(oauthUrl, '_blank',
          'location=no,clearsessioncache=yes,clearcache=yes');
        browser.addEventListener('loadstart', (event) =&amp;gt; {
          if ((event.url).indexOf('http://localhost:8100') === 0) {
            browser.removeEventListener('exit', () =&amp;gt; {});
            browser.close();
            const responseParameters = ((event.url).split('#')[1]).split('&amp;amp;');
            const parsedResponse = {};
            for (let i = 0; i &amp;lt; responseParameters.length; i++) {
              parsedResponse[responseParameters[i].split('=')[0]] =
                responseParameters[i].split('=')[1];
            }
            const defaultError = 'Problem authenticating with Okta';
            if (parsedResponse['state'] !== state) {
              reject(defaultError);
            } else if (parsedResponse['access_token'] !== undefined &amp;amp;&amp;amp;
              parsedResponse['access_token'] !== null) {
              resolve(parsedResponse);
            } else {
              reject(defaultError);
            }
          }
        });
        browser.addEventListener('exit', function (event) {
          reject('The Okta sign in flow was canceled');
        });
      });
    });
  }

  buildOAuthUrl(state, nonce): string {
    return this.oauthService.issuer + '/oauth2/v1/authorize?' +
        'client_id=' + this.oauthService.clientId + '&amp;amp;' +
        'redirect_uri=' + this.oauthService.redirectUri + '&amp;amp;' +
        'response_type=id_token%20token&amp;amp;' +
        'scope=' + encodeURI(this.oauthService.scope) + '&amp;amp;' +
        'state=' + state + '&amp;amp;nonce=' + nonce;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把在构造器中设置的 &lt;code&gt;redirectUri&lt;/code&gt; 替换成硬编码 &lt;code&gt;http://localhost:8100&lt;/code&gt;。如果省略这一步，当 app 在设备上运行时， &lt;code&gt;window.location.origin&lt;/code&gt; 会跳转到 &lt;code&gt;file://&lt;/code&gt;。为了将它设置成已知的 URL，我们可以通过 in-app browser 的 &quot;loadstart&quot; 事件查找它。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;constructor(private navCtrl: NavController, private oauthService: OAuthService) {
  oauthService.redirectUri = 'http://localhost:8100';
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改之后，需要将 app 重新部署到手机上。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ionic&lt;/span&gt; cordova emulate ios&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以点击 &quot;Login with Okta&quot; 按钮，然后输入合法的凭证进行登录。&lt;/p&gt;
&lt;p&gt;使用这项技术的好处就是 Okta 的登录页具有“记住我”和“忘记密码”的功能，所以不需要自己编写代码。&lt;/p&gt;
&lt;p&gt;为了将 app 部署到 iPhone，首先将手机插到电脑上。然后运行以下命令安装 ios-deploy、构建 app 并在你的设备上运行。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g ios-deploy 
&lt;span class=&quot;kw&quot;&gt;ionic&lt;/span&gt; cordova run ios&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你之前没有为应用程序设置代码签名，则此命令可能会失败。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Signing for &quot;MyApp&quot; requires a development team. Select a development team in the project editor.
Code signing is required for product type 'Application' in SDK 'iOS 10.3'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Xcode 中打开你的项目，运行以下命令。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;open platforms/ios/MyApp.xcodeproj&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://ionicframework.com/docs/intro/deploying/#ios-devices&quot;&gt;Ionic's 开发文档&lt;/a&gt; 有解决这一问题的说明。&lt;/p&gt;
&lt;p&gt;选择你的手机作为 Xcode 的目标，然后点击 play 按钮运行 app。如果你是第一次做，Xcode 可能会加载一段时间，上方会显示一条 &quot;Processing symbol files&quot; 的信息。&lt;/p&gt;
&lt;p&gt;只要你已经设置了你的手机、电脑以及 Apple ID，你就可以打开应用并登录。以下是在我的手机上的展示效果。&lt;/p&gt;
&lt;h3 id=&quot;android&quot;&gt;Android&lt;/h3&gt;
&lt;p&gt;为了模拟或者部署到 Android 设备上，你首先要安装 &lt;a href=&quot;https://developer.android.com/studio/index.html&quot;&gt;Android Studio&lt;/a&gt;。在安装过程中，它会提示你将 Android SDK 安装到哪里。将这个路径设置为 ANDROID_HOME 的环境变量。在 Mac 上，it should be &lt;code&gt;~/Library/Android/sdk/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你已经安装了Android Studio，请确保打开它以完成安装。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了部署到 Android 模拟器，运行 &lt;code&gt;ionic cordova emulate android&lt;/code&gt;。这个命令将安装 Android 支持并打印关于如何创建模拟图像的说明。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Error: No emulator images (avds) found.
1. Download desired System Image by running:
/Users/mraible/Library/Android/sdk/tools/android sdk
2. Create an AVD by running: /Users/mraible/Library/Android/sdk/tools/android avd
HINT: For a faster emulator, use an Intel System Image and install the HAXM device driver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行第一条建议并下载您想要的系统映像。然后运行第二个命令并用以下设置创建一个 AVD（Android 虚拟设备）：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;AVD Name: TestPhone
Device: Nexus 5
Target: Android 7.1.1
CPU/ABI: Google APIs Intel Axom (x86_64)
Skin: Skin with dynamic hardware controls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 这些设置不适用于 Mac 上的 Android Studio 2.3.2 版本。当你尝试运行第一条命令时，它会显示以下内容：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;*************************************************************************
The &quot;android&quot; command is deprecated.
For manual SDK, AVD, and project management, please use Android Studio.
For command-line tools, use tools/bin/sdkmanager and tools/bin/avdmanager
*************************************************************************&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了解决这个问题，打开 Android Studio，选择 &quot;Open an existing Android Studio project&quot;，然后选择 &lt;code&gt;ionic-auth/platforms/android&lt;/code&gt; 的路径。如果提示升级，选择 &quot;OK&quot;，然后继续创建一个新的 AVD ，和 &lt;a href=&quot;https://developer.android.com/studio/run/managing-avds.html#createavd&quot;&gt;Android Studio 文档描述的那样&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;执行完这些步骤之后，你可以运行 &lt;code&gt;ionic cordova emulate android&lt;/code&gt; 查看运行在 AVD 中的 app。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果应用程序显示错误 &quot;连接服务器失败 (&lt;code&gt;file:///android/www/index.html&lt;/code&gt;)&quot;，在 &lt;code&gt;config.xml&lt;/code&gt; 中添加以下代码。这行代码将默认超时时间设置为 60 秒 (默认 20)。感谢 &lt;a href=&quot;https://stackoverflow.com/a/31377846&quot;&gt;Stack Overflow 社区&lt;/a&gt; 对此问题的解答。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;preference&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;loadUrlTimeoutValue&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;60000&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;使用-ionic-开发-pwas&quot;&gt;使用 Ionic 开发 PWAs&lt;/h2&gt;
&lt;p&gt;Ionic 支持创建 progressive web apps (PWAs)。这意味着你可以将 Ionic app 部署成 web app (不是移动端 app) ，它可以在离线的 &lt;a href=&quot;https://caniuse.com/#feat=serviceworkers&quot;&gt;支持 service workers 的浏览器&lt;/a&gt; 中运行。&lt;/p&gt;
&lt;p&gt;想要了解如何使用 service workers 并把 app 转换成 PWA ，可以阅读 &lt;a href=&quot;https://developer.okta.com/blog/2017/05/17/develop-a-mobile-app-with-ionic-and-spring-boot&quot;&gt;如何使用 Ionic 和 Spring Boot 开发移动应用&lt;/a&gt; 的 &lt;a href=&quot;https://developer.okta.com/blog/2017/05/17/develop-a-mobile-app-with-ionic-and-spring-boot#pwas-with-ionic&quot;&gt;PWAs 部分&lt;/a&gt; 。PWA 是可以安装在系统中的 web 应用程序。它可以在离线情况下工作，使用的是你最后一次与 app 交互的数据缓存。添加 PWA 功能可以让 app 加载更快，提供更好的用户体验。想要了解更多关于 PWA 的知识，可以阅读 &lt;a href=&quot;https://scotch.io/tutorials/the-ultimate-guide-to-progressive-web-applications&quot;&gt;The Ultimate Guide to Progressive Web Applications&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;了解更多&quot;&gt;了解更多&lt;/h2&gt;
&lt;p&gt;我希望你喜欢这篇关于 Ionic、Angular 及 Okta 的教程。我喜欢 Ionic 是因为它可以将你的 web 开发技能提升一个档次，并且它可以快速创建仿原生的移动应用。&lt;/p&gt;
&lt;p&gt;你可以在 &lt;a href=&quot;https://github.com/oktadeveloper/okta-ionic-auth-example&quot;&gt;GitHub&lt;/a&gt; 上查看本教程的完整代码。如果你有问题，可以通过 Twitter &lt;a href=&quot;https://twitter.com/mraible&quot;&gt;@mraible&lt;/a&gt; 或者在 &lt;a href=&quot;https://devforum.okta.com/&quot;&gt;Okta's Developer Forums&lt;/a&gt; 上联系我。&lt;/p&gt;
&lt;p&gt;想要了解更多关于 Ionic、Angular 或者 Okta 的知识，可以查看以下资源：&lt;/p&gt;
</description>
<pubDate>Sun, 13 May 2018 12:59:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nzbin/p/9010206.html</dc:identifier>
</item>
<item>
<title>最近面了不少java开发，据此来说下我的感受：哪怕事先只准备1小时，成功概率也能大大提升 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/9032323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/9032323.html</guid>
<description>&lt;p&gt;    本人最近几年一直在做java后端方面的技术面试官，而在最近两周，又密集了面试了一些java初级和高级开发的候选人，在面试过程中，我自认为比较慎重，遇到问题回答不好的候选人，我总会再三从不同方面提问，只有当反复确认能力不行才会下结论，相反，如果候选人给我的印象不错，我也会从多个角度来衡量，以免招进会说但不会干活的“大忽悠”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513131421046-1416475478.png&quot; alt=&quot;&quot; width=&quot;76&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    其实倒也不是我故意要为难候选人，毕竟入职后就是同事，但面试官的职责使然，而且，如果资深的面试官一般也这样。&lt;/p&gt;
&lt;p&gt;    写到这里，恐怕会吓到一些想要面试的朋友，能力强和能力弱都会被多问，那怎么办？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513132239445-1728106139.png&quot; alt=&quot;&quot; width=&quot;86&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这就是本文将要讲到的主题：如何准备Java初级和高级的技术面试。&lt;/p&gt;
&lt;h4&gt;1  换位思考下，如果你面试官，你会怎么做&lt;/h4&gt;
&lt;p&gt;    1 只能通过简历和面试来衡量，别无他法。如果某位大牛确认能力很行，但面试时无法充分地自证能力，那对不起了，过不了，现实就这样。&lt;/p&gt;
&lt;p&gt;    2 如果面试官由于能力不行，招进来一个大忽悠，那估计会被领导骂。而且再也不会被让面试了，给领导的印象就不好了。所以不能评主观印象，而是会有些客观标准，具体而言，就是从多个方面问些题目，答好答坏就看候选人的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513135354054-1933030294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    其实一些题目都差不多，但不同能力的面试官问问题的切入点和渐进程度会不同，而且有经验的面试官会挖掘候选人的优势，并能从候选人的说辞中判断候选人是真懂还是忽悠。 &lt;/p&gt;
&lt;h4&gt;2 总体上说下准备面试的几个方面点&lt;/h4&gt;
&lt;p&gt;    记得之前考政治，某个大题10分，分5个点，每个点的标准答案不多，也就一两句话。比较取巧的做法是，涵盖点要全，每个点无需多说，但要说到点子上。相反，如果在某个点做得再多，其它点没覆盖到，只能拿这个点的分。&lt;/p&gt;
&lt;p&gt;    同理，在面试时，应当综合准备 java Core，数据库，框架，分布式等方面的题目。根据我面试的结果，我发现不少候选人走了弯路，他们或者干脆不准备，准备时可能方法不到位，单准备一个方面。比如只准备了算法题，在这方面回答很好，但其它方面就一无所知了。&lt;/p&gt;
&lt;p&gt;    所以说，没有所谓的一定能成功的面试秘籍，但有可以帮助提升成功率的准备方法。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513151253741-1471169442.png&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   切记，面试前一定得准备，否则成功的可能性很低，准备时，得综合看各方面的点。至于每个点要到什么程度，后文会讲到。 &lt;/p&gt;
&lt;h4&gt;3 架构方面需要准备的点&lt;/h4&gt;
&lt;p&gt;    初级开发而言，需要让面试官感觉出如下的要点。&lt;/p&gt;
&lt;p&gt;    1 熟悉SSM架构，至少在项目里做过。&lt;/p&gt;
&lt;p&gt;    这个的说法是，介绍项目时，用一个业务流程来说spring mvc如何做的。&lt;/p&gt;
&lt;p&gt;    2 知道Spring MVC中的细节，比如@Autowired的用法，如何把url映射到Controller上，ModelAndView对象返回的方式等。&lt;/p&gt;
&lt;p&gt;    3 最好结合项目的用法，说下你是怎么用AOP，拦截器的，比如说可以通过拦截器拦截非法请求，怎么用 AOP输出日志等。&lt;/p&gt;
&lt;p&gt;    4 关于ORM方面，不限用过哪种，但得知道一对一，一多多，多对多等的用法，以及cascade和inverse的用法。&lt;/p&gt;
&lt;p&gt;    5 最好知道声明式事务的做法。&lt;/p&gt;
&lt;p&gt;    如果你要应聘高级开发，那在上述基础上，最好了解如下的知识点：&lt;/p&gt;
&lt;p&gt;    1 Spring Bean的周期 2 最好能通过阅读源代码，说下IOC,AOP以及Spring MVC的工作流程 3 最好能结合反射，说下IOC等的实现原理。4 Spring Boot和Spring Cloud的一些知识点。 &lt;/p&gt;
&lt;h4&gt;4 数据库方面需要准备的点&lt;/h4&gt;
&lt;p&gt;     不少候选人会看很多SQL的技巧，比如select该怎么写，insert又该怎么写，但仅限于此，不会再准备其它的。&lt;/p&gt;
&lt;p&gt;     这样就很吃亏，因为面试官会认为，哪怕是初级开发，SQL语句也该会写，所以这块不会多问，而会问如下方面的问题。&lt;/p&gt;
&lt;p&gt;     1 索引怎么建的，怎么用的？比如我建好了一个索引，在where 语句里写 name like '123%'会不会走索引，怎么情况下不该建索引，哪些语句不会走索引。&lt;/p&gt;
&lt;p&gt;     2 除了索引之外，你有过哪些SQL优化方面的经验，比如分库分表，或通过执行计划查看SQL的优化点。这最好是能结合你做的项目实际来讲。&lt;/p&gt;
&lt;p&gt;     这里，我面试下来，大概有70%的候选人只知道基本SQL的写法，所以哪怕你是只有理论经验，会说一些优化点，也是非常有利的。&lt;/p&gt;
&lt;p&gt;     这块对于高级开发而言，更得了解优化方面的技能。      &lt;/p&gt;
&lt;h4&gt;5 Java Core方面需要准备的点&lt;/h4&gt;
&lt;p&gt;    这块是基础，其实很多问的问题，候选人一定会在项目里用到，但很少能说好说全。&lt;/p&gt;
&lt;p&gt;    这块主要会从集合，多线程，异常处理流程以及JVM虚拟机这些方面来问。&lt;/p&gt;
&lt;p&gt;    集合方面：&lt;/p&gt;
&lt;p&gt;    1 hashcode有没有重写过？在什么场景下需要重写。如果可以，结合hash表的算法，说下hashmap的实现原理。&lt;/p&gt;
&lt;p&gt;    对于高级开发而言，最好通过ConcurrentHashMap来说明下并发方面的底层实现代码。&lt;/p&gt;
&lt;p&gt;    2 ArrayList，LinkedList的差别，比如一个基于数组，一个基于链表，它们均是线程不安全的，ArrayList的扩容做法等。&lt;/p&gt;
&lt;p&gt;    对于高级而言，最好看下底层的代码。&lt;/p&gt;
&lt;p&gt;    3 Set如何实现防重的，比如TreeSet和HashSet等。&lt;/p&gt;
&lt;p&gt;    4 Collection的一些方法，比如比较方法，包装成线程安全的方法等。&lt;/p&gt;
&lt;p&gt;    5 可能有些面试官会问，如何通过ArrayList实现队列或堆栈，这个可以准备下。&lt;/p&gt;

&lt;p&gt;    多线程方面，其实在项目里不怎么会用到，但会问如下的问题：&lt;/p&gt;
&lt;p&gt;    1 synchronized和可重入锁的差别，然后可能会顺便问下信号量等防并发的机制。&lt;/p&gt;
&lt;p&gt;    2 在线程里该如何返回值，其实就是callable runnable 区别。&lt;/p&gt;
&lt;p&gt;    3 一定得通过ThreadLocal或volatile关键字，来说明线程的内存模型。&lt;/p&gt;
&lt;p&gt;    4 线程池方面，会用，了解些常用参数&lt;/p&gt;
&lt;p&gt;    线程方面，可能问得比较多的就是并发机制，如果是高级开发，可能会问得深些。&lt;/p&gt;

&lt;p&gt;    虚拟机方面&lt;/p&gt;
&lt;p&gt;    1 结构图和流程可以大致说下。&lt;/p&gt;
&lt;p&gt;    2 一定得了解针对堆的垃圾回收机制，具体而言，可以画个图，说下年轻代年老代等。&lt;/p&gt;
&lt;p&gt;    3 说下垃圾回收的流程，然后针对性地说下如何在代码中优化内存性能。&lt;/p&gt;
&lt;p&gt;    4 最好说下如果出现了OOM异常，该怎么排查？如何看Dump文件。&lt;/p&gt;
&lt;p&gt;    5 GC的一些概念，比如强弱软引用，finalize方法等，这些可以准备下。 &lt;/p&gt;
&lt;h4&gt;6 算法，设计模式等，其实是虚的&lt;/h4&gt;
&lt;p&gt;    这块好准备，不过话说哪怕这些没回答好，但能证明有相关技能的项目经验，一般也会让过。   &lt;/p&gt;
&lt;p&gt;    不过在这块，不少候选人就本末倒置了，比如就准备算法，设计模式，刚才提到的框架，数据库和Java Core方面就不准备了。这样很吃亏，就好比考政治只复习了一个点，其它一点也不准备。    &lt;/p&gt;
&lt;h4&gt;7 我面试的感受&amp;amp;听到哪类回答就能证明候选人比较资深&lt;/h4&gt;
&lt;p&gt;     1 大多数的候选人（大概7成）直接就来了，不做任何准备。要知道，面试和项目其实有些脱节，哪怕项目做得再好，不做准备照样通不过，只要我确认过这类人确实无法达标，我拒掉他们没任何心理负担，谁让他们不准备？&lt;/p&gt;
&lt;p&gt;    2 还有些候选人态度很好，明显准备过，但没准备到位，比如像刚才所说，只准备了算法，或者在Java Core方面，只看了集合方面的面试题。对于这些同学，哪怕是过了，我也会感到惋惜，毕竟如果面试好些的话，工资也能更高些，至于哪些过不了的，我敢说，如果他们准备过，估计就不是这个结果了。&lt;/p&gt;
&lt;p&gt;    其实我也知道，人无完人，哪怕我自己去面试，也不可能面面俱到，所以，我不会要求候选人什么问题都能回答出，甚至大多答错也没关系，只要能证明自己的能力即可通过面试。&lt;/p&gt;
&lt;p&gt;    我也和不少面试官交流过，根据我们的经验，如果候选人能说出如下的知识点，即能证明他在这个领域比较资深了，在这块，我可能就不会过多地问问题了。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513183443636-1139493659.png&quot; alt=&quot;&quot; width=&quot;173&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     架构方面&lt;/p&gt;
&lt;p&gt;    1 能证明自己可以干活（这不难），同时能结合底层代码说出IOC，AOP或Spring MVC的流程，只要能说出一个即可。或者能说出拦截器，Controller等的高级用法。&lt;/p&gt;
&lt;p&gt;    2 能证明自己有Spring Boot或Spring Cloud的经验，比如能说出些Spring Cloud组件的用法。&lt;/p&gt;
&lt;p&gt;    3 如果能证明自己有分布式开发的经验，那最好了，其实这不难证明，比如能说出服务的包是放在多台机器上（大多数公司其实都这样），而且能说出如何部署，如何通过nginx等做到负载均衡。&lt;/p&gt;

&lt;p&gt;    数据库方面，其实讲清楚一个问题即可：如何进行SQL调优，比如通过索引，看执行计划即可，如果有其它的优化点，说清楚即可。&lt;/p&gt;

&lt;p&gt;    Java Core方面，这里给出些诀窍：&lt;/p&gt;
&lt;p&gt;    1 能结合ConcurrentHashMap的源代码，说出final,volatile,transient的用法，以及在其中如何用Lock对象防止写并发。&lt;/p&gt;
&lt;p&gt;    2 结合一个项目实际，说下设计模式的实践。&lt;/p&gt;
&lt;p&gt;    3 多线程方面，能说出Lock或volatile等高级知识点的用法。&lt;/p&gt;
&lt;p&gt;    4 这块最取巧：说下GC的流程，以及如何通过日志和Dump文件排查OOM异常，如果再高级些的话，说下如何在代码中优化内存代码。    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    诀窍点归结成一个：能结合源代码或项目实际，说出些比较资深的问题。&lt;/strong&gt;    &lt;/p&gt;
&lt;h4&gt;8 本文的侧重点&amp;amp;后文预告&lt;/h4&gt;
&lt;p&gt;    平心而论，在我的博客里，写了不少关于面试技巧的文章，以至于有朋友说我的文章都是套路，卖书的套路。&lt;/p&gt;
&lt;p&gt;    所以在本文里，不介绍我写的书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513184558665-1494242101.png&quot; alt=&quot;&quot; width=&quot;122&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   本人承认，本文中的一些内容在我的其它文章里出现过（不是文字上的复制粘贴，而是意思上的重构），但如果大家读下我的文章，就会发现其它的文章都有侧重点，比如有的侧重于数据库方面面试技巧的准备，有些介绍如何在简历中介绍项目。&lt;/p&gt;
&lt;p&gt;    本文的侧重点是：1 面试一定得准备 （重要的话说三遍，这里已经超过3遍了）2 如何全面充分地准备。&lt;/p&gt;
&lt;p&gt;    至于为什么要写这个文章？我得不停地总结我作为面试官的技巧，这样我在面试中也能更高效更准确地招到合适的人才。&lt;/p&gt;
&lt;p&gt;    另外，我也在策划下本面试的书，这也算积累素材吧（说漏嘴了）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180513185331178-1907970473.png&quot; alt=&quot;&quot; width=&quot;153&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    不过话说回来，这篇文章应该对大家多少有些帮助，因为不是每个面试官都肯泄漏面试内幕的。&lt;/p&gt;
&lt;p&gt;    在后篇博文里，我将在之前博文的基础上讲述如何准备简历，从而提升简历通过初选的概率，之前我写过类似的文章。&lt;/p&gt;
&lt;p&gt;    如果可以，请大家看在我周末还在辛苦码字的基础上，推荐一下这篇文章，如果大家感觉有任何问题，可以问我。&lt;/p&gt;


</description>
<pubDate>Sun, 13 May 2018 12:58:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/9032323.html</dc:identifier>
</item>
<item>
<title>看完这篇Linux基本的操作就会了 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/9033281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/9033281.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个学期开了Linux的课程了，授课的老师也是比较负责任的一位。总的来说也算是比较系统地学习了一下Linux了~~~&lt;/p&gt;
&lt;p&gt;本文章主要是&lt;strong&gt;总结Linux的基础操作以及一些简单的概念&lt;/strong&gt;~如果不熟悉的同学可下个Linux来玩玩(或者去买一个服务器玩玩【学生版的不是很贵】)，对于开发者来说，能使用Linux做一些基本的操作是必要的！&lt;/p&gt;
&lt;p&gt;那么接下来就开始吧，当然了&lt;strong&gt;我的Linux仅仅是入门水平&lt;/strong&gt;，如果有错的地方还需请大家多多包涵，并不吝在评论区指出错误~&lt;/p&gt;

&lt;p&gt;相信&lt;strong&gt;大部分人&lt;/strong&gt;的PC端都是用Windows系统的，那我们为什么要学习Linux这个操作系统呢？？？Windows图形化界面做得这么好，日常基本使用的话，学习成本几乎为零。&lt;/p&gt;
&lt;p&gt;而Linux不一样，&lt;strong&gt;可能&lt;/strong&gt;刚接触Linux的人会认为：Linux好麻烦哦，不好玩，都是字符界面。不直观、这个破系统是用来干嘛的~~&lt;/p&gt;
&lt;p&gt;日常用的话Windows是比较顺手的，但是我们要知道的是：我们开发出来的程序&lt;strong&gt;一般都是放在Linux下运行&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;那可能就会有人提出疑问了：Windows同样是操作系统，&lt;strong&gt;为啥要放在Linux下，而不放在Windows下呢&lt;/strong&gt;？？相信Windows也是可以运行我们写出来的程序的。&lt;/p&gt;
&lt;p&gt;我总结了Linux的&lt;strong&gt;几个优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;很多软件原生是在Linux下运行的，庞大的社区支持，&lt;strong&gt;生态环境好&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开源&lt;/strong&gt;，可被定制，开放，&lt;strong&gt;多用户的网络操作系统&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对安全稳定&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;所以开发者&lt;strong&gt;选择了Linux&lt;/strong&gt;来跑我们自己写出来的程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux系统的组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;linux内核&lt;/strong&gt;（linus 团队管理）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shell&lt;/strong&gt;：用户与内核交互的接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件系统&lt;/strong&gt;：ext3、ext4等。windows 有 fat32 、ntfs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三方应用软件&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;shell的基本知识&quot;&gt;2.1Shell的基本知识&lt;/h2&gt;
&lt;p&gt;除了Shell、其他的都应该挺好懂的，那么&lt;strong&gt;Shell是什么东西呢&lt;/strong&gt;？？？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Shell是系统的用户界面，提供了&lt;strong&gt;用户与内核进行交互操作的一种接口&lt;/strong&gt;(命令解释器)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shell可以执行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内部命令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shell脚本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598551cc699c6?w=507&amp;amp;h=469&amp;amp;f=png&amp;amp;s=22343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;type&lt;/code&gt;命令可以&lt;strong&gt;区分&lt;/strong&gt;内部命令和外部命令&lt;/p&gt;
&lt;p&gt;于是乎，我们利用Shell就可以干下面这些事了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;命令行解释(这是用得最多的！)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;命令的多种执行顺序&lt;/li&gt;
&lt;li&gt;通配符（ wild-card characters ）&lt;/li&gt;
&lt;li&gt;命令补全、别名机制、命令历史&lt;/li&gt;
&lt;li&gt;I/O重定向（ Input/output redirection ）&lt;/li&gt;
&lt;li&gt;管道（ pipes ）&lt;/li&gt;
&lt;li&gt;命令替换（` ` 或$( ) ）&lt;/li&gt;
&lt;li&gt;Shell编程语言（ Shell Script ）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Shell的主要版本有以下这么多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们&lt;strong&gt;常用(默认)&lt;/strong&gt;的就是&lt;strong&gt;bash&lt;/strong&gt;(bourne again shell)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598551d9ab81d?w=999&amp;amp;h=537&amp;amp;f=png&amp;amp;s=59079&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;ps&lt;/code&gt;命令观察正在执行的shell&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985512206081?w=276&amp;amp;h=88&amp;amp;f=png&amp;amp;s=1756&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux基本目录结构&quot;&gt;2.2Linux基本目录结构&lt;/h2&gt;
&lt;p&gt;在Windows下，会有&lt;strong&gt;基本的目录结构&lt;/strong&gt;的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855187bd624?w=1299&amp;amp;h=673&amp;amp;f=png&amp;amp;s=53821&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855148c3a17?w=1123&amp;amp;h=549&amp;amp;f=png&amp;amp;s=19619&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux下也不例外了，也是有基本的目录结构的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359854a7013d31?w=651&amp;amp;h=125&amp;amp;f=png&amp;amp;s=8284&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux 文件系统是一个&lt;strong&gt;目录树的结构&lt;/strong&gt;，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;bin 存放二进制可执行文件(ls,cat,mkdir等)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;boot 存放用于系统引导时使用的各种文件&lt;/li&gt;
&lt;li&gt;dev 用于存放设备文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;etc 存放系统配置文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;home 存放所有用户文件的根目录&lt;/li&gt;
&lt;li&gt;lib 存放跟文件系统中的程序运行所需要的共享库及内核模块&lt;/li&gt;
&lt;li&gt;mnt 系统管理员安装临时文件系统的安装点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;opt 额外安装的可选应用程序包所放置的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;proc 虚拟文件系统，存放当前内存的映射&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root 超级用户目录&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;sbin 存放二进制可执行文件，只有root才能访问&lt;/li&gt;
&lt;li&gt;tmp 用于存放各种临时文件&lt;/li&gt;
&lt;li&gt;usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录&lt;/li&gt;
&lt;li&gt;var 用于存放运行时需要改变数据的文件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;命令基本格式&quot;&gt;2.3命令基本格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cmd [options] [arguments]&lt;/code&gt;，options称为选项，arguments称为参数&lt;/p&gt;
&lt;p&gt;选项和参数都作为Shell命令执行时的输入，它们&lt;strong&gt;之间用空格分隔开&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Linux是&lt;strong&gt;区分大小&lt;/strong&gt;写的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，后面跟的选项如果&lt;strong&gt;单字符&lt;/strong&gt;选项前使用&lt;strong&gt;一个&lt;/strong&gt;&lt;code&gt;减号-&lt;/code&gt;。&lt;strong&gt;单词选项&lt;/strong&gt;前使用两个&lt;code&gt;减号--&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这是一般的情况，有些命令还是不归属这种规律的(相对较少)~~~&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;ls -a&lt;/code&gt;和&lt;code&gt;ls -all&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt; 单个字符使用一个&lt;code&gt;-&lt;/code&gt;，一个单词&lt;code&gt;all&lt;/code&gt; 使用两个&lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Linux中，&lt;strong&gt;可执行的文件&lt;/strong&gt;也进行了分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内置命令&lt;/strong&gt;：出于效率的考虑，将一些常用命令的解释程序&lt;strong&gt;构造在Shell内部&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外置命令&lt;/strong&gt;：存放在/bin、/sbin目录下的命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实用程序&lt;/strong&gt;：存放在/usr/bin、/usr/sbin、/usr/share、/usr/local/bin等目录下的实用程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户程序&lt;/strong&gt;：用户程序经过编译生成可执行文件后，可作为Shell命令运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell脚本&lt;/strong&gt;：由Shell语言编写的批处理文件，可作为Shell命令运行&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通配符&quot;&gt;2.4通配符&lt;/h2&gt;
&lt;p&gt;学过一些正则表达式的或者有点基础的同学对通配符应该就不陌生的了，在Linux也有通配符(在搜索的时候挺有用的)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*：匹配任何字符和任何数目的字符&lt;/li&gt;
&lt;li&gt;?：匹配单一数目的任何字符&lt;/li&gt;
&lt;li&gt;[ ]：匹配[ ]之内的任意一个字符&lt;/li&gt;
&lt;li&gt;[! ]：匹配除了[! ]之外的任意一个字符，!表示非的意思&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;文件的类型&quot;&gt;2.5文件的类型&lt;/h2&gt;
&lt;p&gt;在Linux下文件的类型有这么多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;普通文件&lt;/strong&gt;&lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;code&gt;d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号链接&lt;/strong&gt; &lt;code&gt;l&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块&lt;/li&gt;
&lt;li&gt;软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径(简单地理解为 Windows 中常见的快捷方式)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;字符设备文件 &lt;code&gt;c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;块设备文件&lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;套接字&lt;code&gt;s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命名管道&lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们常见的就是普通文件，目录和符号链接。其他的了解一下即可~&lt;/p&gt;
&lt;p&gt;符号链接参考资料：&lt;/p&gt;
&lt;h2 id=&quot;用户主目录&quot;&gt;2.5.1用户主目录&lt;/h2&gt;
&lt;p&gt;可能在网上查阅资料的时候会出现&lt;strong&gt;用户主目录&lt;/strong&gt;这么一个名词，那他是什么呢？？？&lt;/p&gt;
&lt;p&gt;前面已经说了，我们的Linux是&lt;strong&gt;多用户的网络系统&lt;/strong&gt;！所以，我们可以在Linux下创建多个用户，&lt;strong&gt;每个用户都会有自己专属的空间&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所以，在创建用户时，系统管理员&lt;strong&gt;会给每个用户建立一个主目录&lt;/strong&gt;，通常在&lt;code&gt;/home/&lt;/code&gt;目录下&lt;/li&gt;
&lt;li&gt;比如：用户osmond的主目录为：&lt;code&gt;/home/osmond&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用户&lt;strong&gt;对自己主目录的文件拥有所有权&lt;/strong&gt;，可以在自己的主目录下进行相关操作。&lt;/p&gt;

&lt;p&gt;上面说了一堆的基础概念，这是给我们敲命令之前打了一点基础，在敲命令的同时也会遇到一些比较重要的知识点的。那就到时候再说说了~~~&lt;/p&gt;
&lt;h2 id=&quot;常用的文件目录操作命令&quot;&gt;3.1常用的文件、目录操作命令&lt;/h2&gt;
&lt;p&gt;这是我们&lt;strong&gt;使用得最多&lt;/strong&gt;的命令了，&lt;strong&gt;Linux最基础的命令&lt;/strong&gt;！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可用 &lt;code&gt;pwd&lt;/code&gt;命令查看用户的当前目录&lt;/li&gt;
&lt;li&gt;可用 &lt;code&gt;cd&lt;/code&gt; 命令来切换目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;表示当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;..&lt;/code&gt; 表示当前目录的上一级目录（父目录）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt;表示用 cd 命令切换目录&lt;strong&gt;前&lt;/strong&gt;所在的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 表示&lt;strong&gt;用户主目录&lt;/strong&gt;的绝对路径名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;绝对路径：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以斜线（/）开头 ，描述到文件位置的&lt;strong&gt;完整说明&lt;/strong&gt; ，任何时候你想指定文件名的时候都可以使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;相对路径 ：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不以斜线（/）开头 ，指定&lt;strong&gt;相对于你的当前工作目录而言的位置&lt;/strong&gt; ，可以被用作指定文件名的简捷方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tips:&lt;strong&gt;输入命令的时候要常用tab键来补全&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ls&lt;/code&gt;：显示文件或目录信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt;：当前目录下创建一个空目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rmdir&lt;/code&gt;：要求目录为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch&lt;/code&gt;：生成一个空文件或更改文件的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp&lt;/code&gt;：复制文件或目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mv&lt;/code&gt;：移动文件或目录、文件或目录改名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm&lt;/code&gt;：删除文件或目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ln&lt;/code&gt;：建立链接文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find&lt;/code&gt;：查找文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file/stat&lt;/code&gt;：查看文件类型或文件属性信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat：&lt;/code&gt;查看文本文件内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;more：&lt;/code&gt;可以分页看&lt;/li&gt;
&lt;li&gt;&lt;code&gt;less：&lt;/code&gt;不仅可以分页，还可以方便地搜索，回翻等操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tail -10&lt;/code&gt;： 查看文件的尾部的10行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head -20&lt;/code&gt;：查看文件的头部20行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo&lt;/code&gt;：把内容重定向到指定的文件中 ，有则打开，无则创建&lt;/li&gt;
&lt;li&gt;&lt;code&gt;管道命令 |&lt;/code&gt; ：将前面的结果给后面的命令，例如：&lt;code&gt;ls -la | wc&lt;/code&gt;，将ls的结果加油wc命令来统计字数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;重定向 &amp;gt; 是覆盖模式，&amp;gt;&amp;gt; 是追加模式&lt;/code&gt;，例如：&lt;code&gt;echo &quot;Java3y,zhen de hen xihuan ni&quot; &amp;gt; qingshu.txt&lt;/code&gt;把左边的输出放到右边的文件里去&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;学了这些命令我们能干嘛？&lt;strong&gt;其实就是在Windows下复制文件、粘贴文件、创建文件、查看文件这几种&lt;/strong&gt;~~~&lt;/p&gt;
&lt;h3 id=&quot;常用的文件目录操作练习题&quot;&gt;3.1.1常用的文件、目录操作练习题&lt;/h3&gt;
&lt;p&gt;巩固一下基础，&lt;strong&gt;来做做题目：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）Linux的shell程序默认是&lt;code&gt;bash 程序&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;（2）Linux命令格式包含三个部分，分别是： &lt;code&gt;命令&lt;/code&gt; 、 &lt;code&gt;选项&lt;/code&gt; 、 &lt;code&gt;参数&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（3）Linux命令选项前为单个减号（-），后面一般为 &lt;code&gt;单字符&lt;/code&gt; ，选项前为双减号（--），后面一般为 &lt;code&gt;单词&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（4）Linux命令中使用的通配符有 &lt;code&gt;？ * []&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（5）命令 ls /usr/bin/w* 的效果是 &lt;code&gt;列出指定目录下的所有以w开头的文件或目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（6）命令 ls /usr/bin/w?? 的效果是 &lt;code&gt;列出指定目录下的以w开头名称长度为3的所有文件或目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（7）命令 ls /usr/bin/[xyz]* 的效果是 &lt;code&gt;列出指定目录下的文件名以x或y或z开头的所有文件或目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（8）命令 ls /usr/bin/[!a-h]* 的效果是 &lt;code&gt;列出指定目录下的文件名不以a到h区间字母开头的所有文件或目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（9）目录操作时，“.” 表示 &lt;code&gt;当前目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（10）目录操作时，“..” 表示 &lt;code&gt;上一级目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（11）目录操作时，“-” 表示 &lt;code&gt;上一次工作目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（12）目录操作时，“~” 表示 &lt;code&gt;用户主目录&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（13）命令ln可以建立文件链接，这种链接分为： &lt;code&gt;硬链接&lt;/code&gt; 和 &lt;code&gt;软链接&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;（14）命令touch可以改变文件的三种时间，分别是： &lt;code&gt;access time&lt;/code&gt; 、 &lt;code&gt;modify time&lt;/code&gt; 、 &lt;code&gt;change time&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入/tmp目录，建立一个文件，goldXX（XX为学号的末两位），查看文件的时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598550d05e97e?w=535&amp;amp;h=210&amp;amp;f=png&amp;amp;s=5919&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在账户的主目录中，建立一个dog目录，进入dog目录后，建立一个catXX（XX为学号的末两位）目录,进入catXX目录，显示当前目录；然后返回上一级目录，删除catXX目录；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985fb2a3e8f4?w=325&amp;amp;h=188&amp;amp;f=png&amp;amp;s=3408&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;复制/etc/passwd文件到账户主目录，修改账户主目录下passwd为passwdXX（XX为学号的末两位）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985558e4527c?w=450&amp;amp;h=86&amp;amp;f=png&amp;amp;s=2201&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;查找文件名叫做zcat的文件；复制该文件到/tmp目录；用长格式列出该文件；然后删除/tmp目录下的所有文件，并检查文件是否已被删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985562f7c516?w=444&amp;amp;h=245&amp;amp;f=png&amp;amp;s=5939&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;复制/etc/hosts文件到账户主目录下；在账户主目录中建立一个硬链接文件（文件名为hostsYYY（YYY为学生姓名拼音缩写）），链接到主目录下的hosts文件；分别查看hosts和hostsYYY的文件的inode信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598556096aebb?w=522&amp;amp;h=318&amp;amp;f=png&amp;amp;s=9565&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;复制/usr/bin/vdir文件到账户主目录下；在账户主目录中建立一个软链接文件（文件名为newdir），链接到主目录下的vdir文件；分别查看vdir和newdir的文件的inode信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985572995cc4?w=508&amp;amp;h=323&amp;amp;f=png&amp;amp;s=9663&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;用长格式列出目录/usr/bin目录下的所有文件，输出重新定向到文件outXX（XX为学生学号末两位），检查结果；用长格式列出目录/etc目录下的所有文件，输出结果补充到文件outXX末尾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598557fd77046?w=446&amp;amp;h=130&amp;amp;f=png&amp;amp;s=3028&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用长格式列出/usr/bin目录下的所有文件，通过管道与more命令连接，实现对文件列表的浏览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855b13c81d9?w=638&amp;amp;h=401&amp;amp;f=png&amp;amp;s=12526&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;和&amp;gt;&amp;gt;&lt;/code&gt;有何区别？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：&lt;code&gt;&amp;gt;&lt;/code&gt;是&lt;strong&gt;覆盖&lt;/strong&gt;方式重定向到新的文件；&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;是以&lt;strong&gt;补充&lt;/strong&gt;方式，添加到原文件的末尾。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过管道和more命令，浏览文件列表方便在哪里？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：对于文件列表超出一个屏幕显示的情况，这种方式可以&lt;strong&gt;分屏浏览，比较方便&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;文件打包和压缩命令&quot;&gt;3.2文件打包和压缩命令&lt;/h2&gt;
&lt;p&gt;在Windows操作系统下，我们会使用WinRAR或者快压等等的压缩软件来进行压缩或者解压。&lt;/p&gt;
&lt;p&gt;在Linux下&lt;strong&gt;当然也存在压缩或解压的操作咯&lt;/strong&gt;，下面我们就来学习一下在Linux下是怎么压缩和解压的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855aefa276d?w=1025&amp;amp;h=533&amp;amp;f=png&amp;amp;s=64338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855b69a008d?w=997&amp;amp;h=614&amp;amp;f=png&amp;amp;s=37720&quot;/&gt;&lt;/p&gt;
&lt;p&gt;压缩的方式也是有好几种，我们&lt;strong&gt;常用&lt;/strong&gt;的有下面这三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gzip&lt;/li&gt;
&lt;li&gt;bzip2&lt;/li&gt;
&lt;li&gt;tar&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的压缩的命令就有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;gzip filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bzip2 filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -czvf filename&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的解压命令有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;gzip -d filename.gz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bzip2 -d filename.bz2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -xzvf filename.tar.gz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;正则表达式grep&quot;&gt;3.3正则表达式+grep&lt;/h2&gt;
&lt;p&gt;上面我们已经学过了&lt;code&gt;cat、more、less、tail&lt;/code&gt;这些查看文本文件的命令了，但是我想&lt;strong&gt;快速查看这个文本文件下的某些关键字是否存在&lt;/strong&gt;，那怎么办？？？&lt;/p&gt;
&lt;p&gt;在Windows下就比较简单的，几乎所有的文本编辑器(记事本)都支持&lt;code&gt;CTRL+F&lt;/code&gt;，往里面输入关键字就可查找出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855bd57ef72?w=1909&amp;amp;h=640&amp;amp;f=png&amp;amp;s=44622&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那在Linux下，没有图形界面，没有&lt;code&gt;CTRL+F&lt;/code&gt;的情况下，&lt;strong&gt;如果不懂一些命令的话，那还真是难找对应的字符出来&lt;/strong&gt;。下面我就来说说如何快速&lt;strong&gt;查找一个文本文件下的某些字符&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;正则表达式&quot;&gt;3.3.1正则表达式&lt;/h3&gt;
&lt;p&gt;首先我们就来说说正则表达式，如果接触过的同学就知道：这玩意并不好记。一旦不用就很容易就忘记了，所以只能在用的时候查查了~~~所以下面我就直接给出一些规则了，不多说啦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855c6fca3cf?w=1004&amp;amp;h=633&amp;amp;f=png&amp;amp;s=65006&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855f61dd75a?w=1071&amp;amp;h=572&amp;amp;f=png&amp;amp;s=48537&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;grep命令&quot;&gt;3.3.2grep命令&lt;/h3&gt;
&lt;p&gt;grep(global search regular expression)是一个&lt;strong&gt;强大的文本搜索工具&lt;/strong&gt;。grep 使用正则表达式搜索文本，并把匹配的行打印出来。&lt;/p&gt;
&lt;p&gt;格式：&lt;code&gt;grep [options] PATTERN [FILE...]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PATTERN 是查找条件：&lt;strong&gt;可以是普通字符串、可以是正则表达式&lt;/strong&gt;，通常用单引号将RE括起来。&lt;/li&gt;
&lt;li&gt;FILE 是要查找的文件，可以是用空格间隔的多个文件，也可是使用Shell的通配符在多个文件中查找PATTERN，省略时表示在标准输入中查找。&lt;/li&gt;
&lt;li&gt;grep命令不会对输入文件进行任何修改或影响，可以使用输出重定向将结果存为文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在文件 myfile 中查找包含字符串 mystr的行
&lt;ul&gt;&lt;li&gt;&lt;code&gt;grep -n mystr myfile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;显示 myfile 中第一个字符为字母的所有行
&lt;ul&gt;&lt;li&gt;&lt;code&gt;grep '^[a-zA-Z]' myfile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在文件 myfile 中查找首字符不是 # 的行（&lt;strong&gt;即过滤掉注释行&lt;/strong&gt;）
&lt;ul&gt;&lt;li&gt;&lt;code&gt;grep -v '^#' myfile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;列出/etc目录（包括子目录）下所有文件内容中包含字符串“root”的文件名
&lt;ul&gt;&lt;li&gt;&lt;code&gt;grep -lr root /etc/*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用grep查找/etc/passwd文件中以a开头的行，要求显示行号；查找/etc/passwd文件中以login结束的行；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359855f950da9f?w=616&amp;amp;h=385&amp;amp;f=png&amp;amp;s=14435&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;几种提高工作效率的方法&quot;&gt;3.4几种提高工作效率的方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;自动补全命令&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史命令&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;上下箭头键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;别名alias&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里感觉要说说的就只有别名alias了，我们下面看看例子就懂了！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;显示shell当前已经定义的别名；执行其中的两个定义别名的命令；定义一个别名grep，要求其采用彩色方式显示结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985612bad5c6?w=538&amp;amp;h=269&amp;amp;f=png&amp;amp;s=5479&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598561a9d2927?w=485&amp;amp;h=83&amp;amp;f=png&amp;amp;s=2463&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;shell变量-和-shell环境&quot;&gt;3.5Shell变量 和 Shell环境&lt;/h2&gt;
&lt;p&gt;在Windows下有用户的环境变量，系统的环境变量。在Linux一样也是有的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985fb2af4d18&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Shell 变量大致可以&lt;strong&gt;分为三类&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内部变量&lt;/strong&gt;：由系统提供，用户只能使用不能修改。
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境变量&lt;/strong&gt;：这些变量决定了用户工作的环境，它们不需要用户去定义，可以直接在 shell 中使用，其中某些变量用户可以修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户变量&lt;/strong&gt;：由用户建立和修改，在 shell 脚本编写中会经常用到。
&lt;ul&gt;&lt;li&gt;变量赋值（定义变量）
&lt;ul&gt;&lt;li&gt;&lt;code&gt;varName=Value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export varName=Value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;引用变量&lt;code&gt;$varName&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Shell变量的&lt;strong&gt;作用域&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt;的作用范围仅仅&lt;strong&gt;限制在其命令行所在的Shell或Shell脚本文件中&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt;的作用范围则包括&lt;strong&gt;本Shell进程及其所有子进程&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;局部变量与全局变量&lt;strong&gt;互换&lt;/strong&gt;：可以使用 &lt;code&gt;export&lt;/code&gt; 内置命令将局部变量设置为全局变量。 可以使用 &lt;code&gt;export&lt;/code&gt; 内置命令将全局变量设置为局部变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;export命令&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;显示&lt;/strong&gt;当前Shell可见的全局变量
&lt;ul&gt;&lt;li&gt;&lt;code&gt;export [-p]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定义变量值的同时声明为全局变量&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;export &amp;lt;变量名1=值1&amp;gt; [&amp;lt;变量名2=值2&amp;gt; ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;声明已经赋值的某个（些）&lt;strong&gt;局部变量为全局变量&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;export &amp;lt;变量名1&amp;gt; [&amp;lt;变量名2&amp;gt; ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;声明已经赋值的某个（些）&lt;strong&gt;全局变量为局部变量&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;export -n &amp;lt;变量名1&amp;gt; [&amp;lt;变量名2&amp;gt; ...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Shell环境变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环境变量定义 Shell 的&lt;strong&gt;运行环境&lt;/strong&gt;，保证 Shell 命令的正确执行。&lt;/li&gt;
&lt;li&gt;Shell用环境变量来确定查找路径、注册目录、终端类型、终端名称、用户名等。&lt;/li&gt;
&lt;li&gt;所有环境变量&lt;strong&gt;都是全局变量&lt;/strong&gt;（即可以传递给 Shell 的子进程），并可以由用户重新设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985fb2b79111?w=994&amp;amp;h=699&amp;amp;f=png&amp;amp;s=68837&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Shell变量：查询、显示和取消&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显示当前已经定义的所有变量
&lt;ul&gt;&lt;li&gt;所有&lt;strong&gt;环境变量&lt;/strong&gt;：&lt;code&gt;env&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有&lt;strong&gt;变量和函数&lt;/strong&gt;（包括环境变量） ：&lt;code&gt;set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;显示某（些）个变量的值
&lt;ul&gt;&lt;li&gt;&lt;code&gt;echo $NAME1 [$NAME2 ……]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;取消变量的声明或赋值
&lt;ul&gt;&lt;li&gt;&lt;code&gt;unset &amp;lt;NAME&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;shell变量-和-shell环境练习题&quot;&gt;3.5.1Shell变量 和 Shell环境练习题&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;定义Shell变量stuXX（XX为学生学号末两位），初值为学生姓名全拼，用echo命令显示stuXX变量的值；用unset命令取消stuXX变量，检查结果；用env命令观察当前有哪些已经定义好的shell环境变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985fb2d4fee6?w=349&amp;amp;h=132&amp;amp;f=png&amp;amp;s=2444&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985fb2efdafc?w=507&amp;amp;h=385&amp;amp;f=png&amp;amp;s=9796&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Shell环境变量的值是否可以修改？为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：环境变量的值一般情况下，可以修改。但一定要&lt;strong&gt;慎重修改&lt;/strong&gt;，因为一旦修改错误，对shell正常运行造成严重影响，甚至导致shell无法运行。&lt;/p&gt;

&lt;p&gt;相信没有用过Linux的同学在看一些段子的时候都会看到过两个编辑器：&lt;/p&gt;
&lt;p&gt;下面我们学习如何简单使用vi。vi 是 “Visual interface” 的简称，它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且&lt;strong&gt;用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vi可以看做成我们Windows下的记事本&lt;/li&gt;
&lt;li&gt;vim 即 Vi IMproved，vi 克隆版本之一&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用Vi来编辑文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985fb3082c3e?w=1020&amp;amp;h=618&amp;amp;f=png&amp;amp;s=59083&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Vi有三种模式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985feb23834e?w=1010&amp;amp;h=635&amp;amp;f=png&amp;amp;s=103599&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;普通模式&quot;&gt;4.1普通模式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;G&lt;/code&gt;用于直接跳转到文件尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZZ&lt;/code&gt;用于存盘退出Vi&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZQ&lt;/code&gt;用于不存盘退出Vi&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/和？&lt;/code&gt;用于查找字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;继续查找下一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yy&lt;/code&gt;复制一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;粘帖在下一行，P粘贴在前一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt;删除一行文本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;删除光标所在的字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt;取消上一次编辑操作（undo）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;插入模式&quot;&gt;4.2插入模式&lt;/h2&gt;
&lt;p&gt;在 Normal 模式下输入插入命令 &lt;code&gt;i、 a 、 o&lt;/code&gt;进入insert模式。用户输入的任何字符都被vim&lt;strong&gt;当做文件内容保存起来&lt;/strong&gt;，并将其显示在屏幕上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在文本输入过程中，若想回到Normal模式下，按 Esc 键即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;命令行模式&quot;&gt;4.3命令行模式&lt;/h2&gt;
&lt;p&gt;Normal 模式下，用户按冒号 &lt;code&gt;:&lt;/code&gt;即可进入 Command 模式，此时 vim 会在显示窗口的最后一行 (屏幕的最后一行) 显示一个 “:” 作为 Command 模式的提示符，等待输入命令。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;:w&lt;/code&gt; 保存当前编辑文件，但并不退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w&lt;/code&gt; newfile 存为另外一个名为 “newfile” 的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt; 用于存盘退出Vi&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q!&lt;/code&gt; 用于不存盘退出Vi&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt;用于直接退出Vi （未做修改）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;设置Vi环境:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;:set autoindent 缩进,常用于程序的编写&lt;/li&gt;
&lt;li&gt;:set noautoindent 取消缩进&lt;/li&gt;
&lt;li&gt;:set number 在编辑文件时显示行号&lt;/li&gt;
&lt;li&gt;:set nonumber 不显示行号&lt;/li&gt;
&lt;li&gt;:set tabstop=value 设置显示制表符的空格字符个数&lt;/li&gt;
&lt;li&gt;:set 显示设置的所有选项&lt;/li&gt;
&lt;li&gt;:set all 显示所有可以设置的选项&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;vi练习题&quot;&gt;4.4Vi练习题&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在用户主目录下，执行vi程序，编辑文件install.log；移动光标到第10行，第五个字符；按大写字母G，达到文件末尾；不存盘退出；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359856ab7c2e22?w=364&amp;amp;h=196&amp;amp;f=png&amp;amp;s=4970&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/16359856ea9fcab3?w=332&amp;amp;h=290&amp;amp;f=png&amp;amp;s=5782&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在用户主目录下，执行vi程序，编辑文件install.log；用/命令查找字符串sudo，复制包含字符串sudo的行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598571772b6b0?w=335&amp;amp;h=303&amp;amp;f=png&amp;amp;s=6657&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在用户主目录下，执行vi程序，编辑文件install.log；进入命令模式，设置显示行号；用？命令查找字符串openssh，用命令n查找下一个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/163598573e5767f6?w=478&amp;amp;h=53&amp;amp;f=png&amp;amp;s=1762&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985742bfdce6?w=443&amp;amp;h=73&amp;amp;f=png&amp;amp;s=2138&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文主要讲解了Linux的最基础的知识，可以简单地操作Linux了。命令可以说是学不完的，只能是记住Linux是有这个功能，到时候去网上查查也很方便。&lt;/p&gt;
&lt;p&gt;主要是多练、多玩就可以记住一些常用的Linux命令了~~~~&lt;/p&gt;
&lt;p&gt;下面我就花点时间画个Linux命令的脑图(当然了，&lt;strong&gt;命令仅限于是本文章的知识点&lt;/strong&gt;，等写到用户、网络等知识点的时候再继续补充上去！)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/13/1635985762c94aa9?w=3315&amp;amp;h=1526&amp;amp;f=png&amp;amp;s=474365&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;。为了大家方便，刚新建了一下&lt;strong&gt;qq群：742919422&lt;/strong&gt;，大家也可以去交流交流。谢谢支持了！希望能多介绍给其他有需要的朋友&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;文章的目录导航&lt;/strong&gt;：&lt;/p&gt;
</description>
<pubDate>Sun, 13 May 2018 12:51:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/9033281.html</dc:identifier>
</item>
<item>
<title>特征工程之特征选择 - 刘建平Pinard</title>
<link>http://www.cnblogs.com/pinard/p/9032759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinard/p/9032759.html</guid>
<description>&lt;p&gt;　　　　特征工程是数据分析中最耗时间和精力的一部分工作，它不像算法和模型那样是确定的步骤，更多是工程上的经验和权衡。因此没有统一的方法。这里只是对一些常用的方法做一个总结。本文关注于特征选择部分。后面还有两篇会关注于特征表达和特征预处理。&lt;/p&gt;

&lt;p&gt;　　　　在做数据分析的时候，特征的来源一般有两块，一块是业务已经整理好各种特征数据，我们需要去找出适合我们问题需要的特征；另一块是我们从业务特征中自己去寻找高级数据特征。我们就针对这两部分来分别讨论。&lt;/p&gt;

&lt;p&gt;　　　　我们首先看当业务已经整理好各种特征数据时，我们如何去找出适合我们问题需要的特征，此时特征数可能成百上千，哪些才是我们需要的呢？&lt;/p&gt;
&lt;p&gt;　　　　第一步是找到该领域懂业务的专家，让他们给一些建议。比如我们需要解决一个药品疗效的分类问题，那么先找到领域专家，向他们咨询哪些因素（特征）会对该药品的疗效产生影响，较大影响的和较小影响的都要。这些特征就是我们的特征的第一候选集。&lt;/p&gt;
&lt;p&gt;　　　　这个特征集合有时候也可能很大，在尝试降维之前，我们有必要用特征工程的方法去选择出较重要的特征结合，这些方法不会用到领域知识，而仅仅是统计学的方法。&lt;/p&gt;
&lt;p&gt;　　　　最简单的方法就是方差筛选。方差越大的特征，那么我们可以认为它是比较有用的。如果方差较小，比如小于1，那么这个特征可能对我们的算法作用没有那么大。最极端的，如果某个特征方差为0，即所有的样本该特征的取值都是一样的，那么它对我们的模型训练没有任何作用，可以直接舍弃。在实际应用中，我们会指定一个方差的阈值，当方差小于这个阈值的特征会被我们筛掉。sklearn中的VarianceThreshold类可以很方便的完成这个工作。&lt;/p&gt;
&lt;p&gt;　　　　特征选择方法有很多，一般分为三类：第一类过滤法比较简单，它按照特征的发散性或者相关性指标对各个特征进行评分，设定评分阈值或者待选择阈值的个数，选择合适特征。上面我们提到的方差筛选就是过滤法的一种。第二类是包装法，根据目标函数，通常是预测效果评分，每次选择部分特征，或者排除部分特征。第三类嵌入法则稍微复杂一点，它先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值系数从大到小来选择特征。类似于过滤法，但是它是通过机器学习训练来确定特征的优劣，而不是直接从特征的一些统计学指标来确定特征的优劣。下面我们分别来看看3类方法。&lt;/p&gt;
&lt;h2&gt;2.1 过滤法选择特征&lt;/h2&gt;
&lt;p&gt;　　　　上面我们已经讲到了使用特征方差来过滤选择特征的过程。除了特征的方差这第一种方法，还有其他一些统计学指标可以使用。&lt;/p&gt;
&lt;p&gt;　　　　第二个可以使用的是相关系数。这个主要用于输出连续值的监督学习算法中。我们分别计算所有训练集中各个特征与输出值之间的相关系数，设定一个阈值，选择相关系数较大的部分特征。&lt;/p&gt;
&lt;p&gt;　　　　第三个可以使用的是假设检验，比如卡方检验。卡方检验可以检验某个特征分布和输出值分布之间的相关性。个人觉得它比比粗暴的方差法好用。如果大家对卡方检验不熟悉，可以参看这篇&lt;a title=&quot;卡方检验原理及应用&quot; href=&quot;https://segmentfault.com/a/1190000003719712&quot; target=&quot;_blank&quot;&gt;卡方检验原理及应用&lt;/a&gt;，这里就不展开了。在sklearn中，可以使用chi2这个类来做卡方检验得到所有特征的卡方值与显著性水平P临界值，我们可以给定卡方值阈值， 选择卡方值较大的部分特征。&lt;/p&gt;
&lt;p&gt;　　　　除了卡方检验，我们还可以使用F检验和t检验，它们都是使用假设检验的方法，只是使用的统计分布不是卡方分布，而是F分布和t分布而已。在sklearn中，有F检验的函数f_classif和f_regression，分别在分类和回归特征选择时使用。&lt;/p&gt;
&lt;p&gt;　　　　第四个是互信息，即从信息熵的角度分析各个特征和输出值之间的关系评分。在&lt;a title=&quot;决策树&quot; href=&quot;http://www.cnblogs.com/pinard/p/6050306.html&quot; target=&quot;_blank&quot;&gt;决策树&lt;/a&gt;算法中我们讲到过互信息（信息增益）。互信息值越大，说明该特征和输出值之间的相关性越大，越需要保留。在sklearn中，可以使用mutual_info_classif(分类)和mutual_info_regression(回归)来计算各个输入特征和输出值之间的互信息。&lt;/p&gt;
&lt;p&gt;　　　　以上就是过滤法的主要方法，个人经验是，在没有什么思路的 时候，可以优先使用卡方检验和互信息来做特征选择&lt;/p&gt;
&lt;h2&gt;2.2 包装法选择特征&lt;/h2&gt;
&lt;p&gt;　　　　包装法的解决思路没有过滤法这么直接，它会选择一个目标函数来一步步的筛选特征。&lt;/p&gt;
&lt;p&gt;　　　　最常用的包装法是递归消除特征法(recursive feature elimination,以下简称RFE)。递归消除特征法使用一个机器学习模型来进行多轮训练，每轮训练后，消除若干权值系数的对应的特征，再基于新的特征集进行下一轮训练。在sklearn中，可以使用RFE函数来选择特征。&lt;/p&gt;
&lt;p&gt;　　　　我们下面以经典的SVM-RFE算法来讨论这个特征选择的思路。这个算法以支持向量机来做RFE的机器学习模型选择特征。它在第一轮训练的时候，会选择所有的特征来训练，得到了分类的超平面$w \dot x+b=0$后，如果有n个特征，那么RFE-SVM会选择出$w$中分量的平方值$w_i^2$最小的那个序号i对应的特征，将其排除，在第二类的时候，特征数就剩下n-1个了，我们继续用这n-1个特征和输出值来训练SVM，同样的，去掉$w_i^2$最小的那个序号i对应的特征。以此类推，直到剩下的特征数满足我们的需求为止。&lt;/p&gt;
&lt;h2&gt;2.3 嵌入法选择特征&lt;/h2&gt;
&lt;p&gt;　　　　嵌入法也是用机器学习的方法来选择特征，但是它和RFE的区别是它不是通过不停的筛掉特征来进行训练，而是使用的都是特征全集。在sklearn中，使用SelectFromModel函数来选择特征。&lt;/p&gt;
&lt;p&gt;　　　　最常用的是使用L1正则化和L2正则化来选择特征。在之前讲到的&lt;a id=&quot;ArchiveMonth1_Days_ctl00_Entries_TitleUrl_20&quot; class=&quot;entrylistItemTitle&quot; href=&quot;http://www.cnblogs.com/pinard/p/6023000.html&quot;&gt;用scikit-learn和pandas学习Ridge回归&lt;/a&gt;第6节中，我们讲到正则化惩罚项越大，那么模型的系数就会越小。当正则化惩罚项大到一定的程度的时候，部分特征系数会变成0，当正则化惩罚项继续增大到一定程度时，所有的特征系数都会趋于0. 但是我们会发现一部分特征系数会更容易先变成0，这部分系数就是可以筛掉的。也就是说，我们选择特征系数较大的特征。常用的L1正则化和L2正则化来选择特征的基学习器是逻辑回归。&lt;/p&gt;
&lt;p&gt;　　　　此外也可以使用决策树或者GBDT。那么是不是所有的机器学习方法都可以作为嵌入法的基学习器呢？也不是，一般来说，可以得到特征系数coef或者可以得到特征重要度(feature importances)的算法才可以做为嵌入法的基学习器。&lt;/p&gt;

&lt;p&gt;　　　　在我们拿到已有的特征后，我们还可以根据需要寻找到更多的高级特征。比如有车的路程特征和时间间隔特征，我们就可以得到车的平均速度这个二级特征。根据车的速度特征，我们就可以得到车的加速度这个三级特征，根据车的加速度特征，我们就可以得到车的加加速度这个四级特征。。。也就是说，高级特征可以一直寻找下去。&lt;/p&gt;
&lt;p&gt;　　　　在Kaggle之类的算法竞赛中，高分团队主要使用的方法除了集成学习算法，剩下的主要就是在高级特征上面做文章。所以寻找高级特征是模型优化的必要步骤之一。当然，在第一次建立模型的时候，我们可以先不寻找高级特征，得到以后基准模型后，再寻找高级特征进行优化。&lt;/p&gt;
&lt;p&gt;　　　　寻找高级特征最常用的方法有：&lt;/p&gt;
&lt;p&gt;　　　　若干项特征加和： 我们假设你希望根据每日销售额得到一周销售额的特征。你可以将最近的7天的销售额相加得到。&lt;br/&gt;　　　　若干项特征之差： 假设你已经拥有每周销售额以及每月销售额两项特征，可以求一周前一月内的销售额。&lt;br/&gt;　　　　若干项特征乘积： 假设你有商品价格和商品销量的特征，那么就可以得到销售额的特征。&lt;br/&gt;　　　　若干项特征除商： 假设你有每个用户的销售额和购买的商品件数，那么就是得到该用户平均每件商品的销售额。&lt;/p&gt;
&lt;p&gt;　　　　当然，寻找高级特征的方法远不止于此，它需要你根据你的业务和模型需要而得，而不是随便的两两组合形成高级特征，这样容易导致特征爆炸，反而没有办法得到较好的模型。个人经验是，聚类的时候高级特征尽量少一点，分类回归的时候高级特征适度的多一点。&lt;/p&gt;

&lt;p&gt;　　　　特征选择是特征工程的第一步，它关系到我们机器学习算法的上限。因此原则是尽量不错过一个可能有用的特征，但是也不滥用太多的特征。&lt;/p&gt;

&lt;p&gt;（欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com） &lt;/p&gt;
</description>
<pubDate>Sun, 13 May 2018 12:13:00 +0000</pubDate>
<dc:creator>刘建平Pinard</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pinard/p/9032759.html</dc:identifier>
</item>
<item>
<title>项目微管理19 - 单挑 - 沙场秋点兵</title>
<link>http://www.cnblogs.com/dxy1982/p/9032971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxy1982/p/9032971.html</guid>
<description>&lt;p&gt;四代曾经记得有一篇这样的文章是这样说的：“所谓管理，就是沟通，沟通，再沟通！”四代觉得非常的有道理，这是在团队对话中，四代说过的最多的一句话，没有之一。&lt;/p&gt;

&lt;p&gt;目前，四代碰到过的团队问题，不管是任务分配不明确、功能实现不清晰、产品发布不顺利，还是队员之间互相不理解、团队之间协作不顺畅、利益之间分配不公平，基本都可以归结为“沟通”的问题，或者说是“沟通”出了问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;YY计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;PC团队的沟通采用的基本上是前面谈到的直接的沟通的几种方式，包括面对面，即时聊天工具和邮件。&lt;/p&gt;

&lt;p&gt;这些方式中，四代最喜欢采用的就是面对面的方式，这里包括非正式的聊天，比如吃饭时，休息时，也包括正式的“一对一”的聊天，四代称之为“单挑”，简称“YY”。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513192030971-1892727019.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四队为鼬和路飞都制定了每月一次的YY计划，鼬是每月第一周的周二，路飞是第二周的周四。&lt;/p&gt;

&lt;p&gt;虽然很多管理圣经都强调，管理者最重要的职责就是与员工沟通，最好与每个员工的沟通要保持在至少两周一次，但是对于技术团队，因为任务情况比较平稳，社会关系也比较简单，而且大部分人的性格也比较直率，在正常的情况下，四代觉得一月一次就可以了。&lt;/p&gt;

&lt;p&gt;四代期望在平时的非正式的聊天中能解决大部分的问题，只有一些平时不好解决的问题，会保留到YY聊天中正式提出来。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513192159809-1626677309.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;四代是这么想的，也是这么做的，第一次给四代留下的印象非常深。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;不要让问题过夜&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;记得鼬来了以后，由于做事非常谨慎，所以四代把一些日常的一些工作交给鼬来完成。&lt;/p&gt;

&lt;p&gt;其中一项工作需要和客户沟通，鼬也不说，只是每次需要打电话给客户的时候，他直接就拿自己的手机打了，后来四代发现了这个情况，四代觉得非常的惭愧，他立即找到行政部门，从那边拿了一个业务手机过来，放到了鼬的手边。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513194134288-565744842.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;虽然不知道鼬是怎么想的，不过四代觉得他自己是完成了一个项目经理应该做的事。他不能让他的队员在不必要的情况下，为了公司的事务而损失自己的利益，这不科学，不符合四代“双赢”的基本原则。&lt;/p&gt;

&lt;p&gt;四代还是希望团队之间能完成“润物细无声”式的融合，所以四代在平时都非常细致的在观察团队的状况，一旦发现一些端倪，四代立即会进行沟通。&lt;span&gt;&lt;strong&gt;四代对沟通这件事，秉持的最基本的原则之一就是“不要让问题过夜”。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513200326964-932599496.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;但是即使是这样，有些情况四代还是不能注意到，只能等到YY聊天的时候才能知道。&lt;/p&gt;

&lt;p&gt;记得那一次是在和鼬YY聊天的时候，在四代以往的多次提示下已经习惯了四代套路的鼬，反馈说他这星期太忙了。这是一个非常重要的情况，四代立马详细听取了鼬的反馈，然后和鼬一起讨论一下出现这种情况的原因，最终两人都觉得这一周应该是业务突然增长的原因，而不是计划有误。&lt;/p&gt;

&lt;p&gt;四代和鼬商议了一下，觉得还是先观察一下接下来两周的情况，如果只是突发情况，在需要的情况下就做小幅度任务的调整，不做大的调整；如果是变成了常规情况，那么四代就正式的将这种情况纳入正常的Release计划中。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513194824785-600304204.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;不过接下来的情况证明了那周就是特殊情况，也不需要做太大的调整，于是就这样处理了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;你搪塞的机会只有一次&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;确实，四代见过太多死气沉沉的团队了。并不是大家没有什么建议，而是收到建议以后，项目主管要么是习惯性的找了一堆理由随便的就搪塞过去，要么是依照自己的经验，直接进行对其进行说服教育，要么是长久没什么反馈，就像什么事都没有发生过一样。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513195106412-809442804.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;不需要多次，一般只要一次是这样，那么提建议的人基本就不会再有什么意见了。四代就曾经亲身体验过这种事，自从被敷衍以后，四代就不再提任何的建议和意见了。&lt;/p&gt;

&lt;p&gt;人与人之间的信任总是在在一次次接触与反馈的过程中建立起来，就像软件也总是在一次次发布与反馈中成熟起来一个样，这就是及时反馈的重要性。如果缺少了及时反馈这一环，那么团队建设就像瀑布软件开发流程一样，只能一条道走到黑。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513195233036-1825381536.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;到了那个时候，即使你想调整，也已经不可能了。何况很多人根本是两眼一抹黑，根本不知道发生了什么事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;制怒不败家&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;在鼬最初来的那一阶段，由于鼬是从手机开发转过来的，基础不是很好。四代在专门给鼬培训以后，鼬做起功能还是有点吃力。就在不经意间，四代对鼬说话的声音就大了起来，确实有时候，四代已经有点没有耐心了。&lt;/p&gt;

&lt;p&gt;不过就在某一天四代反思自己的时候，自己也意识到了这个问题。&lt;/p&gt;

&lt;p&gt;在一次YY聊天中，四代坦然的对鼬说了这些事，四代觉得是有必要提高自己在这方面的控制力，这大概就是传说中的“情商”吧，四代做的还不够。于是在当年的年终的时候，四代在自己的微信上郑重的写下了自己未来一年努力的目标：“制怒，不败家”。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/109061/201805/109061-20180513195421622-1908374277.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;“不败家”还好说，“制怒”能做的到吗？四代苦笑了一下。&lt;/p&gt;

</description>
<pubDate>Sun, 13 May 2018 12:10:00 +0000</pubDate>
<dc:creator>沙场秋点兵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxy1982/p/9032971.html</dc:identifier>
</item>
<item>
<title>[创业] 01：为什么要创业，创业需要哪些条件和品质。 - 一步之遥&gt;&gt;</title>
<link>http://www.cnblogs.com/somebody2005/p/9033082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/somebody2005/p/9033082.html</guid>
<description>&lt;div readability=&quot;7.5428571428571&quot;&gt;上一篇《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/somebody2005/p/9024870.html&quot; target=&quot;_blank&quot;&gt;三次创业&lt;/a&gt;历程》开了个头，简单说了一下三次创业的经历。而第一篇想写的是“创业之前”的事情：到底要不要创业，如果真要创业，你准备好了吗。&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;为什么要创业&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对我来说，&lt;strong&gt;人生贵在体验&lt;/strong&gt;。如果不试试，总觉得将来会有遗憾。&lt;/p&gt;
&lt;p&gt;《易》云：穷则变，变则通，通则久。&lt;br/&gt;久在职场，从码农到技术经理，再到项目经理，再到CTO，觉得自己如鱼得水。然而，到了某种程度（比如毕业5-10年左右吧）之后，会感觉职业生涯到了天花板（身在国外这个感觉更明显）。&lt;br/&gt;突破这个天花板的方式之一，就是改变跑道，试试自己创业。&lt;br/&gt;（当然还有其它方向，创业不过是其中之一，并且还不能算是一条好的出路。混职场也是一种学问，有空也可以说说职场之道。这条路其实更容易走一些）&lt;/p&gt;

&lt;p&gt;工作这么久也接触了各种老板，有创业者、有守业者，有成功的、也有失败的。曾亲眼看过某公司从无到有，从小到大，从强到弱，再到破产关门。细心观察各种老板，会发现他们的很多可贵品质，也能觉得他们有些明显的短板不足。所以不止一次的想，自己有可能会做的更好。&lt;/p&gt;

&lt;p&gt;想靠创业发财？创业者十之八九是会失败的，亏钱的概率远大于暴富。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IT创业的机遇&lt;/strong&gt;&lt;br/&gt;IT类创业公司，既不是劳动密集型，也不是资金密集型，甚至都不能算是技术密集型，因为毕竟IT类的绝大部分项目不太需要十分高深的算法技术。比起动辄千万上亿的设备投资，IT类主要靠的还是有限的一组人，算是轻资产。&lt;br/&gt;所以到今天为止还是需要资本最低、技术含量不算太高、成功率很高的一个方向。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IT创业的困境&lt;/strong&gt;&lt;br/&gt;创业者大多年轻，职场经验不丰富。&lt;br/&gt;风口少。&lt;br/&gt;门槛不算太高，容易被模仿。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;创业需要的条件&lt;/strong&gt;&lt;br/&gt;1：健康的&lt;strong&gt;经济状况&lt;/strong&gt;。&lt;br/&gt;创业是无底洞，如果已经经济紧张，最好不要雪上加霜。财务状况/现金流是公司的命根子。&lt;br/&gt;2：健康的&lt;strong&gt;心理状况&lt;/strong&gt;。稍后详加解释。&lt;br/&gt;3：健康的&lt;strong&gt;身体状况&lt;/strong&gt;。&lt;br/&gt;加班熬夜、交际应酬、压力和焦虑，这些会搞垮一个不健康的躯体。&lt;br/&gt;4：良&lt;strong&gt;好的项目&lt;/strong&gt;。下一期解释如何选择创业项目。&lt;br/&gt;5：互补的&lt;strong&gt;团队&lt;/strong&gt;。&lt;br/&gt;包括组建核心团队、中层领导的建设、员工的培训/激励框架等，再下一期解释。&lt;br/&gt;6：可能需要&lt;strong&gt;融资&lt;/strong&gt;渠道/关系&lt;br/&gt;熟悉IT类企业的金融圈的人创业其实比IT类出身的创业更容易，因为他们有这个渠道和知识。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;创业的心理建设&lt;/strong&gt;&lt;br/&gt;1：准备好失败。创业者十之八九是会失败的，有些人惨败，有些没开始就被打败。成功=良好的项目+努力+运气。其中，运气的成分非常大。&lt;br/&gt;2：没有了上班和下班的区别，好点也是无底线的加班。&lt;br/&gt;3：亏钱。请设定自己的底线，亏到一定程度，及时退出。&lt;br/&gt;4：需要朋友，而又得罪朋友。需要亲人，而又得罪亲人。&lt;br/&gt;5：焦虑。太多未知数和太多等待，太多对外各种条件的依赖。为自己的智商捉急，总觉得到处都没有想好。所以信命信风水，都是一种寄托。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;创业者需要的品质&lt;/strong&gt;&lt;br/&gt;1：凝聚力/合作能力。&lt;br/&gt;一个强大的团队是创业成功的关键。也要准备好，该散伙的时候就要立即决定，不是所有的股东都能一起走到最后。谁先掉队都不奇怪。&lt;br/&gt;2：敢打敢拼的个人能力。&lt;br/&gt;过程中不能怂，很多时候，咬咬牙也就顶过去了。谁顶的久，谁的机会就更多。&lt;br/&gt;如何找第一个种子客户？到时候都得豁出去找。比起来，打工就容易多了，可以有很多借口。&lt;br/&gt;另外，各种工作都得自己做起，除了设计开发，还有订货、招聘、财务、甚至打扫卫生，各种小事儿都得亲力亲为。&lt;br/&gt;3：抗压。&lt;br/&gt;西天取经还九九八十一难呢。有困难是常态。&lt;br/&gt;多少个夜里睡不着，第二天还得看起来信心满满的工作。&lt;br/&gt;信心是黄金，对合作伙伴、员工、客户，都是这样的。再苦都不能表现出来。&lt;br/&gt;4：分析和学习能力。&lt;br/&gt;看项目和看人，都要好好分析，“夫未战而庙算胜者，得算多也，未战而庙算不胜者，得算少也”。所以丰富的职场经验是创业的基础之一。&lt;br/&gt;创业过程中遇到什么问题都得去解决，很多从来没处理过的领域都要大着胆子去干。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;退出机制&lt;/strong&gt;&lt;br/&gt;1：设定时间。比如2年还没有盈利或者盈利不如预期。&lt;br/&gt;2：设定亏损额。比如xx万&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;创业的感受&lt;br/&gt;创业就像是谈恋爱，要的就是这股劲儿：前途可能美好、过程非常曲折、时时充满未知，似有情还无意、摸不透看不穿，激动/失落就在一瞬间，机关算尽、全力以赴。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;说了这么多，如果很多品质和条件都没有怎么办？ 那就请&lt;strong&gt;确保你的团队其他人有这些品质，而你的位置又不可被动摇&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下一篇想写写如何选择创业方向。&lt;/p&gt;

</description>
<pubDate>Sun, 13 May 2018 11:50:00 +0000</pubDate>
<dc:creator>一步之遥&amp;gt;&amp;gt;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/somebody2005/p/9033082.html</dc:identifier>
</item>
</channel>
</rss>