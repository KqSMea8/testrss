<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>通过vuepress管理项目文档(一) - qfstudy</title>
<link>http://www.cnblogs.com/qfstudy/p/10061771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qfstudy/p/10061771.html</guid>
<description>&lt;p&gt;这篇文章主要是记录自己在使用vuepress过程中所遇到的问题以及如何一步一步的解决问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;安装vuepress前，请确保你的 Node.js 版本 &amp;gt;= 8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;全局安装&quot;&gt;全局安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 安装
yarn global add vuepress # 或者：npm install -g vuepress

# 新建一个 markdown 文件
echo '# Hello VuePress!' &amp;gt; README.md

# 开始写作
vuepress dev .

# 构建静态文件
vuepress build .&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注意-vuepress-dev-.和vuepress-build-.后面的.&quot;&gt;注意 ：&lt;code&gt;vuepress dev .&lt;/code&gt;和&lt;code&gt;vuepress build .&lt;/code&gt;后面的&lt;code&gt;.&lt;/code&gt;。&lt;/h4&gt;
&lt;h2 id=&quot;在现有项目中安装&quot;&gt;在现有项目中安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 将 VuePress 作为一个本地依赖安装
yarn add -D vuepress # 或者：npm install -D vuepress

# 新建一个 docs 文件夹
mkdir docs

# 新建一个 markdown 文件
echo '# Hello VuePress!' &amp;gt; docs/README.md

# 开始写作
npx vuepress dev docs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，在 &lt;code&gt;package.json&lt;/code&gt; 里加一些脚本:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始写作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn docs:dev # 或者：npm run docs:dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个坑：我的项目就是依赖&lt;code&gt;webpack 3.6.0&lt;/code&gt;同时也是用npm安装依赖，然后继续使用npm安装vuepress，然后执行&lt;code&gt;npx vuepress dev docs&lt;/code&gt;的时候报错了，上网查了好久也没有解决问题，最后使用yarn安装vuepress成功了。&lt;/p&gt;
&lt;p&gt;如果你的现有项目依赖了 webpack 3.x，推荐使用 yarn而不是 npm 来安装 VuePress。&lt;/p&gt;
&lt;p&gt;要生成静态的 HTML 文件，运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn docs:build # 或者：npm run docs:build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，文件将会被生成在 &lt;code&gt;.vuepress/dist&lt;/code&gt;，也可以通过 &lt;code&gt;.vuepress/config.js&lt;/code&gt; 中的 &lt;code&gt;dest&lt;/code&gt; 字段来修改.&lt;/p&gt;
&lt;p&gt;以上步骤都成功以后，就可以在浏览器总看到页面了，接下来就是对页面进行布局&lt;/p&gt;
&lt;h2 id=&quot;主题配置&quot;&gt;主题配置&lt;/h2&gt;
&lt;p&gt;本文是根据vuepress默认主题配置&lt;/p&gt;
&lt;h3 id=&quot;首页&quot;&gt;1.首页&lt;/h3&gt;
&lt;p&gt;在docs文件夹下创建&lt;code&gt;.vuepress文件夹&lt;/code&gt;和&lt;code&gt;README.md文件&lt;/code&gt;。(如果以及有了就不要再新建)&lt;br/&gt;根目录下的README.md文件可以当作首页，在文件中加入下面文字：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;---
home: true
heroImage: /hero.png
actionText: 快速上手 →
actionLink: /zh/guide/
features:
- title: 简洁至上
  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。
- title: Vue驱动
  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。
- title: 高性能
  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。
footer: MIT Licensed | Copyright © 2018-present Evan You
---&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以根据自己的需要添加、删除、修改，这就完成了首页的布局&lt;br/&gt;&lt;code&gt;actionLink/zh/guide/&lt;/code&gt;就是首页后要显示的下一个页面&lt;/p&gt;
&lt;p&gt;接下来在docs文件夹中创建&lt;code&gt;guide文件夹&lt;/code&gt;(根据自己的需要命名)。这个文件夹中放的是&lt;code&gt;markdown&lt;/code&gt;文件，每一个&lt;code&gt;markdown&lt;/code&gt;文件对应一个页面。至于页面之间的跳转和页面导航栏和侧边栏布局在&lt;code&gt;config.js&lt;/code&gt;文件中设置。&lt;br/&gt;VuePress 网站必要的配置文件是 &lt;code&gt;.vuepress/config.js&lt;/code&gt;，它应该导出一个 JavaScript 对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  title: 'Hello VuePress',
  description: 'Just playing around'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上述的配置，如果你运行起 dev server，你应该能看到一个页面，它包含一个页头，里面包含一个标题和一个搜索框。&lt;/p&gt;
&lt;h3 id=&quot;导航栏&quot;&gt;2.导航栏&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;themeConfig.nav&lt;/code&gt; 增加一些导航栏链接:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// .vuepress/config.js
module.exports = {
  themeConfig: {
    nav: [       
           {text: '指南',link:'/guide/install/install'}
        ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你提供了一个 &lt;code&gt;items&lt;/code&gt; 数组而不是一个单一的 &lt;code&gt;link&lt;/code&gt; 时，它将显示为一个 &lt;code&gt;下拉列表&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  themeConfig: {
    nav: [
      {
        text: 'Languages',
        items: [
          { text: 'Chinese', link: '/language/chinese/' },
          { text: 'Japanese', link: '/language/japanese/' }
        ]
      }
    ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;侧边栏&quot;&gt;3.侧边栏&lt;/h3&gt;
&lt;p&gt;想要使侧边栏（Sidebar）生效，需要配置 &lt;code&gt;themeConfig.sidebar&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// .vuepress/config.js
module.exports = {
  themeConfig: {
    sidebar: [
        {
            title: '开发指南',
            collapsable: false, //是否展开
        },
        ['./guide/install/install','安装'],
        ['./guide/started/started','快速上手'],
        {
            title: '组件',
            collapsable: false
        },
        ['./guide/icon/icon','icon'],
        ['./guide/button/button','button'],
    ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以省略 &lt;code&gt;.md&lt;/code&gt; 拓展名，同时以 &lt;code&gt;/&lt;/code&gt; 结尾的路径将会被视为 &lt;code&gt;*/README.md&lt;/code&gt;&lt;br/&gt;如果想要显示地指定链接的文字，使用一个格式为 &lt;code&gt;[link, text]&lt;/code&gt; 的数组。&lt;br/&gt;具体配置可以根据官网配置：&lt;a href=&quot;https://vuepress.vuejs.org/zh/theme/default-theme-config.html#%E4%BE%A7%E8%BE%B9%E6%A0%8F&quot;&gt;默认主题配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在页面基本也搭建完成，可以在页面之间进行切换。下一步是如何在&lt;code&gt;markdown&lt;/code&gt;中使用vue组件，也就是在页面中展示自己的项目。&lt;/p&gt;
&lt;h2 id=&quot;在markdown中使用vue&quot;&gt;在markdown中使用Vue&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;.vuepress&lt;/code&gt;中创建&lt;code&gt;components&lt;/code&gt;文件夹。&lt;br/&gt;所有在 &lt;code&gt;.vuepress/components&lt;/code&gt; 中找到的 &lt;code&gt;*.vue&lt;/code&gt; 文件将会自动地被注册为全局的异步组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.
└─ .vuepress
   └─ components
      ├─ demo-1.vue
      └─ Foo
         └─ demo-2.vue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接使用这些组件在任意的 Markdown 文件中（组件名是通过文件名取到的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;demo-1/&amp;gt;
&amp;lt;Foo-demo-2/&amp;gt; //文件名和组件名之间同`-`连接&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成这一步以后就可以在页面中看到自己的组件在页面中展示了，但是在运行下面命令的时候会报错：&lt;br/&gt;报错原因参考官网文档&lt;a href=&quot;https://vuepress.vuejs.org/zh/guide/using-vue.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84-api-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6&quot;&gt;## 浏览器的 API 访问限制&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn docs:build # 或者：npm run docs:build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决这个问题只需要在&lt;code&gt;markdown&lt;/code&gt;文件中使用&lt;code&gt;&amp;lt;ClientOnly&amp;gt;&amp;lt;/ClientOnly&amp;gt;&lt;/code&gt;将组件包裹起来。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;ClientOnly&amp;gt;
  &amp;lt;Foo-demo-2/&amp;gt;
&amp;lt;/ClientOnly&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：在markdown文件中如果需要给组件名缩进，不要用&lt;code&gt;tab&lt;/code&gt;键，会被当做&lt;code&gt;markdown&lt;/code&gt;语法解析。&lt;/p&gt;
&lt;p&gt;到这一步，基本上可以在页面中展示自己的组件。下一篇将继续写如何通过vue组件实现跟&lt;a href=&quot;http://element-cn.eleme.io/#/zh-CN/component/icon&quot;&gt;Element&lt;/a&gt;相似的效果。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:30:00 +0000</pubDate>
<dc:creator>qfstudy</dc:creator>
<og:description>这篇文章主要是记录自己在使用vuepress过程中所遇到的问题以及如何一步一步的解决问题。 安装vuepress前，请确保你的 Node.js 版本 = 8 全局安装 注意 ： 和`vuepress</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qfstudy/p/10061771.html</dc:identifier>
</item>
<item>
<title>HBase之Table.put客户端流程 - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/10061630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/10061630.html</guid>
<description>&lt;p&gt;　　首先，让我们从HTable.put方法开始。由于这一节有很多方法只是简单的参数传递，我就简单略过，但是，关键的方法我还是会截图讲解，所以希望大家尽可能对照源码进行流程分析。另外，在这一节，我单单介绍put操作在客户端的流程，毕竟，这个内容已经很多了。至于具体服务端的流程，我会在后面的章节中介绍到，欢迎大家到时候阅读。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　由于这一节的方法还是比较复杂的，我特地画了一张思维导图，大家可以先通过思维导图来对本节的内容有一个大概的了解，置于具体的流程，我在下面将对照源码的贴图一一为大家讲解(在这里声明一点，我在这一节只介绍单个put操作的流程，至于put批处理，大家有兴趣可以自己研究一下)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203223950803-1101287935.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;32&quot;&gt;　　首先，让我们来到HTable.put方法，如下图所示：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224019895-640461177.png&quot; alt=&quot;&quot;/&gt;　　这里我先讲一下这一节的最后调用流程，也同时让大家明确一下在本节我着重要讲解的流程是哪块。在上图中我已经表示出来了，后面方法的调用最后调用到了上面新创建的ClientServiceCallable中覆写的rpcCall方法，也就是调用到了ClientServiceCallable.doMutate。关于这个方法中具体与服务端的交互流程在本节我就略过，但是，在后面的内容中，我会谈到类似的情况，如果大家感兴趣的话，可以继续后面的内容。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224034790-1129904396.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们回到本节的重点。首先是RpcRetryingCallerFactory.newCaller方法的调用，该方法使用RpcRetryingCallerFactory的成员参数创建了RpcRetryingCaller，用于后面对于RetryingCallable的调用(该方法在后面也会多次调用，在后面我就不贴图了)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224054171-625211579.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到RpcRetryingCallerImpl.callWithRetries。这个方法是本节中最为重要的方法，在后面也会多次用到。方法虽然比较长，但大多是异常的情况的解决，在本节中我们就单单介绍callable.prepare与callable.call两个方法。至于interceptor.intercept，由于在构造RpcRetryingCallerFactory时默认的interceptor类型为RetryingCallerInterceptorFactory.NO_OP_INTERCEPTOR，在本节并不会有其它影响，所以我们暂时不需要关注。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224129088-1486469391.png&quot; alt=&quot;&quot;/&gt;　　上面的方法调用的callable具体类型为覆写了rpcCall方法的ClientServiceCallable，下面让我们来到ClientServiceCallable类的内部。ClientServiceCallable继承自RegionServerCallable，因此，上面方法实际调用的是RegionServerCallable.prepare与RegionServerCallable.call。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224157918-57704934.png&quot; alt=&quot;&quot;/&gt;　　首先让我们来到RegionServerCallable.prepare方法。这里比较重要的方法我已经框选出来了。需要大家特别留意的是最后的setStubByServiceName，一是因为他比较重要，二是我在后面的内容才会介绍，大家到时候可能忘记了，所以在这里特别提醒一下大家。&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;　　容易看到，首先调用了connection.getRegionLocator获得一个新构建的HRegionLocator(这里就不截图了，因为实在是没有什么内容需要讲)，不过大家需要注意的是，这里的tableName是我们实际要查询到tableName，而后面会用到META_TABLE_NAME，容易混淆，我在这里简单提一下。接下来调用了HRegionLocator.getRegionLocation。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224257809-532710579.png&quot; alt=&quot;&quot;/&gt;　　在调用HRegionLocator.getRegionLocation时，这里会有一系列简单方法的调用，由于在上面的导图中我并没有画出，在这里我就一一贴图描述。&lt;img src=&quot;http://note.youdao.com/src/94CA36BA08FC4267AD31586EA79680B2&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203231418016-2087475422.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203231429823-1258301774.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://note.youdao.com/src/53A742038BB0468A8ABD9A4E49DD0F6F&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224403420-1331295672.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224416637-1068350022.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224425841-1732532478.png&quot; alt=&quot;&quot;/&gt;　　一系列方法走下来，到这里就到了比较重要的方法。由于这个是长图，没有办法框选除重点，我就在文字中一一介绍该方法中调用的比较好重要的方法。&lt;/div&gt;
&lt;p&gt;　　1.getCachedLocation，该方法简介调用到了metaCache.getCachedLocation，但此时，由于我们是第一次调用该表的信息，并没有放到缓存中，因此，这里返回的locations = null。&lt;/p&gt;
&lt;p&gt;　　2.然后我们来到RegionInfo.createRegionName，需要注意的是，其入参row就是我们put操作创建的rowKey，也就是我们常说的行键。另外，在metaStartKey中传入的id为HConstants.NINES(NINES = &quot;99999999999999&quot;)，而在metaStopKey中传入的id为空字符串。&lt;/p&gt;
&lt;p&gt;　　3.接着构造了Scan。其中withStartRow与withStopRow中的inclusive入参都为true。将reversed设置为true，并且将catalog family设置为&quot;info&quot;(CATALOG_FAMILY_STR = &quot;info&quot;)。大家可能注意到了，这里的info列族在我们的表中并不一定存在。到了这里，大家可能就猜到我在前面埋的伏笔了。没错，这里构建的Scan是为了后面的查询后面的META_TABLE_NAME做准备。&lt;/p&gt;
&lt;p&gt;　　4.紧接着来到fro循环中，这里连着调用了两次getCachedLocation，后面的那次调用加了锁，类似我们在单例设计模式中流程，加锁以确保对象不会重复。&lt;/p&gt;
&lt;p&gt;　　5.然后构建了ReversedClientScanner对象。(鉴于之前经验，贴太多图容易扰乱大家的思维，我在这里尽量用文字来介绍)。ReversedClientScanner是ClientScanner的子类，另外，大家需要注意的是，在构造ReversedClientScanner时传入的tableName为TableName.META_TABLE_NAME。在ReversedClientScanner的构造过程中，虽然有一些需要注意的地方，不过，我还是放在后面来描述，以便大家能够更好的理解整个流程。&lt;/p&gt;
&lt;p&gt;　　6.接下来调用了ReversedClientScanner.next，大家千万不要小看这个方法，这个方法里面的一系列调用时非常复杂的，也是本节的另外一个重点，我将在后面详细介绍。&lt;/p&gt;
&lt;p&gt;　　7.然后调用了MetaTableAccessor.getRegionLocations，其入参为ReversedClientScanner.next的返回值。这个方法的详细流程也比较重要，同样，我放到后面为大家讲解。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　8.最后调用了cacheLocation，也就是将当前tableName放到缓存中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224538615-1525187294.png&quot; alt=&quot;&quot;/&gt;　　上面，我将ConnectionImplementation.locateRegionInMeta方法中调用的各个流程都简单介绍了一下，下面，我就选择其中比较重要的方法来详细描述。&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;　　首先让我们来到ReversedClientScanner.next。这个方法调用了ClientScanner.nextWithSyncCache,如下图所示：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224610676-765780531.png&quot; alt=&quot;&quot;/&gt;　　上图框选的两个方法都比较重要，让我们首先介绍比较复杂的loadCache，如下图所示。&lt;/div&gt;
&lt;p&gt;　　看到这个方法大家可能比较慌，没有关系，我会在这里为大家一一介绍。&lt;/p&gt;
&lt;p&gt;　　1.首先调用了moveToNextRegion。该方法首先调用closeScanner(其间首先调用了成员变量callable.setClose方法，然后调用了ClientScanner.call方法，这个方法我在后面也会提到，最后将当前成员变量callable中的值置为null，简而言之，将成员变量callable.setClose置为null)。&lt;/p&gt;
&lt;p&gt;　　然后构造了ScannerCallableWithReplicas并赋给成员变量callable。在构造ScannerCallableWithReplicas时需要注意的是其中创建了ReversedScannerCallable。也就是说ScannerCallableWithReplicas的成员变量currentScannerCallable为ReversedScannerCallable。顺便提一下，ScannerCallableWithReplicas的成员变量scan为我们在上面构造的scan。&lt;/p&gt;
&lt;p&gt;　　2.接着调用了ClientScanner.call方法。这里的调用流程比较繁琐。为了更清楚的解释清楚loadCache方法，我们先跳过这里，假设其中已经有了返回值。&lt;/p&gt;
&lt;p&gt;　　3.然后调用了scanResultCache.addAndGet。简单提示一下我们这里的scanResultCache类型为CompleteScanResultCache。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　4.然后将结果集中的内容遍历放到成员变量cache中。这里我们可以回过头来看看上面的图。上面图中我框选了cache.poll方法。也就是说cache.poll将在loadCache方法中放入的结果集取出来。&lt;img src=&quot;http://note.youdao.com/src/0F085604DFDD4EEF89BDE26E09D08B63&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224717171-546006533.png&quot; alt=&quot;&quot;/&gt;　　上面我提到过很多次ClientScanner.call方法，但是都没有详细描述，下面我就特意来讲解该方法。其实这个方法很简单，只是调用了方法RpcRetryingCaller.callWithoutRetries。这里的caller是在ReversedClientScanner方法构造时创建的(上面只是提到说构造ReversedClientScanner有需要注意的地方，也就是这里，其截图我在上面也已经贴出来了)。&lt;img src=&quot;http://note.youdao.com/src/F6FF2FC5407B4A208FEDE51BB77813A9&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224757376-1716304435.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到RpcRetryingCallerImpl.callWithoutRetries。这里的入参callable我在上面的方法loadCache已经介绍过了。其类型为ScannerCallableWithReplicas。由于ScannerCallableWithReplicas.prepare方法为空实现，我在这里就不贴图了，接下来将重点放在ScannerCallableWithReplicas.call。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224828696-550428629.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ScannerCallableWithReplicas.call，如下图所示。&lt;/div&gt;
&lt;p&gt;　　1.在ClientScanner.closeScanner方法调用时，会走上面的if判断。由于currentScannerCallable.closed的值为true。&lt;/p&gt;
&lt;p&gt;　　2.由于默认的成员变量regionReplication，因此会调用RpcRetryingCallerWithReadReplicas.getRegionLocations。这个方法的调用与我们今天的主要流程并没有什么太多的联系，因此，在这里简单略过。该方法我可能会放在后面的章节中讲到。&lt;/p&gt;
&lt;p&gt;　　3.构造了ResultBoundedCompletionService。这个方法比较重要，在后面的流程中我会反复讲到。&lt;/p&gt;
&lt;p&gt;　　4.调用了addCallsForCurrentReplica，将成员变量currentScannerCallable封装到ScannerCallableWithReplicas.RetryingRPC中，并交由ResultBoundedCompletionService提交。&lt;/p&gt;
&lt;p&gt;　　5.接着调用cs.poll，获取其提交的任务的返回值。&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;　　后面我将详细讲解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224901015-1309029398.png&quot; alt=&quot;&quot;/&gt;　　首先来到ScannerCallableWithReplicas.addCallsForCurrentReplica方法。容易看到，将成员变量currentScannerCallable封装到RetryingRPC中。然后调用了ResultBoundedCompletionService.submit。这里着重提醒一下大家，这里的currentScannerCallable类型为ReversedScannerCallable。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224928973-1289213065.png&quot; alt=&quot;&quot;/&gt;　　接着让我们来到ResultBoundedCompletionService.submit，如下图所示。&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;　　这里将传入的RetryingRPC封装到QueueingFuture，然后调用了executor.execute。由于QueueingFuture继承自java.util.concurrent.RunnableFuture，也就是在调用executor.execute时，QueueingFuture.run方法会执行。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224941997-158799681.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到QueueingFuture。在下图中，我框选出了其中比较重要的方法。&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;　　首先这里调用了RpcRetryingCallerImpl.callWithRetries方法(由于这个方法我在上面已经提到过了，因此在这里就不贴图了)。重要的是其中的入参future类型为ScannerCallableWithReplicas.RetryingRPC。另外后面将当前QueueingFuture添加到ResultBoundedCompletionService成员变量completedTasks中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225007616-1710167860.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ScannerCallableWithReplicas.RetryingRPC.prepare方法。如下图所示。大家可能对这里的成员变量callable比较模糊了，大家可以往上翻到方法addCallsForCurrentReplica的描述，没错这里的callable就是ScannerCallableWithReplicas的成员变量currentScannerCallable。而ScannerCallableWithReplicas.currentScannerCallable正是在构造ScannerCallableWithReplicas时传入的ReversedScannerCallable。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225022875-2006983984.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到ReversedScannerCallable.prepare。由于这是第一次调用prepare方法，因此其成员变量instantiated为false。这里简单提一下，这里的getRow方法获取的是我们调用put时的行键，也就是我们对于目标表的rowKey。由于这里的tableName为TableName.META_TABLE_NAME，其rowKey在后面并没有用到。&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;　　然后调用了ReversedScannerCallable.setStub方法。为成员变量stub的赋值。其值为getConnection().getClient(getLocation().getServerName())调用的返回值。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225051208-1896079319.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ConnectionImplementation.getClient方法。看过我博文《HBase之HRegionServer启动（含与HMaster交互）》的同学看到这里可能就比较熟悉。 没错，这里正是通过ClientProtos.ClientService.newBlockingStub构造了协议ClientProtos.ClientService的客户端stub。关于与服务端交互的流程，我在《HBase之HRegionServer启动（含与HMaster交互）》中已经具体介绍了，大家感兴趣的可以去看一下，我们这里来描述比较重要一个点。&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;　　就是computeIfAbsentEx的最后一个入参IOExceptionSupplier。他类似于java中的Supplier(类似的方法调用我在后面讲解方法MetaTableAccessor.getRegionLocations)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225131640-135451287.png&quot; alt=&quot;&quot;/&gt;　　在第一次调用时，我们的stubs中并没有到该serverName的客户端stub，因此调用了入参supplier的get方法。也就是我们上面看到的lambda表达式方法内容被调用。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225317162-1204654681.png&quot; alt=&quot;&quot;/&gt;　　到这里，ReversedScannerCallable.prepare方法就调用完成了。这个还有一个需要注意的点就是ReversedScannerCallable.prepare方法的最后将其成员变量instantiated置为true。&lt;/div&gt;
&lt;p&gt;　　接下来让我们来到ScannerCallableWithReplicas.RetryingRPC.call方法(这里的callable类型为ReversedScannerCallable)。&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;　　这里再次调用了RpcRetryingCallerImpl.callWithRetries，由于ReversedScannerCallable.prepare方法已经调用，并且其成员变量instantiated被置为true，所以上面描述的内容并不会再次调用(这里框选的内容作为后面的伏笔)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225334687-1668361278.png&quot; alt=&quot;&quot;/&gt;　　也就是说，接下来应该调用的是ReversedScannerCallable.call。由于其并没有call方法，因此，会一直调用到其父类RegionServerCallable.call。如下图所示。这里的rpcController类型为HBaseRpcControllerImpl。接下来调用了rpcCall方法。由于ReversedScannerCallable中并没有rpcCall方法的实现，而在其父类ScannerCallable有实现rpcCall。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225404092-1046665400.png&quot; alt=&quot;&quot;/&gt;　　接下来，让我们来到ScannerCallable.rpcCall。由于默认的成员变量scannerId为-1，因此，会调用openScanner。由于openScanner方法仅仅是通过Client协议发送到服务端。关于rpc流程我在博客《hbase之RPC调用流程简介》中已经介绍过了，感兴趣的同学可以去看一下，那篇博文讲的比较浅显，我会在春节期间将那篇内容更新，大家可以关注我，到时候有更新大家也就收到通知了。&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;　　然后调用了ResponseConverter.getResults，将服务端的返回的ScanResponse转换为Result。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225432643-2131577349.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ResponseConverter.getResults。这个方法的主要作用是将CellScanner中Cell的或ScanResponse中的PB类型的results转换为java类型的Result。至于该方法的详细描述我要放到后面开设的第二章节，也就是HBase中客户端协议各个操作中来讲解，因为这里流程是比较复杂的，要结合上服务端的流程才能讲述清楚。所以这里暂时略过。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225451772-543711710.png&quot; alt=&quot;&quot;/&gt;　　到这里，一个完整的RpcRetryingCallerImpl.callWithRetries方法调用流程可以说是完结了。然后在ResultBoundedCompletionService.QueueingFuture.run方法的后面，将当前QueueingFuture添加到ResultBoundedCompletionService成员变量completedTasks中(虽然我在上面提到过，但这里还是重述一下，以便我们后面的理解)。&lt;/div&gt;
&lt;p&gt;　　而在我们本节描述的整体流程中，ScannerCallableWithReplicas.addCallsForCurrentReplica方法调用完结。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来让我们来到ResultBoundedCompletionService.poll，由于其间接调用了ResultBoundedCompletionService.pollForSpecificCompletedTask，如下图所由于在QueueingFuture.run方法的最后，将自身添加到了completedTasks。因此，上面的方法获取的正是刚刚添加的QueueingFuture。接着调用了ResultBoundedCompletionService.QueueingFuture.get方法。如下图所示。也就是说，这里将result返回。这里result的类型我们需要注意一下，以便后面在类型上面的理解。由于这里QueueingFuture成员变量future的实际类型为ScannerCallableWithReplicas.RetryingRPC。大家可以往上翻到ScannerCallableWithReplicas.RetryingRPC.call，就可以发现，这里的result是从ResponseConverter.getResults获得的Result数组与成员变量callable封装后的Pair对象。接着，将r.getFirst()，也就是实际获得的结果返回。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225529787-1221293209.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，大家可能以为要结束了，很遗憾，这里只是到了ClientScanner.call方法的返回。&lt;/p&gt;
&lt;p&gt;　　由于接下来的是两个单独的流程了。一个是MetaTableAccessor.getRegionLocations，另外一个是ConnectionImplementation.cacheLocation。至于这两个流程之外的后续流程比较简单，我就不一一叙述了，相信大家跟着源码与我在前面的提示很容易就可以弄清楚了。而前面提到的那两个单独的流程我将放在后面的一节《HBase之Table.put客户端流程(续)》中介绍。到时候欢迎大家阅读。&lt;/p&gt;
&lt;p&gt;　　大家可以关注我的博客，或者发送邮件到我的邮箱15935152719@163.com来沟通交流大数据相关的知识。感谢大家的阅读，如果觉得不错，希望您可以点击下面的推荐。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>首先，让我们从HTable.put方法开始。由于这一节有很多方法只是简单的参数传递，我就简单略过，但是，关键的方法我还是会截图讲解，所以希望大家尽可能对照源码进行流程分析。另外，在这一节，我单单介绍p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/10061630.html</dc:identifier>
</item>
<item>
<title>tomcat整体架构 - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/10061742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/10061742.html</guid>
<description>&lt;p&gt;        Tomcat作为JavaWeb领域的Web容器，目前在我们淘宝也使用的也非常广泛，现在基本上所有线上业务系统都是部署在Tomcat上。为了对平时开发的Web系统有更深入的理解以及出于好奇心对我们写的Web系统是如何跑在Tomcat上的，于是仔细研究了下Tomcat的源码。大家都知道Servlet规范是Java领域中为服务端编程制定的规范，对于我们开发者只是关注了Servlet规范中提供的编程组件(ServletContextListener,Filer,Servlet) 等 ，但是规范中还有一些我们经常使用的接口（ServletContext,ServletRequest,ServletResponse,FilterChain）等都是由Tomcat去实现的，并且我们开发者实现的编程组件只是被Tomcat去回调而已。所以看Tomcat源码实现也有助于我们更好的理解Servlet规范及系统如何在容器中运行(一些开源的MVC框架如Struts2,Webx,SpringMVC本质无非就是这个)&lt;/p&gt;

&lt;p&gt;        仔细查看下图（网络上描述Tomcat架构比较清晰的一张图），不难发现其中的Connecotr组件以及与Container组件是Tomcat的核心。一个Server可以有多个Service，而一个Service可以包含了多个Connector组件和一个Engine容器组件，一个Engine可以由多个虚拟主机Host组成，每一个Host下面又可以由多个Web应用Context构成，每一个的Context下面可以包含多个Wrapper（Servlet的包装器）组成。&lt;/p&gt;
&lt;p&gt;       Tomcat将Engine，Host，Context，Wrapper统一抽象成Container。一个抽象的Container模块可以包含各种服务。例如，Manager管理器（Session管理），Pipeline管道（ 维护管道阀门Value ）等。Lifecycle接口统一定义了容器的生命周期，通过事件机制实现各个容器间的内部通讯。而容器的核心接口Container的抽象实现中定义了一个Pipeline，一个Manager，一个Realm以及ClassLoader统一了具体容器的实现规范。连接器（Connector）组件的主要任务是为其所接收到的每一个请求（可以是HTTP协议，也可以AJP协议），委托给具体相关协议的解析类ProtocolHandler，构造出Request 对象和Response 对象。然后将这两个对象传送给容器（Container）进行处理。容器（Container）组件收到来自连接器（Connector）的Request 和Response对象后，负责调用Filter，最后调用Servlet的service 方法（进入我们开发的Web系统中）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201812/738818-20181203230857843-270403203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.Server组件：Server是最顶级的组件，代表Tomcat的运行实例；包含Listener组件用以监听生命周期中的各种事件；包含GlobalNamingResources组件用以集成JNDI；包含Service组件用以提供服务。&lt;/p&gt;
&lt;p&gt;2.Service组件：Service是服务的抽象，代表请求从接受到处理的所有组件的集合；Server组件可以包含多个Service组件；包含Connector组件用以接收客户端的信息；包含Engine组件用以处理请求；包含Executor用以提供线程池执行任务。&lt;/p&gt;
&lt;p&gt;3.Connector组件：接收客户端连接并接收信息报文，信息报文经由它解析后送往容器中处理；包含Mapper组件对请求地址进行路由；包含CoyoteAdaptor组件用以将Connector组件和Engine等容器组件适配起来；包含Protocol组件用以接收客户端连接、接收客户端信息报文、报文解析处理、对客户端响应等整个过程。&lt;/p&gt;
&lt;p&gt;4.Protocol组件：包含JioEndPoint组件，其中的Acceptor组件将启动某个端口的监听，将监听到的请求放入线程池Executor组件，其中的Processor组件对HTTP协议解析并传递到Engine容器继续处理；NIO模式下NioEndPoint多了一个Poller组件轮询多个客户端连接处理事件。&lt;/p&gt;
&lt;p&gt;Engine组件：代表全局Servlet引擎；每个Service组件只能包含一个Engine容器组件；包含Listener组件用以在生命周期中对Engine相关的事件进行监听；包含AccessLog组件以记录访问日志；包含Cluster组件以提供集群功能，将需要共享的数据同步到集群中的其他Tomcat实例中；包含Pipeline组件用以处理请求；包含Realm组件用以提供安全权限功能。&lt;/p&gt;
&lt;p&gt;5.Host组件：代表虚拟主机；一个Engine组件可以包含若干个Host容器组件；包含Listener组件用以在生命周期中对Host相关的事件进行监听；包含AccessLog组件以记录访问日志；包含Cluster组件以提供集群功能，将需要共享的数据同步到集群中的其他Tomcat实例中；包含Pipeline组件用以处理请求；包含Realm组件用以提供安全权限功能。&lt;/p&gt;
&lt;p&gt;6.Context组件：是Web应用的抽象，Web应用部署到Tomcat后运行时就会转化成Context对象；包含了各种静态资源、若干Servlet（Wrapper容器）以及各种其他动态资源；&lt;/p&gt;
&lt;p&gt;　　包含Listener组件用以在生命周期中对Context相关的事件进行监听；&lt;/p&gt;
&lt;p&gt;　　包含AccessLog组件以记录访问日志；&lt;/p&gt;
&lt;p&gt;　　包含Pipeline组件用以处理请求；&lt;/p&gt;
&lt;p&gt;　　包含Realm组件用以提供安全权限功能；&lt;/p&gt;
&lt;p&gt;　　包含Loader组件用以加载Web应用的资源，保证不同Web应用之间的资源隔离；&lt;/p&gt;
&lt;p&gt;　　包含Manager组件用以管理Web容器的会话，包括维护会话的生成、更新和销毁；&lt;/p&gt;
&lt;p&gt;　　包含NamingResource组件将Tomcat配置文件的server.xml和Web应用的context.xml资源和属性映射到内存中；&lt;/p&gt;
&lt;p&gt;7.Mapper组件用以作为路由映射Servlet。&lt;/p&gt;
&lt;p&gt;8.Wrapper组件：对应的是Servlet；包含Web应用开发常用的Servlet组件；包含ServletPool组件用以存放Servlet对象，当Web应用的Servlet实现了SingleThreadModel接口时则会再Wrapper中产生一个Servlet对象池，线程执行时，需先从对象池中获取到一个Servlet对象，ServletPool组件能保证Servlet对象的线程安全；包含Pipeline组件用以处理请求。&lt;/p&gt;
&lt;p&gt;我们从功能的角度将Tomcat源代码分成5个子模块，它们分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Jsper子模块：这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块；&lt;/li&gt;
&lt;li&gt;Servlet和Jsp规范的实现模块：这个子模块的源代码属于javax.servlet包及其子包，如我们非常熟悉的javax.servlet.Servlet接口、javax.servet.http.HttpServlet类及javax.servlet.jsp.HttpJspPage就位于这个子模块中；&lt;/li&gt;
&lt;li&gt;Catalina子模块：这个子模块包含了所有以org.apache.catalina开头的java源代码。该子模块的任务是规范了Tomcat的总体架构，定义了Server、Service、Host、Connector、Context、Session及Cluster等关键组件及这些组件的实现，这个子模块大量运用了Composite设计模式。同时也规范了Catalina的启动及停止等事件的执行流程。从代码阅读的角度看，这个子模块应该是我们阅读和学习的重点。&lt;/li&gt;
&lt;li&gt;Connectors子模块：如果说上面三个子模块实现了Tomcat应用服务器的话，那么这个子模块就是Web服务器的实现。所谓连接器(Connector)就是一个连接客户和应用服务器的桥梁，它接收用户的请求，并把用户请求包装成标准的Http请求(包含协议名称，请求头Head，请求方法是Get还是Post等等)。同时，这个子模块还按照标准的Http协议，负责给客户端发送响应页面，比如在请求页面未发现时，connector就会给客户端浏览器发送标准的Http 404错误响应页面。&lt;/li&gt;
&lt;li&gt;Resource子模块：这个子模块包含一些资源文件，如Server.xml及Web.xml配置文件。严格说来，这个子模块不包含java源代码，但是它还是Tomcat编译运行所必需的。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:22:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>1.背景 Tomcat作为JavaWeb领域的Web容器，目前在我们淘宝也使用的也非常广泛，现在基本上所有线上业务系统都是部署在Tomcat上。为了对平时开发的Web系统有更深入的理解以及出于好奇心对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/10061742.html</dc:identifier>
</item>
<item>
<title>Vue源码解析之数组变异 - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/10045326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/10045326.html</guid>
<description>&lt;h3 id=&quot;力有不逮的对象&quot;&gt;力有不逮的对象&lt;/h3&gt;
&lt;p&gt;众所周知，在 &lt;code&gt;Vue&lt;/code&gt; 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变。&lt;/p&gt;
&lt;p&gt;这是什么原因？&lt;/p&gt;
&lt;p&gt;原因在于： &lt;code&gt;Vue&lt;/code&gt; 的响应式系统是基于&lt;code&gt;Object.defineProperty&lt;/code&gt;这个方法的，该方法可以监听对象中某个元素的获取或修改，经过了该方法处理的数据，我们称其为响应式数据。但是，该方法有一个很大的缺点，新增属性或者删除属性不会触发监听，举个栗子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var vm = new Vue({
    data () {
        return {
            obj: {
                a: 1
            }
        }
    }
})
// `vm.obj.a` 现在是响应式的

vm.obj.b = 2
// `vm.obj.b` 不是响应式的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因在于，在 &lt;code&gt;Vue&lt;/code&gt; 初始化的时候， &lt;code&gt;Vue&lt;/code&gt; 内部会对 &lt;code&gt;data&lt;/code&gt; 方法的返回值进行深度响应式处理，使其变为响应式数据，所以， &lt;code&gt;vm.obj.a&lt;/code&gt; 是响应式的。但是，之后设置的 &lt;code&gt;vm.obj.b&lt;/code&gt; 并没有经过 &lt;code&gt;Vue&lt;/code&gt; 初始化时响应式的洗礼，所以，理所应当的不是响应式。&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;vm.obj.b&lt;/code&gt;可以变成响应式吗？当然可以，通过 &lt;code&gt;vm.$set&lt;/code&gt; 方法就可以完美地实现要求，在此不再赘述相关原理了，之后应该会写一篇文章讲述 &lt;code&gt;vm.$set&lt;/code&gt; 背后的原理。&lt;/p&gt;
&lt;h3 id=&quot;更凄惨的数组&quot;&gt;更凄惨的数组&lt;/h3&gt;
&lt;p&gt;上面说了这么多，还没有提到本篇文章的主角——数组，现在该主角出场了。&lt;/p&gt;
&lt;p&gt;比起对象，数组的境遇更加凄惨一些，看看官方文档：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;由于 JavaScript 的限制， &lt;code&gt;Vue&lt;/code&gt; 不能检测以下变动的数组：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当你利用索引直接设置一个项时，例如：&lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当你修改数组的长度时，例如：&lt;code&gt;vm.items.length = newLength&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;有可能官方文档不是很清晰，那我们继续举个栗子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var vm = new Vue({
    data () {
        return {
            items: ['a', 'b', 'c']
        }
    }
})
vm.items[1] = 'x' // 不是响应性的
vm.items.length = 2 // 不是响应性的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，数组连自身元素的修改也无法监听，原因在于， &lt;code&gt;Vue&lt;/code&gt; 对 &lt;code&gt;data&lt;/code&gt; 方法返回的对象中的元素进行响应式处理时，如果元素是数组时，仅仅对数组本身进行响应式化，而不对数组内部元素进行响应式化。&lt;/p&gt;
&lt;p&gt;这也就导致如官方文档所写的后果，无法直接修改数组内部元素来触发响应式。&lt;/p&gt;
&lt;p&gt;那么，有没有破解方法呢？&lt;/p&gt;
&lt;p&gt;当然有，官方规定了 7 个数组方法，通过这 7 个数组方法，可以很开心地触发数组的响应式，这 7 个数组方法分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unshift()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以发现，这 7 个数组方法貌似就是原生的那些数组方法，为什么这 7 个数组方法可以触发应式，触发视图更新呢？&lt;/p&gt;
&lt;p&gt;你是不是心里想着：数组方法了不起呀，数组方法就可以为所欲为啊？&lt;/p&gt;
&lt;p&gt;骚瑞啊，这 7 个数组方法是真的可以为所欲为的。&lt;/p&gt;
&lt;p&gt;因为，它们是变异后的数组方法。&lt;/p&gt;
&lt;h3 id=&quot;数组变异思路&quot;&gt;数组变异思路&lt;/h3&gt;
&lt;p&gt;什么是变异数组方法？&lt;/p&gt;
&lt;p&gt;变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展，在 &lt;code&gt;Vue&lt;/code&gt; 中这个所谓的功能拓展就是添加响应式功能。&lt;/p&gt;
&lt;p&gt;将普通的数组变为变异数组的方法分为两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;功能拓展&lt;/li&gt;
&lt;li&gt;数组劫持&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;功能拓展&quot;&gt;功能拓展&lt;/h4&gt;
&lt;p&gt;先来个思考题：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有这样一个需求，要求在不改变原有函数功能以及调用方式的情况下，使得每次调用该函数都能在控制台中打印出'HelloWorld'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实思路很简单，分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用新的变量缓存原函数&lt;/li&gt;
&lt;li&gt;重新定义原函数&lt;/li&gt;
&lt;li&gt;在新定义的函数中调用原函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看看具体的代码实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function A () {
    console.log('调用了函数A')
}

const nativeA = A
A = function () {
    console.log('HelloWorld')
    nativeA()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过这种方式，我们就保证了在不改变 &lt;code&gt;A&lt;/code&gt; 函数行为的前提下对其进行了功能拓展。&lt;/p&gt;
&lt;p&gt;接下来，我们使用这种方法对数组原本方法进行功能拓展：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 变异方法名称
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

const arrayProto = Array.prototype
// 继承原有数组的方法
const arrayMethods = Object.create(arrayProto)

mutationMethods.forEach(method =&amp;gt; {
    // 缓存原生数组方法
    const original = arrayProto[method]
    arrayMethods[method] = function (...args) {
        const result = original.apply(this, args)
        
        console.log('执行响应式功能')
        
        return result
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看出来，我们调用 &lt;code&gt;arrayMethods&lt;/code&gt; 这个对象中的方法有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用功能拓展方法：直接调用 &lt;code&gt;arrayMethods&lt;/code&gt; 中的方法&lt;/li&gt;
&lt;li&gt;调用原生方法：这种情况下，通过原型链查找定义在数组原型中的原生方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过上述方法，我们实现了对数组原生方法进行功能的拓展，但是，有一个巨大的问题摆在面前：我们该如何让数组实例调用功能拓展后数组方法呢？&lt;/p&gt;
&lt;p&gt;解决这一问题的方法就是：数组劫持。&lt;/p&gt;
&lt;h4 id=&quot;数组劫持&quot;&gt;数组劫持&lt;/h4&gt;
&lt;p&gt;数组劫持，顾名思义就是将原本数组实例要继承的方法替换成我们功能拓展后的方法。&lt;/p&gt;
&lt;p&gt;想一想，我们在前面实现了一个功能拓展后的数组 &lt;code&gt;arrayMethods&lt;/code&gt; ，这个自定义的数组继承自数组对象，我们只需要将其和普通数组实例连接起来，让普通数组继承于它即可。&lt;/p&gt;
&lt;p&gt;而想实现上述操作，就是通过原型链。&lt;/p&gt;
&lt;p&gt;实现方法如下代码所示：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let arr = []
// 通过隐式原型继承arrayMethods
arr.__proto__ = arrayMethods

// 执行变异后方法
arr.push(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过功能拓展和数组劫持，我们终于实现了变异数组，接下来让我们看看 &lt;code&gt;Vue&lt;/code&gt; 源码是如何实现变异数组的。&lt;/p&gt;
&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;
&lt;p&gt;我们来到 &lt;code&gt;src/core/observer/index.js&lt;/code&gt; 中在 &lt;code&gt;Observer&lt;/code&gt; 类中的 &lt;code&gt;constructor&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    // 检测是否是数组
    if (Array.isArray(value)) {
        // 能力检测
        const augment = hasProto
        ? protoAugment
        : copyAugment
        // 通过能力检测的结果选择不同方式进行数组劫持
        augment(value, arrayMethods, arrayKeys)
        // 对数组的响应式处理
        this.observeArray(value)
    } else {
        this.walk(value)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Observer&lt;/code&gt; 这个类是 &lt;code&gt;Vue&lt;/code&gt; 响应式系统的核心组成部分，在初始化阶段最主要的功能是将目标对象进行响应式化。在这里，我们主要关注其对数组的处理。&lt;/p&gt;
&lt;p&gt;其对数组的处理主要是以下代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 能力检测
const augment = hasProto
? protoAugment
: copyAugment
// 通过能力检测的结果选择不同方式进行数组劫持
augment(value, arrayMethods, arrayKeys)
// 对数组的响应式处理，很本文关系不大，略过
this.observeArray(value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先定义了 &lt;code&gt;augment&lt;/code&gt; 常量，这个常量的值由 &lt;code&gt;hasProto&lt;/code&gt; 决定。&lt;/p&gt;
&lt;p&gt;我们来看看 &lt;code&gt;hasProto&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const hasProto = '__proto__' in {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现， &lt;code&gt;hasProto&lt;/code&gt; 其实就是一个布尔值常量，用来表示浏览器是否支持直接使用 &lt;code&gt;__proto__&lt;/code&gt; （隐式原型） 。&lt;/p&gt;
&lt;p&gt;所以，第一段代码很好理解：根据根据能力检测结果选择不同的数组劫持方法，如果浏览器支持隐式原型，则调用 &lt;code&gt;protoAugment&lt;/code&gt; 函数作为数组劫持的方法，反之则使用 &lt;code&gt;copyAugment&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;不同的数组劫持方法&quot;&gt;不同的数组劫持方法&lt;/h4&gt;
&lt;p&gt;现在我们来看看 &lt;code&gt;protoAugment&lt;/code&gt; 以及 &lt;code&gt;copyAugment&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function protoAugment (target, src: Object, keys: any) {
  /* eslint-disable no-proto */
  target.__proto__ = src
  /* eslint-enable no-proto */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到， &lt;code&gt;protoAugment&lt;/code&gt; 函数极其简洁，和在数组变异思路中所说的方法一致：将数组实例直接通过隐式原型与变异数组连接起来，通过这种方式继承变异数组中的方法。&lt;/p&gt;
&lt;p&gt;接下来我们再看看 &lt;code&gt;copyAugment&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function copyAugment (target: Object, src: Object, keys: Array&amp;lt;string&amp;gt;) {
  for (let i = 0, l = keys.length; i &amp;lt; l; i++) {
    const key = keys[i]
    // Object.defineProperty的封装
    def(target, key, src[key])
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于在这种情况下，浏览器不支持直接使用隐式原型，所以数组劫持方法要麻烦很多。我们知道该函数接收的第一个参数是数组实例，第二个参数是变异数组，那么第三个参数是什么？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 获取变异数组中所有自身属性的属性名
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arrayKeys&lt;/code&gt; 在该文件的开头就定义了，即变异数组中的所有自身属性的属性名，是一个数组。&lt;/p&gt;
&lt;p&gt;回头再看 &lt;code&gt;copyAugment&lt;/code&gt; 函数就很清晰了，将所有变异数组中的方法，直接定义在数组实例本身，相当于变相的实现了数组的劫持。&lt;/p&gt;
&lt;p&gt;实现了数组劫持后，我们再来看看 &lt;code&gt;Vue&lt;/code&gt; 中是怎样实现数组的功能拓展的。&lt;/p&gt;
&lt;h4 id=&quot;功能拓展-1&quot;&gt;功能拓展&lt;/h4&gt;
&lt;p&gt;数组功能拓展的代码位于 &lt;code&gt;src/core/observer/array.js&lt;/code&gt; ，代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import { def } from '../util/index'

// 缓存数组原型
const arrayProto = Array.prototype
// 实现 arrayMethods.__proto__ === Array.prototype
export const arrayMethods = Object.create(arrayProto)

// 需要进行功能拓展的方法
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  // 缓存原生数组方法
  const original = arrayProto[method]
  // 在变异数组中定义功能拓展方法
  def(arrayMethods, method, function mutator (...args) {
    // 执行并缓存原生数组方法的执行结果
    const result = original.apply(this, args)
    // 响应式处理
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    // 返回原生数组方法的执行结果
    return result
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，源码在实现的方式上，和我在数组变异思路中采用的方法一致，只不过在其中添加了响应式的处理。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt; 的变异数组从本质上是来说是一种装饰器模式，通过学习它的原理，我们在实际工作中可以轻松处理这类保持原有功能不变的前提下对其进行功能拓展的需求。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>力有不逮的对象 众所周知，在 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变。 这是什么原因？ 原因在于： 的响应式系统是基于 这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/karthuslorin/p/10045326.html</dc:identifier>
</item>
<item>
<title>PEP 492 -- Coroutines with async and await syntax 翻译 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10024264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10024264.html</guid>
<description>&lt;p&gt;因为工作中慢慢开始用python的协程，所以想更好的理解一下实现方式，故翻译此文&lt;/p&gt;
&lt;p&gt;原文中把词汇表放到最后，但是我个人觉得放在最开始比较好，这样可以增加当你看原文时的理解程度&lt;/p&gt;
&lt;h2&gt;词汇表&lt;/h2&gt;
&lt;p&gt;原生协程函数 Native coroutine function：&lt;/p&gt;
&lt;p&gt;由async def定义的协程函数，可以使用await和return value语句&lt;/p&gt;

&lt;p&gt;原生协程 Native coroutine：&lt;/p&gt;
&lt;p&gt;原生协程函数返回的对象。见“await表达式”一节。&lt;/p&gt;

&lt;p&gt;基于生成器的协程函数 Generator-based coroutine function：&lt;/p&gt;
&lt;p&gt;基于生成器语法的协程，最常见的是用 @asyncio.coroutine装饰过的函数。&lt;/p&gt;

&lt;p&gt;基于生成器的协程 Generator-based coroutine：&lt;/p&gt;
&lt;p&gt;基于生成器的协程函数返回的对象。&lt;/p&gt;

&lt;p&gt;协程 Coroutine：&lt;/p&gt;
&lt;p&gt;“原生协程”和“基于生成器的协程”都是协程。&lt;/p&gt;

&lt;p&gt;协程对象 Coroutine object：&lt;/p&gt;
&lt;p&gt;“原生协程对象”和“基于生成器的协程对象”都是协程对象。&lt;/p&gt;

&lt;p&gt;Future-like对象 Future-like object：&lt;/p&gt;
&lt;p&gt;一个有__await__方法的对象，或一个有tp_as_async-&amp;gt;am_await函数的C语言对象，它们返回一个迭代器。Future-like对象可以在协程里被一条await语句消费（consume）。协程会被await语句挂起，直到await语句右边的Future-like对象的__await__执行完毕、返回结果。见“await表达式”一节。&lt;/p&gt;

&lt;p&gt;Awaitable&lt;/p&gt;
&lt;p&gt;一个Future-like对象或一个协程对象。见“await表达式”一节。&lt;/p&gt;

&lt;p&gt;异步上下文管理器 Asynchronous context manager：&lt;/p&gt;
&lt;p&gt;有__aenter__和__aexit__方法的对象，可以被async with语句使用。见“异步上下文管理器和‘async with’”一节。&lt;/p&gt;

&lt;p&gt;可异步迭代对象 Asynchronous iterable：&lt;/p&gt;
&lt;p&gt;有__aiter__方法的对象， 该方法返回一个异步迭代器对象。可以被async for语句使用。见“异步迭代器和‘async for’”一节。&lt;/p&gt;

&lt;p&gt;异步迭代器 Asynchronous iterator：&lt;/p&gt;
&lt;p&gt;有__anext__方法的对象。见“异步迭代器和‘async for’”一节。&lt;/p&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;p&gt;随着互联网和连接程序的增长，引发了对响应性和可扩展代码的需求，该提议的目标是让我们共容易的通过编写显示异步，高并发的python代码并且更加Pythonic&lt;/p&gt;
&lt;p&gt;它提出把写成的概念独立出来，并引入新的支持语法。最终的目标是帮助在python中建立一个通用的，易于接近的异步编程构思模型，并使其尽可能接近于同步编程(&lt;span&gt;说白了就是让你通过类似写同步编程的方式，写出异步代码&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;这个PEPE建设异步任务是类似于标准模块asyncio.events.AbstractEventLoop的事件循环调度和协调。虽然这个PEP不依赖人去特定的时间循环实现，但它仅仅与使用yield作为调度程序信号的协程类型相关，表示协程将等待知道事件(例如:IO)完成&lt;/p&gt;
&lt;p&gt;我们相信，这里提出的更改将有助于python在快速增长的异步编程领域保持更好的竞争力，因为许多其他语言已经采或将要采用类似的功能&lt;/p&gt;
&lt;h2&gt;API设计和实施修订&lt;/h2&gt;
&lt;p&gt;对Python 3.5的初始beta版本的反馈导致重新设计支持此PEP的对象模型，以更清楚地将原生协程与生成器分离 - 而不是一种新的生成器，现在原生协程有明确的独立类型&lt;/p&gt;
&lt;p&gt;这个改变主要是为了解决原生协程在tornado里使用出现的一些问题&lt;/p&gt;

&lt;p&gt;在CPython3.5.2 中更新了__aiter__ 协议。&lt;/p&gt;
&lt;p&gt;在3.5.2之前，__aiter__ 是被期望返回一个等待解析为异步迭代器，从3.5.2开始，__aiter__ 应该直接返回异步迭代器&lt;/p&gt;
&lt;p&gt;如果在3.5.2中使用旧协议中，Python将引发PendingDeprecationWarning异常&lt;/p&gt;
&lt;p&gt;在CPython 3.6中，旧的__aiter__协议仍将受到引发DeprecationWarning的支持&lt;/p&gt;
&lt;p&gt;在CPython 3.7中，将不再支持旧的__aiter__协议：如果__aiter__返回除异步迭代器之外的任何内容，则将引发RuntimeError。&lt;/p&gt;

&lt;h2&gt;理论和目标&lt;/h2&gt;
&lt;p&gt;当前的Python支持通过生成器（PEP342）实现协程，并通过PEP380中引入的yield from 语法进一步增强，这种方法有很多缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协程序与生成器具有相同的语法，很容易混淆，对于初级开发者来说尤其如此。&lt;/li&gt;
&lt;li&gt;一个函数是否是一个协程，取决于它里面是否出现了yield或yield from语句。这并不明显，容易在重构函数的时候搞乱，导致出错。&lt;/li&gt;
&lt;li&gt;异步调用被yield语法限制了，我们不能获得、使用更多的语法特性，比如with和for。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个PEP把协程从生成器独立出来，成为Python的一个原生事物。这会消除协程和生成器之间的混淆，方便编写不依赖特定库的协程代码。也为linter和IDE进行代码静态分析提供了机会。&lt;/p&gt;
&lt;p&gt;使用原生协程和相应的新语法，我们可以在异步编程时使用上下文管理器（context manager）和迭代器。如下文所示，新的async with语句可以在进入、离开运行上下文（runtime context）时进行异步调用，而async for语句可以在迭代时进行异步调用。&lt;/p&gt;

&lt;h2&gt;规范&lt;/h2&gt;
&lt;p&gt;该提议引入了新的语法和语义来增强Python对协程支持。&lt;/p&gt;
&lt;p&gt;请理解Python现有的协程（见PEP 342和PEP 380），这次改变的动机来自于asyncio框架（PEP 3156）和Confunctions提案（PEP 3152，此PEP已经被废弃）。&lt;/p&gt;
&lt;p&gt;由此，在本文中，我们使用“原生协程”指用新语法声明的协程。“生成器实现的协程”指用传统方法实现的协程。“协程”则用在两个都可以使用的地方。&lt;/p&gt;
&lt;h3 id=&quot;新的协程声明语法&quot;&gt;新的协程声明语法&lt;/h3&gt;
&lt;p&gt;使用以下语法声明原生协程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_data(db):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;协程语法的关键点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;async def函数必定是协程，即使里面不含有await语句。&lt;/li&gt;
&lt;li&gt;如果在async函数里面使用yield或yield from语句，会引发SyntaxError异常。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;在CPython内部，引入两个新的代码对象标识（code object flags）：&lt;br/&gt;CO_COROUTINE表示这是原生协程。（由新语法定义）&lt;br/&gt;CO_ITERABLE_COROUTINE表示这是用生成器实现的协程，但是和原生协程兼容。（用装饰器types.coroutine()装饰过的生成器协程）&lt;/li&gt;
&lt;li&gt;调用一个普通生成器，返回一个生成器对象（generator object）；相应的，调用一个协程返回一个协程对象（coroutine object&lt;/li&gt;
&lt;li&gt;协程不再抛出StopIteration异常，因为抛出的StopIteration异常会被包装（wrap）成一个RuntimeError异常。对于普通的生成器想要这样需要进行future import&lt;/li&gt;
&lt;li&gt;如果一个协程从未await等待就被垃圾收集器销毁了，会引发一个RuntimeWarning异常&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;types.coroutine()&lt;/h3&gt;
&lt;p&gt;types模块添加了一个新函数coroutine(fn)，使用它，“生成器实现的协程”和“原生协程”之间可以进行互操作。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@types.coroutine
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_data(db):
    data &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; read_data(db)
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数将CO_ITERABLE_COROUTINE标志应用于生成器函数的代码对象，使其返回一个协程对象。如果fn不是生成器函数，它将被包装。如果它返回一个生成器，它将被包装在一个等待的代理对象中（参见下面的等待对象的定义）。&lt;/p&gt;
&lt;p&gt;types.coroutine()不会设置CO_COROUTINE标识，只有用新语法定义的原生协程才会有这个标识。&lt;/p&gt;
&lt;h3 id=&quot;await表达式&quot;&gt;await表达式&lt;/h3&gt;
&lt;p&gt;新的await表达式用于获得协程执行的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_data(db):
    data &lt;/span&gt;= await db.fetch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT ...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;await 和yield from 是非常类似的，会挂起read_data的执行，直到等待db.fetch完成并返回结果数据。&lt;/p&gt;
&lt;p&gt;await使用yield from的实现，但是加入了一个额外步骤——验证它的参数类型。await只接受awaitable对象，awaitable对象是以下的其中一个：&lt;/p&gt;
&lt;p&gt;在本文中，有__await__方法的对象被称为Future-like对象（协程会被await语句挂起，直到await语句右边的Future-like对象的__await__执行完毕、返回结果。）&lt;/p&gt;
&lt;p&gt;如果__await__返回的不是一个迭代器，则引发TypeError异常。 &lt;/p&gt;
&lt;p&gt;在CPython C API，有tp_as_async.am_await函数的对象，该函数返回一个迭代器（类似__await__方法）&lt;/p&gt;
&lt;p&gt;如果在async def函数之外使用await语句，会引发SyntaxError异常。这和在def函数之外使用yield语句一样。&lt;/p&gt;
&lt;p&gt;如果await右边不是一个awaitable对象，会引发TypeError异常。&lt;/p&gt;

&lt;h3&gt;新的运算符优先级表&lt;/h3&gt;
&lt;p&gt;有效的语法示例&lt;/p&gt;

&lt;table class=&quot;docutils&quot; border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr&gt;&lt;th class=&quot;head&quot;&gt;Expression&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;Will be parsed as&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if await fut: pass&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if (await fut): pass&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if await fut + 1: pass&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if (await fut) + 1: pass&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;pair = await fut, 'spam'&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;pair = (await fut), 'spam'&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;with await fut, &lt;span class=&quot;pre&quot;&gt;open(): pass&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;with (await fut), &lt;span class=&quot;pre&quot;&gt;open(): pass&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await &lt;span class=&quot;pre&quot;&gt;foo()['spam'].baz()()&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await ( &lt;span class=&quot;pre&quot;&gt;foo()['spam'].baz()() )&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;return await coro()&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;return ( await coro() )&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;res = await coro() ** 2&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;res = (await &lt;span class=&quot;pre&quot;&gt;coro()) ** 2&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;func(a1=await &lt;span class=&quot;pre&quot;&gt;coro(), a2=0)&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;func(a1=(await &lt;span class=&quot;pre&quot;&gt;coro()), a2=0)&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await foo() + await bar()&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;(await &lt;span class=&quot;pre&quot;&gt;foo()) + (await &lt;span class=&quot;pre&quot;&gt;bar())&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;-await foo()&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;-(await &lt;span class=&quot;pre&quot;&gt;foo())&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;










&lt;p&gt;无效的用法&lt;/p&gt;

&lt;div id=&quot;examples-of-await-expressions&quot; class=&quot;section&quot;&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr&gt;&lt;th class=&quot;head&quot;&gt;Expression&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;Should be written as&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await await coro()&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await (await &lt;span class=&quot;pre&quot;&gt;coro())&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await &lt;span class=&quot;pre&quot;&gt;-coro()&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await &lt;span class=&quot;pre&quot;&gt;(-coro())&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;




&lt;h3&gt;异步上下文管理器和“async with”&lt;/h3&gt;

&lt;p&gt;异步上下文管理器（asynchronous context manager），可以在它的enter和exit方法里挂起、调用异步代码。&lt;/p&gt;
&lt;p&gt;为此，我们设计了一套方案，添加了两个新的魔术方法：__aenter__和__aexit__，它们必须返回一个awaitable。&lt;/p&gt;
&lt;p&gt;异步上下文管理器的一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncContextManager:
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aenter__&lt;/span&gt;&lt;span&gt;(self):
        await log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;entering context&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aexit__&lt;/span&gt;&lt;span&gt;(self, exc_type, exc, tb):
        await log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;exiting context&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;新语法&lt;/h3&gt;
&lt;p&gt;采纳了一个异步上下文管理器的新语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async with EXPR as VAR:
    BLOCK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这在语义上等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
mgr =&lt;span&gt; (EXPR)
aexit &lt;/span&gt;= type(mgr).&lt;span&gt;__aexit__&lt;/span&gt;&lt;span&gt;
aenter &lt;/span&gt;= type(mgr).&lt;span&gt;__aenter__&lt;/span&gt;&lt;span&gt;(mgr)

VAR &lt;/span&gt;=&lt;span&gt; await aenter
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    BLOCK
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; await aexit(mgr, *&lt;span&gt;sys.exc_info()):
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    await aexit(mgr, None, None, None)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与常规with语句一样，可以在单个async with语句中指定多个上下文管理器。&lt;/p&gt;
&lt;p&gt;在使用async with时，如果上下文管理器没有__aenter__和__aexit__方法，则会引发错误。在async def函数之外使用async with则会引发SyntaxError异常。&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;例子&lt;/h4&gt;
&lt;p&gt;使用异步上下文管理器，可以轻松地为协同程序实现适当的数据库事务管理器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; commit(session, data):
    ...

    async with session.transaction():
        ...
        await session.update(data)
        ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;加锁的处理也更加简洁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async with lock:
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不再是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with (&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; lock):
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;异步迭代器和“async for”&lt;/h3&gt;
&lt;p&gt;异步迭代器可以在它的iter实现里挂起、调用异步代码，也可以在它的__next__方法里挂起、调用异步代码。要支持异步迭代，需要：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象必须实现__aiter__方法（或者，如果使用CPython C API，需要定义tp_as_async.am_aiter）返回一个异步迭代器对象&lt;/li&gt;
&lt;li&gt;一个异步迭代对象必须实现一个__anext__方法（或者，如果使用CPython C API，需要定义tp_as_async.am_anext）返回一个awaitable&lt;/li&gt;
&lt;li&gt;要停止迭代，__anext__必须抛出一个StopAsyncIteration异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个一步迭代的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncIterable:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(self):
        data &lt;/span&gt;=&lt;span&gt; await self.fetch_data()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopAsyncIteration

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch_data(self):
        ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;新语法&lt;/h3&gt;
&lt;p&gt;采纳了一个迭代异步迭代器的新语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;for&lt;/span&gt; TARGET &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ITER:
    BLOCK
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    BLOCK2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在语义上等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iter =&lt;span&gt; (ITER)
iter &lt;/span&gt;= type(iter).&lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(iter)
running &lt;/span&gt;=&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; running:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        TARGET &lt;/span&gt;= await type(iter).&lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(iter)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopAsyncIteration:
        running &lt;/span&gt;=&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        BLOCK
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    BLOCK2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果async for的迭代器不支持__aiter__方法，则引发TypeError异常。如果在async def函数外使用async for，则引发SyntaxError异常。&lt;/p&gt;
&lt;p&gt;和普通的for语句一样，async for有一个可选的else分句。&lt;/p&gt;
&lt;h3&gt;例子1&lt;/h3&gt;
&lt;p&gt;使用异步迭代协议，可以在迭代期间异步缓冲数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cursor:
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中cursor是一个异步迭代器，它在每N次迭代后从数据库中预取N行数据。&lt;/p&gt;
&lt;p&gt;以下代码说明了新的异步迭代协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cursor:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.buffer &lt;/span&gt;=&lt;span&gt; collections.deque()

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _prefetch(self):
        ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.buffer:
            self.buffer &lt;/span&gt;=&lt;span&gt; await self._prefetch()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.buffer:
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopAsyncIteration
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.buffer.popleft()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，可以这样使用Cursor类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Cursor():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(row)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与下述代码相同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
i = await Cursor().&lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        row &lt;/span&gt;= await i.&lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopAsyncIteration:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(row)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;例子2：&lt;/h3&gt;
&lt;p&gt;以下是将常规迭代转换为异步迭代的实用程序类。虽然这不是一件非常有用的事情，但代码说明了常规迭代器和异步迭代器之间的关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncIteratorWrapper:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, obj):
        self._it &lt;/span&gt;=&lt;span&gt; iter(obj)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            value &lt;/span&gt;=&lt;span&gt; next(self._it)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopAsyncIteration
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value

async &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; letter &lt;span&gt;in&lt;/span&gt; AsyncIteratorWrapper(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(letter)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;为什么是stopasynciteration&quot;&gt;为什么是StopAsyncIteration？&lt;/h4&gt;
&lt;p&gt;协程在内部仍然是基于生成器实现的，因此，在PEP479之前，下面两者是没有区别的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; g1():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; fut
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;spam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; g2():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; fut
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; StopIteration(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于PEP 479已被正式采纳，并作用于协程，以下代码的StopIteration会被包装（wrapp）成一个RuntimeError。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; a1():
    await fut
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; StopIteration(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，要想通知外部代码迭代已经结束，抛出一个StopIteration异常的方法不行了。因此，添加了一个新的内置异常StopAsyncIteration，用于表示迭代结束。&lt;/p&gt;
&lt;p&gt;此外，根据PEP 479，协程抛出的所有StopIteration异常都会被包装成RuntimeError异常。&lt;/p&gt;
&lt;h3&gt;协程对象&lt;/h3&gt;
&lt;h4 id=&quot;和生成器的不同之处&quot;&gt;和生成器的不同之处&lt;/h4&gt;
&lt;p&gt;本节仅适用于具有CO_COROUTINE的原生协程，即使用新的async def 定义的函数&lt;/p&gt;
&lt;p&gt;对于asyncio模块里现有的“基于生成器的协程”，仍然保持不变。&lt;/p&gt;
&lt;p&gt;为了把协程和生成器的概念区分开来：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原生协程对象不实现__iter__和__next__方法，因此，不能对其进行迭代（如for...in循环），也不能传递给iter()，list()，tuple()及其它内置函数。如果尝试对其使用__iter__或__next__方法，会引发TypeError异常。&lt;/li&gt;
&lt;li&gt;未装饰的生成器不能yield from一个原生协程，这样做会引发TypeError异常。&lt;/li&gt;
&lt;li&gt;“基于生成器的协程”在经过 @asyncio.coroutine装饰后，可以yield from原生协程对象。&lt;/li&gt;
&lt;li&gt;对于原生协程对象和原生协程函数，调用inspect.isgenerator()和inspect.isgeneratorfunction()会返回False。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;协程对象的方法&lt;/h3&gt;
&lt;p&gt;协程是基于生成器实现的，因此它们有共同的代码。像生成器对象那样，协程也有throw()，send()和close()方法。&lt;br/&gt;对于协程，StopIteration和GeneratorExit起着同样的作用（虽然PEP 479已经应用于协程）。详见PEP 342、PEP 380，以及Python文档。&lt;/p&gt;
&lt;p&gt;对于协程，send()，throw()方法用于往Future-like对象发送内容、抛出异常。&lt;/p&gt;
&lt;h3&gt;调试特性&lt;/h3&gt;
&lt;p&gt;初级开发者在使用协程时可能忘记使用yield from语句，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@asyncio.coroutine
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; useful():
    asyncio.sleep(&lt;/span&gt;1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this will do nothing without 'yield from'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了调试这种错误，在asyncio中有一个特殊的调试模式，其中@coroutine装饰器用一个特殊对象包装所有函数，并使用析构函数记录警告。每当一个包装的生成器被垃圾回收时，就会生成一条详细的日志消息，其中包含有关定义装饰器函数的确切位置，堆栈跟踪收集位置等的信息.Wrapper对象还提供了一个方便的__repr__函数，其中包含有关生成器的详细信息。&lt;/p&gt;
&lt;h3&gt;新标准库函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;types.coroutine(gen) 详见types.coroutine()一节。&lt;/li&gt;
&lt;li&gt;inspect.iscoroutine(obj) 如果obj是原生协程对象，返回True。&lt;/li&gt;
&lt;li&gt;inspect.iscoroutinefunction(obj) 如果obj是原生协程函数，返回True。&lt;/li&gt;
&lt;li&gt;inspect.isawaitable(obj) 如果obj是awaitable返回True。&lt;/li&gt;
&lt;li&gt;inspect.getcoroutinestate(coro) 返回原生协程对象的当前状态（inspect.getfgeneratorstate(gen)的镜像）。&lt;/li&gt;
&lt;li&gt;inspect.getcoroutinelocals(coro) 返回一个原生协程对象的局部变量的映射【译注：变量名-&amp;gt;值】（inspect.getgeneratorlocals(gen) 的镜像）。&lt;/li&gt;
&lt;li&gt;sys.set_coroutine_wrapper(wrapper) 允许拦截原生协程对象的创建。wrapper必须是一个接受一个参数callable（一个协程对象），或者是None。None会重置（reset）这个wrapper。如果再次调用，新的wrapper会取代旧的。这个函数是线程专有的（thread-specific）。详见“调度特性”一节。&lt;/li&gt;
&lt;li&gt;sys.get_coroutine_wrapper() 返回当前的包装对象(wrapper object)。如果没有则返回None。这个函数是线程专有的（thread-specific）。详见“调度特性”一节。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;新的抽象基类&lt;/h3&gt;
&lt;p&gt;为了更好地与现有框架（如Tornado，见[13]）和编译器（如Cython，见[16]）集成，增加了两个新的抽象基类（ABC）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;collections.abc.Awaitable，Future-like类的抽象基类，实现__await__方法。&lt;/li&gt;
&lt;li&gt;collections.abc.Coroutine，协程对象的抽象基类，实现send(value)，throw(type, exc, tb)，close()和__await__()方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意，“基于生成器的协程”（有CO_ITERABLE_COROUTINE标识）并不实现__await__方法，因此它们不是collections.abc.Coroutine和collections.abc.Awaitable的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@types.coroutine
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gencoro():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;

&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; isinstance(gencoro(), collections.abc.Coroutine)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; however:&lt;/span&gt;
&lt;span&gt;assert&lt;/span&gt; inspect.isawaitable(gencoro())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了便于测试对象是否支持异步迭代，还添加了两个ABC：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;collections.abc.AsyncIterable --用于测试__aiter__方法。&lt;/li&gt;
&lt;li&gt;collections.abc.AsyncIterator --用于测试__aiter__和__anext__方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Mon, 03 Dec 2018 14:58:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>因为工作中慢慢开始用python的协程，所以想更好的理解一下实现方式，故翻译此文 原文中把词汇表放到最后，但是我个人觉得放在最开始比较好，这样可以增加当你看原文时的理解程度 词汇表 原生协程函数 Na</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10024264.html</dc:identifier>
</item>
<item>
<title>记一次idea性能调优 - 虚空之王</title>
<link>http://www.cnblogs.com/nevermorewang/p/10061377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nevermorewang/p/10061377.html</guid>
<description>&lt;p&gt;　　因自研的自动化测试工具包含压测功能，在自己本地代码开发完毕后进行测试，对目标接口进行1000次访问，发现idea在执行结束后变的异常卡顿，怀疑是idea工具或者程序代码存在问题，遂进行排查。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　本地所用MacBook Pro 2015配置&lt;/p&gt;
&lt;p&gt;　　处理器：i7 2.2GHz&lt;/p&gt;
&lt;p&gt;　　核心数：4&lt;/p&gt;
&lt;p&gt;　　内存：16GB&lt;/p&gt;
&lt;p&gt;　　系统：macOS Mojave&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　先从idea排查开始：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、打开jdk自带的jconsole工具，连接idea；同时打开活动监控器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　启动idea，可以看到idea的cpu跟内存消耗并不高：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220522434-1008454759.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220605916-253827753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动程序，再次观察cpu跟内存，cpu从2%到了10%，内存增长300M：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220648154-943706500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220709346-1721628236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本以为jconsole能明显看到jvm的变化情况，结果不然，而且显示的数值很小，只有47兆：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220806193-430467465.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220831585-2081692334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这跟系统的活动监视器的结果明显不符合嘛，后来发现，jconsole实际把idea跟程序的jvm内存使用都分开了，这个显示的只是idea的，其实本例中如果要查看内存大小，应该直接监控程序的。这个是程序的执行模块的内存情况：&lt;/p&gt;
&lt;div readability=&quot;27.027446300716&quot;&gt;
&lt;p&gt;　　&lt;strong&gt;2、执行压测程序，1000访问量，第一次执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　idea变得非常卡顿，系统的监控器看到明显的内存变化：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220933492-285008356.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221012354-1072982846.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;　　同时，jconsole看到了明显的内存跟cpu变化情况：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221043187-1625270834.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221104453-983694452.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;　　堆中老年代old：62M，新生代eden：780M左右，幸存区15M,之所以看到新生代跟幸存区一样高，是因为这里显示的百分比，实际新生代占用的非常多。这里多说一句，jvm的各个区的命名也是挺有意思的，新对象刚出生，就叫eden区，eden，，，伊甸园么，亚当跟夏娃开始的那个地方，这名字挺合适的；然后会有垃圾收集，挺不过去就被回收了，对对象来说这辈子也就算完了，挺过去的话，这条命算是保住了，属于幸存者，于是到了幸存区(survivor)。可是生活并没有结束，接下来还是有一次次的gc来考验我们的对象，很多人没能坚持下来，最终经历15次gc而没被回收的，相对来说年龄也不小了，进入的区域叫老年代(old)。挺有意思。&lt;/p&gt;
&lt;p&gt;这次执行结束之后，idea的响应速度还是可以的，不是怎么卡顿。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、压测1000访问量，第二次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从之前的经历来看，就是这次压测会导致idea非常卡顿，监控器情况:&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221206193-1628540751.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221217025-1792533751.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;　　执行过程中跟上次相比，并无明显区别，cpu跟内存均没有明显增长，但idea抛出了OOM提示框：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221251938-935897366.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;　　如果修改这几个参数，修改后的内容将被保存到/Users/nm/Library/Preferences/IntelliJIdea2018/idea.vmoptions中，idea默认读的配置文件也是这个，而不是安装目录的bin下的。&lt;/p&gt;
&lt;p&gt;　　压测程序执行结束之后，监控器看到的idea占用cpu依然很高，对idea的操作也会有卡顿(有时比较明显，也偶尔有相对流畅的)：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221341013-1527420459.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;　　点击Memory Dump，信息会被存到idea.vmoptions，然后点击continue继续。&lt;/p&gt;
&lt;p&gt;　　jconsole同样看到了内存跟cpu的增长：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221400140-1322447520.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;22.429752066116&quot;&gt;
&lt;p&gt;　　图表中的15:54左右的内存下降应该是jvm的gc导致，后边16:10分左右的cpu跟内存暴增然后降低才是这次压测的表现。（为何堆内存在16:10会骤降，怀疑可能正好有一次gc，jconsole的vm概要有gc次数，忘了截图）&lt;/p&gt;
&lt;p&gt;　　idea OOM框dump出的信息保存在$USER_HOME/heapDump_Leak_Supports.zip中，解压有heapDump.hprof文件，内容如下：&lt;/p&gt;
&lt;p&gt;　　用Memory Analyzer Tool打开这个hprof进行查看：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221448803-1110366988.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;　　说是a、b两部分内容“怀疑有罪”，分别235M跟109M，这两个都是什么东西呢？&lt;/p&gt;
&lt;p&gt;　　两个都是idea自己的一个类的对象com.intellij.openapi.editor.impl.DocumentImpl，看名字是个文档实现类&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221514389-1565831066.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;25.716748768473&quot;&gt;
&lt;p&gt;　　到这里，其实我已经猜出问题出在哪里了，是日志！因为我以前把控制台的输出设置为无限制，而为了本地调试方便，我又把hibernate的日志也打印了出来，在执行单个案例的时候并不明显，而如果执行大量案例执行，这个日志的量就非常大了，多次压测1000访问量后系统产生大量日志，这些日志都被作为文本类的内容被保存了起来，又因为我把控制台日志设为无限，idea不清除这些类对象，最终导致对象越来越大，拖垮了idea。&lt;/p&gt;
&lt;p&gt;　　如果检测的不是idea而是自己的程序，那么还可以继续通过histogram跟dominator_tree进行跟踪。因为强引用、软引用、弱引用跟虚引用只有强引用不会被gc，如果多次gc没有回收掉，肯定有强引用在关联这个对象，通过支配树　　dominator_tree(展示对象层级关系跟内存占用百分比)跟Merge Shortest Paths to GC Roots(展示gc树引用关系图)可以慢慢找到强引用的所在，从而定位内存溢出原因。&lt;/p&gt;


&lt;p&gt;　&lt;strong&gt;　4、参数修正&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　明白了问题所在，那么进行修复并测试，修改idea的相关参数配置为：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
-Xms512m
-Xmn512m
-Xmx2048m
-XX:ReservedCodeCacheSize=240m
-XX:+UseCompressedOops
-Dfile.encoding=UTF-8
-XX:+UseG1GC   //使用G1收集器，好处是并行收集
-XX:+UseNUMA  //优先使用速度较快的内存
-XX:SoftRefLRUPolicyMSPerMB=50
-ea
-Dsun.io.useCanonCaches=false
-Djava.net.preferIPv4Stack=true
-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;
-XX:+HeapDumpOnOutOfMemoryError
-XX:-OmitStackTraceInFastThrow
-Xverify:none

-XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log
-XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof
-javaagent:JetbrainsCrack-3.1-release-enc.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19.325670498084&quot;&gt;
&lt;p&gt;　　主要是将堆内存最小设为512，最大为2G，变为了原来的3倍，然后把gc算法改为了G1，并优化内存读取为NUMA。NUMA我也不熟悉，网上查到的结果如下：&lt;/p&gt;
&lt;p&gt;　　numa 是一个 CPU 的特性。SMP 架构下，CPU 的核是对称，但是他们共享一条系统总线。所以 CPU 多了，总线就会成为瓶颈。在 NUMA 架构下，若干 CPU 组成一个组，组之间有点对点的通讯，相互独立。启动它可以提高性能。&lt;/p&gt;
&lt;div readability=&quot;9.5333333333333&quot;&gt;　　NUMA 需要硬件，操作系统，JVM 同时启用，才能启用。Linux 可以用 &lt;a href=&quot;http://linux.die.net/man/8/numactl&quot;&gt;numactl&lt;/a&gt; 来配置 numa,JVM 通过-XX:+UseNUMA来启用。&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;5、执行，查看结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　按照以上步骤，同样程序启动后执行两次请求数量均为1000的压测，jconsole如图：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221758153-457008060.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;p&gt;　　两次明显的内存增长跟cpu消耗，监控器看到的内存情况：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221820413-1138206153.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;　　相比之前，idea的内存增长到了2.5G，cpu在压测结束后恢复正常。点击idea使用，没有在发生卡顿的情况，可知的确是日志导致idea卡顿的。而当时idea的cpu消耗亦很高，应该是频繁gc所致。&lt;/p&gt;
&lt;p&gt;　　当然，我仅仅这么修改是肯定不行的，如果控制台仍旧是无限，那么总有一天还是会oom的，我目前是手动清空控制台，发现效果也还可以，会有效。如果不手动清空，则一定要设置控制台最大行数，或者内存值，防止因日志而导致的idea卡死现象。&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　对jconsole的使用并不熟练，如有错误之处请留言指正，多谢多谢。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 03 Dec 2018 14:20:00 +0000</pubDate>
<dc:creator>虚空之王</dc:creator>
<og:description>因自研的自动化测试工具包含压测功能，在自己本地代码开发完毕后进行测试，对目标接口进行1000次访问，发现idea在执行结束后变的异常卡顿，怀疑是idea工具或者程序代码存在问题，遂进行排查。 本地所用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nevermorewang/p/10061377.html</dc:identifier>
</item>
<item>
<title>1 小时 SQL 极速入门（二） - 李英杰同学</title>
<link>http://www.cnblogs.com/injet/p/10061372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/injet/p/10061372.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-113aa322971bb7a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;eeee.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上篇我们说了 SQL 的基本语法，掌握了这些基本语法后，我们可以对单表进行查询及计算分析。但是一个大的系统，往往会有数十上百张表，而业务关系又错综复杂。我们要查的数据往往在好几张表中，而要从多张表中来获取信息就需要用到表联结了。&lt;/p&gt;
&lt;p&gt;先说说什么是联结，联结就是用一条 SELECT 语句从多个表中查询数据。通过联结，让多张表中的数据互相关联起来。联结又分为内联结、左外联结、右外联结、全外联结。别怕，我知道有些初学者看到这几个概念就头大，不过请继续往后看，看完后你肯定能看明白。在实际中，内联结和左联结应该是使用最多的，我几乎没用到过右连接与全外联结。&lt;/p&gt;
&lt;p&gt;对初学者来说，在这里迷惑的原因是去记这些概念，这是没必要的，我们只要在实际中抱着问题去用一次就可以完全掌握了。&lt;/p&gt;
&lt;p&gt;下面我们就开始：&lt;br/&gt;我们有下面三张表，一张订单表存放订单头信息，包括订单号、订单类型、订单数量、订单状态信息。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-d99d7a4865481433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ORDER_HEADER.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一张订单明细表，存储订单的详细信息。包含订单号、订单类型、工序号、工序名称、工序状态、物料号、工位号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-c66c73ec611be8e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ORDER_DETAIL.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一张物料表，存储订单工序用到的物料。包含物料号、物料名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-4f1e8032674b2331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;PRODUCT.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;内联结&quot;&gt;内联结&lt;/h2&gt;
&lt;p&gt;我们先观察一下，订单头信息中只包含订单的数量、状态信息。订单明细表中包含着订单的详细信息，如工序信息，每道工序用到的物料，每道工序的名称，在哪个工位操作等信息。假如我们现在要查询订单号、订单数量、工序号、工序名称、工位等信息，只有一张表我们是查不到的，那么我们就要把这两张表结合起来。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
  oh.orderno,
  oh.order_type,
  oh.quantity,
  od.order_line_no,
  od.order_line_name,
  od.workcenter
FROM
  order_header oh
INNER JOIN order_detail od
ON
  oh.orderno     =od.orderno
AND oh.order_type=od.order_type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释下：我们用INNER JOIN 表示内连接，在 INNER JOIN 后写上我们需要关联的表，oh 和 od 表示别名，方便后面书写，不然后面我们就要用到表的全称来写了。这里我们要关联到订单明细表 order_detail，去取出订单详细信息。后面跟上 ON 关键字，表示条件，这里 ON 后面有两个条件。表示我们通过订单号和订单类型来把两个表中的数据关联起来，通过订单表中的订单号和订单类型作为条件来查找订单明细表中同样订单号和订单类型的订单的详细信息。&lt;/p&gt;
&lt;p&gt;我们看下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-c52c6e8cc0281b27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;JOIN1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们查出了订单 1001 ，1002， 1003， 1004， 1005五个订单的总数量，各个工序的名称，在哪个工位生产等信息。&lt;/p&gt;
&lt;p&gt;细心的读者可能会注意到，在订单表中还有一个 1008 的订单，为什么没有查出来？那就接着往下看&lt;/p&gt;
&lt;h2 id=&quot;左联结&quot;&gt;左联结&lt;/h2&gt;
&lt;p&gt;相比于内联结，左联结使用 LEFT JOIN 来表示。我们先不看概念，我们直接把刚才的 SQL 语句改成左联结来看一下结果。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
  oh.orderno,
  oh.order_type,
  oh.quantity,
  od.order_line_no,
  od.order_line_name,
  od.workcenter
FROM
  order_header oh
LEFT JOIN order_detail od
ON
  oh.orderno     =od.orderno
AND oh.order_type=od.order_type;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-85f818706a4fe6d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;LEFTJOIN.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比内联结的结果，我们发现了什么，我们发现最下面多了一行，1008 订单，而1008 后面的几个字段为空。我们看一下订单明细表会发现没有 1008 这个订单。&lt;/p&gt;
&lt;p&gt;这样子我们就明白了，内联结是两张表中都存在才能关联出来。而左联结的意思就是我们的主表中的所有行都会展示出来，如果在联结的表中找不到对应的，会默认为 null.&lt;/p&gt;
&lt;h2 id=&quot;右联结&quot;&gt;右联结&lt;/h2&gt;
&lt;p&gt;知道了左联结，右联结也就清楚了，右连接呢会把我们关联的表中的所有行都展示出来，不管主表中有没有匹配的行。右联结关键字为 RIGHT JOIN&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
  oh.orderno,
  oh.order_type,
  oh.quantity,
  od.order_line_no,
  od.workcenter
FROM
  order_header oh
RIGHT JOIN order_detail od
ON
  oh.orderno     =od.orderno
AND oh.order_type=od.order_type;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-ae3e5d4cfaac0ab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;RIGHTJOIN.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，RIGHT JOIN 把关联的订单明细表中的所有行都显示了出来，但是订单主表中并没有 1006 和 1007 两个订单，所以这两行显示为 null&lt;/p&gt;
&lt;h2 id=&quot;多表联结&quot;&gt;多表联结&lt;/h2&gt;
&lt;p&gt;多表联结就是超过两张表的联结，上面我们关联了订单表和订单明细表，现在我们想知道每道工序用到的物料，就需要关联到物料表。我们看到订单明细表中有 productid 字段，我们用这个关联到 product 表中。同时，后面我们也用了 ORDER BY 进行排序。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
  oh.orderno,
  oh.order_type,
  oh.quantity,
  od.order_line_no,
  od.workcenter,
  p.productno,
  p.product_name
FROM
  order_header oh
INNER JOIN order_detail od
ON
  oh.orderno =od.orderno
INNER JOIN product1 p
ON
  od.productid   =p.ID
AND oh.order_type=od.order_type
ORDER BY
  orderno,
  order_line_no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-1fd3f2c8c8698c5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;JOIN2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;
&lt;p&gt;在使用联结时一定要注意联结条件，如果 联结条件不正确，就会得到不正确的结果。而且要注意，联结条件是必须的。&lt;/p&gt;
&lt;h2 id=&quot;union-与-union-all&quot;&gt;UNION 与 UNION ALL&lt;/h2&gt;
&lt;p&gt;UNION 与 UNION ALL 表示并集，可以把两个 SELECT 查询的结果合并成一个，前提是两个 SELECT 所查询的列数量和字段类型一致。不同的是 UNION 会去除重复行，而 UNION ALL 不会去除重复行。&lt;/p&gt;
&lt;p&gt;如果我们有两张表，都存有相似的信息。比如我们在一个其他表中也存储的有订单信息。举个栗子，order_header_bak 表中存有如下两条数据。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-5846ab992fd19dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ORDERBAK.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们用 UNION ALL 试一下&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
  orderno,
  order_type,
  order_status
FROM
  order_header
UNION ALL
SELECT
  orderno,
  order_type,
  order_status
FROM
  order_header_bak;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-dd28c99ccdcc38e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;UNIONALL.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到查出了 8 条信息，1001 订单有两条一样的信息。&lt;br/&gt;我们用 UNION 试一下&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
  orderno,
  order_type,
  order_status
FROM
  order_header
UNION
SELECT
  orderno,
  order_type,
  order_status
FROM
  order_header_bak&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1691280-0dcb0f83e516c680.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;UNION.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到只有 7 条数据了， 1001 订单只有一行数据。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 14:19:00 +0000</pubDate>
<dc:creator>李英杰同学</dc:creator>
<og:description>1 小时 SQL 极速入门（二）——表联结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/injet/p/10061372.html</dc:identifier>
</item>
<item>
<title>超平面多维近似向量查找工具annoy使用总结 - zxyza</title>
<link>http://www.cnblogs.com/zxyza/p/10061330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxyza/p/10061330.html</guid>
<description>&lt;p&gt;需求：我有800万的中文词向量，我想要查询其中任意一个向量对应的最邻近的向量是哪些。通常情况下如果向量集比较小的话，几十万个向量（几个G这种），我们都可以用gensim的word2vec来查找，但是880万有16个G，加到内存中就爆炸了，而且gensim中的查找属于暴力搜索，即全都遍历比较余弦相似度来进行查找，因此几百万的词向量查找起来就很慢了。这里我需要用更快速的工具来进行查找，找到了两个工具，一个是facebook的faiss包另一个是annoy包。Faiss只能部署在linux，而且看着好复杂，各种索引类型啥的，估计够我研究一阵，索性使用了annoy包；&lt;/p&gt;
&lt;p&gt;关于annoy包的使用方法参考这两个网址足够：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;invisible&quot;&gt;1、&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/spotify/annoy&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;github.com/spotify/anno&lt;span class=&quot;invisible&quot;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;invisible&quot;&gt;2、&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//markroxor.github.io/gensim/static/notebooks/annoytutorial.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;markroxor.github.io/gen&lt;span class=&quot;invisible&quot;&gt;sim/static/notebooks/annoytutorial.html&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;span class=&quot;visible&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;1是官方文档，写的非常简单，但是我刚开始没有认真看，所以走了很多弯路；2是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;一个notebook实践案例，基于gensim的，我就是被这个版本给坑了。。。这里面有很多说道，首先我先说一下代码逻辑，其实很简单，首先是读取你的带 word和vec的txt向量文件作为model：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; model = gensim.models.KeyedVectors.load_word2vec_format(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\describe\\dic\\synonyms_vector.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,binary=False,unicode_errors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ignore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; annoy_index = AnnoyIndexer(model, 100&lt;span&gt;)　　　　　　# 生成索引
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; fname = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;synonyms_txt_index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; annoy_index.save(fname)　　　　　　　　　　　　　　　# 将索引文件保存到硬盘
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码说明&lt;/p&gt;
&lt;p&gt;这四行代码目的是&lt;/p&gt;
&lt;p&gt;1、加载model&lt;/p&gt;
&lt;p&gt;2、对model进行聚类计算&lt;/p&gt;
&lt;p&gt;3、建立一个二叉树集合的索引（树的数量为100），&lt;/p&gt;
&lt;p&gt;4、将索引保存到硬盘&lt;/p&gt;
&lt;p&gt;接下来我们就可以根据建立的这个索引来查找近似向量了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; annoy_index2 =&lt;span&gt; AnnoyIndexer()　　　　# 初始化索引
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;annoy_index2.load(fname)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; annoy_index2.model = model
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这三行就是来加载索引，值得注意的是这里的model就是之前最开始加载的txt文件对应的model&lt;/p&gt;
&lt;p&gt;接下来问题来了，执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; word =&lt;span&gt; ‘人民’
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; vector1 =&lt;span&gt; model[word]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; approximate_neighbors = model.most_similar([vector1], topn=30, indexer=annoy_index2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里想要查询“人民”对应的前30个相近词，通过加载索引来查询，可是最终的查询速度跟我没建立索引之前的暴力搜索（即word2vec自带搜索）是一样的，但是如果我在这个加载索引之前先进行一个词的暴力搜索，然后再对其他的词进行加载索引搜索，速度就会快出很多倍，这让我百思不得其解，最后没办法我就先用暴力搜索先搜索一个词，然后剩下的词都用annoy搜索，这样速度还是很快的；&lt;/p&gt;
&lt;p&gt;但是我还是想弄明白到底怎么回事，于是我去官网问作者，作者就说了一句，你需要进行整数映射，（而且应该是非负整数），靠！！！其实官网写的明明白白：&lt;/p&gt;
&lt;p&gt;a.add_item(i, v) adds item i (any nonnegative integer) with vector v. Note that it will allocate memory for max(i)+1 items.&lt;/p&gt;
&lt;p&gt;也就是说我的txt文件格式需要如下这种格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1 vecor
2 vecor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而不是开头是汉语单词以及对应的vector，最后再做一个integer到word的映射字典即可；&lt;/p&gt;
&lt;p&gt;接下来我对作者给出的github上的版本进行了验证，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; annoy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AnnoyIndex
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
f &lt;/span&gt;= 100&lt;span&gt;
t &lt;/span&gt;=&lt;span&gt; AnnoyIndex(f)
dict &lt;/span&gt;=&lt;span&gt; {}
with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\Administrator\Desktop\synonyms\\synonyms_vector.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    count &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
        result &lt;/span&gt;=&lt;span&gt; line.split()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(result)&amp;gt;10&lt;span&gt;:
            count&lt;/span&gt;+=1&lt;span&gt;
            word &lt;/span&gt;=&lt;span&gt; result[0]
            dict[count] &lt;/span&gt;=&lt;span&gt; word
            vector &lt;/span&gt;= list(map(eval, result[1:]))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需要将txt中的str格式vec转化为float格式&lt;/span&gt;
&lt;span&gt;            t.add_item(count, vector)
t.build(&lt;/span&gt;10&lt;span&gt;)
t.save(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\Administrator\Desktop\synonyms\\test.ann&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
u &lt;/span&gt;= AnnoyIndex(100&lt;span&gt;)
u.load(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\Administrator\Desktop\synonyms\\test.ann&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
simi_id &lt;/span&gt;= u.get_nns_by_item(880, 20,include_distances=&lt;span&gt;True)
id &lt;/span&gt;=&lt;span&gt; simi_id[0]
score &lt;/span&gt;= simi_id[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(simi_id)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; for i,j in zip(id,score):&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(dict[i])&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(0.5*(abs(1-j))+0.5)&lt;/span&gt;
result =[(dict[i],0.5*(abs(1-j))+0.5) &lt;span&gt;for&lt;/span&gt; i,j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(id,score)]
输出结果(result)：
[(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;投资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1.0), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;融资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.6934992074966431), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;投资者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.6180032193660736), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;投资额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.6166684031486511), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;房地产&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.6127455532550812), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;外资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.6104367673397064)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面我需要指出几点需要注意的地方：&lt;/p&gt;
&lt;p&gt;1、需要将txt中的str格式vec转化为float格式，否则会报错；&lt;/p&gt;
&lt;p&gt;2、我建立了一个字典映射，这样能够最后从查询到的近似向量对应的id值查询到映射的词；&lt;/p&gt;
&lt;p&gt;3、最后那个0.5*(abs(1-j))+0.5是余弦相似度归一化的计算公式，作者程序中建立的距离索引以及最后查找返回值都是默认angular模式（即j的值），也即是余弦相似度，即angular=1-cosin，且其值域为[0,2]（因为cosin值域为[-1,1]）。但是我们通常只需要求取cosin的绝对值，即其值域应该位于[0,1]。所以我先用1-angular 获取cosin 然后再求取绝对值，最后再进行归一化（（1+余弦相似度）/2）即可。&lt;/p&gt;
&lt;p&gt;4、对于上面代码求取结果我和word2vec的most_similar对比了一下，近似度基本一致，前三位精度完全一致，说明最后的余弦相似度求取向量相似度就是按照我上面说的方法来进行的；&lt;/p&gt;
&lt;p&gt;最后附上余弦相似度计算方法参考网址：&lt;a href=&quot;https://www.cnblogs.com/bymo/p/8489037.html&quot; target=&quot;_blank&quot;&gt;余弦相似度python实现&lt;/a&gt;&lt;a title=&quot;余弦相似度python实现&quot; href=&quot;https://www.cnblogs.com/bymo/p/8489037.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;PS:关于annoy加载索引还需要注意一点，索引文件路径必须是英文路径，否则程序就会提示查找不到文件，望注意！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 14:12:00 +0000</pubDate>
<dc:creator>zxyza</dc:creator>
<og:description>annoy快速查询数百万级别的近似向量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zxyza/p/10061330.html</dc:identifier>
</item>
<item>
<title>正确的使用字符串String - Fode</title>
<link>http://www.cnblogs.com/fode/p/10061233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fode/p/10061233.html</guid>
<description>&lt;p&gt;&lt;span&gt;字符串作为所有编程语言中使用最频繁的一种基础数据类型。如果使用不慎，将会造成不必要的内存开销，为此而付出代价。而要优化此类型，从以下两点入手：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、尽量少的装箱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、避免分配额外的内存空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从第一点装箱的操作说起,查看如下代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发生装箱的代码&lt;/span&gt;
 String boxOperate = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;4.5f&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中间语言IL代码为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    IL_0000: nop
    IL_0001: ldstr &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    IL_0006: ldc.r4 &lt;/span&gt;&lt;span&gt;4.5&lt;/span&gt;&lt;span&gt;
    IL_000b: box [mscorlib]System.Single
    IL_0010: call &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; [mscorlib]System.String::Concat(&lt;span&gt;object&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;)
    IL_0015: stloc.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    IL_0016: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey()
    IL_001b: pop
    IL_001c: ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不难看出，上述代码发生了装箱的操作(IL代码中的box).装箱之所以会发生性能损耗，因为它要完成如下三个步骤：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、首先，会为值类型在托管堆中分配内存。除了值类型本身所分配的内存外，内存总量还要加上类型对象指针和同步块索引所占用的内存，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、将值类型的值复制到新分配的堆内存中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、返回已经成为引用类型的对象的地址。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在来看以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有发生装箱的代码&lt;/span&gt;
 String boxOperate = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;4&lt;/span&gt;.ToString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中间IL代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    IL_0000: nop
    IL_0001: ldstr &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    IL_0006: ldc.r4 &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    IL_000b: stloc.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    IL_000c: ldloca.s &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    IL_000e: call instance &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; [mscorlib]System.Single::ToString()
    IL_0013: call &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; [mscorlib]System.String::Concat(&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
    IL_0018: stloc.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    IL_0019: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey()
    IL_001e: pop
    IL_001f: ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，并没有发生任何装箱操作，但是达到的结果却是我们想要的。原因是 4.ToString() 这行代码并没有发生装箱行为，是实际调用的是浮点型的ToString()方法，其原型如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString(){
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Number.FormatInt32(m_value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, NumberFormat.CurrentInfo);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能有人会问，是不是原型中的 Number.Format_XXX方法会发生装箱行为呢？实际上，Number.Format_XXX方法是一个非托管的方法，其原型如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[MethodImpl(MethodImplOptions.InternalCall), SecurityCritical]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; statuc &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FormatInt32(&lt;span&gt;int&lt;/span&gt; value, &lt;span&gt;string&lt;/span&gt; format,NumberFormatInfo info);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它是通过&lt;strong&gt;直接操作内存&lt;/strong&gt;来完成 Int32 到 String 的转换，效率要比装箱高得多。所以，在使用其他值引用类型到字符串得转换比完成拼接时，应当避免使用操作符 “+” 来我完成，而应该使用值引用类型提供得ToString方法。&lt;/p&gt;
&lt;p&gt;也许有人会问：即使FCL提供得方法没有发生装箱行为，但在其他情况下，FCL方法内部会不会含有装箱的行为？也许会存在，所以，本人推荐：&lt;strong&gt;编写代码中，应当尽量避免发生不必要的装箱代码。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第二个方面：避免分配额外的空间。对于CLR来说，String对象(字符串对象)是个很特殊的对象，它一旦被赋值就不可改变（在内存中）。在运行时调用System.String类中的任何方法或进行任何运算(’=‘赋值，’+‘拼接等)，都会在内存中创建一个新的字符串对象，这也意味着要为该新对象分配新的内存空间。如以下代码会带来额外开销。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test()&lt;br/&gt;{
 　　String str1 &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     str1 &lt;/span&gt;= str1 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;345&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上代码创建了3个String对象，并执行了一次String.Contact方法。&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而在以下代码中，字符串不会在运行时拼接字符串，而是会在编译时直接生成一个字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;private static void Test()&lt;br/&gt;{&lt;br/&gt;String str= &quot;aa&quot; + &quot;123&quot; + &quot;345&quot;;//等效 String str= &quot;aa123345&quot;；&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;private static void Test2()&lt;br/&gt;{&lt;br/&gt;const String str = &quot;aa&quot;;&lt;br/&gt;String newStr = &quot;123&quot; + str;&lt;br/&gt;//因为str是一个常量，所以该代码等效于 String newStr = &quot;123&quot; + “aa”;&lt;br/&gt;//最终等效于 String newStr = &quot;123aa”;&lt;br/&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;       由于使用System.String类会在某些场合带来明显的性能损耗，所以微软另外提供了一个类型StringBuilder来弥补String的不足。&lt;/p&gt;
&lt;p&gt;       StringBuilder并不会重新创建一个String对象，它的效率源于预先以非托管的方式分配内存。如果StringBuilder没有先定义长度，则默认分配的长度为16。当StringBuilder的长度大于16小于32时，StringBuild又会重新分配内存，使之成为16的倍数。StringBuilder重新分配内存时按照上次的容量加倍进行分配的。&lt;strong&gt;注意：StringBuilder指定的长度要合适，太小了，需要频繁分配内存；太大了，浪费内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以下是例子举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String Test3()
        {
            String a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            a &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            a &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            a &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String Test4()
        {
            String a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            String b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            String c &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            String d &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b + c +&lt;span&gt; d;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上两种效率都不高效。不要以为前者比后者创建的字符串对象更少，事实上，两者创建的字符串对象相等
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;且前者进行了3次的String.Contact方法调用，比后者还多了两次。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要完成上图的运行时的字符串拼接(注意：是运行时)，更佳的做法是使用StringBuilder类型，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String Test5()
        {
            String a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            String b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            String c &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            String d &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder(a);
            sb.Append(b);
            sb.Append(c);
            sb.Append(d);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.ToString();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为说的是运行时，所以没必要使用以下代码
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;StringBuilder sb = new StringBuilder(&quot;t&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sb.Append(&quot;e&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sb.Append(&quot;s&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sb.Append(&quot;t&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return sb.ToString();&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;微软还提供了另外一个来简化这种操作，即使用String.Format 方法。String.Format方法在内部使用StringBuilder 进行字符串格式化，如下图代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String Test6()
{
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为演示，定义4个变量&lt;/span&gt;
      String a = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      String b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      String c &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      String d &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}{1}{2}{3}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, a, b, c, d);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此次随笔结束！这是本人第一次写博客，如有什么错误的解释，欢迎批评指正。&lt;/p&gt;

</description>
<pubDate>Mon, 03 Dec 2018 13:58:00 +0000</pubDate>
<dc:creator>Fode</dc:creator>
<og:description>字符串作为所有编程语言中使用最频繁的一种基础数据类型。如果使用不慎，将会造成不必要的内存开销，为此而付出代价。而要优化此类型，从以下两点入手： 1、尽量少的装箱 2、避免分配额外的内存空间 先从第一点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fode/p/10061233.html</dc:identifier>
</item>
<item>
<title>前端入门12-JavaScript语法之函数 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/10061204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/10061204.html</guid>
<description>&lt;p&gt;本系列文章内容全部梳理自以下几个来源：&lt;/p&gt;
&lt;p&gt;作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。&lt;/p&gt;
&lt;p&gt;PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。&lt;/p&gt;

&lt;p&gt;在 JavaScript 里用 function 声明的就是函数，函数本质上也是一个对象，不同的函数调用方式有着不同的用途，下面就来讲讲函数。&lt;/p&gt;
&lt;p&gt;函数有一些相关术语： function 关键字、函数名、函数体、形参、实参、构造函数；&lt;/p&gt;
&lt;p&gt;其中，大部分的术语用 Java 的基础来理解即可，就构造函数需要注意一下，跟 Java 里不大一样。在 JavaScript 中，所有的函数，只要它和 new 关键字一起使用的，此时，就可称这个函数为构造函数。&lt;/p&gt;
&lt;p&gt;因为，为了能够在程序中辨别普通函数和构造函数，书中建议需要有一种良好的编程规范，比如构造函数首字母都用大写，普通函数或方法的首字母小写，以人为的手段来良好的区分它们。这是因为，通常用来当做构造函数就很少会再以普通函数形式使用它。&lt;/p&gt;
&lt;h3 id=&quot;函数定义&quot;&gt;函数定义&lt;/h3&gt;
&lt;p&gt;函数的定义大体上包含以下几部分：function 关键字、函数对象的变量标识符、形参列表、函数体、返回语句。&lt;/p&gt;
&lt;p&gt;如果函数没有 return 语句，则函数返回的是 undefined。&lt;/p&gt;
&lt;p&gt;函数定义有三种方式：&lt;/p&gt;
&lt;h4 id=&quot;函数声明式&quot;&gt;函数声明式&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;add(1,2); //由于函数声明被提前了，不会出错
function add(x, y) {
    //函数体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;add 是函数名，由于 JavaScript 有声明提前的处理，以这种方式定义的函数，可以在它之前调用。&lt;/p&gt;
&lt;h4 id=&quot;函数定义表达式&quot;&gt;函数定义表达式&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var add = function (x, y) {
    //函数体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式其实是定义了匿名函数，然后将函数对象赋值给 add 变量，JavaScript 的声明提前处理只将 add 变量的声明提前，赋值操作仍在原位置，因此这种方式的声明，函数的调用需要在声明之后才不会报错。&lt;/p&gt;
&lt;p&gt;注意，即使 function 后跟随了一个函数名，不使用匿名函数方式，但在外部仍旧只能使用 add 来调用函数，无法通过函数名，这是由于 JavaScript 中作用域机制原理导致，在后续讲作用域时会来讲讲。&lt;/p&gt;
&lt;h4 id=&quot;function&quot;&gt;Function&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var add = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
//基本等价于
var add = function (x, y) {
    return x*y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Function 构造函数接收不定数量的参数，最后一个参数表示函数体，前面的都作为函数参数处理。&lt;/p&gt;
&lt;p&gt;注意：以这种方式声明的函数作用域是全局作用域，即使这句代码是放在某个函数内部，相当于全局作用域下执行 eval()，而且对性能有所影响，不建议使用这种方式。&lt;/p&gt;
&lt;h3 id=&quot;函数调用&quot;&gt;函数调用&lt;/h3&gt;
&lt;p&gt;跟 Java 不一样的地方，在 JavaScript 中函数也是对象，既然是对象，那么对于函数对象这个变量是可以随意使用的，比如作为赋值语句的右值，作为参数等。&lt;/p&gt;
&lt;p&gt;当被作为函数对象看待时，函数体的语句代码并不会被执行，只有明确是函数调用时，才会触发函数体内的语句代码的执行。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function () {
    return 2;
}
var b = a;    //将函数对象a的引用赋值给b
var c = a();  //调用a函数，并将返回值赋值给c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数的调用可分为四种场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作为普通函数被调用&lt;/li&gt;
&lt;li&gt;作为对象的方法被调用&lt;/li&gt;
&lt;li&gt;作为构造函数被调用&lt;/li&gt;
&lt;li&gt;通过 call() 或 apply() 间接的调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同场景的调用所造成的区别就是，函数调用时的上下文（this）区别、作用域链的区别；&lt;/p&gt;
&lt;h4 id=&quot;作为普通函数被调用&quot;&gt;作为普通函数被调用&lt;/h4&gt;
&lt;p&gt;通常来说，直接使用函数名+() 的形式调用，就可以认为这是作为函数被调用。如果有借助 &lt;code&gt;bind()&lt;/code&gt; 时会是个例外的场景，但一般都可以这么理解。&lt;/p&gt;
&lt;p&gt;如果只是单纯作为函数被调用，那么通常是不用去考虑它的上下文、它的this值，因为这个时候，函数的用途倾向于处理一些通用的工作，而不是特定对象的特定行为，所以需要使用 this 的场景不多。&lt;/p&gt;
&lt;p&gt;普通函数被调用时的作用域链的影响因素取决于这个函数被定义的位置，作用域链是给变量的作用域使用的，变量的作用域分两种：全局变量、函数内变量，作用域链决定着函数内的变量取值来源于哪里；&lt;/p&gt;
&lt;p&gt;普通函数被调用时的上下文在非严格模式下，一直都是全局对象，不管这个函数是在嵌套函数内被调用或定义还是在全局内被定义或调用。但在严格模式下，上下文是 undefined。&lt;/p&gt;
&lt;h4 id=&quot;作为对象的方法被调用&quot;&gt;作为对象的方法被调用&lt;/h4&gt;
&lt;p&gt;普通的函数如果挂载在某个对象内，作为对象的属性存在时，此时可从对象角度称这个函数为对象的方法，而通过对象的引用访问这个函数类型的属性并调用它时，此时称为方法调用。&lt;/p&gt;
&lt;p&gt;方法调用的上下文（this）会指向挂载的这个对象，作用域链仍旧是按照函数定义的位置生成。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = {
    b: 1,
    c: function () {
        return this.b;
    }
}
a.c();  //输出1，a.c() 称为对象的方法调用
a[&quot;c&quot;](); //对象的属性也可通过[]访问，此种写法也是调用对象a的c方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有明确通过对象的引用访问函数类型的属性并调用它的行为才称为对象的方法调用，并不是函数挂载在对象上，它的调用就是方法调用，需要注意下这点，看个例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var d = a.c;
d();  //将对象的c函数引用赋值给d，调用d，此时d()是普调的函数调用，上下文在非严格模式下是全局对象，不是对象a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面通过一个例子来说明普通函数调用和对象的方法调用：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = 0;
var o = {
    a:1,
    m: function () {
        console.log(this.a); 
        f();  //f() 是函数调用
        function f() {
            console.log(this.a);
        }
    }
}
o.m(); //输出 1 0，因为0.m()是方法调用，m中的this指向对象o，所以输出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出1 0，因为 &lt;code&gt;o.m()&lt;/code&gt; 是方法调用，m 中的 this 指向对象 o，所以输出的 a 是对象 o 中 a 属性的值 1；&lt;/p&gt;
&lt;p&gt;而 m 中虽然内嵌了一个函数 f，它并不挂载在哪个对象像，&lt;code&gt;f()&lt;/code&gt; 是对函数 f 的调用，那么它的上下文 this 指向的是全局对象。&lt;/p&gt;
&lt;p&gt;所以，对于函数的不同场景的调用，重要的区别就是上下文。&lt;/p&gt;
&lt;h4 id=&quot;作为构造函数被调用&quot;&gt;作为构造函数被调用&lt;/h4&gt;
&lt;p&gt;普通函数挂载在对象中，通过对象来调用称方法；而当普通函数结合 new 关键字一起使用时，被称为构造函数。&lt;/p&gt;
&lt;p&gt;构造函数的场景跟其他场景比较不同，区别也比较大一些，除了调用上下文的区别外，在实参处理、返回值方面都有不同。&lt;/p&gt;
&lt;p&gt;如果不需要给构造函数传入参数，是可以省略圆括号的，如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var o = new Object();
var o = new Object;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于方法调用或函数调用圆括号是不能省略的，一旦省略，就只会将它们当做对象处理，并不会调用函数。&lt;/p&gt;
&lt;p&gt;构造函数调用时，是会创建一个新的空对象，继承自构造函数的 prototype 属性，并且这个新创建的空对象会作为构造函数的上下文，如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var o = {
    a:1,
    f:function () {
        console.log(this.a);
    }
}
o.f();  //输出1
new o.f();  //输出undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是 &lt;code&gt;o.f()&lt;/code&gt; 时，此时是方法调用，输出 1;&lt;/p&gt;
&lt;p&gt;而如果是 &lt;code&gt;new o.f()&lt;/code&gt; 时，此时 f 被当做构造函数处理，this 指向的是新创建的空对象，空对象没有 a 这个属性，所以输出 undefined。&lt;/p&gt;
&lt;p&gt;构造函数通常不使用 return 语句，默认会创建继承自构造函数 prototype 的新对象返回。但如果硬要使用 return 语句时，如果 return 的是个对象类型，那么会覆盖掉构造函数创建的新对象返回，如果 return 的是原始值时，return 语句无效。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var o = {
    f:function () {
        return [];
    }
}

var b = new o.f();  //b是[] 空数组对象，而不是f&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;间接调用&quot;&gt;间接调用&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 是 Function.prototype 提供的函数，所有的函数对象都继承自 Function.prototype，所有都可以使用这两个函数。它们的作用是可以间接的调用此函数。&lt;/p&gt;
&lt;p&gt;什么意思，也就是说，任何函数可以作为任何对象的方法来调用，即使这个函数并不是那个对象的方法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var o = {
    a:1,
    f:function () {
        console.log(this.a);
    }
}
o.f(); //输出1
var o1 = {
    a:2
}
o.f.call(o1); //输出2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数 f 原本是对象 o 的方法，但可以通过 call 来间接让函数 f 作为其他对象如 o1 的方法调用。&lt;/p&gt;
&lt;p&gt;所以间接调用本质上也还是对象的方法调用。应用场景可以是子类用来调用父类的方法。&lt;/p&gt;
&lt;p&gt;那么函数的调用其实按场景来分可以分为三类：作为普通函数被调用，作为对象方法被调用，作为构造函数被调用。&lt;/p&gt;
&lt;p&gt;普通函数和对象方法这两种区别在于上下文不一样，而构造函数与前两者区别更多，在参数处理、上下文、返回值上都有所区别。&lt;/p&gt;
&lt;p&gt;如果硬要类比于 Java 的函数方面，我觉得可以这么类比：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;     普通函数的调用 VS 公开权限的静态方法&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;     对象方法的调用 VS 对象的公开权限的方法&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;     构造函数的调用 VS 构造函数的调用&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;左边 JavaScript，右边 Java，具体实现细节很多不一样，但大体上可以这么类比理解。&lt;/p&gt;
&lt;h3 id=&quot;函数参数&quot;&gt;函数参数&lt;/h3&gt;
&lt;p&gt;参数分形参和实参两个概念，形参是定义时指定的参数列表，期望调用时函数所需传入的参数，实参是实际调用时传入的参数列表。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中，不存在 Java 里方法重载的场景，因为 JavaScript 不限制参数的个数，如果实参比形参多，多的省略，如果实参比形参少，少的参数值就是 undefined。&lt;/p&gt;
&lt;p&gt;这种特性让函数的用法变得很灵活，调用过程中，根据需要传入所需的参数个数。但同样的，也带来一些问题，比如调用时没有按照形参规定的参数列表来传入，那么函数体内部就要自己做相对应的处理，防止程序因参数问题而异常。&lt;/p&gt;
&lt;p&gt;同样需要处理的还有参数的类型，因为 JavaScript 是弱类型语言，函数定义时无需指定参数类型，但在函数体内部处理时，如果所期望的参数类型与传入的不一致，比如希望数组，传入的是字符串，这种类型不一致的场景JavaScript虽然会自动根据类型转换规则进行转换，但有时转换结果也不是我们所期望的。&lt;/p&gt;
&lt;p&gt;所以，有些时候，函数体内部除了要处理形参个数和实参个数不匹配的场景外，最好也需要处理参数的类型检查，来避免因类型错误而导致的程序异常。&lt;/p&gt;
&lt;h4 id=&quot;arguments&quot;&gt;arguments&lt;/h4&gt;
&lt;p&gt;函数也是个对象，当定义了一个函数后，它继承自 Function.prototype 原型，在这个原型中定义了所有函数共有的基础方法和属性，其中一个属性就是 arguments。&lt;/p&gt;
&lt;p&gt;这个属性是一个类数组对象，按数组序号顺序存储着实参列表，所以在函数内使用参数时，除了可以使用形参定义的变量，也可以使用 arguments。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function (x, y) {
    //x 和 arguments[0]等效
    console.log(x);
    console.log(arguments[0]);
    console.log(arguments[1]);
    console.log(arguments[2]);
}

a(5); //输出 5 5 undefined undefined
a(5, 4, 3); //输出 5 5 4 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，虽然函数定义时声明了三个参数，但使用的时候，并不一定需要传入三个，当传入的实参个数少于定义的形参个数时，相应形参变量对应的值为 undefined；&lt;/p&gt;
&lt;p&gt;相反，当传入实参个数超过形参个数时，可用 arguments 来取得这些参数使用。&lt;/p&gt;
&lt;h4 id=&quot;参数处理&quot;&gt;参数处理&lt;/h4&gt;
&lt;p&gt;因为函数不对参数个数、类型做限制，使用时可以传入任意数量的任意类型的实参，所以在函数内部通常需要做一些处理，大体上从三个方面进行考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;形参个数与实参个数不符时处理&lt;/li&gt;
&lt;li&gt;参数默认值处理&lt;/li&gt;
&lt;li&gt;参数类型处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面分别来讲讲：&lt;/p&gt;
&lt;h5 id=&quot;形参个数与实参个数不符时处理&quot;&gt;形参个数与实参个数不符时处理&lt;/h5&gt;
&lt;p&gt;通过 argument.length 可以获取实参的个数，通过函数属性 length 可以获取到形参个数，知道形参个数和实参个数就可以做一些处理。如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function (x) {
    if (arguments.length !== arguments.callee.length) {
        throw Error(&quot;...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码表示当传入的实参个数不等于形参个数时，抛异常。&lt;/p&gt;
&lt;p&gt;形参个数用：arguments.callee.length 获取，callee 是一个指向函数本身对象的引用。这里不能直接用 length 或 this.length，因为在函数调用一节说过，当以不同场景使用函数时，上下文 this 的值是不同的，不一定指向函数对象本身。&lt;/p&gt;
&lt;p&gt;在函数体内部要获取一个指向函数本身对象的引用有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数名&lt;/li&gt;
&lt;li&gt;arguments.callee&lt;/li&gt;
&lt;li&gt;作用域下的一个指向该函数的变量名&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;参数默认值处理&quot;&gt;参数默认值处理&lt;/h5&gt;
&lt;p&gt;通常是因为实参个数少于形参的个数，导致某些参数并没有被定义，函数内使用这些参数时，参数值将会是 undefined，为了避免会造成一些逻辑异常，可以做一些默认值处理。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function (x) {
    //根据形参实参个数做处理
    if (arguments.length !== arguments.callee.length) {
        throw Error(&quot;...&quot;);
    }
    //处理参数默认值
    x = x || &quot;default&quot;; // 等效于 if(x === undefined) x = &quot;default&quot;;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;参数类型处理&quot;&gt;参数类型处理&lt;/h5&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function (x) {
    //根据形参实参个数做处理
    if (arguments.length !== arguments.callee.length) {
        throw Error(&quot;...&quot;);
    }
    //处理参数默认值
    x = x || &quot;default&quot;; // 等效于 if(x === undefined) x = &quot;default&quot;;
    //参数类型处理
    if (Array.isArray(x)) {
        //...   
    }
    if (x instanceof Function) {
        //...   
    } 
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数类型的处理可能比较常见，通过各种辅助手段，确认所需的参数类型究竟是不是期望的类型。&lt;/p&gt;
&lt;h5 id=&quot;多个参数时将其封装在对象内&quot;&gt;多个参数时将其封装在对象内&lt;/h5&gt;
&lt;p&gt;当函数的形参个数比较多的时候，对于这个函数的调用是比较令人头疼的，因为必须要记住这么多参数，每个位置应该传哪个。这个时候，就可以通过将这些参数都封装到对象上，函数调用传参时，就不必关心各个参数的顺序，都添加到对象的属性中即可。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//函数用于复制原始数组指定起点位置开始的n个元素到目标数组指定的开始位置
function arrayCopy(fromArray, fromStart, toArray, toStart, length) {
    //...
}

//外部调用时，传入对象内只要有这5个属性即可，不必考虑参数顺序，同时这种方式也可以实现给参数设置默认值
function arrayCopyWrapper(args) {
    arrayCopy(args.fromArray,
                args.fromStart || 0, 
                args.toArray,
                args.toStart || 0,
                args.length);
}
arrayCopyWrapper({fromArray:[1,2,3], fromStart:0, toArray:a, length:3});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种方式相比第一种方式会更方便使用。&lt;/p&gt;
&lt;h3 id=&quot;函数特性&quot;&gt;函数特性&lt;/h3&gt;
&lt;p&gt;函数既是函数，也是对象。它拥有类似其他语言中函数的角色功能，同时，它本身也属于一个对象，同样拥有对象的相关功能。&lt;/p&gt;
&lt;p&gt;当作为函数来对待时，它的主要特性也就是函数的定义和调用：如何定义、如何调用、不同定义方式有和区别、不同调用方式适用哪些场景等等。&lt;/p&gt;
&lt;p&gt;而当作为对象来看待时，对象上的特性此时也就适用于这个函数对象，如：动态为其添加或删除属性、方法，作为值被传递使用等。&lt;/p&gt;
&lt;p&gt;所以，函数的参数类型也可以是函数，函数对象也可以拥有类型为函数的属性，此时称它为这个对象的方法。&lt;/p&gt;
&lt;p&gt;如果某些场景下，函数的每次调用时，函数体内部都需要一个唯一变量，此时通过给函数添加属性的方式，可以避免在全局作用域内定义全局变量，这是 Java 这类语言做不到的地方。&lt;/p&gt;
&lt;p&gt;类似需要跟踪函数每次的调用这种场景，就都可以通过对函数添加一些属性来实现。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function uniqueCounter() {
    return uniqueCounter.counter++;
}
uniqueCounter.counter = 0;

var a = uniqueCounter();  //a = 0;
var b = uniqueCounter();  //b = 1;
var c = uniqueCounter();  //c = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然定义全局变量的方式也可以实现，但容易污染全局空间的变量。&lt;/p&gt;
&lt;h3 id=&quot;函数属性&quot;&gt;函数属性&lt;/h3&gt;
&lt;p&gt;除了可动态对函数添加属性外，由于函数都是继承自 Function.prototype 原型，因此每个函数其实已经自带了一些属性，包括常用的方法和变量，比如上述介绍过的 arguments。&lt;/p&gt;
&lt;p&gt;这里就来学下，一个函数本身自带了哪些属性，不过函数比较特别，下面介绍的一些属性并没有被纳入标准规范中，但各大浏览器却都有实现，不过使用这类属性还是要注意下：&lt;/p&gt;
&lt;h4 id=&quot;arguments-1&quot;&gt;arguments&lt;/h4&gt;
&lt;p&gt;上述介绍过，这个属性是个类数组对象，用于存储函数调用时传入的实参列表。&lt;/p&gt;
&lt;p&gt;但有一点需要注意，在严格模式下，不允许使用这个属性了，这个变量被作为一个保留字了。&lt;/p&gt;
&lt;h4 id=&quot;length&quot;&gt;length&lt;/h4&gt;
&lt;p&gt;上述也提过，这个属性表示函数声明时的形参个数，也可以说是函数期望的参数个数。&lt;/p&gt;
&lt;p&gt;有一点也需要注意，在函数体内不能直接通过 length 或 this.length 来访问这个属性，因为函数会跟随着不同的调用方式有不同的上下文 this，并不一定都指向函数对象本身。&lt;/p&gt;
&lt;p&gt;而 arguments 对象中还有一个属性 callee，它指向当前正在执行的函数，在函数体内部可以通过 arguments.callee 来获取函数对象本身，然后访问它的 length 属性。&lt;/p&gt;
&lt;p&gt;在函数外部，就可以直接通过访问函数对象的属性方式直接获取 length。如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function (x, y) {
    console.log(arguments.length);
    console.log(arguments.callee.length);
}

a(1); // 输出 1 2，实参个数1个，形参个数2个
a.length;  //2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但需要注意一点，在严格模式下，函数体内部就不能通过 arguments.callee.length 来使用了。&lt;/p&gt;
&lt;h4 id=&quot;caller&quot;&gt;caller&lt;/h4&gt;
&lt;p&gt;caller 属性表示指向当前正在执行的函数的函数，也就是当前在执行的函数是在哪个函数内执行的。这个是非标准的，但大多浏览器都有实现。&lt;/p&gt;
&lt;p&gt;在严格模式下，不能使用。&lt;/p&gt;
&lt;p&gt;还有一点需要注意的是，有的书里是说这个 caller 属性是函数的参数对象 arguments 里的一个属性，但某些浏览器中，caller 是直接作为函数对象的属性。&lt;/p&gt;
&lt;p&gt;总之，arguments，caller，callee 这三个属性如果要使用的话，需要注意一下。&lt;/p&gt;
&lt;h4 id=&quot;name&quot;&gt;name&lt;/h4&gt;
&lt;p&gt;返回函数名，这个属性是 ES6 新增的属性，但某些浏览器在 ES6 出来前也实现了这个属性。即使不通过这个属性，也可以通过函数的 &lt;code&gt;toSring()&lt;/code&gt; 来获取函数名。&lt;/p&gt;
&lt;h4 id=&quot;bind&quot;&gt;bind()&lt;/h4&gt;
&lt;p&gt;用于将当前函数绑定至指定对象，也就是作为指定对象的方法存在。同时，这个函数会返回一个函数类型的返回值，所以通过 &lt;code&gt;bind()&lt;/code&gt; 方式，可以实现以函数调用的方式来调用对象的方法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function f(y) {
    return this.x + y;
}
var o = {x:1}

var g = f.bind(o);
g(2);  //输出 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时 g 虽然是个函数，但它表示的是对象 o 的方法 f，所以 &lt;code&gt;g()&lt;/code&gt; 这种形式虽然是函数调用，但实际上却是调用 o 对象的方法 f，所以方法 f 函数体中的 this 才会指向对象 o。&lt;/p&gt;
&lt;p&gt;另外，如果调用 &lt;code&gt;bind()&lt;/code&gt; 时传入了多个参数，第一个参数表示需要到的对象，剩余参数会被使用到当前函数的参数列表。&lt;/p&gt;
&lt;h4 id=&quot;prototype&quot;&gt;prototype&lt;/h4&gt;
&lt;p&gt;该属性名直译就是原型，当函数被当做构造函数使用时才有它的意义，用于当某个对象是从构造函数实例化出来的，那么这个对象会继承自这个构造函数的 prototype 所指向的对象。&lt;/p&gt;
&lt;p&gt;虽然这个属性的中文直译就是原型，但我不喜欢这么称呼它，因为原型应该是指从子对象的角度来看，它们继承的那个对象，称作它们的原型，因为原型就是类似于 Java 里父类的概念。&lt;/p&gt;
&lt;p&gt;虽然，子对象的原型确实由构造函数的 prototype 决定，但如果将这个词直接翻译成原型的话，那先来看下这样的一句表述：通过构造函数创建的新对象继承自构造函数的原型。&lt;/p&gt;
&lt;p&gt;没觉得这句话会有一点儿歧义吗？构造函数本质上也是一个对象，它也有继承结构，它也有它继承的原型，那么上面那句表述究竟是指新对象继承自构造函数的原型，还是构造函数的 prototype 属性值所指向的那个对象？&lt;/p&gt;
&lt;p&gt;所以，你可以看看，在我写的这系列文章中，但凡出现需要描述新对象的原型来源，我都是说，新对象继承自构造函数的 prototype 所指向的那个对象，我不对这个属性名进行直译，因为我觉得它会混淆我的理解。&lt;/p&gt;
&lt;p&gt;另外，在 prototype 指向的原型对象中添加的属性，会被所有从它关联的构造函数创建出来的对象所继承。所有，数组内置提供的一些属性方法、函数内置提供的相关属性方法，实际上都是在 Array.prototype 或 Function.prototype 中定义的。&lt;/p&gt;
&lt;h4 id=&quot;call-和-apply&quot;&gt;call() 和 apply()&lt;/h4&gt;
&lt;p&gt;这两个方法在函数调用一小节中介绍过了，因为在 JavaScript 中的函数的动态的，任意函数都可以作为任意对象的方法被调用，即使这个函数声明在其他对象中。此时，就需要通过间接调用实现，也就是通过 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一种很常见的应用场景，就是用于调用原型中的方法，类似于 Java 中的 super 调用父类的方法。因为子类可能重写了父类的方法，但有时又需要调用父类的方法，那么可通过这个实现。&lt;/p&gt;
&lt;h4 id=&quot;tostring&quot;&gt;toString()&lt;/h4&gt;
&lt;p&gt;Function.prototype 重写了 Object.prototype 中提供的 toString 方法，自定义的函数会通常会返回函数的完整源码，而内置的函数通常返回 [native code] 字符串。&lt;/p&gt;
&lt;p&gt;借助这个可以获取到自定义的函数名。&lt;/p&gt;
&lt;h3 id=&quot;嵌套函数&quot;&gt;嵌套函数&lt;/h3&gt;
&lt;p&gt;嵌套函数就是在函数体中继续定义函数，需要跟函数的方法定义区别开来。&lt;/p&gt;
&lt;p&gt;函数的方法定义，是将函数看成对象，定义它的属性，类型为函数，这个函数只是该函数对象的方法，并不是它的嵌套函数。&lt;/p&gt;
&lt;p&gt;而嵌套函数需要在函数体部分再用 function 定义的函数，这些函数称为嵌套函数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var x = 0;
var a = function () {
    var x = 1;
    function b() {
        console.log(x);
    }

    var c = function () {
        console.log(x);
    }

    b();  //输出：1
    c();  //输出：1
    a.d();//输出：0
}

a.d = function () {
    console.log(x);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数 b 和 c 是嵌套在函数 a 中的函数，称它们为嵌套函数。其实本质就是函数体内部的局部变量。&lt;/p&gt;
&lt;p&gt;函数 d 是函数 a 的方法。&lt;/p&gt;
&lt;p&gt;嵌套函数有些类似于 Java 中的非静态内部类，它们都可以访问外部的变量，Java 的内部类本质上是隐式的持有外部类的引用，而 JavaScript 的嵌套函数，其实是由于作用域链的生成规则形成了一个闭包，以此才能嵌套函数内部可以直接访问外部函数的变量。&lt;/p&gt;
&lt;p&gt;闭包涉及到了作用域链，而继承涉及到了原型链，这些概念后面会专门来讲述。&lt;/p&gt;
&lt;p&gt;这里稍微提下，闭包通俗点理解也就是函数将其外部的词法作用域包起来，以便函数内部能够访问外部的相关变量。&lt;/p&gt;
&lt;p&gt;通常有大括号出现都会有闭包，所以函数都会对应着一个闭包。&lt;/p&gt;
&lt;h3 id=&quot;高级应用场景&quot;&gt;高级应用场景&lt;/h3&gt;
&lt;p&gt;利用函数的特性、闭包特性、继承等，能够将函数应用到各种场景。&lt;/p&gt;
&lt;h4 id=&quot;使用函数作为临时命名空间&quot;&gt;使用函数作为临时命名空间&lt;/h4&gt;
&lt;p&gt;JavaScript 中的变量作用域大概就两种：全局作用域和函数内作用域，函数内定义的变量只能内部访问，外部无法访问。函数外定义的变量，任何地方均能访问。&lt;/p&gt;
&lt;p&gt;基于这点，为了保护全局命名空间不被污染，常常利用函数来实现一个临时的命名空间，两种写法：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a;
(function () {
    var a = 1;
    console.log(a);  //输出1
})();
console.log(a);  //输出undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单说就是定义一个函数，定义的同时末尾加上 () 顺便调用执行函数体内容，那么这个函数的作用其实也就是创建一个临时的命名空间，在函数体内部定义的变量不用担心与其他人起冲突。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;(function () {
   //...
}());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外层括号不能漏掉，末尾函数调用的括号也不能漏掉，这样就可以了，至于末尾的括号是放在外层括号内，还是外都可以。&lt;/p&gt;
&lt;h4 id=&quot;使用函数封装内部信息&quot;&gt;使用函数封装内部信息&lt;/h4&gt;
&lt;p&gt;闭包的特性，让 JavaScript 虽然没有类似 Java 的权限控制机制，但也能近似的模拟实现。&lt;/p&gt;
&lt;p&gt;因为函数内的变量外部访问不到，而函数又有闭包的特性，嵌套函数可以包裹外部函数的局部变量，那么外部函数的这些局部变量，只有在嵌套函数内可以访问，这样就可以实现对外隐藏内部一些实现细节。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var a = function () {
    var b = 1;
    return {
        getB: function () {
            return b;
        }
    }
}
console.log(c.b); //输出 undefined
var c = a();   //输出 1&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），公众号中有我的联系方式，欢迎有事没事来唠嗑一下，如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 13:52:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>声明 本系列文章内容全部梳理自以下几个来源： 《JavaScript权威指南》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/10061204.html</dc:identifier>
</item>
</channel>
</rss>