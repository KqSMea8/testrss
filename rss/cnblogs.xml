<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JeeSite中Excel导入导出 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9000288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9000288.html</guid>
<description>&lt;p&gt;　　在各种管理系统中，数据的导入导出是经常用到的功能，通常导入导出以Excel、CSV格式居多。如果是学习的过程中，最好是自己实现数据导入与导出的功能，然而在项目中，还是调用现成的功能比较好。近期一直使用一款名叫JeeSite的开源项目来进行二次开发，就记录一下该项目对于Excel导入导出数据的过程。JeeSite提供了很好的Excel的导入导出功能，隐藏了底层的很多实现，通过简单的套路式步骤即可完成数据的Excel数据的导入导出。对于没有使用过JeeSite的可以不用往下看了，因为下面的代码是跟JeeSite二次开发相关的代码，不做JeeSite的二次开发，以下代码对您无用，在这里友情提醒，避免浪费您宝贵的时间。&lt;/p&gt;

&lt;p&gt;导入导出步骤&lt;/p&gt;
&lt;p&gt;　　无论是JeeSite系统，还是其他的系统或者自己写的系统，对于数据导入导出功能而言，首先要确定的是导入导出哪些数据的字段，然后提供一个导入的模板，编写导入导出的功能，最后在页面上提供导入导出的操作方式来供使用者进行使用。&lt;/p&gt;

&lt;p&gt;定义导入导出字段&lt;/p&gt;
&lt;p&gt;　　在导入导出数据时会先确定要导入导出数据的哪些关键字段，在确定好字段之后，通过数据库查询出的数据根据字段逐个的导出，或者通过读取的Excel逐个的读入。在JeeSite中，确定要导入导出的字段以后，在JeeSite的实体类中可以通过注解来进行说明，注解方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @ExcelField(title=&quot;列名1&quot;, align=2, sort=10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样定义，就可以将类中的字段与Excel的列进行关联，包括列名称和排序。例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @ExcelField(title=&quot;名称&quot;, align=2, sort=10&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; @ExcelField(title=&quot;年龄&quot;, align=2, sort=20&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAge() {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在实体类的getter方法上添加@ExcelField注解，就完成了Excel列名称与实体类字段的关联。&lt;/p&gt;

&lt;p&gt;Excel数据导出功能&lt;/p&gt;
&lt;p&gt;　　对于JeeSite中的导出功能完全是套路，只要简单的3行就可以完成一个导出功能，首先设置导出文件名，接着查询导出数据，最后调用ExportExcel()来完成Excel的导出，例子代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @RequestMapping(value = &quot;export&quot;, method=&lt;span&gt;RequestMethod.POST)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String exportFile(Info info, HttpServletRequest request, HttpServletResponse response, RedirectAttributes redirectAttributes) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String fileName = &quot;信息数据&quot;+DateUtils.getDate(&quot;yyyyMMddHHmmss&quot;)+&quot;.xlsx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         // 调用获取数据的方法 ... 省略&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; ExportExcel(&quot;信息数据&quot;, Info.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).setDataList(page).write(response, fileName).dispose();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         addMessage(redirectAttributes, &quot;信息数据导出失败！失败信息：&quot;+&lt;span&gt;e.getMessage());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &quot;redirect:&quot; + adminPath + &quot;/info/Info/list?repage&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　return后的地址，根据实际的Controller来填写。&lt;/p&gt;

&lt;p&gt;导入模板&lt;/p&gt;
&lt;p&gt;　　导入模板是用来给系统使用者在导入数据时使用的，有了导入模板就相当于有了一个导入的规范，确定需要导入哪些列来让使用者填入。在JeeSite中，导入模板并不用事先提供一个Excel，而是通过代码直接生成一个Excel文件，Excel文件中的列也是由前面实体类中确定的，这样的好处是，当列的数量改变时不用人为的去替换修改Excel，因为它是有代码生成的。导入模板的代码例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @RequestMapping(value = &quot;import/template&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String importFileTemplate(HttpServletResponse response, RedirectAttributes redirectAttributes) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String fileName = &quot;信息数据导入模板.xlsx&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         List&amp;lt;Info&amp;gt; list =&lt;span&gt; Lists.newArrayList(); 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         list.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; ExportExcel(&quot;信息数据&quot;, Info.&lt;span&gt;class&lt;/span&gt;, 2&lt;span&gt;).setDataList(list).write(response, fileName).dispose();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         addMessage(redirectAttributes, &quot;导入模板下载失败！失败信息：&quot;+&lt;span&gt;e.getMessage());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &quot;redirect:&quot; + adminPath + &quot;/info/Info/list?repage&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此处return后的地址，也是根据实际的Controller来填写。&lt;/p&gt;

&lt;p&gt;Excel数据导入功能&lt;/p&gt;
&lt;p&gt;　　用户下载好数据模板后，将相应的数据填写好，就可以进行数据的导入了。数据的导入是对Excel中的数据不断进行遍历和保存的一个过程，代码虽然比导出要长，但是也完全是套路，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @RequestMapping(value = &quot;import&quot;, method=&lt;span&gt;RequestMethod.POST)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String importFile(MultipartFile file, RedirectAttributes redirectAttributes) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; successNum = 0;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导入成功计数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; failureNum = 0;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导入失败计数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         StringBuilder failureMsg = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         ImportExcel ei = &lt;span&gt;new&lt;/span&gt; ImportExcel(file, 1, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         List&amp;lt;Info&amp;gt; list = ei.getDataList(Info.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; ( Info info : list ) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( ... ) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导入条件的判断
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 符合导入条件
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存 ... 方法省略&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 successNum++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不符合导入条件&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 failureMsg.append(&quot;&amp;lt;br/&amp;gt;名字 &quot; + info.getName() + &quot; 已存在; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 failureNum++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (failureNum&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             failureMsg.insert(0, &quot;，失败 &quot; + failureNum + &quot; 条信息，导入信息如下：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         
&lt;span&gt;29&lt;/span&gt;         addMessage(redirectAttributes, &quot;已成功导入 &quot; + successNum + &quot; 条片区信息&quot; +&lt;span&gt; failureMsg);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &quot;redirect:&quot; + adminPath + &quot;/info/Info/list?repage&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;添加导入导出按钮&lt;/p&gt;
&lt;p&gt;　　在页面上添加两个按钮，分别是导入和导入按钮，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&quot;btns&quot;&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;input id=&quot;btnExport&quot; &lt;span&gt;class&lt;/span&gt;=&quot;btn btn-primary&quot; type=&quot;button&quot; value=&quot;导出&quot;/&amp;gt;
&lt;span&gt;3&lt;/span&gt;     &amp;lt;input id=&quot;btnImport&quot; &lt;span&gt;class&lt;/span&gt;=&quot;btn btn-primary&quot; type=&quot;button&quot; value=&quot;导入&quot;/&amp;gt;
&lt;span&gt;4&lt;/span&gt; &amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;导入时弹出的窗口&lt;/p&gt;
&lt;p&gt;　　在点击“导入”按钮时会弹出一个窗口，窗口中可以提供导入文件选择，也可以下载导入模板。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;div id=&quot;importBox&quot; &lt;span&gt;class&lt;/span&gt;=&quot;hide&quot;&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;form id=&quot;importForm&quot; action=&quot;${ctx}/info/Info/import&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;class&lt;/span&gt;=&quot;form-search&quot; style=&quot;padding-left:20px;text-align:center;&quot; onsubmit=&quot;loading('正在导入，请稍等...');&quot;&amp;gt;&amp;lt;br/&amp;gt;
&lt;span&gt;4&lt;/span&gt;         &amp;lt;input id=&quot;uploadFile&quot; name=&quot;file&quot; type=&quot;file&quot; style=&quot;width:330px&quot;/&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;　　
&lt;span&gt;5&lt;/span&gt;         &amp;lt;input id=&quot;btnImportSubmit&quot; &lt;span&gt;class&lt;/span&gt;=&quot;btn btn-primary&quot; type=&quot;submit&quot; value=&quot;   导    入   &quot;/&amp;gt;
&lt;span&gt;6&lt;/span&gt;         &amp;lt;a href=&quot;${ctx}/info/Info/import/template&quot;&amp;gt;下载模板&amp;lt;/a&amp;gt;
&lt;span&gt;7&lt;/span&gt;     &amp;lt;/form&amp;gt;
&lt;span&gt;8&lt;/span&gt; &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在代码中，需要修改action和href后的具体路径才能保证数据的提交，和模板下载的地址，具体地址根据自己项目中的Controller来进行替换。&lt;/p&gt;

&lt;p&gt;控制导入导出按钮的JS代码&lt;/p&gt;
&lt;p&gt;　　对于导出按钮来说，需要通过action来讲数据进行导出，对于导入按钮来说只是需要把导入时显示的窗口显示出来即可。相关代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;$(document).ready(function() {        
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     $(&quot;#btnExport&quot;&lt;span&gt;).click(function(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         top.$.jBox.confirm(&quot;确认要导出片区数据吗？&quot;,&quot;系统提示&quot;&lt;span&gt;,function(v,h,f){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(v==&quot;ok&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 $(&quot;#searchForm&quot;).attr(&quot;action&quot;,&quot;${ctx}/info/Info/export&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 $(&quot;#searchForm&quot;&lt;span&gt;).submit();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         },{buttonsFocus:1&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         top.$('.jbox-body .jbox-icon').css('top','55px'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     $(&quot;#btnImport&quot;&lt;span&gt;).click(function(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         $.jBox($(&quot;#importBox&quot;).html(), {title:&quot;导入数据&quot;, buttons:{&quot;关闭&quot;:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             bottomText:&quot;导入文件不能超过5M，仅允许导入“xls”或“xlsx”格式文件！&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　对于需要使用JeeSite开源项目进行二次开发的话，上面的代码算是一个比较详细的笔记了，如果不使用JeeSite开源项目的话，上面的代码就没有什么用处了。这篇笔记留个自己和需要的人吧。我还会陆续的发一些关于JeeSite的二次开发的笔记。&lt;/p&gt;

&lt;p&gt;注：我使用的JeeSite是3.X版本的，不是最新的JeeSite 4的版本。&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 15:16:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9000288.html</dc:identifier>
</item>
<item>
<title>使用LSTM和Softmx来进行意图识别 - ModifyBlog</title>
<link>http://www.cnblogs.com/ModifyRong/p/8546421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ModifyRong/p/8546421.html</guid>
<description>&lt;p&gt;&lt;span&gt;    在前面我们大致介绍了什么是意图识别，把这个问题抽象出来其实是一个分类问题。在结构上面，我们使用LSTM来提取特征,Softmax来进行最后的多分类。由于语料的限制，我们目前仅考虑电台,音乐，问答类等三类的意图识别。更多种类的意图识别, 其实也是把更多种类的语料加入进来，修改softmax的分类数。最后的目标是在这三类的分类准备率能够达到90%。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们将考虑使用 keras(严格意义上只能说是一个接口)来实现这个意图识别的工作。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;整体流程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666027/201805/666027-20180506221924367-1335179259.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;150&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图一 意图分类训练流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       我们整体的流程如图所示，首先是利用对语料语料进行预处理，包括去除语料的标点符号，去除停用词等等。将语料初始化以后便是利用word2vec生成词向量, 生成词向量以后便是利用LSTM来进行特征提取,最后便是利用softmax来完成我们的意图分类工作。整体流程非常的清晰。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;数据说明&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;        我们的数据有三个文件，一个是question.txt, 一个是music.txt, 一个是station.txt。我们展示一下数据的格式，大家按照如下结构组织训练即可，至于更多分类是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;music.txt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我想听千千阙歌
汪峰的歌曲&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;question.txt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;天为甚么这么蓝
中国有多大&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;station.txt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我要听郭德纲的相声
交通广播电台&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;语料预处理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       在语料预处理这块，我们的工作目前做的很粗糙，仅仅是将语料按照1:1:1的比例提取出来进行训练，这里有个问题大家可以思考一下，为什么我们在训练的时候要尽量使不同类别的数据按照1:1:1的比例来进行训练.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;生成词向量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       生成词向量的过程，是将语料从文字转化为数值，方便程序后续处理的过程。我们直接使用word2vec来进行训练的，至于word2Vec的原理，我们不在这里展开。在训练的时候，我们把所有一万五千条数据全部加入进行训练。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: UTF-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; gensim.models.word2vec &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Word2Vec
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; gensim.corpora.dictionary &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dictionary

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Embedding(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, dirname):
        self.dirname &lt;/span&gt;=&lt;span&gt; dirname

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; fname &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.listdir(self.dirname):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; open(os.path.join(self.dirname, fname)):
                &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; line.split()

 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;//&lt;span&gt; 训练word2vec模型
    sentences &lt;/span&gt;= Embedding(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../data/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; a memory-friendly iterator&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;代码的架构如下&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666027/201805/666027-20180506212736467-1113571601.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;107&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图二：多层LSTM提取特征,外接softmax 三分类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;150&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; yaml
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;reload(sys)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; sys.setdefaultencoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.cross_validation &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; multiprocessing
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; np_utils
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; gensim.models.word2vec &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Word2Vec
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; gensim.corpora.dictionary &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dictionary
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sequence
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.layers.embeddings &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Embedding
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.layers.recurrent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LSTM
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.layers.core &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense, Dropout,Activation
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model_from_yaml
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LabelEncoder
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; np.random.seed(1337)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; For Reproducibility&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; jieba
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; sys.setrecursionlimit(1000000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; set parameters:&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; vocab_dim = 100
&lt;span&gt; 27&lt;/span&gt; maxlen = 100
&lt;span&gt; 28&lt;/span&gt; n_iterations = 1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ideally more..&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; n_exposures = 10
&lt;span&gt; 30&lt;/span&gt; window_size = 7
&lt;span&gt; 31&lt;/span&gt; batch_size = 32
&lt;span&gt; 32&lt;/span&gt; n_epoch = 15
&lt;span&gt; 33&lt;/span&gt; input_length = 100
&lt;span&gt; 34&lt;/span&gt; cpu_count =&lt;span&gt; multiprocessing.cpu_count()
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载训练文件&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadfile():
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     fopen = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/question_query.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     questtion =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fopen:
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        question.append(line)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;     fopen = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/music_query.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     music =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fopen:
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        music.append(line)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;     fopen = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/station_query.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     station =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fopen:
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;        station.append(line)
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;     combined =&lt;span&gt; np.concatenate((station, music, qabot))
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     question_array = np.array([-1]*len(question),dtype=&lt;span&gt;int)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     station_array = np.array([0]*len(station),dtype=&lt;span&gt;int)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     music_array = np.array([1]*len(music),dtype=&lt;span&gt;int)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;y = np.concatenate((np.ones(len(station), dtype=int), np.zeros(len(music), dtype=int)),qabot_array[0])&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;     y =&lt;span&gt; np.hstack((qabot_array, station_array,music_array))
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y is:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; y.size
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;combines is:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; combined.size
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; combined, y
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对句子分词，并去掉换行符&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tokenizer(document):
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt; Simple Parser converting each document to lower-case, then
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        removing the breaks for new lines and finally splitting on the
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;        whitespace
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;text = [jieba.lcut(document.replace('\n', '')) for str(document) in text_list]&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     result_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; text &lt;span&gt;in&lt;/span&gt;&lt;span&gt; document:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         result_list.append(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(jieba.cut(text)).encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip())
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result_list
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建词语字典，并返回每个词语的索引，词向量，以及每个句子所对应的词语索引&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; create_dictionaries(model=&lt;span&gt;None,
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                         combined=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt; Function does are number of Jobs:
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        1- Creates a word to index mapping
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        2- Creates a word to vector mapping
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        3- Transforms the Training and Testing Dictionaries
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         4- 返回所有词语的向量的拼接结果
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (combined &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None) &lt;span&gt;and&lt;/span&gt; (model &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None):
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         gensim_dict =&lt;span&gt; Dictionary()
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        gensim_dict.doc2bow(model.wv.vocab.keys(),
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                             allow_update=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         w2indx = {v: k+1 &lt;span&gt;for&lt;/span&gt; k, v &lt;span&gt;in&lt;/span&gt; gensim_dict.items()}&lt;span&gt;#&lt;/span&gt;&lt;span&gt;所有频数超过10的词语的索引&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         w2vec = {word: model[word] &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; w2indx.keys()}&lt;span&gt;#&lt;/span&gt;&lt;span&gt;所有频数超过10的词语的词向量&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;   
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse_dataset(combined):
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;'''&lt;/span&gt;&lt;span&gt; Words become integers
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;             data=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; sentence &lt;span&gt;in&lt;/span&gt;&lt;span&gt; combined:
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 new_txt =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 sentences = sentence.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sentences:
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 word = unicode(word, errors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ignore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                        new_txt.append(w2indx[word])
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                     &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                        new_txt.append(0)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                data.append(new_txt)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         combined=&lt;span&gt;parse_dataset(combined)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         combined= sequence.pad_sequences(combined, maxlen=maxlen)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每个句子所含词语对应的索引，所以句子中含有频数小于10的词语，索引为0&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; w2indx, w2vec,combined
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No data provided...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建词语字典，并返回每个词语的索引，词向量，以及每个句子所对应的词语索引&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; word2vec_train(combined):
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载word2vec 模型&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;     model = Word2Vec.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstm_data/model/Word2vec_model.pkl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     index_dict, word_vectors,combined = create_dictionaries(model=model,combined=&lt;span&gt;combined)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;   index_dict, word_vectors,combined
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_data(index_dict,word_vectors,combined,y):
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取句子的向量&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;     n_symbols = len(index_dict) + 1                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所有单词的索引数，频数小于10的词语索引为0，所以加1&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;     embedding_weights = np.zeros((n_symbols, vocab_dim))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;索引为0的词语，词向量全为0&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; word, index &lt;span&gt;in&lt;/span&gt; index_dict.items():                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从索引为1的词语开始，对每个词语对应其词向量&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;         embedding_weights[index, :] =&lt;span&gt; word_vectors[word]
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;     x_train, x_test, y_train, y_test = train_test_split(combined, y, test_size=0.2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; encode class values as integers&lt;/span&gt;
&lt;span&gt;133&lt;/span&gt;     encoder =&lt;span&gt; LabelEncoder()
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;     encoded_y_train =&lt;span&gt; encoder.fit_transform(y_train)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     encoded_y_test =&lt;span&gt; encoder.fit_transform(y_test)
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; convert integers to dummy variables (one hot encoding)&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;     y_train =&lt;span&gt; np_utils.to_categorical(encoded_y_train)
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     y_test =&lt;span&gt; np_utils.to_categorical(encoded_y_test)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; x_train.shape,y_train.shape
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n_symbols,embedding_weights,x_train,y_train,x_test,y_test
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#定义网络结构&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train_lstm(n_symbols,embedding_weights,x_train,y_train,x_test,y_test):
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;     nb_classes = 3
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Defining a Simple Keras Model...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 定义基本的网络结构&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;     model = Sequential()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; or Graph or whatever&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 对于LSTM 变长的文本使用Embedding 将其变成指定长度的向量&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt;     model.add(Embedding(output_dim=&lt;span&gt;vocab_dim,
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                         input_dim=&lt;span&gt;n_symbols,
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                         mask_zero=&lt;span&gt;True,
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                         weights=&lt;span&gt;[embedding_weights],
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                         input_length=input_length))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Adding Input Length&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 使用单层LSTM 输出的向量维度是50，输入的向量维度是vocab_dim,激活函数relu&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;     model.add(LSTM(output_dim=50, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, inner_activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hard_sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;     model.add(Dropout(0.5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 在这里外接softmax，进行最后的3分类&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;     model.add(Dense(output_dim=nb_classes, input_dim=50, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Compiling the Model...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 激活函数使用的是adam&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;     model.compile(loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                   optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; 
&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Train...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; y_train
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;     model.fit(x_train, y_train, batch_size=batch_size, nb_epoch=n_epoch,verbose=1, validation_data=&lt;span&gt;(x_test, y_test))
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Evaluate...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt;     score =&lt;span&gt; model.evaluate(x_test, y_test,
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                                 batch_size=&lt;span&gt;batch_size)
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;     yaml_string =&lt;span&gt; model.to_yaml()
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstm_data/lstm_koubei.yml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as outfile:
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;         outfile.write( yaml.dump(yaml_string, default_flow_style=&lt;span&gt;True) )
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     model.save_weights(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstm_data/lstm_koubei.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test score:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, score
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型，并保存&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train():
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Loading Data...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;     combined,y=&lt;span&gt;loadfile()
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; len(combined),len(y)
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tokenising...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;     combined =&lt;span&gt; tokenizer(combined)
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Training a Word2vec model...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;     index_dict, word_vectors,combined=&lt;span&gt;word2vec_train(combined)
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Setting up Arrays for Keras Embedding Layer...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;     n_symbols,embedding_weights,x_train,y_train,x_test,y_test=&lt;span&gt;get_data(index_dict, word_vectors,combined,y)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; x_train.shape,y_train.shape
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;    train_lstm(n_symbols,embedding_weights,x_train,y_train,x_test,y_test)&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt; 
&lt;span&gt;191&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型，并保存&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; self_train():
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Loading Data...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt;     combined,y=&lt;span&gt;loadfile()
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; len(combined),len(y)
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tokenising...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;     combined =&lt;span&gt; tokenizer(combined)
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Training a Word2vec model...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;     index_dict, word_vectors,combined=&lt;span&gt;word2vec_train(combined)
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Setting up Arrays for Keras Embedding Layer...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;     n_symbols,embedding_weights,x_train,y_train,x_test,y_test=&lt;span&gt;get_data(index_dict, word_vectors,combined,y)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; x_train.shape,y_train.shape
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;    train_lstm(n_symbols,embedding_weights,x_train,y_train,x_test,y_test)
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;span&gt;205&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; input_transform(string):
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;     words=&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(jieba.cut(string)).encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     tmp_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;    tmp_list.append(words)
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;words=np.array(tmp_list).reshape(1,-1)&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;     model=Word2Vec.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstm_data/model/Word2vec_model.pkl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;     _,_,combined=&lt;span&gt;create_dictionaries(model,tmp_list)
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; combined&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;br/&gt;&lt;span&gt;249&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;     self_train()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;修改网络结构 &lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    我们使用LSTM单层网络结构，在迭代15 次以后训练准确率已经可以达到96%以上。进一步思考一下，叠加LSTM网络，是否可以达到更高的训练准确率，其他的部分不变，我们仅仅修改我们的网络定义部分&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#定义网络结构&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train_lstm(n_symbols,embedding_weights,x_train,y_train,x_test,y_test):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     nb_classes = 3
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Defining a Simple Keras Model...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     model = Sequential()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; or Graph or whatever&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     model.add(Embedding(output_dim=&lt;span&gt;vocab_dim,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                         input_dim=&lt;span&gt;n_symbols,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                         mask_zero=&lt;span&gt;True,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         weights=&lt;span&gt;[embedding_weights],
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                         input_length=input_length))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Adding Input Length&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; vocab_dim
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; n_symbols
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;model.add(LSTM(output_dim=50, activation='relu',inner_activation='hard_sigmoid'))&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;model.add(LSTM(output_dim=25, activation='relu', return_sequences=True))&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     model.add(LSTM(64, input_dim=vocab_dim, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, return_sequences=&lt;span&gt;True))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     model.add(LSTM(32, return_sequences=&lt;span&gt;True))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     model.add(Dropout(0.5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;model.add(Dense(nb_classes))&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;model.add(Activation('softmax'))&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; model.summary()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    model.add(NonMasking())
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    model.add(Flatten())
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     model.add(Dense(output_dim=nb_classes, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Compiling the Model...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     model.compile(loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                   optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Train...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; y_train
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     model.fit(x_train, y_train, batch_size=batch_size, nb_epoch=n_epoch,verbose=1, validation_data=&lt;span&gt;(x_test, y_test))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Evaluate...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     score =&lt;span&gt; model.evaluate(x_test, y_test,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                                 batch_size=&lt;span&gt;batch_size)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     yaml_string =&lt;span&gt; model.to_yaml()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstm_data/lstm_koubei.yml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as outfile:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         outfile.write( yaml.dump(yaml_string, default_flow_style=&lt;span&gt;True) )
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     model.save_weights(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lstm_data/lstm_koubei.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test score:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, score&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们发现同样迭代15次，训练准确率可以达到97%左右。说明叠加LSTM网络结构确实是有效的，能够更好的抓取训练语料的特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;训练反思与总结 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     目前，我们仅仅可以说做了一个意图识别的demo，已经可以达到比较高的训练准确率，但是我们还有很多方面改进。第一也是最直观的是我们目前的训练语料还很少，并且训练的类别也比较少，我们希望在保持训练准确率的前提下，训练的语料可以更多，训练的类别更多。第二对语料的预处理做的非常的粗糙，没有去除停用词，没有去除标点符号等等，我们这里没有做的原因是我们的训练语料是比较干净所以就没有进行处理了。第三个是我们目前分词的算法是非常的粗糙，使用的结巴分词默认的词库进行分词。分词的词库没有匹配我们领域知识。第四我们还希望使用CNN来对比一下抽取的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     但是大家可以看到深度学习在自然语言处理当中巨大的威力，我们不用辛辛苦苦的去提取unigram,bigram等等特征，使用embeding的方法来描述文本，节省了大量人工，并且训练的准确率远超过我们的预期。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 14:47:00 +0000</pubDate>
<dc:creator>ModifyBlog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ModifyRong/p/8546421.html</dc:identifier>
</item>
<item>
<title>手把手教你用Jenkins自动发布dotnet core程序 - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/9000143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/9000143.html</guid>
<description>&lt;p&gt;首先,我们要有个Jenkins咯,下载链接:&lt;a href=&quot;https://jenkins.io/download/&quot; class=&quot;uri&quot;&gt;https://jenkins.io/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们安装官网教程安装好jenkins,安装教程略....&lt;/p&gt;
&lt;p&gt;嗯?不是说好手把手么?你妹的.&lt;/p&gt;
&lt;p&gt;好好好,我们还是来手把手教程好了.&lt;/p&gt;
&lt;h2 id=&quot;首先安装jdk8&quot;&gt;首先安装JDK8&lt;/h2&gt;
&lt;p&gt;添加安装源之后直接apt-get install就好,下面是ubuntu的安装命令,其他系统自己玩一下就好.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; add-apt-repository ppa:webupd8team/java

&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get update

&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install oracle-java8-installer&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;下载jenkins.war-启动jenkins&quot;&gt;下载jenkins.war + 启动Jenkins&lt;/h2&gt;
&lt;p&gt;下载链接:&lt;a href=&quot;http://mirrors.jenkins.io/war-stable/&quot; class=&quot;uri&quot;&gt;http://mirrors.jenkins.io/war-stable/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这里面找最新的下载,我当前最新的应该是&lt;a href=&quot;http://mirrors.jenkins.io/war-stable/2.107.2/jenkins.war&quot;&gt;2.107.2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载好了jenkins.war之后,在当前目录创建一个jenkins-home文件夹,设置JENKINS_HOME环境变量为jenkins-home(不设置也可以,默认在~/.jenkins)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;wget&lt;/span&gt; http://mirrors.jenkins.io/war-stable/2.107.2/jenkins.war&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; ~/jenkins-home&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;JENKINS_HOME=&lt;/span&gt;~/jenkins-home;
&lt;span class=&quot;kw&quot;&gt;tmux;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;java&lt;/span&gt; -jar jenkins.war&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般建议开个后台进程来跑jenkins,免得终端退出之后jenkins就死掉了.&lt;/p&gt;
&lt;p&gt;所以上面我先打开了tmux之后再跑java -jar jenkins.war.&lt;/p&gt;
&lt;p&gt;如下图:&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%886.53.24.png&quot; alt=&quot;jenkins启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着留意一下initialAdminPassword的输出&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt;
Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

XXXXXXXXXXXXXX

This may also be found at: /root/jenkins-home/secrets/initialAdminPassword&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候访问当前主机的8080端口已经可以看到jenkins正在启动了,稍等片刻就可以看到jenkins登录页.&lt;/p&gt;
&lt;p&gt;这个时候把上面的XXXXXXXXXXXXXX复制出来,输进去点击继续配置jenkins账号密码信息之类的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%886.58.58.png&quot; alt=&quot;配置jenkins&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着安装默认插件.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%887.00.12.png&quot; alt=&quot;安装插件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里估计也要等几分钟不等,看你的机器性能和网络速度.&lt;/p&gt;
&lt;p&gt;安装好了之后会进入配置登录账号密码,安装提示配置就完事.&lt;/p&gt;
&lt;p&gt;最后进入jenkins页面是这样的.&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%887.02.42.png&quot; alt=&quot;jenkins&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到现在我们已经把jenkins跑起来了,也有了一些常用的插件.&lt;/p&gt;
&lt;p&gt;我们先去把dotnet core docker 编译发布相关的东西弄好之后再回来继续做jenkins任务.&lt;/p&gt;
&lt;h2 id=&quot;dotnet-core-docker-打包&quot;&gt;dotnet core docker 打包&lt;/h2&gt;
&lt;p&gt;在项目目录下新建Dockerfile文件,内容如下:&lt;/p&gt;
&lt;pre class=&quot;docker&quot;&gt;
&lt;code&gt;
FROM microsoft/aspnetcore-build:2.0 AS build-env
WORKDIR /app

# copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out

# build runtime image
FROM microsoft/aspnetcore:2.0
WORKDIR /app
COPY --from=build-env /app/out .
ENTRYPOINT [&quot;dotnet&quot;, &quot;你的dotnet core程序.dll&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Dockerfile基本就是把当前目录的文件拷贝到aspnetcore-build镜像中,再里面编译好之后再发布到aspnetcore:2.0镜像中,&lt;/p&gt;
&lt;p&gt;最后指定运行你的dotnet core程序&lt;/p&gt;
&lt;p&gt;来源:&lt;a href=&quot;https://github.com/DaoCloud/dotnet-docker-samples&quot; class=&quot;uri&quot;&gt;https://github.com/DaoCloud/dotnet-docker-samples&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-build-run-脚本非必须可以使用jenkins中脚本编译替代&quot;&gt;docker build + run 脚本(非必须,可以使用jenkins中脚本编译替代)&lt;/h2&gt;
&lt;p&gt;以&lt;a href=&quot;https://github.com/liguobao/58HouseSearch/blob/master/HouseCrawler.Core/HouseCrawler.Web/&quot;&gt;HouseCrawler.Web&lt;/a&gt;为例,&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;
&lt;span class=&quot;co&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;image_version=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;`date&lt;/span&gt; +%Y%m%d%H%M&lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$image_version&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~/code/58HouseSearch/HouseCrawler.Core/HouseCrawler.Web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; pull --rebase origin master&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; stop house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; rm house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; build -t house-web:&lt;span class=&quot;ot&quot;&gt;$image_version&lt;/span&gt; .&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -p 8080:80 -v ~/docker-data/house-web/appsettings.json:/app/appsettings.json -v ~/docker-data/house-web/NLogFile/:/app/NLogFile  --restart=always --name house-web -d house-web:&lt;span class=&quot;ot&quot;&gt;$image_version&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; logs house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面这个build+run脚本,我们已经把dotnet core程序编译好了,并且打包成了docker images,还直接跑起来了.&lt;/p&gt;
&lt;p&gt;但是我们想要的应该是自动化编译部署,而且上面我们都把jenkins跑起来了,所以....&lt;/p&gt;
&lt;h2 id=&quot;jenkins-job配置&quot;&gt;jenkins job配置&lt;/h2&gt;
&lt;h3 id=&quot;新建job&quot;&gt;新建Job&lt;/h3&gt;
&lt;p&gt;打开jenkins首页,左侧选择&quot;新建任务&quot;(newJob),如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.10.00.png&quot; alt=&quot;newJob&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给新的job取个名字,然后选择&quot;构建自由风格的软件项目&quot;,如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.12.27.png&quot; alt=&quot;构建自由风格的软件项目&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加源码仓库&quot;&gt;添加源码仓库&lt;/h3&gt;
&lt;p&gt;确认之后进入Job配置页面,源码管理里面选择git,如图:&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.14.06.png&quot; alt=&quot;源码管理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果git仓库是需要权限的话需要配置一下权限,我一般简单粗暴直接把jenkins主机的公钥添加到git仓库里面,所以这里直接配置成'From the Jenkins master ~/.ssh',也可以用账号密码访问等等的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.16.09.png&quot; alt=&quot;git仓库权限配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&quot;Branch Specifier (blank for 'any') &quot;默认master分支,根据自己的需求填入不同的分支.&lt;/p&gt;
&lt;p&gt;构建触发器和构建环境先跳过,我们不管,待会弄.&lt;/p&gt;
&lt;h3 id=&quot;构建&quot;&gt;构建&lt;/h3&gt;
&lt;p&gt;点击&quot;添加构建步骤&quot;,选择&quot;Execute shell&quot;,然后能看到如下图:&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.22.45.png&quot; alt=&quot;Execute shell&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还记得我们上一步的脚本么?修改一下源码路径再放进去.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 切换到源码目录,对应在jenkins-home的workspace下面&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~jenkins-home/workspace/项目名称/Dockerfile所在目录&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;image_version=&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;`date&lt;/span&gt; +%Y%m%d%H%M&lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$image_version&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 停止之前的docker container&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; stop house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 删除这个container&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; rm house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# build镜像并且打上tag&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; build -t house-web:&lt;span class=&quot;ot&quot;&gt;$image_version&lt;/span&gt; .&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 把刚刚build出来的镜像跑起来&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -p 8080:80 -v ~/docker-data/house-web/appsettings.json:/app/appsettings.json -v ~/docker-data/house-web/NLogFile/:/app/NLogFile  --restart=always --name house-web -d house-web:&lt;span class=&quot;ot&quot;&gt;$image_version&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; logs house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果jenkins主机和程序运行主机不在一台机器上,建议直接在把上面的脚本放在运行主机上,命名成 start_XXX.sh.&lt;/p&gt;
&lt;p&gt;上面的命令直接就是成了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ssh&lt;/span&gt; username@发布主机的IP &lt;span class=&quot;st&quot;&gt;'~/start_XXX.sh'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ps:记得在jenkins主机配置&lt;a href=&quot;https://blog.csdn.net/wind520/article/details/38421359&quot;&gt;ssh免登陆&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;构建触发器&quot;&gt;构建触发器&lt;/h3&gt;
&lt;p&gt;构建触发器就是我们选择什么时候来触发构建任务,有几种方案可以做.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 Build periodically,定时 or 隔N久去拉一次代码构建&lt;/li&gt;
&lt;li&gt;Poll SCM：定时检查源码变更（根据SCM软件的版本号）,如果有变化就去执行构建&lt;/li&gt;
&lt;li&gt;GitHub hook trigger for GITScm polling 或者其他Git平台提供的webhook&lt;/li&gt;
&lt;li&gt;安装Generic Webhook Trigger插件之后,使用其他平台的webhook来触发构建任务.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我这里选择第4种方案,安装Generic Webhook Trigger插件,下面马上回告诉你为什么这样做的.&lt;/p&gt;
&lt;p&gt;Generic Webhook Trigger插件在&quot;系统管理-管理插件-可选插件&quot;里面直接搜&quot;Generic Webhook Trigger&quot;安装就可以.&lt;/p&gt;
&lt;p&gt;从上一步的构建步骤里面的脚本中我们就知道,其实我们现在要不就在jenkins主机上docker build,要不就在发布目标主机上build,&lt;/p&gt;
&lt;p&gt;build过程比较慢而且还会产生镜像在本机or目标主机上,docker images也没有被管理起来.&lt;/p&gt;
&lt;p&gt;有什么好的办法么?嗯,还真有.直接用阿里云&quot;容器镜像服务&quot;来构建镜像&lt;/p&gt;
&lt;h3 id=&quot;使用阿里云-容器镜像服务&quot;&gt;使用阿里云-容器镜像服务&lt;/h3&gt;
&lt;p&gt;首先登录阿里云,然后进入容器镜像服务,地址是&lt;a href=&quot;https://cr.console.aliyun.com/&quot; class=&quot;uri&quot;&gt;https://cr.console.aliyun.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首次进入估计需要创建一个命名空间,一般用公司名或者你的名字就完事.&lt;/p&gt;
&lt;p&gt;接着选择&quot;创建镜像仓库&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.51.25.png&quot; alt=&quot;创建镜像仓库&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选地区-选命名空间-填仓库名称(就是镜像名称)-填摘要-设置代码源(支持GitHub/阿里云code/Bitbucket/私有Gitlab/本地Git等等,给个授权就完事)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.54.10.png&quot; alt=&quot;选地区&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建设置选择&quot;代码变更时自动构建镜像&quot;,然后选一下构建分支为你想要的分支,填入Dockerfile在源码中的路径,然后保存&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%889.57.50.png&quot; alt=&quot;构建分支&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们进入管理平台看一下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.00.51.png&quot; alt=&quot;aliyun-构建&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击一下&quot;立即构建&quot;,然后查看一下日志.&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.02.00.png&quot; alt=&quot;build 日志&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.02.49.png&quot; alt=&quot;构建成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候,我们用docker pull registry-internal.cn-hangzhou.aliyuncs.com/你的命名空间/你的镜像名称 就可以拉到这个阿里云build成功的镜像了.&lt;/p&gt;
&lt;p&gt;镜像build的问题解决了,那么我们怎么自动把镜像发布到我们的运行主机呢?&lt;/p&gt;
&lt;p&gt;这时候webhook又出来了.&lt;/p&gt;
&lt;h3 id=&quot;jenkins-webhook触发配置&quot;&gt;jenkins webhook触发配置&lt;/h3&gt;
&lt;p&gt;我们看阿里云镜像构建服务里面,有一项是webhook的,官方介绍在这里:&lt;a href=&quot;https://help.aliyun.com/document_detail/60949.html?spm=5176.8351553.0.0.645319912fjxim&quot;&gt;阿里云-webhook管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.08.45.png&quot; alt=&quot;阿里云-webhook管理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就需要填入我们的webhook地址,还记得前面我无端端选择的第四种方案,然后让大家跟着安装的Generic Webhook Trigger插件么?&lt;/p&gt;
&lt;p&gt;我们就是用这货来为我们提供webhook API.&lt;/p&gt;
&lt;p&gt;理一下流程:&lt;/p&gt;
&lt;p&gt;git仓库代码变化 -&amp;gt;阿里云容器构建服务启动 -&amp;gt; 构建好镜像之后触发webhook -&amp;gt; jenkins收到阿里云的webhook之后触发job执行部署脚本 -&amp;gt;部署脚本使用阿里云镜像run起来 -&amp;gt;完事.&lt;/p&gt;
&lt;p&gt;我们继续配置Generic Webhook Trigger.&lt;/p&gt;
&lt;p&gt;Generic Webhook Trigger支持的命名触发URL格式是这样的:&lt;/p&gt;
&lt;pre class=&quot;http&quot;&gt;
&lt;code&gt;http://jenkins登录用户名:token授权码@jenkins IP:8080/generic-webhook-trigger/invoke?token=触发器名称&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jenkins登录名和token在&quot;账号-设置-API Token-Show API Token...&quot;里面能看到,找出来之后填到上面去就可以.&lt;/p&gt;
&lt;p&gt;最后一个token参数其实就是&quot;构建触发器&quot;中&quot;触发远程构建&quot;的参数,建议使用job名字.这里的配置大概是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.21.13.png&quot; alt=&quot;触发远程构建&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们还需要在jenkins全局安全设置中取消勾选“防止跨站点请求伪造（Prevent Cross Site Request Forgery exploits)&quot;选项,这样阿里云webhook才能过得来.&lt;/p&gt;
&lt;p&gt;手动在浏览器中访问一下http://jenkins登录用户名:&lt;a href=&quot;mailto:token授权码@jenkins&quot;&gt;token授权码@jenkins&lt;/a&gt; IP:8080/generic-webhook-trigger/invoke?token=触发器名称&lt;br/&gt;如果对应的jenkins Job能正常开始执行,说明整个流程已经ok了.&lt;/p&gt;
&lt;p&gt;最后我们回到上面&quot;阿里云-容器镜像服务-对应镜像仓库-webhook-添加记录&quot;&lt;br/&gt;&lt;img src=&quot;http://7xrayk.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.27.02.png&quot; alt=&quot;webhook-添加记录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS:webhook名称不要带特殊字符or &quot;-&quot;之类的,不然一直保存失败而且还不会提示你是因为名字不合法,下午被这个坑了半个小时.&lt;/p&gt;
&lt;p&gt;到这里,我们基本大功告成了.&lt;/p&gt;
&lt;p&gt;最后我们再改一下jenkins的脚本,不在本地build docker了,直接拿阿里云镜像服务构建出来的镜像跑就可以.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 停止之前的docker container&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; stop house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 删除这个container&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; rm house-web&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; pull 你的阿里云镜像地址&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 把刚刚build出来的镜像跑起来&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run --restart=always --name 你的contianer名称 你的阿里云镜像地址&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;总结一下我们做了什么&quot;&gt;总结一下我们做了什么&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;搭建jenkins&lt;/li&gt;
&lt;li&gt;编写Dockerfile文件,直接编译发布+打包成docker镜像+部署脚本&lt;/li&gt;
&lt;li&gt;使用阿里云-容器构建服务构建docker镜像,构建成功后使用webhook通知jenkins&lt;/li&gt;
&lt;li&gt;配置jenkins webhook触发器,触发部署脚本&lt;/li&gt;
&lt;li&gt;完事...&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 06 May 2018 14:39:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/9000143.html</dc:identifier>
</item>
<item>
<title>Java内存模型与指令重排 - 大道方圆</title>
<link>http://www.cnblogs.com/xdecode/p/8948277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/8948277.html</guid>
<description>&lt;p&gt;本文暂不讲JMM(Java Memory Model)中的主存, 工作内存以及数据如何在其中流转等等,&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些本身还牵扯到硬件内存架构, &lt;/span&gt;&lt;span&gt;直接上手容易绕晕, 先&lt;/span&gt;从以下几个点探索JMM&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有序性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可见性&lt;/li&gt;
&lt;li&gt;指令重排
&lt;ul&gt;&lt;li&gt;CPU指令重排&lt;/li&gt;
&lt;li&gt;编译器优化重排&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Happen-Before规则&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;原子性是指一个操作是不可中断的. 即使是在多个线程一起执行的时候，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个操作一旦开始，就不会被其它线程干扰. &lt;/strong&gt;例如CPU中的一些指令, 属于原子性的,&lt;/p&gt;
&lt;p&gt;又或者变量直接赋值操作(i = 1),, 也是原子性的 即使有多个线程对i赋值, 相互也不会干扰.&lt;/p&gt;
&lt;p&gt;而如i++, 则不是原子性的, 因为他实际上i = i + 1, 若存在多个线程操作i, 结果将不可预期.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180506210812001-1855659578.png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;有序性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有序性是指在单线程环境中, 程序是按序依次执行的.&lt;/p&gt;
&lt;p&gt;而在多线程环境中, 程序的执行可能因为指令重排而出现乱序, 下文会有详细讲述.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderExample {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; a = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writer() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 以下两句执行顺序可能会在指令重排等场景下发生变化&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt; 7&lt;/span&gt;             a = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reader() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; i = a + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                ……
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201804/1285727-20180427001805861-1545078440.jpg&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;可见性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改.&lt;/p&gt;
&lt;p&gt;会有多种场景影响到可见性:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU指令重排&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多条汇编指令执行时, 考虑性能因素, 会导致执行乱序, 下文会有详细讲述.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬件优化&lt;/strong&gt;（如写吸收，批操作）&lt;/p&gt;
&lt;p&gt;cpu2修改了变量T, 而cpu1却从高速缓存cache中读取了之前T的副本, 导致数据不一致.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180503234458138-1727120494.jpg&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译器优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是Java虚拟机层面的可见性, 下文会有详细讲述.&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;指令重排&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;指令重排是指在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序.&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;CPU指令重排&lt;/h4&gt;
&lt;p&gt;一条汇编指令的执行是可以分为很多步骤的, 分为不同的硬件执行&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取指 IF&lt;/li&gt;
&lt;li&gt;译码和取寄存器操作数 ID&lt;/li&gt;
&lt;li&gt;执行或者有效地址计算 EX (ALU逻辑计算单元)&lt;/li&gt;
&lt;li&gt;存储器访问 MEM&lt;/li&gt;
&lt;li&gt;写回 WB (寄存器)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然指令可以被分解为很多步骤, 那么多条指令就不一定依次序执行.&lt;/p&gt;
&lt;p&gt;因为每次只执行一条指令, 依次执行效率太低了, 假设上述每一个步骤都要消耗一个时钟周期, &lt;/p&gt;
&lt;p&gt;那么依次执行的话, 一条指令要5个时钟周期, 两条指令要占用10个时钟周期, 三条指令消耗15个时钟.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180506221649503-1022752155.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;112&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如果硬件空闲即可执行下一步, 类似于工厂中的流水线, 一条指令要5个时钟周期, &lt;/p&gt;
&lt;p&gt;两条指令只需要6个时钟周期, 因为是错位流水执行, 三条指令消耗7个时钟.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180502235149335-562215859.jpg&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子 A = B + C, 需要如下指令&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指令1 : 加载B到寄存器R1中&lt;/li&gt;
&lt;li&gt;指令2 : 加载C到寄存器R2中&lt;/li&gt;
&lt;li&gt;指令3 : 将R1与R2相加, 得到R3&lt;/li&gt;
&lt;li&gt;指令4 : 将R3赋值给A&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意下图红色框选部分, 指令1, 2独立执行, 互不干扰.&lt;/p&gt;
&lt;p&gt;指令3依赖于指令1, 2加载结果, 因此红色框选部分表示在等待指令1, 2结束.&lt;/p&gt;
&lt;p&gt;待指令1, 2都已经走完MEM部分, 数据加载到内存后, 指令3继续执行计算EX.&lt;/p&gt;
&lt;p&gt;同理指令4需要等指令3计算完, 才可以拿到R3, 因此也需要错位等待.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180503000137100-174664797.jpg&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;218&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看一个复杂的例子&lt;/p&gt;
&lt;p&gt;a = b + c&lt;/p&gt;
&lt;p&gt;d = e - f&lt;/p&gt;
&lt;p&gt;具体指令执行步骤如图, 不再赘述, 与上图类似, 在执行过程中同样会出现等待.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180503000816520-1448656185.jpg&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这边框选的X统称一个气泡, 有没有什么方案可以削减这类气泡呢.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案自然是可以的, 我们可以在出现气泡之前, 执行其他不相干指令来减少气泡.&lt;/p&gt;
&lt;p&gt;例如可以将第五步的加载e到寄存器提前执行, 消除第一个气泡, &lt;/p&gt;
&lt;p&gt;同理将第六步的加载f到寄存器提前执行, 消除第二个气泡.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180503001705504-1035222196.jpg&quot; alt=&quot;&quot; width=&quot;132&quot; height=&quot;246&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过指令重排后, 整个流水线会更加顺畅, 无气泡阻塞执行.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180503001908551-719443674.jpg&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原先需要14个时钟周期的指令, 重排后, 只需要12个时钟周期即可执行完毕.&lt;/p&gt;
&lt;p&gt;指令重排只可能发生在毫无关系的指令之间, 如果指令之间存在依赖关系, 则不会重排.&lt;/p&gt;
&lt;p&gt;如 指令1 : a = 1 指令2: b = a - 1, 则指令1, 2 不会发生重排.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;编译器优化&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;主要指jvm层面的, 如下代码, 在jvm client模式很快就跳出了while循环, 而在server模式下运行, &lt;strong&gt;永远不会停止&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Created by Administrator on 2018/5/3/0003.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VisibilityTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; stop;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;stop) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;finish loop,i=&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stopIt() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         stop = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getStop() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt; stop;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;  
&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;          VisibilityTest v = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VisibilityTest();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;         v.start();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;          Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        v.stopIt();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;          Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;          System.out.println(&quot;finish main&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;         System.out.println(v.getStop());
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以通过修改JAVA_HOME/jre/lib/i386/jvm.cfg, 将jvm调整为server模式验证下.&lt;/p&gt;
&lt;p&gt;修改内容如下图所示, 将-server调整到-client的上面.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;-server KNOWN&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;-client KNOWN&lt;/strong&gt;&lt;br/&gt;-hotspot ALIASED_TO -client&lt;br/&gt;-classic WARN&lt;br/&gt;-native ERROR&lt;br/&gt;-green ERROR&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改成功后, java -version会产生如图变化.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180504000139424-1460048613.jpg&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;两者区别在于当jvm运行在-client模式的时候,使用的是一个代号为C1的轻量级编译器,&lt;/p&gt;
&lt;p&gt;而-server模式启动的虚拟机采用相对重量级,代号为C2的编译器. C2比C1编译器编译的相对彻底,&lt;/p&gt;
&lt;p&gt;会导致程序启动慢, 但服务起来之后, 性能更高, 同时有可能带来可见性问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们将上述代码运行的&lt;strong&gt;汇编代码&lt;/strong&gt;打印出来, 如下图所示, 从红字注释的部分可以看出来, &lt;/p&gt;
&lt;p&gt;只有第一次进入循环之前, 检查了下stop的值, 不满足条件, 进入循环后, &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再也没有检查stop&lt;/strong&gt;, 一直在做循环i++.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180504001833335-1584768177.png&quot; alt=&quot;&quot; width=&quot;857&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方案也很简单, 只要给stop加上&lt;strong&gt;volatile&lt;/strong&gt;关键字, 再次打印汇编代码, 发现他每次都会检查stop的值.&lt;/p&gt;
&lt;p&gt;就不会出现无限循环了.&lt;/p&gt;
&lt;p&gt;再来看&lt;strong&gt;两个从Java语言规范中摘取的例子&lt;/strong&gt;, 也是涉及到编译器优化重排, 这里不再做详细解释, 只说下结果.&lt;/p&gt;
&lt;p&gt;例子1中有可能出现r2 = 2 并且 r1 = 1;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180506205920332-1723315790.png&quot; alt=&quot;&quot; width=&quot;907&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子2中是r2, r5值因为都是=r1.x, 编译器会使用向前替换, 把r5指向到r2, 最终可能导致r2=r5=0, r4 = 3;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201805/1285727-20180506210013656-496055010.png&quot; alt=&quot;&quot; width=&quot;906&quot; height=&quot;446&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Happen-Before先行发生规则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果光靠sychronized和volatile来保证程序执行过程中的原子性, 有序性, 可见性, 那么代码将会变得异常繁琐.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JMM提供了Happen-Before规则来约束数据之间是否存在竞争, 线程环境是否安全, 具体如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个线程内保证语义的串行性; a = 1; b = a + 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;volatile变量的写，先发生于读，这保证了volatile变量的可见性,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解锁（unlock）必然发生在随后的加锁（lock）前.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传递性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A先于B，B先于C，那么A必然先于C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程启动, 中断, 终止&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程的start()方法先于它的每一个动作.&lt;/p&gt;
&lt;p&gt;线程的中断（interrupt()）先于被中断线程的代码.&lt;/p&gt;
&lt;p&gt;线程的所有操作先于线程的终结（Thread.join()）.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象终结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象的构造函数执行结束先于finalize()方法.&lt;/p&gt;

</description>
<pubDate>Sun, 06 May 2018 14:31:00 +0000</pubDate>
<dc:creator>大道方圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/8948277.html</dc:identifier>
</item>
<item>
<title>Netty入门 - 阿拉巴洞</title>
<link>http://www.cnblogs.com/0813lichenyu/p/9000068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0813lichenyu/p/9000068.html</guid>
<description>&lt;hr/&gt;
&lt;p&gt;　　Netty框架底层是对NIO的高度封装，所以想要更好的学习Netty之前，应先了解下什么是NIO - NIO是non-blocking的简称，&lt;br/&gt;在jdk1.4 里提供的新api，他的他的特性如下：&lt;br/&gt;　　* 为所有的原始类型提供(Buffer)缓存支持，字符集编码解码解决方案。&lt;br/&gt;　　* Channel ：一个新的原始I/O 抽象。支持锁和内存映射文件的文件访问接口。提供多路(non-bloking)非阻塞式的高伸缩&lt;br/&gt;性网络I/O 。&lt;br/&gt;　　NIO是一个非阻塞式的I/O,它由一个专门的线程来处理所有的IO事件，并负责分发，并且它只有在事件到达的时候才会触发，&lt;br/&gt;而不是去同步的监视事件；线程之间通过wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。&lt;br/&gt;　　NIO和IO最大的区别是数据打包和传输方式。IO是以流的方式处理数据，而NIO是以块的方式处理数据。NIO的核心部分由&lt;br/&gt;Channels、Buffers、Selectors三部分组成。&lt;/p&gt;
&lt;h2&gt;（一）Channel和Buffer&lt;/h2&gt;
&lt;p&gt;　　正常的情况下，所有的IO在NIO中都从一个Channel 开始。Channel有点像流。数据可以从Channel读到Buffer中，也可以从&lt;br/&gt;Buffer写到Channel中。JAVA NIO中的一些主要Channel的实现：FileChannel、DatagramChannel、SocketChannel、&lt;br/&gt;ServerSocketChannel。这些实现类覆盖了UDP和TCP网络IO，以及文件IO。&lt;br/&gt;　　而Buffer的一些实现类：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer，则覆盖&lt;br/&gt;了能通过IO发送的基本数据类型：byte,short,int,long,float,double和char。&lt;/p&gt;
&lt;h2&gt;（二）Selector&lt;/h2&gt;
&lt;p&gt;　　Selector允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector&lt;br/&gt;就会很方便。而要使用Selector，就得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的&lt;br/&gt;通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。&lt;/p&gt;

&lt;h2&gt;（一）Netty入门&lt;/h2&gt;
&lt;p&gt;　　大数据，高访问场景的互联网项目或者多系统的协同工作，使用一个服务器根本不能胜任。就需要把系统拆分成了多个服务，&lt;br/&gt;根据需要部署在多个机器上，这些服务非常灵活，可以随着访问量弹性扩展。但是多个模块的跨服务通信，时间和资源都是极大&lt;br/&gt;地浪费。传统的Blocking IO不能解决，因为会有线程阻塞的问题，而使用非阻塞IO(NIO),则需要耗费太多的精力。而Netty框架&lt;br/&gt;（RPC框架）则很好的解决了这个问题。&lt;br/&gt;　　Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、&lt;br/&gt;高可靠性的网络服务器和客户端程序。他就是一个程序，是封装java socket noi的，我们直接拿来用就好了。&lt;br/&gt;　　Netty通信服务端的步骤：&lt;br/&gt;　　　　1、创建两个NIO线程组，一个专门用于网络事件处理（接受客户端的连接），另一个则进行网络通信的读写。&lt;br/&gt;　　　　2、创建一个ServerBootstrap对象，配置Netty的一系列参数，例如接受传出数据的缓存大小等。&lt;br/&gt;　　　　3、创建一个用于实际处理数据的类ChannelInitializer，进行初始化的准备工作，比如设置接受传出数据的字符集、&lt;br/&gt;格式以及实际处理数据的接口。&lt;br/&gt;　　　　4、绑定端口，执行同步阻塞方法等待服务器端启动即可。&lt;br/&gt;　　　　5、关闭相应的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端栗子：&lt;/strong&gt;&lt;br/&gt;  服务端的管理者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 服务端处理通道.这里只是打印一下请求的内容，并不对请求进行任何的响应
* 继承自ChannelHandlerAdapter， 这个类实现了ChannelHandler接口，
* ChannelHandler提供了许多事件处理的接口方法，然后你可以覆盖这些方法。
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; lcy
*
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DiscartServiceHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelHandlerAdapter {
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 客户端收到新消息时，这个方法会被调用
* 
* &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ctx
* 通道处理的上下文信息
* &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; msg
* 接受的消息
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead(ChannelHandlerContext ctx, Object msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将接收到的信息转换为缓冲区&lt;/span&gt;
ByteBuf str =&lt;span&gt; (ByteBuf) msg;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印传输过来的信息&lt;/span&gt;
&lt;span&gt;System.out.print(str.toString(CharsetUtil.UTF_8));
} &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放ByteBuf对象&lt;/span&gt;
&lt;span&gt;ReferenceCountUtil.release(msg);
}
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 在异常时触发
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出错误信息&lt;/span&gt;
&lt;span&gt;cause.printStackTrace();
ctx.close();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  服务端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 服务端
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; lcy
*
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DiscartServer {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DiscartServer(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; port) {
&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.port =&lt;span&gt; port;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; run() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（一）设置两个线程组
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来接收进来的连接&lt;/span&gt;
NioEventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来处理已经接受的连接&lt;/span&gt;
NioEventLoopGroup workGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup();
System.out.println(&lt;/span&gt;&quot;准备运行的端口&quot; +&lt;span&gt; port);
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（二）辅助工具类，用于服务器通道的一系列配置&lt;/span&gt;
ServerBootstrap bootstrap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（三）绑定两个线程组
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置group，这一步是必须的，如果没有设置group将会报java.lang.IllegalStateException:group not set异常&lt;/span&gt;
bootstrap =&lt;span&gt; bootstrap.group(bossGroup, workGroup);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（四）指定NIO的模式&lt;/span&gt;&lt;span&gt;
/**&lt;/span&gt;&lt;span&gt;*
* ServerSocketChannel以NIO的selector为基础进行实现的，用来接收新的连接
* 这里告诉Channel如何获取新的连接.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
bootstrap &lt;/span&gt;= bootstrap.channel(NioServerSocketChannel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（五）配置具体的数据处理方式,就是往里添加规则&lt;/span&gt;
bootstrap = bootstrap.childHandler(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt;() {

@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(SocketChannel arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与50秒内都没有与服务端进行通信的客户端断连&lt;/span&gt;
arg0.pipeline().addLast(&lt;span&gt;new&lt;/span&gt; ReadTimeoutHandler(50&lt;span&gt;));
arg0.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HttpObjectAggregator(1048576&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加实际处理数据的类&lt;/span&gt;
arg0.pipeline().addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscartServiceHandler());
}
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(六)设置TCP缓冲区&lt;/span&gt;
bootstrap = bootstrap.option(ChannelOption.SO_BACKLOG, 128&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保持连接&lt;/span&gt;
bootstrap = bootstrap.childOption(ChannelOption.SO_KEEPALIVE, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（七）绑定端口，启动接收进来的连接&lt;/span&gt;
ChannelFuture sync =&lt;span&gt; bootstrap.bind(port).sync();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（八） 这里会一直等待，直到socket被关闭&lt;/span&gt;
&lt;span&gt;sync.channel().closeFuture().sync();
} &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（九）关闭资源&lt;/span&gt;
&lt;span&gt;workGroup.shutdownGracefully();
bossGroup.shutdownGracefully();
}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务开启&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.length &amp;gt; 0&lt;span&gt;) {
port &lt;/span&gt;= Integer.parseInt(args[0&lt;span&gt;]);
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
port &lt;/span&gt;= 8080&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscartServer(port).run();
System.out.println(&lt;/span&gt;&quot;server:run()&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;客户端栗子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  实际处理数据的类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ChannelClient &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelInitializer{

@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initChannel(Channel arg0) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与50秒内都没有与服务端进行通信的客户端断连&lt;/span&gt;
arg0.pipeline().addLast(&lt;span&gt;new&lt;/span&gt; ReadTimeoutHandler(50&lt;span&gt;));
arg0.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HttpObjectAggregator(1048576&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Channel&lt;/span&gt;
arg0.pipeline().addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelHandlerAdapter(){

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead(ChannelHandlerContext ctx, Object msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将接收到的信息转换为缓冲区&lt;/span&gt;
ByteBuf str =&lt;span&gt; (ByteBuf) msg;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印传输过来的信息&lt;/span&gt;
&lt;span&gt;System.out.print(str.toString(CharsetUtil.UTF_8));
} &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放ByteBuf对象&lt;/span&gt;
&lt;span&gt;ReferenceCountUtil.release(msg);
}
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出错误信息&lt;/span&gt;
&lt;span&gt;cause.printStackTrace();
ctx.close();
}
});

}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  客户端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 客户端
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; lcy
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
@SuppressWarnings(&lt;/span&gt;&quot;resource&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个新的线程组&lt;/span&gt;
NioEventLoopGroup workGroup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化Netty&lt;/span&gt;
Bootstrap bootstrap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bootstrap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定工作的线程组&lt;/span&gt;
bootstrap =&lt;span&gt; bootstrap.group(workGroup);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定 Channel的类型。因为是客户端, 因此使用了 NioSocketChannel。&lt;/span&gt;
bootstrap.channel(NioSocketChannel.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 设置链接的一些属性
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;降低延迟，禁用了禁用nagle算法。nagle算法受TCP延迟确认影响,会导致相继两次向连接发送请求包。&lt;/span&gt;
bootstrap.option(ChannelOption.TCP_NODELAY, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入&lt;/span&gt;
bootstrap.option(ChannelOption.SO_KEEPALIVE, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用netty默认的解码器会出现读取不完整，不会执行channelRead方法。设置这个属性可惜保证Netty读取的完整&lt;/span&gt;
&lt;span&gt;bootstrap.option(ChannelOption.MAX_MESSAGES_PER_READ, Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置数据处理器&lt;/span&gt;
bootstrap.handler(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelClient());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步的链接&lt;/span&gt;
Channel channel = bootstrap.connect(&quot;127.0.0.1&quot;, 8080&lt;span&gt;).sync().channel();
channel.writeAndFlush(Unpooled.copiedBuffer(&lt;/span&gt;&quot;Hello Netty...&quot;&lt;span&gt;.getBytes()));
channel.closeFuture().sync();
workGroup.shutdownGracefully();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;（二）Netty的数据通讯：&lt;/h2&gt;
&lt;p&gt;　　1、使用长连接通道不断开的形式进行通信，也就是服务器和客户端的通道一直处于开启状态，如果服务器性能足够好，&lt;br/&gt;并且客户端数量也比较多的情况下，推荐这种方式。&lt;br/&gt;　　2、一次性批量提交数据，采用短连接方式。也就是说先把数据保存到本地临时缓存区或者临时表，当达到界值时进行一&lt;br/&gt;次性批量提交，又或者根据定时任务轮询提交。&lt;br/&gt;　　3、使用一种特殊的长连接，在某一指定时间段内，服务器与某台客户端没有任何通信，则断开连接。下次连接则是客户&lt;br/&gt;端向服务器发送请求的时候，再次建立连接。&lt;/p&gt;
&lt;h2&gt;（三）Netty的编解码器: 　&lt;/h2&gt;
&lt;p&gt;　   1. Decoder 解码器    负责将消息从字节或其他序列形式转成指定的消息对象。&lt;br/&gt;　　2. Encoder 编码器    将消息对象转成字节或其他序列形式在网络上传输。&lt;br/&gt;　　入站”ByteBuf读取bytes后由 ToIntegerDecoder 进行解码，然后将解码后的消息存入List集合中，然后传递到ChannelPipeline&lt;br/&gt;中的下一个ChannelInboundHandler。&lt;br/&gt;　　&lt;strong&gt;解码器：&lt;/strong&gt;&lt;br/&gt;　　　　1）ByteToMessageDecoder，需自己判断ByteBuf读取前是否有足够的字节，否则会出现沾包的现象。&lt;br/&gt;　　　　2）ReplayingDecoder，无需自己检查字节长度，但是使用起来具有局限性：&lt;br/&gt;　　　　　　* 不是所有的操作都被ByteBuf支持，如果调用一个不支持的操作会抛出DecoderException。&lt;br/&gt;　　　　　　* ByteBuf.readableBytes()大部分时间不会返回期望值。&lt;br/&gt;　　　　3）MessageToMessageDecoder（message-to-message）&lt;br/&gt;　　解码器是用来处理入站数据，Netty提供了很多解码器的实现，可以根据需求详细了解。&lt;br/&gt;　&lt;strong&gt;　编码器：&lt;/strong&gt;&lt;br/&gt;　　　　1）MessageToByteEncoder&lt;br/&gt;　　　　2）MessageToMessageEncoder 需要将消息编码成其他的消息时可以使用Netty提供的MessageToMessageEncoder抽象类&lt;br/&gt;来实现。例如将Integer编码成String。&lt;/p&gt;
&lt;h2&gt;（四）Netty中解决TCP粘包/拆包问题&lt;/h2&gt;
&lt;p&gt;　　想要解决TCP的粘包/拆包问题，首先要知道什么是&lt;span&gt;TCP粘包、拆包&lt;/span&gt;:&lt;br/&gt;　　　　TCP是一个“流”协议，所谓流就是没有界限的遗传数据。大家可以想象一下，如果河水就好比数据，他们是连成一片的，没有&lt;br/&gt;分界线，TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的具体情况进行包的划分，也就是说，在业务上一个完整的&lt;br/&gt;包可能会被TCP分成多个包进行发送，也可能把多个小包封装成一个大的数据包发送出去，这就是所谓的粘包/拆包问题。&lt;br/&gt;　　&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br/&gt;　　1、消息定长，例如每个报文的大小固定为200个字节，如果不够，空位补空格。&lt;br/&gt;　　2、在包尾部增加特殊字符进行分割，例如加回车等。&lt;br/&gt;　　3、将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行业务逻辑的处理。&lt;br/&gt;　　&lt;strong&gt;Netty中解决TCP粘包/拆包的方法：&lt;/strong&gt;&lt;br/&gt;　　　　1、分隔符类：DelimiterBasedFrameDecoder（自定义分隔符）&lt;br/&gt;　　　　2、定长：FixedLengthFrameDecoder&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 14:27:00 +0000</pubDate>
<dc:creator>阿拉巴洞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0813lichenyu/p/9000068.html</dc:identifier>
</item>
<item>
<title>Git分支创建与合并 - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/8999445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/8999445.html</guid>
<description>&lt;p&gt;分支管理是Git支持多人协作和版本控制的关键，参照廖雪峰对Git的介绍，对真实开发环境中Git的使用结合实践进行梳理。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td readability=&quot;19&quot;&gt;
&lt;p&gt;摘自：廖雪峰的官方网站&lt;/p&gt;
&lt;p&gt;在实际开发中，我们应该按照几个基本原则进行分支管理：&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;master&lt;/code&gt;分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；&lt;/p&gt;
&lt;p&gt;那在哪干活呢？干活都在&lt;code&gt;dev&lt;/code&gt;分支上，也就是说，&lt;code&gt;dev&lt;/code&gt;分支是不稳定的，到某个时候，比如1.0版本发布时，再把&lt;code&gt;dev&lt;/code&gt;分支合并到&lt;code&gt;master&lt;/code&gt;上，在&lt;code&gt;master&lt;/code&gt;分支发布1.0版本；&lt;/p&gt;
&lt;p&gt;你和你的小伙伴们每个人都在&lt;code&gt;dev&lt;/code&gt;分支上干活，每个人都有自己的分支，时不时地往&lt;code&gt;dev&lt;/code&gt;分支上合并就可以了。&lt;/p&gt;
&lt;p&gt;所以，团队合作的分支看起来就像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506173032937-1781560847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在看具体实践前，需要了解一些理论概念，参考&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000&quot; target=&quot;_blank&quot;&gt;创建与合并分支&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;　　（1）HEAD指针与分支间的关系：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506183509438-2093659720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）分支合并的时候，默认采用Fast Forward模式，可称为“快进合并”，即将master直接指向dev的当前提交，如下图，但这种模式下，删除分支后，会丢掉分支信息：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506183729862-1945782106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506190629378-1494840260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）no-ff模式，在合并的时候采用该模式，会新创建一个提交，并将master指向该最新提交。&lt;/p&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506184117638-1941977575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1. 创建git工程&lt;/h3&gt;
&lt;p&gt;　　（1）创建本地库：执行命令 git init ，创建 .git隐藏文件&lt;/p&gt;
&lt;p&gt;　　（2）本地库关联远程仓库：用github对工程进行托管，具体可参照&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013752340242354807e192f02a44359908df8a5643103a000&quot; target=&quot;_blank&quot;&gt;添加远程库&lt;/a&gt;，为本地库添加远程仓库信息&lt;/p&gt;
&lt;p&gt;　　创建完成后，本地工程如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506174101133-376437309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 开发过程&lt;/h3&gt;
&lt;p&gt;　　假设有2名开发，bob和lilei。&lt;/p&gt;
&lt;p&gt;　　（1）创建开发分支dev&lt;/p&gt;
&lt;p&gt;　　　　git checkout -b dev，此时该分支还属于私人分支。&lt;/p&gt;
&lt;p&gt;　　　　git push origin dev:dev，远程仓库创建dev分支，并与本地关联。&lt;/p&gt;
&lt;p&gt;　　　　git checkout dev   切换分支（切之前，可以先执行 git pull  拉去分支信息）。&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506175146988-1581801427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）对index.html文件进行修改，bob添加“add by bob”，提交到远程仓库，具体指令参照&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/shuimuzhushui/p/8993913.html&quot;&gt;Git常用命令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　（3）lilei拉取最新代码，并进行修改，在index.html中添加“add by lilei”&lt;/p&gt;
&lt;p&gt;　　　　① git fetch origin dev    拉去dev分支最新代码&lt;/p&gt;
&lt;p&gt;　　　　② git merge --no-ff -m '合并最新代码' dev      采用no-ff方式，将拉取的最新代码与本地合并，注意：不加 -m后边参数，会打开编辑器，输入注解&lt;/p&gt;
&lt;p&gt;　　　　③ 在index.html中添加“add by lilei”，提交并push到远程仓库&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506180125542-257961027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）bob拉取最新代码，并将dev分支合并到master分支&lt;/p&gt;
&lt;p&gt;　　　　① git pull origin dev   直接pull，代替fetch+merge操作，默认采用Fast-Forward模式合并。（此处应该采用（3）先fetch，再merge，分支结构更明显）&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506180401231-1802657435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　② git checkout master   切到主分支&lt;/p&gt;
&lt;p&gt;　　　　③  git merge --no-ff -m 'merge with no-ff' dev 或者 git merge dev，会对dev和master进行&lt;strong&gt;合并提交&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506180910207-633892855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　④ git push origin  将合并后的主分支同步到远程仓库&lt;/p&gt;
&lt;h3&gt;3. 分支结构&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;（1）采用no-ff模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　执行命令： git log --graph --pretty=oneline --abbrev-commit  查看分支图形结构，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506182449436-1774262855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　① bob在dev的本地分支上修改文件，并提交到远程仓库。&lt;/p&gt;
&lt;p&gt;　　② lilei本地拉取最新文件，并采用 no-ff方式进行合并（新创建一个提交，从而是dev分支的HEAD指针指向新提交）&lt;/p&gt;
&lt;p&gt;　　③ lilei修改文件，并提交到远程仓库。bob直接pull拉取，默认采用Fast-Forward模式。&lt;/p&gt;
&lt;p&gt;　　④ bob将dev合并到master分支，执行命令 &lt;strong&gt;git merge --no-ff -m 'merge with no-ff' dev&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 　　在github上查看最后一次提交，其中本次提交有2个parent（4f368cc和5b53028），与上图对应，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506185158779-1570264482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）采用Fast Forward模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1012728/201805/1012728-20180506191929398-890434511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　① 第一种模式最后一次提交。&lt;/p&gt;
&lt;p&gt;　　② bob将修改提交远程仓库。lilei从远程仓库直接pull拉取合并，采用Fast Forward方式，没有产生新的提交。&lt;/p&gt;
&lt;p&gt;　　③ lilei将修改提交远程仓库。bob拉取远程仓库后合并（fetch+merge），采用Fast Forward模式，没产生新的提交。&lt;/p&gt;
&lt;p&gt;　　④ 切换到master分支，执行 &lt;strong&gt;git merge dev&lt;/strong&gt;  合并。&lt;/p&gt;
&lt;h3&gt; 4. 合并冲突解决&lt;/h3&gt;
&lt;p&gt;　　遇到冲突时，Git已经做了合并，但是没有自动地创建一个新的合并提交。 Git会暂停下来，等待你去解决合并产生的冲突，然后再对冲突的文件执行提交（add、commit、push）即可。&lt;/p&gt;
&lt;p&gt;　　具体做法参考：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6&quot; target=&quot;_blank&quot;&gt;Git 分支 - 分支的新建与合并&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 06 May 2018 14:26:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/8999445.html</dc:identifier>
</item>
<item>
<title>挑子学习笔记：基于两步聚类的离群点检测 - 挑子</title>
<link>http://www.cnblogs.com/tiaozistudy/p/anomaly_detection.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiaozistudy/p/anomaly_detection.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;转载请标明出处：http://www.cnblogs.com/tiaozistudy/p/anomaly_detection.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   本文主要针对IBM SPSS Modeler 18.0中离群点检测算法的原理以及“异常”节点（见图1）使用方法进行说明。SPSS Modeler中的离群点检测算法思想主要基于聚类分析。如图2所示，可先将图中样本点聚成三类，$A$、$B$和$C$三个样本点应分别属于距离他们最近的类，但与相对类内的其他样本点，这三个点又分别远离各自的类，所以可以基于此判定是离群点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506170309649-1927311951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1：“异常”节点&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506170422539-1273747478.png&quot; alt=&quot;&quot; width=&quot;264&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2：离群点检测示意图&lt;/p&gt;

&lt;p&gt;根据上述分析，你群点检测算法主要分为三个阶段：第一阶段，聚类，即将样本点聚成若干类；第二阶段，计算，即在第一阶段聚类的基础上，依据距离计算所有样本点的异常性测度指标；第三阶段，诊断，即在第二阶段异常性测度指标的基础上，确定最终的离群点，并分析导致样本点异常的原因，也就是分析离群点在哪个变量方向上呈现异常。以下就这三个阶段分别讨论：&lt;/p&gt;
&lt;h2&gt;1.1. 第一阶段：聚类&lt;/h2&gt;
&lt;p&gt;该阶段主要借助两步聚类算法实现对所有样本点的聚类（可参考&lt;a href=&quot;http://www.cnblogs.com/tiaozistudy/p/twostep_cluster_algorithm.html&quot; target=&quot;_blank&quot;&gt;两步聚类算法&lt;/a&gt;的相关内容）。两步聚类算法主要分为两个步骤：第一步是通过构造聚类特征（CF）树将大量零散的数据样本浓缩成可管理数量的子簇；第二步是从CF树叶节点的子簇开始利用凝聚法（agglomerative hierarchical clustering method），逐个地合并子簇，直到期望的簇数量。&lt;/p&gt;
&lt;p&gt;两步聚类算法可以进行离群点处理，首先在CF树瘦身（rebuilding）之前筛选出潜在离群点，并CF树瘦身步骤后重新插入误识离群点到中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;潜在离群点的筛选。在CF树实施瘦身之前，从当前CF树中的所有叶元项（leaf entry）中找出包含最多数据样本的元项，记录该元项包含的数据样本数目（$N_{\max} $），根据事先确定的比例参数$\alpha$；如果某叶元项包含的数据样本数目小于$\alpha N_{\max} $，则该叶元项置为潜在离群点，从当前CF 树中移除。&lt;/li&gt;
&lt;li&gt;误识离群点的插入。在CF树瘦身完毕后，逐个处理潜在离群点，如果能够在不增加当前CF树体积的条件下吸收到CF树中，则认为该潜在离群点为误识离群点，将插入至当前CF树上。在完成数据集$\mathfrak D $中所有数据点到CF树上的插入后，仍为潜在离群点的元项，视为最终离群点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在完成数据集中所有数据样本到CF树上的插入后，仍为潜在离群点的元项，视为最终离群点。这些离群点将会分配到第二步凝聚法的聚类结果中。&lt;/p&gt;
&lt;p&gt;“异常”节点中与此阶段相关的，是其“专家”选项的相关参数设计（见图3）:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调整系数。指定一个大于0的数，用于调整连续型变量和分类型变量在计算距离时的权重，该值越大，连续型变量的权重越大。&lt;/li&gt;
&lt;li&gt;自动计算对等组数。表示自动判断样本点应聚成几个类，聚类数目允许的最小值和最大值须分别指定。&lt;/li&gt;
&lt;li&gt;指定对等组数。选中此选项，可直接指定聚类数目。&lt;/li&gt;
&lt;li&gt;噪声水平。其对应了上文中的$\alpha$，噪声水平的取值在0到0.5之间。&lt;/li&gt;
&lt;li&gt;插补缺失值。如果选中该选项，对于连续型变量将用变量均值代替缺失值，对于分类型变量，缺失值将作为一个有效的新类别；如果，该选项没有选中，任何带有缺失值的样本都将从分析中剔除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506171049282-804840995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3：“异常”节点的“专家”选项&lt;/p&gt;
&lt;h2&gt;1.2. 第二阶段：计算&lt;/h2&gt;
&lt;p&gt;第二阶段的任务是在第一阶段聚类的基础上，计算样本的异常性测度指标，异常性测度指标的计算是基于对数似然距离（可参考&lt;a href=&quot;http://www.cnblogs.com/tiaozistudy/p/log-likelihood_distance.html&quot; target=&quot;_blank&quot;&gt;对数似然距离&lt;/a&gt;的相关内容）。对于样本点$s$，离群点检测算法计算了以下指标。&lt;/p&gt;
&lt;p&gt;（1）找到样本点$s$所属的簇$C_j$。通过计算$\{s\}$与$C_j \setminus \{s\}$的对数似然距离得到样本点$s$的组差异指标GDI（Group Deviation Index）：&lt;/p&gt;
&lt;p&gt;\begin{equation}\label{Eq.1}&lt;br/&gt;GDI_s = d(\{s\}, C_j \setminus \{s\}) = \zeta_{C_j \setminus \{s\}} + \zeta_{\{s\}} - \zeta_{C_j}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;\begin{equation*}&lt;br/&gt;\zeta_{C_j} = -N_j \left ( \frac12 \sum_{k=1}^{D_1} \ln (\hat \sigma^2_{jk} + \hat \sigma^2_k) + \sum_{k=1}^{D_2} \hat E_{jk} \right )&lt;br/&gt;\end{equation*}&lt;/p&gt;
&lt;p&gt;\begin{equation*}&lt;br/&gt;\hat E_{jk} = -\sum_{l=1}^{\epsilon_k} N_{jkl}/N_j \ln (N_{jkl}/N_j)&lt;br/&gt;\end{equation*}&lt;/p&gt;
&lt;p&gt;公式中符号的具体含义见“对数似然距离”。GDI反映的是，样本点$s$加入簇$C_j$后所引起的簇$C_j$内部差异/散布的增大量，因此GDI越大，样本点越有可能是离群点。&lt;/p&gt;
&lt;p&gt;（2）根据$\zeta_{C_j}$的定义，$\zeta_{C_j}$可以划分成各变量上值得线性组合：&lt;/p&gt;
&lt;p&gt;\begin{equation*}&lt;br/&gt;\zeta_{C_j} = \sum_k^D \zeta_{C_j}^{(k)}&lt;br/&gt;\end{equation*}&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;\begin{equation*}&lt;br/&gt;\zeta_{C_j}^{(k)} =&lt;br/&gt;\begin{cases}&lt;br/&gt;- \frac{N_j}2 \ln (\hat \sigma^2_{jk} + \hat \sigma^2_k), &amp;amp; \text{变量}k\text{是连续型的} \\&lt;br/&gt;-\sum_{l=1}^{\epsilon_k} N_{jkl} \ln (N_{jkl}/N_j), &amp;amp; \text{变量}k\text{是分类型的}&lt;br/&gt;\end{cases}&lt;br/&gt;\end{equation*}&lt;/p&gt;
&lt;p&gt;进一步定义样本点$s$在变量$k$上的变量差异指标VDI（Variable Deviation Index）:&lt;/p&gt;
&lt;p&gt;\begin{equation}\label{Eq.2}&lt;br/&gt;VDI_s^{(k)} = \zeta_{C_j \setminus \{s\}}^{(k)} + \zeta_{\{s\}}^{(k)} - \zeta_{C_j}^{(k)}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;因此有$GDI_s = \sum_k VDI_s^{(k)}$，变量差异指标VDI表示各变量在组差异指标GDI上的“贡献”大小。&lt;/p&gt;
&lt;p&gt;（3）计算异常指标AI（Anomaly Index）。&lt;/p&gt;
&lt;p&gt;对于样本点$s$，其AI定义为：&lt;/p&gt;
&lt;p&gt;\begin{equation}\label{Eq.3}&lt;br/&gt;AI_s = \frac{GDI_s}{\frac{1}{|C_j|} \sum_{t \in C_j} GDI_t}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;AI是一个相对指标较GDI更直观，是样本点$s$所引起的簇内差异与簇$C_j$内其它样本点所引起差异的平均值的比例，该值越大，认为样本点$s$是离群点的可能性就越大。&lt;/p&gt;
&lt;p&gt;（4）计算变量贡献指标VCM（Variable Contribution Measures）。&lt;/p&gt;
&lt;p&gt;对于样本点$s$，变量$k$的贡献指标定义为&lt;/p&gt;
&lt;p&gt;\begin{equation}\label{Eq.4}&lt;br/&gt;VCM_s^{(k)} = \frac{VDI_s^{(k)}}{GDI_s}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;VCM是一个相对指标，较VDI更直观，反映的是各聚类变量对组内差异“贡献”的比例。该值越大，则相应变量导致样本点$s$离群原因的可能性越大。&lt;/p&gt;
&lt;h2&gt;1.3. 第三阶段：诊断&lt;/h2&gt;
&lt;p&gt;第二阶段计算得到了所有样本点的GDI、VDI、AI和VCM，本阶段将依据这些指标的排序结果，确定离群点，并分析导致异常的原因。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将AI按照降序排序，排在前$m$位的样本点可能为离群点。同时，$m$位置的AI 值就是离群点的判断标准。大于该值的为离群点，小于为非离群点。&lt;/li&gt;
&lt;li&gt;对于离群点，将VDI按照降序排序，排在前$l$位的变量是导致该点可能异常的主要原因。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;“异常”节点中与第二、三阶段相关的，是其“模型”选项的相关参数设计（见图4）:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最小异常指数水平。指定异常指标AI的阈值，对于样本点$s$，如果根据式(3)计算出的$AI_s$大于该阈值，则该样本点$s$定义为离群点。&lt;/li&gt;
&lt;li&gt;训练数据中最异常的记录百分比。指定多少百分比的样本为离群点。&lt;/li&gt;
&lt;li&gt;训练数据中最异常的记录数。指定多少个样本为离群点。&lt;/li&gt;
&lt;li&gt;要报告的异常字段数（$l$）。对于离群点$s$，对于所有变量$k$，取$l$个$VDI_s^{(k)}$值（由式(2)计算）最大的变量在模型结果中进行报告。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506171419458-1047445242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4：“异常”节点的“模型”选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506171456428-1084708492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5：异常检测示例流&lt;/p&gt;
&lt;p&gt;参考《SPSS Modeler数据挖掘方法及应用》中的数据和流，构造了图5中所示的流。打开流中的模型块（如图6和7所示）。&lt;/p&gt;
&lt;p&gt;图6中“模型”选项的结果表明，所有样本数据聚成了两类（称之为“对等组”），第1类包含498个样本，发现5个离群点；第2类包含169个样本，发现1个离群点。对第1类中5 个离群点分别找出3个VCM值（见式(4)）最大的变量，形成了图6中的上表。所有5个离群点对应的3个VCM值最大的变量中都包含“基本费用”，换句话说，变量“基本费用”对于形成所有5个离群点都有较大贡献，5个离群点的平均VCM 值为0.165. 另一个需要注意的变量是“免费部分”，虽然该变量只对3个离群点的成因有较大贡献，但其平均VCM的值达到了0.325，这说明，它对这3个离群点的成因有非常大的贡献。&lt;/p&gt;
&lt;p&gt;图7中“摘要”选项给出了判断离群点的AI阈值，即“异常指数分界值：1.52328”。 针对本次找出的6个离群点，通过式(3)计算出的AI值都不小于该值，而其它样本点的AI值都小于该值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506171713731-1698406994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6：“异常”模型块的“模型”选项&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506172024078-160672469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图7：“异常”模型块的“摘要”选项&lt;/p&gt;
&lt;p&gt;在模型块的“设置”选项中选中“丢弃记录”-“非异常”后运行“异常数据”表格，得到如图8的离群点输出结果，该表格中一共出现了5类新变量：&lt;/p&gt;
&lt;p&gt;表1：新变量说明&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;新变量名称&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;em&gt;$O-Anomaly&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;是否离群点，T：是，F：否&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;em&gt;$O-AnomalyIndex&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;该样本的异常指标AI，由式(3)计算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;em&gt;$O-PeerGroup&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;样本分配到的对等组（所在簇）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;em&gt;$O-Field-n&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;VCM第n大的变量名称，VCM由式(4)计算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;em&gt;$O-FieldImpact-n&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;VCM第n大的变量对应的VCM值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 以图5中的流为例，因为图4中的“要报告的异常字段数”设定为3，所以&lt;em&gt;$O-Field-n&lt;/em&gt;和&lt;em&gt;$O-FieldImpact-n&lt;/em&gt;中的$n$最大只能取到3. 再看图8中的第一行，该样本的$AI=1.530$，属于第一个簇，VCM贡献最大的变量是“收入”，该样本在变量“收入”下的$VCM=0.200$.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1069522/201805/1069522-20180506172436660-1172122594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图8：离群点输出结果表&lt;/p&gt;

&lt;p&gt;[1] 薛薇, 陈欢歌. SPSS Modeler数据挖掘方法及应用[M]. 北京: 电子工业出版社. 2014.&lt;/p&gt;

</description>
<pubDate>Sun, 06 May 2018 14:02:00 +0000</pubDate>
<dc:creator>挑子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiaozistudy/p/anomaly_detection.html</dc:identifier>
</item>
<item>
<title>Ribbon整合Eureka组件，以实现负载均衡 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8999772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8999772.html</guid>
<description>&lt;h4&gt;1整体框架的说明&lt;/h4&gt;
&lt;p&gt;    在本案例的框架里，我们将配置一个Eureka服务器，搭建三个提供相同服务的Eureka服务提供者，同时在Eureka服务调用者里引入Ribbon组件，这样，当有多个url向服务调用者发起调用请求时，整个框架能按配置在IRule和IPing中的“负载均衡策略“和“判断服务器是否可用的策略”，把这些url请求合理地分摊到多台机器上。&lt;/p&gt;
&lt;p&gt;    在下图里，我们能看到本系统的结构图，在其中，三个服务提供者向Eureka服务器注册服务，而基于Ribbon的负载均衡器能有效地把请求分摊到不同的服务器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180506211652148-1935925295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    为了让大家更方便地跑通这个案例，我们将讲解全部的服务器、服务提供者和服务调用者部分的代码。在下表里，列出了本架构中的所有项目。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;222&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;项目名&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;214&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;222&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;EurekaRibbonDemo-Server&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;214&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;Eureka服务器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;222&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;EurekaRibbonDemo-ServiceProviderOne&lt;/p&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;EurekaRibbonDemo-ServiceProviderTwo&lt;/p&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;EurekaRibbonDemo-ServiceProviderThree&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;214&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在这三个项目里，分别部署着一个相同的服务提供者&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;222&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;EurekaRibbonDemo-ServiceCaller&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;214&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;服务调用者&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4&gt;2 编写Eureka服务器    &lt;/h4&gt;
&lt;p&gt;    第一，在pom.xml里编写本项目需要用到的依赖包，在其中，是通过如下的代码引入了Eureka服务器所必需的包，关键代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1        &amp;lt;dependency&amp;gt;
2            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;        
3    &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;
4        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    第二，在application.yml这个文件里，指定了针对Eureka服务器的配置，关键代码如下。   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    server:
&lt;/span&gt;2      port: 8888
3&lt;span&gt;    eureka:
&lt;/span&gt;4&lt;span&gt;      instance:
&lt;/span&gt;5&lt;span&gt;        hostname: localhost
&lt;/span&gt;6&lt;span&gt;      client:
&lt;/span&gt;7&lt;span&gt;        serviceUrl:
&lt;/span&gt;8          defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第2和第5行里，指定了本服务器所在的主机地址和端口号是localhost:8888，在第8行里，指定了默认的url是http://localhost:8888/eureka/。&lt;/p&gt;
&lt;p&gt;    第三步，在RegisterCenterApp这个服务启动程序里编写启动代码。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2&lt;span&gt;    @EnableEurekaServer
&lt;/span&gt;3&lt;span&gt;    @SpringBoot
&lt;/span&gt;4&lt;span&gt;    Application
&lt;/span&gt;5    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegisterCenterApp 
&lt;/span&gt;6&lt;span&gt;    {
&lt;/span&gt;7        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;8        { SpringApplication.run(RegisterCenterApp.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args); }
&lt;/span&gt;9    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    启动该程序后，能在http://localhost:8888/看到该服务器的相关信息。&lt;/p&gt;
&lt;h4&gt;3 编写Eureka服务提供者&lt;/h4&gt;
&lt;p&gt;    这里有三个服务提供者，它们均是根据之前博文中的案例EurekaBasicDemo-ServiceProvider改写而来。我们就拿EurekaRibbonDemo-ServiceProviderOne来举例，看下其中包含的关键要素。&lt;/p&gt;
&lt;p&gt;    第一，同样是在pom.xml里，引入了服务提供者程序所需的jar包，不过在其中需要适当地修改项目名。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    第二，同样是在ServiceProviderApp.java里，编写了启动程序，代码不变。&lt;/p&gt;
&lt;p&gt;    第三，在application.yml里，编写了针对这个服务提供者的配置信息，关键代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    server:
&lt;/span&gt;2      port: 1111
3&lt;span&gt;    spring:
&lt;/span&gt;4&lt;span&gt;      application:
&lt;/span&gt;5&lt;span&gt;        name: sayHello
&lt;/span&gt;6&lt;span&gt;    eureka:  
&lt;/span&gt;7&lt;span&gt;      client:
&lt;/span&gt;8&lt;span&gt;        serviceUrl:
&lt;/span&gt;9          defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第2行里，指定了本服务是运行在1111端口上，在另外的两个服务提供者程序里，我们分别指定了它们的工作端口是2222和3333。&lt;/p&gt;
&lt;p&gt;    在第5行里，我们指定了服务提供者的名字是sayHello，另外两个服务器提供者的名字同样是sayHello，正因为它们的名字都一样，所以服务调用者在请求服务时，负载均衡组件才能有效地分摊流量。&lt;/p&gt;
&lt;p&gt;    第四，在Controller这个控制器类里，编写了处理url请求的逻辑，关键代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略了必要的package和import的代码&lt;/span&gt;
2&lt;span&gt;    @RestController
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {    
&lt;/span&gt;4        @RequestMapping(value = &quot;/sayHello/{username}&quot;, method =&lt;span&gt; RequestMethod.GET    )
&lt;/span&gt;5        &lt;span&gt;public&lt;/span&gt; String hello(@PathVariable(&quot;username&quot;&lt;span&gt;) String username) {
&lt;/span&gt;6            System.out.println(&quot;This is ServerProvider1&quot;&lt;span&gt;);        
&lt;/span&gt;7            &lt;span&gt;return&lt;/span&gt; &quot;Hello Ribbon, this is Server1, my name is:&quot; +&lt;span&gt; username;
&lt;/span&gt;8&lt;span&gt;        }
&lt;/span&gt;9    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第2行里，我们通过@RestController注解来说明本类承担着“控制器”的角色。在第4行里，我们定义了触发hello方法的url格式和Http请求的方式。在第5到第8行的hello方法里我们返回了一个字符串。请大家注意，在第6行和第7行的代码里，我们能明显看出输出和返回信息是来自于1号服务提供者。&lt;/p&gt;
&lt;p&gt;    EurekaRibbonDemo-ServiceProviderTwo和EurekaRibbonDemo-ServiceProviderOne项目很相似，改动点有如下三个。&lt;/p&gt;
&lt;p&gt;    第一，在pom.xml里，把项目名修改成EurekaRibbonDemo-ServiceProviderTwo。&lt;/p&gt;
&lt;p&gt;    第二，在application.yml里，把端口号修改成2222，关键代码如下所示。&lt;/p&gt;
&lt;p class=&quot;2&quot;&gt;          1      server:&lt;/p&gt;
&lt;p class=&quot;2&quot;&gt;          2        port: 2222&lt;/p&gt;
&lt;p class=&quot;2&quot;&gt;    第三，在Controller.java的hello方法里，在输出和返回信息里，打上出“Server2“的标记，关键代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1    @RequestMapping(value = &quot;/sayHello/{username}&quot;, method =&lt;span&gt; RequestMethod.GET    )
&lt;/span&gt;2        &lt;span&gt;public&lt;/span&gt; String hello(@PathVariable(&quot;username&quot;&lt;span&gt;) String username) {        
&lt;/span&gt;3            System.out.println(&quot;This is ServerProvider2&quot;&lt;span&gt;);        
&lt;/span&gt;4            &lt;span&gt;return&lt;/span&gt; &quot;Hello Ribbon, this is Server2, my name is:&quot; +&lt;span&gt; username;
&lt;/span&gt;5        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在EurekaRibbonDemo-ServiceProviderThree里，同样在EurekaRibbonDemo-ServiceProviderOne基础上做上述3个改动。这里需要在application.yml里，把端口号修改成3333，在Controller类中，同样需要在输出和返回信息中打上“Server3”的标记。    &lt;/p&gt;
&lt;h4&gt;4 在Eureka服务调用者里引入Ribbon&lt;/h4&gt;
&lt;p&gt;    EurekaRibbonDemo-ServiceCaller项目是根据第三章的EurekaBasicDemo-ServiceCaller改写而来，其中的关键代码如下。&lt;/p&gt;
&lt;p&gt;    第一，在pom.xml里，只是适当地修改项目名字，没有修改其它代码。&lt;/p&gt;
&lt;p&gt;    第二，没有修改启动类ServiceCallerApp.java里的代码。&lt;/p&gt;
&lt;p&gt;    第三，在application.yml了， 添加了描述服务器列表的listOfServers属性，代码如下。     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    spring:
&lt;/span&gt;2&lt;span&gt;      application:
&lt;/span&gt;3&lt;span&gt;        name: callHello
&lt;/span&gt;4&lt;span&gt;    server:
&lt;/span&gt;5      port: 8080
6&lt;span&gt;    eureka: 
&lt;/span&gt;7&lt;span&gt;      client:
&lt;/span&gt;8&lt;span&gt;        serviceUrl:
&lt;/span&gt;9          defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/&lt;/span&gt;
10&lt;span&gt;    sayHello:
&lt;/span&gt;11&lt;span&gt;      ribbon:
&lt;/span&gt;12&lt;span&gt;        listOfServers: 
&lt;/span&gt;13    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:1111/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:2222/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:3333&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第3行，我们指定了服务调用者本身的服务名是callHello，在第5里，指定了这个微服务的是运行在8080端口上。由于服务调用者本身也能对外界提供服务，所以外部程序能根据这个服务名和端口号，以url的形式调用其中的hello方法。&lt;/p&gt;
&lt;p&gt;    这里的关键是在第12和13行，我们通过ribbon.listOfServers，指定了该服务调用者能获得服务的三个url地址，请注意，这里的三个地址和上文里服务提供者发布服务的三个地址是一致的。&lt;/p&gt;
&lt;p&gt;    第四，在控制器类里，用RestTemplate对象，以负载均衡的方式调用服务，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import的代码&lt;/span&gt;
2&lt;span&gt;    @RestController
&lt;/span&gt;3&lt;span&gt;    @Configuration
&lt;/span&gt;4    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {        
&lt;/span&gt;5&lt;span&gt;        @Bean
&lt;/span&gt;6&lt;span&gt;        @LoadBalanced
&lt;/span&gt;7        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate getRestTemplate()
&lt;/span&gt;8        { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();  }
&lt;/span&gt;9        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供服务的hello方法     &lt;/span&gt;
10        @RequestMapping(value = &quot;/hello&quot;, method =&lt;span&gt; RequestMethod.GET    )
&lt;/span&gt;11        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello() {        
&lt;/span&gt;12            RestTemplate template =&lt;span&gt; getRestTemplate();
&lt;/span&gt;13            String retVal = template.getForEntity(&quot;http://sayHello/sayHello/Eureka&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).getBody();
&lt;/span&gt;14            &lt;span&gt;return&lt;/span&gt; &quot;In Caller, &quot; +&lt;span&gt; retVal;
&lt;/span&gt;15&lt;span&gt;        }
&lt;/span&gt;16    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在这个控制器类的第7行里，我们通过getRestTemplate方法返回一个RestTemplate类型对象。&lt;/p&gt;
&lt;p&gt;    RestTemplate是Spring提供的能以Rest形式访问服务的对象，本身不具备负载均衡的能力，所以我们需要在第6行通过@LoadBalanced注解赋予它这个能力。&lt;/p&gt;
&lt;p&gt;    在第11行的hello方法里，我们首先在第12行通过getRestTemplate方法得到了template对象，随后通过第13行的代码，用template对象提供的getForEntity方法，访问之前Eureka服务提供者提供的“http://sayHello/sayHello/Eureka“服务，并得到String类型的结果，最后在第14行，根据调用结果返回一个字符串。&lt;/p&gt;
&lt;p&gt;    由于在框架里，我们模拟了在三台机器上部署服务的场景，而在上述服务调用者的代码里，我们又在template对象上加入了@LoadBalanced注解，所以在上述第13行代码里发起的请求会被均摊到三台服务器上。&lt;/p&gt;
&lt;p&gt;    需要注意的是，这里我们没有重写IRule和IPing接口，所以这里是采用了默认的RoundRobbin（也就是轮询）的访问策略，同时将默认所有的服务器都处于可用状态。&lt;/p&gt;
&lt;p&gt;    依次启动本框架中的Eureka服务器，三台服务提供者和服务器调用者的服务之后，在浏览器里输入http://localhost:8888/，我们能看到如下图所示的效果。&lt;/p&gt;
&lt;p&gt;    在其中，我们能看到有三个提供服务的SAYHELLO应用实例，它们分别运行在1111,2222和3333端口上，同时，服务调用者CALLHELLO则运行在8080端口上。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180506212557669-739742573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如果我们不断在浏览器里输入http://localhost:8080/hello，那么能依次看到如下所示的输出。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
1    In Caller, Hello Ribbon, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; is Server2, my name is:Eureka
&lt;/span&gt;2    In Caller, Hello Ribbon, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; is Server1, my name is:Eureka
&lt;/span&gt;3    In Caller, Hello Ribbon, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; is Server3, my name is:Eureka
&lt;/span&gt;4    In Caller, Hello Ribbon, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; is Server2, my name is:Eureka
&lt;/span&gt;5    In Caller, Hello Ribbon, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; is Server1, my name is:Eureka
&lt;/span&gt;6    In Caller, Hello Ribbon, &lt;span&gt;this&lt;/span&gt;&lt;span&gt; is Server3, my name is:Eureka
&lt;/span&gt;7    …
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    从上述输出来看，请求是以Server2，Server1和Server3的次序被均摊到三台服务器上。在每次启动服务后，可能承接请求的服务器次序会有所变化，可能下次是按Server1，Server2和Server3的次序，但每次都能看到“负载均衡”的效果。&lt;/p&gt;
&lt;h4&gt;5 重写IRule和IPing接口&lt;/h4&gt;
&lt;p&gt;    这里，我们将在上述案例的基础上，重写IRule和IPing接口里的方法，从而实现自定义负载均衡和判断服务器是否可用的规则。&lt;/p&gt;
&lt;p&gt;    请注意，由于我们是在客户端，也就是EurekaRibbonDemo-ServiceCaller这个项目调用服务，所以本部分的所有代码是写在这个项目里的。&lt;/p&gt;
&lt;p&gt;    步骤一，编写包含负载均衡规则的MyRule.java，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;package&lt;/span&gt; com.controller; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请注意这个package路径&lt;/span&gt;
2&lt;span&gt;    省略必要的import语句
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyRule &lt;span&gt;implements&lt;/span&gt; IRule {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现IRule类&lt;/span&gt;
4        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ILoadBalancer lb;
&lt;/span&gt;5         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须要重写这个choose方法&lt;/span&gt;
6        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Server choose(Object key) {
&lt;/span&gt;7            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到0到3的一个随机数，但不包括3&lt;/span&gt;
8            &lt;span&gt;int&lt;/span&gt; number = (&lt;span&gt;int&lt;/span&gt;)(Math.random() * 3&lt;span&gt;);
&lt;/span&gt;9            System.out.println(&quot;Choose the number is:&quot; +&lt;span&gt; number);
&lt;/span&gt;10            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到所有的服务器对象&lt;/span&gt;
11            List&amp;lt;Server&amp;gt; servers =&lt;span&gt; lb.getAllServers();
&lt;/span&gt;12            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据随机数，返回一个服务器&lt;/span&gt;
13            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; servers.get(number);        
&lt;/span&gt;14&lt;span&gt;        }
&lt;/span&gt;15&lt;span&gt;         省略必要的get和set方法
&lt;/span&gt;16    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在上述代码的第3行里，我们实现了IRule类，并在其中得第6行里，重写了choose方法。&lt;/p&gt;
&lt;p&gt;    在这个方法里，我们在第8行通过Math.random方法，得到了0到3之间的一个随机数，包括0，但不包括3，并用这个随机数在第13行返回了一个Server对象，以此实现随机选择的效果。在实际的项目里，还可以根据具体的业务逻辑choose方法，以实现其它的“选择服务器”的策略。&lt;/p&gt;
&lt;p&gt;    第二步，编写判断服务器是否可用的MyPing.java，代码如下。   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;package&lt;/span&gt; com.controller; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;也请注意这个package的路径&lt;/span&gt;
2&lt;span&gt;    省略import语句
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyPing &lt;span&gt;implements&lt;/span&gt; IPing { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是实现IPing类&lt;/span&gt;
4        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写了判断服务器是否可用的isAlive方法 &lt;/span&gt;
5        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAlive(Server server) {
&lt;/span&gt;6            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是生成一个随机数，以此来判断该服务器是否可用 &lt;/span&gt;
7            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还可以根据服务器的相应时间等依据，判断服务器是否可用&lt;/span&gt;
8            &lt;span&gt;double&lt;/span&gt; data =&lt;span&gt; Math.random();
&lt;/span&gt;9            &lt;span&gt;if&lt;/span&gt; (data &amp;gt; 0.6&lt;span&gt;) {
&lt;/span&gt;10                System.out.println(&quot;Current Server is available, Name：&quot; + server.getHost() + &quot;, Port is:&quot; +&lt;span&gt; server.getHostPort());
&lt;/span&gt;11                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;12            } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;13                System.out.println(&quot;Current Server is not available, Name：&quot; + server.getHost() + &quot;, Port is:&quot; +&lt;span&gt; server.getHostPort());
&lt;/span&gt;14                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;15&lt;span&gt;            }
&lt;/span&gt;16&lt;span&gt;        }
&lt;/span&gt;17    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第3行里，我们是实现了IPing这个接口，并在第5行重写了其中的isAlive方法。&lt;/p&gt;
&lt;p&gt;    在这个方法里，我们是根据一个随机数，来判断该服务器是否可用，如果可用，则返回true，如反之则返回false。请注意，这仅仅是个演示的案例，在实际项目里，我们基本上是不会重写isAlive方法的。&lt;/p&gt;
&lt;p&gt;    第三步，改写application.yml，在其中添加关于MyPing和MyRule的配置，代码如下。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    spring:
&lt;/span&gt;2&lt;span&gt;      application:
&lt;/span&gt;3&lt;span&gt;        name: callHello
&lt;/span&gt;4&lt;span&gt;    server:
&lt;/span&gt;5      port: 8080
6&lt;span&gt;    eureka: 
&lt;/span&gt;7&lt;span&gt;      client:
&lt;/span&gt;8&lt;span&gt;        serviceUrl:
&lt;/span&gt;9          defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/&lt;/span&gt;
10&lt;span&gt;    sayHello:
&lt;/span&gt;11&lt;span&gt;      ribbon:
&lt;/span&gt;12&lt;span&gt;        NFLoadBalancerRuleClassName: com.controller.MyRule
&lt;/span&gt;13&lt;span&gt;        NFLoadBalancerPingClassName: com.controller.MyPing
&lt;/span&gt;14&lt;span&gt;        listOfServers: 
&lt;/span&gt;15    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:1111/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:2222/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:3333&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    改动点是从第10行到第13行，请注意这里的SayHello需要和服务提供者给出的“服务名”一致，在第12和13行里，分别定义了本程序（也就是服务调用者）所用到的IRule和IPing类，配置时需要包含包名和文件名。&lt;/p&gt;
&lt;p&gt;    第四步，改写Controller.java和这个控制器类，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    省略必要的package和import代码
&lt;/span&gt;2&lt;span&gt;    @RestController
&lt;/span&gt;3&lt;span&gt;    @Configuration
&lt;/span&gt;4    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Controller {
&lt;/span&gt;5        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以Autowired的方式引入loadBalanceerClient对象    &lt;/span&gt;
6&lt;span&gt;        @Autowired  
&lt;/span&gt;7        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LoadBalancerClient loadBalancerClient; 
&lt;/span&gt;8        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给RestTemplate对象加入@LoadBalanced注解&lt;/span&gt;
9        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以此赋予该对象负载均衡的能力 &lt;/span&gt;
10&lt;span&gt;        @Bean
&lt;/span&gt;11&lt;span&gt;        @LoadBalanced
&lt;/span&gt;12        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate getRestTemplate()
&lt;/span&gt;13        { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();   }
&lt;/span&gt;14            @Bean &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入MyRule&lt;/span&gt;
15        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule()
&lt;/span&gt;16        { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRule();}
&lt;/span&gt;17        @Bean &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入MyPing&lt;/span&gt;
18        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IPing ribbonpIng() 
&lt;/span&gt;19        {  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyPing();}
&lt;/span&gt;20        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编写提供服务的hello方法&lt;/span&gt;
21        @RequestMapping(value = &quot;/hello&quot;, method =&lt;span&gt; RequestMethod.GET    )
&lt;/span&gt;22        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello() {
&lt;/span&gt;23             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入策略，这里的sayHello需要和application.yml&lt;/span&gt;
24             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第10行的sayHello一致，这样才能引入MyPing和MyRule&lt;/span&gt;
25            loadBalancerClient.choose(&quot;sayHello&quot;&lt;span&gt;);
&lt;/span&gt;26            RestTemplate template =&lt;span&gt; getRestTemplate();
&lt;/span&gt;27            String retVal = template.getForEntity(&quot;http://sayHello/sayHello/Eureka&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).getBody();
&lt;/span&gt;28            &lt;span&gt;return&lt;/span&gt; &quot;In Caller, &quot; +&lt;span&gt; retVal;
&lt;/span&gt;29&lt;span&gt;        }
&lt;/span&gt;30    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    和之前的代码相比，我们添加了第15行和第18行的两个方法，以此引入自定义的MyRule和MyPing两个方法。&lt;/p&gt;
&lt;p&gt;    而且，在hello方法的第15行里，我们通过choose方法，为loadBalancerClient这个负载均衡对象选择了MyRule和MyPing这两个规则。&lt;/p&gt;
&lt;p&gt;    如果依次启动Eureka服务器，注册在Eureka里的三个服务提供者和服务调用者之后，在浏览器里输入http://localhost:8080/hello，那么能在EurekaRibbonDemo-ServiceCaller的控制台里看到类似于如下的输出。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1    Choose the number is:1
2    Choose the number is:0
3    Current Server is not available, Name：192.168.42.1, Port is:192.168.42.1:2222
4    Current Server is available, Name：192.168.42.1, Port is:192.168.42.1:3333
5    Current Server is not available, Name：192.168.42.1, Port is:192.168.42.1:1111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    第1和第2行是MyRule里的输出，而第3到第5行是MyPing里的输出，由于这些输出是和随机数有关，所以每次输出的内容未必一致，但至少能说明，我们在MyRule和MyPing里配置的相关策略是生效的，服务调用者（EurekaRibbonDemo-ServiceCaller）的多次请求在以“负载均衡”的方式分发到各服务提供者时，会引入我们定义在上述两个类里的策略。&lt;/p&gt;

&lt;h4&gt;本文所给出的代码均可运行，此外，本文内容摘自本人所写的专业书籍，转载时请同时引入该版权申明，请勿用于商业用途。&lt;/h4&gt;



</description>
<pubDate>Sun, 06 May 2018 13:32:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8999772.html</dc:identifier>
</item>
<item>
<title>教你一步步发布一个开源库到 JCenter - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/8999768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/8999768.html</guid>
<description>&lt;p&gt;今天想来分享下，如何一步步自己发布一个开源库到 JCenter&lt;/p&gt;
&lt;p&gt;这方面的博客网上已经特别多了，所以本篇并不打算仅仅只是记录流程步骤而已，而是尽可能讲清楚，为什么需要有这个步骤，让大伙知其然的同时还知其所以然，那么掌握就会更深刻一点，所以本篇篇幅会很长。另外，本篇是参考、引用、借鉴了以下文章中的内容：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://inthecheesefactory.com/blog/how-to-upload-library-to-jcenter-maven-central-as-dependency/en&quot;&gt;How to distribute your own Android library through jCenter and Maven Central from Android Studio&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然是英文版，但有四级基础就可以基本看懂了，文章写得很全，很详&lt;/p&gt;
&lt;p&gt;实在不想看英文版的，国内有中文版翻译，在&lt;strong&gt;&lt;em&gt;《Android高级进阶》&lt;/em&gt;&lt;/strong&gt;的第 9 章有完整版的中文翻译&lt;/p&gt;

&lt;p&gt;首先得想清楚一件事：&lt;strong&gt;是不是只有写得很牛的开源库，或者只有牛人、大神才可以发布开源库到 JCenter呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能有些人觉得自己不是大神，自己写不出啥牛逼的开源库，所以不用发布到 JCenter 上给别人用。所以，得先想清楚，你为什么要发布一个开源库到 JCenter 上去？&lt;/p&gt;
&lt;p&gt;学习也行；分享也行；自己用也行；总之，没什么规定说只有大神才可以发布；&lt;/p&gt;
&lt;p&gt;其实，这里之所以叫做开源库，是因为发布到 JCenter 上之后，大伙都可以使用的原因。我更喜欢在《Android高级进阶》里的说法：函数库&lt;/p&gt;
&lt;p&gt;我是带着这么一种想法的：&lt;/p&gt;
&lt;p&gt;作为一个懒人，一些可以在多个项目中使用的公共基础模块，实在不想每次新建项目都手动去复制粘贴，或者手动去导 Module，所以就想着将这些公共基础模块打包发布到 JCenter，以后新建项目时只要配置下 build.gradle 就可以了&lt;/p&gt;
&lt;p&gt;Q：你问我为啥不上传到私服？&lt;/p&gt;
&lt;p&gt;A：没钱&lt;/p&gt;
&lt;p&gt;Q：你问我那不怕代码被盗用？&lt;/p&gt;
&lt;p&gt;A：又不是什么牛逼的开源库，就是一些基本的公共模块如工具类，网络层封装等等，别人想用，我高兴还来不及，怕啥&lt;/p&gt;
&lt;p&gt;Q：你问我那这些基础模块为啥不用别人开源的，还要自己造轮子？&lt;/p&gt;
&lt;p&gt;A：自己的用着顺手，自己的想怎么改就可以怎么改&lt;/p&gt;
&lt;p&gt;Q：你问我那不怕发布的开源库代码太槽糕，被人骂？&lt;/p&gt;
&lt;p&gt;A：老哥，我又不是大神，我要不写这篇博客，都没人知道我发布了个开源库，反正就我自己使用，怕啥&lt;/p&gt;
&lt;p&gt;Q：你问我...&lt;/p&gt;
&lt;p&gt;A：老哥，别问了，赶快去发布一个试试看吧，万一以后你就是大神了呢，省得到时再现学&lt;/p&gt;
&lt;p&gt;好了，接下去就开始讲发布的步骤了&lt;/p&gt;

&lt;p&gt;先盗用开头分享的链接里的一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-3cb9b85a3c2d7efb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;流程.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个流程其实就是上图中介绍的这样，先本地打包成 jar 或 aar 文件，然后上传到 bintray 自己的仓库中，最后发布到 jcenter 上去就可以了。&lt;/p&gt;
&lt;p&gt;除了第一步是在本地自己操作外，剩下的操作都是在网页上移移鼠标点一点就可以了&lt;/p&gt;
&lt;h3 id=&quot;第-0-步jcenter-网址&quot;&gt;第 0 步：JCenter 网址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://bintray.com/&quot; class=&quot;uri&quot;&gt;https://bintray.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jcenter.bintray.com/&quot; class=&quot;uri&quot;&gt;https://jcenter.bintray.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么会有两个呢？那是因为，第一个是提供给我们可 ui 交互操作的网站，注册账号、配置仓库、发布等等操作都是在第一个网址上面操作，我们也只要记住第一个网站就可以了&lt;/p&gt;
&lt;p&gt;第二个是存放这些开源库的网址，如果你想手动下载某个开源库的 jar，那么你可以直接在第二个网址后面加上开源库的路径即可&lt;/p&gt;
&lt;p&gt;比如，我之前写过一篇 &lt;a href=&quot;https://www.jianshu.com/p/28bb90e565de&quot;&gt;如何用Android Studio查看build.gradle源码&lt;/a&gt;，某些情况下，Android Studio 并没有成功将 Android Gradle 插件的源码下载下来，我们又想去查看源码时，只能自己去下载。写那篇博客的时候 Android Studio 还是默认配置的 mavenCentral 作为开源库拉取来源的。&lt;/p&gt;
&lt;p&gt;但现在新版的 Android Studio 已经改成默认配置 JCenter 作为开源库的来源了，举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;compile 'com.squareup.okhttp:okhttp:2.4.0'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想手动下载 okhttp 的 jar 包，那么就是访问：&lt;a href=&quot;https://jcenter.bintray.com/com/squareup/okhttp/okhttp/2.4.0/&quot; class=&quot;uri&quot;&gt;https://jcenter.bintray.com/com/squareup/okhttp/okhttp/2.4.0/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以此类推&lt;/p&gt;
&lt;h3 id=&quot;第-1-步注册账号-创建仓库&quot;&gt;第 1 步：注册账号 &amp;amp; 创建仓库&lt;/h3&gt;
&lt;h5 id=&quot;注册账号&quot;&gt;1.1 注册账号&lt;/h5&gt;
&lt;p&gt;打开 &lt;a href=&quot;https://bintray.com/&quot; class=&quot;uri&quot;&gt;https://bintray.com/&lt;/a&gt; 网站，注册一个账号，也可以选择直接 Github 账号授权登录，很简单，不贴图了。&lt;/p&gt;
&lt;h5 id=&quot;创建仓库&quot;&gt;1.2 创建仓库&lt;/h5&gt;
&lt;p&gt;登录账号后，跟 Github 操作类似，bintray 允许你在网站上创建自己的仓库，可 public，可 private。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-ba409ef729313a17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建模块.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建仓库的操作跟 Github 是类似的，我就不演示了，我这里创建了一个叫 base-module 的空仓库。&lt;/p&gt;
&lt;p&gt;接下去就跟 Github 的概念有点不一样了，在 Github 上我们一个仓库通常对应一个具体的项目，本地项目长啥样，Github 上的仓库基本也就长啥样。&lt;/p&gt;
&lt;p&gt;在 bintray 这里，一个仓库我更倾向于把它就理解成仓库的意思，也就是作为容器的作用。创建完一个空仓库后，页面右下角会有一个 &lt;strong&gt;Add New Package&lt;/strong&gt; 按钮，也就是仓库下面还有一层 package 的概念。&lt;/p&gt;
&lt;p&gt;一个 package 就是一个可发布到 JCenter 上的开源包，而发布到 JCenter 上的内容是一些 pom，aar，jar 之类的文件，并不是整个项目。所以我们需要先创建一个 package 来准备给本地需要打包发布的 module 生成 pom，aar 等文件的存放地了。&lt;/p&gt;
&lt;h3 id=&quot;第-2-步配置本地-gradle-脚本插件&quot;&gt;第 2 步：配置本地 gradle 脚本插件&lt;/h3&gt;
&lt;p&gt;上传到 Github 上的是整个项目的源码，而上传到 bintray 上的是 pom， jar，arr 这类文件。&lt;/p&gt;
&lt;p&gt;所以，在发布开源库到 JCenter 之前，我们需要先在本地将要发布的 Module 打包成 jar, aar。那么，在本地要怎么操作呢？就像 Google 提供了 Android Gradle 插件来方便开发者直接对项目进行编译一样，bintray 也提供了相对应的 gradle 插件，来方便我们直接在本地打包成 jar。&lt;/p&gt;
&lt;p&gt;同样，Github 支持通过 Git 来将本地项目上传到 Github 上，而 bintray 也提供了对应的 gradle 脚本来让开发者将本地打包后的 jar 等上传至 bintray 网站上的仓库中。&lt;/p&gt;
&lt;p&gt;这就是为什么我们需要在本地配置一些 gradle 插件的原因，一者方便开发者对项目进行编译、打包成所需的文件；二者通过它提供的桥梁上传至 bintray 网站上的仓库。&lt;/p&gt;
&lt;h5 id=&quot;配置-gradle-插件地址&quot;&gt;2.1 配置 gradle 插件地址&lt;/h5&gt;
&lt;p&gt;使用 Android Gradle 插件，需要在根项目的 build.gradle 文件中配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    classpath 'com.android.tools.build:gradle:2.3.3'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的道理，要使用 bintray gradle 插件，同样也得在&lt;strong&gt;根项目的 build.gradle 文件中配置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; dependencies {
    //Android Gradle 插件
    classpath 'com.android.tools.build:gradle:2.3.3'
    //bintray 插件
    classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.4'
    classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1'
    //android-maven-gradle-plugin:1.3版本有bug，网上很多例子用的这个版本，编译的时候可能会出错，改一下版本就好了
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，只是配置了插件的路径，那么使用插件的地方肯定就是在对应 module 下的 build.gradle 文件中了&lt;/p&gt;
&lt;h5 id=&quot;使用-gradle-插件&quot;&gt;2.2 使用 gradle 插件&lt;/h5&gt;
&lt;p&gt;gradle 插件使用的地方都是在&lt;strong&gt;每个具体 module 下的 build.gradle 文件&lt;/strong&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apply plugin: 'com.android.library'

android {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是常见的 build.gradle 文件，这表示的是，将会使用 Android gradle 插件中 id 为 com.android.library 的 gradle 插件来将该 Module 构建成一个 library，而 build.gradle 里其他配置项如 android 等则表示构建该项目所需的一些配置，这是我对 gradle 的理解（不知道对不对）。&lt;/p&gt;
&lt;p&gt;同样，因为上传到 bintray 的是一些 pom, jar 文件，所以我们也需要在这个 build.gradle 中使用 bintray 提供的插件来编译，打包项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//切记：以下代码必须放在 build.gradle 文件末尾
apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle'
apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上 apply from 指的是该 module 需要使用一个存储于网上的 gradle 脚本文件来根据各种配置项来编译、打包项目。&lt;/p&gt;
&lt;p&gt;之所以这个 gradle 脚本文件存储在网络上，纯粹是因为 bintray 担心我们不知道怎么使用它提供的 gradle 插件来生成 pom, jar 等文件，所以连模板脚本都提供给我们了（这是我的理解）。&lt;/p&gt;
&lt;p&gt;所以，你可以将 apply from 后面的链接在网页上输入看看，你会看到以下脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//以下代码大概瞄一眼即可，不用细看
apply plugin: 'com.github.dcendents.android-maven'

group = publishedGroupId //开源库的 groupId

install {
    repositories.mavenInstaller {
        // This generates POM.xml with proper parameters
        pom {
            project {
                packaging 'aar'//将项目打包成 aar
                groupId publishedGroupId
                artifactId artifact

                // Add your description here
                name libraryName
                description libraryDescription
                url siteUrl

                // Set your license
                licenses {
                    license {
                        name licenseName
                        url licenseUrl
                    }
                }
                developers {
                    developer {
                        id developerId
                        name developerName
                        email developerEmail
                    }
                }
                scm {
                    connection gitUrl
                    developerConnection gitUrl
                    url siteUrl

                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个将项目打包成 arr，并生成项目的 pom.xml 文件的脚本，这些文件都是要上传到 bintray 网站上你的仓库中去的。&lt;/p&gt;
&lt;p&gt;所以，如果你知道使用 bintray gradle 插件都需要进行哪些配置的话，你完全可以自己在 build.gradle 将上述脚本中所需的配置直接写上就好，不用使用 apply from；或者，你根据 apply from 后面的链接将脚本代码复制粘贴到 build.grale 文件中也行。&lt;/p&gt;
&lt;p&gt;同样的道理，另外一个 apply from 所提供的 gradle 脚本内容我就不截图了，那个脚本的作用是用于将生成的 pom, aar 等文件上传至你的 bintray 网站的仓库中去的。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;bintray 提供了两个 gradle 插件，一个用于将本地项目编译，打包成 aar，并生成所需的 pom.xml 等文件；另一个用于将生成的这些文件都上传至你的 bintray 仓库中去。同时，bintray 还提供了两份脚本配置模板，如果不懂得怎么使用，就参照这两份模板来就行了&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;修改-gradle-脚本模板文件中的配置项&quot;&gt;2.3 修改 gradle 脚本模板文件中的配置项&lt;/h5&gt;
&lt;p&gt;既然提供的仅仅是模板文件，那么具体的配置项肯定是需要我们根据自己的实际项目来进行配置的。有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不使用 apply from，直接将脚本模板文件里的代码拷贝至 build.gradle 中，然后根据具体项目，手动修改每一个配置项（略麻烦，不推荐）&lt;/li&gt;
&lt;li&gt;脚本模板文件中，每一个配置项都使用了对应的变量来配置，那么我们只需在 build.gradle 中声明这些变量，并对变量进行赋值，就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Android Gradle 编译项目的用法其实就是第一种，但由于我们对 android 项目编译要配置的项都挺熟悉了，加上 Android Studio 会自动生成一些必要的配置项，所以并不麻烦。但由于对 bintray gradle 插件的配置项不熟，个人不建议这里也使用这种方式。&lt;/p&gt;
&lt;p&gt;而第二种方式，如果你有兴趣再去网上搜索下其他的这类教程的文章，可能你会发现，很多文章都会让你在 build.gradle 文件中写这么一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//下一步会具体来看每个配置项含义
ext {
    bintrayRepo = 'maven'
    bintrayName = 'fb-like'

    publishedGroupId = 'com.inthecheesefactory.thecheeselibrary'
    libraryName = 'FBLike'
    artifact = 'fb-like'

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以理解，为什么他们要你写这段代码了吧。因为 bintray 提供的脚本模板文件中，对它所需的配置项都使用了相对应的变量，那么我们如果直接使用脚本模板文件，就需要对这些变量进行声明并赋值，也就是说在 ext 中 声明的 bintrayRepo, libraryName 等等这些变量，其实都是因为它们在 bintray 提供的脚本模板文件中被使用了。&lt;/p&gt;
&lt;p&gt;另外，由于 gradle 脚本是按顺序执行代码，所以声明这些变量的代码必须在 apply from 代码之前，否则如果先执行了 apply from，会报找不到相对应的变量错误。&lt;/p&gt;
&lt;p&gt;还有一点，bintray gradle 插件源码我没去深入看，但要让项目生成对应的 pom 项目说明文件，以及打包成 aar，所以我猜测，这表明 bintray gradle 插件内部除了脚本模板上所列的各种配置项外，还需要 Android Gradle 插件的一些配置项，比如 build.gradle 里的 android 块配置项。&lt;/p&gt;
&lt;p&gt;这也是为什么其他文章里提到说，要将 apply from 这几行代码放在 build.gradle 最后的原因。因为 gradle 脚本是按顺序执行代码，而 bintray gradle 插件的运行又依赖于一些 android 配置项，所以如果将 apply from 放在开头的话，会报找不到一些变量的错误。&lt;/p&gt;
&lt;h5 id=&quot;将变量的声明赋值代码写在单独的脚本文件中可选&quot;&gt;2.3.2 将变量的声明赋值代码写在单独的脚本文件中（可选）&lt;/h5&gt;
&lt;p&gt;如果不想让 build.gradle 文件中有太多跟编译项目本身无关的代码，那么可以将跟 bintray gradle 插件相关的代码都单独写在另外一个 gradle 文件中，然后在该 build.gradle 开头通过 apply from 将那个 gradle 文件应用进来即可，有点类似于 import 的概念。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//build.gradle 文末
//bintray-config.gradle 就是跟 build.gradle 同层目录下的一个 gradle 文件，里面就是单纯将 exe {} 这块代码里的变量声明和赋值拷贝至 bintray-config.gradle 文件里
apply from: 'bintray-config.gradle'
apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/bintrayv1.gradle'
apply from: 'https://raw.githubusercontent.com/nuuneoi/JCenter/master/installv1.gradle'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第-3-步设置-gradle-插件中各种配置项&quot;&gt;第 3 步：设置 gradle 插件中各种配置项&lt;/h3&gt;
&lt;p&gt;第 2 步在于配置各种所需的 gradle 插件以及如何使用，至于脚本模板的每一行代码，感兴趣的可以去深究，但不去管也么事，反正大概知道两个脚本都干了什么事就行，怎么干的就不用去管了。&lt;/p&gt;
&lt;p&gt;那么接下去就该了解一下，都需要对项目进行哪些属性的配置，这些插件才可以正常运行，才可以正常的将开源库上传至 bintray 上的仓库去：&lt;/p&gt;
&lt;h5 id=&quot;各种基本配置项&quot;&gt;3.1 各种基本配置项&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;ext {
    //bintray 网站上你创建的仓库的名字（必配项）
    bintrayRepo = 'base-module'
    //在这个仓库下的 package name（必配项）
    bintrayName = 'tv'
    //以上两项均只是指向 bintray 网站上你的仓库和仓库下的package

    //publishedGroupId:artifact:libraryVersion 构成你开源库的唯一路径
    //例如：com.dasu.tv:tv:0.0.1，在build.gradle里就可以根据这个路径来compile依赖库了
    //以下三项均是必配项
    publishedGroupId = 'com.dasu.tv'
    artifact = 'tv'
    libraryVersion = '0.0.1'

    //以下三项只是对开源库的描述（应该不是必配项吧，没尝试过）
    libraryName = 'tv'
    libraryDescription = 'dasu 封装的常用，可公用的 tvui 库'
    siteUrl = 'https://github.com/woshidasusu/base-module/tree/master/tv'

    //开源库对应的 github 地址，不知道可不可以不配，应该也是必配
    gitUrl = 'https://github.com/woshidasusu/base-module.git'

    //开发者信息，也是必配的吧
    developerId = 'dasu'
    developerName = 'dasu'
    developerEmail = '295207731@qq.com'

    //这部分可以不用改，我也不大懂这些开源协议，但应该都一样
    licenseName = 'The Apache Software License, Version 2.0'
    licenseUrl = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
    allLicenses = [&quot;Apache-2.0&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就像 build.gradle 文件一样，有些属性必须配置后项目才可以正常编译，运行。要使用 bintray gradle 插件来进行生成对应的 pom，aar 文件，上传到 bintray 仓库等功能，也必须进行一些属性配置才行。&lt;/p&gt;
&lt;p&gt;总之，对应在 bintray 仓库的信息肯定需要配置，发布到 JCenter 后的唯一路径也需要配置，开发者信息当然也需要，其他还需要一些开源库的描述信息以及开源协议信息。&lt;/p&gt;
&lt;h5 id=&quot;配置身份验证信息敏感信息&quot;&gt;3.2 配置身份验证信息（敏感信息）&lt;/h5&gt;
&lt;p&gt;经常使用 Github 肯定还觉得需要关键的用户跟秘钥信息是不是，否则使用 Git 上传项目到 Github 上时没办法进行身份验证。&lt;/p&gt;
&lt;p&gt;同样的道理，要将经过 bintray gradle 插件生成的 pom，aar 等上传到 bintray 仓库，同样需要进行身份验证，那么就配置一些用户名和 key 的关键信息，但这些信息又极其敏感，隐私，所以只能配置在本地文件中。&lt;/p&gt;
&lt;p&gt;如果不修改那两份脚本模板文件的话，那么这些信息就需要配置在项目的根目录下面的 &lt;strong&gt;local.properties&lt;/strong&gt; 文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//根目录下的local.properties文件 
bintray.user= woshidasusu
bintray.apikey= XXXXXXX&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bintray.user 就是你的 bintray 网站的登录账号，如果你用 Github 授权登录，就是你的 Github 账号。&lt;/p&gt;
&lt;p&gt;bindtray.apikey 需要进入 bintray 网站你的设置里去查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-807b30b8f74afb82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;APIkey.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能你在看别人写的教程文章时，会发现他们在这里还配置了一个&lt;/p&gt;
&lt;p&gt;bintray.gpg.password=YOUR_GPG_PASSWORD&lt;/p&gt;
&lt;p&gt;这个应该是用于将 bintray 上的开源库同步发布到 mavenCentral 仓库里的验证信息吧，反正我测试过，我没配置这个，还是可以正常将本地开源库上传至 bintray 并发布到 JCenter 上面去。&lt;/p&gt;
&lt;h3 id=&quot;第-4-步执行-gradle-脚本&quot;&gt;第 4 步：执行 gradle 脚本&lt;/h3&gt;
&lt;p&gt;好了，bintray gradle 插件我们配置好了，它运行所需的各种属性我们也配置好了，那么接下去就只是执行它而已了&lt;/p&gt;
&lt;p&gt;如果本地有配置 gradle 环境的话，那么直接在 cmd 中以命令行的形式执行脚本即可。&lt;/p&gt;
&lt;p&gt;如果没有配置 gradle 环境，那么每个项目的根目录下都有个 gradle 文件夹，里面有 gradle 命名行执行所需的文件，所以可以直接在 Android Studio 的 Terminal 里直接以命令行的形式执行对应脚本即可，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-bcb056d29fd6ba08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;terminal.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如何运行 bintray gradle 插件的脚本呢？只需记录两条命令即可：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;gradlew install&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gradlew bintrayUpload&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;gradlew install&lt;/code&gt; 用于将项目编译、打包生成 pom，aar 等文件；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradlew bintrayUpload&lt;/code&gt; 用于将生成的 pom，aar 等文件上传至 bintray 仓库中；&lt;/p&gt;
&lt;p&gt;跟编译、运行项目一样，当按顺序分别执行上述两条脚本命名时，如果运行成功，你可以在日志中看到 &lt;code&gt;BUILD SUCCESSFUL&lt;/code&gt; 信息，同样，如果脚本运行出错，那么就需要根据日志查看是哪里的问题了，通常就是第 2 步跟第 3 步出了一些问题。&lt;/p&gt;
&lt;p&gt;另外，你还可以通过在 build 文件夹下面查看是否有生成对应的文件来判断 &lt;code&gt;gradlew install&lt;/code&gt; 脚本有没有成功执行。然后直接在 bintray 网站你的仓库里查看文件是否有上传来判断 &lt;code&gt;gradlew bintrayUpload&lt;/code&gt; 脚本是否有成功执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-863b87d875c2f1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;outputs.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-ac6c8f515f4f35dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;upload.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第-5-步在-bintray-网站上将-package-发布到-jcenter&quot;&gt;第 5 步：在 bintray 网站上将 package 发布到 JCenter&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-f9e6538346985144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;发布到JCenter.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下去就是最后一步了，登录你的 bintray 账号，进入你的仓库里，找到上传的开源库，然后在页面右下角找到 &lt;strong&gt;Add to JCenter&lt;/strong&gt; 按钮，点击进去，按照要求填写一下开源库说明，然后就静等几个小时，等收到 JCenter 发给你的审核通过邮件，那么就成功了。&lt;/p&gt;
&lt;p&gt;那么这时候，你就可以愉快的在你的新项目中的 build.gradle 文件里直接通过 compile 来将你的开源库依赖到你项目中就可以了。&lt;/p&gt;

&lt;p&gt;以上，就是怎么一步步的将自己的开源库打包发布到 JCenter 的步骤，小结一下，无外乎以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册 bintray 账号（可用 Github 授权登录）&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在 bintray 上创建仓库，在仓库下创建 package&lt;/li&gt;
&lt;li&gt;准备好本地需要打包发布的项目&lt;/li&gt;
&lt;li&gt;在项目中配置 bintray gradle 插件，有两个，一个用于生成 aar，pom 等文件；一个用于将这些文件上传至 bintray 仓库；两个插件均在项目根目录下的 build.gradle 配置插件的 classPath 路径即可&lt;/li&gt;
&lt;li&gt;在要打包发布的那个 Module 下的 build.grale 文件中配置两种插件的使用，可直接使用 apply from 配置存储在网上的脚本文件，也可将这脚本模板文件下载到本地使用&lt;/li&gt;
&lt;li&gt;apply from 必须要在 build.gradle 文件末尾，另外 exe 代码块需要在 apply from 前面，因为脚本模板文件使用的各种变量需要在 exe 块中先进行声明，赋值&lt;/li&gt;
&lt;li&gt;理解 exe 块中的各种配置项的含义&lt;/li&gt;
&lt;li&gt;在 Android Studio 的 Terminal 面板直接执行 gradlew install, gradlew bintrayUpload 命令来执行脚本&lt;/li&gt;
&lt;li&gt;脚本成功执行结束后，即可在 bintray 网站中找到 Add to JCenter 按钮发布到 JCenter，然后静等邮件消息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，还有一篇专门记录我自己在整个过程中遇到的一些问题以及解决方法记录：&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/a7b491c240ef&quot;&gt;发布开源库到JCenter的一些问题记录&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-35fed4659c556352.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;QQ图片20180316094923.jpg&quot;/&gt;&lt;br/&gt;最近刚开通了公众号，想激励自己坚持写作下去，初期主要分享原创的Android或Android-Tv方面的小知识，感兴趣的可以点一波关注，谢谢支持~~&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 13:31:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/8999768.html</dc:identifier>
</item>
<item>
<title>并发编程（五）：CAS - 三杯然诺</title>
<link>http://www.cnblogs.com/sbrn/p/8999709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sbrn/p/8999709.html</guid>
<description>&lt;p&gt;    在atomic包中，大多数类都是借助unsafe类来实现的，如以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger count = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        count.incrementAndGet();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  incrementAndGet()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; incrementAndGet() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; unsafe.getAndAddInt(&lt;span&gt;this&lt;/span&gt;, valueOffset, 1) + 1&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再继续深入getAndInt（）方法，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getAndAddInt(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; var4) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; var5;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            var5 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getIntVolatile(var1, var2);
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.compareAndSwapInt(var1, var2, var5, var5 +&lt;span&gt; var4));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var5;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  在以上代码中我们着重要说的是 compareAndSwapInt(var1, var2, var5, var5 + var4) 这个方法，compareAndSwap，取每个单词首写字母，就是我们经常说的cas。这个方法中有四个参数var1为当前对象，即代码中的count，var2为当前值，如想计算2加上1等于3的操作，var2即为2，var4为增加量，也就是这个例子中的1,var5为调用底层方法得到的底层当前的值，如果没有其他线程改变底层当前值，返回为2，compareAndSwapInt方法的作用为，如果var2（当前值）与var5（底层当前值相等）则将底层值覆盖为底层当前值（var5）+增加量（var4），否则（其他线程更改了底层当前值，var5不等于var2），重新从底层方法取一次var5的值，如此时var5=4，并重新从var1（当前对象）取一次var2的值，如此时var2的值也变为4，则采取相加操作覆盖底层值，如果var2与var5仍不等，则继续循环取值，直到相等为止。 &lt;/p&gt;
&lt;p&gt;  总结一下，CAS操作包含三个操作数，内存位置（V），预期原值（A）和新值（B），如果内存位置的值与预期原值相匹配，处理器会自动将该位置值更新为新值，否则处理器不做任何操作。CAS指令一般都返回该位置的值（有特殊情况只返回是否成功），CAS简而言之就是，我认为位置V应该包含值A，如果包含该值，就将B放到这个位置，否则不更改该位置的值，只告诉我这个位置现在的值即可 。&lt;/p&gt;

&lt;p&gt;  对于getIntVolatile方法和compareAndSwapInt的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getIntVolatile(Object var1, &lt;span&gt;long&lt;/span&gt; var2);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSwapInt(Object var1, &lt;span&gt;long&lt;/span&gt; var2, &lt;span&gt;int&lt;/span&gt; var4, &lt;span&gt;int&lt;/span&gt; var5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可将两个方法都由native修饰，native修饰的方法为底层方法，一般由c语言来实现。&lt;/p&gt;

&lt;p&gt;  锁分为悲观锁和乐观锁，独占锁是一种悲观锁，synchronized是一种独占锁，如果锁被占用，其他需要锁的线程就会被挂起，直到持有锁的线程释放锁，它会产生的问题如下：&lt;/p&gt;
&lt;p&gt;  a、在多线程竞争下，加锁释放锁会导致比较多的上下文切换和调度延时，引起性能问题&lt;/p&gt;
&lt;p&gt;  b、如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险&lt;/p&gt;

&lt;p&gt;  另一种就是乐观锁，它每次执行时并不加锁而是假设没有冲突的去完成操作，如果因为冲突失败就重试，直到成功为止，而客观锁用到的机制就是CAS。虽然CAS可以很高效的解决原子操作，但是CAS仍然存在三大问题：&lt;/p&gt;
&lt;p&gt;  a、ABA问题，如果一个值原来是A，后被改成B，之后又改为A，那么使用CAS进行检查时发现它的值并没有发生变化，但是实际上却发生变化了，ABA问题的解决思路就是使用版本号，在变量面前加上版本号，每次变量更新的时候把版本加一，上面博客中我们提到atomic包中有专门的类来解决ABA问题&lt;/p&gt;
&lt;p&gt;  b、循环时间长开销大。CAS循环如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令则效率会有一定的提升，pause指令有两个作用，推迟流水线执行，使cpu不会消耗过多的执行资源和避免退出循环的时候因内存顺序冲突而引起CPU流水线被清空，提高CPU执行效率&lt;/p&gt;
&lt;p&gt;  c、只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候可以用锁或把多个共享变量合并成一个共享变量来操作或者把多个变量放在一个对象里（atomic包中有对引用类型的原子操作）来进行CAS操作&lt;/p&gt;

</description>
<pubDate>Sun, 06 May 2018 13:17:00 +0000</pubDate>
<dc:creator>三杯然诺</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sbrn/p/8999709.html</dc:identifier>
</item>
</channel>
</rss>