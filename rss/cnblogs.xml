<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ionic3-ng4学习见闻--(多语言方案) - 赵皖华</title>
<link>http://www.cnblogs.com/zwhblog/p/8976399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwhblog/p/8976399.html</guid>
<description>&lt;p&gt;1.安装&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;ng2-&lt;span class=&quot;hljs-keyword&quot;&gt;translate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_989b5f25-67c7-4fa9-958b-d70d88c056f6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_989b5f25-67c7-4fa9-958b-d70d88c056f6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_989b5f25-67c7-4fa9-958b-d70d88c056f6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
npm install ng2-translate --save
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.app.moudle.ts&lt;/p&gt;
&lt;p&gt;引入模块，在下方新增方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_63abeecc-63d1-4d3c-9064-6addb1b371ef&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_63abeecc-63d1-4d3c-9064-6addb1b371ef&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_63abeecc-63d1-4d3c-9064-6addb1b371ef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; import { TranslateModule, TranslateStaticLoader, TranslateLoader } from 'ng2-translate/ng2-translate'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; import { TranslateService } from 'ng2-translate';
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_bcd32f0c-6bee-41e0-ae62-2b8f5acec0b5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在@ngmodule&lt;/p&gt;
&lt;p&gt;imports添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_56cdc485-1b53-44f6-9087-e472e70e83cc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56cdc485-1b53-44f6-9087-e472e70e83cc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56cdc485-1b53-44f6-9087-e472e70e83cc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  TranslateModule.forRoot({
      provide: TranslateLoader,
      useFactory: (createTranslateLoader),
      deps: [Http]
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;provider添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_efb9d09d-4b93-4fe1-8ffb-89f05d2aa693&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_efb9d09d-4b93-4fe1-8ffb-89f05d2aa693&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_efb9d09d-4b93-4fe1-8ffb-89f05d2aa693&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
TranslateService
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;3.app.component.ts&lt;/p&gt;
&lt;p&gt;引入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_64f5ba36-58a6-4251-85a2-418b237d2a4b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_64f5ba36-58a6-4251-85a2-418b237d2a4b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_64f5ba36-58a6-4251-85a2-418b237d2a4b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
import { TranslateService } from 'ng2-translate';
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;构造器注入服务后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_cac9e208-0673-47a5-8092-ac767ab05a60&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cac9e208-0673-47a5-8092-ac767ab05a60&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cac9e208-0673-47a5-8092-ac767ab05a60&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;this&lt;/span&gt;.translate.setDefaultLang('zh');
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;4.新增语言配置文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/962052/201805/962052-20180501153115609-1733660448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/962052/201805/962052-20180501153303379-2055877293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/962052/201805/962052-20180501153305839-1614122931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.login.module.ts&lt;/p&gt;
&lt;p&gt;引入多语言相关模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_e00cf652-f32d-4434-a45f-1660d1e972fc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e00cf652-f32d-4434-a45f-1660d1e972fc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e00cf652-f32d-4434-a45f-1660d1e972fc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
import { TranslateModule} from 'ng2-translate';
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;importers新增&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_53f89c3d-e570-413a-a01e-de6792991af3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_53f89c3d-e570-413a-a01e-de6792991af3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_53f89c3d-e570-413a-a01e-de6792991af3&quot; class=&quot;cnblogs_code_hide&quot;&gt;
&lt;pre&gt;
TranslateModule
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;6.login.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/962052/201805/962052-20180501153519305-831212798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 7.login.ts&lt;/p&gt;
&lt;p&gt;注入服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_beea633b-bef1-425c-86ea-0e2de943d6e6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_beea633b-bef1-425c-86ea-0e2de943d6e6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_beea633b-bef1-425c-86ea-0e2de943d6e6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
import { TranslateService } from 'ng2-translate';
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/962052/201805/962052-20180501154352104-31503116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就到这里了。&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 07:37:00 +0000</pubDate>
<dc:creator>赵皖华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwhblog/p/8976399.html</dc:identifier>
</item>
<item>
<title>计算机存储计量单位解析 - windlike</title>
<link>http://www.cnblogs.com/windlike/p/8976382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/windlike/p/8976382.html</guid>
<description>&lt;h2 id=&quot;一.-预备知识&quot;&gt;一. 预备知识&lt;/h2&gt;
&lt;h3 id=&quot;bit与byte&quot;&gt;1. bit与byte&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1. bit(简记为 b)

    1 bit = 0 or 1 = one binary

2. byte(简记为 B)

    1 byte = 8 bits    1字节,8个二进制位元&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;标准十进制度量体系倍率关系&quot;&gt;2. 标准十进制度量体系倍率关系&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;k (kilo)&lt;/td&gt;
&lt;td&gt;thousand (千)&lt;/td&gt;
&lt;td&gt;1,000&lt;/td&gt;
&lt;td&gt;1e+3&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;M (mega)&lt;/td&gt;
&lt;td&gt;million (百万)&lt;/td&gt;
&lt;td&gt;1,000,000&lt;/td&gt;
&lt;td&gt;1e+6&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;G (giga)&lt;/td&gt;
&lt;td&gt;billion (十亿)&lt;/td&gt;
&lt;td&gt;1,000,000,000&lt;/td&gt;
&lt;td&gt;1e+9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;T (tera)&lt;/td&gt;
&lt;td&gt;trillion (万亿)&lt;/td&gt;
&lt;td&gt;1,000,000,000,000&lt;/td&gt;
&lt;td&gt;1e+12&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;(1e+3=1e3=1x10^3)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二.-两种数据存储容量计算方式&quot;&gt;二. 两种数据存储容量计算方式&lt;/h2&gt;
&lt;h3 id=&quot;microsoft-windows中表示数据存储容量1024倍&quot;&gt;1. Microsoft Windows中表示数据存储容量(1,024倍)&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本条以下KB、MB、GB……正确表示应该是KiB、MiB、GiB…… 原因:微软误用简写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1 KB (Kilobyte) = 2^10 bytes 千字节&lt;/li&gt;
&lt;li&gt;1 MB (Megabyte) = 2^20 bytes 兆字节&lt;/li&gt;
&lt;li&gt;1 GB (Gigabyte = 2^30 bytes 千兆字节或吉字节&lt;/li&gt;
&lt;li&gt;1 TB (Terabyte) = 2^40 bytes 太字节&lt;/li&gt;
&lt;li&gt;1 PB (Petabyte) = 2^50 bytes&lt;/li&gt;
&lt;li&gt;1 EB (Exabyte) = 2^60 bytes&lt;/li&gt;
&lt;li&gt;1 ZB (Zettabyte) = 2^70 bytes&lt;/li&gt;
&lt;li&gt;1 YB (Yottabyte) = 2^80 bytes&lt;/li&gt;
&lt;li&gt;1 BB (Brontobyte) = 2^90 bytes&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;硬盘生厂商大多数结合十进制来计算容量1000倍&quot;&gt;2. 硬盘生厂商(大多数)结合十进制来计算容量(1,000倍)&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这就是在wondows操作系统中显示的容量比厂家标志的容量要小一些的原因(大概少7%,如64GB的U盘在windows上显示接近60GB)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1 KB = 10^3 bytes = 1,000 bytes&lt;/li&gt;
&lt;li&gt;1 MB = 10^6 bytes = 1,000,000 bytes&lt;/li&gt;
&lt;li&gt;1 GB = 10^9 bytes = 1,000,000,000 bytes&lt;/li&gt;
&lt;li&gt;1 TB = 10^12 bytes = 1,000,000,000,000 bytes&lt;/li&gt;
&lt;li&gt;1 PB = 10^15 bytes&lt;/li&gt;
&lt;li&gt;1 EB = 10^18 bytes&lt;/li&gt;
&lt;li&gt;1 ZB = 10^21 bytes&lt;/li&gt;
&lt;li&gt;1 YB = 10^24 bytes&lt;/li&gt;
&lt;li&gt;1 BB = 10^27 bytes&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;混淆起因&quot;&gt;3. 混淆起因&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;由于以上两点原因，1 MB 可能就是1 MB (1,000倍的关系), 也可能是1 MiB(1,024倍的关系)。同样的有1 KB、1MB、1GB……根据具体情况区分就好&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三.-正确表示&quot;&gt;三. 正确表示&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;KiB = Kibibyte = Kilo binary byte&lt;/li&gt;
&lt;li&gt;MiB = Mebibyte = Mega binary byte&lt;/li&gt;
&lt;li&gt;GiB = Gibibyte = Giga binary byte&lt;/li&gt;
&lt;li&gt;TiB = Tibibyte = Tera binary byte&lt;br/&gt;- --&lt;/li&gt;
&lt;li&gt;1 GB = 1,000 MB = 1,000,000 KB = 1,000,000,000 B (1,000倍)&lt;/li&gt;
&lt;li&gt;1 GiB = 1,024 MiB = 1,048,576 KiB = 107,374,1824 B (1,024倍)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;除微软Windows操作系统外，其他操作系统基本上对于存储设备的容量计算方式与硬盘厂商一致,均为1GB = 1,000,000,000 bytes, 避免了计算和使用上的麻烦。linux系统更是对如GiB和GB有严格正确的区分，不会混淆二者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;（本文完）&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 07:34:00 +0000</pubDate>
<dc:creator>windlike</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/windlike/p/8976382.html</dc:identifier>
</item>
<item>
<title>About Windows 10 April 2018 Update - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/8976285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/8976285.html</guid>
<description>&lt;p&gt;在四月的最后一天，微软终于正式发布了 Windows 10 的又一次重大更新，并命名为 Windows 10 四月更新，轮压哨，我软确实谁也不服；再晚一天，我软改名部门恐怕又要发挥作用了，毕竟我软存在感最强部门没有之一。&lt;/p&gt;
&lt;p&gt;言归正传，我们一起来关注一下本次 Windows 10 四月更新都有哪些重大改变。&lt;/p&gt;
&lt;p&gt;在 Windows Blogs 看到一篇文章：&lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/04/27/make-the-most-of-your-time-with-the-new-windows-10-update/#lbvuz8h7ORDiXsSu.97&quot; target=&quot;_blank&quot;&gt;Make the most of your time with the new Windows 10 update&lt;/a&gt;. 是 Windows and Devices Group 的 VP，Yusuf Mehdi 撰写的。重点讲述了全新的 Windows 10 怎么让你更有效更充分的利用你的时间。下面跟大家分享文章的主要观点：&lt;/p&gt;
&lt;p&gt;我们都拥有相同的 24 小时，而现在越来越明显的 24 小时从来都不够用。人们比以前更加觉得不敢重负，几乎所有人都想拥有更多的时间 - 不一定是需要时间去做更多的事，而是需要时间去做我们喜欢做的事。在微软，我们就是想帮助你做到这一点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201805/306530-20180501132213172-1073842664.jpg&quot; alt=&quot;&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在 Windows 10 中，我们专注于提供最现代化和最安全的操作系统。自从首次启动后，我们发布了两项更新，其中的特性旨在为我们每个创作者赋能。而在最新的一次重要更新，也就是 Windows 10 四月更新中，我们想要提供给你最重要的东西 - 时间。我们的愿望是让你有更多的时间去做你最想做的事情，创造，娱乐，工作或简单的做你爱做的事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;时间线 - 帮助你更容易的跨设备找到你关心的事情&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设备的激增，以及信息量的爆炸，导致“屏幕时间”大量涌入。事实上在今天，几乎所有空闲时间都在面对着屏幕。你的信息分布在多个设备上，使得你越来越难找到你要的东西。我们都有过在邮件或者文件系统中寻找文档，或者寻找你想要的照片和视频的经历，但是却没有找到，或者已经不存在了。而时间线能够帮你节约这些被浪费的时间。&lt;/p&gt;
&lt;p&gt;使用时间线，你的 Windows 10 电脑可以让你回到 30 天以前找到你的东西，不管你今天早些时候或者上星期，几个星期前是否在使用它来工作。因为我们大部分的活动都在进行中，当你使用 Windows 10 电脑时，如果你在 iOS 或 Android 设备上使用了 Microsoft Edge 或者 Office 365 来登录你的 Microsoft 账户，你甚至可以使用时间线来选择你整个进行的活动。想象一下，当你正在外出时，正在手机上为你的家庭装修浴室洗手盆做购买选择，然后回到电脑上很快的完成购买。或者在上下班途中，在公共汽车上处理文件，然后在办公电脑上无缝的将其备份。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201805/306530-20180501135754313-1039556630.png&quot; alt=&quot;&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频地址：WIndows 10 April 2018 Update - Timeline &lt;a href=&quot;https://youtu.be/nNdirfTlU4E&quot; target=&quot;_blank&quot;&gt;https://youtu.be/nNdirfTlU4E&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;专注助手 - 帮助保持专注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在，我们大多数人每天都会花 3-6 个小时在屏幕上。而大部分时间都花在社交媒体上，无数的设备不断分散着注意力，使得我们难以集中注意力。在很多方面，我们的注意力正在被吞噬，使我们陷入联系的信息刷屏中，但是却从最重要的事情中分散了注意力。这是一场真实的“战争”，在工作场所，人们在任何单一事件中间或者转换任务前平均会花费三分钟时间（会议之外）。而在被打断后，平均每个人需要 23 分钟来重组任务，我们看到我们的生产力和创造力在下降。&lt;/p&gt;
&lt;p&gt;在本次 Windows 10 四月更新中，我们介绍了专注助手帮你你保持在你的区域。当你想在做事情时不受社交媒体或者其他通知信息打扰时，打开专注助手。或者设置每天专注的时间来自动打开它。当你完成后，你会收到一个在专注时间发生事情的摘要，包括通知，电子邮件或更新。当你正在等待一个特定的电话或邮件时，可以选择这个人脉在专注助手中设置特例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201805/306530-20180501142003424-258036903.png&quot; alt=&quot;&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频地址：WIndows 10 April 2018 Update - Focus Assist &lt;a href=&quot;https://youtu.be/kqIzbqTtT4s&quot; target=&quot;_blank&quot;&gt;https://youtu.be/kqIzbqTtT4s&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Edge 浏览器更新 - 帮助在 Web 浏览中保持专注&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在你可以点击音乐按钮来静音和恢复 Tab 中正在播放的声音。书籍，PDF 和阅读预览页面可以全屏显示，提高阅读中的无中断体验。购物体验变得越来越简单，因为你的地址，支付和其他信息可以被安全的保存和填充，使用 Web 支付表单。现在你可以通过使用全新的无杂乱打印选项以更清晰的格式打印网页，在打印输出中清除混乱。最后，任何需要帮助阅读的人都可以使用新的语法工具按钮来启动理解辅助工具，语法工具可以将页面上的单词分解为音节，并突出显示不同的分类，如名词 动词和形容词。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201805/306530-20180501142857381-1175646301.png&quot; alt=&quot;&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频地址：WIndows 10 April 2018 Update - Microsoft Edge &lt;a href=&quot;https://youtu.be/_XIDCA6BcE8&quot; target=&quot;_blank&quot;&gt;https://youtu.be/_XIDCA6BcE8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;声音作为一种自然输入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自然计算经验可以让我们直接对我们的设备说话来完成任务，不需要键盘输入。我们发现语音输入的潜力可以明显改变人们和设备互动的方式，远远超出新奇体验或娱乐的范畴。&lt;/p&gt;
&lt;p&gt;我们在 Windows 10 四月更新中已经实现的一种方式是口述。现在使用语音来记录一篇笔记或写一篇文章都比以前方便很多。在 Windows 10 或 App 中，把光标置于一个文本区域中，简单的点击“Win+H”就可以开始讲话。提升了的口述特性，可以快速准确的捕捉你的想法。以至于你刚刚和同事即兴聊到的好主意，或者为最好朋友的婚礼练习的演讲永远不会丢失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201805/306530-20180501150123365-1954993313.png&quot; alt=&quot;&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频地址：WIndows 10 April 2018 Update - Dictation &lt;a href=&quot;https://youtu.be/OEEPWIzlI84&quot; target=&quot;_blank&quot;&gt;https://youtu.be/OEEPWIzlI84&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Windows 10 四月更新中，如果启用了 Cortana 功能，你就可以使用自己的声音方便的通过电脑管理你的智能家居设备。例如，你想在一整天的工作之后，回到一个温暖的家吗，只需要点击电脑上的 Cortana，对它说“你好 Cortana，把我的卧室温度稳定在 ×× 度”，这样就能控制智能家居了。&lt;/p&gt;

&lt;p&gt;当然，Windows 10 四月更新中还有更多的新特性，包含在 &lt;a href=&quot;https://www.microsoft.com/en-us/microsoft-365/blog/2018/04/27/making-it-simpler-with-a-modern-workplace/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Simplified IT management tools&lt;/strong&gt;&lt;/a&gt; 中，可以为企业用户提供一种全新的方式去创造照片，3D 和 虚拟现实；提供一种全新的方式保证上网安全，提高 PC 游戏体验。&lt;/p&gt;

&lt;p&gt;而 Windows 10 四月更新将会在 4 月 30 日开始提供免费下载。想象一下，你会如何利用 Windows 10 帮你节约的宝贵时间呢？&lt;/p&gt;

</description>
<pubDate>Tue, 01 May 2018 07:34:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/8976285.html</dc:identifier>
</item>
<item>
<title>WebRTC 音频算法 附完整C代码 - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/8976346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/8976346.html</guid>
<description>&lt;p&gt;WebRTC提供一套音频处理引擎，&lt;/p&gt;
&lt;p&gt;包含以下算法：&lt;/p&gt;
&lt;p&gt;AGC自动增益控制(Automatic Gain Control)&lt;/p&gt;
&lt;p&gt;ANS噪音抑制(Automatic Noise Suppression)&lt;/p&gt;
&lt;p&gt;AEC是声学回声消除(Acoustic Echo Canceller for Mobile)&lt;/p&gt;
&lt;p&gt;VAD是静音检测(Voice Activity Detection)&lt;/p&gt;
&lt;p&gt;这是一套非常经典，以及值得细细品阅学习的音频算法资源。&lt;/p&gt;
&lt;p&gt;在前面分享的博文，也有提及音频相关知识点。&lt;/p&gt;
&lt;p&gt;一些算法优化的知识点，由于历史的原因，&lt;/p&gt;
&lt;p&gt;WebRTC的实现已经不是当下最优的思路。&lt;/p&gt;
&lt;p&gt;但也是非常经典的。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;AGE算法中的WebRtcSpl_Sqrt  快速开平方的实现。&lt;/p&gt;
&lt;p&gt;可以采用如下汇编函数替换之：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fast_sqrt(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; x) {
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; defined(__x86_64__)&lt;span&gt;
    __asm__ __volatile__ (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sqrtss %1, %0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;(s) : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(x));
&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; defined(__i386__)&lt;span&gt;
    s &lt;/span&gt;=&lt;span&gt; x;
    __asm__ __volatile__ (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fsqrt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(s));
&lt;/span&gt;&lt;span&gt;#elif&lt;/span&gt; defined(__arm__) &amp;amp;&amp;amp; defined(__VFP_FP__)&lt;span&gt;
    __asm__ __volatile__ (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vsqrt.f32 %0, %1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;(s) : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(x));
&lt;/span&gt;&lt;span&gt;#else&lt;/span&gt;&lt;span&gt;
    s &lt;/span&gt;=&lt;span&gt; sqrtf(x);
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现代很多cpu 汇编指令已经支持开平方的快速实现，&lt;/p&gt;
&lt;p&gt;经过测试比对确实会比WebRtcSpl_Sqrt 快不少的。&lt;/p&gt;
&lt;p&gt;关于开平方的快速实现，详情可以看下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/69941/Best-Square-Root-Method-Algorithm-Function-Precisi&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/Articles/69941/Best-Square-Root-Method-Algorithm-Function-Precisi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;做算法优化的同学，就放过开平方吧。&lt;/p&gt;
&lt;p&gt;每个算法有两个基本指标，&lt;/p&gt;
&lt;p&gt;性能，效果。&lt;/p&gt;
&lt;p&gt;WebRTC 着力于音频通信，所以它对性能的要求是极高的。&lt;/p&gt;
&lt;p&gt;而算法的性能的优化，绝大多数情况的思路，都是特例化。&lt;/p&gt;
&lt;p&gt;以前在公司开技术分享会的时候，也分享过。&lt;/p&gt;
&lt;p&gt;也就一句话，越靠近CPU，性能越快。&lt;/p&gt;
&lt;p&gt;也就是除非要不得以，请不要写到硬盘上，然后再读上来。&lt;/p&gt;
&lt;p&gt;因为硬盘离CPU太远了。&lt;/p&gt;
&lt;p&gt;所以优化的思路也就非常明显了。&lt;/p&gt;
&lt;p&gt;从快到慢的介质分别是&lt;/p&gt;
&lt;p&gt;CPU的寄存器 -&amp;gt; CPU的缓存 -&amp;gt; 内存空间 -&amp;gt; 硬盘空间(磁盘)&lt;/p&gt;
&lt;p&gt;所以 尽可能地要使用上层的资源，能用寄存器就用寄存器，&lt;/p&gt;
&lt;p&gt;能往CPU的资源上靠，就要把算法数据结构和资源做得更加紧凑。&lt;/p&gt;
&lt;p&gt;关于CPU的相关资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cpuid.com/softwares/cpu-z.html&quot; target=&quot;_blank&quot;&gt;https://www.cpuid.com/softwares/cpu-z.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以下一个CPU-Z 查看一下。&lt;/p&gt;
&lt;p&gt;抽丝剥茧，一定要了解CPU的结构性能信息。&lt;/p&gt;
&lt;p&gt;然后对症下药，尽可能符合CPU的口味。&lt;/p&gt;

&lt;p&gt;科普下算法优化的思路：&lt;/p&gt;
&lt;p&gt;1.尽可能多用局部变量，编写最短，最有效的闭合函数。&lt;/p&gt;
&lt;p&gt;为了编译处理的时候，能最终用上寄存器，去缓存。&lt;/p&gt;
&lt;p&gt;2.尽可能少调用函数，参数最好是指针或引用传递，这样能减少拷贝，&lt;/p&gt;
&lt;p&gt;当然，可以的话参数要尽可能地少。&lt;/p&gt;
&lt;p&gt;3.处理的数据尽可能紧凑且少，数据对齐很大程度上，&lt;/p&gt;
&lt;p&gt;就是为了符合CPU的喜好，用上它的缓存。&lt;/p&gt;
&lt;p&gt;4.尽可能顺序读写，也是为了用上缓存资源&lt;/p&gt;
&lt;p&gt;5.计算降级，一般情况下乘法比加法耗时，除法比乘法耗时。&lt;/p&gt;
&lt;p&gt;浮点比整形耗时。&lt;/p&gt;
&lt;p&gt;所以将乘法降为加法，将除法降为乘法，浮点降为整形(定点化)。&lt;/p&gt;
&lt;p&gt;这一条大多数朋友若是不清楚为什么，可以移步资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ARM-software/CMSIS_5&quot; target=&quot;_blank&quot;&gt;https://github.com/ARM-software/CMSIS_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阅读其中的一些实现，你会找到具体原因的。&lt;/p&gt;
&lt;p&gt;这里就不展开了。&lt;/p&gt;
&lt;p&gt;6.能用内存的，就不要用磁盘，我想这个没必要多解释了。&lt;/p&gt;
&lt;p&gt;7.当然如果能用特定算法思路数据接口进行优化也是可以的，例如查表之类的。&lt;/p&gt;

&lt;p&gt;好像有点跑题了，回到主题上。&lt;/p&gt;
&lt;p&gt;抽空把以上提及的几个算法整理成 &lt;/p&gt;
&lt;p&gt;单文件实现的方式,并附加示例代码。&lt;/p&gt;
&lt;p&gt;便于学习或者工程化之用。&lt;/p&gt;

&lt;p&gt;相关项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/WebRTC_AECM&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/WebRTC_AECM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/WebRTC_NS&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/WebRTC_NS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/WebRTC_VAD&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/WebRTC_VAD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/WebRTC_AGC&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/WebRTC_AGC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路漫漫其修远兮，一条道走到黑。&lt;/p&gt;
&lt;p&gt;用cmake即可进行编译示例代码，详情见CMakeLists.txt。&lt;/p&gt;

&lt;p&gt;若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 07:15:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/8976346.html</dc:identifier>
</item>
<item>
<title>算法初体验 - 木可大大</title>
<link>http://www.cnblogs.com/neal-ke/p/8976339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neal-ke/p/8976339.html</guid>
<description>&lt;blockquote readability=&quot;7.6603773584906&quot;&gt;
&lt;p&gt;我们在&lt;a href=&quot;https://www.jianshu.com/p/04d986590ad8&quot;&gt;面向对象的演进过程&lt;/a&gt;一文中介绍了面向对象发展的几个阶段，其中第一个阶段远古时期的&lt;strong&gt;程序由数据结构和算法组成的&lt;/strong&gt;。其中，数据结构表示数据的组织形式，基本的数据结构包括数组、链表、栈、队列、树、哈希表、图、堆等。而算法表示对数据结构中的数据进行处理的方式或过程，换句话说，就是解决问题的方法。它们俩之间的关系：数据结构为算法服务，很多算法依赖于特定的数据结构，但不是全部算法，算法可以和数据结构没有关系。本期我们就来聊一聊算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;学习算法的重要性&quot;&gt;学习算法的重要性&lt;/h2&gt;
&lt;p&gt;在介绍具体算法之前，我先谈一下个人对学习算法的初心。我的初心无非有两点：一，BAT等互联网公司招聘面试时要问算法知识，如果想要进入互联网公司，我就必须学好算法；二，通过学习算法提升个人开发的基本功，这样一来，对于不同场景我就可以正确选择对应的数据结构和算法，使得程序更健壮，提高程序的运行效率。&lt;/p&gt;
&lt;h2 id=&quot;应用领域&quot;&gt;应用领域&lt;/h2&gt;
&lt;p&gt;目前计算机各个细分领域涉及到不同的算法。比如说&lt;strong&gt;搜索引擎&lt;/strong&gt;，平时我们使用google、百度等浏览器，只要我们输入一个关键字，浏览器就会&lt;strong&gt;快速&lt;/strong&gt;地返回相关的集合，这个集合的背后就隐藏着许多算法。如果没有这些算法，我们是不可能这么快速地得到想要的结果。再比如说人工智能，通过计算模型算法实现人体识别、语音识别等各应用场景。&lt;/p&gt;
&lt;h2 id=&quot;算法分析&quot;&gt;算法分析&lt;/h2&gt;
&lt;p&gt;上文我们已经介绍到算法就是解决问题的方法，而对于同一个问题，可能存在不同的解决方法。因此，为了衡量一个算法的优劣，提出了&lt;strong&gt;时间复杂度&lt;/strong&gt;与&lt;strong&gt;空间复杂度&lt;/strong&gt;这两个概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间复杂度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记为 &lt;code&gt;T(n) = O(f(n))&lt;/code&gt;，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;空间复杂度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，记做&lt;code&gt;S(n)=O(f(n))&lt;/code&gt;。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。&lt;/p&gt;
&lt;h2 id=&quot;排序算法&quot;&gt;排序算法&lt;/h2&gt;
&lt;p&gt;根据时间复杂度我们大体可以将排序算法分为两类，一类是以选择排序为代表的&lt;code&gt;O(n^2)&lt;/code&gt;的算法，另一类是以快速排序为代表的&lt;code&gt;O(nlogn)&lt;/code&gt;的算法。看到这里我们不禁会问：既然有&lt;code&gt;O(nlogn)&lt;/code&gt;的排序算法，那些&lt;code&gt;O(n^2)&lt;/code&gt;的算法还有存在的必要吗？要回答这个问题，先来看下&lt;code&gt;O(n^2)&lt;/code&gt;的排序算法的特点：首先，它相对是比较基础的，编码简单，易于实现，在一些特定场景下&lt;code&gt;O(n^2)&lt;/code&gt;更适合 ，譬如在机器语言中&lt;code&gt;O(n^2)&lt;/code&gt;更容易实现；其次，简单的排序算法思路衍生出复杂的排序算法，比如说希尔排序是对插入排序的优化；最后，对于一些简单的算法，由于它们本身的一些性质，可以被用作改进更复杂排序算法的子过程中。基于此，本文&lt;code&gt;O(n^2)&lt;/code&gt;排序算法中两个代表性的算法即选择算法和插入算法。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-7c660de7c7b512d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;选择排序&quot;&gt;选择排序&lt;/h2&gt;
&lt;p&gt;思想：在整个待排序数组里找到最小的值，然后和待排序中的第一个元素进行交换，接着在剩下的元素里找到最小的元素，接着将它和待排序中的第一个元素进行交换，以此类推。为了加深大家的理解，举个具体例子，对8、6、2、3、1、5、7、4进行升序排序。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-34b9668f4be592d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择排序的Java语言实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   /**
     * 思路：每次从待选数组中选择一个最小元素，然后和对应位置交换位置
     * @param arr
     * @param n
     */
    public void sort(int[] arr, int n) {
        for(int i=0;i&amp;lt;n;i++) {
            // 1. 寻找[i,n)区间里的最小元素
            int minIndex = i;
            for(int j=i+1;j&amp;lt;n;j++ ) {
                if (arr[j] &amp;lt; arr[minIndex]) {
                    minIndex = j;
                }
            }
            // 2. 交换位置
            this.swap(arr,i,minIndex);

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;插入排序&quot;&gt;插入排序&lt;/h2&gt;
&lt;p&gt;思路：插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-234f85644c03a342.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;插入排序的Java语言实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void sort(Comparable[] arr){
        int n = arr.length;
        for (int i = 0; i &amp;lt; n; i++) {
            // 寻找元素arr[i]合适的插入位置
            for( int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j].compareTo(arr[j-1]) &amp;lt; 0 ; j--)
                swap(arr, j, j-1);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过比较选择排序和插入排序的代码实现，我们可以发现一旦有部分排序好之后，新插入一个数如果比排好序最大值还要大，则不用再和其他数字比较，&lt;strong&gt;减少了比较次数&lt;/strong&gt;。但是，&lt;strong&gt;我们应该注意到插入排序在每次遍历的时候都需要进行交换操作&lt;/strong&gt;，这个交换操作包含三次赋值操作，导致插入排序的时间要比选择排序的时间更长。针对这个问题，我们的先辈们想到了一个方法：&lt;strong&gt;先将待比较元素复制一份&lt;/strong&gt;，然后依次和有序数组中的元素进行比较，如果比有序数组中的元素小，则将有序数组中的元素覆盖待比较元素，以此类推。如下图所示，首先我们将元素6复制一份，接着验证元素6是否应当放在当前位置，通过比较6和它之前的元素大小，发现元素8应该放在元素6的位置上，因此将元素8覆盖元素6，然后我们考查元素6是否应该放在前一个元素位置上，此时，由于元素8在第0个位置上我们就不用比较直接覆盖。它的Java代码实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-fad9fc1a65fca85e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; for (int i = 0; i &amp;lt; n; i++) {
            // 寻找元素arr[i]合适的插入位置
            Comparable e = arr[i];
            int j = i;
            for( ; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1].compareTo(e) &amp;gt; 0 ; j--)
                arr[j] = arr[j-1];
            arr[j] = e;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来，内循环只需要进行一次赋值操作，效率得到了大大优化，不仅超过了选择排序，而且在待排序数组是有序的情况下，时间复杂度可以达到&lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10175366-c5019c4af30667e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：木可大大，所有文章都将同步在公众号上。&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 07:12:00 +0000</pubDate>
<dc:creator>木可大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neal-ke/p/8976339.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构13（树01-二叉搜索树的实现） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8964937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8964937.html</guid>
<description>&lt;p&gt;　　前一篇文章我们学会了第一个非顺序数据结构hashMap，那么这一篇我们来学学树，包括树的概念和一些相关的术语以及二叉搜索树的实现。唉？为什么不是树的实现，不是二叉树的实现。偏偏是二叉搜索树的实现？嗯，别急。我们一点一点循序渐进。&lt;/p&gt;
&lt;p&gt;　　我们先来了解一下什么是&lt;a href=&quot;https://baike.baidu.com/item/%E6%A0%91%E7%BB%93%E6%9E%84/3399688?fr=aladdin&quot; target=&quot;_blank&quot;&gt;树&lt;/a&gt;。树是一种非线性数据结构，直观的看，它是数据元素（在树中称为节点）按分支关系组织起来的结构，很像自然界中的树那样。在现实生活中，最常见的例子就是家谱或者公司的组织架构图。就像是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180429220620997-18378555.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么我们还要知道树的一些相关术语，比较多，大家要仔细阅读，不然后面就完全懵逼了。我们先来看一下树这种数据结构的图示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180429220858741-1763985659.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是我在百度上找到的一张图，还算清晰明了。这就是树数据结构了。&lt;/p&gt;
&lt;p&gt;　　首先，一个树结构，存在一系列的父子关系，除了顶部的第一个节点以外，每一个结点都有一个父节点以及零个或多个子节点。位于树顶部的节点叫做&lt;strong&gt;根节点。&lt;/strong&gt;看上图，根节点就是A。树中的每一个元素（A,B,C,D,E,F这些）都叫做节点。节点又分为&lt;strong&gt;内部节点&lt;/strong&gt;和&lt;strong&gt;外部节点&lt;/strong&gt;。&lt;strong&gt;至少有一个子节点的节点称为内部节点&lt;/strong&gt;（如上图的A,B,C,E）。&lt;strong&gt;没有子节点的节点称为外部节点或叶节点&lt;/strong&gt;（如上图的D,F,G）。&lt;/p&gt;
&lt;p&gt;　　另一个概念是&lt;strong&gt;子树，&lt;/strong&gt;定义是这样的：子树由节点和它的后代构成。也就是说，把树中的一部分剖离出来，它仍旧可以看作是是一颗单独的树，那么就可以称之为子树。&lt;/p&gt;
&lt;p&gt;　　节点还有一个属性，叫做度，也可以叫做深度，节点的深度取决于它有多少个祖先节点。如上图的H，深度就是3，因为它有E,B,A三个祖先节点。E的深度就是2。&lt;/p&gt;
&lt;p&gt;　　除了节点的深度，一棵树还可以被分解层级。根节点是第0层，根节点的子节点是第1层。以此类推。&lt;/p&gt;
&lt;p&gt;　　那么我们对树的概念有了简单的了解，那么什么是二叉树呢？其实不论是二叉树，还是二叉搜索树，又或者是其它什么树，&lt;strong&gt;只不过是在树的基础上加上一个限制条件以便更高效率的操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　在二叉树中，一个节点的子节点最多只能有两个节点，一个左节点，一个右节点，二叉树只能是左右分叉的，所以叫做二叉树。&lt;/p&gt;
&lt;p&gt;　　那二叉搜索树（&lt;strong&gt;BST&lt;/strong&gt;）呢？不过是在二叉树的基础上，又加了一个插入元素的条件，就是，&lt;strong&gt;只允许你在左侧节点存储比父节点小的值，在右侧节点存储大于或等于父节点的值&lt;/strong&gt;。这里要注意的一点是，二叉树的子节点&lt;strong&gt;最多&lt;/strong&gt;只能有两个节点，也就说不一定非要有两个节点，只有一个左节点，或者只有一个右节点都是可以的可能的允许的。&lt;/p&gt;
&lt;p&gt;　　那么似乎我们不去实现树，也不去实现二叉树，而是直接实现二叉搜索树的原因就出来了。只要我们学会了二叉搜索树，自然树和二叉树的实现也就会了。&lt;/p&gt;
&lt;p&gt;　　来，我们来看图说话，在开始实现二叉搜索树之前，先给大家放张图（图片百度的），以便大家更好的理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201804/1184971-20180429232041394-466861398.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　既然图有了，我们就来看看如何实现一个BinarySearchTree。首先，要告诉大家的是，在链表中，我们称每一个节点本身称作节点，但是在树中，我们叫它键。唉？我好像看到了链表？树跟链表有毛关系？嗯。。。确实没关系，但是我们要实现树的方式却跟链表有关系。我们之前学习过双向链表，双向链表中有prev和next，分别指向当前节点的上一个和下一个节点。树的实现我们也要借用类似的方式，只不过是一个指向左侧子节点，另一个指向右侧子节点。&lt;/p&gt;
&lt;p&gt;　　那么我们都要实现哪些方法呢？&lt;/p&gt;
&lt;p&gt;　　1、insert(key)：像树中插入一个新的键。&lt;/p&gt;
&lt;p&gt;　　2、search(key)：在树中查找一个键。&lt;/p&gt;
&lt;p&gt;　　3、inOrderTraverse：中序遍历。&lt;/p&gt;
&lt;p&gt;　　4、preOrderTraverse：先序遍历。&lt;/p&gt;
&lt;p&gt;　　5、postOrderTraverse：后序遍历。&lt;/p&gt;
&lt;p&gt;　　6、min：返回树中最小的值/键。&lt;/p&gt;
&lt;p&gt;　　7、max：返回树中最大的值/键。&lt;/p&gt;
&lt;p&gt;　　8、remove(key)：从树中移除某个键。&lt;/p&gt;
&lt;p&gt;　　我们知道了基本的实现方式和BinarySearchTree需要的方法。我们开始吧。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个二叉搜索树的实现根本其实并没有多复杂，复杂的其实是概念。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 但是，我会尽量给大家解释清楚。不至于让大家一脸懵逼。&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; BinarySearchTree() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先这里，声明一个node节点，也就是我们树结构中所代表的每一个节点，包括根节点在内。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; Node = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的key，也就是键，大家要记住一个事情，我们所有的数据结构，都是为了应对合理适当的场景。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而无论何种数据结构，都需要检索，我记得前面说过，也就是增删改查这种万年不变的操作。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而这里的键（也就是key），是为了依照一定的规则来设置键，以便我们更快速的检索到，提取其值。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当然，我们实现的这个二叉搜索树貌似并没有value，但是我们可以自己去设置一个键值对的映射关系。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 既然能检索到key，也就可以找到其对应的值。当然，这里就不都说了。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如说这里，我们就可以给Node私有构造函数加一个this.value = value。来形成一个映射关系。&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; left和right，也就是指向当前节点的左右子节点的指针。&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个二叉搜索树，声明一个私有变量root代表根节点。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是插入节点的私有属性，我们会在insert方法中直接调用。那么我们先去看insert方法。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实这里也不复杂，但是用到了递归，如果大家对递归不太了解，可以去百度搜一下。后面的文章我也会写一些算法的相关内容。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们回到这里，insertNode有两个参数，在insert方法调用的时候我们传入了root，newNode。以便我们从根节点去查找。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; insertNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,newNode) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就分为了两种情况，其实后面的方法也是这样，新插入的key和node（第一次执行的时候是root）相对比。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果新插入的key小于node的key，我们要插入到left里，如果是大于等于node的key，就插入到right。这是我们二叉搜索树的规则。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(newNode.key &amp;lt;&lt;span&gt; node.key) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么这里，如果（或者说是‘直到’）node.left是空，也就是没有元素，那么就插入到node.left中。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则，再调用一下这个函数自身（也就是递归了，这就是为什么上面也可以说是‘直到’，递归必须有递归终止的条件，不然会陷入死循环）。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么下面的else情况也是同理。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node.left &lt;/span&gt;=&lt;span&gt; newNode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                insertNode(node.left,newNode);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node.right &lt;/span&gt;=&lt;span&gt; newNode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                insertNode(node.right,newNode);
            }
        }
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中序遍历，首先需要说一下什么是中序遍历。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中序遍历是一种以上行顺序访问BST所有节点的遍历方式（也就是从小到大的顺序访问所有节点），BST就是binary search tree。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么该方法有两个参数，一个是node，一个是回调函数（这个回调函数，在本文的应用是下面的console每一个节点的值，当然，你也可以用回调函数做一些羞羞的事）。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; inOrderTraverseNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,callback) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们要递归使用该方法，前面说了，必须有一个终止回调的条件。这里就是如果节点为空，我们就认为元素遍历完成，停止递归。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里，递归调用相同的函数来访问左侧子节点，然后对这个节点进行一些操作，最后访问右侧子节点。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到这里，其实中序遍历可以说是，左（左侧子节点），中（该节点），右（右侧子节点）的访问方式。&lt;/span&gt;
&lt;span&gt;            inOrderTraverseNode(node.left,callback);
            callback(node.key);
            inOrderTraverseNode(node.right,callback);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先序遍历，其实我们看代码就可以知道了，先序遍历就是中，左，右。也就是先访问节点本身，再访问左侧然后是右侧子节点。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; preOrderTraverseNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,callback) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            callback(node.key);
            preOrderTraverseNode(node.left,callback);
            preOrderTraverseNode(node.right,callback);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么后序遍历呢?额......可想而知，也就是左右中的方式，先访问节点的后代节点，再访问节点本身。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; postOrderTraverseNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,callback) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            postOrderTraverseNode(node.left,callback);
            postOrderTraverseNode(node.right,callback);
            callback(node.key);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 搜索树中的最小值，嗯......我们根据前面了解的内容，猜猜看最小的值是哪一个？如果你说不知道，请从头再来！&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树中最小的值，就是在树的最底层最左侧的节点。那么最大值就是右侧的节点了。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为什么会这样呢？如果你还是不知道。请从头再......再来！&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; minNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该节点是否是合法值，是-&amp;gt;继续，不是，返回null。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(node) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就是循环判断node.left是否存在，知道不存在的时候（说明已经得到最左侧的子节点了）就直接返回上一次赋值的node.key。&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(node &amp;amp;&amp;amp; node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; node.left;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.key;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同上&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; maxNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(node) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node &amp;amp;&amp;amp; node.right !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; node.right;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.key;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实这里，我真的不想说......但是我还是要'磨叽'一下......&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里第一个的node参数，在search中传入的是root，因为要从root开始执行逻辑。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还有，后面就几乎所有的传入node参数的私有方法，传入的都是root，因为要从root开始。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; searchNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,key) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是null了，返回false&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里，其实也就是根据不同的值得大小来判断递归时所需要传入的参数是什么，如果即不大也不小。bingo，说明找到了。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(key &amp;lt;&lt;span&gt; node.key) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchNode(node.left,key);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key &amp;gt;&lt;span&gt; node.key) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchNode(node.right,key);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法稍微复杂并且有意思一点，我们详细来说说。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; removeNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,key) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个判断没什么好说的了，如果是null说明在树中没有这个键，直接返回null就可以了。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么这里会有三种情况的判断，如果要找的key小于当前的node.key，就递归调用函数，沿着树的左边一直找下去。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么如果要找的key大于当前的node.key，就沿着树的右边一直找下去。直到找到为止。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(key &amp;lt;&lt;span&gt; node.key) {
            node.left &lt;/span&gt;=&lt;span&gt; removeNode(node.left,key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key &amp;gt;&lt;span&gt; node.key) {
            node.right &lt;/span&gt;=&lt;span&gt; removeNode(node.right,key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就是找到了匹配的key的时候所处理的逻辑了&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种情况就是该节点是没有左右子节点的，我们直接赋值null来移除就可以了。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虽然该节点没有子节点，但是有一个父节点，我们需要通过返回null，来使对应的父节点的指针指向null。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要记得我们在remove方法中有一个root = removeNode(root,key);赋值语句，可以到下面查看。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就是为了让我们父节点接收到更改的指针。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(node.left === &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.right === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是第二种情况，移除有一个左侧节点或者右侧节点的节点。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们只要跳过这个节点，直接将父节点的指针指向子节点就可以了。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(node.left === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; node.right;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node.right === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; node.left;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后是第三种情况，稍微复杂些，其实也就是我们要做的操作多一些。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先，我们在找到了需要移除的节点后，需要找到它右边子树种最小的节点。（要移除节点的继承者，也就是说在移除了匹配的节点后，这个值会替换被移除的节点）&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里findMinNode跟min方法是一样的，只不过返回值稍有不同&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; aux =&lt;span&gt; findMinNode(node.right);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后用aux去更新要移除节点的值，这个时候，我们已经改变了要移除节点的值，也就相应的移除了该节点。&lt;/span&gt;
            node.key =&lt;span&gt; aux.key;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是这个时候就有两个相同的键了，所以我们要移除aux也就是node.right指向的节点。&lt;/span&gt;
            node.right =&lt;span&gt; removeNode(node.right,aux.key);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回更新后的引用。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后，要提醒大家一个需要注意的地方，移除一个树中的节点，并没有移除该节点下的所有子树或者子节点，这是一个比较容易让人迷惑的误区。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如说,我有一棵下面这样的树&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                        A
                    B       C
                D      E  F    G 
            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我想要移除C，并没有把F,G也同时移除，只是单纯的移除了C这个节点，所以我们需要依照二叉搜索树的规则，找到一个合理的值代替这个位置（也就是F）。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么我们用F替换C，并把C移除，更改对应的指针。也就完成了第三种情况的移除操作。&lt;/span&gt;
&lt;span&gt;        }
    } 

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; findMinNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node &amp;amp;&amp;amp; node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node &lt;/span&gt;=&lt;span&gt; node.left;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实这个方法很简单，一看就明白了。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果root是null，说明是一个空树，我们直接让newNode为root就可以了，如果不是,我们再调用insertNode那个私有方法。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.insert = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (key) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            root &lt;/span&gt;=&lt;span&gt; newNode;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            insertNode(root,newNode);
        }
    }


    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inOrderTraverse = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback) {
        inOrderTraverseNode(root,callback);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.preOrderTraverse = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback) {
        preOrderTraverseNode(root,callback);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.postOrderTraverse = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (callback) {
        postOrderTraverseNode(root,callback);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.min = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; minNode(root);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.max = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxNode(root);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.search = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchNode(root,key);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.remove = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (key) {
        root &lt;/span&gt;=&lt;span&gt; removeNode(root,key);
    }

} 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个就是callback了&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; printNode (value) {
        console.log(value);
    }

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinarySearchTree();
tree.insert(&lt;/span&gt;11&lt;span&gt;);
tree.insert(&lt;/span&gt;7&lt;span&gt;);
tree.insert(&lt;/span&gt;15&lt;span&gt;);
tree.insert(&lt;/span&gt;5&lt;span&gt;);
tree.insert(&lt;/span&gt;3&lt;span&gt;);
tree.insert(&lt;/span&gt;9&lt;span&gt;);
tree.insert(&lt;/span&gt;8&lt;span&gt;);
tree.insert(&lt;/span&gt;10&lt;span&gt;);
tree.insert(&lt;/span&gt;13&lt;span&gt;);
tree.insert(&lt;/span&gt;12&lt;span&gt;);
tree.insert(&lt;/span&gt;14&lt;span&gt;);
tree.insert(&lt;/span&gt;20&lt;span&gt;);
tree.insert(&lt;/span&gt;18&lt;span&gt;);
tree.insert(&lt;/span&gt;25&lt;span&gt;);
tree.insert(&lt;/span&gt;6&lt;span&gt;);
tree.inOrderTraverse(printNode);&lt;span&gt;//3，5，6，7，8，9，10，11，12，13，14，15，18，20，25&lt;/span&gt;
tree.remove(&lt;/span&gt;15&lt;span&gt;);
console.log(&lt;/span&gt;&quot;--------------&quot;&lt;span&gt;)
tree.inOrderTraverse(printNode);&lt;span&gt;//3，5，6，7，8，9，10，11，12，13，14，18，20，25&lt;/span&gt;
tree.insert(&lt;/span&gt;100&lt;span&gt;);
console.log(&lt;/span&gt;&quot;--------------&quot;&lt;span&gt;);
tree.inOrderTraverse(printNode);&lt;span&gt;//3，5，6，7，8，9，10，11，12，13，14，18，20，25，100&lt;/span&gt;
console.log(tree.min(),&lt;/span&gt;&quot;min&quot;&lt;span&gt;);&lt;span&gt;//3，“min”&lt;/span&gt;
console.log(tree.max(),&lt;/span&gt;&quot;max&quot;&lt;span&gt;);&lt;span&gt;//100,&quot;max&quot;&lt;/span&gt;
console.log(tree.search(&lt;/span&gt;66&lt;span&gt;))&lt;span&gt;//false&lt;/span&gt;
console.log(tree.search(&lt;/span&gt;8&lt;span&gt;))&lt;span&gt;//true&lt;/span&gt;

console.log(&lt;/span&gt;&quot;--------------&quot;&lt;span&gt;);
tree.preOrderTraverse(printNode);&lt;span&gt;//11,7,5,3,6,9,8,10,18,13,12,14,20,25,100&lt;/span&gt;
console.log(&lt;/span&gt;&quot;--------------&quot;&lt;span&gt;);
tree.postOrderTraverse(printNode);&lt;span&gt;//3,6,5,8,10,9,7,12,14,13,100,25,20,18,11&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么我们二叉搜索树就实现完成了。其实如果大家看过前面的文章，这里的BinarySearchTree的实现其实并没有多复杂，而需要注意的是remove一个节点时在对不同的情况的处理方法。说到底，二叉搜索树也就是在插入元素也就是节点的时候要按照必要的规则，所以我们在对树进行操作的时候依照这种规则就可以了。&lt;/p&gt;
&lt;p&gt;　　本来到这里就应该结束了，但是我觉得有必要给大家上几幅图片，解释解释我们上面代码中每一步的执行，在BinarySearchTree是如何操作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180501144147714-463795491.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图展示了我们依次插入各个数字的时候，二叉搜索树会根据数值的大小来安排它的位置，之后我们做了一个移除15这个节点的操作，那么在移除之后它看起来就是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180501144727647-1886423211.png&quot; alt=&quot;&quot; width=&quot;699&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体的解释在代码的注释中已经有了，这里就不再重复的去啰嗦了。&lt;/p&gt;
&lt;p&gt;　　好了，到这里我们已经基本完成了二叉搜索树的基本实现，那么下一篇文章我们会简单的介绍一下其它类型的树结构。比如自平衡树，红黑树，堆积树等。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 06:54:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8964937.html</dc:identifier>
</item>
<item>
<title>C#基础拾遗系列之二：使用ILSpy探索C#7.0新增功能点 - 菠萝吹雪—Code</title>
<link>http://www.cnblogs.com/runningsmallguo/p/8972678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/runningsmallguo/p/8972678.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;C＃是一种通用的，类型安全的，面向对象的编程语言。有如下特点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）面向对象：c# 是面向对象的范例的一个丰富实现, 它包括封装、继承和多态性。C#面向对象的行为包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;统一的类型系统&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;类与接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;属性、方法、事件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（2）类型安全：&lt;span&gt;C&lt;/span&gt;&lt;span&gt;＃还允许通过dynamic关键字动态指定类型。 但是，&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;＃仍然是一个主要的静态类型语言。之所以是一种强类型的语言，是因为它的类型规则是非常严格的，例如，不能够使用一个float类型的参数去调用一个解释int 类型的函数，除非显式的把float转换为int ，这样有助于防止编码错误。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）内存管理：C#依赖运行时的自动内存管理，它的公共语言运行库有一个垃圾回收器，在合适非时间回收不再引用的对象所占的空间，这就释放了程序员手动释放对象的内存。C#并没有消除指针，它只是使大多数编程任务不需要使用指针，对于性能要求高的地方，还是可以使用指针的，但是只允许在显式标记为不安全的代码块中使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）C#和CLR：&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;是依赖&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;提供的内存管理和异常处理，&lt;/span&gt;&lt;span&gt;CLR&lt;/span&gt;&lt;span&gt;允许开发者使用不同的语言建立应用程序。&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;＃是被编译成托管代码的几种托管语言之一。托管代码以中间语言或&lt;/span&gt;&lt;span&gt;IL&lt;/span&gt;&lt;span&gt;表示。&lt;/span&gt;&lt;span&gt;CLR&lt;/span&gt;&lt;span&gt;把&lt;/span&gt;&lt;span&gt;IL&lt;/span&gt;&lt;span&gt;转换成机器的本地代码，例如&lt;/span&gt;&lt;span&gt;X86&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;X64&lt;/span&gt;&lt;span&gt;，通常就在此之前执行，这被称为即时（&lt;/span&gt;&lt;span&gt;Just-In-Time&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;JIT&lt;/span&gt;&lt;span&gt;）编译。 提前时间编译也可用于改善大型程序集的启动时间，或资源受限的设备。元数据的存在允许，程序集引用其他程序集中的类型而不需要额外的文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）CRL和 .Net Framework的关系&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;.NET Framework由CLR和大量的库组成；该类库中包含核心类库（也就是基础类库BCL）和应用类库，应用类库又依赖核心类库&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201804/896449-20180430005124198-1131498770.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;婆婆妈妈说了这么多，我相信大家都知道，好了，下面我们通过代码来看看C#7.0到底有哪些让你拍手叫好的地方。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（1）数字字面量的提升：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;C＃7中的数字文字可以包含下划线以提高可读性，这些被称为数字分隔符，并被编译器忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501103027892-506284020.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501103130918-743246244.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;span&gt;&lt;strong&gt;二进制文字可以用0b前缀指定。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以见到这种写法你不要惊讶，只是为了提高可读性。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（2）Out variables and discards（接收out变量和丢弃out变量）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;以前我们的写法：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501103948905-928705263.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;现在C#7.0中可以这样写：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501103856002-266489042.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们不需要在外面先定义好要接收值的变量，而是直接在里面写，是不是代码更简洁，另外一个有趣的地方是，当一个方法要返回多个值的时候，我们可以使用 out _，来选择性的接收返回来的值，在上面图中的代码中，方法SomeBigMethod返回四个值，但是我们在接收它返回来的值时，可以使用out _不接收返回来的值，而使用out int x，来接收返回来的值，是不是很灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501105012441-1452108887.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ILSpy结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Methods&lt;/span&gt;
    .method &lt;span&gt;private&lt;/span&gt; hidebysig &lt;span&gt;static&lt;/span&gt; 
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main (
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args
        ) cil managed 
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Method begins at RVA 0x2050
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Code size 49 (0x31)&lt;/span&gt;
        .maxstack &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
        .entrypoint
        .locals init (
            [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] int32,
            [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;] int32,
            [&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;] int32,
            [&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;] int32,
            [&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;] int32
        )

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (no C# code)&lt;/span&gt;
&lt;span&gt;        IL_0000: nop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bool successful = int.TryParse(&quot;123&quot;, out result);&lt;/span&gt;
        IL_0001: ldstr &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        IL_0006: ldloca.s &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        IL_0008: call &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; [System.Runtime]System.Int32::TryParse(&lt;span&gt;string&lt;/span&gt;, int32&amp;amp;&lt;span&gt;)
        IL_000d: stloc.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SomeBigMethod(out int _, out int _, out int x, out int _);&lt;/span&gt;
        IL_000e: ldloca.s &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
        IL_0010: ldloca.s &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
        IL_0012: ldloca.s &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        IL_0014: ldloca.s &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
        IL_0016: call void ConsoleApp1.Program::SomeBigMethod(int32&amp;amp;, int32&amp;amp;, int32&amp;amp;, int32&amp;amp;)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (no C# code)&lt;/span&gt;
&lt;span&gt;        IL_001b: nop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Console.WriteLine(x);&lt;/span&gt;
        IL_001c: ldloc.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
        IL_001d: call &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; [System.Console]System.Console::WriteLine(int32)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (no C# code)&lt;/span&gt;
&lt;span&gt;        IL_0022: nop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Console.WriteLine(result);&lt;/span&gt;
        IL_0023: ldloc.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        IL_0024: call &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; [System.Console]System.Console::WriteLine(int32)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (no C# code)&lt;/span&gt;
&lt;span&gt;        IL_0029: nop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Console.ReadKey();&lt;/span&gt;
&lt;span&gt;        IL_002a: call valuetype [System.Console]System.ConsoleKeyInfo [System.Console]System.Console::ReadKey()
        IL_002f: pop
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (no C# code)&lt;/span&gt;
&lt;span&gt;        IL_0030: ret
    } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of method Program::Main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（3）Patterns&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：你可以使用is运算符来引入一个变量，这个变量被称为模式变量。不明白，看个例子就明白了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501105302419-218572916.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析：x is string s 的作用是：如果x 可以被转换为string 转换后的值赋值给了s ，所以输出的结果就是字符串的长度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中switch的声明也支持这种模式，而且还可以使用when子句指定条件，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501110055830-2030827608.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501105842789-1764391407.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501110143842-468296796.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析：Foo2(9)传递过来的是9，是int 类型，所以就进入到第一个case 子句中，所以最终输出的结果就是：It is an int !，这个解释给零分，下面我们通过ILSpy看看这种语法糖到底是什么东东，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501111158797-1112354065.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我就不解释了，大家一看就明白，是不是想拍下大腿，TM原来就这么简单！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）本地方法（Local methods）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：A local method is a method declared inside another function。这里我给出英文，因为这种方式给出是最准确的，中文翻译出来就TM看不懂了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501111616024-1265168922.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501111836438-1341001660.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析：&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501111957214-343392137.png&quot; alt=&quot;&quot;/&gt;  定义了一个本地方法，返回值类型是int 传入的参数是value ,返回值是：value*value*value+i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cube(2)，调用传入值2 ，所以最终计算出来的值为 2*2*2+9=17&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：本地方法仅对包含函数可见，并且可以使用包含该本地方法的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSpy反编译的结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501114009090-1318922043.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看出在调用Cube(2)，最终被编译成Cube(2,ref xx)这样一个方法，但看不到 &amp;lt;WriteCubes&amp;gt;g__Cube|3_0方法的内部实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）c# 6 介绍了方法的 &quot;fat-箭头&quot; 语法, 可以用在只读、属性、运算符和索引器。c# 7 将此扩展到构造函数、读/写属性、终结器&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;代码：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501114455965-1866549988.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSPy代码结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501114702770-474936845.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （6）对于 c# 7, 可能最显著的改进是显式元组支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：元组提供了一种简单的方法来存储一组相关值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;代码：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501114918550-2076038672.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501115118472-522034148.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析： var bob = (&quot;Bob&quot;, 23);定义了一个元组，可以使用bob.Item1来访问第一个参数，可以使用bob.Item2来访问第二参数，但问题来了，为什么可以这样来访问？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSpy结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501115643119-1162411485.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，元组其实是一个ValueTuple&amp;lt;,&amp;gt;的泛型类型，其中string int 是有你的值的类型决定的，那为什么可以使用Item1和Item2来访问对应的值呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501120101628-1296114534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501120129656-958661316.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先Item1和Item2是人家 ValueTuple&amp;lt;T1, T2&amp;gt; 中定义的，那为什么我访问Item1就是&quot;Bob&quot;，那是因为在构造函数中，把&quot;Bob&quot;赋值给了Item1，所以明白了吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外可以看出元组是一个结构体，属于值类型的。讲到这里还没有讲完元组的点，由于编译器的魔力, 元组元素可以被命名为下面的形式:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501120657997-1941511755.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSpy结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501120816944-1603808359.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501120902578-304247376.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;借助于元组，函数可以返回多个参数，而不需要借助于out 参数：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501120935998-71566972.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501121838816-831619790.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSpy结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501122230870-1604751941.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;注意：元组隐含地支持反解析模式, 因此它们可以很容易地被分解成单个变量。我们可以重写前面的主方法使 GetFilePosition 返回的元组被分配给两个局部变量：row和cloum:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501121345927-2069055286.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501122336065-1394974300.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSPy结果：（结果和上面的一样）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501122440012-507202494.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，元组就讲到这里，接下让我们看看如何抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）抛出异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能：&lt;em&gt;在C#7之前，throw总是要被声明，现在它可以作为一个表达式出现在一个函数 体中，&lt;/em&gt;而且也可以出现在三元表达式中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501121606771-1682629596.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501121646155-1940548868.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; ILSpy结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501122646859-255885287.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（8）字符串的插值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接上代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501122820492-452526523.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果要多行显示，可以这样写：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501122947951-1782617943.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：$符一定要在@符号之前。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ILSpy结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501123135395-1737646123.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单我就不多说了，继续下面的知识点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（9）异常筛选器（Exception filters）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：允许你在catch中应用一个条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501123319003-563933235.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（10）引用本地变量Ref Locals&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用：C#7.0中引入了一个极为重要的点，借此，你可以定义一个本地变量，这个变量引用一个数组中的元素或者对象中的字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501123741028-2102142070.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;注意：Ref Locals 必须是数组中的一个元素、字段、或者本地变量，不能是属性。它通常与 ref returns 一起使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501123812122-1543524337.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501124650603-31083477.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析：ref int age 标注这个变量时就是一个引用类型的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（11）Ref Returns&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 作用：你可以在一个方法中返回一个 ref local,这种方式被叫做ref return&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501130131544-1279440630.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501130210616-643937644.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;解析：private static ref int GetX() 其实是一个 返回值为int32&amp;amp;（就是一个标记了内存指针的INT32类型）的方法，也就是返回一个地址，这样我再修改值后其实就是修改的x的值。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;ILSpy结果：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896449/201805/896449-20180501131716217-239092077.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：ldsflda int32 ：是把一个静态字段x的地址压入到栈中，ret，然后返回，在Main方法中，调用上面的方法后，从栈顶把值取出来，存储到本地变量列表中索引位置0里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后取本地变量中索引位置为0的值，并压入栈中，注意重点来了，stind.i4 是把 ldc.i4.s 9 值 的地址存储下来，这样就改变了x的值。所以这个int32&amp;amp;其实就是一个变量的地址，也就是我们通常所说的指针。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了讲到这里基本上C#7.0新增的功能就讲的差不多了，后续我会继续补充C#7.0新的知识点，希望对你有帮助！谢谢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，欢迎大家加入到我的C#+.Net Core英文书籍翻译群，我会不定期通过博客更新翻译的英文资料，希望得到最新的C#知识，同时对你我也有所提高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考书籍：《C 7.0 in a Nutshell 7th Edition》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：郭峥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：http://www.cnblogs.com/runningsmallguo/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 01 May 2018 06:06:00 +0000</pubDate>
<dc:creator>菠萝吹雪—Code</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/runningsmallguo/p/8972678.html</dc:identifier>
</item>
<item>
<title>Docker初体验 - 雨夜朦胧</title>
<link>http://www.cnblogs.com/RainingNight/p/first-docker-note.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RainingNight/p/first-docker-note.html</guid>
<description>&lt;p&gt;断断续续的使用Docker好几年了，但是一直没有全面深入的去了解过，每次用到都是Google一下相关的命令解决临时的问题，到头来却毫无收获。好在，我终于意识到了这个问题，便决定从头开始，耐心的学学Docker，并把学习过程记录下来，方便以后参考，也望与大家交流学习。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本人比较偏爱&lt;strong&gt;Ubuntu&lt;/strong&gt;，故本文所用命令皆基于Ubuntu 16.04，其他版本的命令会有稍有不同，本文不多做介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/RainingNight/p/first-docker-note.html#简介&quot;&gt;简介&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/RainingNight/p/first-docker-note.html#安装&quot;&gt;安装&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/RainingNight/p/first-docker-note.html#常用命令&quot;&gt;常用命令&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/RainingNight/p/first-docker-note.html#dockerfile&quot;&gt;Dockerfile&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;容器：将软件打包成标准化单元，以用于开发、交付和部署，而 Docker 是世界领先的软件容器平台。&lt;/p&gt;
&lt;p&gt;容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。&lt;/p&gt;
&lt;h3 id=&quot;容器-vs-虚拟机&quot;&gt;容器 VS 虚拟机：&lt;/h3&gt;
&lt;p&gt;容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且 VM 启动也十分缓慢。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/347047/201804/347047-20180428002728376-1167437176.png&quot; alt=&quot;container-vm&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;
&lt;p&gt;首先更新Package索引：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get update&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加Https支持：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common -y&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后添加Docker官方的GPG key:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -fsSL https://download.docker.com/linux/ubuntu/gpg &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-key add -

&lt;span class=&quot;co&quot;&gt;## 如果上面的地址不能下载，可以使用国内镜像&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg  &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-key add -&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加Docker-CE稳定版仓储地址：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; add-apt-repository \
   &lt;span class=&quot;st&quot;&gt;&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lsb_release&lt;/span&gt; -cs&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; \&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;   stable&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Docker官方仓储&lt;code&gt;download.docker.com&lt;/code&gt;的访问较慢，故使用了中科大镜像源替代。&lt;/p&gt;
&lt;h3 id=&quot;安装-1&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;最后，便可以直接安装了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get update
&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install docker-ce&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以运行一下&lt;code&gt;Hello Word&lt;/code&gt;来验证一下是否安装成功：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; docker run hello-world&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，Docker需要使用root身份来访问，每次都使用&lt;code&gt;sudo&lt;/code&gt;命令较为麻烦，我们可以将当前用户添加到&lt;code&gt;docker&lt;/code&gt;用户组来实现非root用户访问：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; usermod -aG docker &lt;span class=&quot;ot&quot;&gt;$USER&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新登录一下，便可以不使用&lt;code&gt;sudo&lt;/code&gt;命令来操作docker了。&lt;/p&gt;
&lt;h3 id=&quot;镜像加速&quot;&gt;镜像加速&lt;/h3&gt;
&lt;p&gt;默认情况下，Docker镜像是从Docker官方市场&lt;code&gt;store.docker.com&lt;/code&gt;来拉取的，同样非常缓慢，好在Docker官方提供了国内镜像库，可使用如下命令来配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; --registry-mirror=https://registry.docker-cn.com daemon&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了永久性保留更改，可以修改&lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;文件并添加上 registry-mirrors 键值：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;st&quot;&gt;&quot;registry-mirrors&quot;&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;&quot;https://registry.docker-cn.com&quot;&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改保存后重启 Docker 以使配置生效：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; systemctl restart docker&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;安装docker-compose&quot;&gt;安装Docker Compose&lt;/h3&gt;
&lt;p&gt;Docker Compose 是一个用来定义和运行复杂应用的Docker工具。我们的应用通常会由多个容器组成，使用Docker Compose可以非常容易的将一组容器当成一个整体来配置部署。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-&lt;span class=&quot;kw&quot;&gt;`uname&lt;/span&gt; -s&lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt;-&lt;span class=&quot;kw&quot;&gt;`uname&lt;/span&gt; -m&lt;span class=&quot;kw&quot;&gt;`&lt;/span&gt; -o /usr/local/bin/docker-compose
&lt;span class=&quot;kw&quot;&gt;chmod&lt;/span&gt; +x /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在 &lt;a href=&quot;https://github.com/docker/compose/releases&quot; class=&quot;uri&quot;&gt;https://github.com/docker/compose/releases&lt;/a&gt; 查看具体的发布列表。&lt;/p&gt;
&lt;h2 id=&quot;常用命令&quot;&gt;常用命令&lt;/h2&gt;
&lt;h3 id=&quot;运行容器run&quot;&gt;运行容器(run)&lt;/h3&gt;
&lt;p&gt;run是我们最常用的命令：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，便启动了一个&lt;code&gt;nginx&lt;/code&gt;容器。&lt;/p&gt;
&lt;h4 id=&quot;端口映射-p&quot;&gt;端口映射(-p)&lt;/h4&gt;
&lt;p&gt;此时，我们还无法通过访问宿主机的IP来访问刚才部署的Nginx，需要先进行端口映射：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -p 8080:80 nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;后台运行-d&quot;&gt;后台运行(-d)&lt;/h4&gt;
&lt;p&gt;默认情况下，当我们推出命令行时，容器也会被关闭。我们可以使用&lt;code&gt;-d&lt;/code&gt;参数使容器保持后台运行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -d &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;image-name&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后访问宿主机的IP:8080，便可以看到“Welcome to nginx!”。&lt;/p&gt;
&lt;h4 id=&quot;指定名称-n&quot;&gt;指定名称(-n)&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run --name &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;container-name&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;image-name&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run --name myredis redis&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，创建了一个名称为&lt;code&gt;redis&lt;/code&gt;的容器。&lt;/p&gt;
&lt;h4 id=&quot;持久化数据-v&quot;&gt;持久化数据(-v)&lt;/h4&gt;
&lt;p&gt;容器被设计为无状态的，当我们删除一个容器时，保存在其中的数据也会随之删除。如果我们希望某些数据不随着容器的删除而删除，则可以使用目录绑定（通常称为卷），将容器中的某个文件夹于主机上的文件夹绑定，来实现数据的持久化。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -v &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;host-dir&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;:&lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;container-dir&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;image-name&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除此之外，我们还可以使用&lt;code&gt;Data Containers&lt;/code&gt;来实行数据的持久化，数据容器(Data Containers)唯一的职责就是存储和管理数据：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; create -v /config --name dataContainer busybox&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，我们使用&lt;code&gt;busybox&lt;/code&gt;镜像创建了一个数据容器，并使用&lt;code&gt;-v&lt;/code&gt;参数来指定容器存储和管理数据的目录位置。&lt;/p&gt;
&lt;p&gt;然后我们可以将文件拷贝到容器中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; cp config.conf dataContainer:/config/&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们就可以在新的容器中引用该数据容器了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run --volumes-from dataContainer ubuntu&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新创建的&lt;code&gt;ubuntu&lt;/code&gt;容器挂载了数据容器的&lt;code&gt;/config&lt;/code&gt;目录。&lt;/p&gt;
&lt;h4 id=&quot;重启策略--restart&quot;&gt;重启策略(--restart)&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;--restart&lt;/code&gt;选项，可以设置容器的重启策略，以决定在容器退出时Docker守护进程是否重启刚刚退出的容器。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -d --restart=always &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;image-name&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有如下4种重启策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;no，默认策略，在容器退出时不重启容器&lt;/li&gt;
&lt;li&gt;on-failure，在容器非正常退出时（退出状态非0），才会重启容器
&lt;ul&gt;&lt;li&gt;on-failure:3，在容器非正常退出时重启容器，最多重启3次&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;always，在容器退出时总是重启容器&lt;/li&gt;
&lt;li&gt;unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;进入交互模式-it&quot;&gt;进入交互模式(-it)&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -it [image-name] /bin/bash&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;-i interact 进入交互模式。&lt;/li&gt;
&lt;li&gt;-t tty 分配一个伪终端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行之后，可以看到命令行的主机名已经变成了容器的Id，表示成功进入到了容器中，可以使用&lt;code&gt;exit&lt;/code&gt;命令退出容器。&lt;/p&gt;
&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 启动一个SQLServer容器&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -e &lt;span class=&quot;st&quot;&gt;'ACCEPT_EULA=Y'&lt;/span&gt; -e &lt;span class=&quot;st&quot;&gt;'SA_PASSWORD=Qwer1234'&lt;/span&gt; -p 1433:1433 -d --restart=unless-stopped microsoft/mssql-server-linux&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;管理容器&quot;&gt;管理容器&lt;/h3&gt;
&lt;h4 id=&quot;查看容器ps&quot;&gt;查看容器(ps)&lt;/h4&gt;

&lt;p&gt;通过&lt;code&gt;ps&lt;/code&gt;命令可以看到当前运行的容器，添加&lt;code&gt;-a&lt;/code&gt;参数，则可以看到停止的容器。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;docker inspect &amp;lt;friendly-name|container-id&amp;gt;&lt;/code&gt;来查看某个容器的详细信息：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;dokcer&lt;/span&gt; inspect redis&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;附加容器attach&quot;&gt;附加容器(attach)&lt;/h4&gt;
&lt;p&gt;ttach可以附加到一个已经运行的容器的stdin中。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; attach [containerid]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;进入容器exec&quot;&gt;进入容器(exec)&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; exec -it [containerid] /bin/bash&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是需要注意的是，对于&lt;code&gt;attach&lt;/code&gt;，如果从这个stdin中exit，会导致容器的停止。而&lt;code&gt;exec&lt;/code&gt;则不会，推荐使用&lt;code&gt;exec&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;停止容器stop&quot;&gt;停止容器(stop)&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; stop [containerid]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;删除容器rm&quot;&gt;删除容器(rm)&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; rm [containerid]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要删除的容器正在运行，则无法删除，可以添加&lt;code&gt;-f&lt;/code&gt;参数来强制删除，也可以先停止容器再删除：&lt;/p&gt;
&lt;p&gt;如果我们想删除所有的容器，可以使用如下命令：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; rm &lt;span class=&quot;ot&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; ps -a -q&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; -f&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;镜像管理&quot;&gt;镜像管理&lt;/h3&gt;
&lt;p&gt;Docker把应用程序及其运行环境等打包在 image 文件里面，相当于容器的模板。&lt;/p&gt;
&lt;h4 id=&quot;搜索镜像&quot;&gt;搜索镜像&lt;/h4&gt;
&lt;p&gt;我们可以在 &lt;a href=&quot;https://hub.docker.com&quot;&gt;registry.hub.docker.com&lt;/a&gt; 查找镜像，也可以使用 &lt;code&gt;dokcer search &amp;lt;name&amp;gt;&lt;/code&gt; 命令来搜索，如：我们使用如下命令来搜索&lt;code&gt;redis&lt;/code&gt;镜像。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; search redis&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;查看镜像&quot;&gt;查看镜像&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 查看镜像列表&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images

&lt;span class=&quot;co&quot;&gt;# 查看所有镜像（包括中间层镜像）&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; image -a

&lt;span class=&quot;co&quot;&gt;# 查看所有镜像的ID&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images -q

&lt;span class=&quot;co&quot;&gt;# 按仓库名过滤&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images [REPOSITORY]

&lt;span class=&quot;co&quot;&gt;# 按仓库名和标签过滤&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images [REPOSITORY:TAG]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;镜像列表输出如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;hello-world&lt;/td&gt;
&lt;td&gt;latest&lt;/td&gt;
&lt;td&gt;e38bc07ac18e&lt;/td&gt;
&lt;td&gt;2 weeks ago&lt;/td&gt;
&lt;td&gt;1.85kB&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;每列含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;REPOSITORY：仓储名&lt;/li&gt;
&lt;li&gt;TAG：标签， 一个镜像可以有多个标签&lt;/li&gt;
&lt;li&gt;IMAGE ID：镜像的唯一标识，通常在删除镜像时使用&lt;/li&gt;
&lt;li&gt;CREATED：创建时间&lt;/li&gt;
&lt;li&gt;SIZE：所占用的空间，展开后的各层所占空间的总和。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;删除镜像&quot;&gt;删除镜像&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 删除镜像&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; image rm [imageid]

&lt;span class=&quot;co&quot;&gt;# 删除所有镜像&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; image rm &lt;span class=&quot;ot&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; images -q&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; -f

&lt;span class=&quot;co&quot;&gt;# 删除虚悬镜像(dangling image)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; image prune&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仓库名和标签均为&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;，这类无标签、无仓储名的镜像被称为&lt;code&gt;dangling image&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;拉取推送&quot;&gt;拉取推送&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 拉取镜像&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; pull [imagename]

&lt;span class=&quot;co&quot;&gt;# 构建镜像&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; build

&lt;span class=&quot;co&quot;&gt;# 推送镜像&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; push [imagename]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;其他-1&quot;&gt;其他&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 查看镜像、容器、卷占用的空间&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; system df&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h2&gt;
&lt;p&gt;Dcoker镜像是从一个基础镜像开始的，基础镜像包括应用程序所需的平台依赖项, 例如, 安装了&lt;code&gt;JVM&lt;/code&gt;或&lt;code&gt;CLR&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;镜像的定义是使用&lt;code&gt;dockerfile&lt;/code&gt;文件来表达的。&lt;code&gt;dockerfile&lt;/code&gt;是描述如何部署应用的列表。一个简单的&lt;code&gt;Dockerfile&lt;/code&gt;文件如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; nginx:alpine
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; . /usr/share/nginx/html&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，我们的基础镜像是一个alpine版本的&lt;code&gt;nginx&lt;/code&gt;，从而拥有了一个安装了&lt;code&gt;nginx&lt;/code&gt;的linux环境。&lt;/p&gt;
&lt;p&gt;接下来，我们可以通过定义的&lt;code&gt;dockerfile&lt;/code&gt;文件来构建镜像：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; build -t webserver-image:v1 .&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其&lt;code&gt;-t&lt;/code&gt;参数为镜像指定一个友好的名字和标记，&lt;code&gt;.&lt;/code&gt;则表示使用当前目录的&lt;code&gt;dockerfile&lt;/code&gt;文件。&lt;/p&gt;
&lt;h3 id=&quot;onbuild&quot;&gt;OnBuild&lt;/h3&gt;
&lt;p&gt;通常，&lt;code&gt;dockerfile&lt;/code&gt;文件的执行顺序是从上到下，但我们可以使用&lt;code&gt;ONBUILD&lt;/code&gt;指令来延后执行（在子镜像构建时执行）。&lt;/p&gt;
&lt;p&gt;如下，我们定义一个经典的&lt;code&gt;Node&lt;/code&gt;应用程序基础镜像：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; node:10
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; mkdir -p /usr/src/app
&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /usr/src/app
&lt;span class=&quot;kw&quot;&gt;ONBUILD&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; package.json /usr/src/app/
&lt;span class=&quot;kw&quot;&gt;ONBUILD&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; npm install
&lt;span class=&quot;kw&quot;&gt;ONBUILD&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; . /usr/src/app
&lt;span class=&quot;kw&quot;&gt;CMD&lt;/span&gt; [ &lt;span class=&quot;st&quot;&gt;&quot;npm&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;start&quot;&lt;/span&gt; ]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们构建该镜像时，&lt;code&gt;ONBUILD&lt;/code&gt;指令包含的内容将不会执行，然后我们定义一个该镜像的子镜像：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; node:10-onbuild
&lt;span class=&quot;kw&quot;&gt;EXPOSE&lt;/span&gt; 3000&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们构建该镜像时，上面的&lt;code&gt;ONBUILD&lt;/code&gt;才会被执行。这样做的优势是可以在多个镜像中共享一份基础镜像，大大减少构建的速度。&lt;/p&gt;
&lt;h3 id=&quot;ignore-file&quot;&gt;Ignore File&lt;/h3&gt;
&lt;p&gt;为了防止将一个不必要或者敏感的数据打包到镜像中，可以使用&lt;code&gt;.dockerignore&lt;/code&gt;文件进行配置。&lt;/p&gt;
&lt;p&gt;下面的命令将&lt;code&gt;passwords.txt&lt;/code&gt;文件加到了忽略中，确保它不会意外的被打包到镜像中发布出去。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; passwords.txt &lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; .dockerignore&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以将&lt;code&gt;.dockerignore&lt;/code&gt;文件存储在源代码管理中，保持团队间的一致。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Docker是革命性的，干净利落的UX俘获了技术人员的芳心，ASP.NET Core 也是全面拥抱Docker，我们也要紧跟时代的步伐。&lt;/p&gt;
&lt;p&gt;本文主要介绍docker的一些基本用法，可作为一个docker使用笔记来参考，并不断的补充完善，但不会涉及到比较深入的介绍，后续在其他文章中会详细介绍一些具体的用法。&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 04:49:00 +0000</pubDate>
<dc:creator>雨夜朦胧</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RainingNight/p/first-docker-note.html</dc:identifier>
</item>
<item>
<title>时间对于程序员的价值，以及如何高效地利用时间，同时划分下勤奋度的等级 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8975724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8975724.html</guid>
<description>&lt;p&gt;    本文不讲“时间就是生命”之类的套话，而是会量化地直观地描述时间对程序员的价值。在高效利用时间的方法方面，也不会讲“合理制定计划，然后再执行”之类的对每类人都适用的方法，而会专门讲述针对程序员的时间管理方案。&lt;/p&gt;
&lt;h4&gt;1  对初级Java开发而言，学习能带来的其实收益不多，但必须得学&lt;/h4&gt;
&lt;p&gt;    一般而言，本科有1年经验，可以算得上初级开发，再做个2到3年，一般就能达到高级开发的工作年限要求，但是!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501090832516-2091347885.png&quot; alt=&quot;&quot; width=&quot;181&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    最终完成升级，不能仅凭工作经验的积累，还得通过升级认证（即成功通过高级开发的Java面试）。本人一直在做技术面试官，也经常帮助初级程序员升级通过面试。&lt;/p&gt;
&lt;p&gt;    根据社会上普遍的实践经验，初级程序员估计最少需要150个小时的学习积累，即可掌握高级开发的面试技巧，（Java Core估计30个小时，数据库估计30个小时，Java Web估计30个小时，优化类估计30个小时，准备简历总结面试经验估计30个小时），这况且还是最低标准，如果总结再充分些，各方面条件也再好些，估计累计准备个200小时，就能直接进到大公司了。这些我倒不是拍脑袋想出来了，根据我的实践经验，我整理出一本书，&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt;，不少&lt;/strong&gt;&lt;span&gt;技术面试官和技术讲师都能认可这个观点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     我找了份工资统计数值，目前（2018年5月），1年java开发（初级水平）工资大概是10k，而完成升级后的高级开发，工资在13到15k左右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501091953384-52366960.png&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    也就是说，按平均水准，初级程序员用了150个小时学习后，涨的工资哪怕按一年来算，一年能多拿3600，平摊到150小时的学习时间，大约每小时的收益是24元。（看似不多。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501092734672-1059153019.png&quot; alt=&quot;&quot; width=&quot;183&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    但话说回来，如果不用这150小时学习，那么该程序员也就一直停留在3年经验的能力水准上，从上图来看，初级开发的工作年限的上限是3年，工资上限是12k，哪怕工作了5年以上，如果能力不达标，依然是初级开发，而5年经验高级开发的工资能将近20k，这一来一去的差距就大了。&lt;/p&gt;
&lt;h4&gt;2  对高级Java开发而言，学习带来的收益就不可计量了&lt;/h4&gt;
&lt;p&gt;     工作经验满3年的java高级开发，其实工资差距并不多，一个月的差距估计也就在5k左右，但是！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501093828941-1905574173.png&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    5年左右经验的高级开发，工资差距就有可能拉开了，均价是20k,如果有些程序员特别卖力，学习时间比较长（估计也就200小时），工资能达到30k左右，这样一年的差距就12w，按此计算，每小时的学习收益是600。&lt;/p&gt;
&lt;p&gt;    7年开发经验的平均工资估计在25k，但如果能升级到架构师（学习时间在300小时左右），工资就能达到至少50k,这样一年的差距就25w了。每小时的学习收益将近有850。&lt;/p&gt;
&lt;p&gt;    这都是按平均水准来算的，如果学习效率再高些，一年学和不学的差距甚至能到35w，这绝不是夸大，在职场中这些案例比比皆是。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501093434776-54716291.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;3  高级Java开发升级到架构师的学习明细账&lt;/h4&gt;
&lt;p&gt;     刚才我们提到了高级开发升级所需要的具体时间，这里我们列个明细账。&lt;/p&gt;
&lt;p&gt;    1 用大约10小时的时间，了解架构师所需要的技术点，以及常规的学习路线。&lt;/p&gt;
&lt;p&gt;    2 用50个小时的时间，学习Spring Cloud各组件，因为这是个微服务架构，通过学习这部分的内容，能感性地认识架构师要干的活，比如负载均衡，容错保护等。&lt;/p&gt;
&lt;p&gt;    3 用大概40到50小时，了解基于Dubbo或其它架构的框架实现，比如怎么实现模块间通讯，如何实现秒杀系统。&lt;/p&gt;
&lt;p&gt;    4 最后再用50小时，了解一个真实的案例（如果找不到就看书，或者干脆上网上买），吃透了，就可以准备面试了。&lt;/p&gt;
&lt;p&gt;    5 随后就不断面试，在面试后花时间不断总结和提升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501095659611-778894460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;4  时间价值方面的总结&amp;amp;举例说明（不是结尾）&lt;/h4&gt;
&lt;p&gt;       学习能带来收益，这点毋庸置疑，但大家在计算时，应当同时把“不学习造成的损失”考虑在内。&lt;/p&gt;
&lt;p&gt;       比如某程序员工作4年，但不上心，能力始终停留在初级开发阶段，工资是1.3w，看似达到初级开发的高点了，但别人4年经验的，或许已经升级到高级开发了，工资能到16k了，一来一去的损失就是3k了，更何况，这位程序员同时还失去了进一步升级的基础，如果停留在初级阶段，工资升级到2w以及以上的可能性基本没有，这同样是损失。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501101647303-442952157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这里，再根据我切身体会和我看到的情况，说下合理利用时间能带来的收益。&lt;/p&gt;
&lt;p&gt;     1 &lt;strong&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt; 这本&lt;/strong&gt;书，写了6个月，大概用时360小时，账面收益1.5w，间接收益（比如名气、写作能力的提升以及能进一步帮我提升能力）不可限量。&lt;/p&gt;
&lt;p&gt;     2 我目前在写spring cloud的书，估计也是用时360小时，但能帮我夯实架构师的基础。&lt;/p&gt;
&lt;p&gt;     3 在博客园里，写一篇能进48小时排行榜的文章，估计需要1个小时，如果要写篇能上推荐榜的，估计得3个小时，时间用上去了，能提升知名度。&lt;/p&gt;
&lt;p&gt;     4 我见过一个java培训师，从0基础（上讲台磕磕巴巴）到资深（被别人抢着要），他也就最多也就100小时练习讲课技巧和归纳讲课内容。&lt;/p&gt;
&lt;p&gt;     5 再啰嗦一下，我见过大量初级开发，也就用3个月时间学习（有效学习时间150小时左右），然后面试进更好的公司。&lt;/p&gt;
&lt;p&gt;     6 高级开发层面，哪怕技术没提升，也就用50到100个小时看面试技巧和不断面试总结，大多都能成功跳槽，工资至少提升20%。&lt;/p&gt;

&lt;h4&gt;5  如何高效利用时间学习（早起篇）&lt;/h4&gt;
&lt;p&gt;    一日之计在于晨，这句话绝不是白说，大家一定有切身体会，同样是学习，晚上10点到11点和早上7点到8点的学习效率绝不相同。那我们能早起吗？绝对能，只不过现在不肯了。&lt;/p&gt;
&lt;p&gt;    早上6点半，学生们（祖国的花朵）大多起床了，开始洗漱，准备上学。此时程序员们估计大多还在梦见周公。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501102824464-453647368.png&quot; alt=&quot;&quot; width=&quot;156&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    早上7点到8点，路上见到的大多是背着书包上学的孩子们，而此时，估计程序员的闹钟开始响第一次了。（估计不少会被直接忽视）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501103023555-496995971.png&quot; alt=&quot;&quot; width=&quot;191&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     早上8点到8点半，学生们都已经开始上课了，而程序员可能就不得不起来了，然后早饭也来不及吃，直接往公司赶。&lt;/p&gt;
&lt;p&gt;     早上8点半到9点，一些老油子，不对，是老法师，开始出门了，这些人可以10点前到公司。&lt;/p&gt;
&lt;p&gt;     这样一算，早上哪有学习时间？好的剧本应该是这样：6点到6点半起床，7点洗漱完毕吃好早饭，用半小时到1小时学习，8点出门，这样身体也好，学习效率也高。其实我们读书时也都这样过来的。&lt;/p&gt;
&lt;p&gt;     怎么做到这点：&lt;/p&gt;
&lt;p&gt;     1 晚上尽量10点半前睡觉，如果可以10点最好。&lt;/p&gt;
&lt;p&gt;     2 如果确实有必要，比如公司开会要加班，那没办法，如果可以，免去些看连续剧和刷手机的时间，当然不是不放松，而是不能沉迷。&lt;/p&gt;
&lt;p&gt;     3 睡前如何放松，有专门的文章，这就不说了。&lt;/p&gt;
&lt;p&gt;     4 关键是毅力，如果没，就想下做到的好处（能涨工资）和做不到的坏处（钱会少）。&lt;/p&gt;

&lt;h4&gt;6  如何高效利用时间学习（利用碎片时间）&lt;/h4&gt;
&lt;p&gt;    我们每天都会用足量的时间刷手机，我也会。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501104201012-115095673.png&quot; alt=&quot;&quot; width=&quot;181&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    现在我会每天带本书，地铁上，工作之余看会。   &lt;/p&gt;
&lt;p&gt;    总结下来比较好的经验是，路上以及上班闲暇，看书，同时摘录要点，晚上到家后，用1个小时运行代码，如果可以，边接本书，边学边写，这样学习也就有出版社卖单了。&lt;/p&gt;

&lt;h4&gt;7  利用周末，更为高效的学习，同时可以变现学习的收益&lt;/h4&gt;
&lt;p&gt;     我们没有必要用头悬梁的学习方法，但得好好利用周末。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501104615579-608463645.png&quot; alt=&quot;&quot; width=&quot;237&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    周末可以放松，也可以偶尔开启混吃等死模式，比如10点起来，看个新闻，吃午饭了，睡个午觉，玩游戏，到晚上了，再出门逛一圈，又睡觉。但不能长久。&lt;/p&gt;
&lt;p&gt;     我们周末可以这样安排：&lt;/p&gt;
&lt;p&gt;     1 看各大招聘网站，看下我的升级目标，同时看下这些职位的具体要求。 &lt;/p&gt;
&lt;p&gt;     2 对此找些学习资料，指定学习规划，或者可以看些视频资料。&lt;/p&gt;
&lt;p&gt;     3 周末的时间比平时晚上要多很多，所以可以到网上下个项目来学。&lt;/p&gt;
&lt;p&gt;     当达到一定水准后，就可以利用周末时间找点活干挣点外快。比如出去讲课，到各网站上接点活，或者干脆接本书来写或者翻译。&lt;/p&gt;

&lt;h4&gt;8  总结  &lt;/h4&gt;
&lt;p&gt;    本文提到的合理利用时间，有个前提是勤奋：在这基础上，才肯花时间学习，才能进一步谈“合理利用”。换句话说，不少程序员不是不知道时间的重要性，也不是不知道合理利用时间的方法，而是不肯，说穿了就是不勤奋。虽说世艰不拆，但毕竟良药苦口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201805/1226172-20180501110405255-803707400.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    如果说头悬梁锥刺股的勤奋度是100分，而不工作啃老算0分，下面列些各种勤奋度的标准。&lt;/p&gt;
&lt;p&gt;   1 还能找工作养活自己，哪怕是工作中一直得过且过，敷衍工作，不及格，但能给到50分。&lt;/p&gt;
&lt;p&gt;   2 能在工作中，主观上想把事情干好，比如积极防治空指针，但工作之余不积极学习，能给到60分。这种人的公司水平会远低于行业标准。&lt;/p&gt;
&lt;p&gt;   3 工作之余能学习，有一定的上进心，能给到60到70分。这些人一般能完成准时升级，比如3年后能升级到高级开发，6年后能升到架构师。这些人的工资会和平均标准差不多，但不会高多少。&lt;/p&gt;
&lt;p&gt;    4 平时积极学习，能力优于行业平均，能给到70到80分，比如某人3年后，不仅能达到高级开发，而且还能进大公司，或者虽然只有3年经验，但能力看上去有5年。&lt;/p&gt;
&lt;p&gt;    5 不仅能积极学习，而且能通过不断总结和实践，学习很有成效，在某一领域成为技术大牛，比如能在6年左右就能玩转高并发架构或大数据架构，这些人的勤奋程度能达到80到90分，这些人的工资估计能是平均工资的n倍（n至少是3）。&lt;/p&gt;
&lt;p&gt;    6 至于90分以上，这些本人没机会膜拜，想象下，如果在国内高考，达到这种勤奋度的人能考上清华吧。&lt;/p&gt;
&lt;p&gt;    按此标准，本人的勤奋度估计是75分，和大牛相比，依然有差距。&lt;/p&gt;
&lt;p&gt;    大家也可以参照下自己的分数，还可以进一步采取措施提升勤奋度。&lt;/p&gt;
&lt;p&gt;    其实，本文提到的勤奋，学习方法和学习态度都是虚的，真正做到了收益的是自己，本人写这篇文章的动机也是时时提醒自己不忘初心，如果还能让勤奋的读者进一步提升勤奋度，那么也算额外的收获了。&lt;/p&gt;

</description>
<pubDate>Tue, 01 May 2018 03:18:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8975724.html</dc:identifier>
</item>
<item>
<title>谈谈Circuit Breaker在.NET Core中的简单应用 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/8975192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/8975192.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;由于微服务的盛行，不少公司都将原来细粒度比较大的服务拆分成多个小的服务，让每个小服务做好自己的事即可。&lt;/p&gt;
&lt;p&gt;经过拆分之后，就避免不了服务之间的相互调用问题！如果调用没有处理好，就有可能造成整个系统的瘫痪，好比说其中一些基础服务出现了故障，那么用到这些基础服务的地方都是要做一定的处理的，不能让它们出现大面积的瘫痪！！！&lt;/p&gt;
&lt;p&gt;正常情况下的解决方案就要对服务进行熔断处理，不能因为提供方出现了问题就让调用方也废了。&lt;/p&gt;
&lt;p&gt;熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施。&lt;/p&gt;
&lt;p&gt;对于这个问题，&lt;a href=&quot;http://steeltoe.io/&quot;&gt;Steeltoe&lt;/a&gt;的Circuit Breaker是一个不错的选择。本文的示例代码也是基于它的。&lt;/p&gt;
&lt;h2 id=&quot;steeltoe的circuit-breaker&quot;&gt;Steeltoe的Circuit Breaker&lt;/h2&gt;
&lt;p&gt;Steeltoe是什么呢？Steeltoe可以说是构建微服务的一个解决方案吧。具体的可以访问它的官网：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://steeltoe.io/&quot; class=&quot;uri&quot;&gt;http://steeltoe.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;回归正题，先来看看官方对Circuit Breaker的描述：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;What do you do when a service you depend on stops responding? Circuit breakers enable you to bypass a failing service, allowing it time to recover, and preventing your users from seeing nasty error messages. Steeltoe includes a .NET implementation of Netflix Hystrix, a proven circuit breaker implementation with rich metrics and monitoring features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不难发现，Circuit Breaker可以让我们很好的处理失败的服务。它也包含了对Netflix Hystrix的.NET(Core)实现。&lt;/p&gt;
&lt;p&gt;关于熔断机制，有个非常经典的图(这里直接拿了官方文档的图)，核心描绘的就是三种状态之间的变化关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201805/558945-20180501102330192-331567878.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说了那么多，下面还是来看个简单的例子来略微深入理解一下吧。&lt;/p&gt;
&lt;p&gt;注：服务发现和服务注册不是本文的重点，所以这里不会使用Steeltoe相应的功能。&lt;/p&gt;
&lt;h2 id=&quot;简单例子&quot;&gt;简单例子&lt;/h2&gt;
&lt;p&gt;先定义一个简单的订单服务，这个服务很简单，就一个返回直接返回对应订单号的接口，这里用默认的ASP.NET Core Web API项目做一下调整就好了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;[&lt;span class=&quot;fu&quot;&gt;Route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;api/[controller]&quot;&lt;/span&gt;)]
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ValuesController : Controller
{
    &lt;span class=&quot;co&quot;&gt;// GET api/values/123&lt;/span&gt;
    [&lt;span class=&quot;fu&quot;&gt;HttpGet&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;{id}&quot;&lt;/span&gt;)]
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Get&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; id)
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; $&lt;span class=&quot;st&quot;&gt;&quot;order-{id}&quot;&lt;/span&gt;;
    }        
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来一个新服务去调用上面的订单服务。&lt;/p&gt;
&lt;p&gt;先抛开熔断相关的，定义一个用于访问订单服务的Service接口和实现。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; IOrderService
{
    Task&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;GetOrderDetailsAsync&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; orderId);
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; OrderService : IOrderService
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;GetOrderDetailsAsync&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; orderId)
    {
        &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (HttpClient client = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HttpClient&lt;/span&gt;())
        {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; await client.&lt;span class=&quot;fu&quot;&gt;GetStringAsync&lt;/span&gt;($&lt;span class=&quot;st&quot;&gt;&quot;http://localhost:9999/api/values/{orderId}&quot;&lt;/span&gt;);
        }             
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较简单，就是发起HTTP请求到订单服务，拿一下返回的结果。&lt;/p&gt;
&lt;p&gt;忽略熔断的话，现在已经可以通过这个OrderService去拿到结果了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;[HttpGet]
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;Get&lt;/span&gt;([FromServices] Services.&lt;span class=&quot;fu&quot;&gt;IOrderService&lt;/span&gt; service, &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; id = &lt;span class=&quot;st&quot;&gt;&quot;0&quot;&lt;/span&gt;)
{
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; await service.&lt;span class=&quot;fu&quot;&gt;GetOrderDetailsAsync&lt;/span&gt;(id);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201804/558945-20180430232623494-1739676629.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是最最最最理想的情况！如果我们把订单服务停了，会发生什么事呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201804/558945-20180430232652445-1012644499.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;十分尴尬，这个订单服务的调用方也废了。&lt;/p&gt;
&lt;p&gt;当然，try-catch也是可以帮我们处理这个尴尬的问题，但这并不是我们想要的结果啊！&lt;/p&gt;
&lt;p&gt;下面来看看引入Circuit Breaker之后如何略微优雅一点去处理这个问题。&lt;/p&gt;
&lt;p&gt;定义一个GetOrderDetailsHystrixCommand，让它继承HystrixCommand。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GetOrderDetailsHystrixCommand : HystrixCommand&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt;
{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;readonly&lt;/span&gt; IOrderService _service;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;readonly&lt;/span&gt; ILogger&amp;lt;GetOrderDetailsHystrixCommand&amp;gt; _logger;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; _orderId;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;GetOrderDetailsHystrixCommand&lt;/span&gt;(
        IHystrixCommandOptions options,
        IOrderService service,
        ILogger&amp;lt;GetOrderDetailsHystrixCommand&amp;gt; logger
        ) : &lt;span class=&quot;kw&quot;&gt;base&lt;/span&gt;(options)
    {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;_service&lt;/span&gt; = service;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;_logger&lt;/span&gt; = logger;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;IsFallbackUserDefined&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; async Task&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;GetOrderDetailsAsync&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt; orderId)
    {
        _orderId = orderId;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; await &lt;span class=&quot;fu&quot;&gt;ExecuteAsync&lt;/span&gt;();
    }

    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; async Task&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;RunAsync&lt;/span&gt;()
    {
        &lt;span class=&quot;dt&quot;&gt;var&lt;/span&gt; result = await _service.&lt;span class=&quot;fu&quot;&gt;GetOrderDetailsAsync&lt;/span&gt;(_orderId);
        _logger.&lt;span class=&quot;fu&quot;&gt;LogInformation&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Get the result : {0}&quot;&lt;/span&gt;, result);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; async Task&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;fu&quot;&gt;RunFallbackAsync&lt;/span&gt;()
    {
        &lt;span class=&quot;co&quot;&gt;//断路器已经打开&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;_circuitBreaker&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;AllowRequest&lt;/span&gt;)
        {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; await Task.&lt;span class=&quot;fu&quot;&gt;FromResult&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Please wait for sometimes&quot;&lt;/span&gt;);
        }

        _logger.&lt;span class=&quot;fu&quot;&gt;LogInformation&lt;/span&gt;($&lt;span class=&quot;st&quot;&gt;&quot;RunFallback&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; await Task.&lt;span class=&quot;fu&quot;&gt;FromResult&lt;/span&gt;&amp;lt;&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;&amp;gt;($&lt;span class=&quot;st&quot;&gt;&quot;RunFallbackAsync---OrderId={_orderId}&quot;&lt;/span&gt;);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有几个地方要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数一定要有&lt;strong&gt;IHystrixCommandOptions&lt;/strong&gt;这个参数&lt;/li&gt;
&lt;li&gt;RunAsync是真正执行调用的地方&lt;/li&gt;
&lt;li&gt;RunFallbackAsync是由于某些原因不能拿到返回结果时会执行的地方，所谓的优雅降级。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来要做的是在Startup中进行注册。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode cs&quot;&gt;
&lt;code class=&quot;sourceCode cs&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConfigureServices&lt;/span&gt;(IServiceCollection services)
{
    services.&lt;span class=&quot;fu&quot;&gt;AddSingleton&lt;/span&gt;&amp;lt;IOrderService, OrderService&amp;gt;();
    services.&lt;span class=&quot;fu&quot;&gt;AddHystrixCommand&lt;/span&gt;&amp;lt;GetOrderDetailsHystrixCommand&amp;gt;(&lt;span class=&quot;st&quot;&gt;&quot;Order&quot;&lt;/span&gt;, Configuration);

    services.&lt;span class=&quot;fu&quot;&gt;AddMvc&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，在添加熔断命令的时候，还用到了&lt;strong&gt;Configuration&lt;/strong&gt;这个参数，这就说明，我们还少了配置！！&lt;/p&gt;
&lt;p&gt;配置是放到appsettings.json里面的，下面来看一下要怎么配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;hystrix&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;circuitBreaker&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;er&quot;&gt;//是否启用，默认是true&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;enabled&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;er&quot;&gt;//在指定时间窗口内，熔断触发的最小个数&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;requestVolumeThreshold&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;er&quot;&gt;//熔断多少时间后去尝试请求&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;sleepWindowInMilliseconds&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;er&quot;&gt;//失败率达到多少百分比后熔断&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;errorThresholdPercentage&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;er&quot;&gt;//是否强制开启熔断&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;forceOpen&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;er&quot;&gt;//是否强制关闭熔断&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;forceClosed&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;er&quot;&gt;//是否启用fallback&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;fallback&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;enabled&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要添加一个名字为&lt;strong&gt;hystrix&lt;/strong&gt;的节点，里面的command节点才是我们要关注的地方！&lt;/p&gt;
&lt;p&gt;default，是默认的配置，针对所有的Command！如果说有某个特定的Command要单独配置，可以在command下面添加相应的命令节点即可。&lt;/p&gt;
&lt;p&gt;其他配置项，都已经用注释的方式解释了。&lt;/p&gt;
&lt;p&gt;下面这张动图模拟了订单服务从&lt;strong&gt;可用-&amp;gt;不可用-&amp;gt;可用&lt;/strong&gt;的情形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201804/558945-20180430232736069-943419830.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了服务不可用，可能还有一种情况发生的概率会比较大，&lt;strong&gt;超时&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;举个例子，有一个服务平常都是响应很快，突然有一段时间不知道什么原因，处理请求的速度慢了很多，这段时间内经常出现客户端等待很长的时间，甚至超时了。&lt;/p&gt;
&lt;p&gt;当遇到这种情况的时候，一般都会设置一个超时时间，只要在这个时间内没有响应就认为是超时了！&lt;/p&gt;
&lt;p&gt;可以通过下面的配置来完成超时的配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;hystrix&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;&quot;default&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;&quot;execution&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;enabled&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;
          &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;&quot;isolation&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;&quot;strategy&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;THREAD&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt; 
            &lt;span class=&quot;dt&quot;&gt;&quot;thread&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;er&quot;&gt;//超时时间&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;&quot;timeoutInMilliseconds&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt; 
          &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这里也只是介绍了几个比较常用和简单的功能，它还可以合并多个请求，缓存请求等诸多实用的功能。总体来说，Steeltoe的熔断功能，用起来还算是比较简单，也比较灵活。&lt;/p&gt;
&lt;p&gt;更多配置和说明可以参考&lt;a href=&quot;http://steeltoe.io/docs/steeltoe-circuitbreaker/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文的示例代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/catcherwong/Demos/tree/master/src/CircuitBreakerDemo&quot;&gt;CircuitBreakerDemo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 02:44:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/catcher1994/p/8975192.html</dc:identifier>
</item>
</channel>
</rss>