<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>精读《原则》，教你如何通过原则过上想要的人生（下篇） - 奶爸码农</title>
<link>http://www.cnblogs.com/wdsunny/p/9461636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdsunny/p/9461636.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;做有意义的工作，发展有意义的人际关系&lt;br/&gt;-瑞·达利欧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上篇介绍了《原则》这本书里面的生活相关的原则，这里是传送门：&lt;a href=&quot;https://www.jianshu.com/p/c7e81a6e121e&quot; target=&quot;_blank&quot;&gt;上篇&lt;/a&gt;。这篇文章会继续介绍工作相关的原则。&lt;/p&gt;

&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;235&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-96da8e94dafbe8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-96da8e94dafbe8ae.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;235&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;152889&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;600&quot; data-height=&quot;898&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-2078172ee5d01442.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-2078172ee5d01442.jpeg&quot; data-original-width=&quot;600&quot; data-original-height=&quot;898&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;36382&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;目标到结果，需要经过组织/机构等运作达到，作者把机构视为机器，通过不断的实现更高、更大的目标而不断优化改进。在机器中，最为重要的是文化和人，两者相辅相成，因为优秀的文化会吸引优秀的人，而优秀的人又会创造出优秀的文化。&lt;/p&gt;

&lt;p&gt;瑞·达利欧不断强调创意择优，创意择优由以下几个部分组成&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创意择优 = 极度求真 + 极度透明 + 可信度加权的决策&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现实是一切决策的基础，透明可以保证所有人都可以得到相同的信息用于决策，再根据可信度加权来进行决策，这样可以大大提高决策的成功性。&lt;/p&gt;

&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;445&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-4bd9263bbba1d9e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-4bd9263bbba1d9e1.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;445&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;233039&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;打造良好文化是公司成功的首要因素，作者提出了若干原则用于帮助打造良好文化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.相信极度求真和极度透明&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;385&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-03655f99586e46af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-03655f99586e46af.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;385&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;231160&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;隐藏事实也许让人在短期内更开心，但从长远看来无法让他们变得更聪明、更令人信赖。只有让人们知道可以信赖我们所说的每句话，这才是真正的资产。极度求真和极度透明的工作方式需要人们来适应，因为这需要和人的天性作斗争，但是一旦实施并且良好执行，这样的工作效率是极高的。&lt;br/&gt;为人正直，同时也要求他人保持正直，若不想当面议论别人，背地里也不要说，要批评别人就当面指出来。让每个人都有权了解合理之事，不设定障碍，将不可透明的事项减到最少。公司很多时候会担心信息的泄露或者内部出现不合规的操作，极度透明的方式往往会降低做错事的风险，因为在极度透明的情况下，做坏事更难，发现事实、解决纠纷更容易。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.做有意义的工作，发展有意义的人际关系&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;349&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-f8b57040b8d5d917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f8b57040b8d5d917.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;349&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;200437&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;做有意义的工作，发展有意义的人际关系&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;798&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-de883b2b2f70a4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-de883b2b2f70a4ef.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;798&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;255784&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在极度求真和极度透明的情况下，更容易培养有意义的人际关系，做出更有意义的工作，这样最终会让你的人生获得成功。成功的工作和人际关系，需要做到忠于共同的使命。同时不要太单纯，在努力让尽可能多的员工从事有意义的工作，发展有意义的人际关系同时，要知道总会有一定比例不关心公司，甚至做出有损集体利益的事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.打造允许犯错，但不容忍罔顾教训、一错再错的文化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;245&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-f7d0a88e16c6f600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f7d0a88e16c6f600.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;245&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;145331&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;要求人们敢于犯错，以便从错误中学习，这样就会快速成长，也不会再犯大错。瑞·达利欧建立错误日志记录所有犯下的错误，系统化的解决。不要为自己的错误而懊恼，要珍爱它！记住在经历痛苦的时候反思，记住痛苦+反思=进步。&lt;br/&gt;没人可以客观的看待自己，因此一个人犯下最严重的错误，就是不能直面自己的错误。作者发明了痛苦按钮的工具，当某人经历痛苦，就让他把经历什么样的痛苦记录下来，以后再利用反思所用的问题进行回顾反思。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.求取共识并坚持&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;346&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-07c03819a4d748cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-07c03819a4d748cb.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;346&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;171587&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;让一个机构有效运作，其员工必须在多个层面保持一致-从共同的使命、如何对待彼此，到追求成功，明确每个人的职责。但是需要理解人和人存在很大的不同，因此需要大家不要回避分歧和问题，直面且积极解决小的矛盾，才会更好的维持长久的良好关系。&lt;/p&gt;
&lt;p&gt;求取共识需要大家保持开放心态，能够换位思考，理解对方得出结论的思维方式，同时也需要果断作出决断。在机构中，通常保持同步的方式通常有三个维度：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;KPI：公司/部门核心数据指标，例如营收、利润、增长率等等&lt;/li&gt;
&lt;li&gt;OKR：团队的目标、关键产出和行为&lt;/li&gt;
&lt;li&gt;IDP：个人的发展计划，通常可以结合团队OKR制定&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;5.做决策时要从观点的可信度出发&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;275&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-4813d9bebad49ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-4813d9bebad49ecb.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;275&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;178636&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创意择优=极度现实+极度透明+可信度加权的决策&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;瑞·达利欧极力推行创意择优的方式，创意择优的方式包括三个方面的内容，缺一不可：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;极度现实：现实是成功的基础，需要大家认清现实的情况，才可以做出正确的决策&lt;/li&gt;
&lt;li&gt;极度透明：信息的共享及其关键，这部分内容要求客观，帮助大家理解更多的细节&lt;/li&gt;
&lt;li&gt;可信度加权的决策：决策权不是在某个人，而是由一群人共同产出，但是每个人可信度需要基于过往决策效果历史进行加权。如果某人在这个方面经常能够得出正确的预测，那么他的可信度应该大大提高&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一种极致理性的民主决策方式，不同于大多数人认为的一人一票制的绝对民主，因为那样往往会产生乌合之众的效果，群体的智慧是会远远低于某些个人，如果一人一票就好导致决策的失败，似乎美国总统特朗普就是个例子:)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.解决分歧&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;290&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-f455a1f757dc0f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f455a1f757dc0f8f.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;290&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;185239&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;解决分歧最重要的是要坚守原则，并且不要避免冲突要快速解决重要的问题，一旦做出决定，每个人都应该支持它，尽管有些人可能仍然不同意。要记住进化是对整体有利的，而不是对于个人。&lt;/p&gt;

&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;784&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-ad4dfa09f6cb63c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-ad4dfa09f6cb63c2.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;784&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;453408&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现代企业尤其是脑力劳动密集型的企业，人毫无疑问是关键性的因素，因此用对人及其重要。按照一个人进入公司的阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;招聘合适的人&lt;br/&gt;用极高的标准来招聘员工，记得Facebook的CEO扎克伯格说过他招人的标准就是看是否你原意汇报给他。因此永远不要降低招聘的标准，A类员工会招揽A类员工，但是B类员工就会招揽到C类或D类的员工。&lt;/li&gt;
&lt;li&gt;让合适的人做合适的事情&lt;br/&gt;每个人性格、擅长的事情也不一样，因此让每个人找到合适的工作，这样才能最大化的发挥他们的才能。&lt;/li&gt;
&lt;li&gt;持续发展每个人&lt;br/&gt;为每个人制定发展计划，帮助他们找到未来成长的机会和空间，不断提供反馈，并且需要准确的提供客观评价。严厉的爱是最重要的爱，需要感激每一位能够客观地指出你自身不足的人，因为人往往存在盲点而且自负，很难客观的评论自身的不足，如果有一位领导可以指出你的不足，那么应该感激而不是愤怒。&lt;/li&gt;
&lt;li&gt;淘汰不合格的员工&lt;br/&gt;对于不能胜任的员工，需要及时进行辅导，安排改进计划，如果还是不能改善需要及时淘汰。因为不能胜任的员工会影响到团队的整体氛围，导致整个团队变得平庸，这就是所谓需要清理老白兔的道理。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;956&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-84c55525323d7b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-84c55525323d7b70.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;956&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;543701&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;将自己和机构想象成为一个机器，基于原则把方法系统化，在更好层面俯视整个的机器的运作，进行调整以期达到最终的目标。不断把结果和你的目标进行对照，找出机器的问题，进行诊断，解决问题。&lt;br/&gt;在管理方面要避免通过命令的方式强迫下属做事，要确保双方达成共识。通过可以明确量化指标来进行评估。对待问题上要迎难而上，并且在分析问题需要非常具体，这里采用“5 why”方式，多问几个为什么，这样可以找到最根本的原因，触及到最痛的地方，这样才能有效的解决问题。&lt;br/&gt;管理者需要记住通常会因为以下5个原因而失败或未能达成目标：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;他们离问题太远。&lt;/li&gt;
&lt;li&gt;他们在辨别低素质、低质量方面能力欠缺。&lt;/li&gt;
&lt;li&gt;他们已经感受不到问题的严重性，因为他们对问题已经习惯了。&lt;/li&gt;
&lt;li&gt;他们对工作太自负，不愿意承认解决不了自己的问题。&lt;/li&gt;
&lt;li&gt;他们对承认失败的不利后果感到害怕。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;p&gt;瑞·达利欧这本原则总结了他关于人生和工作的原则，更为重要的是他提供一种以原则为基础的生活和思考方式。这是瑞·达利欧原则系列的上半部分，期待他的关于经济和投资的下半部分。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 15:40:00 +0000</pubDate>
<dc:creator>奶爸码农</dc:creator>
<og:description>做有意义的工作，发展有意义的人际关系-瑞·达利欧 上篇介绍了《原则》这本书里面的生活相关的原则，这里是传送门：上篇。这篇文章会继续介绍工作相关的原则。 工作原则概述 目标到结果，需要经过组织</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdsunny/p/9461636.html</dc:identifier>
</item>
<item>
<title>Java多线程学习总结之---多线程基础 - Marksmanbat</title>
<link>http://www.cnblogs.com/-Marksman/p/9322589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-Marksman/p/9322589.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、线程相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、线程与进程的区别&lt;/p&gt;
&lt;p&gt;　　　　线程是操作系统调度的最小单元，也叫轻量级进程，而进程是操作系统中的应用程序，在进程中可以创建多个线程。&lt;/p&gt;
&lt;p&gt;　　2）、上下文切换 &lt;/p&gt;
&lt;p&gt;　　　　我们知道现代处理器都是多核的，几核处理器只能同时处理几个线程，多线程执行程序看起来是同时进行，实际上是CPU在多个线程之间快速切换执行，这中间就涉及到上下问切换，所谓的上下文切换就是指一个线程T被分配的时间片用完了之后，线程的信息被保存起来，CPU执行另外的线程，再到CPU读取线程T的信息并继续执行T的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、线程实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1)、继承Thread类&lt;/p&gt;
&lt;p&gt;　　　　由于类的单继承性，使用这种方式实现就无法再去继承其他的线程，有局限，耦合度高。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.run();
        System.out.println(&lt;/span&gt;&quot;我继承了Thread类...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2)、实现Runnable接口&lt;/p&gt;
&lt;p&gt;　　　　大多数都用这种方式实现，很灵活，重写run()方法即可，run() 方法没有返回值。&lt;/p&gt;
&lt;p&gt;　　3)、实现Callable接口&lt;/p&gt;
&lt;p&gt;　　　　若是想获取到线程的执行结果，那就用这种方式，它和实现Runnable接口的区别是要重写call()方法，call()方式是有返回值的，返回的Object是任务的执行结果，可以用Future接口的实现类FutureTask来接收，并调用get()方法获取到执行结果。另外call()方法可抛出异常，而run()方法是不能抛出异常的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class&lt;span&gt; Test {&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();
        thread1.start();

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable());
        thread2.start();

        Callable callable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyCallable();
        FutureTask&lt;/span&gt;&amp;lt;String&amp;gt; future = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(callable);
        ExecutorService executorService &lt;/span&gt;=&lt;span&gt; Executors.newSingleThreadExecutor();
        executorService.submit(future);
        System.out.println(future.get());
        executorService.shutdown();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyRunnable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;我实现了Runnable接口...&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyCallable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Callable{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;我实现了Callable接口...&quot;&lt;span&gt;;
        }
    }
}&lt;p&gt;执行结果：&lt;br/&gt;　　&lt;/p&gt;&lt;/span&gt;我继承了Thread类...&lt;br/&gt;我实现了Runnable接口...&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;   我实现了Callable接口...&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、线程状态 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据jdk中Thread类的State内部类，线程有6种状态，下次面试官问你线程有几种状态，你可以很有底气的回答：6种，如下左图，右图是线程状态之间的转换。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401002/201807/1401002-20180721161258690-1096239145.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;330&quot;/&gt;                  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401002/201807/1401002-20180721172729480-1627719319.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里注意：线程在等待进入synchronzed方法或者synchronized块时的线程状态时BLOCKED，而在等待进入lock锁时的状态是WAITING或者TIME_WAITING，因为lock是用LockSupport实现的（源码还没研究）。&lt;/p&gt;
&lt;p&gt; 测试如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyService {

   public static synchronized void serviceMethod1(){&lt;br/&gt;　　　　try{&lt;br/&gt;　　　　　　&lt;/span&gt;System.out.println(Thread.currentThread().getName+&quot;进入了业务方法&quot;);&lt;br/&gt;　　　　　　Thread.sleep(millis: 1000);&lt;br/&gt;&lt;span&gt;　　　　} catch (Execption e){&lt;br/&gt;　　　　　　e.printStackTrace();&lt;br/&gt;　　　　}&lt;/span&gt;&lt;span&gt;　　&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serviceMethod2(){&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;        ReentrantLock reentrantLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        reentrantLock.lock();
        System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot;进入了业务方法&quot;&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;　　　　 try {&lt;br/&gt;　　　　　　Thread.sleep(1000);&lt;br/&gt;　　　　} catch (InterruptedException e) {&lt;br/&gt;　　　　　　e.printStackTrace();&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　}&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　　　　　reentrantLock.unlock();&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　　　}&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;}&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread1 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod1();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod1();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread3 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod2();
}
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread4 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod2();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadStatusTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        test1();
        test2();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        MyThread1 t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread1();
        t1.setName(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        t1.start();

        MyThread2 t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread2();
        t2.setName(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        t2.start();

        System.out.println(&lt;/span&gt;&quot;t2的状态:&quot;+&lt;span&gt;t2.getState());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        MyThread3 t3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread3();
        t3.setName(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        t3.start();

        MyThread4 t4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread4();
        t4.setName(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        t4.start();

        System.out.println(&lt;/span&gt;&quot;t4的状态:&quot;+&lt;span&gt;t4.getState());
    }
}&lt;p&gt;test1() 运行结果： &lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;　　a进入了业务方法&lt;br/&gt;　　t2的状态:RUNNABLE&lt;br/&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　b进入了业务方法&lt;p&gt;test2() 运行结果：&lt;br/&gt;&lt;/p&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　a进入了业务方法&lt;br/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　t4的状态:RUNNABLE&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　b进入了业务方法&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、常用方法 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、start() 启动线程的一种方式，线程调用start()方法后由NEW状态变为RUNNABLE状态中的READY状态，等待CPU分配时间片，它是Thread类的方法；&lt;/p&gt;
&lt;p&gt;　　2）、 run() 所需实现的逻辑写在run方法里，线程获得时间片后由READY状态变为RUNNING，并自动调用run()方法，当然run()方法也可以直接调用，那它就是普通方法，和线程无关；&lt;/p&gt;
&lt;p&gt;　　3）、sleep(...) 线程由RUNNABLE状态变为TIMED_WAITING状态，调用此方法会抛出InterruptedException异常，线程自己拥有系统资源，并等待时间到了，自己醒来，这是和wait()方法的主要区别；&lt;/p&gt;
&lt;p&gt;　　4）、wait()  notify()  notifyAll() 这三个都是Object类的方法，它们是配合使用的，调用wait()方法的线程状态由RUNNABLE中的RUNNING变为WAITING状态，并且此对象是不占有系统资源的，当调用notify()或notifyAll() 方法后线程又进入RUNNABLE中的READY状态，等待获取CPU时间片；&lt;/p&gt;
&lt;p&gt;　　5）、join(...) 等待线程对象销毁，线程状态由RUNNABLE变为WAITING或者TIMED_WAITING；&lt;/p&gt;
&lt;p&gt;　　6）、interrupt() 中断线程，线程状态变为TERMINATED；&lt;/p&gt;
&lt;p&gt;　　7）、yield() ，线程状态由RUNNING变为READY，即由运行中变为就绪状态，向处理器表示自己愿意放弃当前CPU资源（让出自己的执行时间），但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片，所有此方法并不能保证其它线程一定执行，调用此方法的线程一定不执行，而是看CPU是否分配了时间片，并且它只会让优先级不低于当前线程的线程执行，优先级比它低的是没有机会执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、线程的优先级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　线程优先级为1-10（由低到高），默认优先级是5，优先级高的线程分配的时间片的数量要低于优先级低的，我们可以调用Thread.setPriority(int) 方法来为线程设置优先级，在设置线程优先级时应注意，争对频繁阻塞的，如休眠、IO、数据库等任务的线程应设置较高的优先级，对于偏重计算的，如需要较多的CPU时间或者偏运算的线程则应设置较低的优先级，确保处理器不会被独占。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、线程间的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、&lt;em id=&quot;__mceDel&quot;&gt;volatile  synchronized&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　这两个关键字可以实现线程间的通讯，我们知道每个线程都有自己的工作内存，并且它们还有共享内存，线程对一个变量修改时会先从共享内存中读取这个变量到自己私有的工作内存中，若是一个普通变量则修改后刷新到主内存中的时机时随机的，若是volatile变量（可见性和有序性），这时另一个线程来读这个变量，则它会被立即刷新到主内存中去，让后面读取的线程能看到变化，这就实现了两个线程之间的通信。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401002/201808/1401002-20180808174158273-632870215.png&quot; alt=&quot;&quot; width=&quot;318&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　synchronized实现线程之间的同步，B线程必须等到A线程释放锁才能获得相应的资源，这是线程之间的一种通信方式。&lt;/p&gt;
&lt;p&gt;　　2）、等待通知机制 wait()  notify()  notifyAll()&lt;/p&gt;
&lt;p&gt;　　一个过程从一个线程开始，在另一个线程结束，前者是生产者，后者是消费者，生成者完成生产，通知消费者去消费，完成二者之间的通信。&lt;/p&gt;
&lt;p&gt;　　等待通知的相关方法有&lt;/p&gt;
&lt;p&gt;　　　　wait()：调用该方法的线程进入WAITING状态，只有被其他线程通知或者被中断才会返回，调用该方法后，会释放对象的锁；&lt;/p&gt;
&lt;p&gt;　　　　wait(long)：超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回；&lt;/p&gt;
&lt;p&gt;　　　　wait(long,int)：超时时间为long毫秒+int纳秒；&lt;/p&gt;
&lt;p&gt;　　　　notify()：通知一个在对象等待的线程，使其从wait()方法返回，而返回的前提时该线程获取了对象的锁；&lt;/p&gt;
&lt;p&gt;　　　　notifyAll()：通知所有等待在该对象上的线程。&lt;/p&gt;
&lt;p&gt;　　以上方法都来自java.lang.Object类中，所以只要是对象就可以调用它们。&lt;/p&gt;
&lt;p&gt;　　　　wait()、notify()和notifyAll()调用时需要注意：&lt;/p&gt;
&lt;p&gt;　　　　a、使用wait()、notify()和notifyAll()时需要先对调用对象加锁；&lt;/p&gt;
&lt;p&gt;　　　　b、调用wait()方法后，线程状态由RUNNING变为WAITING,并将当前线程放置到对象的等待队列；&lt;/p&gt;
&lt;p&gt;　　　　c、notify()或者notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或者notifyAll()的线程释放锁之后，等待线程才有机会从wait()返回；&lt;/p&gt;
&lt;p&gt;　　　　d、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法将等待队列中所有的线程全部移到同步队列，被移动的线程状&lt;/p&gt;
&lt;p&gt;　　　　　　态由WAITING变为BLOCKED；&lt;/p&gt;
&lt;p&gt;　　　　e、从wait()方法返回的前提是获得了调用对象的锁。&lt;/p&gt;
&lt;p&gt;　　A线程调用wait() 方法会释放持有的对象监视器，进入等待状态，等B线程执行完了后，调用notify()或者notifyAll() 方法唤醒A线程&lt;/p&gt;
&lt;p&gt;　　3）、管道输入、输出流&lt;/p&gt;
&lt;p&gt;　　　　管道流专门用于线程之间的通信，和普通字符字节流的区别是它们操作的是内存而不是硬盘。&lt;/p&gt;
&lt;p&gt;　　　　主要有四种实现：字节流：PipedOutputStream、PipedInputStream&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　字符流：&lt;em id=&quot;__mceDel&quot;&gt;PipedWriter、PipedReader &lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　   4）、join(...)&lt;/p&gt;
&lt;p&gt;　　　　当前存在线程A、B，若A执行了join()方法，意思就是：当前线程A等待B线程执行完成之后，才继续执行，即完成了A、B间的通信。&lt;/p&gt;
&lt;p&gt;　　5）、ThreadLocal&lt;/p&gt;
&lt;p&gt;　　　　ThreadLocal，即线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。可以通过set(T)方法来设置一个值，在当前线程下通过get()方法获取原先获取的值。&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　下面摘抄《Java并发编程的艺术》中的一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Profiler {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final ThreadLocal&amp;lt;Long&amp;gt; TIME_THREADLOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Long&amp;gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Long initialValue(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.currentTimeMillis();
        }
    };
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; begin(){
        TIME_THREADLOCAL.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(System.currentTimeMillis());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt;&lt;span&gt; end(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; System.currentTimeMillis() - TIME_THREADLOCAL.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        Profiler.begin();
        TimeUnit.SECONDS.sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cost: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+Profiler.end() +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; mills&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;);
    }
}&lt;p&gt;运行结果：&lt;br/&gt;Cost: 1005 mills&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 参考资料：&lt;em id=&quot;__mceDel&quot;&gt;《Java并发编程的艺术》&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　最后，如有写的不对或不好的地方，请指出，谢谢！&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 15:38:00 +0000</pubDate>
<dc:creator>Marksmanbat</dc:creator>
<og:description>1、线程相关概念 1）、线程与进程的区别 线程是操作系统调度的最小单元，也叫轻量级进程，而进程是操作系统中的应用程序，在进程中可以创建多个线程。 2）、上下文切换 我们知道现代处理器都是多核的，几核处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-Marksman/p/9322589.html</dc:identifier>
</item>
<item>
<title>安装window下的redis，redis可视化管理工具（Redis Desktop Manager）安装，基础使用，实例化项目 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9090819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9090819.html</guid>
<description>&lt;p&gt;以下包括内容：&lt;/p&gt;
&lt;p&gt;一、redis下载安装，启动&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;二、Redis可视化管理工具（Redis Desktop Manager）安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、实例化项目&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、redis下载安装，启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，redis官方下载地址：&lt;a href=&quot;https://redis.io/download&quot; target=&quot;_blank&quot;&gt;https://redis.io/download&lt;/a&gt;，redis 64位下载地址：&lt;a href=&quot;https://github.com/ServiceStack/redis-windows&quot; target=&quot;_blank&quot;&gt;https://github.com/ServiceStack/redis-windows&lt;/a&gt;，本人测试使用的是redis-64.3.0.503版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、解压redis-64.3.0.503.zip，解压后的文件结构如下：&lt;/strong&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20171219090318125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM0MzI5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、修改redis.windows.conf文件，设置maxmemory 大小 &lt;/strong&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20171219091440982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM0MzI5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;设置redis密码 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20171219091155063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM0MzI5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、启动redis:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;redis-server.exe redis.windows.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525213857253-1004007223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、测试，成功安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525214514046-1613095057.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 6、将redis加入到windows的服务中（都是两个-）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-server --service-install redis.windows.conf --loglevel verbose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525215107622-1712402627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、安装成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525215036141-411132990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、但是安装好之后，Redis并没有启动，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）启动命令如下：&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（2）停止命令：&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（3）还可以安装多个实例&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;install &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService1 &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;port &lt;span class=&quot;lit&quot;&gt;10001&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;install &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService2 &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;port &lt;span class=&quot;lit&quot;&gt;10002&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L4&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;install &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService3 &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;port &lt;span class=&quot;lit&quot;&gt;10003&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L5&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（4）卸载命令：&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;uninstall&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;二、Redis可视化管理工具（Redis Desktop Manager）安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、安装过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529223732249-856798621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529223825483-1208704894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529223913379-501197861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529224107425-1893009414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、基本操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先确定redis服务启动没有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811230500101-1668058419.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出现这样的就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1、新建连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;自己起一个redis名字，随便取，输入redis的连接服务器密码，保存就好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811231849716-58935052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自己之前设置的myKey，userInfo，username的值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811230815743-32462400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一条的值是，自己singlePointSystem系统（&lt;a href=&quot;https://github.com/saucxs/PointSingleSystem&quot; target=&quot;_blank&quot;&gt;https://github.com/saucxs/PointSingleSystem&lt;/a&gt;）的登录的时候，把成功的登录的结果存到redis服务器中，这样就不用每一次都从服务器里查询是否登录。&lt;/p&gt;
&lt;p&gt;样例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811234256644-1872287861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Aug 2018 15:22:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>以下包括内容： 一、redis下载安装，启动 二、Redis可视化管理工具（Redis Desktop Manager）安装 三、实例化项目 一、redis下载安装，启动 1，redis官方下载地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9090819.html</dc:identifier>
</item>
<item>
<title>WebGL绘制有端头的线 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/9461506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/9461506.html</guid>
<description>&lt;p&gt;　　关于WebGL绘制线原理不明白的小伙伴，可以看看我之前的文章&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/dojo-lzz/p/9219290.html&quot;&gt;WebGL绘制有宽度的线&lt;/a&gt;。这一篇我们主要来介绍端头的绘制，先看效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811221330458-699605154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　端头一般被称为lineCap，主要有以下三种形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811221457829-1905375009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　butt最简单等于没有端头，square一般是多出lineWidth/2的长度，round是一个以lineWidth/2为半径的圆。一般情况下绘制lineCap的思路都是添加额外的三角形，如一些开元库或者mapbox的方法，一般来说mapbox的方法已经可以了，但是我还是感觉顶点太多，甚至对square的情况都不愿意在增加两个顶点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811221751424-1409508421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方法总是自己去探索的，在绘制宽度线中，我已经总结了自己的一套理论，将线距离映射成uv坐标的思路来绘制一些线的效果，那么在这里仍然沿着这种思路去思考。&lt;/p&gt;
&lt;p&gt;　　对于square来说只要在绘制顶点的时候，在线的开头和结尾分别做一定的偏移即可。对于round我们可以在suqare的基础上，在片元着色器中做一些判断，距离中心点距离大于lineWidth/2的像素全部抛弃掉。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811222814911-1778992368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以对于线起点和终点处顶点的位置在上一篇文章的基础上，做了沿着线方向的偏移&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; flag -1代表线起点, 1代表线终点；同时为了防止一些精度问题，同样使用纹理值来做一些判断，让真正的起点和终点做偏移，防止其中的一些小碎线段影响结果&lt;/span&gt;
'    vec2 vertical_offset = normal * lineWidth * realSide * 0.5;'&lt;span&gt;,
&lt;/span&gt;'    vec2 horizontal_offset = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;'    if (flag == -1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = -dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'    } else if (flag == 1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;'    if (useLineCap &amp;lt;= 0.0) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset.xy = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;'        vUV.x = uv.x;'&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;'    vec2 pos = currentP + vertical_offset + horizontal_offset;'&lt;span&gt;,
&lt;/span&gt;'    gl_Position = unproject(pos, finalPosition.z, finalPosition.w);',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样的话我们就能绘制出square类型的lineCap。但是对于round仅仅这样做还不行，还需要在片元着色器中根据中心点做一次剔除。那么问题来了，经过偏移后如何知道圆心点的位置，在来根据像素距离来进行剔除。这时候就轮到上篇文章利用纹理坐标来表示线长度的思路了，上一篇中我们把路线长度映射成从0-1的uv坐标，那么对于端头来说，我们可以把超出的那一半线宽的像素映射成纹理坐标，可以想象这部分长度对于起点来说等于负的线长度，对应的纹理坐标就是负的纹理坐标；对于终点来说多出的这部分像素等于增加了的线长度，那么对应纹理坐标就是超过1的部分。那么接下来的问题就是如何把线上的像素长度对应于线的长度等于把像素与3d世界中的单位进行映射。&lt;/p&gt;
&lt;p&gt;　　如果对投影矩阵不是很了解的同学，最好看看我的这篇文章&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/dojo-lzz/p/7223364.html&quot;&gt;webgl开发第一道坎——矩阵与坐标变换&lt;/a&gt;，这里我们需要用到投影矩阵的中的元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811224510634-2113494509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　resolution.x代表canvas显示元素的宽度，这里恐怕有些地方不太好理解。n其实是代表相机的近平面，我们先假设为1；那么pixelWidthRatio表示像素与3d单位的一个比值的一半。后面我们先暂时也假设finalPosition.w的值也为一，那么最终vPixelWidth的值表示每像素代表多少3d单位。但是由于视锥体的投影变换并不是线性的，所以这样得到的vPixelWidth并不适用视锥体中的所有地方。这时候我们回来看pixelWidthRatio有一个分母n代表近平面，finalPosition.w代表投影后的点距离相机坐标中的z值距离。w/n这里是想用线性来补充一部分非线性变换带来的影响，让vPixelWidth表示每像素代表多少3d单位这个结果尽量的准确。实际效果也确实可以达到预期。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
'    float aspect = resolution.x / resolution.y;', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏幕宽高比&lt;/span&gt;
'     float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (r-l)/(2n*Width)&lt;/span&gt;
''&lt;span&gt;,
&lt;/span&gt;'    vColor = vec4( color, opacity );'&lt;span&gt;,
&lt;/span&gt;'    vUV = uv;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec4 finalPosition = transform(position);'&lt;span&gt;,
&lt;/span&gt;'    vec4 prevPos = transform(previous);'&lt;span&gt;,
&lt;/span&gt;'    vec4 nextPos = transform(next);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec2 currentP = project(finalPosition);'&lt;span&gt;,
&lt;/span&gt;'    vec2 prevP = project(prevPos);'&lt;span&gt;,
&lt;/span&gt;'    vec2 nextP = project(nextPos);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,&lt;/span&gt;'    float pixelWidth = finalPosition.w * pixelWidthRatio;'&lt;span&gt;,
&lt;/span&gt;'    vPixelWidth = pixelWidth * 2.0;',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在我们可以将端头多出的一半线宽的像素距离转化成线的距离，同时在转化成纹理单位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
'    vec2 horizontal_offset = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;'    if (flag == -1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = -dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'        float radio = length(horizontal_offset) * vPixelWidth / repeat.x;',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; repeat.x代表线的距离长度&lt;/span&gt;
'        vUV.x -= radio;'&lt;span&gt;,
&lt;/span&gt;'    } else if (flag == 1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'        float radio = length(horizontal_offset) * vPixelWidth / repeat.x;'&lt;span&gt;,
&lt;/span&gt;'        vUV.x += radio;'&lt;span&gt;,
&lt;/span&gt;'    }',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们可以在片元着色器中进行剔除工作。这里我们需要做几步工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;纹理坐标转换成线的距离长度&lt;/li&gt;
&lt;li&gt;线的距离长度转换成像素单位&lt;/li&gt;
&lt;li&gt;对大于lineWidth/2长度的像素进行剔除&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
'varying float vPixelWidth;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'void main() {'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'  vec4 c = vColor;'&lt;span&gt;,
&lt;/span&gt;'  float uvx = vUV.x * repeat.x;'&lt;span&gt;,
&lt;/span&gt;'  vec2 coord = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '  float horizontal = 0.0;',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '  float vertical = 0.0;',&lt;/span&gt;
'  if (uvx &amp;lt; 0.0) {'&lt;span&gt;,
&lt;/span&gt;'    coord.x = abs(uvx) / vPixelWidth;'&lt;span&gt;,
&lt;/span&gt;'    coord.y = abs(vUV.y - 0.5) * lineWidth;'&lt;span&gt;,
&lt;/span&gt;'  } else if (uvx &amp;gt; repeat.x) {'&lt;span&gt;,
&lt;/span&gt;'    coord.x = abs(uvx - repeat.x) / vPixelWidth;'&lt;span&gt;,
&lt;/span&gt;'    coord.y = abs(vUV.y - 0.5) * lineWidth;'&lt;span&gt;,
&lt;/span&gt;'  }'&lt;span&gt;,
&lt;/span&gt;'  if (length(coord) &amp;gt; lineWidth * 0.5) {c.a = 0.0;}'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    float uvx = vUV.x * repeat.x;',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '    if (uvx &amp;lt; 0.0 || uvx &amp;gt; repeat.x) {c.x=1.0;c.y=0.0;c.z=0.0;c.a = 1.0;}',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '     if( c.a &amp;lt; alphaTest ) c.a = 0.0;',&lt;/span&gt;

'    gl_FragColor = c;'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '     gl_FragColor.a *= step(vCounters,visibility);',&lt;/span&gt;
'}' ];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们需要用到varying变量对vPixelWidth进行差值。最终我们绘制出round的lineCap效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811230450737-1463888976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Aug 2018 15:11:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<og:description>关于WebGL绘制线原理不明白的小伙伴，可以看看我之前的文章WebGL绘制有宽度的线。这一篇我们主要来介绍端头的绘制，先看效果图。 端头一般被称为lineCap，主要有以下三种形式： butt最简单等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/9461506.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--16 利用几何着色器可选的流输出阶段帮助绘制多种分形 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9461074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9461074.html</guid>
<description>&lt;p&gt;在上一章，我们知道了如何使用几何着色器来重新组装图元，比如从一个三角形分裂成三个三角形。但是为了实现更高阶的分形，我们必须要从几何着色器拿到输出的顶点。这里我们可以使用可选的流输出阶段来拿到顶点集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意: 本章末尾有大量的GIF动图！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在我们知道GPU可以写入纹理(textures)，例如深度/模板缓冲区以及后备缓冲区。当然，我们也可以通过渲染管线的流输出阶段让GPU将几何着色器输出的顶点集合写入到指定的顶点缓冲区(vertex buffer)。除此之外，我们还能够指定不进行光栅化以及后续的所有阶段，仅让顶点数据经过流输出阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180810093044735-1752743030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在几何着色器中，最多四个流输出对象可以被设置，即几何着色器的入口函数中只允许设置四个流输出对象的参数。当多个流输出对象存在时，它们必须都要为&lt;code&gt;PointStream&lt;/code&gt;类模板，但允许模板参数不同。输出的顶点回流到顶点缓冲区后可以再次进行一遍新的渲染管线流程。&lt;/p&gt;
&lt;p&gt;上一章也提到，几何着色器的单次调用不能产出超过1024个标量。因此分配给所有流输出对象的标量总和不能超过1024。比如现在我有2个流输出对象，它们的结构体相同，容纳512个标量，那最多仅允许输出2个这样的顶点来分配给这2个流输出对象。&lt;/p&gt;

&lt;h2 id=&quot;id3d11devicecontextsosettargets方法--绑定流输出对应用于接收数据的顶点缓冲区&quot;&gt;ID3D11DeviceContext::SOSetTargets方法--绑定流输出对应用于接收数据的顶点缓冲区&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::SOSetTargets(
  UINT         NumBuffers,              // [In]顶点缓冲区数目
  ID3D11Buffer * const *ppSOTargets,    // [In]顶点缓冲区数组
  const UINT   *pOffsets                // [In]一个数组包含对每个顶点缓冲区的字节偏移量
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法多允许设置4个顶点缓冲区。&lt;/p&gt;
&lt;p&gt;每个要绑定到流输出阶段的缓冲区资源必须要在创建的时候额外设置&lt;code&gt;D3D11_BIND_STREAM_OUTPUT&lt;/code&gt;绑定标签。&lt;/p&gt;
&lt;p&gt;若偏移值设为-1，则会引起流输出缓冲区被追加到最后一个缓冲区的后面&lt;/p&gt;
&lt;p&gt;顶点缓冲区绑定到流输出阶段的输出槽0操作如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;UINT offset = 0;
md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们需要恢复默认的状态，则可以这样调用：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ID3D11Buffer* nullBuffer = nullptr;
UINT offset = 0;
md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意: 如果使用的是当前绑定到输入装配阶段的顶点缓冲区，则绑定会失效。因为顶点缓冲区不可以同时被绑定到输入装配阶段和流输出阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为后续我们是将每一阶输出的顶点都保存下来，即便不需要交换顶点缓冲区，但也有可能出现同时绑定输入/输出的情况。一种合理的绑定顺序如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
UINT stride = sizeof(VertexPosColor);
UINT offset = 0;
ID3D11Buffer * nullBuffer = nullptr;
md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);
// ...
md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
// ...
md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当渲染管线完成一次流输出后，我们就可以用下面的方法来获取绑定在流输出阶段上的顶点缓冲区（当然你本身持有该缓冲区的指针的话就不需要了）&lt;/p&gt;
&lt;h2 id=&quot;id3d11devicecontextsogettargets方法--获取绑定在流输出阶段的顶点缓冲区&quot;&gt;ID3D11DeviceContext::SOGetTargets方法--获取绑定在流输出阶段的顶点缓冲区&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::SOGetTargets(
  UINT         NumBuffers,          // [In]缓冲区数目
  ID3D11Buffer **ppSOTargets        // [Out]获取绑定流输出阶段的顶点缓冲区
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的顶点缓冲区引用数会加1，最好是能够使用&lt;code&gt;ComPtr&lt;/code&gt;来承接顶点缓冲区，否则就要在结束的时候手工调用&lt;code&gt;Release&lt;/code&gt;方法，若忘记调用则会引发内存泄漏。&lt;/p&gt;
&lt;h2 id=&quot;id3d11devicecreategeometryshaderwithstreamoutput方法--创建带流输出阶段的几何着色器&quot;&gt;ID3D11Device::CreateGeometryShaderWithStreamOutput方法--创建带流输出阶段的几何着色器&lt;/h2&gt;
&lt;p&gt;接下来我们需要指定数据会流向哪个输出槽，首先我们需要填充结构体&lt;code&gt;D3D11_SO_DECLARATION_ENTRY&lt;/code&gt;，结构体声明如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_SO_DECLARATION_ENTRY {
  UINT   Stream;            // 输出流索引，从0开始
  LPCSTR SemanticName;      // 语义名
  UINT   SemanticIndex;     // 语义索引
  BYTE   StartComponent;    // 从第几个分量(xyzw)开始,只能取0-3
  BYTE   ComponentCount;    // 分量的输出数目，只能取1-4
  BYTE   OutputSlot;        // 输出槽索引，只能取0-3
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，语义名&lt;code&gt;SemanticName&lt;/code&gt;用于指定在几何着色器的流输出对象对应的结构体中该语义描述的成员，然后用语义索引&lt;code&gt;SemanticIndex&lt;/code&gt;指定存在同名语义下用索引值标记的唯一成员。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;StartComponent&lt;/code&gt;和&lt;code&gt;ComponentCount&lt;/code&gt;用于控制该向量需要输出哪些分量。若&lt;code&gt;StartComponent&lt;/code&gt;为1，&lt;code&gt;ComponentCount&lt;/code&gt;为2，则输出的分量为&lt;code&gt;(y, z)&lt;/code&gt;，而要输出全部分量，则指定&lt;code&gt;StartCompnent&lt;/code&gt;为0, &lt;code&gt;ComponentCount&lt;/code&gt;为4.&lt;/p&gt;
&lt;p&gt;输出槽索引&lt;code&gt;OutputSlot&lt;/code&gt;用于指定选择绑定流输出的缓冲区数组中的某一元素。&lt;/p&gt;
&lt;p&gt;由于这里一个结构体只能指定某个输出流中的某一向量，所以通常我们需要像顶点输入布局那样传递一个数组来取出组合成特定顶点。&lt;/p&gt;
&lt;p&gt;比如说现在顶点着色器输入的顶点和流输出的顶点是一致的:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct VertexPosColor
{
    DirectX::XMFLOAT3 pos;
    DirectX::XMFLOAT4 color;
    static const D3D11_INPUT_ELEMENT_DESC inputLayout[2];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入布局描述如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const D3D11_INPUT_ELEMENT_DESC VertexPosColor::inputLayout[2] = {
    { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { &quot;COLOR&quot;, 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HLSL中的结构体如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct VertexPosColor
{
    float3 PosL : POSITION;
    float4 Color : COLOR;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流输出的入口描述如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const D3D11_SO_DECLARATION_ENTRY posColorLayout[2] = {
    { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
    { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对应的是索引为0的流输出对象，输出给绑定在索引为0的输出槽的顶点缓冲区，先输出语义为POSITION的向量中的xyz分量，然后输出COLOR整个向量。这样一个输出的顶点就和原来的顶点一致了。&lt;/p&gt;
&lt;p&gt;接下来给出&lt;code&gt;ID3D11Device::CreateGeometryShaderWithStreamOutput&lt;/code&gt;方法的原型：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11Device::CreateGeometryShaderWithStreamOutput(
  const void                       *pShaderBytecode,    // [In]编译好的着色器字节码
  SIZE_T                           BytecodeLength,      // [In]字节码长度
  const D3D11_SO_DECLARATION_ENTRY *pSODeclaration,     // [In]D3D11_SO_DECLARATION_ENTRY的数组
  UINT                             NumEntries,          // [In]入口总数
  const UINT                       *pBufferStrides,     // [In]一个数组包含了每个绑定到流输出的缓冲区中顶点字节大小
  UINT                             NumStrides,          // [In]上面数组的元素数目
  UINT                             RasterizedStream,    // [In]按索引指定哪个流输出对象用于传递到光栅化阶段
  ID3D11ClassLinkage               *pClassLinkage,      // [In]忽略
  ID3D11GeometryShader             **ppGeometryShader   // [Out]创建好的几何着色器
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不需要有流输出对象提供数据给光栅化阶段，则&lt;code&gt;RasterizedStream&lt;/code&gt;应当指定为&lt;code&gt;D3D11_SO_NO_RASTERIZED_STREAM&lt;/code&gt;。即便某一流输出对象传递了数据给光栅化阶段，它仍可以提供数据给某一绑定的缓冲区。&lt;/p&gt;
&lt;p&gt;当该着色器被绑定到渲染管线上，流输出阶段就会被激活。然后当渲染管线开始执行的时候，任何传递给几何着色器中的流输出对象的数据，都会基于语义名和语义索引尝试匹配输出布局。一旦发现有匹配的语义，该数据就会流向对应的缓冲区来创建完整的输出顶点集。&lt;/p&gt;
&lt;p&gt;下面是一个调用的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const D3D11_SO_DECLARATION_ENTRY posColorLayout[2] = {
    { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
    { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
};

HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posColorLayout, ARRAYSIZE(posColorLayout),
    &amp;amp;stridePosColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mTriangleSOGS.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于现在的着色器多到令人发指，而且有没有很好的办法归类整合，故在下面用一张表列出所有绘制流程用到的着色器hlsl文件名称:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通过流输出得到分裂的三角形&lt;/td&gt;
&lt;td&gt;TriangleSO_VS&lt;/td&gt;
&lt;td&gt;TriangleSO_GS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通过流输出得到分形雪花&lt;/td&gt;
&lt;td&gt;SnowSO_VS&lt;/td&gt;
&lt;td&gt;SnowSO_GS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通过流输出得到分形球体&lt;/td&gt;
&lt;td&gt;SphereSO_VS&lt;/td&gt;
&lt;td&gt;SphereSO_GS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;绘制分形三角形&lt;/td&gt;
&lt;td&gt;Triangle_VS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Triangle_PS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;绘制分形雪花&lt;/td&gt;
&lt;td&gt;Snow_VS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Snow_PS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;绘制分形球体&lt;/td&gt;
&lt;td&gt;Sphere_VS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Sphere_PS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;绘制法向量&lt;/td&gt;
&lt;td&gt;Normal_VS&lt;/td&gt;
&lt;td&gt;Normal_GS&lt;/td&gt;
&lt;td&gt;Normal_PS&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;首先给出&lt;code&gt;Basic.fx&lt;/code&gt;文件的内容，要注意里面的常量缓冲区和之前有所变化:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;LightHelper.hlsli&quot;

cbuffer CBChangesEveryFrame : register(b0)
{
    row_major matrix gWorld;
    row_major matrix gWorldInvTranspose;
}

cbuffer CBChangesOnResize : register(b1)
{
    row_major matrix gProj;
}

cbuffer CBNeverChange : register(b2)
{
    DirectionalLight gDirLight;
    Material gMaterial;
    row_major matrix gView;
    float3 gSphereCenter;
    float gSphereRadius;
    float3 gEyePosW;
}


struct VertexPosColor
{
    float3 PosL : POSITION;
    float4 Color : COLOR;
};

struct VertexPosHColor
{
    float4 PosH : SV_POSITION;
    float4 Color : COLOR;
};

struct VertexPosHLColor
{
    float4 PosH : SV_POSITION;
    float3 PosL : POSITION;
    float4 Color : COLOR;
};


struct VertexPosNormalColor
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float4 Color : COLOR;
};

struct VertexPosHWNormalColor
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION;
    float3 NormalW : NORMAL;
    float4 Color : COLOR;
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战1-绘制分形三角形&quot;&gt;实战1: 绘制分形三角形&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811171149522-1121949958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过流输出阶段，一个三角形就分裂出了三个三角形，顶点的数目翻了3倍。若规定1阶分形三角形的顶点数为3，则N阶分形三角形的顶点数为&lt;span class=&quot;math inline&quot;&gt;\(3^{N}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;首先是&lt;code&gt;TriangleSO_VS.hlsl&lt;/code&gt;，它负责将顶点直接传递给几何着色器。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// TriangleSO_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosColor VS(VertexPosColor pIn)
{
    return pIn;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后和上一章一样，&lt;code&gt;TriangleSO_GS.hlsl&lt;/code&gt;中的几何着色器将一个三角形分裂成三个三角形，并且输出的顶点类型和输入的顶点是一致的。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// TriangleSO_GS.hlsl
#include &quot;Basic.fx&quot;

[maxvertexcount(9)]
void GS(triangle VertexPosColor input[3], inout TriangleStream&amp;lt;VertexPosColor&amp;gt; output)
{
    //
    // 将一个三角形分裂成三个三角形，即没有v3v4v5的三角形
    //       v1
    //       /\
    //      /  \
    //   v3/____\v4
    //    /\xxxx/\
    //   /  \xx/  \
    //  /____\/____\
    // v0    v5    v2


    VertexPosColor vertexes[6];
    int i;
    [unroll]
    for (i = 0; i &amp;lt; 3; ++i)
    {
        vertexes[i] = input[i];
        vertexes[i + 3].Color = (input[i].Color + input[(i + 1) % 3].Color) / 2.0f;
        vertexes[i + 3].PosL = (input[i].PosL + input[(i + 1) % 3].PosL) / 2.0f;
    }

    [unroll]
    for (i = 0; i &amp;lt; 3; ++i)
    {
        output.Append(vertexes[i]);
        output.Append(vertexes[3 + i]);
        output.Append(vertexes[(i + 2) % 3 + 3]);

        output.RestartStrip();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的&lt;code&gt;Triangle_VS.hlsl&lt;/code&gt;和&lt;code&gt;Triangle_PS.hlsl&lt;/code&gt;则是常规的三角形绘制:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Triangle_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHColor VS(VertexPosColor pIn)
{
    row_major matrix worldViewProj = mul(mul(gWorld, gView), gProj);
    VertexPosHColor pOut;
    pOut.Color = pIn.Color;
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    return pOut;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Triangle_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHColor pIn) : SV_Target
{
    return pIn.Color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战2-绘制分形雪花&quot;&gt;实战2: 绘制分形雪花&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811200638475-1077546894.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811200609974-1170475769.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在规定第一张图为一阶分形雪花，第二张为二阶分形雪花。观察二者之间的变化，可以发现前者的每一条直线变成了四条折线。其中每个尖锐角的度数都在60度，并且每条边的长度都应该是一致的。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码-1&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;和之前一样，&lt;code&gt;SnowSO_VS.hlsl&lt;/code&gt;中的顶点着色器阶段只用于顶点直传:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SnowSO_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosNormalColor VS(VertexPosNormalColor pIn)
{
    return pIn;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重点就在于&lt;code&gt;SnowSO_GS.hlsl&lt;/code&gt;的几何着色器了。这里先放出代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SnowSO_GS.hlsl
#include &quot;Basic.fx&quot;

[maxvertexcount(5)]
void GS(line VertexPosColor input[2], inout LineStream&amp;lt;VertexPosColor&amp;gt; output)
{
    // 要求分形线段按顺时针排布
    // z分量必须相等，因为顶点没有提供法向量无法判断垂直上方向
    //                       v1
    //                       /\
    // ____________ =&amp;gt;  ____/  \____
    // i0         i1   i0  v0  v2  i1
    
    VertexPosColor v0, v1, v2;
    v0.Color = lerp(input[0].Color, input[1].Color, 0.25f);
    v1.Color = lerp(input[0].Color, input[1].Color, 0.5f);
    v2.Color = lerp(input[0].Color, input[1].Color, 0.75f);

    v0.PosL = lerp(input[0].PosL, input[1].PosL, 1.0f / 3.0f);
    v2.PosL = lerp(input[0].PosL, input[1].PosL, 2.0f / 3.0f);

    // xy平面求出它的垂直单位向量
    //     
    //     |
    // ____|_____
    float2 upDir = normalize(input[1].PosL - input[0].PosL).yx;
    float len = length(input[1].PosL.xy - input[0].PosL.xy);
    upDir.x = -upDir.x;

    v1.PosL = lerp(input[0].PosL, input[1].PosL, 0.5f);
    v1.PosL.xy += sqrt(3) / 6.0f * len * upDir;

    output.Append(input[0]);
    output.Append(v0);
    output.Append(v1);
    output.Append(v2);
    output.Append(input[1]);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现分形雪花每升一阶，需要绘制的顶点数就变成了上一阶的4倍。&lt;/p&gt;
&lt;p&gt;这里要求了z分量必须相等，因为使用的着色器仍把一切的顶点仍当做3D顶点来对待出来（当然你也可以写成2D的着色器）。&lt;/p&gt;
&lt;p&gt;然后开始具体分析从直线变折线的过程，可以看到因为顶点v1所在角的度数在60度，且v0, v1, v2构成等边三角形，故v0v2,&lt;br/&gt;v0v1和v1v2的边长是一致的。而且4条折线要求边长相等，故这里的i0v0和v2i1应当各占线段i0i1的1/3.&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;lerp&lt;/code&gt;函数是线性插值函数，数学公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{p} = \mathbf{p}_0 + t(\mathbf{p}_1 - \mathbf{p}_0) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中t的取值范围在[0.0f, 1.0f]，并且操作对象p0和p1可以是标量，也可以是矢量，对矢量来说则是对每个分量都进行线性插值。&lt;/p&gt;
&lt;p&gt;当t = 0.5f时，描述的就是p0和p1的中值或中点。&lt;/p&gt;
&lt;p&gt;该函数很容易描述两点之间某一相对位置。&lt;/p&gt;
&lt;p&gt;由于我们规定了连续线段必须按顺时针排布，我们就可以利用向量i0i1逆时针旋转90度得到对应的突出方向向量，然后标准化，乘上相应的高度值即可得到顶点v1的位置。&lt;/p&gt;
&lt;p&gt;最后就是用于绘制的着色器代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Snow_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHColor VS(VertexPosColor pIn)
{
    row_major matrix worldViewProj = mul(mul(gWorld, gView), gProj);
    VertexPosHColor pOut;
    pOut.Color = pIn.Color;
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    return pOut;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Snow_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHColor pIn) : SV_Target
{
    return pIn.Color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战3-绘制分形圆球&quot;&gt;实战3: 绘制分形圆球&lt;/h2&gt;
&lt;p&gt;以下是一阶和二阶的分形圆球:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811205114934-2071592771.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811204931404-1212542141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细观察可以看到，原先的一个三角形分裂出了四个三角形，即每升一阶，需要绘制的顶点数就变成了上一阶的4倍。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码-2&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SphereSO_VS.hlsl&lt;/code&gt;代码和&lt;code&gt;SphereSO_GS.hlsl&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SphereSO_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosNormalColor VS(VertexPosNormalColor pIn)
{
    return pIn;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SphereSO_GS.hlsl

#include &quot;Basic.fx&quot;

[maxvertexcount(12)]
void GS(triangle VertexPosNormalColor input[3], inout TriangleStream&amp;lt;VertexPosNormalColor&amp;gt; output)
{
    //
    // 将一个三角形分裂成四个三角形，但同时顶点v3, v4, v5也需要在球面上
    //       v1
    //       /\
    //      /  \
    //   v3/____\v4
    //    /\xxxx/\
    //   /  \xx/  \
    //  /____\/____\
    // v0    v5    v2
    
    VertexPosNormalColor vertexes[6];

    matrix viewProj = mul(gView, gProj);

    [unroll]
    for (int i = 0; i &amp;lt; 3; ++i)
    {
        vertexes[i] = input[i];
        vertexes[i + 3].Color = lerp(input[i].Color, input[(i + 1) % 3].Color, 0.5f);
        vertexes[i + 3].NormalL = normalize(input[i].NormalL + input[(i + 1) % 3].NormalL);
        vertexes[i + 3].PosL = gSphereCenter + gSphereRadius * vertexes[i + 3].NormalL;
    }
        
    output.Append(vertexes[0]);
    output.Append(vertexes[3]);
    output.Append(vertexes[5]);
    output.RestartStrip();

    output.Append(vertexes[3]);
    output.Append(vertexes[4]);
    output.Append(vertexes[5]);
    output.RestartStrip();

    output.Append(vertexes[5]);
    output.Append(vertexes[4]);
    output.Append(vertexes[2]);
    output.RestartStrip();

    output.Append(vertexes[3]);
    output.Append(vertexes[1]);
    output.Append(vertexes[4]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于v3, v4, v5也需要在球面上，我们还需要额外知道球的半径和球心位置。虽然说通过三角形三个顶点位置和法向量可以算出圆心和半径，但直接从常量缓冲区提供这两个信息会更方便一些。&lt;/p&gt;
&lt;p&gt;要计算诸如v3顶点所在位置，我们可以先求出它的法向量，将v0和v1的法向量相加取其单位向量即为v3的法向量，然后从圆心开始加上半径长度的法向量即可得到顶点v3的位置。&lt;/p&gt;
&lt;p&gt;剩下绘制圆的着色器代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Sphere_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHWNormalColor VS(VertexPosNormalColor pIn)
{
    VertexPosHWNormalColor pOut;
    row_major matrix viewProj = mul(gView, gProj);
    pOut.PosW = mul(float4(pIn.PosL, 1.0f), gWorld).xyz;
    pOut.PosH = mul(float4(pOut.PosW, 1.0f), viewProj);
    pOut.NormalW = mul(pIn.NormalL, (float3x3) gWorldInvTranspose);
    pOut.Color = pIn.Color;
    return pOut;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Sphere_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHWNormalColor pIn) : SV_Target
{
    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 顶点指向眼睛的向量
    float3 toEyeW = normalize(gEyePosW - pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);

    // 只计算方向光
    ComputeDirectionalLight(gMaterial, gDirLight, pIn.NormalW, toEyeW, ambient, diffuse, spec);

    return pIn.Color * (ambient + diffuse) + spec;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;basicfx.h的变化&quot;&gt;BasicFX.h的变化&lt;/h2&gt;
&lt;p&gt;首先是常量缓冲区的变化，新增了存储球心位置和半径信息：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct CBChangesEveryFrame
{
    DirectX::XMMATRIX world;
    DirectX::XMMATRIX worldInvTranspose;
};

struct CBChangesOnResize
{
    DirectX::XMMATRIX proj;
};

struct CBNeverChange
{
    DirectionalLight dirLight;
    Material material;
    DirectX::XMMATRIX view;
    DirectX::XMFLOAT3 sphereCenter;
    float sphereRadius;
    DirectX::XMFLOAT3 eyePos;
    float pad;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是&lt;code&gt;BasicFX&lt;/code&gt;类的变化，其中法向量的绘制可以用于球体绘制的时候，具体实现可以回顾上一章。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class BasicFX
{
public:
    // 使用模板别名(C++11)简化类型名
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    // 初始化Basix.fx所需资源并初始化光栅化状态
    bool InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device);
    // 是否已经初始化
    bool IsInit() const;

    template &amp;lt;class T&amp;gt;
    void UpdateConstantBuffer(const T&amp;amp; cbuffer);

    // 绘制三角形分形
    void SetRenderSplitedTriangle();
    // 绘制雪花
    void SetRenderSplitedSnow();
    // 绘制球体
    void SetRenderSplitedSphere();
    // 通过流输出阶段获取三角形分裂的下一阶分形
    void SetStreamOutputSplitedTriangle(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut);
    // 通过流输出阶段获取雪花的下一阶分形
    void SetStreamOutputSplitedSnow(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut);
    // 通过流输出阶段获取球的下一阶分形
    void SetStreamOutputSplitedSphere(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut);

    // 绘制所有顶点的法向量
    void SetRenderNormal();

private:
    // objFileNameInOut为编译好的着色器二进制文件(.*so)，若有指定则优先寻找该文件并读取
    // hlslFileName为着色器代码，若未找到着色器二进制文件则编译着色器代码
    // 编译成功后，若指定了objFileNameInOut，则保存编译好的着色器二进制信息到该文件
    // ppBlobOut输出着色器二进制信息
    HRESULT CreateShaderFromFile(const WCHAR* objFileNameInOut, const WCHAR* hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob** ppBlobOut);

private:
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mTriangleSOVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mTriangleSOGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mTriangleVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mTrianglePS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSphereSOVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mSphereSOGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSphereVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mSpherePS;
    
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSnowSOVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mSnowSOGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSnowVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mSnowPS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mNormalVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mNormalGS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mNormalPS;

    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosColorLayout;        // VertexPosColor输入布局
    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosNormalColorLayout;  // VertexPosNormalColor输入布局

    ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; md3dImmediateContext;       // 设备上下文

    std::vector&amp;lt;ComPtr&amp;lt;ID3D11Buffer&amp;gt;&amp;gt; mConstantBuffers;     // 常量缓冲区
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxinitall方法的变化&quot;&gt;BasicFX::InitAll方法的变化&lt;/h3&gt;
&lt;p&gt;现在着色器的创建按绘制类别进行分组：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool BasicFX::InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device)
{
    if (!device)
        return false;

    const D3D11_SO_DECLARATION_ENTRY posColorLayout[2] = {
        { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
        { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
    };

    const D3D11_SO_DECLARATION_ENTRY posNormalColorLayout[3] = {
        { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
        { 0, &quot;NORMAL&quot;, 0, 0, 3, 0 },
        { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
    };

    UINT stridePosColor = sizeof(VertexPosColor);
    UINT stridePosNormalColor = sizeof(VertexPosNormalColor);

    ComPtr&amp;lt;ID3DBlob&amp;gt; blob;

    //
    // 流输出分裂三角形
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\TriangleSO_VS.vso&quot;, L&quot;HLSL\\TriangleSO_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTriangleSOVS.GetAddressOf()));
    // 创建顶点输入布局
    HR(device-&amp;gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout), blob-&amp;gt;GetBufferPointer(),
        blob-&amp;gt;GetBufferSize(), mVertexPosColorLayout.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\TriangleSO_GS.gso&quot;, L&quot;HLSL\\TriangleSO_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posColorLayout, ARRAYSIZE(posColorLayout),
        &amp;amp;stridePosColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mTriangleSOGS.GetAddressOf()));
    
    //
    // 绘制分形三角形
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_VS.vso&quot;, L&quot;HLSL\\Triangle_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTriangleVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_PS.pso&quot;, L&quot;HLSL\\Triangle_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTrianglePS.GetAddressOf()));


    //
    // 流输出分形球体
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\SphereSO_VS.vso&quot;, L&quot;HLSL\\SphereSO_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSphereSOVS.GetAddressOf()));
    // 创建顶点输入布局
    HR(device-&amp;gt;CreateInputLayout(VertexPosNormalColor::inputLayout, ARRAYSIZE(VertexPosNormalColor::inputLayout), blob-&amp;gt;GetBufferPointer(),
        blob-&amp;gt;GetBufferSize(), mVertexPosNormalColorLayout.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\SphereSO_GS.gso&quot;, L&quot;HLSL\\SphereSO_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posNormalColorLayout, ARRAYSIZE(posNormalColorLayout),
        &amp;amp;stridePosNormalColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mSphereSOGS.GetAddressOf()));
    
    //
    // 绘制球体
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Sphere_VS.vso&quot;, L&quot;HLSL\\Sphere_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSphereVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Sphere_PS.pso&quot;, L&quot;HLSL\\Sphere_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSpherePS.GetAddressOf()));
    

    //
    // 流输出分形雪花
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\SnowSO_VS.vso&quot;, L&quot;HLSL\\SnowSO_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSnowSOVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\SnowSO_GS.gso&quot;, L&quot;HLSL\\SnowSO_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posColorLayout, ARRAYSIZE(posColorLayout),
        &amp;amp;stridePosColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mSnowSOGS.GetAddressOf()));

    //
    // 绘制雪花
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Snow_VS.vso&quot;, L&quot;HLSL\\Snow_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSnowVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Snow_PS.pso&quot;, L&quot;HLSL\\Snow_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSnowPS.GetAddressOf()));


    //
    // 绘制法向量
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_VS.vso&quot;, L&quot;HLSL\\Normal_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_GS.gso&quot;, L&quot;HLSL\\Normal_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalGS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_PS.pso&quot;, L&quot;HLSL\\Normal_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalPS.GetAddressOf()));

    

    RenderStates::InitAll(device);
    device-&amp;gt;GetImmediateContext(md3dImmediateContext.GetAddressOf());

    // ******************
    // 设置常量缓冲区描述
    mConstantBuffers.assign(3, nullptr);
    D3D11_BUFFER_DESC cbd;
    ZeroMemory(&amp;amp;cbd, sizeof(cbd));
    cbd.Usage = D3D11_USAGE_DEFAULT;
    cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    cbd.CPUAccessFlags = 0;

    cbd.ByteWidth = Align16Bytes(sizeof(CBChangesEveryFrame));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[0].GetAddressOf()));
    cbd.ByteWidth = Align16Bytes(sizeof(CBChangesOnResize));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[1].GetAddressOf()));
    cbd.ByteWidth = Align16Bytes(sizeof(CBNeverChange));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[2].GetAddressOf()));

    // 预先绑定各自所需的缓冲区
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;PSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetrendersplitedtriangle方法--绘制分形三角形&quot;&gt;BasicFX::SetRenderSplitedTriangle方法--绘制分形三角形&lt;/h3&gt;
&lt;p&gt;由于新增了流输出的阶段，这里开始接下来的每一个用于绘制的方法都需要把流输出绑定的顶点缓冲区都解除绑定。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedTriangle()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mTriangleVS.Get(), nullptr, 0);
    // 关闭流输出
    md3dImmediateContext-&amp;gt;GSSetShader(nullptr, nullptr, 0);
    ID3D11Buffer* bufferArray[1] = { nullptr };
    UINT offset = 0;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, bufferArray, &amp;amp;offset);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mTrianglePS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetrendersplitedsnow方法--绘制分形雪花&quot;&gt;BasicFX::SetRenderSplitedSnow方法--绘制分形雪花&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedSnow()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mSnowVS.Get(), nullptr, 0);
    // 关闭流输出
    md3dImmediateContext-&amp;gt;GSSetShader(nullptr, nullptr, 0);
    ID3D11Buffer* bufferArray[1] = { nullptr };
    UINT offset = 0;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, bufferArray, &amp;amp;offset);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mSnowPS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetrendersplitedsphere方法--绘制分形球体&quot;&gt;BasicFX::SetRenderSplitedSphere方法--绘制分形球体&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedSphere()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosNormalColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mSphereVS.Get(), nullptr, 0);
    // 关闭流输出
    md3dImmediateContext-&amp;gt;GSSetShader(nullptr, nullptr, 0);
    ID3D11Buffer* bufferArray[1] = { nullptr };
    UINT offset = 0;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, bufferArray, &amp;amp;offset);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mSpherePS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetstreamoutputsplitedtriangle方法--经过流输出保存下一阶分形三角形的顶点&quot;&gt;BasicFX::SetStreamOutputSplitedTriangle方法--经过流输出保存下一阶分形三角形的顶点&lt;/h3&gt;
&lt;p&gt;为了简化设置，这里还需要提供额外的输入缓冲区和输出缓冲区。为了防止出现顶点缓冲区同时被绑定到输入装配和流输出阶段的情况，需要先清空流输出绑定的顶点缓冲区，然后将用于输入的顶点缓冲区绑定到输入装配阶段，最后才是把输出的顶点缓冲区绑定到流输出阶段。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetStreamOutputSplitedTriangle(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut)
{
    // 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
    UINT stride = sizeof(VertexPosColor);
    UINT offset = 0;
    ID3D11Buffer * nullBuffer = nullptr;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());

    md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, vertexBufferIn.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;VSSetShader(mTriangleSOVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mTriangleSOGS.Get(), nullptr, 0);

    md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);
;
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(nullptr, nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetstreamoutputsplitedsnow方法--经过流输出保存下一阶分形雪花的顶点&quot;&gt;BasicFX::SetStreamOutputSplitedSnow方法--经过流输出保存下一阶分形雪花的顶点&lt;/h3&gt;
&lt;p&gt;注意这里是用LineList而不是LineStrip方式。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetStreamOutputSplitedSnow(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut)
{
    // 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
    UINT stride = sizeof(VertexPosColor);
    UINT offset = 0;
    ID3D11Buffer * nullBuffer = nullptr;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, vertexBufferIn.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;VSSetShader(mSnowSOVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mSnowSOGS.Get(), nullptr, 0);

    md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);

    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(nullptr, nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetstreamoutputsplitedsphere方法--经过流输出保存下一阶分形球体的顶点&quot;&gt;BasicFX::SetStreamOutputSplitedSphere方法--经过流输出保存下一阶分形球体的顶点&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetStreamOutputSplitedSphere(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut)
{
    // 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
    UINT stride = sizeof(VertexPosNormalColor);
    UINT offset = 0;
    ID3D11Buffer * nullBuffer = nullptr;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosNormalColorLayout.Get());
    md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, vertexBufferIn.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;VSSetShader(mSphereSOVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mSphereSOGS.Get(), nullptr, 0);

    md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);

    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(nullptr, nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameapp类的变化&quot;&gt;GameApp类的变化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameApp&lt;/code&gt;类的变化如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class GameApp : public D3DApp
{
public:
    enum class Mode { SplitedTriangle, SplitedSnow, SplitedSphere };
    
public:
    GameApp(HINSTANCE hInstance);
    ~GameApp();

    bool Init();
    void OnResize();
    void UpdateScene(float dt);
    void DrawScene();

private:
    bool InitResource();

    void ResetSplitedTriangle();
    void ResetSplitedSnow();
    void ResetSplitedSphere();


private:
    
    ComPtr&amp;lt;ID2D1SolidColorBrush&amp;gt; mColorBrush;               // 单色笔刷
    ComPtr&amp;lt;IDWriteFont&amp;gt; mFont;                              // 字体
    ComPtr&amp;lt;IDWriteTextFormat&amp;gt; mTextFormat;                  // 文本格式

    ComPtr&amp;lt;ID3D11Buffer&amp;gt; mVertexBuffers[7];                 // 顶点缓冲区数组
    int mVertexCounts[7];                                   // 顶点数目
    int mCurrIndex;                                         // 当前索引
    Mode mShowMode;                                         // 当前显示模式
    bool mIsWireFrame;                                      // 是否为线框模式
    bool mShowNormal;                                       // 是否显示法向量
    BasicFX mBasicFX;                                       // Basic特效管理类

    CBChangesEveryFrame mCBChangeEveryFrame;                // 该缓冲区存放每帧更新的变量
    CBChangesOnResize mCBOnReSize;                          // 该缓冲区存放仅在窗口大小变化时更新的变量
    CBNeverChange mCBNeverChange;                           // 该缓冲区存放不会再进行修改的变量
};

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetsplitedtriangle方法--重新建立包含1-7阶的分形三角形顶点的缓冲区&quot;&gt;GameApp::ResetSplitedTriangle方法--重新建立包含1-7阶的分形三角形顶点的缓冲区&lt;/h3&gt;
&lt;p&gt;首先我们只需要给1阶的顶点缓冲区使用指定三角形的三个顶点，然后后续阶数的顶点缓冲区就根据上一阶产出的顶点缓冲区进行&quot;绘制&quot;。经过6次调用后，里面的7个顶点缓冲区都应该被初始化完毕，后续绘制的时候只需要直接取用某一个顶点缓冲区即可。&lt;/p&gt;
&lt;p&gt;注意顶点缓冲区在创建的时候一定要加上&lt;code&gt;D3D11_BIND_STREAM_OUTPUT&lt;/code&gt;标签。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetSplitedTriangle()
{
    // ******************
    // 初始化三角形
    // 设置三角形顶点
    VertexPosColor vertices[] =
    {
        { XMFLOAT3(-1.0f * 3, -0.866f * 3, 0.0f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f) },
        { XMFLOAT3(0.0f * 3, 0.866f * 3, 0.0f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT3(1.0f * 3, -0.866f * 3, 0.0f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) }
    };
    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_STREAM_OUTPUT;    // 需要额外添加流输出标签
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffers[0].ReleaseAndGetAddressOf()));

    
    // 三角形顶点数
    mVertexCounts[0] = 3;
    // 初始化所有顶点缓冲区
    for (int i = 1; i &amp;lt; ARRAYSIZE(mVertexBuffers); ++i)
    {
        vbd.ByteWidth *= 3;
        mVertexCounts[i] = mVertexCounts[i - 1] * 3;
        HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mVertexBuffers[i].ReleaseAndGetAddressOf()));
        mBasicFX.SetStreamOutputSplitedTriangle(mVertexBuffers[i - 1], mVertexBuffers[i]);
        md3dImmediateContext-&amp;gt;Draw(mVertexCounts[i - 1], 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetsplitedsnow方法--重新建立包含1-7阶的分形雪花顶点的缓冲区&quot;&gt;GameApp::ResetSplitedSnow方法--重新建立包含1-7阶的分形雪花顶点的缓冲区&lt;/h3&gt;
&lt;p&gt;由于绘制方式统一用LineList，初始阶段应当提供3条线段的6个顶点，虽然说每个顶点都被重复使用了2次。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetSplitedSnow()
{
    // ******************
    // 雪花分形从初始化三角形开始，需要6个顶点
    // 设置三角形顶点
    float sqrt3 = sqrt(3.0f);
    VertexPosColor vertices[] =
    {
        { XMFLOAT3(-3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, sqrt3 / 2, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, sqrt3 / 2, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(-3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) }
    };
    // 将三角形宽度和高度都放大3倍
    for (int i = 0; i &amp;lt; ARRAYSIZE(vertices); ++i)
    {
        vertices[i].pos.x *= 3;
        vertices[i].pos.y *= 3;
    }

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_STREAM_OUTPUT;    // 需要额外添加流输出标签
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffers[0].ReleaseAndGetAddressOf()));

    // 顶点数
    mVertexCounts[0] = 6;
    // 初始化所有顶点缓冲区
    for (int i = 1; i &amp;lt; ARRAYSIZE(mVertexBuffers); ++i)
    {
        vbd.ByteWidth *= 4;
        mVertexCounts[i] = mVertexCounts[i - 1] * 4;
        HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mVertexBuffers[i].ReleaseAndGetAddressOf()));
        mBasicFX.SetStreamOutputSplitedSnow(mVertexBuffers[i - 1], mVertexBuffers[i]);
        md3dImmediateContext-&amp;gt;Draw(mVertexCounts[i - 1], 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetsplitedsphere方法--重新建立包含1-7阶的分形圆球顶点的缓冲区&quot;&gt;GameApp::ResetSplitedSphere方法--重新建立包含1-7阶的分形圆球顶点的缓冲区&lt;/h3&gt;
&lt;p&gt;这里不使用&lt;code&gt;Geometry&lt;/code&gt;类来构造一阶圆球，这里仅提供与外接正方体相交的六个顶点，包含八个三角形对应的24个顶点。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetSplitedSphere()
{
    VertexPosNormalColor basePoint[] = {
        { XMFLOAT3(0.0f, 2.0f, 0.0f), XMFLOAT3(0.0f, 1.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(2.0f, 0.0f, 0.0f), XMFLOAT3(1.0f, 0.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, 0.0f, 2.0f), XMFLOAT3(0.0f, 0.0f, 1.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(-2.0f, 0.0f, 0.0f), XMFLOAT3(-1.0f, 0.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, 0.0f, -2.0f), XMFLOAT3(0.0f, 0.0f, -1.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, -2.0f, 0.0f), XMFLOAT3(0.0f, -1.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
    };
    int indices[] = {0, 2, 1, 0, 3, 2, 0, 4, 3, 0, 1, 4, 1, 2, 5, 2, 3, 5, 3, 4, 5, 4, 1, 5};

    std::vector&amp;lt;VertexPosNormalColor&amp;gt; vertices;
    for (int pos : indices)
    {
        vertices.push_back(basePoint[pos]);
    }

    

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = vertices.size() * sizeof(VertexPosNormalColor);
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_STREAM_OUTPUT;    // 需要额外添加流输出标签
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices.data();
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffers[0].ReleaseAndGetAddressOf()));

    // 顶点数
    mVertexCounts[0] = ARRAYSIZE(indices);
    // 初始化所有顶点缓冲区
    for (int i = 1; i &amp;lt; ARRAYSIZE(mVertexBuffers); ++i)
    {
        vbd.ByteWidth *= 4;
        mVertexCounts[i] = mVertexCounts[i - 1] * 4;
        HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mVertexBuffers[i].ReleaseAndGetAddressOf()));
        mBasicFX.SetStreamOutputSplitedSphere(mVertexBuffers[i - 1], mVertexBuffers[i]);
        md3dImmediateContext-&amp;gt;Draw(mVertexCounts[i - 1], 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于篇幅过大，该类的其它方法就在此省略，具体细节可以查阅该章对应源码。来看一下动图感受一些这些酷炫的效果吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811215603121-922316780.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811215946924-615521366.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于文件大小限制，这里分成两个部分：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811220300589-2129952589.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是带法向量的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811220857933-1803464726.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于我现在找不到ID3D11DeviceContext::DrawAuto方法无法输出的原因，故在这里使用的依然是原来的Draw方法进行绘制。若有人能够在不使用FX11框架的情况下能够调用DrawAuto方法绘制到流输出，可以在下面评论我，并告诉我解决方案。&lt;/p&gt;
&lt;p&gt;除此之外，该项目使用图形调试器并退出的时候，会引发内存泄漏，而具体的泄漏对象估计是&lt;code&gt;ID3D11Query&lt;/code&gt;，然而我也没有办法直接拿到该接口对象来释放。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 14:32:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 在上一章，我们知道了如何使用几何着色器来重新组装图元，比如从一个三角形分裂成三个三角形。但是为了实现更高阶的分形，我们必须要从几何着色器拿到输出的顶点。这里我们可以使用可选的流输出阶段来拿到顶点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9461074.html</dc:identifier>
</item>
<item>
<title>用华为eNSP模拟器配置Hybrid、Trunk和Access三种链路类型端口 - 陈林实验室</title>
<link>http://www.cnblogs.com/chenlinlab/p/9461361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenlinlab/p/9461361.html</guid>
<description>&lt;p&gt;　　上一篇文章写到三层交换机实现多个VLAN之间互相通讯，有朋友提问要如何进行配置，可有案例分析。其实那天我在写的时候也有做过模拟，只是后来没有保存。今天重新模拟一次，并附上详细配置命令，希望能够帮助到大家。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先回忆下VLAN间数据传输的三种端口模式各自代表的含义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Access 类型的端口只能属于1个VLAN，一般用于连接计算机的端口,也可以连接交换机和交换机。&lt;/p&gt;
&lt;p&gt;　　Trunk 类型的端口可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，trunk口一般用于连接两台交换机，这样可以只用一条trunk连接实现多个vlan的扩展。对于trunk口发送出去的报文，只有默认vlan的报文不带vlan ID，其它vlan的报文都要带vlan ID（要不然，对端的交换机不知道该报文属于哪个vlan，无法处理，也就不能实现vlan跨交换机扩展了）。简而言之，trunk端口的设计目的就是通过一条连接实现多个vlan的跨交换机扩展。&lt;/p&gt;
&lt;p&gt;　　Hybrid 类型的端口可以实现比trunk端口更多的功能，trunk端口是hybrid端口的真子集。可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，可以用于交换机之间连接，也可以用于连接用户的计算机。hybrid端口可以加入多个vlan，并可以设置该vlan的报文通过该端口发送是否带vlan ID（trunk端口不能设置，只有默认vlan的报文不带vlan ID进行发送）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下配合每个端口模式在eNSP模拟器上模拟的实验：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Trunk+Access链路端口混合模式案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221457971-128592710.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于Access链路类型端口是单一VLAN，而且连接计算机的，所以跟Trunk链路类型端口合并成一个案例，节约大家学习时间。&lt;/p&gt;
&lt;p&gt;通过配置使都在vlan2的PC1和PC2互通，同vlan3的PC3和PC4互通。&lt;/p&gt;
&lt;p&gt;SwitchA配置命令：&lt;/p&gt;
&lt;p&gt;&amp;lt;Huawei&amp;gt;system-view&lt;br/&gt;[Huawei]sysname SwitchA&lt;br/&gt;[SwitchA]vlan batch 2 3 //批量创建VLAN，也可以分两次创建VLAN 2 VLAN 3&lt;br/&gt;[SwitchA]int vlanif 2&lt;br/&gt;[SwitchA-Vlanif2]ip address 192.168.100.1 255.255.255.0&lt;br/&gt;[SwitchA-Vlanif2]quit&lt;br/&gt;[SwitchA]int vlanif 3&lt;br/&gt;[SwitchA-Vlanif3]ip address 192.168.200.1 255.255.255.0&lt;br/&gt;[SwitchA-Vlanif3]quit&lt;br/&gt;[SwitchA] int G0/0/1&lt;br/&gt;[SwitchA-GigabitEthernet0/0/1]port link-type access //与连接PC1的端口链路类型设置为access&lt;br/&gt;[SwitchA-GigabitEthernet0/0/1]port default vlan 2 //将端口G0/0/1加入vlan 2&lt;br/&gt;[SwitchA-GigabitEthernet0/0/1]int G0/0/2 // 可以直接跳入G0/0/2 ，新手可以先quit到系统视图&lt;br/&gt;[SwitchA-GigabitEthernet0/0/2] port link-type access //与连接PC2端口链路类型设置为access&lt;br/&gt;[SwitchA-GigabitEthernet0/0/2] port default vlan 3 //将端口GE1/0/2加入vlan3&lt;br/&gt;[SwitchA] int G0/0/3&lt;br/&gt;[SwitchA-GigabitEthernet0/0/3] port link-type trunk //因为有vlan2 vlan3两个vlan，将交换机互联的端口链路类型设置为trunk&lt;br/&gt;[SwitchA-GigabitEthernet1/0/3] port trunk allow-pass vlan 2 3 //将端口G0/0/3加入vlan2和vlan 3&lt;br/&gt;SwitchB和SwitchA的配置差不多，大家参考SwitchA的配置文件。&lt;/p&gt;
&lt;p&gt;将PC1和PC2配置在一个网段，比如192.168.100.2/24和192.168.100.3/24，网关皆为192.168.100.1；&lt;br/&gt;将PC3和PC4配置在一个网段，比如192.168.200.2/24和192.168.200.3/24，网关皆为192.168.200.1；&lt;br/&gt;测试结果：PC1可以与PC2ping通，PC3可以与PC4ping通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221631406-940024354.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PC1 ping通 PC2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221720744-1697938150.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PC3 ping通 PC4&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Hybrid链路类型端口案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上篇文章有朋友提到Hybrid链路类型端口模式功能非常强大而且相当复杂，今天下午复习了下，确实在很多方面变现出它的先进性。&lt;/p&gt;
&lt;p&gt;使用Hybrid链路类型配置让PC3与PC1、PC2互通，PC1与PC2之间不通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221918094-1223402896.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LSW1配置命令：&lt;/p&gt;
&lt;p&gt;&amp;lt;Huawei&amp;gt;system-view&lt;br/&gt;[Huawei]sysname LSW1&lt;br/&gt;[LSW1]vlan batch 2 3 99&lt;br/&gt;[LSW1]int g0/0/1&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]undo port hybrid vlan 1&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]port hybrid tagged vlan 99&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]port hybird untagged vlan 2 3&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]int g0/0/2&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]undo port hybrid vlan 1&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]port hybrid pvid vlan 2&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]port hybird untagged vlan 2 99&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]int g0/0/3&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]undo port hybrid vlan 1&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]port hybrid pvid vlan 3&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]port hybird untagged vlan 3 99&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]quit&lt;br/&gt;SwitchB和SwitchA的配置差不多，大家参考SwitchA的配置，再次不再累赘。&lt;/p&gt;
&lt;p&gt;PC1、PC2和PC3的IP地址分别顺序设置为192.168.1.1/24、192.168.1.2/24、192.168.1.3/24，网关不填。&lt;br/&gt;测试结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221848069-631050419.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里有必要对Hybrid原理解释一下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、pvid这个属性只针对进入该端口的！没有标签的！普通的！数据包有效，作用是将没有标签的普通数据包打上pvid中配置的标签号；&lt;/p&gt;
&lt;p&gt;　　2、hybrid属性中，tag是针对于端口的接收方向的（从该端口进来的流量允许带有这些vlan标签的通过），untag是针对端口的发送方向的（从该端口出去的流量去除这些vlan标签）；&lt;/p&gt;
&lt;p&gt;Hybird实例配置分析（非常有必要解释）：&lt;/p&gt;
&lt;p&gt;　　1、为了让我们更加简洁的理解hydrid的属性，首先在所有的端口上移除了vlan1这个默认有的vlan，假设为所有端口初始不属于任何vlan，都不能相互之间通信；&lt;/p&gt;
&lt;p&gt;　　2、pvid是当普通的主机数据帧进入交换机端口后被打上的vlan-tag的属性，在途中可以看出PC1、PC2、PC3的流量在进入交换机的时候分别会被打上vlan2、vlan3、vlan99的vlan标签；&lt;/p&gt;
&lt;p&gt;　　3、untag后面的vlan就是该端口属于的vlan，那么不难看出LSW1的G0/0/1属于vlan2、3，G0/0/2属于vlan2、99，G0/0/3属于vlan3、99，而untag的动作是在流量出端口去往主机的时候把vlan-tag全部去除，那么不难看出LSW1的G0/0/1将去除vlan2、3的标签，G0/0/2去除vlan2、1099的标签，G0/0/3去除vlan3、99的标签（还原成普通帧）。&lt;/p&gt;
&lt;p&gt;LSW2的G0/0/1属于vlan99，G0/0/2属于vlan99，在流量出端口的时候会去除vlan99的标签（还原成普通帧）。&lt;/p&gt;
&lt;p&gt;　　PC1与PC2之间的通信分析：当PC1发送arp去请求PC2的MAC地址的时候，PC1会将数据包广播发往LSW1的G0/0/2接口，LSW1收到后发现是个普通的不带标签的数据帧，于是根据接口的pvid给该帧打上vlan2的tag，然后往vlan2中进行泛洪，无奈G0/0/3端口只属于vlan3、99所以无法收到vlan2中的泛洪，故PC1与PC2通信失败。&lt;/p&gt;
&lt;p&gt;　　PC1与PC3之间的通信分析：PC1把帧给LSW1后在G0/0/2打上pvid vlan2的tag，从G0/0/1转发出去，同时untag掉这个帧vlan2的标签，LSW2从G0/0/1收到普通的帧后打上vlan99的tag后从G0/0/2转发给PC3（去掉vlan99的tag后转发给PC3），PC3回包给PC1过程：PC3把帧丢给LSW2的G0/0/2后被pvid打上vlan99的tag后，LSW2根据mac表和vlan信息将帧从G0/0/1口转发出去，！这里因为并没有untag属性所以转发的帧并不会去除任何vlan，而是以vlan99的帧从G0/0/1转发出去！（G0/0/1配置的tag vlan 99是为了让这个端口能转发vlan99的数据帧）当LSW1拿到LSW2发来的带有vlan99的tag的数据帧后，根据G0/0/1上配置的tag vlan99属性，放行vlan99的数据帧，然后根据mac表和vlan信息把帧丢给G0/0/2，由G0/0/2端口将vlan99的tag去除后转发给PC1，完成了PC1与PC3的整个通信过程。&lt;/p&gt;
&lt;p&gt;PC2与PC3的通信过程同理PC1与PC3。&lt;/p&gt;
&lt;p&gt;　　Hybrid确实有点复杂，不过它的功能非常强大，集合了Access和Trunk的优点，还能适合基于汇聚层设备做网关、MAC地址划分、IP子网划分地的配置。欢迎在下方留言提问，看下哪里不大了解的？&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 14:22:00 +0000</pubDate>
<dc:creator>陈林实验室</dc:creator>
<og:description>上一篇文章写到三层交换机实现多个VLAN之间互相通讯，有朋友提问要如何进行配置，可有案例分析。其实那天我在写的时候也有做过模拟，只是后来没有保存。今天重新模拟一次，并附上详细配置命令，希望能够帮助到大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenlinlab/p/9461361.html</dc:identifier>
</item>
<item>
<title>自定义Android控件，封装Arcgis for Android测距测面积工具控件 - 山顶洞洞人</title>
<link>http://www.cnblogs.com/sddman/p/9461279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sddman/p/9461279.html</guid>
<description>&lt;p&gt;控件的功能包括，测距、测面积、撤销、恢复、清除、完成六个功能。&lt;/p&gt;
&lt;p&gt;测距：在地图上绘制线段进行长度测量&lt;/p&gt;
&lt;p&gt;测面积：在地图上绘制一个面，进行面积测量&lt;/p&gt;
&lt;p&gt;撤销：撤销到上一步绘制，只能撤销未完成的测量&lt;/p&gt;
&lt;p&gt;恢复：恢复到下一步绘制，只能恢复未完成的测量&lt;/p&gt;
&lt;p&gt;清除：清空测量内容并结束测量，再次点击地图时不会进行测量&lt;/p&gt;
&lt;p&gt;完成：结束本次测量，本次测量将不能撤销和恢复，再次点击地图时将进行下一次长度测量或者面积测量&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/roomanl/ArcgisTool&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987191989a9375cb6d1&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153398739075078c64264b1&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;最简单的基本用法：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987461621ad4577804b&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;注意：请不要在measureToolView.init(mMapView)之后给mMapView设置点击监听事件，不然会覆盖掉MeasureToolView的地图点击事件，如需要在地图点击之后做一些自己的操作，请看下面的高级用法。&lt;/p&gt;
&lt;p&gt;以上代码将会显示默认的控件样式，下图是默认样式&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/1533987503756e8529003e7&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;MeasureToolView支持样式设置，可以设置成自己需要的样式，下图是自定义样式&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/15339875259938afde1867b&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;在界面设置属性&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987557174c5e2db031e&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;java代码设置属性&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987581169d425883642&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;设置地图点击回调&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/15339876143270490bf7af6&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置测量工具按钮点击回调&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533987642433e1184bd4ee&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;地图点击和测量按钮点击回调同时设置&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153398767344776658fe3af&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置坐标参考系&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153398770618429a6c6eeab&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置测量长度单位&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533988400026b856441bfa&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置测量面积单位&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533987729115355dde91d9&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;ArcGisZoomView控件均由调用ArcGisMeasure开放接口实现&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533987830169a4df4e37ff&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 11 Aug 2018 14:01:00 +0000</pubDate>
<dc:creator>山顶洞洞人</dc:creator>
<og:description>控件的功能包括，测距、测面积、撤销、恢复、清除、完成六个功能。 测距：在地图上绘制线段进行长度测量 测面积：在地图上绘制一个面，进行面积测量 撤销：撤销到上一步绘制，只能撤销未完成的测量 恢复：恢复到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sddman/p/9461279.html</dc:identifier>
</item>
<item>
<title>分享我在 vue 项目中关于 api 请求的一些实现及项目框架 - 易墨</title>
<link>http://www.cnblogs.com/morang/p/9461186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morang/p/9461186.html</guid>
<description>&lt;p&gt;本文主要简单分享以下四点&lt;/p&gt;
&lt;p&gt;本文主要目的为以下三点&lt;/p&gt;
&lt;p&gt;我只是把我觉得有用的东西分享出来罢了&lt;/p&gt;
&lt;h2 id=&quot;使用-axios-请求接口&quot;&gt;使用 axios 请求接口&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装-axios&quot;&gt;安装 axios&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;npm install axios --save&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建-axios-实例-apifetch.js&quot;&gt;创建 axios 实例 (api/fetch.js)&lt;/h3&gt;
&lt;p&gt;axios 默认提交格式为：&lt;code&gt;application/json&lt;/code&gt;&lt;br/&gt;可使用 qs 模块(需要安装)转换后提交格式为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;br/&gt;通过设置 transformRequest 属性 &lt;code&gt;data =&amp;gt; qs.stringify(data)&lt;/code&gt; 可以正常表单形式提交&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import axios from 'axios'

const instance = axios.create({
  baseURL: 'apiBaseUrl', // api的base_url
  timeout: 10000 // 请求超时时间
  // transformRequest: data =&amp;gt; qs.stringify(data) //
})
// request拦截器
instance.interceptors.request.use(
  e =&amp;gt; {
    e.params = e.params || {}
    e.headers = e.headers || {}
    //set 默认值
    return e
  },
  error =&amp;gt; ({ status: 0, msg: error.message })
)
// respone拦截器
instance.interceptors.response.use(
  response =&amp;gt; {
    const resp = response.data
    if (response.status === 200) {
      return resp
    }
    return resp
  },
  error =&amp;gt; {
    console.log('err' + error) // for debug
    return Promise.reject(error)
  }
)
export default instance&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用封装的fetch.js&quot;&gt;使用封装的fetch.js&lt;/h3&gt;
&lt;p&gt;在 api 文件中新建接口模块并使用 axios 实例(api/fetch.js)&lt;br/&gt;src/api/api_test.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import request from '@/utils/fetch'

export function test(data) {
  return request({
    url: '/test',
    method: 'post',
    data: data
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用的时候，可通过引入 api/模块.js 调用方法，也可以通过安装插件的形式将 api 接口扩展到 vue 实例中，使其可以更方便的在项目中使用&lt;/p&gt;
&lt;h3 id=&quot;以-test-模块为例创建一个api-扩展&quot;&gt;以 test 模块为例创建一个$api 扩展&lt;/h3&gt;
&lt;p&gt;src/api/index.js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import * as api_test from './test'

const apiObj = {
  api_test
}

const install = function(Vue) {
  if (install.installed) return
  install.installed = true
  Object.defineProperties(Vue.prototype, {
    $api: {
      get() {
        return apiObj
      }
    }
  })
}
export default {
  install
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 main.js 安装 $api 扩展:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import api from './api'
Vue.use(api)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目中调用：&lt;code&gt;this.$api.api_test.test().then(resp=&amp;gt;{...}).catch(()=&amp;gt;{...})&lt;/code&gt;&lt;br/&gt;在后端项目中我二次封装了下拉框，通过参数接收Function，传递&lt;code&gt;$api.api_test.test&lt;/code&gt;省了可以少写很多代码。&lt;/p&gt;
&lt;h2 id=&quot;关于开发环境和生成环境的配置读取&quot;&gt;关于开发环境和生成环境的配置读取&lt;/h2&gt;
&lt;p&gt;看到很多中做法，分享下我在项目中使怎么做的。&lt;/p&gt;
&lt;p&gt;目前项目中的做法是在config文件夹中根据环境新建不同的配置，然后通过index.js暴露对应环境的配置。&lt;/p&gt;
&lt;h3 id=&quot;目录结构及index.js&quot;&gt;目录结构及index.js&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   config
        - _development.js
        - _production.js
        - _testing.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;config/index.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = require('./_' + process.env.NODE_ENV).default&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际项目中的目录结构如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/11/16528e5477f19fd7?w=864&amp;amp;h=422&amp;amp;f=png&amp;amp;s=77682&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于在项目中使用-mock&quot;&gt;关于在项目中使用 mock&lt;/h2&gt;
&lt;p&gt;看到好多项目把mock混在项目中使用，就感觉很难受，所以想办法独立出来了，功能不强大，只是足够用在一些小Demo上，简单模拟一下数据就可以让我们的Demo不用担心api接口失效导致vue项目跑不起来的问题。&lt;/p&gt;
&lt;p&gt;下面是我的解决方案&lt;/p&gt;
&lt;h3 id=&quot;express-mockjs-的使用&quot;&gt;express-mockjs 的使用&lt;/h3&gt;
&lt;blockquote readability=&quot;5.4615384615385&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/52cik/express-mockjs&quot;&gt;express-mockjs&lt;/a&gt; 是大佬结合 &lt;code&gt;express+mock-lite&lt;/code&gt; 构建的一个 api 服务中间件，用它可以快速的帮助我们在本地搭建一个 mock 服务器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关资料：&lt;/p&gt;
&lt;p&gt;安装 express-mockjs: &lt;code&gt;npm install express-mockjs --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装 nodemon 到项目 以监听 mock 代码修改&lt;/p&gt;
&lt;p&gt;安装 nodemon: &lt;code&gt;npm install nodemon --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建-mock-serverindex.js-编写启动服务器代码&quot;&gt;新建 mock-server/index.js 编写启动服务器代码&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var path = require('path')
var express = require('express')
var mockjs = require('express-mockjs')

var app = express()

// 自定义路径 前缀： '/api'
var config = {
  port: 3000
}
//以/api为前缀，寻找api目录下的所有接口
app.use('/api', mockjs(path.join(__dirname, 'api')))

// 获取port参数 可通过 --port自 定义启动端口
var args = process.argv
for (let i = 0; i &amp;lt; args.length; i++) {
  if (args[i] === '--port' &amp;amp;&amp;amp; i &amp;lt; args.length - 1 &amp;amp;&amp;amp; args[i + 1] &amp;gt; 0) {
    config.port = args[i + 1]
    break
  }
}

console.log('mock-server[mockjs-lite]:http://localhost:' + config.port)
// console.log('mockjs-lite定义：http://mockjs-lite.js.org/docs/examples.html')
app.listen(config.port)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写接口文件&quot;&gt;编写接口文件&lt;/h3&gt;
&lt;p&gt;在 mock-server 文件夹创建 api 文件夹，并按照 &lt;a href=&quot;https://github.com/52cik/express-mockjs&quot;&gt;expess-mockjs 的文档&lt;/a&gt;编写 json/js&lt;br/&gt;json&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;/**
 * Interface function description
 *
 * @url /api-access-path
 */

{
  &quot;code&quot;: 0,
  &quot;result|5&quot;: [
    {
      &quot;uid|+1&quot;: 1,
      &quot;name&quot;: &quot;@name&quot;,
      &quot;email&quot;: &quot;@email&quot;
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * home page links
 *
 * @url /home-links
 *
 * Here you can write a detailed description
 * of the parameters of the information.
 */

module.exports = {
  code: function() {
    // simulation error code, 1/10 probability of error code 1.
    return Math.random() &amp;lt; 0.1 ? 1 : 0
  },
  'list|5-10': [{ title: '@title', link: '@url' }]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行-mock-服务器&quot;&gt;运行 mock 服务器&lt;/h3&gt;
&lt;p&gt;在项目的 package.json 中添加 mock 命令并运行：&lt;code&gt;npm run mock&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;scripts&quot;: {
    //...
    &quot;mock&quot;: &quot;nodemon --watch mock-server node mock-server/index.js --port 6543&quot;
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/11/16528f329ece39c9?w=978&amp;amp;h=389&amp;amp;f=png&amp;amp;s=65786&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开发环境根据上面的配置运行起来没问题了，但是如果自己的小Demo发布后要怎么才能使用呢？我的方法是将js文件生成json然后打包到dist目录&lt;br/&gt;如果有兴趣可以参考&lt;a href=&quot;https://github.com/yimogit/me-admin-template/blob/master/mock-server/build.js&quot;&gt;mock-server/build.js&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分享自己的项目框架&quot;&gt;分享自己的项目框架&lt;/h2&gt;
&lt;p&gt;奉上一个以上实现都有的模板框架(UI使用Element-UI,为了好看),仓库中docs中有一些独立的一些说明有兴趣可以查看。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/yimogit/me-admin-template&quot; class=&quot;uri&quot;&gt;https://github.com/yimogit/me-admin-template&lt;/a&gt;&lt;br/&gt;预览地址：&lt;a href=&quot;https://vue-admin.yimo.link/&quot; class=&quot;uri&quot;&gt;https://vue-admin.yimo.link/&lt;/a&gt;&lt;br/&gt;效果图示：&lt;a href=&quot;https://user-gold-cdn.xitu.io/2018/8/11/165291278ea146d1&quot;&gt;整容前&lt;/a&gt; &lt;a href=&quot;https://user-gold-cdn.xitu.io/2018/8/11/1652912db78bd206&quot;&gt;整容后&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;感觉文章东西太多，什么都没讲清楚，不过，重要的是思路嘛，具体实现可以看框架代码~&lt;/p&gt;
&lt;p&gt;如果文中有错误，欢迎指出。&lt;br/&gt;如果有更好的实现方式，也希望有大佬指点一二。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 13:36:00 +0000</pubDate>
<dc:creator>易墨</dc:creator>
<og:description>本文主要简单分享以下四点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morang/p/9461186.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于Jenkins+Docker实现持续部署（Part 1） - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/CD_foundation_based_on_jenkins_and_docker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/CD_foundation_based_on_jenkins_and_docker.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt; &lt;/em&gt;此篇已加入&lt;a title=&quot;find more ?&quot; href=&quot;https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index.html&quot; target=&quot;_blank&quot;&gt;.NET Core微服务基础系列文章索引&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/46653/201612/46653-20161230152143648-2113509642.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成(Continuous integration，简称 CI) &lt;strong&gt;=&amp;gt;&lt;/strong&gt; 持续集成指的是，&lt;strong&gt;&lt;span&gt;频繁地(一天多次)将代码集成到主干&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　它的好处主要有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;快速发现错误&lt;/strong&gt;。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防止分支大幅偏离主干&lt;/strong&gt;。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　持续集成的目的，就是&lt;strong&gt;&lt;span&gt;让产品可以快速迭代，同时还能保持高质量&lt;/span&gt;&lt;/strong&gt;。与持续集成相关的，还有持续交付和持续部署。&lt;/p&gt;
&lt;p&gt;　　持续交付指的是：&lt;strong&gt;&lt;span&gt;频繁地将软件的新版本，交付给质量团队或者用户，以供评审&lt;/span&gt;&lt;/strong&gt;。如果评审通过，代码就进入生产阶段。它强调的是，&lt;span&gt;&lt;strong&gt;不管怎么更新，软件是随时随地可以交付的&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;CD&quot; src=&quot;https://images2015.cnblogs.com/blog/46653/201612/46653-20161230152159039-1261178652.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;444&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　持续部署是持续交付的下一步，指的是&lt;span&gt;&lt;strong&gt;代码通过评审以后，自动部署到生产环境&lt;/strong&gt;&lt;/span&gt;。它强调的是&lt;span&gt;&lt;strong&gt;代码在任何时刻都是可部署的，可以进入生产阶段&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;CD&quot; src=&quot;https://images2015.cnblogs.com/blog/46653/201612/46653-20161230152211445-454212849.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;444&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Martin Fowler 说：“持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180808233203683-1020834546.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Jenkins 是一款流行的开源持续集成（CI）与持续部署（CD）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。官方网站：&lt;a title=&quot;http://jenkins-ci.org/&quot; href=&quot;http://jenkins-ci.org/&quot; target=&quot;_blank&quot;&gt;http://jenkins-ci.org/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　使用Jenkins的目的在于：&lt;/p&gt;
&lt;p&gt;　　（1）持续、自动地构建/测试软件项目。 &lt;br/&gt;　　（2）监控软件开放流程，快速问题定位及处理，提升开发效率。&lt;/p&gt;
&lt;p&gt;　　这里废话不多说了，更多内容，可以参考这一篇文章《&lt;a href=&quot;http://www.360doc.com/content/17/0213/17/7811581_628728532.shtml&quot; target=&quot;_blank&quot;&gt;不甘寂寞的Jenkins：从持续集成到持续部署&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS:&lt;/strong&gt; 这里采用的是基于CentOS7.x的安装方式，非Docker安装。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;2.1 安装Java环境&lt;/h2&gt;
&lt;p&gt;　　这里参考晓晨Master的《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/9286878.html&quot; target=&quot;_blank&quot;&gt;CentOS7安装Java环境（JDK1.8）&lt;/a&gt;》，不再赘述安装步骤，最终验证效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180808235109410-570041600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;Tip：&lt;/strong&gt;&lt;/em&gt;里面需要注意的是为jdk创建软链接！&lt;/p&gt;
&lt;h2&gt;2.2 安装Git&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install git
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 安装Jenkins&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/&lt;span&gt;jenkins.repo

sudo rpm &lt;/span&gt;--import https://pkg.jenkins.io/redhat-stable/&lt;span&gt;jenkins.io.key

yum install jenkins　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装完成后提示信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811201712260-1771925479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　默认安装后的端口绑定的是8080，如果你想更改请进入文件编辑JENKINS_PORT属性项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/sysconfig/jenkins
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果你使用的是root用户（没有单独创建一个jenkins的用户），那么建议进入上面的配置文件编辑JENKINS_USER属性项将jenkins改为root。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811205843160-386941117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.4 配置Jenkins&lt;/h2&gt;
&lt;p&gt;　　（1）修改目录权限：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
chown -R root:root /var/lib/&lt;span&gt;jenkins
chown &lt;/span&gt;-R root:root /var/cache/&lt;span&gt;jenkins
chown &lt;/span&gt;-R root:root /var/log/jenkins
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;Tip：&lt;/strong&gt;&lt;/em&gt;在 Shell 中，可以使用chown命令来改变文件所有者。chown命令是change owner（改变拥有者）的缩写。-R代表进行递归( recursive )的持续更改，即连同子目录下的所有文件、目录都更新成为这个用户组，常常用在更改某一目录的情况。&lt;/p&gt;
&lt;p&gt;　　（2）重启Jenkins服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;service jenkins restart
ps &lt;/span&gt;-ef | grep jenkins
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示信息如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811203111546-1294008495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）启动Jenkins&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl start jenkins
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证启动状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl status jenkins
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811210151056-1582701958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.5 初始化Jenkins &lt;/h2&gt;
&lt;p&gt;　　（1）访问http://xxxx:8080/进行Jenkins的解锁&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811210025802-71037086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以通过下面的命令查看管理员密码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cat /var/lib/jenkins/secrets/initialAdminPassword
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811210534975-380920088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后把这个密码复制到Web界面中的文本框中去进入下一步&lt;/p&gt;
&lt;p&gt;　　（2）自定义Jenkins =&amp;gt; 这里选择&lt;strong&gt;安装推荐的插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811211001096-365052532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　双击之后进入安装过程，耐心等待：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811211129360-2078977399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）创建管理账户 =&amp;gt; 也可以直接使用admin账户继续&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811211451922-1844826971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）安装完成&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811211640373-171417062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（5）Jenkins主界面&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201808/381412-20180811211918275-1344126078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，Jenkins的基本安装与配置就到此结束，下一篇我们会结合ASP.NET Core与Docker来一个持续部署的实例。&lt;/p&gt;

&lt;p&gt;　　本篇简单介绍了一下持续集成、持续交付与持续部署的基本概念，然后介绍了如何在CentOS7.x下安装Jenkins并初始化Jenkins。下一篇会会结合ASP.NET Core、GitHub与Docker来一个持续部署的实例。&lt;/p&gt;

&lt;p&gt;佚名，《&lt;a href=&quot;http://network.51cto.com/art/201801/563064.htm&quot; target=&quot;_blank&quot;&gt;什么是持续集成？该怎么做？&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;宋潇男，《&lt;a href=&quot;http://www.360doc.com/content/17/0213/17/7811581_628728532.shtml&quot; target=&quot;_blank&quot;&gt;不甘寂寞的Jenkins：从持续集成到持续部署&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;晓晨Master，《&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8629165.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core &amp;amp; Docker &amp;amp; Jenkins零基础持续集成&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;dev_zh，《&lt;a href=&quot;https://my.oschina.net/closeday/blog/1612910&quot; target=&quot;_blank&quot;&gt;安装Jenkins遇到的坑&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 11 Aug 2018 13:24:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>Tip: 此篇已加入.NET Core微服务基础系列文章索引 一、CI, CD 与Jenkins 互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成(Continu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/CD_foundation_based_on_jenkins_and_docker.html</dc:identifier>
</item>
<item>
<title>SSE图像算法优化系列二十：一种快速简单而又有效的低照度图像恢复算法。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/9460334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/9460334.html</guid>
<description>&lt;p&gt;&lt;span&gt;　又有很久没有动笔了，主要是最近没研究什么东西，而且现在主流的趋势都是研究深度学习去了，但自己没这方面的需求，同时也就很少有动力再去看传统算法，今天一个人在加，还是抽空分享一个简单的算法吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前段日子在看水下图像处理方面的资料时，在github搜到一个链接，里面居然有好几篇文章附带的代码，除了水下图像的文章外，我看到了一篇《Adaptive Local Tone Mapping Based on Retinex for High Dynamic Range Images  》的文章，也还不算老，2013年的，随便看了下，内容比较简单，并且作者还分享了Matlab和Java的相关代码，因此，我也尝试这用C和SIMD做了优化，感觉对于低照度的图像处理起来效果还是很不错，因此，记录下优化和开发过程的一些收获。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述github链接为：&lt;a href=&quot;%20https://github.com/IsaacChanghau/OptimizedImageEnhance&quot; target=&quot;_blank&quot;&gt; https://github.com/IsaacChanghau/OptimizedImageEnhance&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　论文提出的主要内容时这对高动态图像的显示问题，他结合传统的Retinex技术提出了全局自适应和局部自适应的HDR实现过程，我也实现了整个的代码，但感觉前面的全局适应方案特别对于低照度图像有着非常明显的调节作用，因此，我重点谈下整个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接应用原文的英文算了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　Global adaptation takes place like an early stage of the human visual system [4]. The human visual system senses rightness as an approximate logarithmic function according o the Weber-Fechner law [5]. To globally compress the ynamic range of a HDR scene, we use the following function n (4) presented in [5].&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170000969-2043921968.png&quot; alt=&quot;&quot; width=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用中文解释下上面的公式，也是本文最重要的一个公式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170207486-1526338434.png&quot; alt=&quot;&quot; width=&quot;65&quot;/&gt; 是全自适应输出的结果，我们这里就是需要得到他，&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170342456-1317607709.png&quot; alt=&quot;&quot; width=&quot;50&quot;/&gt;表示输入图像的luminance值（亮度值），&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170510875-976517664.png&quot; alt=&quot;&quot; width=&quot;40&quot;/&gt;表示输入图像亮度值对的最大值，&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170549714-772607564.png&quot; alt=&quot;&quot; width=&quot;20&quot;/&gt;表示输入亮度对数的平均值，如下式所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170755081-144607661.png&quot; alt=&quot;&quot; width=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　其中N表示像素的总数，而δ一般是个很小的值，其作用主要是为了避免对纯黑色像素进行log计算时数值溢出，这个问题在图像处理时非常常见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在log域进行计算，这个HDR算法中基本是个定律了。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接应用原文的话，上述算式的主要作用是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      The input world luminance values and the maximum luminance values are divided by the log-average luminance of he scene. This enables (4) to adapt to each scene. As the log-&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;verage luminance converges to the high value, the function c&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;onverges from the shape of the logarithm function to the &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;near function. Thus, scenes of the low log-average luminance &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;reboosted more than scenes with high values. As a result, the o&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;verall scene luminance values are adequately compressed in &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;ccordance with the log-average luminance of the scene.&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　特别注意的是 scenes of the low log-average luminance reboosted more than scenes with high values. 这句话，他的意思是说低照度的亮度部分比高照度的部分要能得到更大程度的提升，所以对于低照度图，上述公式能起到很好的增强作用。而算式中使用了全局的对数平均值，这就有了一定的自适应性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我贴一段稍微修改了的作者共享的matlab代码作为本算法的参考代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:matlab;gutter:true;&quot;&gt;
function outval = ALTM_Retinex(I)
II = im2double(I);
Ir=double(II(:,:,1)); Ig=double(II(:,:,2)); Ib=double(II(:,:,3));
% Global Adaptation
Lw = 0.299 * Ir + 0.587 * Ig + 0.114 * Ib;% input world luminance values
Lwmax = max(max(Lw));% the maximum luminance value
[m, n] = size(Lw);
Lwaver = exp(sum(sum(log(0.001 + Lw))) / (m * n));% log-average luminance
Lg = log(Lw / Lwaver + 1) / log(Lwmax / Lwaver + 1);
gain = Lg ./ Lw;
gain(find(Lw == 0)) = 0;
outval = cat(3, gain .* Ir, gain .* Ig, gain .* Ib);
figure;
imshow(outval)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　很简单的代码，贴一个这个代码的结果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811172158819-556019258.jpg&quot; alt=&quot;&quot;/&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811172208990-198798833.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 网上K的一个经常用来测试的美女，也不知道是那位性福男士的女朋友，作图非常的暗淡无光泽，处理后的图像饱和度和亮度都有较大的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 M代码通常只是用来学习用的，并不具有工程价值，M代码也基本不考虑速度和内存占用，因此一般都要根据M代码自行修改为C或者C++代码才有可能实用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　我贴出部分我写的C代码来分析下提速的办法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int IM_ALTM_Retinex(unsigned char *Src, unsigned char *Dest, int Width, int Height, int Stride)
{
        float Avg = 0;
        unsigned char *OldY = (unsigned char *)malloc(Height * Width * sizeof(unsigned char));
        unsigned char *NewY = (unsigned char *)malloc(Height * Width * sizeof(unsigned char));
        float *LogG = (float *)malloc(Height * Width * sizeof(float));
        float *Table = (float *)malloc(256 * sizeof(float));
        IM_GetLuminance(Src, OldY, Width, Height, Stride);                                              //      input world luminance values

        //       *************************************************   Global Adaptation     ******************************************
        int MaxL = IM_GetMaxValue(Src, Width, Height, Width);                                   //      the maximum luminance value

        for (int Y = 0; Y &amp;lt; 256; Y++)                                Table[Y] = log(0.000001F + Y * IM_INV255);
        for (int Y = 0; Y &amp;lt; Height * Width; Y++)     Avg += Table[OldY[Y]];          //      sum of log luminance value

        Avg = exp(Avg / (Height * Width));                                                                              //      log - average luminance

        for (int Y = 0; Y &amp;lt; 256; Y++)                                Table[Y] = log(Y* IM_INV255 / Avg + 1) / log(MaxL * IM_INV255 / Avg + 1);
        for (int Y = 0; Y &amp;lt; Height * Width; Y++)     LogG[Y] = Table[OldY[Y]];       //      globally compress the dynamic range of a HDR scene we use the following function in(4) presented in[5].

        IM_Normalize(LogG, NewY, Width, Height);                                                                //      after normalization, an output image is obtained from the processed luminance values and the input chrominance values

        IM_ModifyYComponent(Src, NewY, Dest, Width, Height, Stride);

        if (OldY != NULL)               free(OldY);
        if (LogG != NULL)               free(LogG);
        if (NewY != NULL)               free(NewY);

        return 0;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　第一步，得到input world luminance，使用IM_GetLuminance函数，具体的实现细节可以参考&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Imageshop/p/8405517.html&quot;&gt;SSE图像算法优化系列十五：YUV/XYZ和RGB空间相互转化的极速实现(此后老板不用再担心算法转到其他空间通道的耗时了)&lt;/a&gt;一文自行实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二步：得到&lt;span&gt;the maximum luminance value，使用&lt;/span&gt;IM_GetMaxValue函数，我分享下这个函数的SSE实现代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
//  求16个字节数据的最大值, 只能针对字节数据。
inline int _mm_hmax_epu8(__m128i a)
{
        __m128i b = _mm_subs_epu8(_mm_set1_epi8(255), a);
        __m128i L = _mm_unpacklo_epi8(b, _mm_setzero_si128());
        __m128i H = _mm_unpackhi_epi8(b, _mm_setzero_si128());
        return 255 - _mm_extract_epi16(_mm_min_epu16(_mm_minpos_epu16(L), _mm_minpos_epu16(H)), 0);
}

int IM_GetMaxValue(unsigned char *Src, int Length)
{
        int BlockSize = 16, Block = Length / BlockSize;
        __m128i MaxValue = _mm_setzero_si128();
        for (int Y = 0; Y &amp;lt; Block * BlockSize; Y += BlockSize)
        {
                MaxValue = _mm_max_epu8(MaxValue, _mm_loadu_si128((__m128i *)(Src + Y)));
        }
        int Max = _mm_hmax_epu8(MaxValue);
        for (int Y = Block * BlockSize; Y &amp;lt; Length; Y++)
        {
                if (Max &amp;lt; Src[Y])    Max = Src[Y];
        }
        return Max;
}

int IM_GetMaxValue(unsigned char *Src, int Width, int Height, int Stride)
{
        int Max = 0;
        for (int Y = 0; Y &amp;lt; Height; Y++)
        {
                Max = IM_Max(Max, IM_GetMaxValue(Src + Y * Stride, Width));
                if (Max == 255) break;
        }
        return Max;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　用到了函数的多态特性，其中求最大值的思路在 &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl28_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Imageshop/p/3410279.html&quot;&gt;一种可实时处理 O(1)复杂度图像去雾算法的实现&lt;/a&gt;一文中有较为详细的说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 单行像素里求取最大值，可以充分利用_mm_max_epu8这条SIMD指令，一次性进行16次比较，速度大为提高，而最后从SIMD寄存器里求出16个字节数据的最大值则充分利用了_mm_minpos_epu16这个SIMD指令，令人感到困惑的是为什么系统只提供_mm_minpos_epu16指令，而没有_mm_minpos_epu8或者_mm_minpos_epu32这样的，16有什么特殊的场合用的最广呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　求对数值这对于8位图像，最快速的方式也只有查表，并且查表可以明确的说是没有好的SIMD加速方法，除非是16个字节的小表（返回值也是字节的），可以利用_mm_shuffle_epi8加速外，其他的都不弄，而这个的应用场合极为少见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查完表后计算出对数的平均值Avg，最后按照公式（4）得到全局的自适应输出值&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170207486-1526338434.png&quot; alt=&quot;&quot; width=&quot;65&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811170207486-1526338434.png&quot; alt=&quot;&quot; width=&quot;65&quot;/&gt;是浮点数，我们需要将其转换为图像数据，这里有个额外的选项，一种是在转换前对浮点数还是做点处理，很多M代码里都有这个过程，通常叫做SimplestColorBalance.m（我看到过很多次了），这个其实就有点类似于图像处理的自动色阶过程，把一定百分比的低亮度和高亮度值删除掉，然后中间的值进行拉升。之后的normalization就是正常的线性处理了，这个浮点处理过程也可以使用SIMD指令加速。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
//  将浮点数按照最大值和最小值线性的插值到0和255之间的像素值。
int IM_Normalize(float *Src, unsigned char*Dest, int Width, int Height)
{
        if ((Src == NULL) || (Dest == NULL))                                    return IM_STATUS_NULLREFRENCE;
        if ((Width &amp;lt;= 0) || (Height &amp;lt;= 0))                                                return IM_STATUS_INVALIDPARAMETER;
        
        float Min = 0, Max = 0;
        
        IM_GetMinMaxValue(Src, Width * Height, Min, Max);

        if (Max == Min)
        {
                memset(Dest, 128, Width * Height);
        }
        else
        {
                float Inv = 255.0f / (Max - Min);                                                       //      不建议用整数的乘以255，因为可能会溢出，反正最后的除法要调用浮点版本的，这里就用浮点乘不是更好吗
                int BlockSize = 8, Block = (Height * Width) / BlockSize;
                for (int X = 0; X &amp;lt; Block * BlockSize; X += BlockSize)               //      正规化
                {
                        __m128 SrcV1 = _mm_load_ps(Src + X);
                        __m128 SrcV2 = _mm_load_ps(Src + X + 4);
                        __m128 Diff1 = _mm_sub_ps(SrcV1, _mm_set1_ps(Min));
                        __m128 Diff2 = _mm_sub_ps(SrcV2, _mm_set1_ps(Min));
                        __m128i Value1 = _mm_cvtps_epi32(_mm_mul_ps(Diff1, _mm_set1_ps(Inv)));
                        __m128i Value2 = _mm_cvtps_epi32(_mm_mul_ps(Diff2, _mm_set1_ps(Inv)));
                        _mm_storel_epi64((__m128i *)(Dest + X), _mm_packus_epi16(_mm_packus_epi32(Value1, Value2), _mm_setzero_si128()));
                }
                for (int X = Block * BlockSize; X &amp;lt; Height * Width; X++)
                {
                        Dest[X] = (int)((Src[X] - Min) * Inv + 0.5f);
                }
        }
        return IM_STATUS_OK;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;就是简单的SIMD指令运用，没啥好说的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于之前处理得到值还是luminance值，如果是灰度图，处理到这里就可以结束了，但是如果是彩色RGB图，我们有很多方案来获得最终的RGB分量值，这里我提三种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　第一种，如上述C++代码所示，使用IM_ModifyYComponent这样的方式，细节上为把原图转换到YUV或者HSV这中带亮度的颜色空间中，然后用新得到的luminance值代替Y通道或V通道，然后在转换会RGB空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二种方法，如上述Matalb代码所示，用新的luminance值和原始luminance值的比值作为三通到的增强系数，这样三通道可以得到同样程度的增强。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三种方法就是在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Imageshop/p/9129162.html&quot;&gt;SSE图像算法优化系列十九：一种局部Gamma校正对比度增强算法及其SSE优化&lt;/a&gt;一文中提到的 &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811181213566-917700222.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;算式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一种方法容易出现结果图色彩偏淡，第二种每个分量易出现过饱和，第三种可能要稍微好一点，建议使用第三种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但总的来说差异可能都不会太大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　    贴一些改过程的图片看看效果，大家也可以自己用下面的图片做测试，看看结果如何。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811190749294-2092737179.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811190755694-2060479035.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811190001049-1133854249.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811190021746-1995341289.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811190900732-878854439.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;  &lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811190912266-1540572690.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811191038675-388646593.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811191105003-1895798975.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811191304865-1216039674.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811191314006-181856814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　倒数第二张是一幅灰度图，可见其增强效果是非常明显的，而最后一张是一副原本就不错的彩色照片，经过算法处理后整体变化不大，稍微更加鲜艳一点，这是有好处的，说明改算法对原本就不错的图，处理后质量不会有明显的差异，这正是我们所希望的。&lt;/p&gt;
&lt;p&gt;　　那么在原文中，作者还提出局部的自适应处理，主要也是基于报边滤波器和Log域进行了处理，大家可以直接运行作者提供的matlab代码试一试，但是那个代码似乎对原文做了不少的添加，特备是系数计算方面，不知道他的依据是什么。&lt;/p&gt;
&lt;p&gt;　　论文中还说到，全局处理容易出现halo现象，但是在我们的测试图中均未出现，其实这主要是由于我这些图都是LDR图，像素取值范围有限，即使对比度低，也不会出现HDR数据中数值之间可能出现的巨大差异，因此，对于高动态图像，后续的局部处理可能尤为必要，下半年我的部分时间可能会在这方面做点研究。&lt;/p&gt;
&lt;p&gt;　　速度测试：1080P的图像处理时间约为20ms。&lt;/p&gt;
&lt;p&gt;　　算法比较简单，有兴趣的朋友自行编程C代码，应该不难实现，测试DEMO见下述附件的Enhance--&amp;gt;全局低照度增强菜单。&lt;/p&gt;
&lt;p&gt;　　Demo下载地址：&lt;a href=&quot;https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/349293/201808/349293-20180811211458787-1809412458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Aug 2018 13:18:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<og:description>介绍了一种对于低照度图像进行增强的快速而又非常有效的算法，有Matlab和Java的代码参考实现，可使用C++进行快速实现，对很多算法的前处理具有非常重要帮助意义。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Imageshop/p/9460334.html</dc:identifier>
</item>
</channel>
</rss>