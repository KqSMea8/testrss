<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux 桌面玩家指南：10. 没有 GUI 的时候应该怎么玩 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop010.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前一篇讲了 X Window，这一篇就来讲讲没有 X Window 的 Linux，主要是 Linux 的字符模式，甚至是在进入 Linux 之前的 Grub 命令行模式。本来想把这一篇的标题叫《字符界面怎么玩》，或者《没有图形界面怎么玩》，但是怎么想都觉得不准确。去掉桌面环境的 Linux，并不一定就不是图形界面，因为 Linux 图形界面无处不在。以前我使用 Linux 桌面的时候，总是有一个误区：认为只有 XServer 启动后，才能够访问到图形系统，否则只能访问字符界面。随着对 Linux 的认识逐步加深，才发现即使在 XServer 启动之前，图形界面也是无处不在的。例如，Grub 的系统启动菜单，可以是图形化的，还可以通过改背景和主题进行美化。再例如在 Linux 初始化过程中，有一个 PlyMouth 软件，可以直接通过内核的 DRM 模块访问图形硬件，从而显示一个图形化的启动界面和进度条，同理，PlyMouth 也是可以通过更改主题进行美化的。最后，当 Linux 初始化完成后，会给我们显示一个让我们登录的图形界面，这就是 DM（Display Manager），这个 DM 既是 XServer 的父进程，负责启动 XServer，又是一个 XClient，给出图形化的登录接口。登录成功后，它又是 Gnome Shell 的父进程，负责启动 Gnome Shell。还有，即使在纯字符界面下，也是可以使用 FrameBuffer 获得图形功能的，甚至可以截图和播放视频。唯一的区别，就是在这些模式下，在没有桌面环境的情况下，我们和计算机的交互，往往只能通过 CLI 进行。所以，我给这一篇取名《没有 GUI 的时候应该怎么玩》。&lt;/p&gt;
&lt;h2 id=&quot;逆天的-grub&quot;&gt;逆天的 GRUB&lt;/h2&gt;
&lt;p&gt;Linux 系统启动的过程是这样的：先由 BIOS 启动一个系统引导程序；然后系统引导程序负责把 Linux 的内核加载到内存，同时把 initrd 加载到内存，然后把控制权交给 Linux 的内核；Linux 的内核初始化完成后，将控制权交给 init 程序；init 程序负责启动各种服务。如果要启动图形桌面系统，则 init 先启动一个窗口管理器，由窗口管理器负责用户的登录和验证；用户登录和验证成功后，窗口管理器负责启动 X 服务器和客户端，进入桌面系统。如果是不需要图形桌面系统的 Linux，则 init 启动 login 程序，login 程序负责用户的登录和验证，验证成功后，启动一个 shell。&lt;/p&gt;
&lt;p&gt;GRUB 就是目前 Linux 系统使用的系统引导程序，是计算机启动后运行的第一个程序（当然，BIOS除外）。它在将 Linux 内核加载到内存的时候，还可以向内核传递各种参数。目前的 Linux 发行版使用的 GRUB 都已经是第 2 版了，它的功能和配置都和以前的版本不一样。网上很多文章都是基于以前的 GRUB Legacy 版本进行的讲解，已经不能适应现在新的形势了。&lt;/p&gt;
&lt;p&gt;GRUB 的文档在这里：&lt;a href=&quot;https://www.gnu.org/software/grub/manual/grub/&quot; class=&quot;uri&quot;&gt;https://www.gnu.org/software/grub/manual/grub/&lt;/a&gt;。从前面的介绍可以看出，GRUB 是计算机启动后运行的第一个程序，这个时候 Linux 的内核还没有加载，其它的程序也都不可能运行。这时有人就会想了，这个 GRUB 的功能应该相当有限吧。我刚开始也是这么想的。但是当我读完前面给出的 GRUB 文档后，我的思想被彻底颠覆了。GRUB 的功能太 TM 强了，简直逆天。&lt;/p&gt;
&lt;p&gt;那么这个一开机就启动的简单程序究竟具有哪些让人意想不到的功能呢？请看我列举几条：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;能够访问任何设备上的数据，不管你是硬盘、软盘还是光盘；&lt;/li&gt;
&lt;li&gt;能够探测到所有的内存；&lt;/li&gt;
&lt;li&gt;能够识别大部分的文件系统，不管你是 FAT32、NTFS 还是 ext2/ext3/ext4；&lt;/li&gt;
&lt;li&gt;能够识别文件系统中的文件，文档中说它可识别大部分可执行文件格式，ELF什么的根本不在话下；&lt;/li&gt;
&lt;li&gt;能够使用 .png、.jpg 格式的图片作为背景，说明它能够识别一些图片格式；&lt;/li&gt;
&lt;li&gt;对字体的支持稍微差一点，好像只能使用 PFF2 格式的字体；&lt;/li&gt;
&lt;li&gt;当然可以读取和输出硬盘上的文本文件；&lt;/li&gt;
&lt;li&gt;据说还能播放乐曲；&lt;/li&gt;
&lt;li&gt;支持联网，可以从网络上启动操作系统；&lt;/li&gt;
&lt;li&gt;可以支持串口输入输出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些功能真的是已经超强了，就快赶上一个操作系统了。重要的是，它还提供了一个非常好用的命令行界面，该命令行界面的使用方法和 Linux 系统中的 Shell 极其接近，也支持编程、支持环境变量，其编程的语法也和 Bash 差不多。再加上 GRUB 提供的丰富的命令，该界面使用起来爽得不要不要的。&lt;/p&gt;
&lt;h2 id=&quot;grub-实战&quot;&gt;GRUB 实战&lt;/h2&gt;
&lt;p&gt;实践出真知，下面以 Ubuntu 为例开始实战。&lt;/p&gt;
&lt;h3 id=&quot;grub的界面&quot;&gt;GRUB的界面&lt;/h3&gt;
&lt;p&gt;刚安装好的 Ubuntu 启动时不显示 GRUB 界面，因为它在设置中把它隐藏了。它的启动画面是这样的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807214907135-1420605455.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必须按一下 ESC 键，我们才能够看到 GRUB 的菜单，它是这样的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807214945299-2111688449.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这个界面想必大家已经很熟悉了。在这个界面中，如果按下 c 键，就会切换到 GRUB 的命令行界面，如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807215059789-1966371025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况就是，如果大家在使用 Linux 过程中不小心删除了 /boot/grub/grub.cfg，或者配置错误，或者删除了 Linux 系统所在的硬盘分区的数据，使得 GRUB 无法正确加载 Linux 系统，也会自动进入到这个命令行界面。&lt;/p&gt;
&lt;h3 id=&quot;grub-支持的命令&quot;&gt;GRUB 支持的命令&lt;/h3&gt;
&lt;p&gt;GRUB 的命令补全功能非常方便，只要按一下 TAB 键，就可以显示它支持的所有命令。命令之后按 TAB 键，可以自动补全文件名。下面是 GRUB 支持的命令，我按 TAB 键调出来的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222157335-355836391.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;ls&lt;/code&gt;命令可以列出目录和文件，使用&lt;code&gt;cat&lt;/code&gt;命令可以输出文本文件的内容。在 GRUB 中，使用&lt;code&gt;(hd0, msdos1)&lt;/code&gt;或者&lt;code&gt;(hd0, gpt1)&lt;/code&gt;识别硬盘分区，使用&lt;code&gt;(hd0, gptN)/boot/grub/grub.cfg&lt;/code&gt;这样的形式识别文件。由于 GRUB 能自动识别根分区，所以我下面的命令中省略掉了指定硬盘分区的部分。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222206483-213234100.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我使用&lt;code&gt;cat /etc/fstab&lt;/code&gt;命令显示了我系统中硬盘分区的情况。可以看到，我使用的是 GPT 分区格式和 EFI 固件，硬盘分了三个去，第一个分区的挂载点是&lt;code&gt;/boot/efi&lt;/code&gt;，并且是 vfat 格式的文件系统，第二个分区的挂载点是根目录&lt;code&gt;/&lt;/code&gt;，第三个分区是 swap 空间。按照 GRUB 的术语，则分区&lt;code&gt;(hd0, gpt1)&lt;/code&gt;是挂载的&lt;code&gt;/boot/efi&lt;/code&gt;，分区&lt;code&gt;(hd0, gpt2)&lt;/code&gt;是根目录，分区&lt;code&gt;(hd0, gpt3)&lt;/code&gt;是交换分区。可以看到，GRUB 中硬盘是从 0 开始计数的，而分区是从 1 开始计数的。&lt;/p&gt;
&lt;h3 id=&quot;grub-的环境变量&quot;&gt;GRUB 的环境变量&lt;/h3&gt;
&lt;p&gt;我在之前的某一篇随笔中讲过，命令行参数、环境变量、配置文件是对软件进行配置的三驾马车，GRUB 也不例外，它的很多行为也受环境变量控制。下面看一个例子，当我想查看 GRUB 的启动配置文件&lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;时，使用&lt;code&gt;cat&lt;/code&gt;命令查看该文件的内容，但是由于该文件太长，一个屏幕显示不完，所以只能看到最后几行，如下两图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222229734-850836392.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222237057-1065506131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是非常蛋疼的，但还不是最郁闷的，毕竟&lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;是系统中的一个文件，大不了我进 Linux 后用 vim 看。最蛋疼的是某些命令的输出，只能看到最后几行，又不能保存下来，真的让人捉急。就像下面这个例子，我使用&lt;code&gt;videoinfo&lt;/code&gt;命令查看我的 GRUB 支持哪些图形分辨率：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180808110450024-1184917970.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180808110500764-488781893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候，就只能通过设置环境变量的方法来解决问题了。使用&lt;code&gt;set pager=1&lt;/code&gt;命令设置环境变量&lt;code&gt;pager&lt;/code&gt;，让 GRUB 的输出启用分页，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222244425-1405932208.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180808110550639-1843170004.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还可以通过不带参数的&lt;code&gt;set&lt;/code&gt;命令显示所有可用的环境变量，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222251927-146797524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以使用&lt;code&gt;echo&lt;/code&gt;命令输出某一个环境变量，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222259424-1121166414.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更改分辨率&quot;&gt;更改分辨率&lt;/h3&gt;
&lt;p&gt;我们可以控制 GRUB 显示界面的分辨率，还可以通过 GRUB 控制 Linux 启动进入字符模式后的分辨率。前提条件是要看我们的 BIOS 和显卡支持哪些模式。可以通过 &lt;code&gt;videoinfo&lt;/code&gt;命令查看，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222213463-531584051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我使用的是虚拟机，因为玩 GRUB 不使用虚拟机无法截图啊。如果采取的是 EFI 固件，则其输出如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222222014-1850037666.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果采取的是 Legacy BIOS，则其输出如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180808110550639-1843170004.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，如果使用的是 Legacy BIOS，它的显示模式是由 ' VESA BIOS Extension Video Driver ' 提供支持的。如果使用的是 EFI，则其显示模式是由 ' EFI GOP driver ' 提供支持的。在我的虚拟机中，它们能提供的最高分辨率也只有 1152 x 864，远远达不到 1920 x 1080。但是在我的物理机中，都是可以达到 1920 x 1080。而且貌似只能进入 1920 x 1080，想改小还改不了。在物理机上，想通过改小分辨率，然后利用显示器的放大功能来放大字体的梦想是破灭了的。&lt;/p&gt;
&lt;p&gt;在虚拟机中，我要做的是把分辨率改大，至少让我完全进入 Linux 字符界面的时候有个 1024 x 768 的分辨率吧，不然字符界面用起来岂不是太憋屈。可以通过修改 &lt;code&gt;/etc/default/grub&lt;/code&gt;文件，然后调用&lt;code&gt;sudo update-grub&lt;/code&gt;命令更新 GRUB。如下图，使用&lt;code&gt;sudo vim /etc/default/grub&lt;/code&gt;修改配置文件：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222305828-772090634.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的这个文件中的注释里，也写得很明白了，要修改 GRUB 和 Linux 字符界面的分辨率，可以通过修改 &lt;code&gt;GRUB_GFXMODE&lt;/code&gt; 和 &lt;code&gt;GRUB_GFXPAYLOAD_LINUX&lt;/code&gt; 参数来设置，而且千万不要设置&lt;code&gt;GRUB_TERMINAL=console&lt;/code&gt;，不然就真的进入只有文字的文字模式了，没有 Graphic 的支持，还谈啥分辨率呢。&lt;/p&gt;
&lt;p&gt;然后重启系统，可以看到我们的 GRUB 界面变大了一圈，如下两图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222312600-1954130370.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222320926-277554756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面进入 Linux 的字符界面，进入 Linux 字符界面的方式是启动进入 Linux 后，使用 &lt;code&gt;sudo systemctl set-default multi-user.target&lt;/code&gt;，然后重启，在 1024 x 768 的分辨率下开一个 vim 看看，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180808174905498-525434245.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;又找到了怀旧的感觉，不是吗？唯一的缺憾是字太小。如果是在我的物理机上，15.6寸 1920 x 1080 的屏幕，字会小得根本无法看。下面，我们再来探讨 Framebuffer 的正确打开姿势。&lt;/p&gt;
&lt;h2 id=&quot;linux-纯字符模式和-framebuffer&quot;&gt;Linux 纯字符模式和 Framebuffer&lt;/h2&gt;
&lt;h3 id=&quot;linux-纯字符界面的用途&quot;&gt;Linux 纯字符界面的用途&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;装逼必备&lt;/li&gt;
&lt;li&gt;省资源，服务器一般不安装图形界面&lt;/li&gt;
&lt;li&gt;图形界面崩溃后紧急救援&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;进入字符界面的正确方式&quot;&gt;进入字符界面的正确方式&lt;/h3&gt;
&lt;p&gt;目前新的 Linux 发行版基本上都使用 Systemd 作为 init 程序，不再使用 SysV init 和 Upstart init。所以如果想让系统启动后直接进入字符界面，应该使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo systemctl set-default multi-user.target&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反过来，要让系统启动后直接进入图形界面，应该使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo systemctl set-default graphical.target&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，Linux 本身提供有虚拟控制台的功能，使用&lt;code&gt;Ctrl + Alt + F1&lt;/code&gt;到&lt;code&gt;Ctrl + Alt + F7&lt;/code&gt;进行切换，其中有一个是图形界面，剩下的是字符界面。图形界面玩崩溃了，就不得不使用&lt;code&gt;Ctrl + Alt + F3&lt;/code&gt;切换到字符界面进行救援。&lt;/p&gt;
&lt;h3 id=&quot;关于-framebuffer&quot;&gt;关于 Framebuffer&lt;/h3&gt;
&lt;p&gt;字符界面分两种，一种是不开启 Framebuffer 的，另一种是开启 Framebuffer 的。Framebuffer 是一种图形驱动，不开启 Framebuffer 就是真的全字符，不能改变分辨率，不能显示图像，不能截图。目前最新的 Linux 发行版默认开启 Framebuffer。控制 Framebuffer 开启和关闭，以及分辨率的方法，是设置 Grub2 的参数。修改 &lt;code&gt;/etc/default/grub&lt;/code&gt;文件，添加如下参数可以设置分辨率：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;GRUB_GFXPAYLOAD_LINUX=1024x768x32&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用如下命令更新 GRUB2 配置：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo update-grub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的分辨率必须是我们的硬件支持的。可以通过 GRUB2 命令行中的&lt;code&gt;videoinfo&lt;/code&gt;命令查看我们的硬件支持的分辨率。&lt;/p&gt;
&lt;p&gt;如果要关闭 Framebuffer，则这样更改 GRUB2 的配置：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;GRUB_GFXPAYLOAD_LINUX=text&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，需要：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo update-grub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重启。&lt;/p&gt;
&lt;h2 id=&quot;字符界面下联网&quot;&gt;字符界面下联网&lt;/h2&gt;
&lt;p&gt;以前在图形界面的时候，设置个网络、连接个 wifi 非常简单，玩儿似的，结果一进入纯字符界面就抓瞎。不联网，就不能下载和安装软件包，后面就玩不下去了。所以进入纯字符界面后，要解决的第一件事就是怎么联网。说到管理网络的工具，大家可以列举一大堆，什么 ipconfig、iwconfig、ip 等等。但是，在最新的 Linux 发行版中，已经是使用 NetManager 管理网络了。通过阅读 NetManager 的文档，可以知道它提供一个功能很强大的命令行工具，那就是 nmcli。通过&lt;code&gt;man nmcli&lt;/code&gt;可以查看该工具的用法。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180827141427050-1411930043.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用如下命令可以查看可用的 wifi 热点以及连接 wifi：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;nmcli device status                                         #查看网络连接的状态，可以看到各网卡的名称
nmcli device wifi list iface 网卡名称                 #查看可用的 wifi 热点
nmcli device wifi connect **** password ****   #连接 wifi，需要提供 wifi 的名称和密码&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921210920821-1505636376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;连上了网，Ubuntu 就可以在纯字符界面下起飞了。&lt;/p&gt;
&lt;h2 id=&quot;使用-fbterm&quot;&gt;使用 fbterm&lt;/h2&gt;
&lt;p&gt;通过上面的截图，发现两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在我的 1920x1080 的笔记本电脑屏幕上，默认的字实在是太小；&lt;/li&gt;
&lt;li&gt;不能显示中文，上图中 wifi 热点名称含有中文的，都显示不出来。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解决办法是使用 fbterm。一举解决字体大小问题和中文显示问题。先安装 fbterm，使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt-get install fbterm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先使用&lt;code&gt;sudo fbterm&lt;/code&gt;启动 fbterm 一次，再用&lt;code&gt;exit&lt;/code&gt;命令退出，这样，fbterm 会自动生成一个默认的配置文件&lt;code&gt;~/.fbtermrc&lt;/code&gt;，然后修改&lt;code&gt;~/.fbtermrc&lt;/code&gt;配置文件中的两行，设置使用的字体和字体大小，如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;font-names=DejaVu\ Sans\ Mono
font-size=16&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用&lt;code&gt;sudo fbterm&lt;/code&gt;命令启动 fbterm，就可以了。下面是看对比图，使用 fbterm 之前，Vim 的启动界面是不能显示中文的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921214800672-1410905995.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 fbterm 之后，中文可以正常显示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921214838337-1879128695.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 fbterm 之前，阅读代码是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921214910487-917688996.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字非常的小，NERDTree 和 Tagbar 里面的符号显示也有问题。使用 fbterm 之后，就很漂亮了，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921215016058-673121513.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这才是全高清屏该有的显示效果嘛。关于在 fbterm 下输入中文，我尝试过 fbterm-ucimf，也尝试过 fcitx-frontend-fbterm，都没有成功。后来我就不试了，反正我也没有在全字符界面下输入中文的需求。&lt;/p&gt;
&lt;h2 id=&quot;显示-framebuffer-的信息&quot;&gt;显示 Framebuffer 的信息&lt;/h2&gt;
&lt;p&gt;使用 fbset 可以查看 Framebuffer 的信息，包括 Framebuffer 是否开启，分辨率是多少，由哪个内核模块提供支持等。使用如下命令安装 fbset：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt-get install fbset&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;sudo fbset -i&lt;/code&gt;命令查看 Framebuffer 的信息，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921215251522-1350097288.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在-framebuffer-下截图&quot;&gt;在 Framebuffer 下截图&lt;/h2&gt;
&lt;p&gt;使用 fbgrab 可以在 Framebuffer 下进行截图。使用如下命令安装 fbgrab：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt-get install fbgrab&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 fbgrab 命令的方式如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo fbgrab -c N filename.png      #对 /dev/ttyN 对应的终端进行截图
sudo fbgrab -C N filename.png     #先跳转到 /dev/ttyN 对应的终端，再进行截图
sudo fbgrab -s N filename.png      #先等待 N 秒，再进行截图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我前面的图片都是使用 fbgrab 截的，这里就不贴图了。&lt;/p&gt;
&lt;h2 id=&quot;在-framebuffer-下查看图片&quot;&gt;在 Framebuffer 下查看图片&lt;/h2&gt;
&lt;p&gt;使用 fbi 可以在 Framebuffer 下查看图片，同样使用&lt;code&gt;sudo apt-get install fbi&lt;/code&gt;安装这个软件。在看图界面下按 H 键，还会显示帮助信息。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180921220124237-1147375184.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在纯字符界面下上网&quot;&gt;在纯字符界面下上网&lt;/h2&gt;
&lt;p&gt;使用老牌的上网工具 w3m，安装方式&lt;code&gt;sudo apt-get install w3m&lt;/code&gt;，然后使用&lt;code&gt;w3m https://www.cnblogs.com/&lt;/code&gt;就可以访问博客园了，只有文字哦，图片就不要想了。效果如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180827151342147-1344507154.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，必须在 fbterm 下执行才能显示中文。&lt;/p&gt;
&lt;h2 id=&quot;视频播放&quot;&gt;视频播放&lt;/h2&gt;
&lt;p&gt;使用 mplayer 播放器可以播放视频，通过&lt;code&gt;mplayer -vo help&lt;/code&gt;命令可以看到，mplayer 支持很多种视频驱动，而 Framebuffer 正是其中一种。使用&lt;code&gt;sudo mplayer -vo fbdev2 badapple.mp4&lt;/code&gt;播放 Bad Apple 的 PV 视频，效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180923180402616-1308594093.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为这里要录制 gif 动画，所以我使用了虚拟机运行 Linux，Framebuffer 的分辨率设置为 1024x768。同样，通过上面的&lt;code&gt;mplayer -vo help&lt;/code&gt;命令，还可以看到 mplayer 支持使用 libaa 库，将视频播放为字符画。据我观察，只有在图形界面下效果才可以，纯字符界面不行。使用&lt;code&gt;mplayer -vo aa -moniterpixelaspect 0.5 badapple.mp4&lt;/code&gt;播放，效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180923181636488-1405704770.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;屏保和装逼&quot;&gt;屏保和装逼&lt;/h2&gt;
&lt;p&gt;当然是 cmatrix 啦。效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180923180657132-1296129641.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年11月02日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 22:33:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop010.html</dc:identifier>
</item>
<item>
<title>大前端的自动化工厂（5）—— 基于Karma+Mocha+Chai的单元测试和接口测试 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9736491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9736491.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/17/cfaef2db2824131c2e59019854e0d091.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/17/eb9dedf7676a4b0881e3f3c810489fe4.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-前端自动化测试&quot;&gt;一. 前端自动化测试&lt;/h2&gt;
&lt;p&gt;大多数前端开发者对测试相关的知识是比较缺乏的，一来是开发节奏很快，来不及写，另一方面团队里也配备了“人肉测试机”，完全没必要自己来。但随着项目体量的增大，许多人维护同一份代码，经常会出现有些函数莫名其妙地结果不对了，或者某个接口的入参变了，又或者哪位大哥把后端返回的数据结构给改了。每天工作的时间里被拉来拉去帮人定位问题，结果花了很多时间却发现大部分都是别人的锅。每当遇到项目上线，那就更热闹了，跟着其他“人肉测试机”大家一起点点点......&lt;/p&gt;
&lt;p&gt;很多团队都有个通病，凡是出了问题，先往前端身上推，然后前端各种检测排查，到最后是谁的锅，谁呵呵一笑然后领走就完了，如果你也曾因此心里印下了不计其数的草泥马的马蹄印，那我强烈建议你学习【前端自动化测试】相关的知识，或许你不会经常用到它，但在组内互怼和甩锅的环节绝对能助你一臂之力。当然总有一天，你会发现测试的价值远不止这样。&lt;strong&gt;它对大型项目提供的可靠性保障是人力无法比拟的&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前端很流行这样一句话：如果你觉得单元测试没什么用，只能说明你做的项目不够大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二.-工具简介&quot;&gt;二. 工具简介&lt;/h2&gt;
&lt;h3 id=&quot;karma&quot;&gt;2.1 Karma&lt;/h3&gt;
&lt;p&gt;官方网址：&lt;a href=&quot;https://karma-runner.github.io/2.0/index.html&quot; class=&quot;uri&quot;&gt;https://karma-runner.github.io/2.0/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Karma&lt;/code&gt;为前端自动化测试提供了跨浏览器测试的能力&lt;/strong&gt;，可以自动在&lt;code&gt;Chrome&lt;/code&gt;,&lt;code&gt;Firefox&lt;/code&gt;,&lt;code&gt;IE&lt;/code&gt;等主流浏览器依次跑完测试用例，同时也支持headless浏览器(入&lt;code&gt;phantomJs&lt;/code&gt;)中运行测试用例。&lt;code&gt;webpack&lt;/code&gt;+&lt;code&gt;babel&lt;/code&gt;可以主动为想要适配的浏览器提供转码和垫片补丁引入能力，而&lt;code&gt;Karma&lt;/code&gt;可以为最终的结果提供验证能力。&lt;code&gt;Karma&lt;/code&gt;的配置方式可以阅读&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/9572753.html&quot;&gt;《webpack4.0各个击破(9)——Karma篇》&lt;/a&gt;进行了解。&lt;/p&gt;
&lt;h3 id=&quot;mocha&quot;&gt;2.2 Mocha&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Mocha&lt;/code&gt;是前端自动化测试框架&lt;/strong&gt;，测试框架需要解决&lt;strong&gt;兼容不同风格断言库&lt;/strong&gt;，&lt;strong&gt;测试用例分组&lt;/strong&gt;，&lt;strong&gt;同步异步测试架构&lt;/strong&gt;，&lt;strong&gt;生命周期钩子&lt;/strong&gt;等框架级的能力。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Mocha&lt;/code&gt;的基本语法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;describe('我现在要测某一个页面的几个功能',function(){
    describe('现在要测XX功能',function(){
        it('某个变量的值应该是数字',function(){
            //写断言
        })
    });
     describe('现在要测YY功能',function(){
        it('某个数组长度应该不小于10',function(){
            //写断言
        })
    });
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;异步测试语法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;describe('现在要测XX功能',function(){
    it('某个变量的值应该是数字',function(done){
        //写断言
        //手动调用done()表示异步结束，类似于Promise中的resolve
    })
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不同风格的断言库&lt;/p&gt;
&lt;p&gt;支持&lt;code&gt;should.js&lt;/code&gt;,&lt;code&gt;expect.js&lt;/code&gt;及node核心断言模块&lt;code&gt;assert&lt;/code&gt;等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生命周期钩子&lt;/p&gt;
&lt;p&gt;生命周期钩子一般用来建立和清理环境或全局变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
describe('hooks', function() {
  before(function() {
    // runs before all tests in this block
  });
  after(function() {
    // runs after all tests in this block
  });
  beforeEach(function() {
    // runs before each test in this block
  });
  afterEach(function() {
    // runs after each test in this block
  });
  // test cases
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;chai&quot;&gt;2.3 Chai&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Chai&lt;/code&gt;是一个断言库合集&lt;/strong&gt;，支持&lt;code&gt;expect&lt;/code&gt;,&lt;code&gt;assert&lt;/code&gt;,&lt;code&gt;should&lt;/code&gt;断言语法，非专业测试岗位其实没必要深究，了解使用方法就可以了。使用示例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;expect(bar).to.not.exist;//断言变量bar不存在
expect(data).to.have.ownProperty('length');//断言data有length属性
expect(name).to.be.a('string');//断言name是一个字符串
assert.equal(value1,value2);//断言value1和value2相等
Tim.should.be.an.instanceof(Person);//断言Tim是Person类的实例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的语法在引入了&lt;code&gt;Chai&lt;/code&gt;后都是支持的，当断言不成立时，结果报告中会给出明确标记。&lt;/p&gt;
&lt;h2 id=&quot;三.-基于chai的自动化单元测试&quot;&gt;三. 基于Chai的自动化单元测试&lt;/h2&gt;
&lt;p&gt;单元测试的原理并不算复杂，相当于另外编写了一套程序，把业务逻辑中的脚本文件当做模块引入，模拟其运行环境（例如需要的浏览器类型，全局变量等），然后使用一组或若干组覆盖不同使用场景的参数来调用想要测试的函数单元，并判断函数返回的结果是否和预期的相同。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单地说，自动化测试工具只是取代了一个照着Excel表格测试并记录结果的人力资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试用例文件的基本写法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var chai = require('chai');//引入断言库
var expect = chai.expect;//使用expect语法
//引用源代码中的业务逻辑模块；
var ColorFac = require('../../../../src/components/Example/colorFac');

describe(&quot;ColorFac Module Test&quot;, function () {
  it(&quot;should return a luminanced color&quot;, function () {
      //调用源代码中业务逻辑模块中的方法;
    var color = ColorFac.luminate(&quot;#fff&quot;, &quot;-0.5&quot;);
      //编写测试断言
    expect(color).is.not.empty;
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试报告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/17/a319218b28a084d225740416ab68d2eb.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;Webpack + Karma + Mocha + Chai&lt;/strong&gt;进行自动化测试（单元测试+代码覆盖率）的方法可以查看&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/9572753.html&quot;&gt;《webpack4.0各个击破(9)——Karma篇》&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;四.-基于chai-http的自动化接口测试&quot;&gt;四. 基于Chai-http的自动化接口测试&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Chai-Http&lt;/code&gt;是基于&lt;code&gt;Chai&lt;/code&gt;扩展的插件，可用于测试与&lt;code&gt;http&lt;/code&gt;请求相关的逻辑代码。开发中也可以利用&lt;code&gt;PostMan&lt;/code&gt;或是&lt;code&gt;DocLever&lt;/code&gt;来管理接口并进行接口测试。接口测试的运行方式和单元测试很类似，区别在于测试用例的写法。假设接口测试的用例都写在&lt;strong&gt;/test/apis/apis.js&lt;/strong&gt;中,配置方式如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Karma.api.conf.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var path = require('path');
module.exports = function(config) {
    config.set({
        files: [
            'test/apis/apis.js'
        ],
        // frameworks to use
        frameworks: ['mocha'],
        preprocessors: {
            // only specify one entry point
            // and require all tests in there
            'test/apis/apis.js': ['webpack']
        },
        reporters: ['mocha'],
        webpack: {
            mode: 'none',
        },
        webpackMiddleware: {
            noInfo: true
        },
        plugins: [
            require(&quot;karma-webpack&quot;),
            require(&quot;karma-mocha&quot;),
            require(&quot;karma-chai&quot;),
            require(&quot;karma-chrome-launcher&quot;),
            require(&quot;karma-mocha-reporter&quot;),
        ],
        browsers: ['Chrome']
    });
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;/test/apis/apis.js&lt;/code&gt;：(测试用例的语义化非常明显，代码基本不需要解释)。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var chai = require('chai');
var chaiHttp = require('chai-http');
var expect = chai.expect;
chai.use(chaiHttp);

//define address
const ADDRESS = &quot;http://localhost:3001&quot;;
//open a http connection
var requester = chai.request(ADDRESS);
describe('列表服务APIS测试',function () {

    it('GET /healthmap/chart1 应该返回包含legendData字段的数据',function (done) {
        chai.request(ADDRESS).get('/healthmap/chart1')
        .end((err,res)=&amp;gt;{
            var data = JSON.parse(res.text);
            expect(res).to.have.status(200);
            expect(data.data).to.have.ownProperty('legendData');
            done();
        })
    });
    
    it('GET /operationdashboard/systemwarn 应该返回字符串',function (done) {
        chai.request(ADDRESS).get('/operationboard/systemwarn')
        .end((err,res)=&amp;gt;{
            var data = JSON.parse(res.text);
            expect(res).to.have.status(200);
            expect(data.data).to.be.a('String');
            done();
        })
    });
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令行里启动&lt;code&gt;Karma&lt;/code&gt;跑一下接口测试，就可以看到结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/17/df7a6dd9cdd7d15772401804f5e7ce4f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试用例没通过的接口全都被标记出来了，省心省力。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 22:24:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>一. 前端自动化测试 大多数前端开发者对测试相关的知识是比较缺乏的，一来是开发节奏很快，来不及写，另一方面团队里也配备了“人肉测试机”，完全没必要自己来。但随着项目体量的增大，许多人维护同一份代码，经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9736491.html</dc:identifier>
</item>
<item>
<title>巧用浏览器F12调试器定位系统前后端bug - 韬哥（NickJiang）</title>
<link>http://www.cnblogs.com/nickjiang/p/9893278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickjiang/p/9893278.html</guid>
<description>&lt;p&gt;做测试的小伙伴可能用过httpwatch，firebug，fiddler，charles等抓包（数据包）工具，但实际上除了这些还有一个简单实用并的抓包工具，那就是浏览器的F12调试器。&lt;/p&gt;
&lt;p&gt;httpwatch，firebug都是浏览器的插件，需要额外下载，fiddler，charles也需要额外下载安装包另行安装，但是浏览器F12调试器却是所有浏览器内置的调试器，不需要大家额外去安装的，打开它只是一个顺手的事情，而且它提供的功能也比较强大，因此如果在开发或者测试web系统的时候，我们可以先考虑使用这个调试器去抓包，来调试系统或者用它来协助定位系统中的bug。&lt;/p&gt;
&lt;p&gt;下文中我准备了几个小案例来说明这个工具的用法以及使用它的便捷性。&lt;/p&gt;
&lt;p&gt;废话不多说，我们首先来一睹它的阵容，以火狐为例，打开浏览器，再按F12就可以打开调试器，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101213922689-1913839105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：不同的浏览器，调试器在ui上可能会有少许差异，但基本功能都差不多，掌握了某种浏览器调试器的用法后，其他也很容易上手。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232242120-292424776.gif&quot; alt=&quot;&quot;/&gt;下面我们通过几个小案例来说明我们测试人员在系统测试中有哪些场景能够应用上调试器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;场景：在对web系统进行测试时，如何分析一个bug是来自于前端还是后端。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先说一下，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232319928-1616257687.jpg&quot; alt=&quot;&quot;/&gt;为什么找到网站中的bug后还要去分析它到底是属于前端bug还是后端bug，三个原因：&lt;/p&gt;
&lt;p&gt;1.在一些公司，一个系统可能是由前端团队和后端团队共同开发出来的，因此在分配bug的时候，不同模块的bug一般都会指派给对应的负责团队乃至于个人。&lt;/p&gt;
&lt;p&gt;2.提bug的时候，如果能尽量提供有价值的信息给开发人员，来缩小定位范围，甚至于如果能够直接协助定位到bug出在哪里，那么开发人员将更容易去fix掉bug，从而降低了测试和开发之间的沟通成本，提高了工作效率。&lt;/p&gt;
&lt;p&gt;3.bug提的好从侧面也能体现测试人员具备了较高的技术专业性，而不是只会点点点，个人形象在项目团队中也会得到迅速提升。别人也会认为你是大佬，他们看你的表情如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232341685-1089478948.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们在分析一个系统bug来自于前端还是后台时，最有用的两个是调试器提供的两个标签，这两个标签底下都记录了一些数据，&lt;span&gt;&lt;span&gt;&lt;strong&gt;一个是控制台，一个网络&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;控制台&lt;/strong&gt;&lt;/span&gt;：记录了前端js执行的情况，以及前端向服务器发出去的所有http请求信息，，如果有js错误可以在控制台下看到，同样如果发送到后台的某个http请求没有得到服务器正常响应，也能看到他的状态信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;网络&lt;/strong&gt;&lt;/span&gt;：记录了前端往服务器发的所有的http请求信息，而且每个请求发送了什么数据，服务器是否正常响应了请求，如果响应了，响应回来的状态码是什么，响应数据是什么都可以在“网络”标签下看到。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101223239826-107491529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说了这么多，到底怎么用呢。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232444582-1795017514.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一个小案例&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;1）访问：http://39.108.136.60:8380/ningmengban/app/login/login.html&lt;/p&gt;
&lt;p&gt;2）输入登录账号(用户名 / 密码)：304034318@qq.com / 123456&lt;/p&gt;
&lt;p&gt;3）点击登录，无任何反映（没有提示也没有跳转）&lt;/p&gt;
&lt;p&gt;从页面交互看，输入账号，点击登录要么登录成功进入系统，跳转到系统其他页面，要么登录失败给出错误提示，而现在没有任何反应，这肯定是一个bug，但是这个bug到底是属于前端bug还是后端，我们无从而知，但是我们可以顺手打开浏览器调试器来分析定位一下。&lt;/p&gt;
&lt;p&gt;打开控制台，我们看到了控制台有一个js错误，并且是login.js这个脚本在执行的时候报的一个错误，login是登录的意思，所以我们下意识认为这个js脚本就是定义了登录前端逻辑的js脚本，点击登录按钮没任何反应这个bug很可能就是因为前端js执行报错引起的，截个图，写上自己的分析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101222849540-990705291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 为了进一步验证自己的猜想，还可以再看下“网络”标签:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101224054853-2038949320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定论：经过分析，前端登录脚本执行报错导致了前端没有对后台登录接口发起调用，页面点击登录按钮没有任何提示，这个bug属于前端的bug。我们提bug的时候带上上面的两个截图，里面有我们的分析。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232517416-1969830571.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二个小案例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）访问：http://39.108.136.60:8380/ningmengban/app/login/login.html&lt;/p&gt;
&lt;p&gt;2）输入登录账号(用户名 / 密码)：304034318@qq.com / 123456&lt;/p&gt;
&lt;p&gt;3）点击登录，无任何反映（没有提示也没有跳转）&lt;/p&gt;
&lt;p&gt;从页面交互看，输入账号，点击登录要么登录成功进入系统，跳转到系统其他页面，要么登录失败给出错误提示，而现在没有任何反应，这肯定是一个bug，但是这个bug到底是属于前端bug还是后端，我们无从而知，但是我们可以顺手打开浏览器调试器来分析定位一下。&lt;/p&gt;
&lt;p&gt;打开控制台，我们看到了控制台并没有js错误，但是有向后台发起一个请求，此时还无法有效定位到问题到底发生在前端还是后端，但是可以截个图，写上自己的测试过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101224828451-1954878389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了进一步定位，可以打开“网络”标签：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101225101991-2136921111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定论：这个404 not found请求路径找不到的问题，可能是前端后台开发人员改了接口地址，也有可能是前端js发起登录请求是接口地址写错了，所以这个bug可以题给前端开发，也可以提给后端。只要提供了上面分析截图，开发人员也能秒改这个bug。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232802058-2053966791.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三个小案例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）访问：http://39.108.136.60:8380/ningmengban/app/login/login.html&lt;/p&gt;
&lt;p&gt;2）输入登录账号(用户名 / 密码)：304034318@qq.com / 123456&lt;/p&gt;
&lt;p&gt;3）点击登录，无任何反映（没有提示也没有跳转）&lt;/p&gt;
&lt;p&gt;从页面交互看，输入账号，点击登录要么登录成功进入系统，跳转到系统其他页面，要么登录失败给出错误提示，而现在没有任何反应，这肯定是一个bug，但是这个bug到底是属于前端bug还是后端，我们无从而知，但是我们可以顺手打开浏览器调试器来分析定位一下。&lt;/p&gt;
&lt;p&gt;打开控制台，我们看到了控制台并没有js错误，但是有向后台发起一个请求，同样，此时还无法有效定位到问题到底发生在前端还是后端，但是可以截个图，写上自己的测试过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101224828451-1954878389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 继续打开“网络”标签，我们看到这个底下有一个500请求，根据请求中的关键字眼login我们断定这个就是登录接口，而500则说明是后端服务器内部异常，一般是由于后台代码执行中报错导致的，所以截图写上我们的分析，到时候提bug附上这个截图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101230330780-191835725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 定论：根据请求返回的状态码500，我们就能断定这个bug是后台代码执行时候报错导致的，提bug带上上面的这个信息，开发人员就知道要去检查登录接口的代码了，因此缩小了开发定位问题的范围，保证了开发能在第一时间快速fix掉bug。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232536677-144185844.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;好了，给大家演示了三个小案例，教大家在碰到bug时，如何顺手借助浏览器调试器定位到bug到底来自于前端还是后端，当然我建议大家平时多关注一下http请求的响应状态码，对于常见的http code，比如200、302、404、500这些最好都去了解下，这样结合了我们的工具，在定位分析问题的时候，我们会更坚定和自信。&lt;/p&gt;
&lt;p&gt;小工具，但是很实用，这个技能大家get到了么。希望大家在工作当中能够应用起来。用的多了就自然熟练了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232552822-2037034425.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 15:29:00 +0000</pubDate>
<dc:creator>韬哥（NickJiang）</dc:creator>
<og:description>做测试的小伙伴可能用过httpwatch，firebug，fiddler，charles等抓包（数据包）工具，但实际上除了这些还有一个简单实用并的抓包工具，那就是浏览器的F12调试器。 httpwat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickjiang/p/9893278.html</dc:identifier>
</item>
<item>
<title>记录一则expdp任务异常处理案例 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9893302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9893302.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;AIX 6.1 + Oracle 10.2.0.4&lt;br/&gt;&lt;strong&gt;现象：&lt;/strong&gt;在XTTS迁移测试阶段，遇到执行几个expdp的导出任务，迟迟没有返回任何信息，对应日志无任何输出，查看任务状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; 
set lines 300
col OWNER_NAME for a10
col OPERATION for a15
col JOB_MODE for a20
col STATE for a15
select * from dba_datapump_jobs; 

OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE             STATE               DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- -------------------- --------------- ---------- ----------------- -----------------
SYS        SYS_EXPORT_TRANSPORTABLE_01    EXPORT          TRANSPORTABLE        DEFINING                 1                 0                 1
SYS        SYS_EXPORT_TRANSPORTABLE_02    EXPORT          TRANSPORTABLE        DEFINING                 1                 1                 2
SYS        SYS_EXPORT_TRANSPORTABLE_03    EXPORT          TRANSPORTABLE        DEFINING                 1                 1                 2
SYS        SYS_EXPORT_SCHEMA_01           EXPORT          SCHEMA               DEFINING                 1                 1                 2
SYS        SYS_EXPORT_TRANSPORTABLE_04    EXPORT          TRANSPORTABLE        DEFINING                 1                 1                 2
SYS        SYS_EXPORT_SCHEMA_02           EXPORT          SCHEMA               DEFINING                 1                 1                 2

6 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到所有的expdp导出任务的STATE都停留在DEFINING状态。&lt;/p&gt;

&lt;p&gt;先强制杀掉后台执行的所有expdp任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep expdp|grep -v grep|awk '{print $2}'|xargs kill -9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后尝试删除这些表（其实应该在not running状态下删除）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 'drop table '||OWNER_NAME||'.'||JOB_NAME||' purge;' from dba_datapump_jobs where STATE='NOT RUNNING';

drop table sys.SYS_EXPORT_TRANSPORTABLE_01 purge;
..&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可这样是没有作用的，查询结果不变。&lt;br/&gt;甚至尝试正常shutdown immediate停止数据库，也无法成功，告警日志看到有活动调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Nov  1 15:14:24 2018
Active call for process 4522064 user 'oracle' program 'oracle@localhost (DM00)'
Active call for process 4456536 user 'oracle' program 'oracle@localhost (DM01)'
Active call for process 10027180 user 'oracle' program 'oracle@localhost (DM02)'
Active call for process 7340140 user 'oracle' program 'oracle@localhost (DM03)'
Active call for process 6291888 user 'oracle' program 'oracle@localhost (DM04)'
Active call for process 8126596 user 'oracle' program 'oracle@localhost (DM05)'
SHUTDOWN: waiting for active calls to complete.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现这些进程的id都对应了ora_dm的进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ps -ef|grep ora_dm
  oracle  4456536        1   0 17:00:09      -  0:00 ora_dm01_xxxxdb
  oracle  4522064        1   0 16:50:57      -  0:00 ora_dm00_xxxxdb
  oracle  7340140        1   0 14:06:07      -  0:00 ora_dm03_xxxxdb
  oracle  8126596        1   0 14:35:03      -  0:00 ora_dm05_xxxxdb
  oracle 10027180        1   0 13:55:08      -  0:00 ora_dm02_xxxxdb
  oracle  6291888        1   0 14:31:17      -  0:00 ora_dm04_xxxxdb
  oracle  7340432  8388786   0 15:22:59  pts/4  0:00 grep ora_dm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，这就是expdp任务的相关进程，强制杀掉这些进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep ora_dm|grep -v grep|awk '{print $2}'|xargs kill -9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后数据库关闭成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Nov  1 15:24:37 2018
All dispatchers and shared servers shutdown
Thu Nov  1 15:24:37 2018
ALTER DATABASE CLOSE NORMAL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动数据库后，再次查询发现已经成功清理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; 
set lines 300
col OWNER_NAME for a10
col OPERATION for a15
col JOB_MODE for a20
col STATE for a15
select * from dba_datapump_jobs; 

no rows selected&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;数据泵任务与ora_dm进程相关；如果数据泵任务发生异常，但任务并没有退出的情况，需要同时杀掉这类进程（杀掉后状态就会变为NOT RUNNING）。关库不是必须的，只是演示此时正常关闭被阻塞的场景。这也能说明为什么要保证在NOT RUNNING状态下才可以清理。&lt;/p&gt;

&lt;p&gt;上面的步骤只是清理了异常的数据泵任务，但没有解决问题，再次后台执行备份任务依然会重现故障：&lt;br/&gt;nohup sh expdp_xtts.sh &amp;amp;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ps -ef|grep expdp
  oracle  6684914  8061208   0 15:30:07  pts/2  0:00 grep expdp
  oracle  7143482  8061208   0 15:30:03  pts/2  0:00 sh expdp_xtts.sh
  oracle  6685096  7143482   0 15:30:03  pts/2  0:00 expdp '/ as sysdba' parfile=expdp_xtts.par
$ ps -ef|grep ora_dm
  oracle  7602308  8061208   0 15:30:10  pts/2  0:00 grep ora_dm
  oracle  3997964        1   1 15:30:05      -  0:00 ora_dm00_xxxxdb
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时查询dba_datapump_jobs,state依然一直是defining状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE                       STATE                              DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- ------------------------------ ------------------------------ ---------- ----------------- -----------------
SYS        SYS_EXPORT_TRANSPORTABLE_01    EXPORT          TRANSPORTABLE                  DEFINING                                1                 1                 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的导出任务都一样，不再赘述。&lt;br/&gt;为了方便测试，写一个简单的单表expdp导出，现象也一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expdp \'/ as sysdba\' directory=XTTS tables=query.test dumpfile=query_test.dmp logfile=query_test.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据故障现象，用如下关键字在MOS中搜索: expdp state DEFINING，匹配到文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DataPump Export/Import Hangs With &quot;DEFINING&quot; Status When Using A Directory On NFS Filesystem (文档 ID 2262196.1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正好这次测试是在NFS文件系统上，MOS建议移动到本地文件系统导出。&lt;/p&gt;
&lt;p&gt;这次再将expdp进程全部杀掉：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep ora_dm|grep -v grep|awk '{print $2}'|xargs kill -9
ps -ef|grep expdp|grep -v grep|awk '{print $2}'|xargs kill -9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时查询dba_datapump_jobs：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE                       STATE               DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- ------------------------------ --------------- ---------- ----------------- -----------------
SYS        SYS_EXPORT_TABLE_04            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_SCHEMA_01           EXPORT          SCHEMA                         NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_02            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_05            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_03            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_01            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TRANSPORTABLE_01    EXPORT          TRANSPORTABLE                  NOT RUNNING              0                 0                 0

7 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清理NOT RUNNING的master表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 'drop table '||OWNER_NAME||'.'||JOB_NAME||' purge;' from dba_datapump_jobs where STATE='NOT RUNNING';
--执行结果用来执行，再次查看结果为空：
SQL&amp;gt; select * from dba_datapump_jobs;
no rows selected&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按MOS建议，将导出任务移动到本地文件系统：&lt;br/&gt;AIX源端导出XTTS源数据至源端/hxbak/xtts_exp目录中，而后copy至nfs共享存储/xtts/dmp中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /hxbak/xtts_exp
chown oracle:dba /hxbak/xtts_exp
ls -ld /hxbak/xtts_exp

select * from dba_directories;
create or replace directory XTTS as '/hxbak/xtts_exp';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时测试expdp任务可正常运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ expdp \'/ as sysdba\' directory=XTTS tables=query.test dumpfile=query_test.dmp logfile=query_test.log
Export: Release 10.2.0.4.0 - 64bit Production on Thursday, 01 November, 2018 16:03:21

Copyright (c) 2003, 2007, Oracle.  All rights reserved.

Connected to: Oracle Database 10g Enterprise Edition Release 10.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
Starting &quot;SYS&quot;.&quot;SYS_EXPORT_TABLE_01&quot;:  '/******** AS SYSDBA' directory=XTTS tables=query.test dumpfile=query_test.dmp logfile=query_test.log 
Estimate in progress using BLOCKS method...
Processing object type TABLE_EXPORT/TABLE/TABLE_DATA
Total estimation using BLOCKS method: 8 MB
Processing object type TABLE_EXPORT/TABLE/TABLE
Processing object type TABLE_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS
. . exported &quot;QUERY&quot;.&quot;TEST&quot;                              6.743 MB   72593 rows
Master table &quot;SYS&quot;.&quot;SYS_EXPORT_TABLE_01&quot; successfully loaded/unloaded
******************************************************************************
Dump file set for SYS.SYS_EXPORT_TABLE_01 is:
  /hxbak/xtts_exp/query_test.dmp
Job &quot;SYS&quot;.&quot;SYS_EXPORT_TABLE_01&quot; successfully completed at 16:03:57

SQL&amp;gt; select * from dba_datapump_jobs;

OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE                       STATE               DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- ------------------------------ --------------- ---------- ----------------- -----------------
SYS        SYS_EXPORT_TABLE_01            EXPORT          TABLE                          EXECUTING                1                 1                 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次导出其他元数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#expdp_xtts.sh (about 5min)
nohup sh expdp_xtts.sh &amp;amp;
#expdp_xtts_other.sh(about 5min)
nohup sh expdp_xtts_other.sh &amp;amp;
#expdp_tmp_table
nohup sh expdp_tmp_table01.sh &amp;amp;
nohup sh expdp_tmp_table02.sh &amp;amp;
nohup sh expdp_tmp_table03.sh &amp;amp;
nohup sh expdp_tmp_table04.sh &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后将这些导出文件再移动到/xtts/dmp/下，供后续xtts测试目标端导入使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ pwd
/hxbak/xtts_exp
$ cp -rp * /xtts/dmp/ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目标端导入时只需要有读这些文件的权限，即可，实际测试恢复OK。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;在自己的linux环境测试过是可以直接expdp到nfs文件系统的，AIX看来有区别，MOS的建议也只是一个workaround，但也能满足需求，毕竟元数据导出文件没多大。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： AIX 6.1 + Oracle 10.2.0.4 现象： 在XTTS迁移测试阶段，遇到执行几个expdp的导出任务，迟迟没有返回任何信息，对应日志无任何输出，查看任务状态： 可以看到所有的e</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9893302.html</dc:identifier>
</item>
<item>
<title>见习三月有感 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9893073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9893073.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/417688/201811/417688-20181101223157905-838326513.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;七月中旬回来到现在已经见习了三个多月，上塔台也就个把月的时间，这段时间就像是一个瓶颈期，目前的状态自己还不够满意，师傅们也不满意。机场管制和程序员是截然不同的两个职业，程序员时间安排非常自由，只要任务按时完成，摸摸鱼很常见。管制员拿着话筒精力就要非常集中，这种集中不是关注一个点，而是关注飞机安全的方方面面，关注天上飞机的间隔、速度，关注地上跑道、航空器的滑行情况，关注天气，关注设备是否正常，以及如何处理接下来要面临的一波高峰，是否已经做好预案，等等。虽然行业相差大，但很多东西也是相通的。&lt;/p&gt;
&lt;h3&gt;心法与剑术&lt;/h3&gt;
&lt;p&gt;自己目前的状态就是发指令口误还比较多，预案做的不好，一些基本的指令还会发错，面对大流量还不能应对自如，甚至有些捉襟见肘。有时候你明明努力过，但结果就是没有到达预期。只能说是努力的还不够，说别的都是苍白。而师傅们觉得我们三个还没有入门，最主要的一点是安全意识不够。比如说着话就忘记了正在落地的飞机，比如给了飞机滑行指令却没有盯着它怎么滑过去的。机长也有走神的时候，可能他一不小心就从中间进了跑道，或者未经允许就进了跑道，这个在我见习的时候就遇到过，如果有飞机正在落地，这将可能造成飞机复飞，后果就比较严重。“安全”，是民航的生命线，安全意识就是每个管制员的心法，你指挥飞机技术再高超，同时能指挥给十几架飞机，但如果安全意识不到位造成严重事件，不单可能对别人的人生财产安全造成很大损失，自己的职业生涯基本上就报销了。现在民航局对人为造成重大差错处罚也比较大，起步就是停职6个月，再加罚款，这个代价是很大的。所以心法第一，剑术第二，没有心法，只练剑术可能会走火入魔。&lt;/p&gt;
&lt;p&gt;而程序员生涯里面很少有人会给你强调这方面，更多的是追求技术的方面提高，效率的提高。诸如像代码整洁，安全生产方面讲的比较少。我想这可能也是犯错成本决定的情况，犯错成本低，出出错无所谓，发布出了问题，再退回，大不了再熬一晚。程序员造bug，改bug是常态。但其实如果强调好心法，降低出错率可能会节省很多时间精力。&lt;/p&gt;
&lt;h3&gt;师徒传承&lt;/h3&gt;
&lt;p&gt; 管制行业是一个很需要经验的行业，天上风云变幻，什么情况都有，经验就是资本，师徒的传承就很重要，新人上去，只会一些基本的指令，一些还是死的知识，非常需要师傅指点，才能慢慢的灵活起来。见习这么久，很感谢每位师傅对我的纠错和培养习惯，虽然有指定的师傅，但每位“前辈”给我的感觉都很好，没有放任不顾，没有揶揄，该说该骂都很直接。其实我比好几位师傅年纪都要大一两岁，但入行早就是前辈。我的指定师傅俗称“炮哥”，是江苏人在张家界干了十几年管制，为人豪爽耿直，喜欢古典文学，对我也苦口婆心的说了很多次了。说实话这个师徒氛围真的很好，让我想起我刚开始做程序员时，那个师傅就丢给我一本书《C#入门经典》，再没怎么管我，期间我曾找他问问题，他说“你这都不会啊”，从此我再也没有问过他问题，就靠看书和自学。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/417688/201811/417688-20181101223433178-1868967892.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员自学门槛低，网上报个班学几个月也能出来写两年工作经验应聘工作，师徒关系比较淡化，彼此还有竞争关系遮遮掩掩的。一方面我觉得作为徒弟自己要感恩，一方面遇到好的师傅确实会让你少走很多弯路。程序虽然可以自学，其实很多行业经验也是很重要的，不懂行业如何写的出行业间应用的好程序，所以我觉得做好师徒传承是对企业有裨益的。对师傅个人而言，如果你觉得分享知识分享经验亏了，建议还是不要带徒弟了，免得误人子弟。作为徒弟要努力做到“青出于蓝而胜于蓝，冰水为之而寒于水”。新人就是做加法，不断的积累，专业知识、行业相关都要积累。曾经有个师傅问我，你知道飞机襟翼有几片，飞机落地构型有几种？我当时有些语塞，感到很惭愧。因为在张家界就发生过飞机襟翼打开有问题的特情。专业知识的积累在关键的时候就能体现一个人的职业素养。&lt;/p&gt;
&lt;h3&gt;职业规划&lt;/h3&gt;
&lt;p&gt; 在一次培训会上一位经理说，大家是想做好一名优秀的管制员呢还是要做推进民航业改革的人才，对自己有什么样的职业规划？这让我陷入了思考，虽然我属于转行过来的，但现在还是很适当前的工作和氛围，未来也很有可能把管制员作为一生的职业，为什么没有更高的目标？眼下是还有很多不足，还苟且着，每天打扫卫生，给师傅带饭，挨训，回头再复习，提醒自己注意，又顾此失彼，如此反复。但未来并不只是眼前一亩三分地，当初带着养家糊口的心态踏进这个行业，现在看来这样的心态是很不对的，这不是一个摸鱼敲钟的位置，要么优秀要么滚蛋，安全面前没有儿戏。总经理也对我说，“人要出彩，只靠基本工作是很难的”，可能我自己六年的程序员是一个点，这方面还要多想想。&lt;/p&gt;
&lt;p&gt;感觉上民航对信息化的推进比较慢，不如高铁系统，一方面旅客候机要检查、等待很长的时间，一方面内部的一些工作其实可以自动化的，很多是完全没有多大意义的重复，可能是在企业和人员的承受压力之内，就没有去做优化。&lt;/p&gt;
&lt;h3&gt;健康&lt;/h3&gt;
&lt;p&gt;管制是一个需要熬夜的岗位，旺季的时候航班一两点结束，早上五点多起来准备六点多的飞机，是比较伤身的。这个比程序员工作熬夜还要频繁，基本上大家都很注意健身，男生尝尝打篮球，游泳，加上上岗之前8小时不准饮酒，大家都比较注意。程序员主要是自己喜欢搞到十二点之后才睡觉，下班之后也很少呼朋引伴的去搞个球，吃饭也是天天外卖。身体是革命的本钱，没有好身体，再好的工作也是枉然。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/417688/201811/417688-20181101223518656-917256586.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;叨了这么多，谢谢观看，诸君有空可以到张家界来玩 ~ ~&lt;/p&gt;

</description>
<pubDate>Thu, 01 Nov 2018 14:37:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<og:description>七月中旬回来到现在已经见习了三个多月，上塔台也就个把月的时间，这段时间就像是一个瓶颈期，目前的状态自己还不够满意，师傅们也不满意。机场管制和程序员是截然不同的两个职业，程序员时间安排非常自由，只要任务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9893073.html</dc:identifier>
</item>
<item>
<title>如果我是一线技术主管 - 谦行</title>
<link>http://www.cnblogs.com/dolphinX/p/9893056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphinX/p/9893056.html</guid>
<description>&lt;p&gt;如果我是一线技术主管，可能曾经是团队综合实力最强的，被时间支配不能再每天写代码，但团队各种挑战依旧在&lt;/p&gt;
&lt;p&gt;如果我是一线技术主管，每周也要写周报，每年也要写绩效，想晋升、加薪、人生巅峰云云&lt;/p&gt;
&lt;p&gt;如果我是一线技术主管，团队有五、六个人还好，十几个人的团队的话会希望有人可以站出来帮我&lt;/p&gt;
&lt;h2 id=&quot;不抱怨&quot;&gt;不抱怨&lt;/h2&gt;
&lt;p&gt;如果我是一线技术主管，我不会喜欢团队爱抱怨的同学&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我每天也很忙，听一个人抱怨会花时间&lt;/li&gt;
&lt;li&gt;一个人抱怨了，自然是有问题的，需要花一定的时间梳理出问题，需要及时给出解决方案，甚至要安抚对方情绪&lt;/li&gt;
&lt;li&gt;一个喜欢抱怨的人会影响整个团队的士气&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实大部分开发抱怨的工作内容很相似，无非是自己做的业务是一堆屎，谁谁谁就是不配合我做某事，PD 提了无理的需求&lt;/p&gt;
&lt;p&gt;大促中我们的后端主管说过句很好理解的话，看到大促这么多问题很激动，这很好，问题越多机会才越大，如果都是稳定健壮的系统、完善的流程、合作良好的团队，要大促 PM 干什么呢？&lt;/p&gt;
&lt;p&gt;如果是机会的话很多情况下没什么必要抱怨，那真的就是有问题还不能说了吗？&lt;/p&gt;
&lt;h2 id=&quot;向上管理&quot;&gt;向上管理&lt;/h2&gt;
&lt;p&gt;恰恰相反，如果我是一线主管，我会迫切希望团队有问题一定要说，甚至没有问题仅仅有想法也要说，但主要是反馈的方式&lt;/p&gt;
&lt;h3 id=&quot;高效&quot;&gt;高效&lt;/h3&gt;
&lt;p&gt;如果我是一线主管，我更希望团队和我交流的方式是让我做选择题、判断题，而不是问答题、思考题&lt;/p&gt;
&lt;h3 id=&quot;主动&quot;&gt;主动&lt;/h3&gt;
&lt;p&gt;一个十几人的团队主管很难有精力面面俱到，了解所有人每天的细节，给大家找出合适方向和机会，甚至认真读完每个人的周报都要用一个下午，很难做到你有一个不错想法的时候主管恰好找你聊聊，如果我是一线主管，我更希望团队同学主动找我聊&lt;/p&gt;
&lt;p&gt;废话这么多，其实看看向上管理的一些理论知识会有豁然开朗的感觉，抄一下知乎上&lt;a href=&quot;https://www.zhihu.com/question/39854128/answer/83504056&quot;&gt;很接地气的总结&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作为领导他们既要有全局决策的能力，杰出的领导魅力，还要有大量一线数据、客户反馈、团队底层真实信息、行业趋势分析与总结。很多点不是他一个人能搞定的，除去那些工作上的support，有时候领导也会出现信息失察、决策失误的情况，所以向上管理的必要性就出现了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;及时定期&lt;/strong&gt;总结工作进展、数据、部门问题、行业关键信息，以清晰文档的方式递交上级，并同时附上下阶段计划及&lt;strong&gt;问题解决办法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;提身而出替上级解决困扰他已久的难题&lt;/li&gt;
&lt;li&gt;对于明显有错的重要决策，给出合理分析建议，反馈给领导&lt;/li&gt;
&lt;li&gt;以培训、分享、个人交流等不同方式，“教”领导一些东西&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;想顺便说一下高质量周报的必要性，很多同学的周报极其敷衍，就是一周的流水账，发送出来都是浪费自己和收件人的时间，团队不会有人&lt;strong&gt;认真&lt;/strong&gt;读完所有人的周报，取决于周报的质量&lt;/p&gt;
&lt;p&gt;个人习惯粗略浏览组内所有人周报（周报有 highlishts 多重要），然后会针对有些人的周报设置规则，必须认真看，遇到不理解的还要过去问，高质量的周报你不主动，主管都会主动&lt;/p&gt;
&lt;h2 id=&quot;每天忙不完的业务怎么办&quot;&gt;每天忙不完的业务怎么办&lt;/h2&gt;
&lt;p&gt;还有一种抱怨的声音是：自己每天很辛苦，想拼命忙完业务后做一些技术的东西，造个轮子什么的，但一个需求还没做完，另外一个需求就安排过来了&lt;/p&gt;
&lt;p&gt;如果我是一线主管，我会把团队面临的问题分一下级&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重要&amp;amp;紧急，不能按时完成都是失败&lt;/li&gt;
&lt;li&gt;重要不紧急，是个很好的机会&lt;/li&gt;
&lt;li&gt;技术想法，很好撬动业务的点&lt;/li&gt;
&lt;li&gt;简单分析只是业务需求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;团队的人可能也有几种特性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;能力强，在某领域是专家&lt;/li&gt;
&lt;li&gt;能力一般，有潜力，但是非常有积极性&lt;/li&gt;
&lt;li&gt;能力一般，主动性一般&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实不用意义说明就知道大部分主管分配任务的思路&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重要&amp;amp;紧急的事情只能交给能力强的认去做，意愿有问题也要说服去做，因人成事，能力强多重要&lt;/li&gt;
&lt;li&gt;重要不紧急的事情就可以借事修人，如果做得好这个人以后就有信心了，团队多了一员干将，做不好也有能力强的人给保底，不会造成业务问题&lt;/li&gt;
&lt;li&gt;技术想法也可以交给有积极性的人做，那么必然占用一些时间，那么这个人手头上无关痛痒的事情只好交给。。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实际上按照向上管理的思路，需要主管去分配任务的时候，就已经输了，甚至主管来找你问进度的时候也已经输了&lt;/p&gt;
&lt;p&gt;当然每个合格的主管都需要发现、解决团队人才培养的问题，不可能放任问题发生&lt;/p&gt;
&lt;h3 id=&quot;什么样的人有积极性&quot;&gt;什么样的人有积极性&lt;/h3&gt;
&lt;p&gt;能力强的人很好识别，那什么样的人才是有积极性的，看过一个 AE 快速升 P8 的同学写的文章，他有个很好的习惯&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;无论大小难易，永远不满足于做出来指定的事情，一定要给人惊喜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我是一线主管，我不会凭空把一件重要的事情就给某个人去做，我会更期望&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;团队同学来教育我某件事情很重要，想去尝试&lt;/li&gt;
&lt;li&gt;在很多微不足道小事情上做出了惊喜，有理由相信这件更大的事情也可能做出惊喜&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;我被分配了纯业务事情怎么办&quot;&gt;我被分配了纯业务事情怎么办&lt;/h3&gt;
&lt;p&gt;上面也提到了&lt;code&gt;简单分析只是业务需求&lt;/code&gt;，简单分析，简单分析，简单分析，在阿里将近五年见了太多事在人为的案例，每个人身边肯定也有不少这样的案例&lt;/p&gt;
&lt;p&gt;我们以为自己在做业务，很多时候是因为两个误区&lt;/p&gt;
&lt;h4 id=&quot;这不是技术项目&quot;&gt;这不是技术项目&lt;/h4&gt;
&lt;p&gt;没有什么所谓的技术项目，所有的技术项目除非显而易见，否则肯定脱胎于业务，只有业务一线的同学才可以抽象出来，做业务需求不是坏事情，拿着完成任务的心态做业务才是最要命的&lt;/p&gt;
&lt;h4 id=&quot;没目标&quot;&gt;没目标&lt;/h4&gt;
&lt;p&gt;所有做的事情都要契合自己的目标，而自己的目标大部分时候应该和团队目标 match，今天让我开发一个前端组件，我要看到的是这个需求反应了我营销体系对某个分类能力的缺失，需求归纳到我营销可视化体系完善的目标中，在阿里这种人才济济的环境中目标不清晰的人和咸鱼没什么区别&lt;/p&gt;
&lt;h3 id=&quot;怎样才算业务负责人&quot;&gt;怎样才算业务负责人&lt;/h3&gt;
&lt;p&gt;很多小伙伴已经是实际的业务负责人，和三、四个小伙伴一块解决特定业务领域问题，但尴尬的是级别相同，在分配任务的时候会不好意思，觉得对方也有自己的&quot;技术项目&quot;要做，我得求他把这个业务需求做一下&lt;/p&gt;
&lt;p&gt;这种其实不算真正的业务负责人，如果业务负责人仅仅是分配任务，那么任何人辛苦一些都可以做。业务负责人的核心特质应该有一条是了解业务的发展、引导相关人个人目标&lt;/p&gt;
&lt;p&gt;这样可以把业务需求转换成每个人目标中的一环，和上面提到的自己做事情思路是一样的，无非写代码的那个人不自己。 其实即使主管也不可能命令团队成员去做某事，那样团队早晚散伙&lt;/p&gt;
&lt;p&gt;如果我是一线技术主管，我希望团队的业务负责人时刻在两个方面提醒自己&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可衡量&lt;/li&gt;
&lt;li&gt;体系化&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 01 Nov 2018 14:31:00 +0000</pubDate>
<dc:creator>谦行</dc:creator>
<og:description>如果我是一线技术主管，可能曾经是团队综合实力最强的，被时间支配不能再每天写代码，但团队各种挑战依旧在 如果我是一线技术主管，每周也要写周报，每年也要写绩效，想晋升、加薪、人生巅峰云云 如果我是一线技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphinX/p/9893056.html</dc:identifier>
</item>
<item>
<title>分布式系统监视zabbix讲解一技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9892708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9892708.html</guid>
<description>
&lt;h3 id=&quot;zabbix是什么&quot; class=&quot;sectionedit1&quot;&gt;Zabbix是什么&lt;/h3&gt;
&lt;p&gt;Zabbix 是由Alexei Vladishev创建，目前由Zabbix SIA在持续开发和支持。&lt;/p&gt;
&lt;p&gt;Zabbix 是一个企业级的分布式开源监控方案。&lt;/p&gt;
&lt;p&gt;Zabbix是一款能够监控各种网络参数以及服务器健康性和完整性的软件。Zabbix使用灵活的通知机制，允许用户为几乎任何事件配置基于邮件的告警。这样可以快速反馈服务器的问题。基于已存储的数据，Zabbix提供了出色的报告和数据可视化功能。这些功能使得Zabbix成为容量规划的理想方案。&lt;/p&gt;
&lt;p&gt;Zabbix支持主动轮询和被动捕获。Zabbix所有的报告、统计信息和配置参数都可以通过基于Web的前端页面进行访问。基于Web的前端页面可以确保您从任何方面评估您的网络状态和服务器的健康性。适当的配置后，Zabbix可以在IT基础架构监控方面扮演重要的角色。对于只有少量服务器的小型组织和拥有大量服务器的大型公司也同样如此。&lt;/p&gt;
&lt;p&gt;Zabbix是免费的。Zabbix是根据GPL通用公共许可证第2版编写和发行的。这意味着它的源代码都是免费发行的，可供公众任意使用。&lt;/p&gt;



&lt;div class=&quot;level4&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;在本节中，你可以了解一些Zabbix常用术语的含义。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;level4&quot; readability=&quot;62&quot;&gt;
&lt;p&gt;&lt;strong&gt;主机 (host)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一台你想监控的网络设备，用IP或域名表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主机组 (host group)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 主机的逻辑组；它包含主机和模板。一个主机组里的主机和模板之间并没有任何直接的关联。通常在给不同用户组的主机分配权限时候使用主机组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控项 (item)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 你想要接收的主机的特定数据，一个度量数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发器 (trigger)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个被用于定义问题阈值和“评估”监控项接收到的数据的逻辑表达式&lt;/p&gt;
&lt;p&gt;当接收到的数据高于阈值时，触发器从“OK”变成“Problem”状态。当接收到的数据低于阈值时，触发器保留/返回一个“OK”的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件 (event)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 单次发生的需要注意的事情，例如触发器状态改变或发现有监控代理自动注册&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常 (problem)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个处在“异常”状态的触发器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动作 (action)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个对事件做出反应的预定义的操作。&lt;/p&gt;
&lt;p&gt;一个动作由操作(例如发出通知)和条件(当时操作正在发生)组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;升级 (escalation)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个在动作内执行操作的自定义场景; 发送通知/执行远程命令的序列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;媒介 (media)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 发送告警通知的手段；告警通知的途径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知 (notification)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 利用已选择的媒体途径把跟事件相关的信息发送给用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程命令 (remote command)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个预定义好的，满足一些条件的情况下，可以在被监控主机上自动执行的命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模版 (template)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一组可以被应用到一个或多个主机上的实体（监控项，触发器，图形，聚合图形，应用，LLD，Web场景）的集合&lt;/p&gt;
&lt;p&gt;模版的任务就是加快对主机监控任务的实施；也可以使监控任务的批量修改更简单。模版是直接关联到每台单独的主机上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用 (application)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一组监控项组成的逻辑分组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web 场景 (web scenario)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 利用一个或多个HTTP请求来检查网站的可用性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端 (frontend)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Zabbix提供的web界面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Zabbix API允许你使用JSON RPC协议来创建、更新和获取Zabbix对象（如主机、监控项、图形和其他）信息或者执行任何其他的自定义的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Zabbix软件实现监控的核心程序，主要功能是与Zabbix proxies和Agents进行交互、触发器计算、发送告警通知；并将数据集中保存等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix agent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个部署在监控对象上的，能够主动监控本地资源和应用的程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix proxy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个帮助Zabbix Server收集数据，分担Zabbix Server的负载的程序&lt;/p&gt;



&lt;h3&gt;1.安装源码库配置部署包&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;安装源码库配置部署包。这个部署包包含了yum配置文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# rpm -ivh http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;安装zabbix部署包&quot; class=&quot;sectionedit6&quot;&gt;2.安装Zabbix部署包&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;安装Zabbix部署包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install zabbix-server-mysql zabbix-web-mysql -y
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.安装Zabbix Agent&lt;/h3&gt;
&lt;p&gt;agent客户端，你想要监控那台服务器就安装这个软件并启动，我这里演示就和服务器端安装在了一起，即服务器端自己监控自己。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install zabbix-agent -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;4.安装初始化数据库&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;77&quot;&gt;
&lt;p&gt;在MySQL上安装Zabbix数据库和用户。在安装完zabbix-server-mysql已经自带了这个压缩包。&lt;/p&gt;
&lt;p&gt;只要解压，然后导入初始架构（Schema）和数据即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# rpm -ql zabbix-server-&lt;span&gt;mysql
&lt;/span&gt;/etc/logrotate.d/zabbix-&lt;span&gt;server
&lt;/span&gt;/etc/zabbix/&lt;span&gt;zabbix_server.conf
&lt;/span&gt;/usr/lib/systemd/system/zabbix-&lt;span&gt;server.service
&lt;/span&gt;/usr/lib/tmpfiles.d/zabbix-&lt;span&gt;server.conf
&lt;/span&gt;/usr/lib/zabbix/&lt;span&gt;alertscripts
&lt;/span&gt;/usr/lib/zabbix/&lt;span&gt;externalscripts
&lt;/span&gt;/usr/sbin/&lt;span&gt;zabbix_server_mysql
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;
/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;AUTHORS
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;COPYING
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;ChangeLog
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;NEWS
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;README
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;create.sql.gz  ##解压这个yasuobao
&lt;/span&gt;/usr/share/man/man8/zabbix_server.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.gz
&lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;zabbix
&lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/run/zabbix
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复制到家目录下，解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cp /usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/create.sql.gz ./&lt;span&gt;
[root@ken &lt;/span&gt;~&lt;span&gt;]# ls
anaconda&lt;/span&gt;-ks.cfg  create.sql.gz  ks-pre.log  original-&lt;span&gt;ks.cfg
[root@ken &lt;/span&gt;~]# gunzip create.sql.gz 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入到数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@localhost:mysql3306.sock [zabbix]&amp;gt;&lt;span&gt;create database zabbix;
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;&lt;span&gt;use zabbix;
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;source /root/&lt;span&gt;create.sql
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;grant all on *.* to zabbix@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified by &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;flush privileges;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5.启动apache服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl restart httpd
[root@ken &lt;/span&gt;~]# ss -tnl | grep &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;         :::&lt;span&gt;80&lt;/span&gt;                      :::*      
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.通过浏览访问zabbix&lt;/h3&gt;
&lt;p&gt;输入ip/zabbix即可访问，访问前务必先关闭selinux以及防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl stop firewalld
[root@ken &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101210803375-274602202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101210853330-1379257722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里报了时区的错误，需要修改一下配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/httpd/conf.d/&lt;span&gt;zabbix.conf
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; # Zabbix monitoring system php web frontend
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
  &lt;span&gt;5&lt;/span&gt; Alias /zabbix /usr/share/&lt;span&gt;zabbix
  &lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
  &lt;span&gt;7&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/share/zabbix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &lt;span&gt;8&lt;/span&gt;&lt;span&gt;     Options FollowSymLinks
  &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;     AllowOverride None
 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;     Require all granted
 &lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
 &lt;span&gt;12&lt;/span&gt;     &amp;lt;IfModule mod_php5.c&amp;gt;
 &lt;span&gt;13&lt;/span&gt;         php_value max_execution_time &lt;span&gt;300&lt;/span&gt;
 &lt;span&gt;14&lt;/span&gt;&lt;span&gt;         php_value memory_limit 128M
 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;         php_value post_max_size 16M
 &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;         php_value upload_max_filesize 2M
 &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         php_value max_input_time &lt;span&gt;300&lt;/span&gt;
 &lt;span&gt;18&lt;/span&gt;         php_value max_input_vars &lt;span&gt;10000&lt;/span&gt;
 &lt;span&gt;19&lt;/span&gt;         php_value always_populate_raw_post_data -&lt;span&gt;1&lt;/span&gt;
 &lt;span&gt;20&lt;/span&gt;         php_value date.timezone Asia/&lt;span&gt;Shanghai   ##时区修改为亚洲/上海
 &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &amp;lt;/IfModule&amp;gt;
 &lt;span&gt;22&lt;/span&gt; &amp;lt;/Directory&amp;gt;
 &lt;span&gt;23&lt;/span&gt; 
 &lt;span&gt;24&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/share/zabbix/conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
 &lt;span&gt;25&lt;/span&gt;&lt;span&gt;     Require all denied
 &lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &amp;lt;/Directory&amp;gt;
 &lt;span&gt;27&lt;/span&gt; 
 &lt;span&gt;28&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/share/zabbix/app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
 &lt;span&gt;29&lt;/span&gt;&lt;span&gt;     Require all denied
...
[root@ken &lt;/span&gt;~]# systemctl restart httpd  ##重启APACHE服务
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101211209515-998591149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认无误之后，点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101211254626-163921706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入刚才创建的数据库zabbix，以及创建的用户zabbix及密码，然后点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101211403364-1168058030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又报了一个无法通过sock文件，连接到数据库的错误。&lt;/p&gt;
&lt;p&gt;这里补充一下造成这个错误的原因主要有如下几点：&lt;/p&gt;
&lt;p&gt;1.防火墙，selinux没有关&lt;/p&gt;
&lt;p&gt;2.配置文件的sock文件没有在/var/lib/mysql/下&lt;/p&gt;
&lt;p&gt;3.对于/var/lib/mysql/，没有权限读取，需要修改为chown -R mysql.mysql /var/lib/mysql&lt;/p&gt;
&lt;p&gt;4.zabbix用户授权错误，是查看是授予的localhost权限还是%权限，即可以在哪个主机上面登录&lt;/p&gt;
&lt;p&gt;5.mysql是否正常启动&lt;/p&gt;
&lt;p&gt;主要会有如上这些错误，大家在平时搭建的时候可以逐一进行排查。&lt;/p&gt;
&lt;p&gt;查看一下我的配置文件，sock文件是在/tmp下需要修改为/var/lib/mysql/mysql.sock.并重新启动mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/&lt;span&gt;my.cnf
#my.cnf
[client]
port            &lt;/span&gt;= &lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
#socket          &lt;/span&gt;= /tmp/&lt;span&gt;mysql3306.sock
socket          &lt;/span&gt;= /&lt;span&gt;var&lt;/span&gt;/lib/mysql/&lt;span&gt;mysql.sock

[mysql]
prompt&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\u@\\h:\\p [\\d]&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#pager&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;less -i -n -S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#tee&lt;/span&gt;=/opt/mysql/&lt;span&gt;query.log
no&lt;/span&gt;-auto-&lt;span&gt;rehash

[mysqld]
#misc
user &lt;/span&gt;=&lt;span&gt; mysql
basedir &lt;/span&gt;= /usr/local/&lt;span&gt;mysql
datadir &lt;/span&gt;= /data/mysql/mysql3306/&lt;span&gt;data
port &lt;/span&gt;= &lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
#socket &lt;/span&gt;= /tmp/&lt;span&gt;mysql3306.sock
socket          &lt;/span&gt;= /&lt;span&gt;var&lt;/span&gt;/lib/mysql/&lt;span&gt;mysql.sock
event_scheduler &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

tmpdir &lt;/span&gt;= /data/mysql/mysql3306/&lt;span&gt;tmp
#timeout
interactive_timeout &lt;/span&gt;= &lt;span&gt;300&lt;/span&gt;&lt;span&gt;
wait_timeout &lt;/span&gt;= &lt;span&gt;300&lt;/span&gt;&lt;span&gt;

#character &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
character&lt;/span&gt;-&lt;span&gt;set&lt;/span&gt;-server = utf8&lt;br/&gt;...&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;[root@ken ~]# mkdir /var/lib/mysql -p&lt;br/&gt;[root@ken ~]# chown -R mysql.mysql /var/lib/mysql&lt;/p&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# pkill msyqld
[root@ken &lt;/span&gt;~]# mysqld &amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] &lt;span&gt;2272&lt;/span&gt;&lt;span&gt;
[root@ken &lt;/span&gt;~]# ss -&lt;span&gt;tnl
State      Recv&lt;/span&gt;-Q Send-&lt;span&gt;Q Local Address:Port               Peer Address:Port              
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;           *:&lt;span&gt;111&lt;/span&gt;                       *:*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;           *:&lt;span&gt;22&lt;/span&gt;                        *:*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;70&lt;/span&gt;           :::&lt;span&gt;3306&lt;/span&gt;                     :::*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;          :::&lt;span&gt;111&lt;/span&gt;                      :::*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;          :::&lt;span&gt;80&lt;/span&gt;                       :::*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;          :::&lt;span&gt;22&lt;/span&gt;                       :::*   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次网站刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212405200-1490740330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212439205-53256992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212507209-919917377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212545614-1793251253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入用户名Admin 密码zabbix&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212647479-688029308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此就已经安装并启动成功了。&lt;/p&gt;



&lt;p&gt;zabbix已经安装完后，现在就可以来启动了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/zabbix/&lt;span&gt;zabbix_server.conf 
&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; # DBUser=
&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; DBUser=&lt;span&gt;zabbix
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;&lt;span&gt; ### Option: DBPassword
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; #       Database password. Ignored &lt;span&gt;for&lt;/span&gt;&lt;span&gt; SQLite.
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; #       Comment &lt;span&gt;this&lt;/span&gt; line &lt;span&gt;if&lt;/span&gt; no password &lt;span&gt;is&lt;/span&gt;&lt;span&gt; used.
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; # DBPassword=
&lt;span&gt;116&lt;/span&gt; DBPassword=&lt;span&gt;123  ##输入你的数据库密码，仅仅修改这一处即可&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;&lt;span&gt; ### Option: DBSocket
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;&lt;span&gt; #       Path to MySQL socket.
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; # DBSocket=/tmp/&lt;span&gt;mysql.sock
..
[root@ken &lt;/span&gt;~]# systemctl restart zabbix-server   ##启动zabbix服务器端
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在在页面查看zabbix启动状态，发现zabbix已经在运行状态了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213003575-219498136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击configuretion--hosts-disabled启动被监控节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213126024-1587336175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行如下命令启动被监控节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart zabbix-agent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213259892-1085302883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次刷新页面之后发现enable后面的ZBX已经变成绿色，表示已经启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213425239-1008045242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击monitoring--latest data--hosts--select选择刚才的hosts即可看到下面监控输出的内容&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 01 Nov 2018 14:26:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>zabbix概述 Zabbix是什么 Zabbix 是由Alexei Vladishev创建，目前由Zabbix SIA在持续开发和支持。 Zabbix 是一个企业级的分布式开源监控方案。 Zabbi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9892708.html</dc:identifier>
</item>
<item>
<title>Lily_music 网页音乐播放器 -可搜索（附歌词联动播放效果解说） - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/9892932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/9892932.html</guid>
<description>&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/59&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/59&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;这是我今年（2018）年初的小项目，当时也是手贱，不想用别的播放器，想着做一个自己的网页播放器，有个歌曲列表、可关键词搜索、歌词滚动播放的效果，于是乎，就做了这一个 Lily_music&lt;/p&gt;
&lt;h3 id=&quot;当时的感慨&quot;&gt;当时的感慨&lt;/h3&gt;
&lt;p&gt;有好几天没有发表博客了，这也是因为一直开发音乐和完善我的博客项目，好不容易抽出时间总结一下这几天所做的东西，还这么多课，实则匆忙&lt;br/&gt;今天难得逃了一次课，就趁这时间，该写写就写写吧~~&lt;/p&gt;
&lt;h2 id=&quot;进入正题lily_music&quot;&gt;进入正题：Lily_music&lt;/h2&gt;
&lt;p&gt;本次开发，参照本人之前所做的 &lt;a href=&quot;https://www.ainyi.com/&quot;&gt;乐诗博客&lt;/a&gt;（文末会说到）的相关播放控制等功能，继续优化的结果&lt;/p&gt;
&lt;p&gt;前端模仿qq音乐界面，然后在此之上进行修改的界面，并使用了一点 es6 的语法&lt;/p&gt;
&lt;p&gt;话说个人挺喜欢qq音乐界面的，简洁，当然也少不了背景模糊插件以及滚动条美化相关插件&lt;/p&gt;
&lt;p&gt;也用到了弹窗、点击复制歌曲链接和歌词链接相关功能，但是目前歌曲分享功能暂未实现、后续....&lt;/p&gt;
&lt;p&gt;==致谢==：歌曲搜索参照某位大佬封装的 qq 音乐的 api，UI 界面参照另一位大神的一些解决方案，在此表示感谢&lt;/p&gt;
&lt;h2 id=&quot;相关插件&quot;&gt;相关插件&lt;/h2&gt;
&lt;p&gt;那么相关使用的开源插件有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;jQuery 官方类库：&lt;a href=&quot;https://jquery.com/&quot; class=&quot;uri&quot;&gt;https://jquery.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;layer 弹窗插件：&lt;a href=&quot;http://layer.layui.com/&quot; class=&quot;uri&quot;&gt;http://layer.layui.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;复制粘贴库插件：&lt;a href=&quot;https://www.npmjs.com/package/clipboard-js&quot; class=&quot;uri&quot;&gt;https://www.npmjs.com/package/clipboard-js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mCustomScrollbar 滚动条美化插件：&lt;a href=&quot;http://manos.malihu.gr/jquery-custom-content-scroller&quot; class=&quot;uri&quot;&gt;http://manos.malihu.gr/jquery-custom-content-scroller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;background-blur 背景图片模糊特效插件：&lt;a href=&quot;https://msurguy.github.io/background-blur&quot; class=&quot;uri&quot;&gt;https://msurguy.github.io/background-blur&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有播放、控制、歌词解析、搜索、加载动画sg类库等功能全部手写，爽的不行&lt;/p&gt;
&lt;h2 id=&quot;温馨提醒&quot;&gt;温馨提醒&lt;/h2&gt;
&lt;p&gt;本播放器并不需要什么特别的运行环境，直接下载打开就能用了 ^_^&lt;/p&gt;
&lt;p&gt;响应式优化，可在各种大小的设备运行打开&lt;/p&gt;
&lt;p&gt;音乐搜索的结果均来自 qq音乐 （后续会继续扩大到多个平台）&lt;/p&gt;
&lt;p&gt;本播放器还有一些 bug，需求就是不断满足的，虚心请教...&lt;/p&gt;
&lt;h2 id=&quot;谈谈开发&quot;&gt;谈谈开发&lt;/h2&gt;
&lt;p&gt;果断使用的是 H5 播放器，十分好用&lt;/p&gt;
&lt;p&gt;一般在做这种播放器的开发，要多多使用面向对象的开发思想&lt;/p&gt;
&lt;p&gt;定义一个播放器对象，相关参数、方法如下：&lt;/p&gt;
&lt;p&gt;播放器对象：krAudio&lt;br/&gt;参数：&lt;br/&gt;　　播放器：audioDom&lt;br/&gt;　　进度条锁定：locked:true&lt;br/&gt;　　进度条按下的锁：kdown&lt;br/&gt;　　静音的锁：flag_volume&lt;br/&gt;　　当前音量：curentVoice&lt;br/&gt;　　当前播放的列表序号：Currentplay&lt;br/&gt;　　当前播放列表歌曲总数：allItem&lt;br/&gt;　　播放模式，1 为列表循环：orderModes&lt;/p&gt;
&lt;p&gt;方法：&lt;br/&gt;　　播放器初始化：init&lt;br/&gt;　　设置播放的音乐地址：seturl&lt;br/&gt;　　播放：play&lt;br/&gt;　　暂停：stop&lt;br/&gt;　　播放时间监听及处理：time&lt;br/&gt;　　时间格式化：format&lt;br/&gt;　　下一首：next&lt;br/&gt;　　上一首：prev&lt;br/&gt;　　播放模式：ordermode&lt;br/&gt;　　拖动进度条：controlTime&lt;br/&gt;　　拖动音量条：controlVoice&lt;/p&gt;
&lt;p&gt;上面部分的参数及方法基本涵盖播放器该有的功能，定义好了整个播放器对象所需要的参数和方法，就可以进行具体开发了&lt;/p&gt;
&lt;h2 id=&quot;歌词联动播放&quot;&gt;歌词联动播放&lt;/h2&gt;
&lt;p&gt;具体谈谈这个功能的实现&lt;/p&gt;
&lt;p&gt;歌词解析，我之前做的==乐诗博客==采用的是自己写的一种歌词解析滚动播放的方法&lt;/p&gt;
&lt;p&gt;首先明白一般歌词的形式是：&lt;br/&gt;[00:13.80]期望飞上恬静月球遥望每家的窗&lt;br/&gt;[00:18.24]谁伴深爱细味露台玫瑰香&lt;/p&gt;
&lt;p&gt;这样子的形式，利用 ajax 异步请求到歌词文件内容，然后就可以进行字符串裁剪，单单取出时间和歌词，html5 播放器可以获取到当前播放时间，就可以实现==当前播放时间==和==当前歌词==一一对应，附上代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;loadLrc :function(){//加载歌词
  var vallrc = $(&quot;.hidetextlrc&quot;).text();
  //如果没有上传歌词或者删除了歌词
  if(!vallrc || $(&quot;.is_deleteLrc&quot;).text() == 1){
    $(&quot;.lrc_content_notext&quot;).text(&quot;暂无歌词&quot;);
    $(&quot;.lrc_content_notext&quot;).show();
    return;
  }
  var isHrefLrc = $(&quot;.is_href_lrc&quot;).text();
  //如果是上传的歌词，那就要拼接上服务器地址
  if(isHrefLrc == 0) vallrc = basePath + &quot;/&quot; + vallrc;
  $.ajax({  //异步请求获取本地歌词
    url:vallrc,
    type:&quot;post&quot;,
    success:function(data){
      //第一次分离歌词
      var lrcArr = data.split(&quot;[&quot;);
      //存放分离后的歌词
      var html = &quot;&quot;;
      var lrclast = null; //记录上一行的歌词
      var lrcmes = null; //记录当前行的歌词
      var bofo = -1; //记录上一行歌词的秒数
      var ms = -1; //当前这一行的秒数
      for(var i = 0;i &amp;lt; lrcArr.length;i++){
        //第二次分割歌词，变成[&quot;03:01.08&quot;,&quot;这个世界变得更加美丽&quot;],数组以逗号分隔
        var arr = lrcArr[i].split(&quot;]&quot;);
        //取到数组arr下标为1的歌词部分
        //将上一行的歌词赋值给lrclast
        lrclast = lrcmes; 
        //得到当前歌词
        lrcmes = arr[1];
       //取到时间
        var time = arr[0].split(&quot;.&quot;); //变成[&quot;03:01&quot;,&quot;08&quot;]
        //取到time下标为0的分钟和秒
        var ctime = time[0].split(&quot;:&quot;); //变成[&quot;03&quot;,&quot;01&quot;];
        //将上一行的秒数赋值给bofo
        bofo = ms;
        //转化成秒数
        ms = ctime[0]*60 + ctime[1]*1;
        //如果上一行和当前行秒数相同，则当前行秒数++ ,解决秒数相同的办法
        if(bofo == ms){
          ms++;
        } else if (ms &amp;gt;= 0){
          if(!isNaN(bofo)){ // 如果是数字
            var classeName = &quot;l_&quot;+bofo;
            var concon = bofo; // bofo会自增，所以下面for循环条件用这个变量来代替
            for(var j = 0;j &amp;lt; ms-concon-1;j++){
              classeName += &quot; l_&quot;+ ++bofo;
            }
            if(ms&amp;gt;=0 &amp;amp;&amp;amp; lrclast != null){
              html += &quot;&amp;lt;li class='&quot;+classeName+&quot;'&amp;gt;&quot;+lrclast+&quot;&amp;lt;/li&amp;gt;&quot;;
            }
          }
        }
      }
      //装载最后一行歌词的机制，先获取歌曲总时间
      setTimeout(function(){
        var allall = krAudio.audioDom.duration;
        var classlaName = &quot;l_&quot;+ms;
        var conben = ms; //ms会自增，所以下面for循环条件必须用这个变量来代替
        for(var j = 0;j &amp;lt; allall-conben-1;j++){
          classlaName += &quot; l_&quot;+ ++ms;
        }
        html += &quot;&amp;lt;li class='&quot;+classlaName+&quot;'&amp;gt;&quot;+lrcmes+&quot;&amp;lt;/li&amp;gt;&quot;;
        //把解析好的歌词放入歌词展示区中
        $(&quot;#lrcly&quot;).html(html);
        $(&quot;#lyrics&quot;).html(html);
      },200);
    }
  });
  // 联动音乐播放歌词
  krAudio.audioDom.addEventListener(&quot;timeupdate&quot;,function(){
    //获取当前播放时间,获得的是秒数
    var time = this.currentTime;
    //解析音乐对应的时间
    var m = parseInt(time / 60);//获取此时的分钟
    var s = parseInt(time); //转换int类型，获取此时的秒数
    $(&quot;.l_&quot;+s).addClass(&quot;lrcsel&quot;).siblings().removeClass(&quot;lrcsel&quot;);
    //歌词滚动条，使歌词在中间的计算公式：
    //第n行歌词*li的高度-歌词区域中间的li（就是包括这个li,取这个li的一半）以上的li的总高度
    //局部歌词的控制
    $(&quot;.lrc_content_box&quot;).stop().animate({
      scrollTop:(($(&quot;.lrcsel&quot;).index()+1)*29 - 145)//减去偏差，使当前歌词在中间
    },240);
    //全屏歌词的控制
    $(&quot;#lyrics&quot;).stop().animate({
      scrollTop:(($(&quot;.lrcsel&quot;).index()+1)*24 - 168)//减去偏差，使当前歌词在中间
    },240);
  });
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种==歌词解析==、==联动播放==的实现是我之前==乐诗博客==采用的一种方案，感觉也不错&lt;/p&gt;
&lt;h3 id=&quot;重点来了&quot;&gt;重点来了&lt;/h3&gt;
&lt;p&gt;此次采用的是另一种歌词解析方式，利用 js 正则表达式全部替换的方式&lt;/p&gt;
&lt;p&gt;替换方式&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var reg = /-/g;  // g表示全部替换 ，要替换的字符串是-
createTime = createTime.replace(reg,&quot;/&quot;); // 第二个参数表示替换成 /
 // 替换成2018/04/03&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;歌词解析&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//解析歌词
function parseLyric(lrc) {
 var lyrics = lrc.split(&quot;\n&quot;);
 var lrcText = {};
 for(var i=0;i&amp;lt;lyrics.length;i++){
   var lyric = decodeURIComponent(lyrics[i]);
   var timeReg = /\[\d*:\d*((\.|\:)\d*)*\]/g;
   var timeRegExpArr = lyric.match(timeReg);
   if(!timeRegExpArr)continue;
   var clause = lyric.replace(timeReg,'');
   for(var k = 0,h = timeRegExpArr.length;k &amp;lt; h;k++) {
     var t = timeRegExpArr[k];
     var min = Number(String(t.match(/\[\d*/i)).slice(1)),
     sec = Number(String(t.match(/\:\d*/i)).slice(1));
     var time = min * 60 + sec;
     lrcText[time] = clause;
   }
 }
 return lrcText;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样子解析出来的是一个对象，存放着键值对&lt;br/&gt;键：==时间（秒）==&lt;br/&gt;值：==歌词==&lt;/p&gt;
&lt;p&gt;就可以直接做一个 for in 循环将每句歌词添加到歌词区域，将时间添加到每句歌词的样式控制 class 名&lt;/p&gt;
&lt;p&gt;根据每句歌词的时间，就可以在播放器的 timeupdate 监听事件里实现滚动播放歌词了（代码上面有）&lt;/p&gt;
&lt;h2 id=&quot;拖动进度条&quot;&gt;拖动进度条&lt;/h2&gt;
&lt;p&gt;鼠标拖动进度条的时候，有三个监听事件&lt;/p&gt;
&lt;p&gt;按下：onmousedown&lt;br/&gt;移动：onmousemove&lt;br/&gt;弹起：onmouseup&lt;/p&gt;
&lt;p&gt;这里鼠标移动事件需要放在鼠标按下事件里面，当鼠标弹起时，在里面清除移动、弹起两个事件，以免弹起时还执行鼠标按下拖动事件（也可以定义一把锁来控制）&lt;/p&gt;
&lt;p&gt;还有很多细节点的问题，上一曲下一曲临界值、搜索后的播放控制、列表小菜单与主按钮之间的联动、三种播放模式（顺序播放、随机播放、单曲循环）等等等等... 有坑也有欢笑&lt;/p&gt;
&lt;h2 id=&quot;截图展示&quot;&gt;截图展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/Lily_music/master/images/cutImg/1.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/Lily_music/master/images/cutImg/2.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/Lily_music/master/images/cutImg/3.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目链接&quot;&gt;项目链接&lt;/h2&gt;
&lt;p&gt;在线演示：&lt;a href=&quot;https://www.ainyi.com/Lily_music&quot;&gt;Lily_music&lt;/a&gt;&lt;br/&gt;GitHub：&lt;a href=&quot;https://github.com/Krryxa/Lily_music&quot; class=&quot;uri&quot;&gt;https://github.com/Krryxa/Lily_music&lt;/a&gt;&lt;br/&gt;欢迎 start&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/59&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/59&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 14:12:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>博客地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/9892932.html</dc:identifier>
</item>
<item>
<title>Django - ORM操作 - JeromeLong</title>
<link>http://www.cnblogs.com/JeromeLong/p/9875171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JeromeLong/p/9875171.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;orm介绍&quot;&gt;ORM介绍&lt;/h3&gt;
&lt;h4 id=&quot;orm的两种方式&quot;&gt;ORM的两种方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;db first    先连接数据库    -&amp;gt; ...
code first  先创建类        -&amp;gt; sqlachemy、Django、大多数都是&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;django-orm&quot;&gt;Django ORM&lt;/h4&gt;
&lt;p&gt;ORM：Object Relational Mapping(关系对象映射)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;类名             -&amp;gt;&amp;gt;   数据库中的表名

类属性           -&amp;gt;&amp;gt;   数据库里的字段

类实例           -&amp;gt;&amp;gt;   数据库表里的一行数据

obj.name.....    -&amp;gt;&amp;gt;   类实例对象的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Django orm的优势：Django的orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句；所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可&lt;/p&gt;
&lt;h4 id=&quot;queryset数据类型介绍&quot;&gt;QuerySet数据类型介绍&lt;/h4&gt;
&lt;p&gt;QuerySet特点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;可迭代的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可切片&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;惰性计算：等于一个生成器，.objects.all()或者.filter()等都只是返回了一个QuerySet的查询结果集对象，它并不会马上执行sql，而是当调用QuerySet的时候才执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;缓存机制：每一次数据库查询结果QuerySet都会对应一块缓存，再次使用该QuerySet时，不会发生新的SQL操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样减小了频繁操作数据库给数据库带来的压力&lt;/p&gt;
&lt;p&gt;但是有时候取出来的数据量太大会撑爆缓存，可以使用迭代器解决这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.Publish.objects.all().iterator()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建orm类&quot;&gt;创建ORM类&lt;/h3&gt;
&lt;h4 id=&quot;在models里创建表的类&quot;&gt;1. 在models里创建表的类&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/app/models.py

from django.db import models
# 表名为app01_userinfo
class UserInfo(models.Model):
    # 自动创建id列，自增，主键
    # 列名，字符串类型，指定长度
    username = models.CharField(max_length=32)
    password = models.CharField(max_length=64)
    email = models.EmailField(max_length=19)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类的字段和参数详见&lt;a href=&quot;http://www.cnblogs.com/JeromeLong/p/9875171.html#类的字段和参数&quot;&gt;字段和参数&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;注册app&quot;&gt;2. 注册APP&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/./settings.py

INSTALLED_APPS = [
    ...,
    'app01',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行命令每次更改表结构都要重复一遍&quot;&gt;3. 执行命令，每次更改表结构都要重复一遍&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py  makemigrations    -&amp;gt;  生成表结构的缓存
python manage.py  migrate           -&amp;gt;  创建表结构&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;默认使用sqlite3数据库可修改为mysql&quot;&gt;4. 默认使用sqlite3数据库，可修改为mysql&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/./settings.py      -&amp;gt;  DATABASES

********** 注意 ***********
Django默认使用MySQLdb模块链接MySQL
主动修改为pymysql，在project同名文件夹下的__init__文件中添加如下代码即可：
    import pymysql
    pymysql.install_as_MySQLdb()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;增删改查&quot;&gt;增删改查&lt;/h3&gt;
&lt;h4 id=&quot;增&quot;&gt;1.增&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/app/views.py
from app01 import models
def orm(request):
    # 直接传入参数
    models.UserInfo.objects.create(username='root',password='123')
    # 传入字典
    dic = {'username': 'eric', 'password': '666'}
    models.UserInfo.objects.create(**dic)
    # 另一种增加方式
    obj = models.UserInfo(username='alex',password='123')
    obj.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查&quot;&gt;2.查&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;result = models.UserInfo.objects.all()
result = models.UserInfo.objects.filter(user='root',psd='123') -&amp;gt; filter传入字典也可 **dic
        =&amp;gt; QuerySet, Django的一种列表, [], 内部元素是.obj =&amp;gt; [obj(id,username),obj]
    
# 转化为字典输出                
    .all().values('id','caption')       -&amp;gt; [{'id:1,'username':'alex'},{},{}]
# 转化为tuple输出            
    .all().values_list('id','caption')  -&amp;gt; [(1,'alex'),(),()]
# 取第一个obj
    .filter(xxx).first()                -&amp;gt; 不存在返回None
            =&amp;gt; 用get取单条数据，如果不存在，直接报错
            =&amp;gt; models.UserInfo.objects.get(id=nid)
# 计数
    .filter(name='seven').count()

# 切片
    .all()[10:20]
    .all()[::2]
    .all()[6]    # 索引

# 去重
    .distinct()

# 排序
    .filter(name='seven').order_by('id')    -&amp;gt;  asc
    .filter(name='seven').order_by('-id')   -&amp;gt;  desc&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删&quot;&gt;3.删&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;models.UserInfo.objects.filter(username=&quot;alex&quot;).delete()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;改&quot;&gt;4.改&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;models.UserInfo.objects.filter(id=3).update(password=&quot;69&quot;)  # 可添加**kwargs形式
# 或者先查找对象再修改保存
    obj = models.tb.objects.get(id=1)
    obj.c1 = '111'
    obj.save()                                              # 修改单条数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;特殊的判断语句神奇的双下划线1&quot;&gt;特殊的判断语句（神奇的双下划线1）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 大于小于
    .filter(id__gt=1)              -&amp;gt;      &amp;gt; 1
    .filter(id=1)                  -&amp;gt;      = 1
    .filter(id__lt=1)              -&amp;gt;      &amp;lt; 1
    .filter(id__lte=1)             -&amp;gt;      &amp;lt;= 1
    .filter(id__gte=1)             -&amp;gt;      &amp;gt;= 1
    .exclude(id__gt=1)             -&amp;gt;      != 1  exclude 除了...与filter相反
    .filter(id__gt=1, id__lt=10)   -&amp;gt;      1&amp;lt; x &amp;lt;10

# 范围range
    .filter(id__range=[1,3])       -&amp;gt;      [1~3]   bettwen + and

# 范围in
    .filter(id__in=[1,2,3])        -&amp;gt;      in [1,2,3]
    .exclude(id__in=[1,2,3])       -&amp;gt;      in [1,2,3]

# 是否为空
    .filter(name__isnull=True)

# 包含、开头、结尾 __startswith, istartswith, endswith, iendswith
    .filter(name__contains=&quot;ven&quot;)
    .filter(name__icontains=&quot;ven&quot;)    # i 忽略大小写

# regex正则匹配，iregex 不区分大小写
    .get(title__regex=r'^(An?|The) +')
    .get(title__iregex=r'^(an?|the) +')

# date
    .filter(pub_date__date=datetime.date(2005, 1, 1))
    .filter(pub_date__date__gt=datetime.date(2005, 1, 1))

# year、month、day、week_day
    .filter(pub_date__year=2005)
    .filter(pub_date__year__gte=2005)

# hour、minute、second
    .filter(timestamp__hour=23)
    .filter(time__hour=5)
    .filter(timestamp__hour__gte=12)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进阶查询&quot;&gt;进阶查询&lt;/h3&gt;
&lt;ul readability=&quot;29.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;F模块，用于获取对象中的某一字段（列）的值，并且对其进行操作；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  from django.db.models import F      # 首先导入F模块
  models.Book.objects.all().update(price=F('price')+1)   # 每一本书的价格上调1块钱&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;Q模块，用于构造复杂的查询条件，使用逻辑关系（&amp;amp;与、|或、~非）组合进行多条件查询；&lt;/p&gt;
&lt;p&gt;虽然filter中可以使用 , 隔开表示关系与，但没法表示或非的关系&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  from django.db.models import Q      # 导入Q模块
  # 方式一：
      .filter( Q(id__gt=10) )                 -&amp;gt; 
      .filter( Q(id=8) | Q(id__gt=10) )       -&amp;gt; or
      .filter( Q( Q(id=8) | Q(id__gt=10) ) &amp;amp; Q(caption='root') )  -&amp;gt; and, or
  # 方式二：
  # 可以组合嵌套
      # q1里面的条件都是or的关系
      q1 = Q()
      q1.connector = 'OR'
      q1.children.append(('id', 1))
      q1.children.append(('id', 10))
      q1.children.append(('id', 9))
      # q2里面的条件都是or的关系
      q2 = Q()
      q2.connector = 'OR'
      q2.children.append(('c1', 1))
      q2.children.append(('c1', 10))
      q2.children.append(('c1', 9))
      # con通过and的条件把q1和q2联系到一块
      con  = Q()
      con.add(q1, 'AND')
      con.add(q2, 'AND')
      models.tb.objects.filter(con)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：查询作者姓名中包含 方/少/伟/3字，书名不包含伟，并且出版社地址以山西开头的书&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  book=models.Book.objects.filter(
                                  Q(
                                      Q(author__name__contains='方') |
                                      Q(author__name__contains='少') |
                                      Q(author__name__contains='伟') |
                                      Q(title__icontains='伟')
                                  ) &amp;amp; 
                                  Q(publish__addr__contains='山西')
                              ).values('title')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：Q查询和非Q查询混合使用，非Q查询一定要放在Q查询后面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;extra方法&lt;/p&gt;
&lt;p&gt;对不同的数据库引擎可能存在移植问题(因为你在显式的书写SQL语句),尽量避免使用extra&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  a.映射
      - select={'new_id':select count(1) from app01_usertype where id&amp;gt;%s'}
      - select_params=[1,]
      # 例：
          models.UserInfo.objects.all().extra(
              select={
                  'n':&quot;select count(1) from app01_utype WHERE id=%s or id=%s&quot;,
                  'm':&quot;select count(1) from app01_uinfo WHERE id=%s or id=%s&quot;,
              },
              select_params=[1,2,3,4]
          )

  b.条件
      - where=[&quot;foo='a' OR bar = 'a'&quot;, &quot;baz = '%s'&quot;],
      - params=['Lennon',]

  c.表
      - tables=[&quot;app01_usertype&quot;]

  d.排序
      - order_by = ['-id']

  # 例1：
      models.UserInfo.objects.extra(
          select={'new_id':select count(1) from app01_usertype where id&amp;gt;%s'},
          select_params=[1,],
          where=['age&amp;gt;%s'],
          params=[18,],
          order_by=['-age'],
          tables=[&quot;app01_usertype']
      )
      -&amp;gt; 相当于:
          '''
          select
              app01_userinfo.id,
              (select count(1) from app01_usertype where id&amp;gt;1) as new_id
          from
              app01_userinfo,
              app01_usertype
          where 
              app01_userinfo.age&amp;gt;18
          order by 
              app01_userinfo.age desc
          '''

  # 例2：
      current_user = models.UserInfo.objects.filter(username=username).first()   # 当前用户

      1、models.Article.objects.all()      # 查出每一篇文章
      2、models.Article.objects.all().filter(user=current_user)  # 查出当前用户的所有文章
      3、models.Article.objects.all().filter(user=current_user).extra(select={&quot;filter_create_date&quot;:&quot;strftime(‘%%Y/%%m‘,create_time)&quot;}).values_list(&quot;filter_create_date&quot;)
          # 查出当前用户的所有文章的create_time，并且只取出年份和月份&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行原生SQL的三种方式&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1.使用extra方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  结果集修改器，一种提供额外查询参数的机制  
  依赖model模型&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.使用raw方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  执行原始sql并返回模型  
  依赖model多用于查询

  book = Book.objects.raw(&quot;select * from hello_book&quot;)
  for item in book:
      print(item.title)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;3.使用cursor游标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  不依赖model

  from django.db import connection, connections
  cursor = connection.cursor()  
  # 或cursor = connections['default'].cursor() 
  # 其中'default'是django数据库配置的default，也可取别的值
  cursor.execute(&quot;&quot;&quot;SELECT * from auth_user where id = %s&quot;&quot;&quot;, [1])
  row = cursor.fetchone()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的字段和参数&quot;&gt;类的字段和参数&lt;/h3&gt;
&lt;h4 id=&quot;字段字符串数字时间二进制&quot;&gt;字段：字符串、数字、时间、二进制&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;AutoField(Field)        -&amp;gt;  自定义自增列（必须加primary_key=True）
IntegerField(Field)     -&amp;gt;  整数列
BooleanField(Field)     -&amp;gt;  布尔
GenericIPAddressField(Field)    -&amp;gt;  IP验证(仅限django admin)
URLField(CharField)     -&amp;gt;  url验证(仅限django admin)
# Django里有很多的字段类型在数据库中都是Char类型，只是用于django admin便于区分&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多详见：&lt;a href=&quot;http://www.cnblogs.com/wupeiqi/articles/5246483.html&quot;&gt;武沛齐的博客 - Django&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;字段的参数&quot;&gt;字段的参数：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;null                -&amp;gt; db中是否可以为空
default=''          -&amp;gt; 默认值
primary_key         -&amp;gt; 是否主键
db_column           -&amp;gt; 列名

db_index            -&amp;gt; 是否可索引
unique              -&amp;gt; 是否可唯一索引
unique_for_date     -&amp;gt; 【日期】部分是否可索引
unique_for_month    -&amp;gt; 【月】部分是否可索引
unique_for_year     -&amp;gt; 【年】部分是否可索引

auto_now_add        -&amp;gt; 创建时，自动生成时间
auto_now            -&amp;gt; 更新时，自动更新为当前时间
        # update方式不生效，先获取再更改才生效
        ctime = models.DateTimeField(auto_now_add=True)
        UserGroup.objects.filter(id=1).update(caption='CEO')    -&amp;gt; 不生效
        obj = UserGroup.objects.filter(id=1).first()
        obj.caption = &quot;CEO&quot;             -&amp;gt; 生效，自动更新更改时间
        obj.save()

# django admin中才生效的字段
blank               -&amp;gt; django admin是否可以为空
verbose_name=''     -&amp;gt; django admin显示字段中文
editable            -&amp;gt; django admin是否可以被编辑
help_text           -&amp;gt; django admin帮助提示
choices=[]          -&amp;gt; django admin中显示下拉框
        # 可避免连表查询，提高效率，一般用于基本不变的选项
        user_type_choices = (
            (1, '超级用户'),
            (2, '普通用户'),
            (3, '普普通用户'),
        )
        user_type_id = models.IntegerField(choices=user_type_choices,default=1)

error_messages      -&amp;gt; 自定义错误信息（字典类型）
        # 字典的键：null, blank, invalid, invalid_choice, unique, unique_for_date
        # 例：error_messages = {'null': &quot;不能为空&quot;, 'invalid': '格式错误'}

validators          -&amp;gt; django form ,自定义错误信息（列表类型）
        # 例：
        from django.core.validators import RegexValidator
        from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\
                MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator
        error_messages={
            'c1': '优先错信息1',
            'c2': '优先错信息2',
            'c3': '优先错信息3',
        },
        validators=[
            RegexValidator(regex='root_\d+', message='错误了', code='c1'),
            RegexValidator(regex='root_112233\d+', message='又错误了', code='c2'),
            EmailValidator(message='又错误了', code='c3'), ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多错误信息的使用方法参考&lt;a href=&quot;http://www.cnblogs.com/wupeiqi/articles/6144178.html&quot;&gt;武沛齐 - FORM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建 Django admin用户：&lt;/strong&gt; &lt;code&gt;python manage.py createsuperuser&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;meta元信息&quot;&gt;Meta元信息&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class UserInfo(models.Model):
    ...
    class Meta:
        # 定义数据库中生成的表名称 默认 app名称 + 下划线 + 类名
        db_table = &quot;table_name&quot;

        # 联合索引
        index_together = [(&quot;pub_date&quot;, &quot;deadline&quot;),]

        # 联合唯一索引,一旦三者都相同，则会被Django拒绝创建。
        可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素
        unique_together = ((&quot;driver&quot;, &quot;restaurant&quot;),)

        # admin后台中显示的表名称
        verbose_name = '用户信息'

        # verbose_name加s，复数形式，不指定自动加s
        verbose_name_plural = 

        # 默认排序
        ordering=['-order_date'] # 按订单降序排列，-表示降序，不加升序，加?表示随机
        ordering=['-pub_date','author'] # 以pub_date为降序，再以author升序排列&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多：&lt;a href=&quot;https://docs.djangoproject.com/en/1.10/ref/models/options/&quot; class=&quot;uri&quot;&gt;https://docs.djangoproject.com/en/1.10/ref/models/options/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;admin拓展知识&quot;&gt;Admin拓展知识&lt;/h4&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;触发Model中的验证和错误提示有两种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; a. Django Admin中的错误信息会优先根据Admin内部的ModelForm错误信息提示，如果都成功，才来检查Model的字段并显示指定错误信息
 b. 调用Model对象的 clean_fields 方法，如：
     # models.py
     class UserInfo(models.Model):
         username = models.CharField(max_length=32)
         email = models.EmailField(error_messages={'invalid': '格式错了.'})

     # views.py
     def index(request):
         obj = models.UserInfo(username='11234', email='uu')
         try:
             print(obj.clean_fields())
         except Exception as e:
             print(e)
         return HttpResponse('ok')

    # Model的clean方法是一个钩子，可用于定制操作，如：上述的异常处理。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;Admin中修改错误提示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # admin.py
 from django.contrib import admin
 from model_club import models
 from django import forms

 class UserInfoForm(forms.ModelForm):
     username = forms.CharField(error_messages={'required': '用户名不能为空.'})
     email = forms.EmailField(error_messages={'invalid': '邮箱格式错误.'})
     age = forms.IntegerField(initial=1, error_messages={'required': '请输入数值.', 'invalid': '年龄必须为数值.'})

     class Meta:
         model = models.UserInfo
         # fields = ('username',)
         fields = &quot;__all__&quot;

 class UserInfoAdmin(admin.ModelAdmin):
     form = UserInfoForm

 admin.site.register(models.UserInfo, UserInfoAdmin)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;orm连表的几种类型&quot;&gt;ORM连表的几种类型&lt;/h3&gt;
&lt;h4 id=&quot;orm一对多&quot;&gt;ORM一对多&lt;/h4&gt;
&lt;p&gt;当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建表结构时关联外键&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  user_group = models.ForeignKey(&quot;UserGroup&quot;,to_field='uid')  -&amp;gt;&amp;gt;   obj(UserGroup)
  # 自动创建user_group_id列，存的是数字（关联主键）&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;添加数据时关联id或对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  方式一：创建数据时添加id关联
      models.UserInfo.object.create(name='root', user_group_id=1)

  方式二：查询obj对象进行关联
      user_group = models.UserGroup.objects.filter(id=1).first()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;一对多自关联&quot;&gt;一对多自关联&lt;/h4&gt;
&lt;p&gt;由原来的2张表，变成一张表！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例：回复评论
class Comment(models.Model):
    news_id = models.IntegerField()                 -&amp;gt; 新闻ID
    content = models.CharField(max_length=32)       -&amp;gt; 评论内容
    user = models.CharField(max_length=32)          -&amp;gt; 评论者
    reply = models.ForeignKey('Comment',null=True,blank=True,related_name='xxxx') -&amp;gt; 回复ID
# 注意：回复的id必须是已经存在的评论的id&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;orm多对多&quot;&gt;ORM多对多&lt;/h4&gt;
&lt;p&gt;在某表中创建一行数据是，有一个可以多选的下拉框&lt;/p&gt;
&lt;h4 id=&quot;多对多自关联&quot;&gt;多对多自关联&lt;/h4&gt;
&lt;p&gt;（由原来的3张表，变成只有2张表）&lt;br/&gt;把两张表通过 choices 字段合并为一张表&lt;br/&gt;使用ManyToManyField字段&lt;/p&gt;
&lt;p&gt;1、查询第三张关系表前面那一列：obj.m&lt;/p&gt;
&lt;p&gt;2、查询第三张关系表后面那一列：obj.userinfo_set&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Userinfo(models.Model):
    sex=((1,'男'),(2,'女'))
    gender=models.IntegerField(choices=sex)
    m=models.ManyToManyField('Userinfo')

# 通过男士查询女生
    boy_obj=models.Userinfo.objects.filter(id=4).first()
    res=boy_obj.m.all()
# 通过女士查询男生
    girl_obj=models.Userinfo.objects.filter(id=4).first()
    res=girl_obj.userinfo_set.all()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;orm一对一&quot;&gt;ORM一对一&lt;/h4&gt;
&lt;p&gt;在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了）&lt;/p&gt;
&lt;p&gt;例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r = models.OneToOneField(...)

# 1. 一对一其实就是 一对多 + 唯一索引
# 2. 当两个类之间有继承关系时，默认会创建一个一对一字段
# 如下会在A表中额外增加一个 c_ptr_id 列且唯一：
    class C(models.Model):
        nid = models.AutoField(primary_key=True)
        part = models.CharField(max_length=12)
    class A(C):
        id = models.AutoField(primary_key=True)
        code = models.CharField(max_length=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;orm连表操作&quot;&gt;ORM连表操作&lt;/h3&gt;
&lt;h4 id=&quot;字段参数&quot;&gt;字段参数&lt;/h4&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;一对多ForeignKey()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  to                          -&amp;gt;  要关联的表名
  to_field='uid',             -&amp;gt;  要关联的字段，不写默认关联主键
  on_delete=None,             -&amp;gt;  删除关联表中的数据时，当前表与其关联的行的行为
      - models.CASCADE        -&amp;gt;  与之关联的也删除
      - models.DO_NOTHING     -&amp;gt;  引发错误IntegrityError
      - models.PROTECT        -&amp;gt;  引发错误ProtectedError
      - models.SET_NULL       -&amp;gt;  与之关联的值设为null（前提FK字段可为空）
      - models.SET_DEFAULT    -&amp;gt;  与之关联的值设为默认值（前提FK字段有默认值）
      - models.SET            -&amp;gt;  与之关联的值设为指定值
              # 有两种指定方法
              a. 设置为指定值：models.SET(值)
              b. 设置为可执行对象的返回值，如：models.SET(func)
                  def func():
                      return 10
                  class MyModel(models.Model):
                      user = models.ForeignKey(...,on_delete=models.SET(func))

  related_name=None,          -&amp;gt;  反向操作时，使用的字段名，用于替换【表名_set】
                                  如： obj.表名_set.all()
  related_query_name=None,    -&amp;gt;  反向操作时，使用的连接前缀，用于替换【表名】
                      如: ...filter(表名__字段名=1).values('表名__字段名')
  limit_choices_to=None,      -&amp;gt;  在Admin或ModelForm中显示关联数据时，提供的条件：
      - limit_choices_to={'nid__gt': 5}
      - limit_choices_to=lambda : {'nid__gt': 5}

      from django.db.models import Q
      - limit_choices_to=Q(nid__gt=10)
      - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
      - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp;amp; Q(caption='root')

  db_constraint=True          -&amp;gt;  是否在数据库中创建外键约束
  parent_link=False           -&amp;gt;  在Admin中是否显示关联数据&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;多对多ManyToManyField()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  symmetrical=None,       -&amp;gt; 仅用于多对多自关联时，指定内部是否创建反向操作的字段
      =&amp;gt; 做如下操作时，不同的symmetrical会有不同的可选字段
          models.BB.objects.filter(...)

      =&amp;gt; 可选字段有：code, id, m1
          class BB(models.Model):
              code = models.CharField(max_length=12)
              m1 = models.ManyToManyField('self',symmetrical=True)

      =&amp;gt; 可选字段有: code, id, m1, bb
          class BB(models.Model):
              code = models.CharField(max_length=12)
              m1 = models.ManyToManyField('self',symmetrical=False)

  through=None,           -&amp;gt; 自定义第三张表时，用于指定关系表
  through_fields=None,    -&amp;gt; 自定义第三张表时，用于指定关系表中哪些字段做多对多关系表

  db_constraint=True,         -&amp;gt; 是否在数据库中创建外键约束
  db_table=None,              -&amp;gt; 默认创建第三张表时，数据库中表的名称&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;一对一OneToOneField()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  to                          -&amp;gt;  要关联的表名
  to_field='uid',             -&amp;gt;  要关联的字段，不写默认关联主键
  on_delete=None,             -&amp;gt;  删除关联表中的数据时，当前表与其关联的行的行为&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;跨表查询神奇的双下划线2&quot;&gt;跨表查询（神奇的双下划线2）&lt;/h4&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;获取值时使用 . 连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  group_obj = models.UserGroup.objects.filter(id=1).first()   # orm连表必须取单个对象
  # 增
  group_obj.user_info.add(1)                -&amp;gt; 添加一个
  group_obj.user_info.add(2,3,4)            -&amp;gt; 添加多个
  group_obj.user_info.add(*[1,2,3,4])       -&amp;gt; 添加*列表
  # 删
  group_obj.user_info.remove(1)
  group_obj.user_info.remove(2,4)
  group_obj.user_info.remove(*[1,2,3])
  group_obj.user_info.clear()           -&amp;gt; 清除当前对象关联的多对多数据
  # 改
  group_obj.user_info.set([3,5,7])      -&amp;gt; （不加*）只保留1-3，1-5，1-7，其它删除
  # 查
  group_obj.user_info.all()             -&amp;gt; 获取所有相关的主机obj 的QuerySet
  group_obj.user_info.filter()
  ......&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;搜索条件使用 __ 连接 (value、value_list、fifter)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  obj = models.UserGroup.objects.filter(id=1).value('name','user_info__name').first()
  在html里也用obj.user_group__name&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;反查&lt;br/&gt;# . 操作，获取对象的QuerySet，表名小写_set&lt;br/&gt;user_info_obj.usergroup_set.add(group_obj)&lt;br/&gt;user_info_obj.usergroup_set.remove(group_obj)&lt;br/&gt;user_info_obj.usergroup_set.all()&lt;br/&gt;user_info_obj.usergroup_set.filter()&lt;br/&gt;......&lt;br/&gt;# __操作，搜索属性，表名小写__属性&lt;br/&gt;obj = models.UserInfo.objects.filter('usergruop__name').first()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;设置反向查找别名&quot;&gt;设置反向查找别名&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;related_query_name      -&amp;gt; 反向查找时用 obj.别名_set.all()，保留了_set
relatedname             -&amp;gt; 反向查找时用 obj.别名.all()  


# 例如：
'''把男女表混合在一起，在代码层面控制第三张关系表的外键关系'''

    # models.py
    class UserInfo(models.Model):
        ...
        sex=((1,'男'),(2,'女'))
        gender=models.IntegerField(choices=sex)
    class U2U(models.Model):
        b=models.ForeignKey(Userinfo,related_name='boy')
        g=models.ForeignKey(Userinfo,related_name='girl')

       # 写到此处问题就来了，原来两个外键 对应2张表 2个主键，可以识别男女
       # 现在两个外键对应1张表，反向查找，无法区分男女了了
       # object对象女.U2U.Userinfo.set  object对象男.U2U.Userinfo.set
       # 所以要加related_name设置反向查找命名 对表中主键加以区分
       # 查找方法
       # 男：obj.a.all()
       # 女：obj.b.all()

    # views.py
    def index(request):
       #查找 ID为1男孩 相关的女孩
       boy_obj=models.UserInfo.objects.filter(id=1).first()
       res = boy_obj.boy.all()   # 得到U2U的对象再正向跨表           
       for obj in res:
           print(obj.girl.name)
       return HttpResponse('OK')&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分组和聚合查询&quot;&gt;分组和聚合查询&lt;/h4&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;aggregate() 聚合函数&lt;/p&gt;
&lt;p&gt;通过对QuerySet进行计算，返回一个聚合值的字典。&lt;br/&gt;aggregate()中每一个参数都指定一个包含在字典中的返回值。即在查询集上生成聚合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; from django.db.models import Avg,Sum,Max,Min

 # 求书籍的平均价
 ret = models.Book.objects.all().aggregate(Avg('price'))
 # {'price__avg': 145.23076923076923}

 # 参与西游记著作的作者中最老的一位作者
 ret = models.Book.objects.filter(title__icontains='西游记').values('author__age').aggregate(Max('author__age'))
 # {'author__age__max': 518}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;annotate() 分组函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 查看每一位作者出过的书中最贵的一本  
 # （按作者名分组 values()，然后 annotate() 分别取每人出过的书价格最高的）
 ret=models.Book.objects.values('author__name').annotate(Max('price'))
 # &amp;lt; QuerySet[
 # {'author__name': '吴承恩', 'price__max': Decimal('234.000')},
 # {'author__name': '吕不韦','price__max': Decimal('234.000')},
 # {'author__name': '姜子牙', 'price__max': Decimal('123.000')},
 # ] &amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;浅谈orm查询性能&quot;&gt;浅谈ORM查询性能&lt;/h3&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;普通跨表查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; obj_list=models.Love.objects.all() 
 for row in obj_list:           # for循环10次发送10次数据库查询请求
     print(row.b.name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理：第一次发送查询请求，每for循环一次也会发送查询请求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;select_related&lt;/p&gt;
&lt;p&gt;结果为对象，query_set类型的对象都有该方法&lt;/p&gt;
&lt;p&gt;原理：select_related查询时主动完成连表形成一张大表，for循环时不用额外发请求&lt;/p&gt;
&lt;p&gt;试用场景：节省硬盘空间，数据量少的时候适用，相当于做了一次数据库查询；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; obj_list=models.Love.objects.all().select_related('b')      # 查询时关联b表
     for row in obj_list:
         print(row.b.name)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;prefetch_related：&lt;/p&gt;
&lt;p&gt;结果为对象&lt;/p&gt;
&lt;p&gt;原理：select_related虽好，但是做连表操作依然会影响查询性能，prefetch_related不做连表，多次单表查询外键表，去重之后显示，2次单表查询（有N个外键做1+N次单表查询）&lt;/p&gt;
&lt;p&gt;适用场景：效率高，数据量大的时候使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; obj_list=models.Love.objects.all().prefetch_related('b')
     for obj in obj_list:
         print(obj.b.name)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;update()和对象.save()修改方式的性能PK&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 方式1
     models.Book.objects.filter(id=1).update(price=3)
     # 执行结果
         (0.000) BEGIN; args=None
         (0.000) UPDATE &quot;app01_book&quot; SET &quot;price&quot; = '3.000' WHERE &quot;app01_book&quot;.&quot;id&quot; = 1; args=('3.000', 1)

 # 方式2
     book_obj=models.Book.objects.get(id=1)
     book_obj.price=5
     book_obj.save()
     # 执行结果
         (0.000) SELECT &quot;app01_book&quot;.&quot;id&quot;, &quot;app01_book&quot;.&quot;title&quot;, &quot;app01_book&quot;.&quot;price&quot;, &quot;app01_book&quot;.&quot;date&quot;, &quot;app01_book&quot;.&quot;publish_id&quot;, &quot;app01_book&quot;.&quot;classify_id&quot; FROM &quot;app01_book&quot; WHERE &quot;app01_book&quot;.&quot;id&quot; = 1; args=(1,)
         (0.000) BEGIN; args=None
         (0.000) UPDATE &quot;app01_book&quot; SET &quot;title&quot; = '我的奋斗', &quot;price&quot; = '5.000', &quot;date&quot; = '1370-09-09', &quot;publish_id&quot; = 4, &quot;classify_id&quot; = 3 WHERE &quot;app01_book&quot;.&quot;id&quot; = 1; args=('我的奋斗', '5.000', '1370-09-09', 4, 3, 1)

 # 结论：
     update() 比 obj.save()性能好&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;django自带contenttype表&quot;&gt;Django自带ContentType表&lt;/h3&gt;
&lt;p&gt;Django程序启动后自带的一张表，记录了Django程序的所有APP下model中的表名和所在app的名称&lt;/p&gt;
&lt;ol readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;通过ContentType中的app名和表名，查找到Django model中所有表；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; from django.contrib.contenttypes.models import ContentType
 def test(request):
     c = ContentType.objects.get(app_label='app01',model='boy')
     print(c)                    -&amp;gt; boy
     print(c.model_class())      -&amp;gt; app01.models.Boy&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;解决 1张表 同时与其他N张表建立外键，并且多个外键中只能选择1个的复杂问题&lt;/p&gt;
&lt;p&gt;场景1：现有N种优惠券，每1种优惠券分别对应N门课程中的一门课程，怎么设计表结构呢？&lt;br/&gt;场景2：学生的学习成绩如何奖惩、 作业如何奖惩、学习进度如何奖惩...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 例：场景1
     from django.db import models
     from django.contrib.contenttypes.models import ContentType
     from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation

     class DegreeCourse(models.Model):
         name = models.CharField(max_length=128, unique=True)
         # GenericRelation 自动连表查询
         xxx = GenericRelation('Coupon')

     class Course(models.Model):
         name = models.CharField(max_length=128, unique=True)

     class Coupon(models.Model):
         &quot;&quot;&quot;优惠券生成规则
             ID     优惠券名称         content_type_id(表)         object_id（表中数据ID）
              1       通用                 null                    null
              2       满100-10               8                      1
              3       满200-30               8                      2
              4       满200-30               9                      1
         &quot;&quot;&quot;
         name = models.CharField(max_length=64, verbose_name=&quot;活动名称&quot;)
         # course_type 代指哪张表 注意该字段必须为 content_type
         content_type = models.ForeignKey(ContentType,blank=True,null=True)
         # 代指对象ID 该字段必须为 object_id
         object_id = models.PositiveIntegerField(blank=True, null=True, help_text=&quot;可以把优惠券跟课程绑定&quot;)
         # GenericForeignKey 通过 content_type 直接创建外键关系，不会生成额外的列
         content_object = GenericForeignKey('content_type','object_id')

 # 给学位课1，创建优惠券100
 # 方式1：
 # 1、在学位课表中 ，找到学位课1
     d1 = models.DegreeCourse.objects.get(id=1)
 # 2、在ContentType找到学位课表
     c1 = ContentType.objects.get(app_label='app01',model='degreecourse')
 # 3、给学位课1，创建优惠券100
     models.Coupon.objects.create(name='优惠券',brief='100',content_type=c1,object_id=d1.id)

 # 方式2：
     d1 = models.DegreeCourse.objects.get(id=1)
     models.Coupon.objects.create(name='优惠券',brief='100',content_object=d1)

 # 查询关联的所有优惠券
     d1 = models.DegreeCourse.objects.get(id=1)
     print(d1.xxx.all())
     v = models.DegreeCourse.objects.values('name','xxx__brief','xxx__name')
     print(v)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;其他小技巧&quot;&gt;其他小技巧&lt;/h3&gt;
&lt;h4 id=&quot;数据库表删除重建&quot;&gt;数据库表删除重建：&lt;/h4&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先到数据库把表删掉：&lt;code&gt;drop table&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注释django中对应的Model&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python manage.py makemigrations   
 python manage.py migrate --fake     -&amp;gt;  只记录变化，不提交数据库操作&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;去掉注释重新迁移&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python manage.py makemigrations   
 python manage.py migrate&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;字典key替换&quot;&gt;字典key替换&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 把value传给新key并同时删除旧key
row['delivery'] = [row.pop('投递')]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取字段名和verbose_name&quot;&gt;获取字段名和verbose_name&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;fields_data = Group._meta.fields
for key in data:
    # 这里是将当前的数据转换成数据字典，方便后面修改后提交
    data_dict = Group.__dict__
    for field in fields_data:
        # 这样或输出这条记录的所有字段名，需要的话还可以输出verbose_name
        print(field.name)
        if field.name == key:
            #进行匹配，将前端传来的字段匹配到，然后修改数据库里面的数据
            data_dict[key] = data[key]
# 保存数据到数据库，这样的好处就是提高效率，避免过多重复操作&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;参考博客&quot;&gt;参考博客&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sss4/p/7070942.html&quot;&gt;ORM详细讲解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wupeiqi/articles/5246483.html&quot;&gt;武沛齐的博客 - Django&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 14:04:00 +0000</pubDate>
<dc:creator>JeromeLong</dc:creator>
<og:description>[TOC] ORM介绍 ORM的两种方式 db first 先连接数据库 ... code first 先创建类 sqlachemy、Django、大多数都是 Django ORM ORM：Objec</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JeromeLong/p/9875171.html</dc:identifier>
</item>
<item>
<title>apk 反编译 - 最新版图文教程 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9892680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9892680.html</guid>
<description>&lt;h3 id=&quot;apk-反编译---最新版图文教程&quot;&gt;apk 反编译 - 最新版图文教程&lt;/h3&gt;
&lt;p&gt;结合网上众多教程，整理一篇自己操作的，工具都是目前最新版 apk 反编译也就是将打包后的 apk 反编译为资源文件(图片)、layout、样式、相关的实现代码等。（注：反编译不是让各位开发者去对一个应用破解搞重装什么的，主要目的是为了促进开发者学习，学习）&lt;/p&gt;
&lt;p&gt;后续也会再整理一篇防止反编译的教程&lt;/p&gt;
&lt;p&gt;转载请注明出处&lt;/p&gt;
&lt;h3 id=&quot;一准备工具&quot;&gt;一、准备工具&lt;/h3&gt;
&lt;p&gt;提示：这些工具在官网都不好下载，偶也是废了好大力气呢，建议直接下载我提供的网盘链接&lt;/p&gt;
&lt;h4 id=&quot;使用工具介绍&quot;&gt;(1) 使用工具介绍：&lt;/h4&gt;
&lt;p&gt; &lt;strong&gt;1.apktool 最新版 jar 包&lt;/strong&gt;&lt;br/&gt;  作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看&lt;br/&gt;  &lt;strong&gt;2.dex2 jar 的zip包&lt;/strong&gt;&lt;br/&gt;  作用：将apk反编译成java源码（classes.dex转化成jar文件）&lt;br/&gt;  &lt;strong&gt;3.jd-gui 工具&lt;/strong&gt;&lt;br/&gt;  作用：查看APK中classes.dex转化成出的jar文件，即源码文件&lt;/p&gt;
&lt;h4 id=&quot;使用工具下载与安装&quot;&gt;(2) 使用工具下载与安装：&lt;/h4&gt;
&lt;p&gt;  &lt;strong&gt;1.apktool_2.3.4 jar 包（2018.10.31 目前最新版）&lt;/strong&gt;&lt;br/&gt;   百度网盘地址：&lt;a href=&quot;https://pan.baidu.com/s/1Vp6PDUc9dfgN0QPtwFp4Zw&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1Vp6PDUc9dfgN0QPtwFp4Zw&lt;/a&gt; 密码：c8n3&lt;br/&gt;   官网下载地址：&lt;a href=&quot;https://bitbucket.org/iBotPeaches/apktool/downloads/&quot; class=&quot;uri&quot;&gt;https://bitbucket.org/iBotPeaches/apktool/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212900787-424863520.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;2.dex2 2.0 jar 包（2018.10.31 目前最新版）&lt;/strong&gt;&lt;br/&gt;   百度网盘地址：&lt;a href=&quot;https://pan.baidu.com/s/1yk5bVAMPYov66u23kxYAJw&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1yk5bVAMPYov66u23kxYAJw&lt;/a&gt; 密码：irxv&lt;br/&gt;   官网下载地址：&lt;a href=&quot;http://sourceforge.net/projects/dex2jar/files/&quot; class=&quot;uri&quot;&gt;http://sourceforge.net/projects/dex2jar/files/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212914656-383424119.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;3.jd-gui 1.4.0（2018.10.31 目前最新版）&lt;/strong&gt;&lt;br/&gt;   百度网盘地址：&lt;a href=&quot;https://pan.baidu.com/s/1ceirRfHzfiqcHFHGxj2fkA&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1ceirRfHzfiqcHFHGxj2fkA&lt;/a&gt; 密码：mx14&lt;br/&gt;   官网下载地址：&lt;a href=&quot;http://jd.benow.ca/&quot; class=&quot;uri&quot;&gt;http://jd.benow.ca/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212927958-1775262773.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二apk-反编译步骤&quot;&gt;二、Apk 反编译步骤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(1) 使用 apktool 反编译 apk 得到图片、XML配置、语言资源等文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.将上述下载好的 3 个工具统一放到一个文件夹中（目录最好不好有中文），并解压 zip 文件，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212941008-561536257.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.打开 cmd/终端，进入上述工具目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212948265-1618542752.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3.运行apktool_2.3.4.jar这个jar文件来将 apk文件进行反编译，在java中，运行可执行jar包的命令是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;java -jar apktool_2.3.4.jar d -f apk文件绝对路径 -o 输出的目录&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt; 使用如下的命令运行apktool_2.0.1.jar反编译MMTS-release-1.0.2.apk&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;java -jar apktool_2.3.4.jar d -f D:\apkDecompile\ocrTest.apk -o source&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个命令是启动 apktool_2.3.4.jar 将位于 D:\apkDecompile\ocrTest.apk 文件执行反编译，然后将反编译生成的文件存放到 apk 文件同级的 source 目录下，截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213013117-549148029.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4.然后就会生成源文件的目录，有开发经验的大概能看出点什么&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213019286-1931168805.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5.重要的有【res】目录和【AndroidManifest.xml】&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213025913-1608018251.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是使用 apktool 这个工具将一个 apk 反编译得到图片、XML配置、语言资源等文件的过程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 使用 dex2jar 反编译 apk 得到 Jar 包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  将要反编译的 APK 后缀名改为 .rar 或者 .zip，并解压，得到其中的classes.dex 文件（它就是java文件编译再通过dx工具打包而成的），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213045374-1509358307.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　将获取到的classes.dex放到之前解压出来的工具【dex2jar-2.0】文件夹内，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213051563-280947961.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在命令行下进入到 dex2jar.bat 所在目录，输入&quot;d2j-dex2jar classes.dex&quot;，截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213058264-1568419686.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令执行完成之后，在当前目录下就可以看到生成的Jar文件了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213106711-714225496.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反编译 classes.dex 得到 classes-dex2jar.jar 文件之后，就可以使用【jd-gui】工具将 class 文件反编译成 java 源代码了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 使用 jd-gui.exe 工具将 class 文件反编译成 java 源代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.打开 jd-gui.exe 程序（不需要安装，之前 zip 包解压即可）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213113412-138495719.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.打开 jar 文件，截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213120260-1814313456.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3.选择 class 文件就可以看到 java 源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213125160-2066442936.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三出错提示&quot;&gt;三、出错提示：&lt;/h3&gt;
&lt;p&gt;如果那不出错了，基本就是工具版本的问题，建议全部下载最新版或者全部使用我提供的版本&lt;/p&gt;
&lt;h3 id=&quot;四更多文章&quot;&gt;四、更多文章：&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;转载请注明出处&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 01 Nov 2018 13:32:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>apk 反编译 最新版图文教程 结合网上众多教程，整理一篇自己操作的，工具都是目前最新版 apk 反编译也就是将打包后的 apk 反编译为资源文件(图片)、layout、样式、相关的实现代码等。（注：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9892680.html</dc:identifier>
</item>
</channel>
</rss>