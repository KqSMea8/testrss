<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>hermite矩阵 - 火山岩上的小红花</title>
<link>http://www.cnblogs.com/duwenlu/p/8878514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duwenlu/p/8878514.html</guid>
<description>&lt;p&gt;在读线代书。因为之前并没有上过线性代数的课。所以决定把基础打牢牢。&lt;/p&gt;
&lt;p&gt;读书的时候当然会出现不懂的概念和术语或者定理什么的。所以在这记录一下啦～～～&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;hermit矩阵&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;要理解它好像先要知道什么是共轭（conjugate）。&lt;/p&gt;
&lt;p&gt;参见百度百科：&lt;a href=&quot;https://baike.baidu.com/item/%E5%85%B1%E8%BD%AD/31802&quot; target=&quot;_blank&quot;&gt;https://baike.baidu.com/item/%E5%85%B1%E8%BD%AD/31802&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 本意：两头牛背上的架子称为轭，轭使两头牛同步行走。共轭即为按一定的规律相配的一对。通俗点说就是孪生。&lt;/p&gt;
&lt;p&gt;共轭关系，通俗来说一般用以描述两件事物以一定规律相互配对或孪生（一般共轭对整体很相似，但在某些特征上却性质相反）&lt;/p&gt;

&lt;p&gt;数学上的共轭：&lt;/p&gt;
&lt;p&gt;共轭复数：实数部分相同而虚数部分互为相反数的两个复数。&lt;/p&gt;
&lt;p&gt;矩阵的共轭转置：把矩阵转置后，再把每一个数换成它的共轭复数。&lt;/p&gt;
&lt;p&gt;自共轭矩阵：矩阵中每一个第i 行第j 列的元素都与第j 行第i 列的元素的共轭相等。&lt;/p&gt;

&lt;p&gt;自共轭矩阵就是hermit矩阵&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:35:00 +0000</pubDate>
<dc:creator>火山岩上的小红花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duwenlu/p/8878514.html</dc:identifier>
</item>
<item>
<title>AutoCAD常用操作命令 - 手握铅笔</title>
<link>http://www.cnblogs.com/kindle/p/8878454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kindle/p/8878454.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近工作需要使用AutoCAD画图，在这里记一下用到的一些常用操作，都是一些很基础的操作，希望对大家有帮助。&lt;/p&gt;
&lt;h3 id=&quot;修剪&quot;&gt;修剪&lt;/h3&gt;
&lt;p&gt;如果两条直线相交，你需要剪掉多余的部分，可以用修剪命令TR。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们先画两条相交的直线。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232145720-275441099.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;输入TR, 空格&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232159993-94909540.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击修剪边，然后空格。记住，不是你想要剪掉的边。这里我们要剪掉的是A的左边的那部分，所以点击直线B&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232213257-991927203.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击你想要剪掉的部分，这里我们点击直线A的左边部分。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232239369-1204769604.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;到这里我们的目的达到了，空格结束&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232249714-895841371.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;待续&quot;&gt;待续&amp;gt;&amp;gt;&amp;gt;&lt;/h3&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:24:00 +0000</pubDate>
<dc:creator>手握铅笔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kindle/p/8878454.html</dc:identifier>
</item>
<item>
<title>201571030319  201571030322  《小学四则运算练习软件需求获取》结对项目报告 - 马绍辉</title>
<link>http://www.cnblogs.com/mashaohui/p/8878380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mashaohui/p/8878380.html</guid>
<description>&lt;p&gt;任务一：&lt;/p&gt;
&lt;p&gt;　　（1）.调研对象：小学生，小学数学代课老师,家长；&lt;/p&gt;
&lt;p&gt;　　（2）.以实验二（），实验三（）开发的程序为软件原型；&lt;/p&gt;
&lt;p&gt;　　（3）.采用问卷调查，访谈两种方式来需求获取；&lt;/p&gt;
&lt;p&gt;　　（4）.和小伙伴设计了网上问卷调查，调查了我们小学的数学代课老师和小学生及其家长；&lt;/p&gt;
&lt;p&gt;　　（5）.调查问卷材料的一些题目：&lt;/p&gt;
&lt;p&gt;2.任务二：&lt;/p&gt;
&lt;p&gt;　　（1）分析建模：&lt;/p&gt;
&lt;p&gt;　　　　&amp;lt;1&amp;gt;实体-联系图:&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346460/201804/1346460-20180418213906085-1560854444.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&amp;lt;2&amp;gt;层次方框图：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1346460/201804/1346460-20180418215019707-1733092582.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;333&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.任务三：&lt;/p&gt;
&lt;p&gt;　　（1）&amp;lt;1&amp;gt; 引言&lt;/p&gt;
&lt;p&gt;　　　　　　为了让小学生能很快的掌握四则混合运算，加强小学生的数学运算能力；同时，提高小学生的学习效率，减轻老师的课业负担。小学四则混合运算就这样产生了。&lt;/p&gt;
&lt;p&gt;　　　　  &amp;lt;2&amp;gt;编写目的&lt;/p&gt;
&lt;p&gt;　　　　　　帮助小学生练习四则混合运算，加强小学生的数学运算能力，为以后的学习打下铺垫。&lt;/p&gt;
&lt;p&gt;　　　　  &amp;lt;3&amp;gt;背景&lt;/p&gt;
&lt;p&gt;　　　　　　完成小学生四则运算的软件的开发。&lt;/p&gt;
&lt;p&gt;　　（2）任务概述&lt;/p&gt;
&lt;p&gt;　　　　 &amp;lt;1&amp;gt;用户特点：用户为小学生，检测用户为数学老师，在设计的过程中，尽量做到实用，效率高等特点。&lt;/p&gt;
&lt;p&gt;　　（3）需求规划；&lt;/p&gt;
&lt;p&gt;　　　　 &amp;lt;1&amp;gt;主要功能&lt;/p&gt;
&lt;p&gt;　　　　　　1）算式引用实验二的代码；&lt;/p&gt;
&lt;p&gt;　　               2）生成的题库显示在QuestionBank.docx 中；并随机产生20道算式；&lt;/p&gt;
&lt;p&gt;　　               3）调用包JfreeChart-1.0.13包；来生成柱状图；&lt;/p&gt;
&lt;p&gt;　              　4）倒计时用Thread.sleep和循环来完成；&lt;/p&gt;
&lt;p&gt;　　               5）多轮测试弹出框用JOptionPane类来完成；&lt;/p&gt;
&lt;p&gt;　　　　 &amp;lt;2&amp;gt;功能描述（概要）&lt;/p&gt;
&lt;p&gt;　　　　　　1）20道测试题结束给出总&lt;/p&gt;
&lt;p&gt;　　　　　　2）带括号算式，真分数算式；&lt;/p&gt;
&lt;p&gt;　　　　　　3）程序允许用户进行多轮测试，给出多轮测试分数柱状图；&lt;/p&gt;
&lt;p&gt;　　　　　　4）程序记录用户答题结果，当程序退出再启动的时候，可为用户显示最后一次结果，并询问用户可否进行新一轮测试&lt;/p&gt;
&lt;p&gt;　　（4）运行环境规定&lt;/p&gt;
&lt;p&gt;　　　　&amp;lt;1&amp;gt;设备&lt;/p&gt;
&lt;p&gt;　　　　        一台pc机&lt;/p&gt;
&lt;p&gt;　　　　&amp;lt;2&amp;gt;开发环境&lt;/p&gt;
&lt;p&gt;　　　　　　采用java面向对象编程语言，完成小学四则混合运算；&lt;/p&gt;
&lt;p&gt;　　（5）验收标准&lt;/p&gt;
&lt;p&gt;　　　　在实验最后，看完成的功能是否齐全，系统是否稳定，小学生实用的过程中是否简便，得心用手。答案是否准确，得到的柱状图是否准确。&lt;/p&gt;
&lt;p&gt;用户是否满意等方面来验收。&lt;/p&gt;


&lt;p&gt;总结：通过此次的用户需求调查分析，明白了自己软件的所存在的各种问题，同时也找到了解决方案，最重要的是真正认识到了用户需求的重要性，而且能从用户需求中准确提炼出信息 对所要设计的软件进行更加全面的分析。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:17:00 +0000</pubDate>
<dc:creator>马绍辉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mashaohui/p/8878380.html</dc:identifier>
</item>
<item>
<title>音频压缩编码 opus 附完整C++代码示例 - 落羽の殇</title>
<link>http://www.cnblogs.com/tntmonks/p/8878392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tntmonks/p/8878392.html</guid>
<description>&lt;p&gt;绝大数人都知道mp3格式编码，以及aac,amr等压缩格式编码。&lt;/p&gt;
&lt;p&gt;而在语音通信界有一个强悍的音频格式编码opus.&lt;/p&gt;
&lt;p&gt;经过实测，压缩比最高可以达到1:10。&lt;/p&gt;
&lt;p&gt;100KB 压缩后 10KB&lt;/p&gt;
&lt;p&gt;虽然是有损压缩，&lt;/p&gt;
&lt;p&gt;但是根据实际对比试听，&lt;/p&gt;
&lt;p&gt;几乎听不出差别。&lt;/p&gt;
&lt;p&gt;而且还原度还比mp3高，压缩比也比mp3高。&lt;/p&gt;
&lt;p&gt;用来压缩传输音频，绝对是一大杀器。&lt;/p&gt;

&lt;p&gt;项目官方地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://opus-codec.org/&quot; target=&quot;_blank&quot;&gt;https://opus-codec.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Opus_(%E9%9F%B3%E9%A2%91)&quot; target=&quot;_blank&quot;&gt;维基&lt;/a&gt;上的描述:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Opus&lt;/strong&gt;是一个&lt;a class=&quot;mw-redirect&quot; title=&quot;破坏性数据压缩&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%A0%B4%E5%A3%9E%E6%80%A7%E8%B3%87%E6%96%99%E5%A3%93%E7%B8%AE#%E9%9F%B3%E8%A8%8A%E5%A3%93%E7%B8%AE&quot;&gt;有损声音编码&lt;/a&gt;的格式，由&lt;a title=&quot;Xiph.Org基金会&quot; href=&quot;https://zh.wikipedia.org/wiki/Xiph.Org%E5%9F%BA%E9%87%91%E6%9C%83&quot;&gt;Xiph.Org基金会&lt;/a&gt;开发，之后由&lt;a title=&quot;互联网工程任务组&quot; href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84&quot;&gt;互联网工程任务组&lt;/a&gt;（IETF）进行标准化，目标用希望用单一格式包含声音和语音，取代&lt;a title=&quot;Speex&quot; href=&quot;https://zh.wikipedia.org/wiki/Speex&quot;&gt;Speex&lt;/a&gt;和&lt;a title=&quot;Vorbis&quot; href=&quot;https://zh.wikipedia.org/wiki/Vorbis&quot;&gt;Vorbis&lt;/a&gt;，且适用于网络上低延迟的即时声音传输，标准格式定义于&lt;a title=&quot;RFC&quot; href=&quot;https://zh.wikipedia.org/wiki/RFC&quot;&gt;RFC&lt;/a&gt; 6716文件。Opus格式是一个&lt;a class=&quot;mw-redirect&quot; title=&quot;开放格式&quot; href=&quot;https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E6%A0%BC%E5%BC%8F&quot;&gt;开放格式&lt;/a&gt;，使用上没有任何&lt;a class=&quot;mw-redirect&quot; title=&quot;专利&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%B0%88%E5%88%A9&quot;&gt;专利&lt;/a&gt;或限制。&lt;/p&gt;
&lt;p&gt;Opus集成了两种声音编码的技术：以语音编码为导向的&lt;a class=&quot;mw-disambig&quot; title=&quot;SILK&quot; href=&quot;https://zh.wikipedia.org/wiki/SILK&quot;&gt;SILK&lt;/a&gt;和低延迟的&lt;a class=&quot;new&quot; title=&quot;CELT（页面不存在）&quot; href=&quot;https://zh.wikipedia.org/w/index.php?title=CELT&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;CELT&lt;/a&gt;。Opus可以无缝调节高低&lt;a title=&quot;比特率&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E7%8E%87&quot;&gt;比特率&lt;/a&gt;。在编码器内部它在较低比特率时使用&lt;a title=&quot;线性预测编码&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E9%A2%84%E6%B5%8B%E7%BC%96%E7%A0%81&quot;&gt;线性预测编码&lt;/a&gt;在高比特率时候使用&lt;a title=&quot;变换编码&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%BC%96%E7%A0%81&quot;&gt;变换编码&lt;/a&gt;（在高低比特率交界处也使用两者结合的编码方式）。Opus具有非常低的算法延迟（默认为22.5 ms），非常适合用于低延迟语音通话的编码，像是网络上的即时声音流、即时同步声音旁白等等，此外Opus也可以通过降低编码比特率，达成更低的算法延迟，最低可以到5 ms。在多个听觉盲测中，Opus都比&lt;a title=&quot;MP3&quot; href=&quot;https://zh.wikipedia.org/wiki/MP3&quot;&gt;MP3&lt;/a&gt;、&lt;a class=&quot;mw-redirect&quot; title=&quot;AAC&quot; href=&quot;https://zh.wikipedia.org/wiki/AAC&quot;&gt;AAC&lt;/a&gt;、&lt;a title=&quot;HE-AAC&quot; href=&quot;https://zh.wikipedia.org/wiki/HE-AAC&quot;&gt;HE-AAC&lt;/a&gt;等常见格式，有更低的延迟和更好的声音压缩率。&lt;/p&gt;

&lt;p&gt;更重要的是要看这条：&lt;/p&gt;
&lt;p&gt;Opus被提出用于在IETF上标准化新的音频格式，最终被IETF编解码器工作组接受和授予。它基于Xiph.Org基金会和&lt;a title=&quot;Skype&quot; href=&quot;https://zh.wikipedia.org/wiki/Skype&quot;&gt;Skype&lt;/a&gt;技术公司两项最初分开的标准提案。其主要开发人员包括Jean-Marc Valin（Xiph.Org，Octasic，Mozilla Corporation），Koen Vos（Skype）和Timothy B. Terriberry（Xiph.Org，Mozilla Corporation）。其中包括Juin-Hwey（Raymond）Chen（Broadcom），Gregory Maxwell（Xiph.Org，Wikimedia）和Christopher Montgomery（Xiph.Org）也参与其中。&lt;/p&gt;

&lt;p&gt;这个项目被几大公司加持，也难怪能有如此出色的压缩比。&lt;/p&gt;

&lt;p&gt;由于是纯C代码，比较好理解。&lt;/p&gt;
&lt;p&gt;抽了点空，俺写个wav压缩解压的示例代码，&lt;/p&gt;
&lt;p&gt;分享出来，权当抛砖引玉。&lt;/p&gt;
&lt;p&gt;示例代码位置：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/opus/blob/master/example/opus.cpp&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/opus/blob/master/example/opus.cpp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;贴上完整C++代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;161&quot;&gt;
&lt;pre&gt;
#include &amp;lt;opus_types.h&amp;gt;&lt;span&gt;
#include  &lt;/span&gt;&amp;lt;opus.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;memory&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;vector&amp;gt;
&lt;span&gt;//&lt;/span&gt; &lt;span&gt;https://github.com/mackron/dr_libs/blob/master/dr_wav.h&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; DR_WAV_IMPLEMENTATION&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dr_wav.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; FRAME_SIZE 480
&lt;span&gt;#define&lt;/span&gt; MAX_FRAME_SIZE (6*FRAME_SIZE)

&lt;span&gt;#define&lt;/span&gt; MAX_CHANNELS 1
&lt;span&gt;#define&lt;/span&gt; MAX_PACKET_SIZE (3*1276)

&lt;span&gt;#pragma&lt;/span&gt; pack(push)
&lt;span&gt;#pragma&lt;/span&gt; pack(1)

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; WavInfo {
    uint16_t channels;
    uint32_t sampleRate;
    uint32_t bitsPerSample;
};

&lt;/span&gt;&lt;span&gt;#pragma&lt;/span&gt; pack(pop)&lt;span&gt;

#ifndef  nullptr
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt;  nullptr NULL
&lt;span&gt;#endif&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileStream {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    FileStream() {
        cur_pos &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Append(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;data, size_t size) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cur_pos + size &amp;gt;&lt;span&gt; Size()) {
            vec.resize(cur_pos &lt;/span&gt;+&lt;span&gt; size);
        }
        memcpy(vec.data() &lt;/span&gt;+&lt;span&gt; cur_pos, data, size);
        cur_pos &lt;/span&gt;+=&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; AppendU32(uint32_t val) {
        Append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *) (&amp;amp;val), &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(val));
    }

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;Data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vec.data();
    }

    size_t Size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vec.size();
    }

    size_t Read(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;buff, size_t elemSize, size_t elemCount) {
        size_t readed &lt;/span&gt;= std::min((vec.size() - cur_pos), (elemCount * elemSize)) /&lt;span&gt; elemSize;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (readed &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            memcpy(buff, vec.data() &lt;/span&gt;+ cur_pos, readed *&lt;span&gt; elemSize);
            cur_pos &lt;/span&gt;+= readed *&lt;span&gt; elemSize;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; readed;
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; SeekCur(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; offset) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cur_pos + offset &amp;gt;&lt;span&gt; vec.size()) {
            cur_pos &lt;/span&gt;= !vec.empty() ? (vec.size() - &lt;span&gt;1&lt;/span&gt;) : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            cur_pos &lt;/span&gt;+=&lt;span&gt; offset;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; SeekBeg(&lt;span&gt;int&lt;/span&gt; offset = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        cur_pos &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SeekCur(offset);
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; WriteToFile(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename) {
        FILE &lt;/span&gt;*fin = fopen(filename, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fin) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        fseek(fin, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SEEK_SET);
        fwrite(vec.data(), &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;), vec.size(), fin);
        fclose(fin);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ReadFromFile(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename) {
        FILE &lt;/span&gt;*fin = fopen(filename, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fin) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        fseek(fin, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SEEK_END);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; fileSize =&lt;span&gt; ftell(fin);
        vec.resize(static_cast&lt;/span&gt;&amp;lt;unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(fileSize));
        fseek(fin, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SEEK_SET);
        fread(vec.data(), &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;), vec.size(), fin);
        fclose(fin);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    std::vector&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt; vec;
    size_t cur_pos;
};

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Wav2Opus(FileStream *input, FileStream *&lt;span&gt;output);

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Opus2Wav(FileStream *input, FileStream *&lt;span&gt;output);

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; wav2stream(&lt;span&gt;char&lt;/span&gt; *input, FileStream *&lt;span&gt;output);

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; stream2wav(FileStream *input, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;output);


&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; wavWrite_int16(&lt;span&gt;char&lt;/span&gt; *filename, int16_t *buffer, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sampleRate, uint32_t totalSampleCount) {
    drwav_data_format format &lt;/span&gt;=&lt;span&gt; {};
    format.container &lt;/span&gt;= drwav_container_riff;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;-- drwav_container_riff = normal WAV files, drwav_container_w64 = Sony Wave64.&lt;/span&gt;
    format.format = DR_WAVE_FORMAT_PCM;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;-- Any of the DR_WAVE_FORMAT_* codes.&lt;/span&gt;
    format.channels = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    format.sampleRate &lt;/span&gt;=&lt;span&gt; (drwav_uint32) sampleRate;
    format.bitsPerSample &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
    drwav &lt;/span&gt;*pWav = drwav_open_file_write(filename, &amp;amp;&lt;span&gt;format);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pWav) {
        drwav_uint64 samplesWritten &lt;/span&gt;=&lt;span&gt; drwav_write(pWav, totalSampleCount, buffer);
        drwav_uninit(pWav);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (samplesWritten !=&lt;span&gt; totalSampleCount) {
            fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

int16_t &lt;/span&gt;*wavRead_int16(&lt;span&gt;char&lt;/span&gt; *filename, uint32_t *sampleRate, uint64_t *&lt;span&gt;totalSampleCount) {
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; channels;
    int16_t &lt;/span&gt;*buffer = drwav_open_and_read_file_s16(filename, &amp;amp;&lt;span&gt;channels, sampleRate, totalSampleCount);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (buffer ==&lt;span&gt; nullptr) {
        fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channels != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        drwav_free(buffer);
        buffer &lt;/span&gt;=&lt;span&gt; nullptr;
        &lt;/span&gt;*sampleRate = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;*totalSampleCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; buffer;
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; wav2stream(&lt;span&gt;char&lt;/span&gt; *input, FileStream *&lt;span&gt;output) {
    uint32_t sampleRate &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    uint64_t totalSampleCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    int16_t &lt;/span&gt;*wavBuffer = wavRead_int16(input, &amp;amp;sampleRate, &amp;amp;&lt;span&gt;totalSampleCount);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wavBuffer == nullptr) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    WavInfo info &lt;/span&gt;=&lt;span&gt; {};
    info.bitsPerSample &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
    info.sampleRate &lt;/span&gt;=&lt;span&gt; sampleRate;
    info.channels &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    output&lt;/span&gt;-&amp;gt;&lt;span&gt;SeekBeg();
    output&lt;/span&gt;-&amp;gt;Append((&lt;span&gt;char&lt;/span&gt; *) &amp;amp;info, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(info));
    output&lt;/span&gt;-&amp;gt;Append((&lt;span&gt;char&lt;/span&gt; *) wavBuffer, totalSampleCount * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(int16_t));
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(wavBuffer);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; stream2wav(FileStream *input, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;output) {
    WavInfo info &lt;/span&gt;=&lt;span&gt; {};
    input&lt;/span&gt;-&amp;gt;&lt;span&gt;SeekBeg();
    size_t read &lt;/span&gt;= input-&amp;gt;Read(&amp;amp;info, &lt;span&gt;sizeof&lt;/span&gt;(info), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    size_t totalSampleCount &lt;/span&gt;= (input-&amp;gt;Size() - &lt;span&gt;sizeof&lt;/span&gt;(info)) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; wavWrite_int16(output, (int16_t *) (input-&amp;gt;Data() + &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(info)), info.sampleRate,
                          static_cast&lt;/span&gt;&amp;lt;uint32_t&amp;gt;&lt;span&gt;(totalSampleCount));
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Wav2Opus(FileStream *input, FileStream *&lt;span&gt;output) {
    WavInfo in_info &lt;/span&gt;=&lt;span&gt; {};
    input&lt;/span&gt;-&amp;gt;&lt;span&gt;SeekBeg();
    size_t read &lt;/span&gt;= input-&amp;gt;Read(&amp;amp;in_info, &lt;span&gt;sizeof&lt;/span&gt;(in_info), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    uint32_t bitsPerSample &lt;/span&gt;=&lt;span&gt; in_info.bitsPerSample;
    uint32_t sampleRate &lt;/span&gt;=&lt;span&gt; in_info.sampleRate;
    uint16_t channels &lt;/span&gt;=&lt;span&gt; in_info.channels;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channels &amp;gt;&lt;span&gt; MAX_CHANNELS) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    OpusEncoder &lt;/span&gt;*encoder = opus_encoder_create(sampleRate, channels, OPUS_APPLICATION_AUDIO, &amp;amp;&lt;span&gt;err);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!encoder || err &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;failed to create an encoder: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, opus_strerror(err));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;encoder) {
            opus_encoder_destroy(encoder);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t *data = (uint16_t *) (input-&amp;gt;Data() + &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(in_info));
    size_t size &lt;/span&gt;= (input-&amp;gt;Size() - &lt;span&gt;sizeof&lt;/span&gt;(in_info)) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    opus_int16 pcm_bytes[FRAME_SIZE &lt;/span&gt;*&lt;span&gt; MAX_CHANNELS];
    size_t index &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    size_t step &lt;/span&gt;= static_cast&amp;lt;size_t&amp;gt;(FRAME_SIZE *&lt;span&gt; channels);
    FileStream encodedData;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; cbits[MAX_PACKET_SIZE];
    size_t frameCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    size_t readCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (index &amp;lt;&lt;span&gt; size) {
        memset(&lt;/span&gt;&amp;amp;pcm_bytes, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(pcm_bytes));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index + step &amp;lt;=&lt;span&gt; size) {
            memcpy(pcm_bytes, data &lt;/span&gt;+ index, step * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(uint16_t));
            index &lt;/span&gt;+=&lt;span&gt; step;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            readCount &lt;/span&gt;= size -&lt;span&gt; index;
            memcpy(pcm_bytes, data &lt;/span&gt;+ index, (readCount) * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(uint16_t));
            index &lt;/span&gt;+=&lt;span&gt; readCount;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nbBytes = opus_encode(encoder, pcm_bytes, channels *&lt;span&gt; FRAME_SIZE, cbits, MAX_PACKET_SIZE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nbBytes &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;encode failed: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, opus_strerror(nbBytes));
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;++&lt;span&gt;frameCount;
        encodedData.AppendU32(static_cast&lt;/span&gt;&amp;lt;uint32_t&amp;gt;&lt;span&gt;(nbBytes));
        encodedData.Append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *) cbits, static_cast&amp;lt;size_t&amp;gt;&lt;span&gt;(nbBytes));
    }
    WavInfo info &lt;/span&gt;=&lt;span&gt; {};
    info.bitsPerSample &lt;/span&gt;=&lt;span&gt; bitsPerSample;
    info.sampleRate &lt;/span&gt;=&lt;span&gt; sampleRate;
    info.channels &lt;/span&gt;=&lt;span&gt; channels;
    output&lt;/span&gt;-&amp;gt;&lt;span&gt;SeekBeg();
    output&lt;/span&gt;-&amp;gt;Append((&lt;span&gt;char&lt;/span&gt; *) &amp;amp;info, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(info));
    output&lt;/span&gt;-&amp;gt;&lt;span&gt;Append(encodedData.Data(), encodedData.Size());
    opus_encoder_destroy(encoder);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Opus2Wav(FileStream *input, FileStream *&lt;span&gt;output) {
    WavInfo info &lt;/span&gt;=&lt;span&gt; {};
    input&lt;/span&gt;-&amp;gt;&lt;span&gt;SeekBeg();
    size_t read &lt;/span&gt;= input-&amp;gt;Read(&amp;amp;info, &lt;span&gt;sizeof&lt;/span&gt;(info), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (read != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; channels =&lt;span&gt; info.channels;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channels &amp;gt;&lt;span&gt; MAX_CHANNELS) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    output&lt;/span&gt;-&amp;gt;&lt;span&gt;SeekBeg();
    output&lt;/span&gt;-&amp;gt;Append((&lt;span&gt;char&lt;/span&gt; *) &amp;amp;info, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(info));
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    OpusDecoder &lt;/span&gt;*decoder = opus_decoder_create(info.sampleRate, channels, &amp;amp;&lt;span&gt;err);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!decoder || err &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;failed to create decoder: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, opus_strerror(err));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;decoder) {
            opus_decoder_destroy(decoder);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; cbits[MAX_PACKET_SIZE];
    opus_int16 &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;[MAX_FRAME_SIZE *&lt;span&gt; MAX_CHANNELS];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; frameCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
        uint32_t nbBytes;
        size_t readed &lt;/span&gt;= input-&amp;gt;Read(&amp;amp;nbBytes, &lt;span&gt;sizeof&lt;/span&gt;(uint32_t), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (readed == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nbBytes &amp;gt; &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cbits)) {
            fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nbBytes &amp;gt; sizeof(cbits)\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        readed &lt;/span&gt;= input-&amp;gt;Read(cbits, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;), nbBytes);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (readed !=&lt;span&gt; nbBytes) {
            fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;readed != nbBytes\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; frame_size = opus_decode(decoder, cbits, nbBytes, &lt;span&gt;out&lt;/span&gt;, MAX_FRAME_SIZE, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (frame_size &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            fprintf(stderr, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decoder failed: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, opus_strerror(frame_size));
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;++&lt;span&gt;frameCount;
        output&lt;/span&gt;-&amp;gt;Append((&lt;span&gt;char&lt;/span&gt; *) &lt;span&gt;out&lt;/span&gt;, channels * frame_size * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
    }
    opus_decoder_destroy(decoder);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; splitpath(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *path, &lt;span&gt;char&lt;/span&gt; *drv, &lt;span&gt;char&lt;/span&gt; *dir, &lt;span&gt;char&lt;/span&gt; *name, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;ext) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;end;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;s;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (path[&lt;span&gt;0&lt;/span&gt;] &amp;amp;&amp;amp; path[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (drv) {
            &lt;/span&gt;*drv++ = *path++&lt;span&gt;;
            &lt;/span&gt;*drv++ = *path++&lt;span&gt;;
            &lt;/span&gt;*drv = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (drv)
        &lt;/span&gt;*drv = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (end = path; *end &amp;amp;&amp;amp; *end != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;)
        end&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (p = end; p &amp;gt; path &amp;amp;&amp;amp; *--p != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; *p != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*p == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
            end &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ext)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (s = end; (*ext = *s++&lt;span&gt;);)
            ext&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (p = end; p &amp;gt;&lt;span&gt; path;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*--p == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; || *p == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
            p&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (name) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (s = p; s &amp;lt;&lt;span&gt; end;)
            &lt;/span&gt;*name++ = *s++&lt;span&gt;;
        &lt;/span&gt;*name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dir) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (s = path; s &amp;lt;&lt;span&gt; p;)
            &lt;/span&gt;*dir++ = *s++&lt;span&gt;;
        &lt;/span&gt;*dir = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; opus2wav(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *in_file, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;out_file) {
    FileStream input;
    FileStream output;
    input.ReadFromFile(in_file);
    Opus2Wav(&lt;/span&gt;&amp;amp;input, &amp;amp;&lt;span&gt;output);
    stream2wav(&lt;/span&gt;&amp;amp;&lt;span&gt;output, out_file);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; wav2opus(&lt;span&gt;char&lt;/span&gt; *in_file, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;out_file) {
    FileStream input;
    FileStream output;
    wav2stream(in_file, &lt;/span&gt;&amp;amp;&lt;span&gt;input);
    Wav2Opus(&lt;/span&gt;&amp;amp;input, &amp;amp;&lt;span&gt;output);
    output.WriteToFile(out_file);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[]) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Opus Demo\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blog:http://tntmonks.cnblogs.com/\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e-mail:gaozhihan@vip.qq.com\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (argc &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *in_file = argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; drive[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; dir[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; fname[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ext[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; out_file[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
    splitpath(in_file, drive, dir, fname, ext);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (memcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ext, strlen(ext)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        sprintf(out_file, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s%s%s.out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, drive, dir, fname);
        wav2opus(in_file, out_file);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (memcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ext, strlen(ext)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        sprintf(out_file, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s%s%s_out.wav&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, drive, dir, fname);
        opus2wav(in_file, out_file);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;done.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;press any key to exit.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    getchar();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;项目地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cpuimage/opus&quot; target=&quot;_blank&quot;&gt;https://github.com/cpuimage/opus&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例具体流程为：&lt;/p&gt;
&lt;p&gt;1.压缩&lt;/p&gt;
&lt;p&gt;加载wav(拖放wav文件到可执行文件上)-&amp;gt;压缩-&amp;gt;保存为out&lt;/p&gt;
&lt;p&gt;2.解压&lt;/p&gt;
&lt;p&gt;加载out(拖放out文件到可执行文件上)-&amp;gt;解压-&amp;gt;保存为wav&lt;/p&gt;

&lt;p&gt;示例比较简单，用cmake即可进行编译示例代码，详情见CMakeLists.txt。&lt;/p&gt;

&lt;p&gt;若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:17:00 +0000</pubDate>
<dc:creator>落羽の殇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tntmonks/p/8878392.html</dc:identifier>
</item>
<item>
<title>PHP面向对象-看父类调用子类方法 - BigNerd</title>
<link>http://www.cnblogs.com/skyfynn/p/8878393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfynn/p/8878393.html</guid>
<description>&lt;p&gt;大部分面向对象编程语言中，父类是不允许调用子类的方法的，但是PHP中可以&lt;/p&gt;
&lt;p&gt;1、父类调用子类方法示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class A
{
    public function testa()
    {
        $this-&amp;gt;testb();
    }
}
class B extends A
{
    //仅对public方法可以进行父类调用子类
    public function testb()
    {
        echo 'bbbbb';
    }
}

$b = new B();
$b-&amp;gt;a();
//输出bbbbb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、弊端&lt;/p&gt;
&lt;p&gt;尽量避免这么写，这样的设计非常不好，如果需要写这样的代码，那么一定有其他的设计模式可以取代它&lt;/p&gt;
&lt;p&gt;3、好的设计方法&lt;/p&gt;
&lt;p&gt;首先发现父类调用子类这种方式是在Yii2.0中的save方法，这个方法位于\yii\db\BaseActiveRecord中，save方法中调用了insert或者update方法，然而在当前类中并没有找到这两个方法，因为BaseActiveRecord实现了ActiveRecordInterface接口，所以应该是必须要实现这两个方法的，但这两个方法却出现在了他的子类\yii\db\ActiveRecord中，也就是子类实现了&lt;/p&gt;
&lt;p&gt;两个知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父类可以调用子类的方法&lt;/li&gt;
&lt;li&gt;如果一个抽象类实现了一个接口，那么它可以不实现接口中方法、而由子类去实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样的好处是：如果接口中新增了方法、并且所有的子类都是需要做相同的实现，那么就可以直接将实现放在这个抽象类中，否则对应的各个子类去各自实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//yii2.0
interface ActiveRecordInterface
{
    public function update($runValidation = true, $attributeNames = null);
    public function insert($runValidation = true, $attributes = null);
}

//BaseActiveRecord实现了ActiveRecordInterface接口
abstract class BaseActiveRecord extends Model implements ActiveRecordInterface
{
    public function save($runValidation = true, $attributeNames = null)
    {
        if ($this-&amp;gt;getIsNewRecord()) {
            return $this-&amp;gt;insert($runValidation, $attributeNames);
        } else {
            return $this-&amp;gt;update($runValidation, $attributeNames) !== false;
        }
    }
}

//ActiveRecord
class ActiveRecord extends BaseActiveRecord
{
    public function insert($runValidation = true, $attributes = null)
    {
        //具体实现
    }
    public function update($runValidation = true, $attributeNames = null)
    {
        //具体实现
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、应用&lt;/p&gt;
&lt;p&gt;如最近的需求：新建了语文、数学、英语三科错题数据库表，目前结构表结构基本一致，但未来可能不同的错题可能会有不同的差异，所以分开三个库建了三张表&lt;/p&gt;
&lt;p&gt;对于目前来说三科都需要查询错题数量统计，这个时候一种做法是三个类分别去实现这个方法，另外一种方式就是可以定义一个接口，接口中定义统计的方法、目前来说并无差异，所以为三个错题的类建立一个抽象的基类，并将统计错题的方法在抽象基类中实现，如果以后出现了不同的统计方式，子类可以直接重写这个统计方法&lt;/p&gt;
&lt;p&gt;如果表发生了改变，统计方法发生了改变，查询依赖于对应科目表中的不同字段，也就是具体数学|语文|英语错题中的变量、常量、或方法，就可以直接在接口中定义、在子类中实现、在抽象基类中调用子类的这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//实例 定义一个接口 里面包含计算错题统计的方法
interface WrongNoteInterface 
{
    public function statistics();
    //public function select();
    //public function where();
}
//抽象基类
abstract class WrongNoteBase implements WrongNoteInterface
{
    public function statistics()
    {
        $select = 'xx’;// $select = $this-&amp;gt;select();
        $where  = ‘xx’;// $where  = $this-&amp;gt;where();
        return $this-&amp;gt;find()-&amp;gt;select($select)-&amp;gt;where($where)-&amp;gt;asArray()-&amp;gt;all();
    }
}
//语数外继承基类
class ChineseWrongNote extends WrongNoteBase
{
    const IS_RIGHT_0 = 0;
    const IS_RIGHT_1 = 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像上面的这种情况，如果要查的字段select变了，select可能是个SUM(xxx)这中结构，而其中计算SUM的条件可能不一样，这个时候就可以在接口中添加:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public function select();&lt;/li&gt;
&lt;li&gt;public function where();&lt;br/&gt;然后在修改statistics中$select获取方式变为直接调用子类方法select，代码改为注释中的内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结：经过这样的修改，避免了代码的冗余（一个统计代码复制三份）、可以方便的对类进行扩展&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:17:00 +0000</pubDate>
<dc:creator>BigNerd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfynn/p/8878393.html</dc:identifier>
</item>
<item>
<title>js高阶函数应用—函数防抖和节流 - 逸丶风</title>
<link>http://www.cnblogs.com/yifeng555/p/8878276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifeng555/p/8878276.html</guid>
<description>&lt;p&gt;高阶函数指的是至少满足下列两个条件之一的函数：&lt;/p&gt;
&lt;p&gt;1. 函数可以作为参数被传递；&lt;br/&gt;2.函数可以作为返回值输出；&lt;/p&gt;
&lt;p&gt;javaScript中的函数显然具备高级函数的特征，这使得函数运用更灵活，作为学习js必定会接触到的闭包也可以通过高阶函数构建，当然本文不打算介绍闭包，我们今天的主题是函数防抖和节流。&lt;/p&gt;
&lt;p&gt;首先我们来简单看一下什么是函数防抖和节流，我们开发过程中常经常会用到一些dom事件，比如mouseover、keydown/keyup、input（处理中文输入还可能用到compositionstart/compositionend）、scroll和resize之类的事件，当然这些事件应用场景也很常见：&lt;/p&gt;
&lt;p&gt;1.如实现一些拖拽功能（不用 H5 Drag&amp;amp;Drop API）和鼠标移动需要触发一些特殊需求的js操作会用mouseover;&lt;/p&gt;
&lt;p&gt;2.处理输入时候可能很多校验，联想之类的可能会用到keydown/keyup、input&lt;/p&gt;
&lt;p&gt;3.一些射击类游戏的点击可能会用到keydown/keyup&lt;/p&gt;
&lt;p&gt;4.resize和scroll这两个不用我多说了，滚动和窗口大小监听&lt;/p&gt;
&lt;p&gt;以上这些事件都有一个共同特点就是用户的操作会触发N多次事件，比如最典型的scroll事件，滚动页面会多次重复触发，导致很多我们写的回调函数被不停的往js的事件队列里添加，重复执行很多次回调里的逻辑（如果你的回调里还有很多操作DOM的逻辑那么页面可能会卡顿）。这些并不是我们希望的，所以我们得采取一定的措施控制这种情况：&lt;/p&gt;
&lt;p&gt;1.减少事件触发的次数&lt;/p&gt;
&lt;p&gt;2.减少回调的执行次数&lt;/p&gt;
&lt;p&gt;显然第一条减少事件触发作为写前端的我们应该是做不到的，所以解决方案就是减少回调的执行，因为我们能控制是否往事件循环队列里添加回调函数和以什么频率去添加，&lt;/p&gt;
&lt;p&gt;故而我们要做的事让&lt;strong&gt;回调函数不要执行得太频繁，减少一些过快的调用以&lt;span&gt;&lt;em&gt;固定频率（这个频率我们可以控制）触发&lt;/em&gt;&lt;/span&gt;来节流，&lt;/strong&gt;或者&lt;strong&gt;让短时间内重复触发的事件回调在事件停止触发的一定时间后（这个时间我们可以控制）&lt;span&gt;&lt;em&gt;只执行一次回调函数&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;好了，简单的介绍了节流和防抖之后我们开始来写代码演示一下，首先我们先介绍函数防抖，因为防抖比节流更容易理解一些。&lt;/p&gt;
&lt;p&gt;我们现在打开控制台给当前页面绑定一个scroll事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;function test() {&lt;/p&gt;
&lt;p&gt;console.log('test')&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;window.addEventListener('scroll', test)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后吧页面滚到底发现控制台打印了很多个&quot;test&quot;，如果我们只希望页面滚到底才触发一些操作，那么我们只需要在最后只执行一次回调，这就需要防抖函数来实现，我们这里来一个简化版本，其实这就是防抖的核心代码，只要理解这点其他的是复杂实现不过都是考虑更多的场景而已（《js高程》中说是节流，实则为防抖）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        function debounce(method, context, time) {
            clearTimeout(method.timeoutId);
            method.timeoutId &lt;/span&gt;= setTimeout(() =&amp;gt;&lt;span&gt; {
                method.apply(context,arguments);
            }, time);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再来试验一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; test() {
            console.log(&lt;/span&gt;'test'&lt;span&gt;)
        }
        window.addEventListener(&lt;/span&gt;'scroll', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                debounce(test, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, 200&lt;span&gt;);
        })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只要滚动事件的触发频率大于200ms就一直不会被执行，只有最后执行一次，如果你在写的页面测试，可能会在一开始执行了一次test因为刷新页面触发了scroll。&lt;/p&gt;
&lt;p&gt;这里给出underscore里的防抖函数的实现(加粗地方对应上边介绍的核心代码逻辑)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Returns a function, that, as long as it continues to be invoked, will not&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; be triggered. The function will be called after it stops being called for&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; N milliseconds. If `immediate` is passed, trigger the function on the&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; leading edge, instead of the trailing.&lt;/span&gt;
  _.debounce = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, wait, immediate) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; timeout, result;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; later = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(context, args) {
      timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args) result =&lt;span&gt; func.apply(context, args);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; debounced = restArgs(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(args) {
      &lt;/span&gt;&lt;strong&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timeout) clearTimeout(timeout);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (immediate) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; callNow = !&lt;span&gt;timeout;
        timeout &lt;/span&gt;=&lt;span&gt; setTimeout(later, wait);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callNow) result = func.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        timeout &lt;/span&gt;= _.delay(later, wait, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
      }

      &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    });

    debounced.cancel &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      clearTimeout(timeout);
      timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; debounced;
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们说一说节流函数，在开始这之前我们先来个简单的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       
        console.time(&lt;/span&gt;'test throttle'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; 5000; i++&lt;span&gt;) {
            test();
        }
        console.timeEnd(&lt;/span&gt;'test throttle');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1098802/201804/1098802-20180418224603164-374366730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行代码后我这里基本是在1.9s内打印了5000个“test”字符串，就是在很短时间内调用了5000次，这5000次调用我们希望每隔10ms的函数才被执行,&lt;/p&gt;
&lt;p&gt;这里我们先来实现一个简单版本的节流函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;var&lt;/span&gt; throttle = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; last = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(method, context, time) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; current = +&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current - last &amp;gt;&lt;span&gt; time) {
                    method.apply(context, arguments);
                    last &lt;/span&gt;=&lt;span&gt; current;
                }
            }
        })();&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;　　　　　　for (let i = 0; i &amp;lt; 50000; i++) {&lt;/p&gt;
&lt;p&gt;　　　　　　　　throttle(test, null, 10);&lt;/p&gt;
&lt;p&gt;　　　　　　}&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
                                  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行我们可以得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1098802/201804/1098802-20180418225757372-717061012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用共用了138ms（时间比前边少很多，这是因为我们前边实际都执行了打印的操作），而这里throttle函数知识把test()函数放进js函数执行队列，并没有执行打印，所以执行时间要少很多，不过我们还是得到了我们期望的效果：&lt;strong&gt;函数在多次调用的时候我们期望固定频率执行函数，而忽略其他函数不执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我们同样给出underscore里的节流函数版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Returns a function, that, when invoked, will only be triggered at most once&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; during a given window of time. Normally, the throttled function will run&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; as much as it can, without ever going more than once per `wait` duration;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; but if you'd like to disable the execution on the leading edge, pass&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; `{leading: false}`. To disable execution on the trailing edge, ditto.&lt;/span&gt;
  _.throttle = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, wait, options) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; timeout, context, args, result;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; previous = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!options) options =&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; later = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      previous &lt;/span&gt;= options.leading === &lt;span&gt;false&lt;/span&gt; ? 0&lt;span&gt; : _.now();
      timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      result &lt;/span&gt;=&lt;span&gt; func.apply(context, args);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; throttled = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; now =&lt;span&gt; _.now();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!previous &amp;amp;&amp;amp; options.leading === &lt;span&gt;false&lt;/span&gt;) previous =&lt;span&gt; now;
      &lt;/span&gt;&lt;strong&gt;&lt;span&gt;var&lt;/span&gt; remaining = wait - (now -&lt;span&gt; previous);
      context &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
      args &lt;/span&gt;=&lt;span&gt; arguments;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (remaining &amp;lt;= 0 || remaining &amp;gt;&lt;span&gt; wait) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timeout) {
          clearTimeout(timeout);
          timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        previous &lt;/span&gt;=&lt;span&gt; now;
        result &lt;/span&gt;=&lt;span&gt; func.apply(context, args);
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!timeout &amp;amp;&amp;amp; options.trailing !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
        timeout &lt;/span&gt;=&lt;span&gt; setTimeout(later, remaining);
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    };

    throttled.cancel &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      clearTimeout(timeout);
      previous &lt;/span&gt;= 0&lt;span&gt;;
      timeout &lt;/span&gt;= context = args = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; throttled;
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 18 Apr 2018 15:07:00 +0000</pubDate>
<dc:creator>逸丶风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yifeng555/p/8878276.html</dc:identifier>
</item>
<item>
<title>JS定时器 - 鲁系大厨</title>
<link>http://www.cnblogs.com/wangrongchen/p/8878265.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangrongchen/p/8878265.html</guid>
<description>&lt;p&gt;&lt;strong&gt;格式：&lt;/strong&gt;定时器(执行的动作，时间(毫秒))；&lt;/p&gt;
&lt;p&gt;返回值：定时器对象　　//第几个&lt;/p&gt;
&lt;p&gt;var aa = setInterval(function(){},1000);　　//间隔执行；清除：clearInterval(第几个定时器/aa);&lt;/p&gt;
&lt;p&gt;setTimeout(function(){},1000);　　//延迟执行；清除：clearTimeout();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在定时器中调用方法：&lt;/strong&gt;setTimeout(aa,1000);　　//直接写方法名，不加小括号。&lt;/p&gt;
&lt;p&gt;如果定时器需要多次定义（比如轮播图的鼠标移开开始定时器）,可以先定义定时器为空，用到的时候s = setInterval(aa,1000);&lt;/p&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;73&quot;&gt;
&lt;p&gt;给对象添加事件&lt;/p&gt;
&lt;p&gt;1.obj.addEventListener('click',aa)&lt;/p&gt;
&lt;p&gt;　　//‘click’:事件类型；加引号，全部小写，区别于html不带‘on’；   &lt;/p&gt;

&lt;p&gt;　　//aa:方法名，不带括号，不可传值。&lt;/p&gt;
&lt;p&gt;　　//可直接使用this&lt;/p&gt;
&lt;p&gt;2.obj.setAttribute('onClick','delTr(this)');&lt;/p&gt;

&lt;p&gt;　　//‘onClick’:事件类型；加引号，按html规范写；   &lt;/p&gt;

&lt;p&gt;　　//aa:方法名，带括号，可以传值。&lt;/p&gt;

&lt;p&gt;　　//不能使用this，必须有this传值才可直接使用&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;blog_post_info_block&quot;&gt;
&lt;div id=&quot;BlogPostCategory&quot;&gt;分类: &lt;a href=&quot;http://www.cnblogs.com/flypea93/category/1173663.html&quot; target=&quot;_blank&quot;&gt;记录&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:05:00 +0000</pubDate>
<dc:creator>鲁系大厨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangrongchen/p/8878265.html</dc:identifier>
</item>
<item>
<title>java 反射（Reflection）-干货 - Hongten</title>
<link>http://www.cnblogs.com/hongten/p/hongten_java_reflection.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongten/p/hongten_java_reflection.html</guid>
<description>&lt;p&gt;看了很多关于java 反射的文章，自己把所看到的总结一下。对自己，对他人或多或少有帮助吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;Java Reflection是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先来看看&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/reflect/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;官方文档&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;Oracle里面对Reflection的描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;p&gt;简单的讲：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;反射机制就是可以把一个类,类的成员(函数，属性)，当成一个对象来操作，希望读者能理解，也就是说，类，类的成员，我们在运行的时候还可以动态地去操作他们。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再简单一点的讲：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们可以在&lt;strong&gt;&lt;span&gt;运行时&lt;/span&gt;&lt;/strong&gt;获得程序或程序集中每一个类型的成员和成员的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;Java是面向对象语言，我们可以把老虎，狮子等具有相同性质的动物归类(抽象)为猫科动物，他们具有牙齿，胡须等一些属性。同时具有吃肉()的动作。&lt;/p&gt;
&lt;p&gt;同样的道理，我们所接触到的类Class，也可以把他们抽象出来，有类名，成员变量，方法等。&lt;/p&gt;
&lt;p&gt;那么既然能够把类看做是对象，那么java就可以对其进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/hongten/1200166/o_java_reflect_1.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;Java反射（Reflection）框架主要提供以下功能：&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;在运行时判断任意一个对象所属的类；&lt;/li&gt;
&lt;li&gt;在运行时构造任意一个类的对象；&lt;/li&gt;
&lt;li&gt;在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；&lt;/li&gt;
&lt;li&gt;在运行时调用任意一个对象的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;Java反射（Reflection）的主要用途&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;工厂模式：Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类Factory了&lt;/li&gt;
&lt;li&gt;数据库JDBC中通过Class.forName(Driver).来获得数据库连接驱动&lt;/li&gt;
&lt;li&gt;分析类文件：毕竟能得到类中的方法等等&lt;/li&gt;
&lt;li&gt;访问一些不能访问的变量或属性：破解别人代码&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;Java反射（Reflection）的基本运用&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　获取Class有一下三种方法：&lt;/p&gt;
&lt;p&gt;1. 使用Class类的forName静态方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），   
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这通过java.lang.Class类的静态方法forName(String  className)实现。   
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;例如：   &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{   
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载MySql的驱动类   &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     Class.forName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;) ;   
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(ClassNotFoundException e){   
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;找不到驱动程序类 ，加载驱动失败！&quot;);   &lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    e.printStackTrace() ;   
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}   
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功加载后，会将Driver类的实例注册到DriverManager类中。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. 直接获取某一个对象的class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class&amp;lt;?&amp;gt; klass = &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Class&amp;lt;?&amp;gt; classInt = Integer.TYPE;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 调用某个对象的getClass()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Demo demo=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Demo();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        System.out.println(demo.getClass().getName());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 下面是一个完整的Demo展示Java Reflection的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.b510.hongten.test.reflex;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Constructor;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Modifier;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectionDemo {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;     * 为了看清楚Java反射部分代码，所有异常我都最后抛出来给虚拟机处理！
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InstantiationException
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalAccessException
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InvocationTargetException
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NoSuchFieldException
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo1. 通过Java反射机制得到类的包名和类名&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        Demo1();
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo2. 验证所有的类都是Class类的实例对象&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        Demo2();
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo3. 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        Demo3();
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo4: 通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        Demo4();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo5: 通过Java反射机制操作成员变量, set 和 get&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        Demo5();
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        Demo6();
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo7: 通过Java反射机制调用类中方法&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        Demo7();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Demo8: 通过Java反射机制获得类加载器&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        Demo8();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;     * Demo1: 通过Java反射机制得到类的包名和类名
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Demo1() {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         Person person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; +&lt;span&gt; person.getClass().getName());
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         
&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        Demo1: 包名: com.b510.hongten.test.reflex，完整类名: com.b510.hongten.test.reflex.Person
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;     * Demo2: 验证所有的类都是Class类的实例对象 
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo2() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         Class&amp;lt;?&amp;gt; class2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写法1, 可能抛出 ClassNotFoundException [多用这个写法]&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         System.out.println(&quot;Demo2:(写法1) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; +&lt;span&gt; class1.getName());
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        Demo2:(写法1) 包名: com.b510.hongten.test.reflex，完整类名: com.b510.hongten.test.reflex.Person
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写法2&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         class2 = Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         System.out.println(&quot;Demo2:(写法2) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; +&lt;span&gt; class2.getName());
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        Demo2:(写法2) 包名: com.b510.hongten.test.reflex，完整类名: com.b510.hongten.test.reflex.Person
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; &lt;span&gt;     * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalAccessException
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InstantiationException
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo3() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException, InstantiationException, IllegalAccessException {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;         Person person =&lt;span&gt; (Person) class1.newInstance();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         person.setAge(20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         person.setName(&quot;Hongten&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         System.out.println(&quot;Demo3: &quot; + person.getName() + &quot; : &quot; +&lt;span&gt; person.getAge());
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         
&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        Demo3: Hongten : 20
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;     * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InvocationTargetException
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalAccessException
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InstantiationException
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo4() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         Person person1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;         Person person2 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到一系列构造函数集合&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;         Constructor&amp;lt;?&amp;gt;[] constructors =&lt;span&gt; class1.getConstructors();
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt;         person1 = (Person) constructors[0&lt;span&gt;].newInstance();
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         person1.setAge(30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         person1.setName(&quot;Hongten&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt;         person2 = (Person) constructors[1].newInstance(20, &quot;Hongten&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;         System.out.println(&quot;Demo4: &quot; + person1.getName() + &quot; : &quot; + person1.getAge() + &quot;  ,   &quot; + person2.getName() + &quot; : &quot; +&lt;span&gt; person2.getAge());
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        Demo4: Hongten : 30  ,   Hongten : 20
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt; &lt;span&gt;     * Demo5: 通过Java反射机制操作成员变量, set 和 get
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalAccessException
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NoSuchFieldException
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InstantiationException
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo5() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         Object obj =&lt;span&gt; class1.newInstance();
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; 
&lt;span&gt;169&lt;/span&gt;         Field personNameField = class1.getDeclaredField(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         personNameField.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;         personNameField.set(obj, &quot;HONGTEN&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;         System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; +&lt;span&gt; personNameField.get(obj));
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;        Demo5: 修改属性之后得到属性变量的值：HONGTEN
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt; &lt;span&gt;     * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo6() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.SuperMan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得父类名称&lt;/span&gt;
&lt;span&gt;191&lt;/span&gt;         Class&amp;lt;?&amp;gt; superClass =&lt;span&gt; class1.getSuperclass();
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;         System.out.println(&quot;Demo6:  SuperMan类的父类名: &quot; +&lt;span&gt; superClass.getName());
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;        Demo6:  SuperMan类的父类名: com.b510.hongten.test.reflex.Person
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt;         
&lt;span&gt;199&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; 
&lt;span&gt;201&lt;/span&gt;         Field[] fields =&lt;span&gt; class1.getDeclaredFields();
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; fields.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             System.out.println(&quot;类中的成员: &quot; +&lt;span&gt; fields[i]);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;        类中的成员: private boolean com.b510.hongten.test.reflex.SuperMan.BlueBriefs
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt;         
&lt;span&gt;210&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; 
&lt;span&gt;212&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得类方法&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt;         Method[] methods =&lt;span&gt; class1.getDeclaredMethods();
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; methods.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;             System.out.println(&quot;Demo6,取得SuperMan类的方法：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;             System.out.println(&quot;函数名：&quot; +&lt;span&gt; methods[i].getName());
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;             System.out.println(&quot;函数返回类型：&quot; +&lt;span&gt; methods[i].getReturnType());
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;             System.out.println(&quot;函数访问修饰符：&quot; +&lt;span&gt; Modifier.toString(methods[i].getModifiers()));
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;             System.out.println(&quot;函数代码写法： &quot; +&lt;span&gt; methods[i]);
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; 
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;223&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;        Demo6,取得SuperMan类的方法：
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        函数名：isBlueBriefs
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;        函数返回类型：boolean
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;        函数访问修饰符：public
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt;        函数代码写法： public boolean com.b510.hongten.test.reflex.SuperMan.isBlueBriefs()
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;        Demo6,取得SuperMan类的方法：
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;        函数名：setBlueBriefs
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;        函数返回类型：void
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;        函数访问修饰符：public
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt; &lt;span&gt;        函数代码写法： public void com.b510.hongten.test.reflex.SuperMan.setBlueBriefs(boolean)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;        Demo6,取得SuperMan类的方法：
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;        函数名：fly
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;        函数返回类型：void
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt;        函数访问修饰符：public
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;        函数代码写法： public void com.b510.hongten.test.reflex.SuperMan.fly()
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;        Demo6,取得SuperMan类的方法：
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;        函数名：walk
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;        函数返回类型：void
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;        函数访问修饰符：public
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;        函数代码写法： public void com.b510.hongten.test.reflex.SuperMan.walk(int)
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt;         
&lt;span&gt;246&lt;/span&gt;         System.out.println(&quot;===============================================&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; 
&lt;span&gt;248&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈&lt;/span&gt;
&lt;span&gt;249&lt;/span&gt;         Class&amp;lt;?&amp;gt; interfaces[] =&lt;span&gt; class1.getInterfaces();
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; interfaces.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             System.out.println(&quot;实现的接口类名: &quot; +&lt;span&gt; interfaces[i].getName());
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;         
&lt;span&gt;254&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt;        实现的接口类名: com.b510.hongten.test.reflex.ActionInterface
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; 
&lt;span&gt;259&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;262&lt;/span&gt; &lt;span&gt;     * Demo7: 通过Java反射机制调用类方法
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; SecurityException
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InvocationTargetException
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalAccessException
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; InstantiationException
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;272&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo7() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException {
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.SuperMan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; 
&lt;span&gt;276&lt;/span&gt;         System.out.println(&quot;Demo7: \n调用无参方法fly()&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;         Method method = class1.getMethod(&quot;fly&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt; &lt;span&gt;        method.invoke(class1.newInstance());
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; 
&lt;span&gt;280&lt;/span&gt;         System.out.println(&quot;调用有参方法walk(int m)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt;         method = class1.getMethod(&quot;walk&quot;, &lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;         method.invoke(class1.newInstance(), 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;         
&lt;span&gt;284&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;285&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; &lt;span&gt;        Demo7: 
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt;        调用无参方法fly()
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt; &lt;span&gt;        fly method....
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; &lt;span&gt;        调用有参方法walk(int m)
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt; &lt;span&gt;        fly in 100 m
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;292&lt;/span&gt;         
&lt;span&gt;293&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt; 
&lt;span&gt;295&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;296&lt;/span&gt; &lt;span&gt;     * Demo8: 通过Java反射机制得到类加载器信息
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; &lt;span&gt;     * 在java中有三种类类加载器。[这段资料网上截取]
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;     * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt; &lt;span&gt;     * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt; &lt;span&gt;     * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;308&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Demo8() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt;         Class&amp;lt;?&amp;gt; class1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt;         class1 = Class.forName(&quot;com.b510.hongten.test.reflex.SuperMan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt;         String nameString =&lt;span&gt; class1.getClassLoader().getClass().getName();
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; 
&lt;span&gt;313&lt;/span&gt;         System.out.println(&quot;Demo8: 类加载器类名: &quot; +&lt;span&gt; nameString);
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;         
&lt;span&gt;315&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;316&lt;/span&gt; &lt;span&gt;        运行结果：
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt; &lt;span&gt;        Demo8: 类加载器类名: sun.misc.Launcher$AppClassLoader
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;319&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; 
&lt;span&gt;321&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt; 
&lt;span&gt;323&lt;/span&gt; 
&lt;span&gt;324&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt; 
&lt;span&gt;328&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt; 
&lt;span&gt;330&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; 
&lt;span&gt;332&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Person(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String name) {
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt; 
&lt;span&gt;337&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; 
&lt;span&gt;341&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; 
&lt;span&gt;345&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; 
&lt;span&gt;349&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; 
&lt;span&gt;354&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SuperMan &lt;span&gt;extends&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ActionInterface {
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; BlueBriefs;
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; 
&lt;span&gt;357&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fly() {
&lt;/span&gt;&lt;span&gt;358&lt;/span&gt;         System.out.println(&quot;fly method....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt; 
&lt;span&gt;361&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isBlueBriefs() {
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; BlueBriefs;
&lt;/span&gt;&lt;span&gt;363&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt; 
&lt;span&gt;365&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBlueBriefs(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; blueBriefs) {
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt;         BlueBriefs =&lt;span&gt; blueBriefs;
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt; 
&lt;span&gt;369&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; walk(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m) {
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt;         System.out.println(&quot;fly in &quot; + m + &quot; m&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;371&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;373&lt;/span&gt; 
&lt;span&gt;374&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ActionInterface {
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; walk(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m);
&lt;/span&gt;&lt;span&gt;376&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;
&lt;h2&gt; 说说工厂模式和Java 反射（Reflection）机制&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 如果在工厂模式下面，我们不使用Java 反射（Reflection）机制，会是什么样子呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.b510.hongten.test.reflex;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hongten
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @created Apr 18, 2018
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FactoryTest {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Cats cats = FactoryTest.getInstance(&quot;Tiger&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        cats.eatMeat();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         * The Result : The tiger eat meat.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cats getInstance(String name) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Cats cats = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;Tiger&quot;&lt;span&gt;.equals(name)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             cats = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tiger();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&quot;Lion&quot;&lt;span&gt;.equals(name)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             cats = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Lion();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cats;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Tiger &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         System.out.println(&quot;The tiger eat meat.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lion &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         System.out.println(&quot;The lion eat meat.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们会发现：&lt;/p&gt;
&lt;p&gt;当我们在添加一个子类（Puma-美洲狮）的时候，就需要修改工厂类了。如果我们添加太多的子类的时候，改的就会很多。&lt;/p&gt;
&lt;p&gt;我们对程序进行修改，加入反射机制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.b510.hongten.test.reflex;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hongten
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * @created Apr 18, 2018
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FactoryTest {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Cats cats = FactoryTest.getInstance(&quot;com.b510.hongten.test.reflex.Lion&quot;);&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         Cats cats = FactoryTest.getInstance(&quot;com.b510.hongten.test.reflex.Tiger&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        cats.eatMeat();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         * The Result : The tiger eat meat.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cats getInstance(String name) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Cats cats = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;use Class.forName() with java reflection&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 cats =&lt;span&gt; (Cats) Class.forName(name).newInstance();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InstantiationException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cats;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Tiger &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         System.out.println(&quot;The tiger eat meat.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lion &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat() {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         System.out.println(&quot;The lion eat meat.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们会发现利用了Java Reflection以后，现在就算我们添加任意多个子类的时候，工厂类就不需要修改。我们只需要传递工厂类的实现类的名称即可。&lt;/p&gt;
&lt;p&gt;然而，在这样的情况下面，如果我们需要运行Lion实例的时候，我们还需要去修改java代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Cats cats = FactoryTest.getInstance(&quot;com.b510.hongten.test.reflex.Lion&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码虽然可以通过反射取得接口的实例，但是需要传入完整的包和类名。而且用户也无法知道一个接口有多少个可以使用的子类，所以我们通过属性文件的形式配置所需要的子类。&lt;/p&gt;
&lt;p&gt;能不能不需要修改java代码，同样可以完成相同的操作呢？是可以的。&lt;/p&gt;
&lt;p&gt;我们可以让工厂模式结合属性文件（如：*.properties, *.xml文件）&lt;/p&gt;
&lt;p&gt; 属性文件：/reflex/cats.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;lion=com.b510.hongten.test.reflex.Lion
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tiger=com.b510.hongten.test.reflex.Tiger
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试文件：/reflex/FactoryTest.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.b510.hongten.test.reflex;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hongten
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * @created Apr 18, 2018
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FactoryTest {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        Cats cats;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             cats = FactoryTest.getInstance(getPro().getProperty(&quot;tiger&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (cats != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                cats.eatMeat();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;         * The Result : The tiger eat meat.
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cats getInstance(String name) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         Cats cats = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use Class.forName() with java reflection&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 cats =&lt;span&gt; (Cats) Class.forName(name).newInstance();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InstantiationException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cats;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Properties getPro() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; FileNotFoundException, IOException {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         Properties pro = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         File f = &lt;span&gt;new&lt;/span&gt; File(&quot;cats.properties&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f.exists()) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             pro.load(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(f));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             pro.setProperty(&quot;lion&quot;, &quot;com.b510.hongten.test.reflex.Lion&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             pro.setProperty(&quot;tiger&quot;, &quot;com.b510.hongten.test.reflex.Tiger&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             pro.store(&lt;span&gt;new&lt;/span&gt; FileOutputStream(f), &quot;FRUIT CLASS&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pro;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Tiger &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat() {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         System.out.println(&quot;The tiger eat meat.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lion &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cats {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatMeat() {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;         System.out.println(&quot;The lion eat meat.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为开发者，我们只需要配置cats.properties属性文件即可。极大的提高了程序的扩展性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2&gt;Java反射（Reflection）的一些注意事项&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。&lt;/li&gt;
&lt;li&gt;另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:03:00 +0000</pubDate>
<dc:creator>Hongten</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongten/p/hongten_java_reflection.html</dc:identifier>
</item>
<item>
<title>一、spring的成长之路——代理设计模式 - IT云私塾</title>
<link>http://www.cnblogs.com/hu1056043921/p/8878213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hu1056043921/p/8878213.html</guid>
<description>&lt;h4 id=&quot;代理模式jdk的动态代理&quot;&gt;1.代理模式(JDK的动态代理)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;【IDept.java】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 这是一个简单的就接口，进行数据的更新&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itcloud.pattern.proxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; IDept {
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;【DeptImp.java】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ Dept的实现类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itcloud.pattern.proxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DeptImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; IDept {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;完成核心功能，进行数据的更新操作&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;【InvoProxy.java】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 代理类，被代理对象只需要完成核心功能，而其他的功能都由代理对象完成&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itcloud.pattern.proxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.InvocationHandler;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Proxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; InvoProxy &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; InvocationHandler {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object obj;

    &lt;span class=&quot;co&quot;&gt;// 首先要获取代理对象&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getProxyInterface&lt;/span&gt;(Object obj) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;obj&lt;/span&gt; = obj;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Proxy.&lt;span class=&quot;fu&quot;&gt;newProxyInstance&lt;/span&gt;(obj.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;(), obj.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInterfaces&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      实现的基本步骤&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      1.获取代理类对象，然后获取其接口&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      2.生成新的类，实现代理类的接口，这个类其实只是字节码文件&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      3.在新生成的类中进行代码的执行&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;数据库开启事物&quot;&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;// 这些事情由代理类完成     &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;obj&lt;/span&gt;, args); &lt;span class=&quot;co&quot;&gt;// 代理类完成核心功能&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {

        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;进行事物的回滚操作&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;【TestDemo.java】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestDemo {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        IDept dept = (IDept)&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InvoProxy&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getProxyInterface&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeptImpl&lt;/span&gt;());
        dept.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;();
    }
}
&lt;span class=&quot;co&quot;&gt;//测试结果&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    数据库开启事物&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    完成核心功能，进行数据的更新操作&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    进行事物的回滚操作&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在代码中我们说过，代理对象会生成一个代理类，那么我们来看一下这个类究竟长什么样&lt;/p&gt;
&lt;p&gt;首先在测试类中将字节码写入本地文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【TestDemo.java】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import sun.misc.ProxyGenerator;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.FileOutputStream;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestDemo {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        IDept dept = (IDept)&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;InvoProxy&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getProxyInterface&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DeptImpl&lt;/span&gt;());
        dept.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] $Proxy0 = ProxyGenerator.&lt;span class=&quot;fu&quot;&gt;generateProxyClass&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;$Proxy0&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[]{IDept.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;});
        FileOutputStream out = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;st&quot;&gt;&quot;G:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;$Proxy0.class&quot;&lt;/span&gt;);
        out.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;($Proxy0);
        out.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以在g盘中生成一个&lt;code&gt;$Proxy0.class&lt;/code&gt;文件，这个文件就是类的字节码文件，你看不懂我也看不懂这时候需要借用反编译软件(&lt;code&gt;jd-gui-0.3.6&lt;/code&gt;)，进行反编译&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【$Proxy0.class】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import com.itcloud.pattern.proxy.IDept;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.InvocationHandler;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Proxy;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.UndeclaredThrowableException;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; $Proxy0
  &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Proxy
  &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; IDept
{
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Method m1;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Method m2;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Method m0;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Method m3;
  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; $&lt;span class=&quot;fu&quot;&gt;Proxy0&lt;/span&gt;(InvocationHandler paramInvocationHandler)
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; 
  {
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(paramInvocationHandler);
  }
  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(Object paramObject)
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; 
  {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;
    {
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ((Boolean)&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;h&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, m1, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[] { paramObject })).&lt;span class=&quot;fu&quot;&gt;booleanValue&lt;/span&gt;();
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; localError;
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; 
  {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;
    {
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (String)&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;h&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, m2, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; localError;
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; 
  {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;
    {
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ((Integer)&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;h&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, m0, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;intValue&lt;/span&gt;();
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; localError;
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Boolean &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; 
  {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;
    {
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Boolean)&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;h&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, m3, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Error|RuntimeException localError)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; localError;
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable localThrowable)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt;
  {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;
    {
      m1 = Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;equals&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class[] { Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;) });
      m2 = Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;toString&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
      m0 = Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hashCode&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
      m3 = Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.itcloud.pattern.proxy.IDept&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;update&quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Class[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (NoSuchMethodException localNoSuchMethodException)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NoSuchMethodError(localNoSuchMethodException.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;());
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException localClassNotFoundException)
    {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NoClassDefFoundError(localClassNotFoundException.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;());
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;总结：jdk动态代理必须要有接口&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;cglib代理&quot;&gt;3.cglib代理&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;cglib中，被代理对象不需要继承相关接口&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;【pom.xml】&lt;/strong&gt;文件中添加依赖&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;cglib&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;cglib&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.2.4&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;【Student.java】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itcloud.pattern.cglib;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Student {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;进行数据的更新操作&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;【CglibProxy.java】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itcloud.pattern.cglib;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import net.sf.cglib.proxy.Enhancer;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import net.sf.cglib.proxy.MethodInterceptor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import net.sf.cglib.proxy.MethodProxy;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.InvocationTargetException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.lang.reflect.Method;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CglibProxy &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; MethodInterceptor {

    &lt;span class=&quot;co&quot;&gt;//获取代理类的对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;(Class&amp;lt;?&amp;gt; clazz) {
        Enhancer enhancer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Enhancer&lt;/span&gt;();
        enhancer.&lt;span class=&quot;fu&quot;&gt;setCallback&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
        enhancer.&lt;span class=&quot;fu&quot;&gt;setSuperclass&lt;/span&gt;(clazz);&lt;span class=&quot;co&quot;&gt;//设置生成代理类的父类&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//enhancer.create()这个方法会创建com.itcloud.pattern.cglib.Student$$EnhancerByCGLIB$$4c126679@20e2cbe0代理类，这个代理类是被代理类的子类&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; enhancer.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//enhancer.create() instanceof Student 返回结果true&lt;/span&gt;
    }


    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param obj &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;cglib生成的代理类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param method &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;被代理对象中的方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param args &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;方法的参数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param methodProxy &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;代理方法，即生成代理类中的方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Throwable&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;intercept&lt;/span&gt;(Object obj, Method method, Object[] args, MethodProxy methodProxy) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;数据更新前，事物开启&quot;&lt;/span&gt;);

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; methodProxy.&lt;span class=&quot;fu&quot;&gt;invokeSuper&lt;/span&gt;(obj, args);&lt;span class=&quot;co&quot;&gt;//明确调用父类中的方法&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;出现异常，事物回滚，rollback&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们也可以像JDK动态代理那样对生成的代理类进行字节码反编译。&lt;br/&gt;&lt;code&gt;爱生活爱分享欢迎您的关注与加入自学交流群：461265466&lt;/code&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180406172046645?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODY3NDA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 14:57:00 +0000</pubDate>
<dc:creator>IT云私塾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hu1056043921/p/8878213.html</dc:identifier>
</item>
<item>
<title>Now trying to drop the old temporary tablespace, the session hangs. - 绿茶有点甜</title>
<link>http://www.cnblogs.com/lvcha001/p/8878196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvcha001/p/8878196.html</guid>
<description>&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[oracle@enmo trace]$ more ENMO_ora_15576.trc

Oracle Database 11g Enterprise Edition Release 11.2.0.4.0

- 64bit Production

Instance name: ENMO

Redo thread mounted by this instance: 1

Oracle process number: 19

Unix process pid: 15576, image: oracle@enmo (TNS V1-V3)

 

######根据spid查询没发现什么有效信息：

/ospid: 15576 

...skipping

    (latch info) wait_event=0 bits=0x0

    Process Group: DEFAULT, pseudo proc: 0x7ed5ac30

    O/S info: user: oracle, term: UNKNOWN, ospid: 15576

    OSD pid info: Unix process pid: 15576, image: oracle@e

nmo (TNS V1-V3)

 

#####根据：ospid: 14800 

 

----------------------------------------

SO: 0x7e892b40, type: 4, owner: 0x7ecc5220, flag: INIT/-/-/0x00 if: 0x3 c: 0x3

proc=0x7ecc5220, name=session, file=ksu.h LINE:12729, pg=0

(session) sid: 1 ser: 5 trans: 0x7ccb8a68, creator: 0x7ecc5220

flags: (0x41) USR/- flags_idl: (0x1) BSY/-/-/-/-/-

flags2: (0x48009) -/DDLT2/INC

DID: , short-term DID:

txn branch: (nil)

edition#: 100 oct: 41, prv: 0, sql: 0x7f76ef79fdf0, psql: 0x78f50ad0, user: 0/SYS

ksuxds FALSE at location: 0

service name: SYS$USERS

client details:

O/S info: user: oracle, term: pts/1, ospid: 14800

machine: enmo program: sqlplus@enmo (TNS V1-V3)

application name: sqlplus@enmo (TNS V1-V3), hash value=1501019605

Current Wait Stack:

0: waiting for 'enq: TS - contention'

name|mode=0x54530006, tablespace ID=0x1c, dba=0x1

wait_id=14569 seq_num=14571 snap_id=1

wait times: snap=7 min 28 sec, exc=7 min 28 sec, total=7 min 28 sec

wait times: max=infinite, heur=7 min 28 sec

wait counts: calls=151 os=151

in_wait=1 iflags=0x15a0

#  有一个会话被阻塞

There are 1 sessions blocked by this session.

Dumping one waiter:

inst: 1, sid: 39, ser: 153         

#等待事件

wait event: 'enq: TT - contention'

#############################根据：会话ID，查询操作系统进程号####

SQL&amp;gt; select spid from v$process where addr=(select paddr from v$session where sid=13);

SPID

------------------------

15542

#############根据操系统进程查询：SMON进程#####################

[root@enmo ~]# ps -ef|grep 15542

oracle   15542     1  0 03:27 ?        00:00:01 ora_smon_ENMO

 

p1: 'name|mode'=0x54540004

p2: 'tablespace ID'=0x1a

p3: 'operation'=0x0

row_wait_obj#: 4294967295, block#: 0, row#: 0, file# 0

min_blocked_time: 232 secs, waiter_cache_ver: 2576

Wait State:

fixed_waits=0 flags=0x2b boundary=0x7e894a28/0

Session Wait History:

elapsed time of 25375533 min 56 sec since current wait

0: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14585 seq_num=14587 snap_id=1

等待时间

wait times: snap=0.042447 sec, exc=0.042447 sec, total=0.042447 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

在经过时间：s后发生

occurred after 0.000000 sec of elapsed time

等待：

1: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14584 seq_num=14586 snap_id=1

wait times: snap=0.045086 sec, exc=0.045086 sec, total=0.045086 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

2: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14583 seq_num=14585 snap_id=1

wait times: snap=0.030094 sec, exc=0.030094 sec, total=0.030094 sec

wait times: max=29.990000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

3: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14582 seq_num=14584 snap_id=1

wait times: snap=0.030958 sec, exc=0.030958 sec, total=0.030958 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

4: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14581 seq_num=14583 snap_id=1

wait times: snap=0.033920 sec, exc=0.033920 sec, total=0.033920 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

5: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14580 seq_num=14582 snap_id=1

wait times: snap=0.029040 sec, exc=0.029040 sec, total=0.029040 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

6: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14579 seq_num=14581 snap_id=1

wait times: snap=0.031045 sec, exc=0.031045 sec, total=0.031045 sec

wait times: max=29.990000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

7: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14578 seq_num=14580 snap_id=1

wait times: snap=0.027048 sec, exc=0.027048 sec, total=0.027048 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

8: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14577 seq_num=14579 snap_id=1

wait times: snap=0.029306 sec, exc=0.029306 sec, total=0.029306 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

9: waited for 'ksdxexeotherwait'

=0x0, =0x0, =0x0

wait_id=14576 seq_num=14578 snap_id=1

wait times: snap=0.031989 sec, exc=0.031989 sec, total=0.031989 sec

wait times: max=30.000000 sec

wait counts: calls=0 os=0

occurred after 0.000000 sec of elapsed time

#会话1，序列号5的采样会话历史记录

Sampled Session History of session 1 serial 5

---------------------------------------------------
&lt;/pre&gt;</description>
<pubDate>Wed, 18 Apr 2018 14:55:00 +0000</pubDate>
<dc:creator>绿茶有点甜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvcha001/p/8878196.html</dc:identifier>
</item>
</channel>
</rss>