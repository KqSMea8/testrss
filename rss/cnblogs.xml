<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>什么样的代码称得上是好代码？ - 刘超（技术超）</title>
<link>http://www.cnblogs.com/flame7/p/9321204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flame7/p/9321204.html</guid>
<description>
&lt;p&gt;朋友指着自己写的代码问：你看我的代码写的怎么样，有没有问题，哪里需要修改？&lt;/p&gt;
&lt;p&gt;以最宽松的标准讲，只要代码没有逻辑错误，没有严重性能问题，就没有问题，但我知道，他问得不是这些，而是问代码有没有可以更进一步优化的可能，我看他的代码做了清晰的分层，提取了基类，使用了模板模式，总体上算是不错了。&lt;/p&gt;

&lt;p&gt;问题来了，&lt;span&gt;&lt;strong&gt;究竟什么样的代码算得上是好代码呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;面对这个问题，可能大多数程序员首先想到的是：高内聚，低耦合，高效率，已维护，易扩展。这些是对的，但这只能算是正确的废话，因为对大部分IT从业者（尤其是刚入行，缺乏足够知识和经验的新人）来说，并不能通过一个具体的标准去衡量。&lt;/p&gt;

&lt;p&gt;抛开框架和具体技术细节，单纯从编码的角度讲，依我的观点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象编程，考察的是抽象化的能力。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一层级的抽象是类。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从实际业务需求入手，将现实世界中的事物，抽象成类，通过类，对象之间的相互调用，完成业务需求，这是面向对象编程最基础的抽象的能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二层级的抽象是基类。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发现类之间的共性，提取基类，抽象类，基类负责处理共性的逻辑，子类负责处理个性的逻辑，从而实现代码的复用，逻辑更清晰，代码更易于维护。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;再高一层级的抽象是接口。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接口仅仅定义了一组规范标准，而不包含任何实现逻辑，因此，接口比抽象类的适用范围更广。面向对象开发原则中的“依赖倒置原则”，简单来说，就是要面向接口编程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;更高一层级的抽象是泛型。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么将泛型放到比基类和接口更高一层级，因为基类和接口，都只是对其继承者的单一类型的抽象，而泛型，是对多个相互协作类型的抽象，泛型不仅仅是对类型的抽象，还抽象出了多个类型间相互协作行为，正确的使用泛型，能够让代码变得更精炼，逻辑更严谨规范。&lt;/p&gt;

&lt;p&gt;好了，以上四个层级，也是简单的给代码划分等级，看看自己写的代码，现在处于哪一个层级呢。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然，并非所有的代码都需要提取基类，定义接口，凡事都有一个适用范围。&lt;/p&gt;
&lt;p&gt;以上关于&lt;strong&gt;抽象化&lt;/strong&gt;的观点，算是自己多年从事软件开发的一点小小的感悟，希望对你有一定帮助。&lt;/p&gt;
&lt;p&gt;更为大家广泛接受的，区分好代码的标准，可以参考“&lt;strong&gt;&lt;span&gt;面向对象开发原则&lt;/span&gt;&lt;/strong&gt;”，因为有太多文章写这方面的内容，这里不做展开，有兴趣的朋友可以自行搜索。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 16:21:00 +0000</pubDate>
<dc:creator>刘超（技术超）</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flame7/p/9321204.html</dc:identifier>
</item>
<item>
<title>ThreadLocal原理深入解析 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9320881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9320881.html</guid>
<description>&lt;h2 id=&quot;从一次项目经历说起&quot;&gt;1. 从一次项目经历说起&lt;/h2&gt;
&lt;p&gt;在上家公司做spark的任务调度系统时,碰到过这么一个需求:&lt;br/&gt;1.任务由一个线程执行,同时在执行过程中会创建多个线程执行子任务,子线程在执行子任务时又会创建子线程执行子任务的子任务。整个任务结构就像一棵高度为3的树。&lt;br/&gt;2.每个任务在执行过程中会生成一个任务ID,我需要把这个任务ID传给子线程执行的子任务,子任务同时也会生成自己的任务ID,并把自己的任务ID向自己的子任务传递。&lt;br/&gt;流程可由下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180716225018798-436102582.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方案有很多,比如借助外部存储如数据库,或者自己在内存中维护一个存储ID的数据结构。考虑到系统健壮性和可维护性,最后采用了jdk中的&lt;code&gt;InheritableThreadLocal&lt;/code&gt;来实现这个需求。&lt;br/&gt;来看下InheritableThreadLocal的结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InheritableThreadLocal&amp;lt;T&amp;gt; extends ThreadLocal&amp;lt;T&amp;gt; {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;InheritableThreadLocal继承自ThreadLocal,ThreadLocal可以说是一个存储线程私有变量的容器(当然这个说法严格来说不准确,后面我们就知道为什么)，而InheritableThreadLocal正如Inheritable所暗示的那样,它是可继承的:使用它可使子线程继承父线程的所有线程私有变量。因此我写了个工具类，底层使用InheritableThreadLocal来存储任务的ID，并且使该ID能够被子线程继承。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InheritableThreadLocalUtils {

    private static final ThreadLocal&amp;lt;Integer&amp;gt; local = new InheritableThreadLocal&amp;lt;&amp;gt;();

    public static void set(Integer t) {
        local.set(t);
    }

    public static Integer get() {
        return local.get();
    }

    public static void remove() {
        local.remove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过这个工具类的set方法和get方法分别实现任务ID的存取。然而在Code Review的時候，有同事觉得我这代码写的有问题:原因大概是InheritableThreadLocal在这里只有一个，子线程的任务ID在存储的时候会相互覆盖掉。真的会这样吗？为此我们用代码测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {

    ExecutorService executorService = Executors.newCachedThreadPool();

    for(int i=0;i&amp;lt;10;i++){
        executorService.execute(new TaskThread(i));
    }

}

static class TaskThread implements Runnable{

    Integer taskId;

    public TaskThread(Integer taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {
        InheritableThreadLocalUtils.set(taskId);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(InheritableThreadLocalUtils.get());
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码开启了10个线程标号从0到9，我们在每个线程中将对应的标号存储到InheritableThreadLocal，然后开启一个子线程，在子线程中获取InheritableThreadLocal中的变量。最后的结果如下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180716225541005-1712892361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个线程都准确的获取到了父线程对应的ID,可见并没有覆盖的问题。InheritableThreadLocal确实是用来存储和获取线程私有变量的，但是真实的变量并不是存储在这个InheritableThreadLocal对象中,它只是为我们存取线程私有变量提供了入口而已。因为InheritableThreadLocal只是在ThreadLocal的基础上提供了继承功能,为了弄清这个问题我们研究下ThreadLocal的源码。&lt;/p&gt;
&lt;h2 id=&quot;threadlocal源码解析&quot;&gt;2. ThreadLocal源码解析&lt;/h2&gt;
&lt;p&gt;ThreadLocal主要方法有两个，一个set用来存储线程私有变量，一个get用来获取线程私有变量。&lt;/p&gt;
&lt;h4 id=&quot;set方法源码解析&quot;&gt;2.1 set方法源码解析&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Sets the current thread's copy of this thread-local variable
 * to the specified value.  Most subclasses will have no need to
 * override this method, relying solely on the {@link #initialValue}
 * method to set the values of thread-locals.
 *
 * @param value the value to be stored in the current thread's copy of
 *        this thread-local.
 */
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Thread t = Thread.currentThread()获取了当前线程实例t,继续跟进第二行的getMap方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;t是线程实例,而threadLocals明显是t的一个成员变量,进入一探究竟&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadLocalMap是个什么结构?&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as &quot;stale entries&quot; in the code that follows.
     */
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadLocalMap是类Thread中的一个静态内部类,看起来像一个HashMap,但和HashMap又有些不一样(关于它们的区别后面会讲),那我们就把它当一个特殊的HashMap好了。因此set方法中第二行代码&lt;br/&gt;ThreadLocalMap map = getMap(t)是通过线程实例t得到一个ThreadLocalMap。接下来的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (map != null)
        map.set(this, value);
    else
        createMap(t, value);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果这个threadlocalmap为null,先创建一个threadlocalmap,然后以当前threadlocal对象为key,以要存储的变量为值存储到threadlocalmap中。&lt;/p&gt;
&lt;h4 id=&quot;get方法源码解析&quot;&gt;2.2 get方法源码解析&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 * Returns the value in the current thread's copy of this
 * thread-local variable.  If the variable has no value for the
 * current thread, it is first initialized to the value returned
 * by an invocation of the {@link #initialValue} method.
 *
 * @return the current thread's value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先获取当前线程实例t,然后通过getMap(t)方法得到threadlocalmap(ThreadLocalMap是Thread的成员变量)。若这个map不为null,则以threadlocal为key获取线程私有变量,否则执行setInitialValue方法。看下这个方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;protected T initialValue() {
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先获取threadlocal的初始化值,默认为null,可以通过重写自定义该值;如果threadlocalmap为null,先创建一个;以当前threadlocal对象为key，以初始化值为value存入map中，最后返回这个初始化值。&lt;/p&gt;
&lt;h4 id=&quot;threadlocal源码总结&quot;&gt;2.3 ThreadLocal源码总结&lt;/h4&gt;
&lt;p&gt;总的来说,ThreadLocal的源码并不复杂,但是逻辑很绕。现总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.ThreadLocal对象为每个线程存取私有的本地变量提供了入口，变量实际存储在线程实例的内部一个叫ThreadLocalMap的数据结构中。&lt;/li&gt;
&lt;li&gt;2.ThreadLocalMap是一个类HashMap的数据结构，Key为ThreadLoca对象(其实是一个弱引用)，Value为要存储的变量值。&lt;/li&gt;
&lt;li&gt;3.使用ThreadLocal进行存取，其实就是以ThreadLocal对象为隐含的key对各个线程私有的Map进行存取。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以用下图的内存图像帮助理解和记忆&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180716225036320-525184510.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocalmap详解&quot;&gt;3. ThreadLocalMap详解&lt;/h2&gt;
&lt;p&gt;先看源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as &quot;stale entries&quot; in the code that follows.
     */
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;threadlocalmap的key为弱引用&quot;&gt;3.1 ThreadLocalMap的key为弱引用&lt;/h4&gt;
&lt;p&gt;ThreadLocalMap的key并不是ThreadLocal,而是WeakReference,这是一个弱引用，说它弱是因为如果一个对象只被弱引用引用到，那么下次垃圾收集时就会被回收掉。如果引用ThreadLocal对象的只有ThreadLocalMap的key，那么下次垃圾收集过后该key就会变为null。&lt;/p&gt;
&lt;h4 id=&quot;为何要用弱引用&quot;&gt;3.2 为何要用弱引用&lt;/h4&gt;
&lt;p&gt;减少了内存泄漏。试想我曾今存储了一个ThreadLocal对象到ThreadLocalMap中，但后来我不需要这个对象了,只有ThreadLocalMap中的key还引用了该对象。如果这是个强引用的话，该对象将一直无法回收。因为我已经失去了其他所有该对象的外部引用，这个ThreadLocal对象将一直存在，而我却无法访问也无法回收它，导致内存泄漏。又因为ThreadLocalMap的生命周期和线程实例的生命周期一致，只要该线程一直不退出，比如线程池中的线程，那么这种内存泄漏问题将会不断积累，直到导致系统奔溃。而如果是弱引用的话，当ThreadLocal失去了所有外部强引用的话，下次垃圾收集该ThreadLocal对象将被回收，对应的ThreadLocalMap中的key将为null。下次get和set方法被执行时将会对key为null的Entry进行清理。有效的减少了内存泄漏的可能和影响。&lt;/p&gt;
&lt;h4 id=&quot;如何真正避免内存泄漏&quot;&gt;3.3 如何真正避免内存泄漏&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;及时调用ThreadLocal的remove方法&lt;/li&gt;
&lt;li&gt;及时销毁线程实例&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;ThreadLocal为我们存取线程私有变量提供了入口,变量实际存储在线程实例的map结构中;使用它可以让每个线程拥有一份共享变量的拷贝，以非同步的方式解决多线程对资源的争用&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:58:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9320881.html</dc:identifier>
</item>
<item>
<title>C# 栈的应用 - 见风任然是风</title>
<link>http://www.cnblogs.com/sunven/p/9320803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunven/p/9320803.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;栈的特性：后进先出（LIFO）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;回文判断&quot;&gt;回文判断&lt;/h2&gt;
&lt;p&gt;类似123321，123a321即为回文&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将字符串前一半入栈&lt;/li&gt;
&lt;li&gt;依次弹出栈与字符串后一半比较&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static bool IsPlalindrome(string str)
{
    var stack = new Stack&amp;lt;char&amp;gt;();
    for (int i = 0; i &amp;lt; str.Length / 2; i++)
    {
        stack.Push(str[i]);
    }

    var len = str.Length % 2 == 0 ? str.Length / 2 : (str.Length + 1) / 2;
    for (int i = len; i &amp;lt; str.Length; i++)
    {
        if (stack.Pop() != str[i])
        {
            return false;
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进制转化&quot;&gt;进制转化&lt;/h2&gt;
&lt;p&gt;10进制转8进制 1024→2000&lt;/p&gt;
&lt;p&gt;转换流程如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取模入栈&lt;/li&gt;
&lt;li&gt;整除运算直至为0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void Main()
{
    Console.WriteLine(Get(4396, 8));
    Console.ReadKey();
}

public static int Get(int value, int i)
{
    var stack = new Stack&amp;lt;int&amp;gt;();
    while (value != 0)
    {
        stack.Push(value % i);
        value /= i;
    }
    return int.Parse(string.Join(&quot;&quot;, stack));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;括号匹配&quot;&gt;括号匹配&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;圆括号、方括号和花括号可以任意嵌套&lt;/li&gt;
&lt;li&gt;正确格式：{{90[]}}(4)&lt;/li&gt;
&lt;li&gt;错误格式：{2(1}1)[3]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果时&lt;code&gt;(&lt;/code&gt;,&lt;code&gt;[&lt;/code&gt;,&lt;code&gt;{&lt;/code&gt; 则入栈&lt;/li&gt;
&lt;li&gt;如果时&lt;code&gt;)&lt;/code&gt;,&lt;code&gt;]&lt;/code&gt;,&lt;code&gt;}&lt;/code&gt; 则将对应左边括号弹出栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void Main()
{
    Console.WriteLine(Check(&quot;{abc[1](2)}sss(aaa)[({})]&quot;));
    Console.ReadKey();
}

public static bool Check(string str)
{
    var stack = new Stack&amp;lt;char&amp;gt;();
    foreach (var c in str)
    {
        switch (c)
        {
            case '(':
            case '{':
            case '[':
                stack.Push(c);
                break;
            case ')':
                if (stack.Count == 0 || stack.Pop() != '(')
                {
                    return false;
                }
                else
                {
                    break;
                }
            case '}':
                if (stack.Count == 0 || stack.Pop() != '{')
                {
                    return false;
                }
                else
                {
                    break;
                }
            case ']':
                if (stack.Count == 0 || stack.Pop() != '[')
                {
                    return false;
                }
                else
                {
                    break;
                }
        }
    }
    return stack.Count == 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;中缀转后缀表达式求职&quot;&gt;中缀转后缀表达式求职&lt;/h2&gt;
&lt;p&gt;运算规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从左算到右&lt;/li&gt;
&lt;li&gt;先乘除，后加减&lt;/li&gt;
&lt;li&gt;先括号内，后括号外&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相邻两个操作符优先级判断如下：&lt;/p&gt;
&lt;p&gt;c1表示前一个操作符，c2表示后一个操作符&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分操作数栈和操作符栈&lt;/li&gt;
&lt;li&gt;操作数进操作数栈&lt;/li&gt;
&lt;li&gt;当前操作符优先级大于顶栈操作符则入栈&lt;/li&gt;
&lt;li&gt;当前操作符优先级小于顶栈操作符，则弹出顶栈，弹出两个操作数运算，运算结果再入栈&lt;/li&gt;
&lt;li&gt;重复上一步骤，直至将当前操作符入栈&lt;/li&gt;
&lt;li&gt;若最后两栈都不为空，则依次弹出操作符与操作数计算，直至操作符栈为空，此时操作数栈剩一个元素即为最终结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void Main()
{
    Console.WriteLine(Calculation(&quot;(2+3)*2+2*(6-3)/(4-2)+2&quot;));
    Console.ReadKey();
}

public static int Calculation(string str)
{
    //操作数栈
    var opndStack = new Stack&amp;lt;int&amp;gt;();
    //操作符栈
    var optrStack = new Stack&amp;lt;char&amp;gt;();
    foreach (var c in str)
    {
        if (char.IsDigit(c))
        {
            //当前的字符是操作数
            opndStack.Push(int.Parse(c.ToString()));
        }
        else
        {
            //当前的字符是操作符
            while (optrStack.Count != 0)
            {
                var priority = Priority(optrStack.Peek(), c);
                if (priority == '&amp;lt;')
                {
                    //栈顶优先级小与当前操作符
                    //入栈
                    optrStack.Push(c);
                    break;
                }
                if (priority == '=')
                {
                    //栈顶优先级等于当前操作符
                    //就是左右括号匹配，弹出左括号
                    optrStack.Pop();
                    break;
                }

                if (priority != '&amp;gt;')
                {
                    continue;
                }
                //栈顶优先级大于当前操作符
                //需要计算
                var optr = optrStack.Pop();
                var value2 = opndStack.Pop();
                var value1 = opndStack.Pop();
                opndStack.Push(Operate(value1, optr, value2));
            }
            //1.第一次栈为空直接入栈。
            //2.退栈直至为空当前操作符也需要入栈,但&quot;)&quot;无需入栈
            if (optrStack.Count == 0 &amp;amp;&amp;amp; c != ')')
            {
                optrStack.Push(c);
            }
        }
    }
    while (optrStack.Count != 0)
    {
        var optr = optrStack.Pop();
        var value2 = opndStack.Pop();
        var value1 = opndStack.Pop();
        opndStack.Push(Operate(value1, optr, value2));
    }
    return opndStack.Count == 1 ? opndStack.Pop() : 0;
}

public static int Operate(int value1, char optr, int value2)
{
    switch (optr)
    {
        case '+':
            return value1 + value2;
        case '-':
            return value1 - value2;
        case '*':
            return value1 * value2;
        case '/':
            return value1 / value2;
    }
    return 0;
}

/// &amp;lt;summary&amp;gt;
/// 比较栈顶操作符与当前操作符优先级
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;c1&quot;&amp;gt;栈顶操作符&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;c2&quot;&amp;gt;当前操作符&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static char Priority(char c1, char c2)
{
    switch (c1)
    {
        case '+':
        case '-':
            if (c2 == '+' || c2 == '-' || c2 == ')')
            {
                return '&amp;gt;';
            }
            return '&amp;lt;';
        case '*':
        case '/':
            if (c2 == '(')
            {
                return '&amp;lt;';
            }
            return '&amp;gt;';
        case '(' when c2 == ')':
            return '=';
        case '(':
            return '&amp;lt;';
        case ')':
            return '&amp;gt;';
    }
    return '&amp;gt;';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gavin_john/article/details/71374487&quot;&gt;栈的应用&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:31:00 +0000</pubDate>
<dc:creator>见风任然是风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunven/p/9320803.html</dc:identifier>
</item>
<item>
<title>吴恩达《深度学习》第四门课（2）卷积神经网络：实例探究 - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9320781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9320781.html</guid>
<description>&lt;h2&gt;2.1为什么要进行实例探究&lt;/h2&gt;
&lt;p&gt;（1）就跟学编程一样，先看看别人怎么写的，可以模仿。&lt;/p&gt;
&lt;p&gt;（2）在计算机视觉中一个有用的模型，，用在另一个业务中也一般有效，所以可以借鉴。&lt;/p&gt;
&lt;p&gt;（3）本周会介绍的一些卷积方面的经典网络经典的包括：LeNet、AlexNet、VGG；流行的包括：ResNet、Inception，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716191626433-201470186.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2经典网络&lt;/h2&gt;
&lt;p&gt;（1）LeNet-5网络结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716192543643-1801814313.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在LeNet-5中的一些注意点：网络输入单通道的，大概有6万个参数，池化用的是平均池化而不是最大值池化，还没有用到padding，输出也不是现在的softmax，激活函数用的是sigmoid和tanh。综上可以看出来许多设置在今天看来都是不合适的了，说明网络在发展。&lt;/p&gt;
&lt;p&gt;（3）AlexNet网络结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716193736937-444964175.png&quot; alt=&quot;&quot; width=&quot;755&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）AlexNet与LeNet-5有非常多相似之处，但前者的网络更深更大，参数达到6000万，同时使用了Relu激活函数。&lt;/p&gt;
&lt;p&gt;（5）VGG-16网络结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716194509367-294382132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）VGG-16网络的说明：16代表卷积层加全连接层一共16层，图中的×2表示连续两次相同的卷积，所有卷积padding都是用了same，卷积核的个数都是成倍增加，而高宽刚好对半减小，真个网络非常简洁优美，网络参数非常多达到了1.38亿各参数，在今天看来依旧是非常大的网络。&lt;/p&gt;
&lt;h2&gt;2.3残差网络（Residual Networks（ResNets））&lt;/h2&gt;
&lt;p&gt;（1）一般正常的网络会进行如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716195835438-1200529521.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）然后将a&lt;sup&gt;[l]&lt;/sup&gt;传到下下层的激活函数之前，即进行如下计算，就得到了残差块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716200008278-1729473424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）以下是一个有五个残差块的网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716200118550-604451682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）残差网络克服了网络很深时存在的梯度消失或爆炸的问题。&lt;/p&gt;
&lt;p&gt;（5）下图展示了普通网络和残差网络随着网络深度训练误差的变化，普通网络由于网络很深之后难以训练所以训练误差变大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716200316667-1737086612.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.4残差网络有什么用&lt;/h2&gt;
&lt;p&gt;（1）因为残差网络很容易学习恒等式函数，所以随着网络加深，至少不会让网络变差。如下图中添加了两层，使用Relu激活函数，当W&lt;sup&gt;[l+2]&lt;/sup&gt;，b&lt;sup&gt;[l+2]&lt;/sup&gt;都为0时，输出还是和不添加这两层的结果一样，都是a&lt;sup&gt;[l]&lt;/sup&gt;，这就是学习恒等式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716201446846-1304452453.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）另个一需要讨论的问题就是维度匹配问题，当z&lt;sup&gt;[l+2]&lt;/sup&gt;和a&lt;sup&gt;[l]&lt;/sup&gt;相同时，可以直接相加，如果不同时需要在让a&lt;sup&gt;[l]&lt;/sup&gt;与矩阵W&lt;sub&gt;s&lt;/sub&gt;相乘，W&lt;sub&gt;s&lt;/sub&gt;的维度为（a&lt;sup&gt;[l+2]&lt;/sup&gt;,a&lt;sup&gt;[l]&lt;/sup&gt;），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716202154239-647863084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.5网络中的网络以及1×1卷积&lt;/h2&gt;
&lt;p&gt;（1）1×1计算示意图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716203948829-1770915622.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）作用：首先相当于把一个点的所有通道进行了全连接操作；其次是起到压缩通道的作用（最重要的作用），或者保持不变，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716204135784-899670356.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.6谷歌Inception网路简介&lt;/h2&gt;
&lt;p&gt;（1）构建卷积层时，你要决定使用多大的卷积核（如1×1,3×3,5×5等）或者要不要添加池化层，而Inception网络的Inception层作用就是它将替你做决定。&lt;/p&gt;
&lt;p&gt;（2）下面就是一个典型的Inception模块的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716204938389-1433083838.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）用1×1卷积核来构建瓶颈层可以大大减少计算量：&lt;/p&gt;
&lt;p&gt;首先是没有添加1×1卷积核如下图所示，由于加法的运算次数和乘法运算次数接近，所以这里只求乘法的计算次数：（5*5*192）*（28*28*32）=1.2亿&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716205710627-632761065.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加了卷积核之后，如下图所示，整个的输入输出是没有发生改变的，乘法计算量为（1*1*16）*（28*28*16）+（5*5*16）*（28*28*32）=1240万。只有上面的十分之一。所以计算量减少了很多，同时只要合理构建，不会影响网络性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716210750759-349169354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.7Inception网络&lt;/h2&gt;
&lt;p&gt;（1）下面是Inception的一个单元，需要注意的是池化时保持尺寸不变，同时池化不能改变通道数导致通道特别多，所以在其后面添加了1×1卷积核压缩通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716211625519-2088264406.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）下面是一个完整的Inception网络，其中可以看到有一些分支，他们同样可以做最终输出预测，这样做是为了防止过拟合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716212212528-1370299601.png&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;388&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.8使用开源的实现方案&lt;/h2&gt;
&lt;p&gt;（1）在GitHub上找资源，然后在此基础上进行开发，会有更快的进展。&lt;/p&gt;
&lt;h2&gt;2.9迁移学习&lt;/h2&gt;
&lt;p&gt;（1）下载别人的模型，以前预训练的权重来初始化，同时将输出层根据自己的需要来修改，比如说分三种类别（已经包括其它了），那么输出为3个单元的sotfmax。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716213735936-724027002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）冻结别人训练好的参数，在深度学习框架中可能参数是trainableParameter=0，或者freeze=1等，视实际框架而定。&lt;/p&gt;
&lt;p&gt;（3）一个重要技巧是：数据量少时只训练最后一层，这时可以将图片输入，然后将最后一层前的输出存到硬盘中，因为这些值是不会改变的。然后在用这些值作为输入训练最后一层，这样不要每次都经过前面的网络，训练会大大加快。&lt;/p&gt;
&lt;p&gt;（4）当数据量越来越大时，从后往前可以训练更多的层，极端情况下是所有层的参数都参与训练。&lt;/p&gt;
&lt;h2&gt;2.10数据扩充&lt;/h2&gt;
&lt;p&gt;（1）镜像、随机裁剪、旋转、剪切、扭曲&lt;/p&gt;
&lt;p&gt;（2）色彩转换（如给一些通道加值）&lt;/p&gt;
&lt;p&gt;（3）在实际使用过程中可以使用多线程，一些线程从硬盘中取出数据，然后进行数据扩充，再传入其他线程进行训练，这样就可以并行实现了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716215125630-1757268258.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.11计算机视觉现状&lt;/h2&gt;
&lt;p&gt;（1）对于计算机视觉而言，其实当前的数据量是远远不够的，所以需要设计出一些更复杂的网络，以及人工去调整非常多的超参数，其本质都是因为数据量不够；假设数据量非常够的时候，网络也好，超参数也好都可以使用更简单的架构和调整。&lt;/p&gt;
&lt;p&gt;（2）再次强调多多使用迁移学习，站在巨人的肩膀上。另外如果要自己设计研究全新的网络可能需要自己从头开始训练。&lt;/p&gt;
&lt;p&gt;（3）为了在竞赛中取得好成绩，常常是以巨大的计算量为代价的（如用多个网络计算输出取平均），这在实际应用中不太实用。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:25:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9320781.html</dc:identifier>
</item>
<item>
<title>2018百度之星开发者大赛－paddlepaddle学习 - bobxx</title>
<link>http://www.cnblogs.com/bobxxxl/p/9320751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobxxxl/p/9320751.html</guid>
<description>&lt;p&gt;本次比赛赛题是进行人流密度的估计，因为之前看过很多人体姿态估计和目标检测的论文，隐约感觉到可以用到这次比赛上来，所以趁着现在时间比较多，赶紧报名参加了一下比赛，比赛规定用paddlepaddle来进行开发，所以最近几天先学习一下paddlepaddle的相关流程，在这里记录一下，也好让自己真正的能够学到东西。&lt;/p&gt;

&lt;p&gt;在我看来，设计一个深度学习网络（主要是基于CNN的，其他的没怎么接触），主要有以下几方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据的读取（这里主要是图片数据和它的“标签”）。&lt;/li&gt;
&lt;li&gt;数据的预处理（包含数据集增强和你需要的操作）。&lt;/li&gt;
&lt;li&gt;如何将你的数据送入网络。&lt;/li&gt;
&lt;li&gt;网络结构的设计（layer的使用）。&lt;/li&gt;
&lt;li&gt;损失函数的计算（这部分是根据你的任务决定的）。&lt;/li&gt;
&lt;li&gt;优化器的选择（我想一般是adam吧）&lt;a href=&quot;https://blog.csdn.net/u010089444/article/details/76725843&quot;&gt;这里&lt;/a&gt;有一篇博客分享了各种优化算法的不同。&lt;/li&gt;
&lt;li&gt;模型的存储以及加载（加载这部分其实挺重要的，之前看过一篇论文说应用ImageNet上预训练的模型进行迁移学习，往往能在新的任务上取得更好的效果，当然也不是绝对的）。&lt;/li&gt;
&lt;li&gt;如何进行测试（可以说就是如何进行前向传播）。&lt;/li&gt;
&lt;li&gt;可选：可视化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来就以上几部分进行学习，在次非常感谢&lt;a href=&quot;http://www.cnblogs.com/charlotte77/&quot;&gt;Charlotte77&lt;/a&gt;和&lt;a href=&quot;https://my.csdn.net/qq_33200967&quot;&gt;夜雨飘零1&lt;/a&gt;。他们的博文给予了我莫大的帮助，向大佬叩首。&lt;/p&gt;

&lt;p&gt;对于本次比赛来说，我的数据是图片（各种监控的图片，大小不同），标注是json格式的文件，所以接下来要讨论一下在paddlepaddle中如何以图片为输入。&lt;/p&gt;
&lt;p&gt;参见&lt;a href=&quot;https://www.cnblogs.com/charlotte77/p/7802226.html&quot;&gt;大佬Charlotte77的博文&lt;/a&gt;，paddlepaddle主要是通过reader来进行数据的输入，这里我参考了paddlepaddle github 上的&lt;a href=&quot;https://github.com/PaddlePaddle/models/tree/develop/fluid/object_detection&quot;&gt;SSD的例子&lt;/a&gt;的例子，先看他们的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;train_reader = paddle.batch(
    reader.train(data_args, train_file_list), batch_size=batch_size)
test_reader = paddle.batch(
    reader.test(data_args, val_file_list), batch_size=batch_size)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中reader是import来的，我们以reader.train来看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def train(settings, file_list, shuffle=True):
    file_list = os.path.join(settings.data_dir, file_list)
    if 'coco' in settings.dataset:
        train_settings = copy.copy(settings)
        if '2014' in file_list:
            sub_dir = &quot;train2014&quot;
        elif '2017' in file_list:
            sub_dir = &quot;train2017&quot;
        train_settings.data_dir = os.path.join(settings.data_dir, sub_dir)
        return coco(train_settings, file_list, 'train', shuffle)
    else:
        return pascalvoc(settings, file_list, 'train', shuffle)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里看得出来，是利用了之前定义的coco函数或者pascalvoc函数，就是从不同的数据集读取数据，以coco为例，看一下，到底返回了什么，&lt;a href=&quot;https://github.com/PaddlePaddle/models/blob/develop/fluid/object_detection/reader.py&quot;&gt;这里&lt;/a&gt;代码有点长，我们主要看返回的是什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
            if 'cocoMAP' in settings.ap_version:
                yield im, boxes, lbls, iscrowd, \
                    [im_id, im_width, im_height]
            else:
                yield im, boxes, lbls, iscrowd

    return reader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;balabala一大堆，终于发现，返回的是一个生成器reader，可见，主要就在于生成这个生成器，下面来总结一下padlepaddle输入数据的生成：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把你的数据（图片，标签）搞出来，然后用yield来产生一个生成器：reader。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;将此reader生成batch，也就是train_reader = paddle.batch(reader, batch_size=batch_size)这样子。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接下来就是送入网络了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面第三步就是将数据送入网络，这是如何办到的呢,用过tensorflow的童鞋们可能知道，我们可以用一个palceholder（占位符）来链接我们的原始数据和我们的网络，在这里，也是同样的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;image = fluid.layers.data(name='image', shape=image_shape, dtype='float32')
gt_box = fluid.layers.data(name='gt_box', shape=[4], dtype='float32', lod_level=1)
gt_label = fluid.layers.data(name='gt_label', shape=[1], dtype='int32', lod_level=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用的是fluid.layers.data，等一下，lod_level是啥，这里paddlepaddle有个序列输入格式，这里lod_level为１说明这条数据是序列格式，那为啥我们的图片不是序列格式？这里图片的size第一维应该就是batch_size,我们注意到后面的gt_box和gt_label没有制定第一维，他们就是一个向量或者整数，为啥不像tensorflow里面直接就指定第一维为batch_size?因为paddlepaddle输入数据格式里面没有QAQ!具体查看&lt;a href=&quot;https://www.cnblogs.com/charlotte77/p/7802226.html&quot;&gt;大佬Charlotte77的博文&lt;/a&gt;吧，这部分我在官网没找到...&lt;/p&gt;
&lt;p&gt;有了这个“占位符”之后，只需将我们之前的那个batch_size的train_reader feed进去就好了，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;feeder = fluid.DataFeeder(place=place, feed_list=[image, gt_box, gt_label])
if args.parallel:
    loss_v, = train_exe.run(fetch_list=[loss.name],feed=feeder.feed(data))#这里的data就是之前train_reader的数据，fetch_list就是要执行的operation的名称,feed的顺序就是上面feed_list指定的
else:
    loss_v, = exe.run(fluid.default_main_program(),
                      feed=feeder.feed(data),
                      fetch_list=[loss])
#train_exe和exe是之前定义的，类似与tensorflow的session(个人感觉，实际上还是不一样的)如下：
#exe = fluid.Executor(place)
#train_exe = fluid.ParallelExecutor(use_cuda=args.use_gpu, loss_name=loss.name)
#其中place为指定设备（CPU GPU）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，总结一下，如何将数据送入网络（在有了reader的前提下）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义一个“占位符”,也就是fluid.layers.data。&lt;/li&gt;
&lt;li&gt;定义一个feeder(fluid.DataFeeder),来指定设备和feed顺序。&lt;/li&gt;
&lt;li&gt;运用执行器（这个后面再说）的run,指定你需要运行的operation，然后feed数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里，我总是感觉paddlepaddle的fluid和tensorflow很像，先定义图模型，然后运行，但是看到官方说fluid是和TensorFlow Eager Execution很像，据我了解（没有用过，所以有可能是错误的，望批评指正）TensorFlow Eager Execution是针对之前tensoflow不能实时出结果（必须sess.run）来设计的，但是现在看好像不是很像，以后看懂了再来解释。留坑。&lt;/p&gt;

&lt;p&gt;这部分我们直接看代码吧，在SSD的例子中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;locs, confs, box, box_var = mobile_net(num_classes, image, image_shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了&lt;a href=&quot;https://github.com/PaddlePaddle/models/blob/develop/fluid/object_detection/mobilenet_ssd.py&quot;&gt;mobile_net模型&lt;/a&gt;，这个有兴趣自己看吧，主要是fluid.layers中各种层的应用，这个估计各个深度学习框架都差不多，这部分实现的还是挺全的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loss = fluid.layers.ssd_loss(locs, confs, gt_box, gt_label, box,box_var)
loss = fluid.layers.reduce_sum(loss)
...
optimizer = fluid.optimizer.RMSProp(
    learning_rate=fluid.layers.piecewise_decay(boundaries, values),
    regularization=fluid.regularizer.L2Decay(0.00005), )
optimizer.minimize(loss)
place = fluid.CUDAPlace(0) if args.use_gpu else fluid.CPUPlace()
exe = fluid.Executor(place)
exe.run(fluid.default_startup_program())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看这一部分，定义了loss，然后指定了优化器，然后最小化loss，指定设备，然后启动我们的程序。我感觉这里是个大坑！有没有发现有些文档里面不是这么个流程，而是这样子的（来源paddlepaddle &lt;a href=&quot;https://github.com/PaddlePaddle/book/blob/high-level-api-branch/03.image_classification/train.py&quot;&gt;03.image_classification&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;place = fluid.CUDAPlace(0) if use_cuda else fluid.CPUPlace()
trainer = fluid.Trainer(
    train_func=train_program, optimizer_func=optimizer_program, place=place)
trainer.train(
    reader=train_reader,
    num_epochs=EPOCH_NUM,
    event_handler=event_handler,
    feed_order=['pixel', 'label'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定了一个trainer然后调用train。&lt;/p&gt;
&lt;p&gt;还有&lt;a href=&quot;http://www.cnblogs.com/charlotte77/p/7906363.html&quot;&gt;一种&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parameters = paddle.parameters.create(cost)
trainer = paddle.trainer.SGD(cost=cost,
                             parameters=parameters,update_equation=momentum_optimizer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先根据cost(loss)产生要优化的参数，然后指定这些参数进行优化。&lt;/p&gt;
&lt;p&gt;这到底用哪一种呢？幸好有&lt;a href=&quot;https://blog.csdn.net/qq_33200967/article/details/79126897&quot;&gt;大佬夜雨飘零1&lt;/a&gt;的经验，是因为新版本Fluid的原因，现在大部分都是用executor来进行编写的。所以以后也不用烦恼了，这里吐槽一下官方文档，感觉维护人员要少吃一个鸡腿，不同版本变化太大，然而官方只给最新的示例，但是对于之前的代码并没有进行版本的说明，导致我们学习起来有点混乱，希望能够重新写一下book。&lt;/p&gt;

&lt;p&gt;这部分&lt;a href=&quot;http://paddlepaddle.org/docs/0.14.0/documentation/fluid/zh/new_docs/user_guides/howto/training/save_load_variables.html&quot;&gt;官方文档&lt;/a&gt;资料挺全的，当然对于大家比较关心的如何加载ImageNet 预训练模型，也是有的，&lt;a href=&quot;https://github.com/PaddlePaddle/models/tree/develop/image_classification&quot;&gt;这里&lt;/a&gt;有例子，但是说实话这里有点问题，大佬在&lt;a href=&quot;https://github.com/PaddlePaddle/Paddle/issues/9274&quot;&gt;这里&lt;/a&gt;也做了讨论，本来想参考官方文档进行resnet的加载，但是一方面官方脚本执行时连接不上，再看模型加载会出现各种问题，所以暂时放弃了这种想法，等一下官方的优化。&lt;/p&gt;
&lt;p&gt;这部分的主要代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exe = fluid.Executor(fluid.CPUPlace())
param_path = &quot;./my_paddle_model&quot;
prog = fluid.default_main_program()
fluid.io.save_params(executor=exe, dirname=param_path, main_program=None)
...
exe = fluid.Executor(fluid.CPUPlace())
param_path = &quot;./my_paddle_model&quot;
prog = fluid.default_main_program()
fluid.io.load_params(executor=exe, dirname=param_path,
                     main_program=prog)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见是通过fluid.io来实现的。&lt;/p&gt;

&lt;p&gt;这部分应该是paddlepaddle的优势了，一方面我们训练的过程中希望能够进行测试，一方面当我们的模型训练完以后我们也希望能够利用前向传播进行预测。paddlepaddle都有这两方面实现：第一种官方给了很好的示例，这里就不赘述了。对于第二种，paddlepaddle也进行了很好的封装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inferencer = fluid.Inferencer(
# infer_func=softmax_regression, # uncomment for softmax regression
# infer_func=multilayer_perceptron, # uncomment for MLP
infer_func=convolutional_neural_network,  # uncomment for LeNet5
param_path=params_dirname,
place=place)
results = inferencer.infer({'img': img})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;convolutional_neural_network就是你的模型里面生成predict的那个函数，params_dirname是保存参数的路径，可见，用paddlepaddle来进行前向传播十分简单，定义好数据之后，加载参数，然后调用infer就可以预测了。&lt;/p&gt;

&lt;p&gt;paddlepaddle还有很好的部署能力，但是局限于我现在用的功能，这部分并没有研究，这篇博客主要是串一下如何用paddlepadle搭建深度学习模型，其中有很多细节没有注意，而且有很多地方也不一定准确，希望各位多批评指正。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010089444/article/details/76725843&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u010089444/article/details/76725843&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/charlotte77/p/7802226.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/charlotte77/p/7802226.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/charlotte77/p/7906363.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/charlotte77/p/7906363.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PaddlePaddle/models/tree/develop/fluid/object_detection&quot; class=&quot;uri&quot;&gt;https://github.com/PaddlePaddle/models/tree/develop/fluid/object_detection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PaddlePaddle/book/blob/high-level-api-branch/03.image_classification/train.py&quot; class=&quot;uri&quot;&gt;https://github.com/PaddlePaddle/book/blob/high-level-api-branch/03.image_classification/train.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33200967/article/details/79126897&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_33200967/article/details/79126897&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://paddlepaddle.org/docs/0.14.0/documentation/fluid/zh/new_docs/user_guides/howto/training/save_load_variables.html&quot; class=&quot;uri&quot;&gt;http://paddlepaddle.org/docs/0.14.0/documentation/fluid/zh/new_docs/user_guides/howto/training/save_load_variables.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:16:00 +0000</pubDate>
<dc:creator>bobxx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobxxxl/p/9320751.html</dc:identifier>
</item>
<item>
<title>《前端之路》之四 JavaScript 的闭包、作用域、作用域链 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/9320050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/9320050.html</guid>
<description>&lt;h4 id=&quot;javascript-的闭包&quot;&gt;04：JavaScript 的闭包&lt;/h4&gt;
&lt;h5 id=&quot;一定义&quot;&gt;一、定义：&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;常规定义：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;闭包的定义： 有权利访问外部函数作用域的函数。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通俗定义：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、函数内部包含了函数。然后内部函数可以访问外部函数的作用域。
2、内部函数可以访问 父级函数的作用域。
...等等等&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;二思考&quot;&gt;二、思考：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;1、我们在日常的开发过程中会应用到 闭包么？
2、如果有遇到的话，会是在什么情况下遇到的？
3、举一些 具体的例子。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;1、我们在日常的开发过程中会应用到 闭包么？&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;以之前的知识对于 闭包的理解来讲是这样的&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
    (function(){
        for(var i=0; i&amp;lt;10; i++) {
            console.log(i)
        }
    })()
    &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;或者说是这样的&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
    var fnX = function() {
        var x = 123
        function y() {
            alert(x)
        }
        y()
    }

    fnX()   // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结下之前的理解就是： 内部函数能访问外部函数作用域，能够保存变量不被销毁而一直存在。&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;三作用&quot;&gt;三、作用：&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;在JavaScript中有作用域和执行环境的问题，在函数内部的变量在函数外部是无法访问的，在函数内部却可以得到全局变量。由于种种原因，我们有时候需要得到函数内部的变量，可是用常规方法是得不到的，这时我们就可以创建一个闭包，用来在外部访问这个变量。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;通过将一个方法或者属性声明为私用的，可以让对象的实现细节对其他对象保密以降低对象之间的耦合程度，可以保持数据的完整性并对其修改方式加以约束，这样可以是代码更可靠，更易于调试。封装是面向对象的设计的基石。&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&quot;什么是作用域&quot;&gt;3.1 什么是作用域&lt;/h6&gt;
&lt;h6 id=&quot;es5的作用域问题&quot;&gt;3.1.1 ES5的作用域问题&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;在 ES5 中 我们常常会说的一个概念是 局部变量 和 全局变量

那么 局部变量 和 全局变量 所这个 局部 和 全局则为 作用域。

这个概念其实介绍起来还是比较多虚无。 但是我记得有一本书 叫 《你不知道的JS》

在这本书的 上册 作者详细的介绍了 作用域 这个概念。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;作用域是什么&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　1.现代JavaScript已经不再是解释执行的，而是编译执行的。但是与传统的编译语言不同，它不是提前编译，编译结果不能进行移植。编译过程中，同样会经过分词／词法分析,解析／语法分析,代码生成三个阶段。

　　2.以var a = 2;语句为例，对这一程序语句对处理，需要经过引擎,编译器,作用域三者的配合。其中，引擎从头到尾负责整个javascript程序的编译和执行过程；编译器负责语法分析和代码生成；作用域负责收集并维护由所有声明的标识符组成的系列查询，并实施一套规则，确定当前执行的代码对这些标识符的访问权限。

　　3.对于var a = 2;编译器首先查找作用域中是否已经有该名称的变量，然后引擎中执行编译器生成的代码时，会首先查找作用域。如果找到就执行赋值操作，否则就抛出异常

　　4.引擎对变量的查找有两种：LHS查询和RHS查询。当变量出现中赋值操作左侧时是LHS查询，出现中右侧是RHS查询&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;词法作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.词法作用域就是定义在词法阶段的作用域。词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，词法处理器分析代码时会保持作用域不变

2.作用域查找会在找到第一个匹配的标识符时停止

3.eval和with可以欺骗词法作用域，不推荐使用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;函数作用域和块作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.JavaScript具有基于函数的作用域，属于这个函数的变量都可以在整个函数的范围内使用及复用
2.(function fun(){})() 函数表达式和函数声明的区别是看function关键字出现在声明中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式

3.with,try/catch具有块作用域，方便好用的实现块级作用域的是es6带来的let关键字&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;提升&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    1. 变量的提升
    2. 函数提升  （这里就不过多的赘述了）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;动态作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　1.词法作用域是一套引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生中代码的书写阶段

　　2.动态作用域让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式。eg:&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function foo(){ 
    console.log(a);  // 2 
} 
function bar(){ 
    var a = 3; 
    foo(); 
} 
var a = 2; 
bar(); &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，所以输出2；动态作用域不关心函数和作用域如何声明以及在何处声明，只关心从何处调用。换言之，作用域链是基于调用栈的，而不是代码中的作用域嵌套。如果以动态作用域来看，上面代码中执行时会输出3


　　3.JavaScript不具备动态作用域，但是this机制中某种程度上很像动态作用域，this关注函数如何调用。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;es6的作用域问题&quot;&gt;3.1.2 ES6的作用域问题&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;在 ES6 中 出现了块级作用域的概念

let const 在（） 内则 （）内的作用域 为 块级作用域。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;什么是执行环境&quot;&gt;3.2 什么是执行环境&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;执行环境 即为 当前作用域内的环境。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;什么是作用域链&quot;&gt;3.3 什么是作用域链&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;这个概念其实 也是比较虚的概念，不太好理解。但是一旦理解就不会忘记了。

所谓 链 其实就是链条， 将需要链接在一起的东西链接在一起（感觉说了一句废话）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;作用域链的通俗理解：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在函数内部作用域 通过 作用域链 可以访问 函数外部作用域 的属性或者方法。

一层层的 作用域链 往外走  到最后 则为 window 对象的全局作用域。

然后这一条条的 作用域链 就形成了一整条关联的链条。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;四具体案例的分析&quot;&gt;四、具体案例的分析:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;这里 我们举了一个栗子 🌰&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eg1:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name) {
    this.name = name
    this.getName = function() {
        return this.name
    }
}

var one = new Person('zhang')
one.getName() // zhang
one.name      // zhang

var two = new Person('wang')
two.getName() // wang
one.name      // wang
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;eg2:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name) {
    var _name = name
    this.getName = function() {
        return _name
    }
} 

var one = new Person('zhang')
one.getName() // zhang

var two = new Person('wang')
two.getName() // wang
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;eg1 vs eg2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这二个例子进行对比，虽然 都拿到了自己想要的 name 但是 eg1 的方式会比 eg2 获取 name 
的方式要多一个， 即为 作为对象的属性来 获取到 当前的 name （one.name）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;那如果 你想让你的 name 属性只能通过 getName 方法来获取，不希望有别的方法来获取 甚至是改变的话，那么 闭包 设置私有属性就是一个很安全的做法，那么这个时候闭包的作用就体现出来了。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%08%E4%B9%8B%E8%B7%AF/04%EF%BC%9AJavaScript%20%E9%97%AD%E5%8C%85.md&quot;&gt;Github地址，欢迎 Star&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 12:50:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/9320050.html</dc:identifier>
</item>
<item>
<title>设计模式（二十一）—— 状态模式 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9319827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9319827.html</guid>
<description>&lt;h2 id=&quot;模式简介&quot;&gt;模式简介&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某些情况下，一个对象的行为取决于它当前所处的状态，当对象属性(状态)在系统运行过程中发生变化，它呈现出的行为也随之发生改变。例如可调节亮度的台灯，假设灯光亮度分为三级，每次按下按钮，台灯会根据当前亮度增加一级，若已经是最亮的状态，按下按钮则关闭台灯。&lt;/p&gt;
&lt;h2 id=&quot;结构分析&quot;&gt;结构分析&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;uml类图&quot;&gt;UML类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180716185317034-1404098128.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色说明&quot;&gt;角色说明&lt;/h3&gt;
&lt;p&gt;环境类。客户端操作的类，包含一个IState类型的对象，保存其当前状态。&lt;/p&gt;
&lt;p&gt;状态接口。定义一个统一的接口以封装与Context的特定状态相关的行为。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConcreteState&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体状态。实现状态接口，表示Context某个状态相关的行为。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;Context类将与状态相关的请求委托给ConcreteState对象处理，并将自身以参数形式传递给ConcreteState对象，如此，便可以在处理完请求后访问Context的SetState方法为Context设置新的状态。&lt;/p&gt;
&lt;h3 id=&quot;结构代码&quot;&gt;结构代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//环境类
class Context
{
    private IState _state;
    public Context(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Initialize state -&amp;gt; {state}&quot;);
    }

    public void SetState(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Set State -&amp;gt; {state}&quot;);
    }

    public void Request()
    {
        _state.Handle(this);
    }
}

//状态接口
interface IState
{
    void Handle(Context context);
}

//具体状态类A
class ConcreteStateA : IState
{
    public void Handle(Context context)
    {
        context.SetState(new ConcreteStateB());
    }
}

//具体状态类B
class ConcreteStateB : IState
{
    public void Handle(Context context)
    {
        context.SetState(new ConcreteStateA());
    }
}

//客户端调用
static void Main(string[] args)
{
    Context context = new Context(new ConcreteStateA());
    for (int i = 0; i &amp;lt; 5; i++)
    {
        context.Request();
    }
    Console.ReadLine();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180716185605443-221284650.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例分析&quot;&gt;示例分析&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;本节模拟第一节中提到的台灯示例。首先创建台灯类Lamp，提供共有方法SetState设置当前状态，包含一个保存当前状态的私有字段_state，并通过Request方法调用该状态的下台灯发光的行为。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Lamp
{
    private IState _state;
    public Lamp(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Initialize state -&amp;gt; {state}&quot;);
    }
    public void SetState(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Set State -&amp;gt; {state}&quot;);
    }

    public void Request()
    {
        _state.Handle(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明状态接口，并分别实现具体状态类，这里包括四种状态Closed、Dim、Medium、Bright。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface IState
{
    void Handle(Lamp context);
}

class Closed : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Dim());
    }
}

class Dim : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Medium());
    }
}

class Medium : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Bright());
    }
}

class Bright : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Closed());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用，将台灯的初始状态设置为Closed，并连续调用，输出台灯状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        Lamp lamp = new Lamp(new Closed());
        for (int i = 0; i &amp;lt; 10; i++)
        {
            lamp.Request();
        }
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180716192012275-1447930891.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;hr/&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个操作中含有大量的分支的条件语句，且这些分支依赖于该对象的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 16 Jul 2018 12:05:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9319827.html</dc:identifier>
</item>
<item>
<title>从 Secure Element 到 Android KeyStore - 程序员赵鑫</title>
<link>http://www.cnblogs.com/xinzhao/p/9319419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinzhao/p/9319419.html</guid>
<description>&lt;p&gt;忽如一夜春风来，智能手机来到每个人的手上，我们用它支付、理财、娱乐、工作、记录生活、存储私密信息、乘坐公共交通、开启家门、控制汽车...。智能手机是如此的重要，不知天天把它拿在手上的你,是否关心过它是否足够安全。&lt;/p&gt;
&lt;p&gt;本文从Secure Element（安全单元）说起，介绍手机设备上若干重要的安全角色和概念。为后续文章介绍如何基于手机安全地实现认证、支付、DRM等业务流程打下基础。&lt;/p&gt;
&lt;h3 id=&quot;sesecure-element&quot;&gt;SE（Secure Element）&lt;/h3&gt;
&lt;p&gt;按照Global Platform的定义：安全单元提供私密信息的安全存储、重要程序的安全执行等功能。其内部组件包含有：CPU、RAM、ROM、加密引擎、传感器等，大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/SEInternal.PNG&quot; alt=&quot;SecureElementInternal&quot;/&gt;&lt;/p&gt;
&lt;p&gt;外在表现上SE是一块物理上独立的芯片卡。从外在表现上可以分为三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UICC 通用集成电路卡，由电信运营商发布和使用。就是大家购买手机号时的手机SIM卡；&lt;/li&gt;
&lt;li&gt;Embedded SE 虽然也是独立的芯片，但普通用户看不到，由手机制造厂商在手机出厂前集成在手机内部；&lt;/li&gt;
&lt;li&gt;Micro SD 以SD存储卡的形式存在，通过插入SD卡槽集成到手机上。由独立的SE制造商制造和销售；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/SEShape.PNG&quot; alt=&quot;SecureElementShape&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SE物理上独立，采用安全协议与外部通讯。具有自己独立的执行环境和安全存储，软件和硬件上防篡改。软件通过签名等方式防篡改很多人都了解，说下硬件防篡改，简单说就是物理拆改SE，它会自毁。最简单的硬件防篡改的例子，大家可以参考大家给自己车安装车牌时所使用的单向螺丝和防盗帽。&lt;/p&gt;
&lt;p&gt;SE固若金汤，但保存在其中的数据和程序需要有更新机制，这通过TSM（Trusted Service Manager）来实现，以保证安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/TrustedServiceManager.PNG&quot; alt=&quot;TrustedServiceManager&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SE不年轻了从19世纪70年代就开始发展，但它十分安全，是目前手机上最安全的技术措施。&lt;/p&gt;
&lt;h3 id=&quot;nfcnear-field-communication&quot;&gt;NFC（Near-field Communication）&lt;/h3&gt;
&lt;p&gt;近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内，由非接触式射频识别（RFID，公交卡、校园一卡通、门禁卡等都采用RFID技术实现）演变而来，由飞利浦、诺基亚和索尼于2004年共同研制开发。目前已成为ISO/IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。&lt;/p&gt;
&lt;p&gt;NFC设备有三种工作模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。&lt;/li&gt;
&lt;li&gt;读卡器模式（Reader/Writer mode）：作为非接触读卡器使用，可用来实现给公交卡充值等功能。&lt;/li&gt;
&lt;li&gt;点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三种工作模式中，卡模拟模式用途最为广泛，可将用平时使用的各种卡通过手机模拟实现，从此出门不再带卡。此种方式下，NFC芯片通过非接触读卡器的RF域来供电，即便是手机没电也可以工作。&lt;/p&gt;
&lt;p&gt;NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全单元（Security Element, SE）以保存重要隐私数据。可以说NFC给SE插上了翅膀，在NFC广泛应用的今天，SE如此的重要，成为电信运营商（移动、联通、电信等）、手机厂商（华为、小米等）、操作系统厂商（谷歌、苹果等）的兵家必争之地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/NFC.PNG&quot; alt=&quot;NFC&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;hcehost-card-emulation&quot;&gt;HCE（Host Card Emulation）&lt;/h3&gt;
&lt;p&gt;因为不涉及硬件制造，在SE的竞争过程中，操作系统厂商相对弱势，确切的说是谷歌弱势，因为苹果既是操作系统厂商，也是手机厂商。&lt;/p&gt;
&lt;p&gt;早期Goole Pay是基于SE实现的，但由于在SE生态环境中弱势的竞争地位，导致Google Pay适配的机型少，难以发展。从Android 4.4开始，谷歌独辟蹊径在Android系统中提供了HCE服务，用来绕过SE直接控制NFC Controller。大概的模式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/HCE.PNG&quot; alt=&quot;HCE&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HCE不在依赖设备上的SE模块，只要有NFC芯片就可以实现支付等功能，但其实是无奈之举。方便是方便了，有两个主要缺点：一个是安全性有所降低，虽然可以使用白盒密码、服务端token校验等一系列手段来提升安全性，但相比SE，安全性降低到依赖Android OS，只要OS被攻破，HCE就无法保证安全；一个是费电，NFC Controller + SE的方案，可以在手机无电的情况下，使用NFC读卡器的电磁信号供电。而HCE则必须在手机供电，OS正常工作甚至还要联网的情况下才能使用。&lt;/p&gt;
&lt;p&gt;相对的，因为对设备有这强的控制力，苹果的Apple Pay是基于SE实现的，更安全一些。&lt;/p&gt;
&lt;h3 id=&quot;teetrusted-execution-environment&quot;&gt;TEE（Trusted Execution Environment）&lt;/h3&gt;
&lt;p&gt;SE千般好，除了慢。硬件隔离，独立的计算和存储资源，意味着SE的计算性能差、跟主机的数据传输速度也慢，这限制了SE的应用场景。与此同时，移动互联网发展迅速，迫切需要一个更好的安全生态。因此TEE应运而生。&lt;/p&gt;
&lt;p&gt;TEE是一个硬件安全执行环境，通常跟平时使用的Rich OS（Android等）共用同一个主处理器（CPU），提供了代码和数据的安全防护、外置设备的安全访问等功能。TEE具有自己的TEE OS，可以安装和卸载执行其中的安全应用TA（TEE Application）。跟SE相比，是一个相对不那么安全，但运行速度更快、功能更丰富的安全环境。为所有支持TEE的手机，提供了操作系统之外的安全方案。&lt;/p&gt;
&lt;p&gt;SE、TEE以及REE的对比：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;安全级别&lt;/td&gt;
&lt;td&gt;最高（硬件防篡改）&lt;/td&gt;
&lt;td&gt;高（硬件安全方案）&lt;/td&gt;
&lt;td&gt;普通&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;是否在主处理器执行&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是（极个别情况有独立处理器）&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;安全的外设访问&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;提供硬件证明&lt;/td&gt;
&lt;td&gt;一定程度上提供&lt;/td&gt;
&lt;td&gt;提供&lt;/td&gt;
&lt;td&gt;不提供&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;软件生态&lt;/td&gt;
&lt;td&gt;较差&lt;/td&gt;
&lt;td&gt;较好&lt;/td&gt;
&lt;td&gt;极好&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;TEE的内部API和外部API都由Global Platform定义和发布。TEE得到了业界广泛的支持，比如ARM在2006年就发布了ARM处理器下的TEE方案TrustZone，AMD、Intel、华为海思等，也有自己的TEE方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/TEE.PNG&quot; alt=&quot;TEE&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TEE广泛应用在支付、身份认证、内容保护等领域。举例来讲，视频厂商往往需要DRM（Digital rights management）系统来保护版权内容能够顺利得在用户设备上播放，而不被泄露。TEE天然适合用来完成这种需求，其安全存储的能力可以用来保存解密版权内容所需密钥，这样，TEE Application访问可信的服务端获取已加密的版权视频后，使用安全密钥解密，然后利用安全访问外置设备的能力，锁住显卡和声卡，将解密后的视频送往显卡和声卡播放。整个过程中，不管是加密密钥还是视频内容都没有离开过TEE，保护了版权视频的安全。尤其值得一提的，因其锁定外置设备的能力，想通过录屏来窃取内容，也是不可能的。&lt;/p&gt;
&lt;h3 id=&quot;android-fingerprint&quot;&gt;Android Fingerprint&lt;/h3&gt;
&lt;p&gt;Android设备的指纹识别，依赖TEE来实现用户指纹认证，要求指纹采集、注册和识别都必须在TEE内部进行，已保证安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/AndroidFingerprint.png&quot; alt=&quot;AndroidFingerprint&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;android-keystore&quot;&gt;Android KeyStore&lt;/h3&gt;
&lt;p&gt;Android从4.0开始引入了KeyStore，开发者可以使用KeyStore API生成密钥、使用密钥签名、使用密钥加解密、获取密钥的属性信息，但无法将密钥本身从KeyStore中取出。因为密钥不进入应用进程，这大大提高了密钥的安全性。随着Android版本更迭，KeyStore的实现不断进化得更加安全，在有些设备上，不仅密钥不进入应用进程，甚至不进入Android OS只存储在TEE或SE中，接下来我们大概列举下KeyStore的进化。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;创世版本，密钥使用用户的passcde加密后存储，支持RSA、ECDSA&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;增加了使用安全硬件的基础设施，在可能的情况下密钥会被存储到安全硬件中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;增加支持AES、HMAC；增加了密钥绑定用户认证的能力，即可以指定某些密钥，在每一次使用时，必须由用户进行认证（指纹、passcode等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;7.0&lt;/td&gt;
&lt;td&gt;强制要求预装7.0系统的设备必须拥有安全硬件并且支持基于安全硬件的KeyStore&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;增加了设备证明（Key Attestation）能力，开发者可通过验证Key Attestation的证书链，来确认密钥的确保存在了安全硬件中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;能被业界接受的，就是好方案。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 11:05:00 +0000</pubDate>
<dc:creator>程序员赵鑫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinzhao/p/9319419.html</dc:identifier>
</item>
<item>
<title>谈谈 JAVA 的对象序列化 - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/9318955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/9318955.html</guid>
<description>&lt;p&gt;所谓的『JAVA 对象序列化』就是指，将一个 JAVA 对象所描述的所有内容以文件 IO 的方式写入二进制文件的一个过程。关于序列化，主要涉及两个流，ObjectInputStream 和 ObjectOutputStream。&lt;/p&gt;
&lt;p&gt;很多人关于『序列化』的认知只停留在 readObject 和 writeObject 这两个方法的调用，但却不知道为什么 JAVA 能够从一个二进制文件中「还原」出来一个完整的 JAVA 对象，也不知道一个对象究竟是如何存储在二进制文件中的。&lt;/p&gt;
&lt;p&gt;本文会带大家分析二进制文件并结合序列化协议规则，去看看文件中的 JAVA 对象是个什么模样，可能枯燥，但一定会提高你对序列化的认知的。&lt;/p&gt;
&lt;h3 id=&quot;一种古老的序列化方式&quot;&gt;一种古老的序列化方式&lt;/h3&gt;
&lt;p&gt;在前面介绍字节流的相关文章中，我们简单提到过 DataInput/OutputStream 这个装饰者流，它允许我们以基本数据类型为输入，向文件进行写入和读出操作。&lt;/p&gt;
&lt;p&gt;看个例子：&lt;/p&gt;
&lt;p&gt;定义一个 People 类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMf1Rf.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍显复杂的 main 函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMfhJx.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这种古老的序列化方式其实就是使用流 DataInput/OutputStream 将对象中字段的值逐个的写入文件，完成所谓的『序列化操作』。&lt;/p&gt;
&lt;p&gt;恢复对象的时候也必须按照写入的顺序一个字段一个字段的读取，这种方式可以说非常的反人类了，如果一个类有一百个字段，岂不是得手动写入一百次。&lt;/p&gt;
&lt;p&gt;这种方式准确意义上来说并不能算作『序列化』的一种实现，它是一种伪序列化，大家知道一下就好了。&lt;/p&gt;
&lt;h3 id=&quot;java-标准序列化&quot;&gt;JAVA 标准序列化&lt;/h3&gt;
&lt;p&gt;之所以需要将一个对象序列化存储到磁盘目录中的一个原因就是，有些对象可能很重要但却占用不小的空间，往往一时半会还用不到，那么将它们放置内存中显然是一种浪费，而丢弃又将导致额外的操作来创建这些对象。&lt;/p&gt;
&lt;p&gt;所以，一种折中解决办法就是，先将这些对象序列化保存进文件，用的时候再从磁盘读取，而这就是『序列化』。&lt;/p&gt;
&lt;p&gt;想要序列化一个对象，JAVA 要求该类必须继承 「java.io.Serializable」接口，而 serializable 接口内并没有定义任何方法，它是一个「标记接口」。&lt;/p&gt;
&lt;p&gt;虚拟机执行序列化指令的时候会检查，要序列化的对象所对应的类型是否继承了 Serializable 接口，如果没有将拒绝执行序列化指令并抛出异常。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;java.io.NotSerializableException&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而序列化的一般用法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMTvfs.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;single
23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ObjectOutputStream 某种意义上来看也是一种装饰者流，内部所有的字节流操作都依赖我们构造实例时传入的 OutputStream 实例。&lt;/p&gt;
&lt;p&gt;这个类的实现很复杂，光内部类就定义了很多，同时它也封装了我们的 DataOutputStream，所以 DataOutputStream 那一套写基本数据类型的方法，这里也有。除此之外的是，它还提供了 DataOutputStream 没有的 writeObject 方法用于将一个继承 Serializable 接口的 Java 对象直接写入磁盘。&lt;/p&gt;
&lt;p&gt;当然，ObjectInputStream 是相反的，它用于从磁盘读取并恢复一个 Java 对象。&lt;/p&gt;
&lt;p&gt;writeObject 方法接受一个 Object 参数，并将该参数所代表的 Java 对象序列化进磁盘文件，这里会写入很多东西而不是简简单单的将字段的值写入文件，它是有一个参照格式的，就像我们编译器会按照一定的格式生成字节码文件一样。&lt;/p&gt;
&lt;p&gt;遵循同样的规则将会使得恢复起来很方便，下面我们来看看这个规则的具体内容。&lt;/p&gt;
&lt;h3 id=&quot;序列化的存储规则&quot;&gt;序列化的存储规则&lt;/h3&gt;
&lt;p&gt;上一小节我们序列化了一个 People 的实例对象到文件中，现在我们打开这个二进制文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMOVQs.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;序列化后的对象需要用这么多的二进制位进行存储，这些二进制位都是符合 JAVA 的序列化规则的，每几个字节用来存储什么都是规定好的，下面我们一起来看看。&lt;/p&gt;
&lt;p&gt;1、魔数：这个是几乎所有的二进制文件头部都有的，用于标识当前二进制文件的文件类型，我们的对象序列化文件的魔数是 &lt;strong&gt;AC ED&lt;/strong&gt;，占两个字节。&lt;/p&gt;
&lt;p&gt;2、序列化协议版本号：这指明 JAVA 采用什么样的序列化规则来生成二进制文件，这里是 &lt;strong&gt;00 05&lt;/strong&gt;，可能还有其他协议，一般都是 5 号协议。&lt;/p&gt;
&lt;p&gt;3、一个字节：接下来的一个字节用于描述当前的对象类型，&lt;strong&gt;0x73&lt;/strong&gt; 表示这是一个普通的 Java 对象，其他可选值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMOfk8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，字符串和数组类型并没有划分到普通的 Java 对象这一类中，它们具有不同的数值标志。我们这里的 People 是一个普通的 Java 对象，所以这里是 0x73 。&lt;/p&gt;
&lt;p&gt;4、一个字节：这一个字节指明当前的对象所属的数据类型，是一个类或者是一个引用，这里的引用区别于 Java 的引用指针。如果你对于同一个对象进行两次序列化，Java 不会重复写入文件，后者会保存为一个引用类型，有关这一点，待会再详细介绍。这里的 People 是一个类，所以这里的值就是，0x72 。&lt;/p&gt;
&lt;p&gt;5、类的全限定名长度：&lt;strong&gt;0x0017&lt;/strong&gt; 这两个字节描述了当前对象的全限定名称长度，所以接下来的 23 个字节是当前对象的全限定名称，经过换算，这 23 个字节表述的值为：TestSerializable.People。&lt;/p&gt;
&lt;p&gt;接着看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMvJyj.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、序列号版本：接下来的八个字节，&lt;strong&gt;3A -&amp;gt; B5&lt;/strong&gt; 描述的是当前类对象的序列化版本号，这个值由于我们定义的 People 类中没有显式指明，所以编译器会根据 People 类的相关信息以某种算法生成一个 serialVersionUID 占八个字节。&lt;/p&gt;
&lt;p&gt;7、序列化类型：一个字节，用于指明当前对象的序列化类型，&lt;strong&gt;0x02&lt;/strong&gt; 即代表当前对象可序列化。&lt;/p&gt;
&lt;p&gt;8、字段个数：两个字节，指明当前对象中需要被序列化的字段个数，我们这里是，&lt;strong&gt;0x0002&lt;/strong&gt;，对应的我们 name 和 age 这两个字段。&lt;/p&gt;
&lt;p&gt;接下来就是对字段的描述了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMxxV1.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、字段类型：一个字节，&lt;strong&gt;0x4C&lt;/strong&gt; 对应的 ASCII 值为 L，即表示当前字段的类型是一个普通类类型。&lt;/p&gt;
&lt;p&gt;10、字段名长度：两个字节，&lt;strong&gt;0x0003&lt;/strong&gt; 指明接下来的三个字节表述了当前字段的全名称，0x616765 正好对应字符 age。&lt;/p&gt;
&lt;p&gt;11、字段类型名：三个字节，&lt;strong&gt;0x740013&lt;/strong&gt; ，其中 0x74 是一个字段类型开始的标志，即每个描述字段类型名的三个字节里，前一个字节都是 0x74，后面两个字节描述了字段类型名称的长度，0x0013 对应 19。所以接着的 19 个字节表述当前字段的完整类型名称。这里算了一下，正好是，Ljava/lang/Integer;。&lt;/p&gt;
&lt;p&gt;接着就是描述我们的第二个字段 name，具体过程是类似，这里不再赘述，我们紧接着 name 字段之后继续介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PMzWRO.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12、字段描述结束符：一个字节，固定值 &lt;strong&gt;0x78&lt;/strong&gt; 标志所有的字段类型信息描述结束。&lt;/p&gt;
&lt;p&gt;13、父类类型描述：一个字节，&lt;strong&gt;0x70&lt;/strong&gt; 代表 null，即没有父类，不算 Object 类。&lt;/p&gt;
&lt;p&gt;接下来这一段其实是 Java 序列化一个 Integer 对象的过程，然后到 0x7872，即 Integer 类还有父类，于是又去序列化一个父类 Number 实例。为什么这么做，我想你应该清楚，每个子类对象的创建都会对应一个父类对象的创建。&lt;/p&gt;
&lt;p&gt;所以，直到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/15/PQpjbj.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一个 0x7870，说明所有的对象信息都已经序列化完成，下面是各个字段的数据部分。&lt;/p&gt;
&lt;p&gt;前四个字节，0x00000017 是我们第一个字段 age 的值，也就是 23 。0x74 指明第二个字段的类型是 String 类型，值的长度 0x0006，最后六个字节刚好是字符串 single。&lt;/p&gt;
&lt;p&gt;至此，整个序列化文件的格式我们已经全部介绍完成了，总结一下：&lt;/p&gt;
&lt;p&gt;整个序列化文件分为两个部分，字段类型描述和字段数据部分。其中，如果字段的类型是普通的 JAVA 类型的话，会继续序列化其父类对象，理解这一点很重要，像我们这个例子中，一共序列化了三个对象，分别是 People，Integer，Number 这三个对象，如果它们的字段有被外部赋值过，这些值也将此排序存储。&lt;/p&gt;
&lt;h3 id=&quot;序列化的几点高级认识&quot;&gt;序列化的几点高级认识&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;循环引用的序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑这样两个类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQGWfx.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQG41K.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个类的定义几乎就是相同的，内部都定义了一个 People 字段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQGRt1.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让 ClassA 和 ClassB 的两个对象公用同一个 People 实例，那么有一个问题，我去序列化这两个对象，这个公用的 People 对象会被序列化两次吗？&lt;/p&gt;
&lt;p&gt;我们打开二进制文件，这次的二进制文件要复杂一点了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQtzjK.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我圈出来了几个 0x7870，它标志着一个对象类型信息的序列化结束，我们简单分析一下，不会详细的说了，具体参照上面的内容。&lt;/p&gt;
&lt;p&gt;第一部分其实是在序列化 ClassA 类型，它指明了 ClassA 类型只有一个字段，并且该字段是一个对象类型，记录下字段的类型名称等信息。&lt;/p&gt;
&lt;p&gt;第二部分在序列化 People 类型，包括序列化其中的 name 字段，并存储了 name 字段的外部赋的值，字符串：single。&lt;/p&gt;
&lt;p&gt;第三部分，序列化 ClassB 类型，ClassB 的类型序列化相对 ClassA 要少一点，虽然它们内部具有相同的定义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQd454.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，阴影部分是 ClassB 类的全限定名，红线框是该类的版本序列号，由于我们没有显式指定，这是由编译器自动生成的。接着指明具有一个字段，字段类型是对象类型，名称长度六个字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0x71&lt;/strong&gt; 指明这个字段是一个引用，按惯例来说，这部分应该进行该字段的类型名称描述，但是由于这种类型已经序列化过了，所以使用引用直接指向前面已经完成序列化的 People 类型。&lt;/p&gt;
&lt;p&gt;最后一部分按惯例应该进行字段数据的描述，描述数据的类型，值的长度，以及值本身。但是由于我们 ClassB 类型的 people 字段值公用的 ClassA 的 people 字段值，所以虚拟机不会傻到重新序列化一遍该 people 对象，而是给出上面该 people 对象的引用编号。&lt;/p&gt;
&lt;p&gt;说了这么多，得出的结论是什么呢，如果你要序列化的多个对象中，有相同的类类型，Java 只会描述一次该类型，并且如果一份序列化文件中存在对同一对象的多次序列化，Java 也只会保存一份对象数据，后面的都用引用指向这里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定制序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于所有继承了 Serializable 接口的类而言，进行序列化时，虚拟机会序列化这些类中所有的字段，无视访问修饰符，但是有时候我们并不需要将所有的字段都进行序列化，而只是选择性的序列化其中的某些字段。&lt;/p&gt;
&lt;p&gt;我们只需要在不想序列化的字段前面使用 transient 关键字进行修饰即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private transient String name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即便你给你的对象的 name 字段赋值了，最终也不会被保存进文件中，当你反序列化的时候，这个对象的 name 字段依然是系统默认值 null。&lt;/p&gt;
&lt;p&gt;除此之外，JAVA 还允许我们重写 writeObject 或 readObject 来实现我们自己的序列化逻辑。&lt;/p&gt;
&lt;p&gt;但是这两个方法的声明必须是固定的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void writeObject(java.io.ObjectOutputStream s) 

private void readObject(java.io.ObjectInputStream s) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，它就是 private 修饰的，在你通过 ObjectOutputStream 的 writeObject 方法对某个对象进行序列化时，虚拟机会自动检测该对象所对应的类是否有以上两种方法的实现，如果有，将转而调用类中我们自定的该方法，放弃 JDK 所实现的相应方法。&lt;/p&gt;
&lt;p&gt;我们看个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQ6Jns.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;name 被关键字 transient 修饰，即默认的序列化机制不会序列化该字段，并且我们重写了 writeObject 和 readObject，在其中调用了默认的序列化方法之后，我们分别将 name 字段写入和读出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/07/16/PQ6aNV.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;single
20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有兴趣的同学可以自己去看看序列化后的二进制文件，其中是没有关于 name 字段的描述信息的，但是整个 people 对象描述之后，紧随其后的就是我们的字符 「single」。&lt;/p&gt;
&lt;p&gt;而反序列化的过程也是类似的，先按照 JDK 的默认反序列化机制反射生成一个 people 对象，再读取文件末尾的字符串赋值给当前 people 对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列化的版本问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列化的版本 ID，我们一直都有提到它，但是始终没有说明这个版本 ID 到底有什么用。用得好的可以拿来实现权限管理机制，用不好也可能导致你反序列化失败。&lt;/p&gt;
&lt;p&gt;JAVA 建议每个继承 Serializable 接口的类都应当定义一个序列化版本字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static final long serialVersionUID = xxxxL;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个值可以理解为是当前类型的一个唯一标识，每个对象在序列化时都会写入外部类型的这个版本号，反序列化时首先就会检查二进制文件中的版本号与目标类型中的版本号是否一样，如果不一样将拒绝反序列化。&lt;/p&gt;
&lt;p&gt;这个值不是必须的，如果你不提供，那么编译器将根据当前类的基本信息以某种算法生成一个唯一的序列号，可是如果你的类发生了一点点的改动，这个值就变了，已经序列化好的文件将无法反序列化了，因为你也不知道这个值变成什么了。&lt;/p&gt;
&lt;p&gt;所以，JAVA 建议我们都自己来定义这么一个版本号，这样你可以控制已经序列化的对象能否反序列化成功。&lt;/p&gt;
&lt;p&gt;至此，我们简单的介绍了序列化的相关内容，很多的都是结合着二进制文件进行描述的，可能枯燥，但是看完想必是能够提高你原先对于 JAVA 对象序列化的认知的。有什么问题，可以留言一起探讨交流 !&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章中的所有代码、图片、文件都云存储在我的 GitHub 上：&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/SingleYam/overview_java&quot; class=&quot;uri&quot;&gt;https://github.com/SingleYam/overview_java&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：OneJavaCoder，所有文章都将同步在公众号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/06/19/Czmcad.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 09:49:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/9318955.html</dc:identifier>
</item>
<item>
<title>记一次在 Ubutun16.04 LTS 系统的 python-environment 安装 MySQL-python 的心（苦）路（笑）旅程 - TonyZhang24</title>
<link>http://www.cnblogs.com/atuotuo/p/9318735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atuotuo/p/9318735.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前项目需要准备线啦， 那么好了~~ 数据库也从测试时使用的 SQLITE 升级到了 MYSQL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（高大上的免费且开源的关系型数据库，要不要了解一下！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716164109145-344353611.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;巧合的是，同事使用的是MySQL-python这个 lib来操作数据库，于是就促成了我在 python-env 中的安装 “坎坷路”&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;出现的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用pip 安装，直接就报错~~~ 废话少说，这接上图把：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716164528958-250312216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;于是，随着报错的提示，开始了网上搜索~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢在互联网上发帖的童鞋，我尝试了不下10几种方式，最终的结果是：！！没有搞定！！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了，此贴到此为止。 不不不！！ LZ从来都不是一个挖坑之人（栏坑王者）。 本着对人対己负责的态度。我们需要把这个问题解决掉！&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;解决方法&lt;/h2&gt;
&lt;h3&gt;1. 首先整理思路， 网上搜罗的结果就是缺少依赖包 “libmysql-dev” .&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;那么，我们首先先更新 apt-get&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;sudo&lt;/span&gt; apt-get update
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;让我们来安装这个依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libmysqlclient-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;遗憾的是，错误发生了，缺少依赖 zlib1g-dev&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716165701191-1359618731.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. 安装 zlib1g-dev&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; zlib1g-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;讨厌人的错误又出现啦！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716165835925-1010864607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注： 这次的问题是找到了依赖包但是版本不对&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 安装正确的 zlib1g&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; zlib1g=&lt;span&gt;1&lt;/span&gt;:&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.dfsg-2ubuntu4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 输入命令后，会出现提示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716170133934-1718491881.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照提示继续安装，一直到依赖安装完成！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716170243530-1729119144.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4. 再次安装 zlib1g-dev &lt;/h3&gt;
&lt;p&gt;这次安装可以正常进行啦~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716170359001-1963164918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5. 重新安装 libmysqlclient-dev&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libmysqlclient-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;依照提示，输入“y”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716170626569-223843817.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;6. 安装完所需要的依赖后，再安装 MySQL-python&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/396477/201807/396477-20180716171300933-1450413016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; OK， 到此终于搞定！！&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先，当问题出现时，我们需要快速定位问题 。 例如这里，我们找到问题是缺少依赖包；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，认真的，认真的，认真的（重要的事情 &quot;say 3 times&quot;）看错误提示，寻找出正确的包；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Lastly，感谢大家能抽出宝贵的时间来看看，欢迎个人看官留言及交流！！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Jul 2018 09:18:00 +0000</pubDate>
<dc:creator>TonyZhang24</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atuotuo/p/9318735.html</dc:identifier>
</item>
</channel>
</rss>