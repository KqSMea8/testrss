<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>STM32的时钟配置随笔 - 树荫下的阳光</title>
<link>http://www.cnblogs.com/wangshucai/p/9458109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshucai/p/9458109.html</guid>
<description>&lt;p&gt;　　以前使用STM32都是使用库函数开发，最近心血来潮想要使用寄存器来试试手感，于是乎便在工作之余研究了一下STM32F4的时钟配置，在此将经历过程写下来作为锻炼，同时也供和我一样的新手参考，如有错误或者更好的方法欢迎大家批评指正。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810232025214-366986574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                   从技术文档上得到STM32时钟源有三种， HSI 振荡器时钟 、HSE 振荡器时钟 、主 PLL时钟，由于每个时钟的工作特性的差异，若想将系统时钟设置为最高频时需使用PLL将基础时钟源进行倍频。&lt;/p&gt;
&lt;p&gt;由于使用外部晶振倍频精确度会比内部震荡时钟高很多，所以一般都是使用外部晶振，这跟我们使用库开发是一样的原理，所以一般的配置关键点大概如下图红框所示：&lt;/p&gt;
&lt;p&gt;                   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810232959582-1666063849.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、第一步首先要将外部HSE时钟打开，等待震荡稳定后再进行下一步操作。&lt;/p&gt;
&lt;p&gt;2、配置PLL寄存器参数。&lt;/p&gt;
&lt;p&gt;3、切换系统时钟源。&lt;/p&gt;

&lt;p&gt;第一步实现：&lt;/p&gt;
&lt;p&gt;依据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810233635609-176712394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          开启HSE时钟源主要是控制CR寄存器的16位，然后打开后硬件会自动将第17位置位，如果未成功则等待，当然在这个地方可以加入时间等待，如果超时说明打开失败，进行其他方法设置。&lt;/p&gt;
&lt;p&gt;          实现：&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810233838022-204794165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步实现：&lt;/p&gt;
&lt;p&gt; 依据：&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810234237106-1240631565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里技术文档上说明了各个参数的设置范围：&lt;/p&gt;
&lt;p&gt; 2 ≤ PLLQ  ≤ 15 、 PLLP = 2、4、6 或 8、 192 ≤ PLLN ≤ 432 、 2 ≤ PLLM ≤  63&lt;/p&gt;
&lt;p&gt;由于我想将STM32设置成最高频168M,于是根据以上参数范围以及计算方法，选择一组设置参数如下：&lt;/p&gt;
&lt;p&gt;PLL_M = 8，PLL_N  = 336，PLL_P  =  1  (2分频)，PLLQ  =  7;&lt;/p&gt;
&lt;p&gt;参数确定便可以直接设置，这些位只能在 PLL 已禁止时写入。&lt;/p&gt;
&lt;p&gt;实现：在这里记录一下自己的小心得，以前配置寄存器都是将要配置的数先算出来，耽误时间，今天在看技术文档时突然发现直接用移位即可，且为提高代码的可读性，最好是选用或运算单个设置每个设置点。这样看起来就舒服多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810234940565-1231503649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步实现：&lt;/p&gt;
&lt;p&gt; 依据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810235349798-1180723592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候就需要将系统时钟切换过来了，主要是设置SW开关，然后再设置AHB、APB1、APB2、等时钟，在上时钟树上可看出。&lt;/p&gt;
&lt;p&gt;还是操作对应的位，在这里又发现一个小技巧，原来STM32系统头文件已经做好这些设置的宏定义，直接使用即可，而且从可读性来说大大加强，如下图所示。最后将设置好的时钟通过MCO1输出，检测。&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180810235935003-2113932910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;整个时钟就到此配置结束，原以为会梦想成真，可实际却发现不尽人意，为啥波形没有呢，苦思冥想了很长时间，最后参考库函数底层实现方式，加了一句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180811000249407-2086513743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就完美输出，在这里我不是很理解为什么要添加这句，以前用msp430的时候好像也没这个设置，而且我发现光设置CPU等待周期还不行，还得设置前面两个参数，不然设置的时钟偏差很大。&lt;/p&gt;
&lt;p&gt;实际设置函数如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SystemClockInit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;    RCC-&amp;gt;CR |=&lt;span&gt; RCC_CR_HSEON;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(!(RCC-&amp;gt;CR &amp;amp;&lt;span&gt; RCC_CR_HSERDY)){}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;    RCC-&amp;gt;CR &amp;amp;= ~&lt;span&gt;RCC_CR_PLLON;   
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    RCC-&amp;gt;PLLCFGR = &lt;span&gt;0x00000000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PLL_M = 8，PLL_N = 336，PLL_P = 1  (2分频)&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;    RCC-&amp;gt;PLLCFGR |= &lt;span&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;   
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;    RCC-&amp;gt;PLLCFGR |= &lt;span&gt;336&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;   
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    RCC-&amp;gt;PLLCFGR |= &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt;    RCC-&amp;gt;PLLCFGR |= &lt;span&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置PLLQ为48M   &lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    RCC-&amp;gt;CR |=&lt;span&gt; RCC_CR_PLLON;  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(!(RCC-&amp;gt;CR &amp;amp;&lt;span&gt; RCC_CR_PLLRDY)){}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;        
&lt;span&gt;19&lt;/span&gt;    FLASH-&amp;gt;ACR = FLASH_ACR_ICEN | FLASH_ACR_DCEN | &lt;span&gt;FLASH_ACR_LATENCY_5WS;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      
&lt;span&gt;21&lt;/span&gt;    RCC-&amp;gt;CFGR |= RCC_CFGR_HPRE_DIV1;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不分频使AHB时钟为168M&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;    RCC-&amp;gt;CFGR |= RCC_CFGR_PPRE2_DIV2;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;APB2 = 84M&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;    RCC-&amp;gt;CFGR |= RCC_CFGR_PPRE1_DIV4;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;APB1 = 42M   &lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;  
&lt;span&gt;25&lt;/span&gt;    RCC-&amp;gt;CFGR |=&lt;span&gt; RCC_CFGR_SWS_PLL;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;    RCC-&amp;gt;CFGR |=&lt;span&gt; RCC_CFGR_SW_PLL;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;          
&lt;span&gt;28&lt;/span&gt;    RCC-&amp;gt;CFGR |= &lt;span&gt;3 &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;21&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PLL输出&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;    RCC-&amp;gt;CFGR |= &lt;span&gt;4 &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2分频     &lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;   
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后两分频的波形显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180811000740131-1384043886.jpg&quot; alt=&quot;&quot; width=&quot;1423&quot; height=&quot;1068&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此配置就结束了，留有一个问题，那就是STM32时钟配置为啥要配置那个CPU等待周期，也就是这条语句：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1252227/201808/1252227-20180811000249407-2086513743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 欢迎大神不吝赐教，下方留言解答，万分感谢。&lt;/p&gt;

</description>
<pubDate>Fri, 10 Aug 2018 16:14:00 +0000</pubDate>
<dc:creator>树荫下的阳光</dc:creator>
<og:description>以前使用STM32都是使用库函数开发，最近心血来潮想要使用寄存器来试试手感，于是乎便在工作之余研究了一下STM32F4的时钟配置，在此将经历过程写下来作为锻炼，同时也供和我一样的新手参考，如有错误或者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshucai/p/9458109.html</dc:identifier>
</item>
<item>
<title>JDK常用命令行工具(基于JDK10) - GoldArowana</title>
<link>http://www.cnblogs.com/noKing/p/9457541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noKing/p/9457541.html</guid>
<description>&lt;p&gt;虽然我是在jdk10环境下, 但是大体上和jdk8是差不多的. 总共有这么多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810235802963-1656631411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本来想着一口气把所有命令都边学边总结一下的, 结果发现....有些还真的不是很常用....或者说我这个水平还接触不到那么多.  于是我就把我能使用到的几个常用的总结一下了.  当做是笔记了.&lt;/p&gt;
&lt;h2&gt;jshell&lt;/h2&gt;
&lt;h3&gt;jshell启动&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810221937931-1024367249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jshell退出&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810233257364-1374663836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jshell使用&lt;/h3&gt;
&lt;p&gt;就想python一样, 可以每一行代码都返回一个交互结果. 编写短小的程序来运行的时候, 就不用新建项目, 然后新建一个类了...可以直接上核心代码了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810233902283-1515851944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810233906916-1378105911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810233911898-1383961818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;还以为我从此以后不再需要计算器了&lt;/h3&gt;
&lt;p&gt;java的jshell计算大数的时候如下:(果然不出所料...失望..)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180811001103554-1188480890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么解决呢? 肯定是因为默认数字都是Integer型. 只好手动调用BigInteger了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180811001142429-273519904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;jcmd&lt;/h2&gt;
&lt;h3&gt;jcmd -h  输出jcmd的帮助信息.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810202032641-2000781999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd -l   打印出所有jvm进程信息.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810202137722-228977831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色圈出来的数字是pid, 也就是进程id&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; PerfCounter.print  性能统计信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810202413960-1902125437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810202426581-619188125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; help    列出可执行的进程操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810202908884-890646374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810202953500-108667178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; VM.version   看JVM版本信息&lt;/h3&gt;
&lt;p&gt;从上面一小节的截图中咱们挑一个执行一下. 比如 倒数第二行的VM.version&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810203023385-1104041829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就利用了VM.version操作打印出了JDK虚拟机的版本.&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; GC.class_histogram  查看系统中类统计信息&lt;/h3&gt;
&lt;p&gt;(和这个命令是一个效果 jmap -histo &amp;lt;pid&amp;gt;  )&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810210652663-107428054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; VM.uptime    查看 JVM 的启动时长&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810210841274-958810316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; Thread.print   查看线程堆栈信息&lt;/h3&gt;
&lt;p&gt;(等同于这个命令:   jstack &amp;lt;pid&amp;gt; )&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810211148068-69033386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; GC.run   对JVM执行System.gc()&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810211533964-144642901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; VM.system_properties  查看JVM的系统配置信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810211734922-373758586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jcmd &amp;lt;pid&amp;gt; VM.flags  查看JVM的启动参数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810212120712-399446553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;jhsdb命令&lt;/h2&gt;
&lt;p&gt;这个命令是jdk9之后才开始有的&lt;/p&gt;
&lt;h3&gt;jhsdb hsdb&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810213248272-647287544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这命令会打开图形界面. 看起来很高大上的样子...这个还有待学习....看知乎上R大介绍过, 学习学习.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810213421343-320778134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jhsdb jmap --heap --pid &amp;lt;pid&amp;gt;&lt;/h3&gt;
&lt;p&gt;查看heap的信息，GC使用的算法，heap的配置. (原来的jmap -heap 命令没有了, 被这个命令代替了)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810215533706-1554300717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;jmap&lt;/h2&gt;
&lt;h3&gt;jmap -dump:live,format=b,file=dump.hprof &amp;lt;pid&amp;gt;  输出堆信息到文件.&lt;/h3&gt;
&lt;p&gt;live指的是活着的对象, 如果不指定, 那么就会输出所有对象的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810214912546-745448038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jmap -heap &amp;lt;pid&amp;gt;  heap的信息，GC使用的算法，heap的配置&lt;/h3&gt;
&lt;p&gt;jdk10 里发现不支持-heap了. 被前面的  `jhsdb jmap --heap --pid &amp;lt;pid&amp;gt;`  这个命令替代了.&lt;/p&gt;
&lt;h3&gt;jmap -finalizerinfo &amp;lt;pid&amp;gt;   打印等待回收的对象信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810215817354-685285586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出这个说明没有&lt;code&gt;F-QUEUE队列中并没有等待Fializer线程执行final&lt;/code&gt;&lt;code&gt;izer方法的对象&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;jmap -histo:live &amp;lt;pid&amp;gt;  打印堆的对象统计&lt;/h3&gt;
&lt;p&gt;(作用和这个命令相同   jcmd &amp;lt;pid&amp;gt; GC.class_histogram   )&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810220051028-1347312020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; jmap -clstats &amp;lt;pid&amp;gt;  类加载器统计信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810220439844-125134398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;jps&lt;/h2&gt;
&lt;h3&gt;jps 显示jvm进程id及name&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810221110079-374044254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jps -q 仅显示进程id&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810221156714-1662667867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jps -m  显示主函数传入的参数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810221303259-1967154522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jps -l  显示全限定名&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810221414315-289228401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;jps -v  显示jvm参数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810221507814-832933861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;jstack &lt;/h2&gt;
&lt;h3&gt;jstack &amp;lt;pid&amp;gt;  查看线程堆栈信息&lt;/h3&gt;
&lt;p&gt;(等同于这个命令 jcmd &amp;lt;pid&amp;gt; Thread.print)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180810234800565-1402807102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;jstat &lt;/h2&gt;
&lt;p&gt;jstat这里讲的更详细:  &lt;a href=&quot;https://blog.csdn.net/zhaozheng7758/article/details/8623549&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zhaozheng7758/article/details/8623549&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 15:58:00 +0000</pubDate>
<dc:creator>GoldArowana</dc:creator>
<og:description>JDK命令行工具, JDK10</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noKing/p/9457541.html</dc:identifier>
</item>
<item>
<title>Python网络编程（子进程的创建与处理、简单群聊工具） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9458056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9458056.html</guid>
<description>
&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;昨天我们已经了解了多进程的原理以及它的实际使用&lt;/p&gt;
&lt;blockquote readability=&quot;10.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;Unix/Linux操作系统提供了一个&lt;code&gt;fork()&lt;/code&gt;系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;但是&lt;code&gt;fork()&lt;/code&gt;调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;子进程永远返回&lt;code&gt;0&lt;/code&gt;，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;父进程要记下每个子进程的ID，而子进程只需要调用&lt;code&gt;getppid()&lt;/code&gt;就可以拿到父进程的ID。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;Python的&lt;code&gt;os&lt;/code&gt;模块封装了常见的系统调用，其中就包括&lt;code&gt;fork&lt;/code&gt;，可以在Python程序中轻松创建子进程&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然是进程那么就会有运行和退出&lt;/p&gt;
&lt;p&gt;接下来我们就来了解一下进程的退出以及处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;孤儿进程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    当&lt;strong&gt;父进程&lt;/strong&gt;优&lt;strong&gt;先&lt;/strong&gt;于子进程&lt;strong&gt;退出&lt;/strong&gt;，此时&lt;strong&gt;子进程&lt;/strong&gt;就会&lt;strong&gt;成为孤儿进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;特征：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         &lt;strong&gt;孤儿进程会被系统指定进程收养&lt;/strong&gt;，即&lt;strong&gt;系统进程&lt;/strong&gt;会&lt;strong&gt;成为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这个孤儿进程&lt;strong&gt;新的父进程&lt;/strong&gt;，系统进程&lt;strong&gt;会自动处理&lt;/strong&gt;进程&lt;strong&gt;退出状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;僵尸进程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    当&lt;strong&gt;子进程&lt;/strong&gt;优&lt;strong&gt;先&lt;/strong&gt;于父进程&lt;strong&gt;退出&lt;/strong&gt;，&lt;strong&gt;父进程没&lt;/strong&gt;有&lt;strong&gt;处理&lt;/strong&gt;子进程的&lt;strong&gt;退出状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    此时子进程&lt;strong&gt;就会成为僵尸进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; 僵尸进程会滞留&lt;/strong&gt;部分&lt;strong&gt;PCB&lt;/strong&gt;信息&lt;strong&gt;在内存中&lt;/strong&gt;，大量的僵尸进程&lt;strong&gt;会消耗系统&lt;/strong&gt;给的&lt;strong&gt;内存资源&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;    所以要&lt;strong&gt;尽量避免僵尸进程&lt;/strong&gt;的产生&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何避免僵尸进程的产生：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1.&lt;strong&gt;父进程先退出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    2.父进程&lt;strong&gt;处理子进程状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;PID，status = os.&lt;span&gt;wait&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt; 功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         在父进程中&lt;strong&gt;阻塞等待&lt;/strong&gt;处理&lt;strong&gt;子进程的退出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;返回值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;           &lt;strong&gt;pid&lt;/strong&gt; ：退出的那个&lt;strong&gt;子进程&lt;/strong&gt;的&lt;strong&gt;PID&lt;/strong&gt;号&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; status &lt;/strong&gt;：子进程的&lt;strong&gt;退出状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      获取原来的退出状态：&lt;/p&gt;
&lt;p&gt;            &lt;strong&gt; wait（status）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      pid，status = os.&lt;span&gt;waitpid&lt;/span&gt;（pid，option）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          功能：在父进程阻塞&lt;strong&gt;等待处理子进程&lt;/strong&gt;的退出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;          参数 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                    pid   &lt;strong&gt;-1 &lt;/strong&gt;表示等待任意子进程退出 &lt;/p&gt;
&lt;p&gt;                            &lt;strong&gt;&amp;gt;0&lt;/strong&gt; 表示等待对应PID号的子进程退出 option &lt;/p&gt;
&lt;p&gt;                             &lt;strong&gt;  0&lt;/strong&gt; 表示阻塞等待 WNOHANG 表示非阻塞 &lt;/p&gt;
&lt;p&gt;          &lt;strong&gt;返回值：pid &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                        退出的那个&lt;strong&gt;子进程的PID&lt;/strong&gt;号 status 子进程的退出状态 &lt;/p&gt;


&lt;p&gt;&lt;strong&gt;创建二级子进程&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;父进程创建子进程等待进程退出&lt;/li&gt;
&lt;li&gt;子进程创建下一个进程，然后立即退出&lt;/li&gt;
&lt;li&gt;二级子进程成为孤儿进程  处理具体工作&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;multiprocessing&lt;/strong&gt;&lt;/span&gt;  模块创建进程&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;  1.需要&lt;strong&gt;将要做的事情&lt;/strong&gt;封装&lt;strong&gt;为函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  2.使用multiprocessing提供的&lt;strong&gt;process 创建进程&lt;/strong&gt;对象&lt;/p&gt;
&lt;p&gt;  3.通过进程对象和process初始化进程进行&lt;strong&gt;进程的设置&lt;/strong&gt;，&lt;strong&gt;绑定函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  4.&lt;strong&gt;启动进程&lt;/strong&gt;，会&lt;strong&gt;自动执行绑定的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  5&lt;strong&gt;.完成进程&lt;/strong&gt;的回收&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建进程对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;span&gt; process（）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     功能：&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt; 创建进程对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;target&lt;/strong&gt;：&lt;strong&gt;函数&lt;/strong&gt;对象&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;name &lt;/strong&gt;给&lt;strong&gt;进程&lt;/strong&gt;新&lt;strong&gt;名&lt;/strong&gt;称（）&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;args&lt;/strong&gt;：&lt;strong&gt;元组&lt;/strong&gt; 用来给target&lt;strong&gt;函数位置传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;kwargs&lt;/strong&gt;：&lt;strong&gt;字典 &lt;/strong&gt;用来给target&lt;strong&gt;函数键值传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   p.start（）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     功能：&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;启动进程&lt;/strong&gt;，&lt;strong&gt;自动运行&lt;/strong&gt;terget&lt;strong&gt;绑定函数，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       此时&lt;strong&gt;进程被创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;&lt;span&gt; p.join（[timeout]）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     功能：&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt; 等待阻塞子进程退出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt; 参数：超时检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     如果&lt;strong&gt;不使用join回收可能&lt;/strong&gt;后&lt;strong&gt;产生僵尸进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;strong&gt;multiprocessing创建&lt;/strong&gt;进程子进程&lt;strong&gt;同样复制&lt;/strong&gt;父进程的&lt;strong&gt;全部内存空间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;之后&lt;strong&gt;有&lt;/strong&gt;自己的&lt;strong&gt;独立空间&lt;/strong&gt; &lt;strong&gt;执行&lt;/strong&gt;上&lt;strong&gt;互不干扰&lt;/strong&gt; 子进程也&lt;strong&gt;有自己的PID&lt;/strong&gt;特有&lt;strong&gt;资源等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;multiprocessing&lt;/strong&gt;创建子进程，&lt;strong&gt;一般父进程功能就是创建&lt;/strong&gt;子进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回收子进程&lt;/strong&gt;，&lt;strong&gt;返回事件&lt;/strong&gt;交给子进程完成&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;






&lt;p&gt;简单群聊：&lt;/p&gt;

&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;p&gt;  类似QQ群聊&lt;/p&gt;
&lt;p&gt;  1.进入聊天室需要输入姓名 姓名不能重复&lt;/p&gt;
&lt;p&gt;  2.有人进入聊天室会向其他人发起通知  xxx进入聊天室&lt;/p&gt;
&lt;p&gt;  3.如果一个人发消息则其他人都能收到  xxx说：...&lt;/p&gt;
&lt;p&gt;  4.如果某个人退出聊天室也会收到通知  xxx退出聊天室&lt;/p&gt;
&lt;p&gt;  5.服务端可以喊话：此时群里所有的都能收到服务端消息  管理员说：...&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;服务器端：&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; * 
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os, sys


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送管理员消息&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_child(s, addr):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;管理员消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C 管理员 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; msg
        s.sendto(msg.encode(), addr)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户登录&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_login(s, user, name, addr):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name &lt;span&gt;in&lt;/span&gt; user) &lt;span&gt;or&lt;/span&gt; name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;管理员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        s.sendto(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该用户已存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.encode(), addr)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    s.sendto(b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, addr)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通知所有人&lt;/span&gt;
    msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n欢迎 %s 进入聊天室&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
        s.sendto(msg.encode(), user[i])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 插入user&lt;/span&gt;
    user[name] =&lt;span&gt; addr


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_chat(s, user, name, data):
    msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n{} 说: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name, data)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i !=&lt;span&gt; name:
            s.sendto(msg.encode(), user[i])


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_quit(s, user, name):
    msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n%s 离开了聊天室&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i ==&lt;span&gt; name:
            s.sendto(b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;EXIT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, user[i])
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            s.sendto(msg.encode(), user[i])
    &lt;/span&gt;&lt;span&gt;del&lt;/span&gt; user[name]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除离开的用户&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收客户端请求并处理&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_parent(s):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于存储用户 {'Alex':('127.0.0.1',8888)}&lt;/span&gt;
    user =&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg, addr &lt;/span&gt;= s.recvfrom(1024&lt;span&gt;)
        msgList &lt;/span&gt;= msg.decode().split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msgList[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            do_login(s, user, msgList[&lt;/span&gt;1&lt;span&gt;], addr)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; msgList[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &quot;C Levi [I miss you]&quot;&lt;/span&gt;
            data = &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(msgList[2&lt;span&gt;:])
            do_chat(s, user, msgList[&lt;/span&gt;1&lt;span&gt;], data)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; msgList[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            do_quit(s, user, msgList[&lt;/span&gt;1&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建套接字，网络连接，创建父子进程&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; server address&lt;/span&gt;
    ADDR = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 8888&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建套接字&lt;/span&gt;
    s =&lt;span&gt; socket(AF_INET, SOCK_DGRAM)
    s.setsockopt(SOL_SOCKET, SO_REUSEADDR, &lt;/span&gt;1&lt;span&gt;)
    s.bind(ADDR)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建父子进程&lt;/span&gt;
    pid =&lt;span&gt; os.fork()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid &amp;lt;&lt;span&gt; 0:
        sys.exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建进程失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; pid ==&lt;span&gt; 0:
        do_child(s, ADDR)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        do_parent(s)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;客户端：&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; * 
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys, os


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login(s, ADDR):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        name &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户名:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; name
        s.sendto(msg.encode(), ADDR)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收登录结果&lt;/span&gt;
        data, addr = s.recvfrom(1024&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; data.decode() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@进入聊天室@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data.decode())


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送消息&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_child(s, name, addr):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        text &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发言(quit退出):&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; text.strip() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Q &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; name
            s.sendto(msg.encode(), addr)
            sys.exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出聊天室&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C %s %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name, text)
        s.sendto(msg.encode(), addr)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收消息&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_parent(s):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg, addr &lt;/span&gt;= s.recvfrom(1024&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; msg.decode() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;EXIT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            sys.exit(0)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(msg.decode() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n发言(quit退出):&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,end=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; main控制套接字的创建&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(sys.argv) &amp;lt; 3&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argv is error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    HOST &lt;/span&gt;= sys.argv[1&lt;span&gt;]
    PORT &lt;/span&gt;= int(sys.argv[2&lt;span&gt;])
    ADDR &lt;/span&gt;=&lt;span&gt; (HOST, PORT)

    s &lt;/span&gt;=&lt;span&gt; socket(AF_INET, SOCK_DGRAM)

    name &lt;/span&gt;=&lt;span&gt; login(s, ADDR)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; name:
        pid &lt;/span&gt;=&lt;span&gt; os.fork()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid &amp;lt;&lt;span&gt; 0:
            sys.exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;创建子进程失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; pid ==&lt;span&gt; 0:
            do_child(s, name, ADDR)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            do_parent(s)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Fri, 10 Aug 2018 15:45:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<og:description>前言： 昨天我们已经了解了多进程的原理以及它的实际使用 Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次， Unix/Linux操作系统提供了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9458056.html</dc:identifier>
</item>
<item>
<title>JavaScript中常见的十五种设计模式 - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9451129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9451129.html</guid>
<description>&lt;p&gt;在程序设计中有很多实用的设计模式，而其中大部分语言的实现都是基于“类”。&lt;/p&gt;
&lt;p&gt;在JavaScript中并没有类这种概念，JS中的函数属于一等对象，在JS中定义一个对象非常简单（var obj = {}），而基于JS中闭包与弱类型等特性，在实现一些设计模式的方式上与众不同。&lt;/p&gt;
&lt;p&gt;本文基于&lt;a href=&quot;https://book.douban.com/subject/26382780/&quot; target=&quot;_blank&quot;&gt;《JavaScript设计模式与开发实践》&lt;/a&gt;一书，用一些例子总结一下JS常见的设计模式与实现方法。文章略长，自备瓜子板凳~&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;设计原则&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单一职责原则（SRP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。&lt;/p&gt;
&lt;p&gt;应该把对象或方法划分成较小的粒度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最少知识原则（LKP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个软件实体应当 尽可能少地与其他实体发生相互作用 &lt;/p&gt;
&lt;p&gt;应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开放-封闭原则（OCP）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改&lt;/p&gt;
&lt;p&gt;当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;什么是设计模式&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;作者的这个说明解释得挺好&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习设计模式，有助于写出可复用和可维护性高的程序&lt;/p&gt;
&lt;p&gt;设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构。&lt;/p&gt;
&lt;p&gt;不过要注意，使用不当的话，可能会事倍功半。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o1&quot; target=&quot;_parent&quot;&gt;一、单例模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o2&quot; target=&quot;_parent&quot;&gt;二、策略模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o3&quot; target=&quot;_parent&quot;&gt;三、代理模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o4&quot; target=&quot;_parent&quot;&gt;四、迭代器模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o5&quot; target=&quot;_parent&quot;&gt;五、发布—订阅模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o6&quot; target=&quot;_parent&quot;&gt;六、命令模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o7&quot; target=&quot;_parent&quot;&gt;七、组合模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o8&quot; target=&quot;_parent&quot;&gt;八、模板方法模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o9&quot; target=&quot;_parent&quot;&gt;九、享元模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o10&quot; target=&quot;_parent&quot;&gt;十、职责链模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o11&quot; target=&quot;_parent&quot;&gt;十一、中介者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o12&quot; target=&quot;_parent&quot;&gt;十二、装饰者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o13&quot; target=&quot;_parent&quot;&gt;十三、状态模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o14&quot; target=&quot;_parent&quot;&gt;十四、适配器模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/imwtr/p/9451129.html#o15&quot; target=&quot;_parent&quot;&gt;十五、外观模式&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span/&gt;&lt;span&gt;一、单例模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确保只有一个实例，并提供全局访问&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设要设置一个管理员，多次调用也仅设置一次，我们可以使用闭包缓存一个内部变量来实现这个单例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetManager(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.manager =&lt;span&gt; name;
}

SetManager.prototype.getName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.manager);
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; SingletonSetManager = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; manager = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;manager) {
            manager &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SetManager(name);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; manager;
    } 
})();

SingletonSetManager(&lt;/span&gt;'a').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
SingletonSetManager('b').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
SingletonSetManager('c').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是比较简单的做法，但是假如我们还要设置一个HR呢？就得复制一遍代码了&lt;/p&gt;
&lt;p&gt;所以，可以改写单例内部，实现地更通用一些&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提取出通用的单例&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getSingleton(fn) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;instance) {
            instance &lt;/span&gt;= fn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再进行调用，结果还是一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取单例&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; managerSingleton = getSingleton(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; manager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SetManager(name);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; manager;
});

managerSingleton(&lt;/span&gt;'a').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
managerSingleton('b').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
managerSingleton('c').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时，我们添加HR时，就不需要更改获取单例内部的实现了，仅需要实现添加HR所需要做的，再调用即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetHr(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hr =&lt;span&gt; name;
}

SetHr.prototype.getName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hr);
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hrSingleton = getSingleton(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SetHr(name);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hr;
});

hrSingleton(&lt;/span&gt;'aa').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aa&lt;/span&gt;
hrSingleton('bb').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aa&lt;/span&gt;
hrSingleton('cc').getName(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者，仅想要创建一个div层，不需要将对象实例化，直接调用函数&lt;/p&gt;
&lt;p&gt;结果为页面中仅有第一个创建的div&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPopup(html) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.createElement('div'&lt;span&gt;);
    div.innerHTML &lt;/span&gt;=&lt;span&gt; html;
    document.body.append(div);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; div;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; popupSingleton = getSingleton(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = createPopup.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; div;
});

console.log(
    popupSingleton(&lt;/span&gt;'aaa'&lt;span&gt;).innerHTML,
    popupSingleton(&lt;/span&gt;'bbb'&lt;span&gt;).innerHTML,
    popupSingleton(&lt;/span&gt;'bbb'&lt;span&gt;).innerHTML
); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aaa  aaa  aaa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;二、策略模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将算法的使用和算法的实现分离开来。&lt;/p&gt;
&lt;p&gt;一个基于策略模式的程序至少由两部分组成：&lt;/p&gt;
&lt;p&gt;第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。&lt;/p&gt;
&lt;p&gt;第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明Context 中要维持对某个策略对象的引用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;策略模式可以用于组合一系列算法，也可用于组合一系列业务规则&lt;/p&gt;
&lt;p&gt;假设需要通过成绩等级来计算学生的最终得分，每个成绩等级有对应的加权值。我们可以利用对象字面量的形式直接定义这个组策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加权映射关系&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; levelMap =&lt;span&gt; {
    S: &lt;/span&gt;10&lt;span&gt;,
    A: &lt;/span&gt;8&lt;span&gt;,
    B: &lt;/span&gt;6&lt;span&gt;,
    C: &lt;/span&gt;4&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组策略&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; scoreLevel =&lt;span&gt; {
    basicScore: &lt;/span&gt;80&lt;span&gt;,

    S: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.basicScore + levelMap['S'&lt;span&gt;]; 
    },

    A: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.basicScore + levelMap['A'&lt;span&gt;]; 
    },

    B: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.basicScore + levelMap['B'&lt;span&gt;]; 
    },

    C: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.basicScore + levelMap['C'&lt;span&gt;]; 
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getScore(level) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; scoreLevel[level] ? scoreLevel[level]() : 0&lt;span&gt;;
}

console.log(
    getScore(&lt;/span&gt;'S'&lt;span&gt;),
    getScore(&lt;/span&gt;'A'&lt;span&gt;),
    getScore(&lt;/span&gt;'B'&lt;span&gt;),
    getScore(&lt;/span&gt;'C'&lt;span&gt;),
    getScore(&lt;/span&gt;'D'&lt;span&gt;)
); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 90 88 86 84 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在组合业务规则方面，比较经典的是表单的验证方法。这里列出比较关键的部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误提示&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; errorMsgs =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: '输入数据格式不正确'&lt;span&gt;,
    minLength: &lt;/span&gt;'输入数据长度不足'&lt;span&gt;,
    isNumber: &lt;/span&gt;'请输入数字'&lt;span&gt;,
    required: &lt;/span&gt;'内容不为空'&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 规则集&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; rules =&lt;span&gt; {
    minLength: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value, length, errorMsg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value.length &amp;lt;&lt;span&gt; length) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; errorMsg || errorMsgs['minLength'&lt;span&gt;]
        }
    },
    isNumber: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value, errorMsg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/\d+/&lt;span&gt;.test(value)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; errorMsg || errorMsgs['isNumber'&lt;span&gt;];
        }
    },
    required: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value, errorMsg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value === ''&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; errorMsg || errorMsgs['required'&lt;span&gt;];
        }
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 校验器&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Validator() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.items =&lt;span&gt; [];
};

Validator.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: Validator,
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加校验规则&lt;/span&gt;
    add: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value, rule, errorMsg) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arg =&lt;span&gt; [value];

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rule.indexOf('minLength') !== -1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp = rule.split(':'&lt;span&gt;);
            arg.push(temp[&lt;/span&gt;1&lt;span&gt;]);
            rule &lt;/span&gt;= temp[0&lt;span&gt;];
        }

        arg.push(errorMsg);

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.items.push(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行校验&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; rules[rule].apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arg);
        });
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始校验&lt;/span&gt;
    start: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.items.length; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items[i]();
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret) {
                console.log(ret);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return ret;&lt;/span&gt;
&lt;span&gt;            }
        }
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试数据&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testTel(val) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; val;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Validator();

validate.add(testTel(&lt;/span&gt;'ccc'), 'isNumber', '只能为数字'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只能为数字&lt;/span&gt;
validate.add(testTel(''), 'required'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内容不为空&lt;/span&gt;
validate.add(testTel('123'), 'minLength:5', '最少5位'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最少5位&lt;/span&gt;
validate.add(testTel('12345'), 'minLength:5', '最少5位'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret =&lt;span&gt; validate.start();

console.log(ret);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4. 优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以有效地避免多重条件语句，将一系列方法封装起来也更直观，利于维护&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;往往策略集会比较多，我们需要事先就了解定义好所有的情况&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、代理模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为一个对象提供一个代用品或占位符，以便控制对它的访问&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当客户不方便直接访问一个 对象或者不满足需要的时候，提供一个替身对象 来控制对这个对象的访问，客户实际上访问的是 替身对象。&lt;/p&gt;
&lt;p&gt;替身对象对请求做出一些处理之后， 再把请求转交给本体对象&lt;/p&gt;
&lt;p&gt;代理和本体的接口具有一致性，本体定义了关键功能，而代理是提供或拒绝对它的访问，或者在访问本体之前做一 些额外的事情&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理模式主要有三种：保护代理、虚拟代理、缓存代理&lt;/p&gt;
&lt;p&gt;保护代理主要实现了访问主体的限制行为，以过滤字符作为简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主体，发送消息&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sendMsg(msg) {
    console.log(msg);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理，对消息进行过滤&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; proxySendMsg(msg) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无消息则直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; msg === 'undefined'&lt;span&gt;) {
        console.log(&lt;/span&gt;'deny'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有消息则进行过滤&lt;/span&gt;
    msg = ('' + msg).replace(/泥\s*煤/g, ''&lt;span&gt;);

    sendMsg(msg);
}


sendMsg(&lt;/span&gt;'泥煤呀泥 煤呀'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 泥煤呀泥 煤呀&lt;/span&gt;
proxySendMsg('泥煤呀泥 煤'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 呀&lt;/span&gt;
proxySendMsg(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; deny&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的意图很明显，在访问主体之前进行控制，没有消息的时候直接在代理中返回了，拒绝访问主体，这数据保护代理的形式&lt;/p&gt;
&lt;p&gt;有消息的时候对敏感字符进行了处理，这属于虚拟代理的模式&lt;/p&gt;

&lt;p&gt;虚拟代理在控制对主体的访问时，加入了一些额外的操作&lt;/p&gt;
&lt;p&gt;在滚动事件触发的时候，也许不需要频繁触发，我们可以引入函数节流，这是一种虚拟代理的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数防抖，频繁操作中不处理，直到操作完成之后（再过 delay 的时间）才一次性处理&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; debounce(fn, delay) {
    delay &lt;/span&gt;= delay || 200&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arg =&lt;span&gt; arguments;
          
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次操作时，清除上次的定时器&lt;/span&gt;
&lt;span&gt;        clearTimeout(timer);
        timer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义新的定时器，一段时间后进行操作&lt;/span&gt;
        timer = setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arg);
        }, delay);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = 0&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主体&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; scrollHandle(e) {
    console.log(e.type, &lt;/span&gt;++count); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; scroll&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; proxyScrollHandle = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; debounce(scrollHandle, 500&lt;span&gt;);
})();

window.onscroll &lt;/span&gt;= proxyScrollHandle;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;缓存代理可以为一些开销大的运算结果提供暂时的缓存，提升效率&lt;/p&gt;
&lt;p&gt;来个栗子，缓存加法操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主体&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; add() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arg =&lt;span&gt; [].slice.call(arguments);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; arg.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
    });
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; proxyAdd = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arg = [].slice.call(arguments).join(','&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有，则直接从缓存返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cache[arg]) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[arg];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = add.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
        }
    };
})();

console.log(
    add(&lt;/span&gt;1, 2, 3, 4&lt;span&gt;),
    add(&lt;/span&gt;1, 2, 3, 4&lt;span&gt;),

    proxyAdd(&lt;/span&gt;10, 20, 30, 40&lt;span&gt;),
    proxyAdd(&lt;/span&gt;10, 20, 30, 40&lt;span&gt;)
); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10 10 100 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;四、迭代器模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JS中数组的map forEach 已经内置了迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[1, 2, 3].forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item, index, arr) {
    console.log(item, index, arr);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过对于对象的遍历，往往不能与数组一样使用同一的遍历代码&lt;/p&gt;
&lt;p&gt;我们可以封装一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; each(obj, cb) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; value;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Array.isArray(obj)) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; obj.length; ++&lt;span&gt;i) {
            value &lt;/span&gt;=&lt;span&gt; cb.call(obj[i], i, obj[i]);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value === &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj) {
            value &lt;/span&gt;=&lt;span&gt; cb.call(obj[i], i, obj[i]);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value === &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}

each([&lt;/span&gt;1, 2, 3], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index, value) {
    console.log(index, value);
});

each({a: &lt;/span&gt;1, b: 2}, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index, value) {
    console.log(index, value);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0 1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 1 2&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2 3&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a 1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; b 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看一个例子，强行地使用迭代器，来了解一下迭代器也可以替换频繁的条件语句&lt;/p&gt;
&lt;p&gt;虽然例子不太好，但在其他负责的分支判断情况下，也是值得考虑的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getManager() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getFullYear();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (year &amp;lt;= 2000&lt;span&gt;) {
        console.log(&lt;/span&gt;'A'&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (year &amp;gt;= 2100&lt;span&gt;) {
        console.log(&lt;/span&gt;'C'&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'B'&lt;span&gt;);
    }
}

getManager(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将每个条件语句拆分出逻辑函数，放入迭代器中迭代&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; year2000() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getFullYear();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (year &amp;lt;= 2000&lt;span&gt;) {
        console.log(&lt;/span&gt;'A'&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; year2100() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getFullYear();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (year &amp;gt;= 2100&lt;span&gt;) {
        console.log(&lt;/span&gt;'C'&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; year() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getFullYear();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (year &amp;gt; 2000 &amp;amp;&amp;amp; year &amp;lt; 2100&lt;span&gt;) {
        console.log(&lt;/span&gt;'B'&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; iteratorYear() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; arguments.length; ++&lt;span&gt;i) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret =&lt;span&gt; arguments[i]();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
        }
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; manager = iteratorYear(year2000, year2100, year); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;五、发布-订阅模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。&lt;/p&gt;
&lt;p&gt;与传统的发布-订阅模式实现方式（将订阅者自身当成引用传入发布者）不同，在JS中通常使用注册回调函数的形式来订阅&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JS中的事件就是经典的发布-订阅模式的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅&lt;/span&gt;
document.body.addEventListener('click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'click1'&lt;span&gt;);
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

document.body.addEventListener(&lt;/span&gt;'click', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'click2'&lt;span&gt;);
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布&lt;/span&gt;
document.body.click(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; click1  click2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自己实现一下&lt;/p&gt;
&lt;p&gt;小A在公司C完成了笔试及面试，小B也在公司C完成了笔试。他们焦急地等待结果，每隔半天就电话询问公司C，导致公司C很不耐烦。&lt;/p&gt;
&lt;p&gt;一种解决办法是 AB直接把联系方式留给C，有结果的话C自然会通知AB&lt;/p&gt;
&lt;p&gt;这里的“询问”属于显示调用，“留给”属于订阅，“通知”属于发布&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 观察者&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; observer =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅集合&lt;/span&gt;
&lt;span&gt;    subscribes: [],

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅&lt;/span&gt;
    subscribe: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(type, fn) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscribes[type]) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subscribes[type] =&lt;span&gt; [];
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收集订阅者的处理&lt;/span&gt;
        &lt;span&gt;typeof&lt;/span&gt; fn === 'function' &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscribes[type].push(fn);
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布  可能会携带一些信息发布出去&lt;/span&gt;
    publish: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type =&lt;span&gt; [].shift.call(arguments),
            fns &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscribes[type];
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在的订阅类型，以及订阅时未传入处理回调的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!fns || !&lt;span&gt;fns.length) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 挨个处理调用&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; fns.length; ++&lt;span&gt;i) {
            fns[i].apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        }
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除订阅&lt;/span&gt;
    remove: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(type, fn) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除全部&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; type === 'undefined'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subscribes =&lt;span&gt; [];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fns = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscribes[type];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在的订阅类型，以及订阅时未传入处理回调的&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!fns || !&lt;span&gt;fns.length) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; fn === 'undefined'&lt;span&gt;) {
            fns.length &lt;/span&gt;= 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 挨个处理删除&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; fns.length; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fns[i] ===&lt;span&gt; fn) {
                fns.splice(i, &lt;/span&gt;1&lt;span&gt;);
            }
        }
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅岗位列表&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; jobListForA(jobs) {
    console.log(&lt;/span&gt;'A'&lt;span&gt;, jobs);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; jobListForB(jobs) {
    console.log(&lt;/span&gt;'B'&lt;span&gt;, jobs);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A订阅了笔试成绩&lt;/span&gt;
observer.subscribe('job'&lt;span&gt;, jobListForA);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B订阅了笔试成绩&lt;/span&gt;
observer.subscribe('job'&lt;span&gt;, jobListForB);


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A订阅了笔试成绩&lt;/span&gt;
observer.subscribe('examinationA', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(score) {
    console.log(score);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B订阅了笔试成绩&lt;/span&gt;
observer.subscribe('examinationB', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(score) {
    console.log(score);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A订阅了面试结果&lt;/span&gt;
observer.subscribe('interviewA', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result) {
    console.log(result);
});

observer.publish(&lt;/span&gt;'examinationA', 100); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 100&lt;/span&gt;
observer.publish('examinationB', 80); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;
observer.publish('interviewA', '备用'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 备用&lt;/span&gt;
&lt;span&gt;
observer.publish(&lt;/span&gt;'job', ['前端', '后端', '测试']); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出A和B的岗位&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B取消订阅了笔试成绩&lt;/span&gt;
observer.remove('examinationB'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A都取消订阅了岗位&lt;/span&gt;
observer.remove('job'&lt;span&gt;, jobListForA);

observer.publish(&lt;/span&gt;'examinationB', 80); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有可匹配的订阅，无输出&lt;/span&gt;
observer.publish('job', ['前端', '后端', '测试']); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出B的岗位&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4. 优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一为时间上的解耦，二为对象之间的解耦。可以用在异步编程中与MV*框架中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销&lt;/p&gt;
&lt;p&gt;弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、命令模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系&lt;/p&gt;
&lt;p&gt;命令（command）指的是一个执行某些特定事情的指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令中带有execute执行、undo撤销、redo重做等相关命令方法，建议显示地指示这些方法名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单的命令模式实现可以直接使用对象字面量的形式定义一个命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; incrementCommand =&lt;span&gt; {
    execute: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; something&lt;/span&gt;
&lt;span&gt;    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过接下来的例子是一个自增命令，提供执行、撤销、重做功能&lt;/p&gt;
&lt;p&gt;采用对象创建处理的方式，定义这个自增&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自增&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; IncrementCommand() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前值&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.val = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令栈&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.stack =&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 栈指针位置&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.stackPosition = -1&lt;span&gt;;
};

IncrementCommand.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: IncrementCommand,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行&lt;/span&gt;
    execute: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._clearRedo();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义执行的处理&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; command = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val += 2&lt;span&gt;;
        }.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行并缓存起来&lt;/span&gt;
&lt;span&gt;        command();
        
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.stack.push(command);

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stackPosition++&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue();
    },
    
    canUndo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.stackPosition &amp;gt;= 0&lt;span&gt;;
    },
    
    canRedo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.stackPosition &amp;lt; &lt;span&gt;this&lt;/span&gt;.stack.length - 1&lt;span&gt;;
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 撤销&lt;/span&gt;
    undo: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.canUndo()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stackPosition--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令的撤销，与执行的处理相反&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; command = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val -= 2&lt;span&gt;;
        }.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 撤销后不需要缓存&lt;/span&gt;
&lt;span&gt;        command();

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue();
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重做&lt;/span&gt;
    redo: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.canRedo()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行栈顶的命令&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.stack[++&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.stackPosition]();

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue();
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在执行时，已经撤销的部分不能再重做&lt;/span&gt;
    _clearRedo: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stack = &lt;span&gt;this&lt;/span&gt;.stack.slice(0, &lt;span&gt;this&lt;/span&gt;.stackPosition + 1&lt;span&gt;);
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前值&lt;/span&gt;
    getValue: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.val);
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再实例化进行测试，模拟执行、撤销、重做的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; incrementCommand = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IncrementCommand();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟事件触发，执行命令&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; eventTrigger =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 某个事件的处理中，直接调用命令的处理方法&lt;/span&gt;
    increment: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        incrementCommand.execute();
    },

    incrementUndo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        incrementCommand.undo();
    },

    incrementRedo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        incrementCommand.redo();
    }
};


eventTrigger[&lt;/span&gt;'increment'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
eventTrigger['increment'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;
eventTrigger[&lt;/span&gt;'incrementUndo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;
eventTrigger[&lt;/span&gt;'increment'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;
eventTrigger[&lt;/span&gt;'incrementUndo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
eventTrigger['incrementUndo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
eventTrigger['incrementUndo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无输出&lt;/span&gt;
&lt;span&gt;
eventTrigger[&lt;/span&gt;'incrementRedo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
eventTrigger['incrementRedo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
eventTrigger['incrementRedo'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无输出&lt;/span&gt;
&lt;span&gt;
eventTrigger[&lt;/span&gt;'increment'](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此外，还可以实现简单的宏命令（一系列命令的集合）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; MacroCommand =&lt;span&gt; {
    commands: [],

    add: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(command) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commands.push(command);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },

    remove: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(command) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;command) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.commands =&lt;span&gt; [];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.commands.length; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.commands[i] ===&lt;span&gt; command) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.commands.splice(i, 1&lt;span&gt;);
            }
        }
    },

    execute: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.commands.length; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commands[i].execute();
        }
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; showTime =&lt;span&gt; {
    execute: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'time'&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; showName =&lt;span&gt; {
    execute: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'name'&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; showAge =&lt;span&gt; {
    execute: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'age'&lt;span&gt;);
    }
};

MacroCommand.add(showTime).add(showName).add(showAge);

MacroCommand.remove(showName);

MacroCommand.execute(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; time age&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;七、组合模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是用小的子对象来构建更大的 对象，而这些小的子对象本身也许是由更小 的“孙对象”构成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以用树形结构来表示这种“部分- 整体”的层次结构。&lt;/p&gt;
&lt;p&gt;调用组合对象 的execute方法，程序会递归调用组合对象 下面的叶对象的execute方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180810130111913-1574024010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但要注意的是，组合模式不是父子关系，它是一种HAS-A（聚合）的关系，将请求委托给 它所包含的所有叶对象。基于这种委托，就需要保证组合对象和叶对象拥有相同的 接口&lt;/p&gt;
&lt;p&gt;此外，也要保证用一致的方式对待 列表中的每个叶对象，即叶对象属于同一类，不需要过多特殊的额外操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用组合模式来实现扫描文件夹中的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件夹 组合对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Folder(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.files =&lt;span&gt; [];
}

Folder.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: Folder,

    add: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(file) {
        file.parent &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.files.push(file);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    },

    scan: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 委托给叶对象处理&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.files.length; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.files[i].scan();
        }
    },

    remove: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(file) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; file === 'undefined'&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.files =&lt;span&gt; [];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.files.length; ++&lt;span&gt;i) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.files[i] ===&lt;span&gt; file) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.files.splice(i, 1&lt;span&gt;);
            }
        }
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件 叶对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; File(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

File.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: File,

    add: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'文件里面不能添加文件'&lt;span&gt;);
    },

    scan: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = [&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parent = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parent;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (parent) {
            name.unshift(parent.name);
            parent &lt;/span&gt;=&lt;span&gt; parent.parent;
        }

        console.log(name.join(&lt;/span&gt;' / '&lt;span&gt;));
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造好组合对象与叶对象的关系后，实例化，在组合对象中插入组合或叶对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; web = &lt;span&gt;new&lt;/span&gt; Folder('Web'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fe = &lt;span&gt;new&lt;/span&gt; Folder('前端'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; css = &lt;span&gt;new&lt;/span&gt; Folder('CSS'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; js = &lt;span&gt;new&lt;/span&gt; Folder('js'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rd = &lt;span&gt;new&lt;/span&gt; Folder('后端'&lt;span&gt;);

web.add(fe).add(rd);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file1 = &lt;span&gt;new&lt;/span&gt; File('HTML权威指南.pdf'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file2 = &lt;span&gt;new&lt;/span&gt; File('CSS权威指南.pdf'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file3 = &lt;span&gt;new&lt;/span&gt; File('JavaScript权威指南.pdf'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file4 = &lt;span&gt;new&lt;/span&gt; File('MySQL基础.pdf'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file5 = &lt;span&gt;new&lt;/span&gt; File('Web安全.pdf'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file6 = &lt;span&gt;new&lt;/span&gt; File('Linux菜鸟.pdf'&lt;span&gt;);

css.add(file2);
fe.add(file1).add(file3).add(css).add(js);
rd.add(file4).add(file5);
web.add(file6);

rd.remove(file4);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描&lt;/span&gt;
web.scan();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扫描结果为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180810134809099-1727124887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 4. 优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可 以方便地构造一棵树来表示对象的部分-整体 结构。在树的构造最终 完成之后，只需要通过请求树的最顶层对 象，便能对整棵树做统一一致的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建出来的对象长得都差不多，可能会使代码不好理解，创建太多的对象对性能也会有一些影响&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;八、模板方法模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在抽象父类中封装子类的算法框架，它的 init方法可作为一个算法的模板，指导子类以何种顺序去执行哪些方法。&lt;/p&gt;
&lt;p&gt;由父类分离出公共部分，要求子类重写某些父类的（易变化的）抽象方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板方法模式一般的实现方式为继承&lt;/p&gt;
&lt;p&gt;以运动作为例子，运动有比较通用的一些处理，这部分可以抽离开来，在父类中实现。具体某项运动的特殊性则有自类来重写实现。&lt;/p&gt;
&lt;p&gt;最终子类直接调用父类的模板函数来执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 体育运动&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Sport() {

}

Sport.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: Sport,
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模板，按顺序执行&lt;/span&gt;
    init: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.stretch();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.jog();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.deepBreath();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.start();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; free = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.end();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 运动后还有空的话，就拉伸一下&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (free !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.stretch();
        }
        
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拉伸&lt;/span&gt;
    stretch: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'拉伸'&lt;span&gt;);
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 慢跑&lt;/span&gt;
    jog: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'慢跑'&lt;span&gt;);
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 深呼吸&lt;/span&gt;
    deepBreath: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'深呼吸'&lt;span&gt;);
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始运动&lt;/span&gt;
    start: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('子类必须重写此方法'&lt;span&gt;);
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结束运动&lt;/span&gt;
    end: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;'运动结束'&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 篮球&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Basketball() {

}

Basketball.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sport();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写相关的方法&lt;/span&gt;
Basketball.prototype.start = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'先投上几个三分'&lt;span&gt;);
};

Basketball.prototype.end &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'运动结束了，有事先走一步'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
};


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 马拉松&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Marathon() {

}

Marathon.prototype &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sport();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; basketball = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Basketball();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; marathon = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Marathon();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子类调用，最终会按照父类定义的顺序执行&lt;/span&gt;
&lt;span&gt;basketball.init();
marathon.init();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180810175832079-2143812978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;九、享元模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;享元（flyweight）模式是一种用于性能优化的模式，它的目标是尽量减少共享对象的数量&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运用共享技术来有效支持大量细粒度的对象。&lt;/p&gt;
&lt;p&gt;强调将对象的属性划分为内部状态（属性）与外部状态（属性）。内部状态用于对象的共享，通常不变；而外部状态则剥离开来，由具体的场景决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在程序中使用了大量的相似对象时，可以利用享元模式来优化，减少对象的数量&lt;/p&gt;
&lt;p&gt;举个栗子，要对某个班进行身体素质测量，仅测量身高体重来评判&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 健康测量&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Fitness(name, sex, age, height, weight) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始评判&lt;/span&gt;
Fitness.prototype.judge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = &lt;span&gt;this&lt;/span&gt;.name + ': '&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.sex === 'male'&lt;span&gt;) {
        ret &lt;/span&gt;+= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.judgeMale();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ret &lt;/span&gt;+= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.judgeFemale();
    }

    console.log(ret);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 男性评判规则&lt;/span&gt;
Fitness.prototype.judgeMale = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ratio = &lt;span&gt;this&lt;/span&gt;.height / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.weight;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age &amp;gt; 20 ? (ratio &amp;gt; 3.5) : (ratio &amp;gt; 2.8&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女性评判规则&lt;/span&gt;
Fitness.prototype.judgeFemale = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ratio = &lt;span&gt;this&lt;/span&gt;.height / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.weight;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age &amp;gt; 20 ? (ratio &amp;gt; 4) : (ratio &amp;gt; 3&lt;span&gt;);
};


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; Fitness('A', 'male', 18, 160, 80&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;new&lt;/span&gt; Fitness('B', 'male', 21, 180, 70&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Fitness('C', 'female', 28, 160, 80&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d = &lt;span&gt;new&lt;/span&gt; Fitness('D', 'male', 18, 170, 60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = &lt;span&gt;new&lt;/span&gt; Fitness('E', 'female', 18, 160, 40&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始评判&lt;/span&gt;
a.judge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A: false&lt;/span&gt;
b.judge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; B: false&lt;/span&gt;
c.judge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; C: false&lt;/span&gt;
d.judge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; D: true&lt;/span&gt;
e.judge(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; E: true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;评判五个人就需要创建五个对象，一个班就几十个对象&lt;/p&gt;
&lt;p&gt;可以将对象的公共部分（内部状态）抽离出来，与外部状态独立。将性别看做内部状态即可，其他属性都属于外部状态。&lt;/p&gt;
&lt;p&gt;这么一来我们只需要维护男和女两个对象（使用factory对象），而其他变化的部分则在外部维护（使用manager对象）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 健康测量&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Fitness(sex) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 工厂，创建可共享的对象&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; FitnessFactory =&lt;span&gt; {
    objs: [],

    create: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(sex) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objs[sex]) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.objs[sex] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fitness(sex);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.objs[sex];
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 管理器，管理非共享的部分&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; FitnessManager =&lt;span&gt; {
    fitnessData: {},
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一项&lt;/span&gt;
    add: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name, sex, age, height, weight) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fitness =&lt;span&gt; FitnessFactory.create(sex);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储变化的数据&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.fitnessData[name] =&lt;span&gt; {
            age: age,
            height: height,
            weight: weight
        };

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fitness;
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从存储的数据中获取，更新至当前正在使用的对象&lt;/span&gt;
    updateFitnessData: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name, obj) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fitnessData = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fitnessData[name];

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fitnessData) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fitnessData.hasOwnProperty(item)) {
                obj[item] &lt;/span&gt;=&lt;span&gt; fitnessData[item];
            }
        }
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始评判&lt;/span&gt;
Fitness.prototype.judge = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作前先更新当前状态（从外部状态管理器中获取）&lt;/span&gt;
    FitnessManager.updateFitnessData(name, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = name + ': '&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.sex === 'male'&lt;span&gt;) {
        ret &lt;/span&gt;+= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.judgeMale();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ret &lt;/span&gt;+= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.judgeFemale();
    }

    console.log(ret);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 男性评判规则&lt;/span&gt;
Fitness.prototype.judgeMale = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ratio = &lt;span&gt;this&lt;/span&gt;.height / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.weight;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age &amp;gt; 20 ? (ratio &amp;gt; 3.5) : (ratio &amp;gt; 2.8&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女性评判规则&lt;/span&gt;
Fitness.prototype.judgeFemale = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ratio = &lt;span&gt;this&lt;/span&gt;.height / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.weight;
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age &amp;gt; 20 ? (ratio &amp;gt; 4) : (ratio &amp;gt; 3&lt;span&gt;);
};


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = FitnessManager.add('A', 'male', 18, 160, 80&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = FitnessManager.add('B', 'male', 21, 180, 70&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = FitnessManager.add('C', 'female', 28, 160, 80&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; d = FitnessManager.add('D', 'male', 18, 170, 60&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = FitnessManager.add('E', 'female', 18, 160, 40&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始评判&lt;/span&gt;
a.judge('A'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A: false&lt;/span&gt;
b.judge('B'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; B: false&lt;/span&gt;
c.judge('C'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; C: false&lt;/span&gt;
d.judge('D'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; D: true&lt;/span&gt;
e.judge('E'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; E: true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过代码可能更复杂了，这个例子可能还不够充分，只是展示了享元模式如何实现，它节省了多个相似的对象，但多了一些操作。&lt;/p&gt;
&lt;p&gt;factory对象有点像单例模式，只是多了一个sex的参数，如果没有内部状态，则没有参数的factory对象就更接近单例模式了&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十、职责链模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链 传递该请求，直到有一个对象处理它为止&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求发送者只需要知道链中的第一个节点，弱化发送者和一组接收者之间的强联系，可以便捷地在职责链中增加或删除一个节点，同样地，指定谁是第一个节点也很便捷&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以展示不同类型的变量为例，设置一条职责链，可以免去多重if条件分支&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义链的某一项&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ChainItem(fn) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fn =&lt;span&gt; fn;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

ChainItem.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: ChainItem,
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一项&lt;/span&gt;
    setNext: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(next) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始执行&lt;/span&gt;
    start: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.fn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转到链的下一项执行&lt;/span&gt;
    toNext: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.start.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.next, arguments);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'无匹配的执行项目'&lt;span&gt;);
        }
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 展示数字&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showNumber(num) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; num === 'number'&lt;span&gt;) {
        console.log(&lt;/span&gt;'number'&lt;span&gt;, num);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转移到下一项&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toNext(num);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 展示字符串&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showString(str) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; str === 'string'&lt;span&gt;) {
        console.log(&lt;/span&gt;'string'&lt;span&gt;, str);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toNext(str);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 展示对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showObject(obj) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; obj === 'object'&lt;span&gt;) {
        console.log(&lt;/span&gt;'object'&lt;span&gt;, obj);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toNext(obj);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chainNumber = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChainItem(showNumber);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chainString = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChainItem(showString);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chainObject = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChainItem(showObject);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置链条&lt;/span&gt;
&lt;span&gt;chainObject.setNext(chainNumber).setNext(chainString);

chainString.start(&lt;/span&gt;'12'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; string 12&lt;/span&gt;
chainNumber.start({}); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 无匹配的执行项目&lt;/span&gt;
chainObject.start({}); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; object {}&lt;/span&gt;
chainObject.start(123); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number 123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时想判断未定义的时候呢，直接加到链中即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 展示未定义&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showUndefined(obj) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; obj === 'undefined'&lt;span&gt;) {
        console.log(&lt;/span&gt;'undefined'&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toNext(obj);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chainUndefined = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChainItem(showUndefined);
chainString.setNext(chainUndefined);

chainNumber.start(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由例子可以看到，使用了职责链后，由原本的条件分支换成了很多对象，虽然结构更加清晰了，但在一定程度上可能会影响到性能，所以要注意避免过长的职责链。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十一、中介者模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;所有的相关 对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使网状的多对多关系变成了相对简单的一对多关系（复杂的调度处理都交给中介者）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180810203810861-1292637448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用中介者后&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180810203755778-500873457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个对象，指的不一定得是实例化的对象，也可以将其理解成互为独立的多个项。当这些项在处理时，需要知晓并通过其他项的数据来处理。&lt;/p&gt;
&lt;p&gt;如果每个项都直接处理，程序会非常复杂，修改某个地方就得在多个项内部修改&lt;/p&gt;
&lt;p&gt;我们将这个处理过程抽离出来，封装成中介者来处理，各项需要处理时，通知中介者即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; A =&lt;span&gt; {
    score: &lt;/span&gt;10&lt;span&gt;,

    changeTo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(score) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score =&lt;span&gt; score;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自己获取&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getRank();
    },
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接获取&lt;/span&gt;
    getRank: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scores = [&lt;span&gt;this&lt;/span&gt;.score, B.score, C.score].sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a &amp;lt;&lt;span&gt; b;
        });

        console.log(scores.indexOf(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score) + 1&lt;span&gt;);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; B =&lt;span&gt; {
    score: &lt;/span&gt;20&lt;span&gt;,

    changeTo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(score) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score =&lt;span&gt; score;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过中介者获取&lt;/span&gt;
&lt;span&gt;        rankMediator(B);
    }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; C =&lt;span&gt; {
    score: &lt;/span&gt;30&lt;span&gt;,

    changeTo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(score) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score =&lt;span&gt; score;

        rankMediator(C);
    }
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中介者，计算排名&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; rankMediator(person) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scores = [A.score, B.score, C.score].sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a &amp;lt;&lt;span&gt; b;
    });

    console.log(scores.indexOf(person.score) &lt;/span&gt;+ 1&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A通过自身来处理&lt;/span&gt;
A.changeTo(100); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; B和C交由中介者处理&lt;/span&gt;
B.changeTo(200); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
C.changeTo(50); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ABC三个人分数改变后想要知道自己的排名，在A中自己处理，而B和C使用了中介者。B和C将更为轻松，整体代码也更简洁&lt;/p&gt;
&lt;p&gt;最后，虽然中介者做到了对模块和对象的解耦，但有时对象之间的关系并非一定要解耦，强行使用中介者来整合，可能会使代码更为繁琐，需要注意。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十二、装饰者模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。&lt;/p&gt;
&lt;p&gt;是一种“即用即付”的方式，能够在不改变对 象自身的基础上，在程序运行期间给对象动态地 添加职责&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是为对象动态加入行为，经过多重包装，可以形成一条装饰链&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最简单的装饰者，就是重写对象的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; A =&lt;span&gt; {
    score: &lt;/span&gt;10&lt;span&gt;
};

A.score &lt;/span&gt;= '分数：' + A.score;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用传统面向对象的方法来实现装饰，添加技能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {}

Person.prototype.skill &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'数学'&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，还会音乐&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MusicDecorator(person) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.person =&lt;span&gt; person;
}

MusicDecorator.prototype.skill &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.person.skill();
    console.log(&lt;/span&gt;'音乐'&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，还会跑步&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; RunDecorator(person) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.person =&lt;span&gt; person;
}

RunDecorator.prototype.skill &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.person.skill();
    console.log(&lt;/span&gt;'跑步'&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰一下&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MusicDecorator(person);
person1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunDecorator(person1);

person.skill(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数学&lt;/span&gt;
person1.skill(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数学 音乐 跑步&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在JS中，函数为一等对象，所以我们也可以使用更通用的装饰函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装饰器，在当前函数执行前先执行另一个函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; decoratorBefore(fn, beforeFn) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ret = beforeFn.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在前一个函数中判断，不需要执行当前函数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (ret !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
            fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
        }
    };
}


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; skill() {
    console.log(&lt;/span&gt;'数学'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; skillMusic() {
    console.log(&lt;/span&gt;'音乐'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; skillRun() {
    console.log(&lt;/span&gt;'跑步'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; skillDecorator =&lt;span&gt; decoratorBefore(skill, skillMusic);
skillDecorator &lt;/span&gt;=&lt;span&gt; decoratorBefore(skillDecorator, skillRun);

skillDecorator(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跑步 音乐 数学&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十三、状态模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;事物内部状态的改变往往会带来事物的行为改变。在处理的时候，将这个处理委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区分事物内部的状态，把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以一个人的工作状态作为例子，在刚醒、精神、疲倦几个状态中切换着&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 工作状态&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Work(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentState = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 工作状态，保存为对应状态对象&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.wakeUpState = &lt;span&gt;new&lt;/span&gt; WakeUpState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 精神饱满&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.energeticState = &lt;span&gt;new&lt;/span&gt; EnergeticState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 疲倦&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.tiredState = &lt;span&gt;new&lt;/span&gt; TiredState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.init();
}

Work.prototype.init &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentState = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wakeUpState;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击事件，用于触发更新状态&lt;/span&gt;
    document.body.onclick = () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentState.behaviour();
    };
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新工作状态&lt;/span&gt;
Work.prototype.setState = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(state) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentState =&lt;span&gt; state;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刚醒&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; WakeUpState(work) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work =&lt;span&gt; work;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刚醒的行为&lt;/span&gt;
WakeUpState.prototype.behaviour = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work.name, ':', '刚醒呢，睡个懒觉先'&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只睡了2秒钟懒觉就精神了..&lt;/span&gt;
    setTimeout(() =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work.setState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.work.energeticState);
    }, &lt;/span&gt;2 * 1000&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 精神饱满&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; EnergeticState(work) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work =&lt;span&gt; work;
}

EnergeticState.prototype.behaviour &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work.name, ':', '超级精神的'&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 才精神1秒钟就发困了&lt;/span&gt;
    setTimeout(() =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work.setState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.work.tiredState);
    }, &lt;/span&gt;1000&lt;span&gt;);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 疲倦&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; TiredState(work) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work =&lt;span&gt; work;
}

TiredState.prototype.behaviour &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work.name, ':', '怎么肥事，好困'&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不知不觉，又变成了刚醒着的状态... 不断循环呀&lt;/span&gt;
    setTimeout(() =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.work.setState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.work.wakeUpState);
    }, &lt;/span&gt;1000&lt;span&gt;);
};


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; work = &lt;span&gt;new&lt;/span&gt; Work('曹操');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击一下页面，触发更新状态的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201808/688270-20180810223020756-1949601941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 优缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态切换的逻辑分布在状态类中，易于维护&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多个状态类，对于性能来说，也是一个缺点，这个缺点可以使用享元模式来做进一步优化&lt;/p&gt;
&lt;p&gt;将逻辑分散在状态类中，可能不会很轻易就能看出状态机的变化逻辑&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十四、适配器模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;32&quot;&gt;
&lt;p&gt;是解决两个软件实体间的接口不兼容的问题，对不兼容的部分进行适配&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决两个已有接口之间不匹配的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如一个简单的数据格式转换的适配器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 渲染数据，格式限制为数组了&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; renderData(data) {
    data.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item) {
        console.log(item);
    });
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对非数组的进行转换适配&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; arrayAdapter(data) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; data !== 'object'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [];
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Object.prototype.toString.call(data) === '[object Array]'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.hasOwnProperty(item)) {
            temp.push(data[item]);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {
    &lt;/span&gt;0: 'A'&lt;span&gt;,
    &lt;/span&gt;1: 'B'&lt;span&gt;,
    &lt;/span&gt;2: 'C'&lt;span&gt;
};

renderData(arrayAdapter(data)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A B C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;十五、外观模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 437&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使子系统更加容易使用&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过请求外观接口来达到访问子系统，也可以选择越过外观来直接访问子系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;外观模式在JS中，可以认为是一组函数的集合&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三个处理函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; start() {
    console.log(&lt;/span&gt;'start'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; doing() {
    console.log(&lt;/span&gt;'doing'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; end() {
    console.log(&lt;/span&gt;'end'&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外观函数，将一些处理统一起来，方便调用&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; execute() {
    start();
    doing();
    end();
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用init开始执行&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; init() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处直接调用了高层函数，也可以选择越过它直接调用相关的函数&lt;/span&gt;
&lt;span&gt;    execute();
}

init(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; start doing end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 10 Aug 2018 15:37:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<og:description>在程序设计中有很多实用的设计模式，而其中大部分语言的实现都是基于“类”。 在JavaScript中并没有类这种概念，JS中的函数属于一等对象，在JS中定义一个对象非常简单（var obj = {}），</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9451129.html</dc:identifier>
</item>
<item>
<title>Java语法之反射 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9452264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9452264.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、反射机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前面Java语法之注解自定义注解时我们也有提到反射，要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象。那什么是反射呢?JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。它有点类似照妖镜的作用，不管是什么妖魔鬼怪(类或对象)都能看到它的真面目(获取类的属性方法、调用对象的属性方法)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、Class理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 反射机制可以动态获取类信息以及调用对象方法，那它是通过什么实现的呢？这就要介绍下Class类了。首先明确Class也是一个类，只是它是一个描述类的类，它也可以生成对象。对于每个类而言，在JRE中有且仅有一个不变的 Class 类型的对象，而这个Class 类型的对象只能由系统建立，封装了当前对象所对应的类的信息，有哪些属性，方法，构造器，实现了哪些接口等等。而且每个类的实例都会记得自己是由哪个Class实例所生成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 那要获取类信息或调用对象方法，肯定首先要获取到该类或对象对应的Class类的实例。一般获取Class对象有三种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1. 通过类名获取   类名.class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2. 通过对象获取   对象.getClass()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3. 通过全类名获取 Class.forName(全类名)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里我们可以使用用字符串来做验证。输出结果都是class java.lang.String。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Reflection;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectionTest {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串的例子&lt;/span&gt;
       Class clazz = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类名.class&lt;/span&gt;
       clazz = String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
       System.out.println(clazz);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象.getClass()&lt;/span&gt;
       clazz = &quot;ReflectionTest&quot;&lt;span&gt;.getClass();
       System.out.println(clazz);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Class.forName(全类名)&lt;/span&gt;
       clazz = Class.forName(&quot;java.lang.String&quot;&lt;span&gt;);
       System.out.println(clazz);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
class java.lang.String
class java.lang.String
class java.lang.String
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上面通过三种方式能获取到&lt;/span&gt;Class&lt;span&gt;实例，然后再了解一下&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;类常用的方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;31.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;功能说明&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;forName(String name)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;返回指定类名 &lt;span&gt;name&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;Class&lt;/span&gt; &lt;span&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;newInstance()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;调用缺省构造函数，返回该&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;对象的一个实例&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;newInstance(Object []args)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;调用当前格式构造函数，返回该&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;对象的一个实例&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getName()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;返回此&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;对象所表示的实体（类、接口、数组类、基本类型或&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;）名称&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getSuperClass()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;返回当前&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;对象的父类的&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getInterfaces()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取当前&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;对象的接口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getClassLoader()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;返回该类的类加载器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getSuperclass()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;返回表示此&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;所表示的实体的超类的&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getFields()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类中&lt;span&gt;public&lt;/span&gt;&lt;span&gt;类型的属性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getField(String name)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类特定的方法，&lt;span&gt;name&lt;/span&gt;&lt;span&gt;参数指定了属性的名称&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getDeclaredFields()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类中所有的属性&lt;span&gt;(public&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;private),&lt;/span&gt;&lt;span&gt;但不包括继承的属性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;getDeclaredField(String name)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类特定的方法，&lt;span&gt;name&lt;/span&gt;&lt;span&gt;参数指定了属性的名称&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getConstructors()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类中的公共方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;getConstructor(Class[] params)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类的特定构造方法&lt;span&gt;,params&lt;/span&gt;&lt;span&gt;参数指定构造方法的参数类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;getDeclaredConstructors()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类中所有的构造方法&lt;span&gt;(public&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;private)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;getDeclaredConstructor(Class[] params)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类的特定构造方法&lt;span&gt;,params&lt;/span&gt;&lt;span&gt;参数指定构造方法的参数类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getMethods()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获得类的&lt;span&gt;public&lt;/span&gt;&lt;span&gt;类型的方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;getMethod(String name, Class[] params)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;获得类的特定方法&lt;span&gt;,name&lt;/span&gt;&lt;span&gt;参数指定方法的名字&lt;/span&gt;&lt;span&gt;,params&lt;/span&gt;&lt;span&gt;参数指定方法的参数类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot;&gt;
&lt;p&gt;&lt;span&gt;getDeclaredMethods()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;获取类中所有的方法&lt;span&gt;(public&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;private)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;221&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;getDeclaredMethod(String name, Class[] params)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;346&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;获得类的特定方法&lt;span&gt;,name&lt;/span&gt;&lt;span&gt;参数指定方法的名字&lt;/span&gt;&lt;span&gt;,params&lt;/span&gt;&lt;span&gt;参数指定方法的参数类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; 三、反射的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里要着重介绍下上面API的使用，因为在后面要学习的Spring中IOC的原理就是反射加工厂模式。学好反射API有助于理解Spring框架内部实现。为了演示Class方法的使用，在注解demo的基础上对Person、Student类进行了修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Person类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7333423f-1a9e-4d64-9720-894fa975d3aa&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7333423f-1a9e-4d64-9720-894fa975d3aa&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7333423f-1a9e-4d64-9720-894fa975d3aa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Reflection;

@CustomDescription(description&lt;/span&gt;=&quot;基类&quot;&lt;span&gt;)
@CustomDescription(description&lt;/span&gt;=&quot;人&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Name;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        Name &lt;/span&gt;=&lt;span&gt; name;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String PersonPublicMethod(String str)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name) {
        Name &lt;/span&gt;=&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String PersonPrivateMethod(String str)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; Student类:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_f177feb1-3436-4a67-9726-16e7af73a9cd&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f177feb1-3436-4a67-9726-16e7af73a9cd&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f177feb1-3436-4a67-9726-16e7af73a9cd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Reflection;

@CustomDescription(description&lt;/span&gt;=&quot;学生&quot;&lt;span&gt;)
@CustomDescription(description&lt;/span&gt;=&quot;人&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String StudentId;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStudentId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StudentId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStudentId(String studentId) {
        StudentId &lt;/span&gt;=&lt;span&gt; studentId;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String StudentPublicMethod(String str)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String StudentPrivateMethod(String str)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student(String name, String studentId) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        StudentId &lt;/span&gt;=&lt;span&gt; studentId;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student() {
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一、描述方法Method&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;描述方法的主要是4个获取方法getMethods、getMethod、getDeclaredMethods、getDeclaredMethod和1个调用方法invoke。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;getMethods：获取clazz对应类中的所有方法，不能获取private方法,且获取从父类继承来的所有方法包括私有父类的私有方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;getMethod：获取clazz对应类中指定方法名和参数类型的方法，不能获取private方法,且获取从父类继承来的所有方法包括私有父类的私有方法，因为存在同方法名不同参数这种情况，所以只有同时指定方法名和参数类型才能唯一确定一个方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;getDeclaredMethods：获取所有方法，包括私有方法,所有声明的方法，都可以获取到，且只获取当前类的方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;getDeclaredMethod：获取clazz对应类中指定方法名和参数类型的方法，包括私有方法,所有声明的方法，都可以获取到，且只获取当前类的方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Invoke：执行方法,第一个参数表示执行哪个对象的方法，剩下的参数是执行方法时需要传入的参数,私有方法的执行，必须在调用invoke之前加上一句method.setAccessible(true);&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {

        Class clazz &lt;/span&gt;= Class.forName(&quot;Reflection.Student&quot;&lt;span&gt;);
        Method method&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Method[] methods&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        methods &lt;/span&gt;=&lt;span&gt; clazz.getMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method mth:methods){
            System.out.print(mth.getName()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }
        System.out.println();
        
        method &lt;/span&gt;= clazz.getMethod(&quot;StudentPublicMethod&quot;,String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.print(method.getName()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        System.out.println();

        methods &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredMethods();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method mth:methods){
            System.out.print(mth.getName()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }
        System.out.println();
        
        method &lt;/span&gt;= clazz.getDeclaredMethod(&quot;StudentPrivateMethod&quot;,String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.print(method.getName()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        System.out.println();
        
        Object obje &lt;/span&gt;=&lt;span&gt; clazz.newInstance();
        method.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        String result&lt;/span&gt;=(String) method.invoke(obje,&quot;inputParams&quot;&lt;span&gt;);
        System.out.println(result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
StudentPublicMethod setStudentId getStudentId getName setName PersonPrivateMethod PersonPublicMethod wait wait wait equals toString hashCode getClass notify notifyAll 
StudentPublicMethod 
StudentPrivateMethod StudentPublicMethod setStudentId getStudentId 
StudentPrivateMethod 
inputParams
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 二、描述字段Filed&lt;br/&gt;描述字段Filed方法的使用和描述方法Method中方法的使用有点类似，也是4个获取字段的方法：getFields、getField、getDeclaredFields、getDeclaredField。&lt;br/&gt;getFields：获得某个类的所有的公共（public）的字段，包括父类中的字段。&lt;br/&gt;getField：获取某个类public成员变量中指定变量名的字段，包括基类。&lt;br/&gt;getDeclaredFields：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。&lt;br/&gt;getDeclaredField：获取某个类的所有成员变量指定变量名的字段，不包括基类。&lt;/p&gt;
&lt;p&gt;1.字段获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Class clazz = Class.forName(&quot;Reflection.Student&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;---------getDeclaredFields---------&quot;&lt;span&gt;);
        Field[] fields &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field: fields){
            System.out.print(field.getName()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }
        System.out.println();
        System.out.println(&lt;/span&gt;&quot;---------getFields---------&quot;&lt;span&gt;);
        fields &lt;/span&gt;=&lt;span&gt; clazz.getFields();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field: fields){
            System.out.print(field.getName()&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
        }
        System.out.println();
       
        System.out.println(&lt;/span&gt;&quot;---------getDeclaredField---------&quot;&lt;span&gt;);
        Field field &lt;/span&gt;= clazz.getDeclaredField(&quot;StudentId&quot;&lt;span&gt;);
        field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        System.out.println(field.getName());
        
        System.out.println(&lt;/span&gt;&quot;---------getField--------&quot;&lt;span&gt;);
        
        field &lt;/span&gt;= clazz.getField(&quot;StudentId&quot;&lt;span&gt;);
        System.out.println(field.getName());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
---------getDeclaredFields---------&lt;span&gt;
StudentId 
&lt;/span&gt;---------getFields---------&lt;span&gt;
StudentId 
&lt;/span&gt;---------getDeclaredField---------&lt;span&gt;
StudentId
&lt;/span&gt;---------getField--------&lt;span&gt;
StudentId&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.字段的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    Class clazz = Class.forName(&quot;Reflection.Person&quot;&lt;span&gt;);
    Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;CYW&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私有字段的值&lt;/span&gt;
        Field field = clazz.getDeclaredField(&quot;Name&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于是私有字段,需要使用setAccessible(true)&lt;/span&gt;
        field.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        Object val &lt;/span&gt;=&lt;span&gt; field.get(person);
        System.out.println(val);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变私有字段的值&lt;/span&gt;
        field.set(person, &quot;ivan&quot;&lt;span&gt;);
        System.out.println(person.getName());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 计划在未来6个月内写一本Spring入门的书，本篇和Java语法注解篇都是书的一部分，博友有什么建议或意见可以留言，我也好在后面的章节进行改进。未完，待续！&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>一、反射机制 在前面Java语法之注解自定义注解时我们也有提到反射，要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象。那什么是反射呢?JAVA反射机制是在运行状</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9452264.html</dc:identifier>
</item>
<item>
<title>如何优雅地使用Redis之位图操作 - 不才黄某</title>
<link>http://www.cnblogs.com/hzjjames/p/redis_bit.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hzjjames/p/redis_bit.html</guid>
<description>&lt;p&gt;&lt;br/&gt;前言&lt;/p&gt;

&lt;p&gt;在进入今天的主题前，先简单地解释下Redis中的位图到底是什么。Redis官方文档对于位图的介绍如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;位图不是一个真实的数据类型，而是定义在字符串类型上的面向位的操作的集合。由于字符串类型是二进制安全的二进制大对象，并且最大长度是 512MB，适合于设置 2^32个不同的位。&lt;br/&gt;位操作分为两组：常量时间单个位的操作，像设置一个位为 1 或者 0，或者获取该位的值。对一组位的操作，例如计算指定范围位的置位数量。&lt;br/&gt;位图的最大优势是有时是一种非常显著的节省空间来存储信息的方式。例如，在一个系统中，不同用户由递增的用户 ID 来表示，可以使用 512MB 的内存来表示 400 万用户的单个位信息（例如他们是否需要接收信件）。 &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简而言之，位图操作是用来操作比特位的，其优点是节省内存空间。为什么可以节省内存空间呢？假如我们需要存储100万个用户的登录状态，使用位图的话最少只需要100万个比特位（比特位1表示登录，比特位0表示未登录）就可以存储了，而如果以字符串的形式存储，比如说以userId为key，是否登录（字符串“1”表示登录，字符串“0”表示未登录）为value进行存储的话，就需要存储100万个字符串了，相比之下使用位图存储占用的空间要小得多，这就是位图存储的优势。&lt;/p&gt;

&lt;p&gt;位图常用操作&lt;/p&gt;

&lt;p&gt;位图的常用操作如下：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;setbit&lt;/p&gt;
&lt;p&gt;设置特定key对应的比特位的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;getbit&lt;/p&gt;
&lt;p&gt;获取特定key对应的比特位的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;bitcount&lt;/p&gt;
&lt;p&gt;统计给定key对应的字符串比特位为1的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用位图存储用户登录状态&lt;/p&gt;

&lt;p&gt;位图的常见应用是用来存储状态值，比如存储用户的登录状态。&lt;/p&gt;
&lt;p&gt;假设我们现在有一个需求，需要记录用户注册以来每天的登录状态，那么我们就可以以用户id为key，然后以日期或者日期的偏移量作为下标，将登录状态存储到对应的比特位中，这样就可以很方便地获取用户某一天的登录状态了。&lt;/p&gt;
&lt;p&gt;接下来看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserLoginStatusService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String host=&quot;111.111.111.111&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; port=6379&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Jedis jedis=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Jedis(host,port);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期的初始值（也可以理解为用户的注册时间），
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下文需要使用日期的偏移量作为redis位图的offset，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因此需要将要保存登录状态的日期减去该初始日期。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里使用了Java 8的新日期API&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; LocalDate beginDate=LocalDate.of(2018,1,1&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        jedis.connect();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setLoginStatus(String userId, LocalDate date,&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isLogin){
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; offset =&lt;span&gt; getDateDuration(beginDate, date);
        jedis.setbit(userId,offset,isLogin);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getLoginStatus(String userId,LocalDate date){
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; offset =&lt;span&gt; getDateDuration(beginDate, date);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jedis.getbit(userId,offset);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getDateDuration(LocalDate start ,LocalDate end){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; start.until(end, ChronoUnit.DAYS);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        UserLoginStatusService userLoginStatusService&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserLoginStatusService();
        String userId&lt;/span&gt;=&quot;user_1&quot;&lt;span&gt;;
        LocalDate today &lt;/span&gt;=&lt;span&gt; LocalDate.now();
        userLoginStatusService.setLoginStatus(userId,today,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; todayLoginStatus =&lt;span&gt; userLoginStatusService.getLoginStatus(userId, today);
        System.out.println(String.format(&lt;/span&gt;&quot;The loginStatus of %s in %s is %s&quot;&lt;span&gt;,userId,today,todayLoginStatus));
        LocalDate yesterday &lt;/span&gt;= LocalDate.now().minusDays(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; yesterdayLoginStatus =&lt;span&gt; userLoginStatusService.getLoginStatus(userId, yesterday);
        System.out.println(String.format(&lt;/span&gt;&quot;The loginStatus of %s in %s is %s&quot;&lt;span&gt;,userId,yesterday,yesterdayLoginStatus));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码不复杂，我们在main方法中设置当天的登录状态为true，然后分别查出当天的登录状态和昨天的登录状态，由于redis位图的比特位默认是0，所以该代码的正确输出应该是今天已登录，昨天未登录，我们运行一次看看结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l75Il02sGGGibIDwxSFUfxeX3Bib7pXtHIjUR4YEWhslnOL3UpAu9olibfIws84wibRVJM8peFL3p7mXg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.1248303934871099&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l75Il02sGGGibIDwxSFUfxeX3Bib7pXtHIjUR4YEWhslnOL3UpAu9olibfIws84wibRVJM8peFL3p7mXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从程序运行结果来看，Redis的位图确实满足了我们的需求，且兼有节省存储空间的优点。&lt;/p&gt;

&lt;p&gt;使用位图统计登录天数&lt;/p&gt;

&lt;p&gt;接下来我们有一个新需求，就是统计某个用户注册后前10天的登录天数，Redis中有个bitcount命令，可以统计某个字符串中的比特位为1的数量，其还有2个参数start和end，表示要统计的范围，咋一看好像可以用来实现我们这个需求，但是这里有一个坑需要注意下，bitcount命令的start和end参数指的是字节的索引，而不是比特位的索引，而我们如果要使用位图来统计某个用户注册后前10天的登录天数的话，需要统计的是比特位索引从0到9的比特值为1的数量，所以直接使用bitcount命令显然是无法满足要求的。那么假如说我们一定要用位图来存储登录状态呢，应该咋办呢？其实办法还是有的。我们可以先拿到比特位索引从0到9所在的字节数组，再将该字节数组解析成二进制形式，进而统计出比特位索引从0到9比特值为1的数量。&lt;/p&gt;
&lt;p&gt;要拿到比特位索引所在的字节在字节数组中的下标比较简单，只要将比特位索引除以8（一个字节包含8个比特位）再向下取整就行了。接下来就是使用redis的getrange命令来截取字节数组了。&lt;/p&gt;
&lt;p&gt;拿到了字节数组，接下来就是解析字节数组，统计其中比特值为1的数量了。我们先从最简单的单个字节说起，假设一个字节的各个比特位的值如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l6BeTPv9fL8NDuRrz2jAspo5xq8QFoIriaVFhtxkPQSMyibD5rtvl7aQCichl3BjIxl5yVFx1YLD5G0w/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.20743034055727555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l6BeTPv9fL8NDuRrz2jAspo5xq8QFoIriaVFhtxkPQSMyibD5rtvl7aQCichl3BjIxl5yVFx1YLD5G0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们设比特位索引为index，假如我们要计算比特位为7的比特值，只需要将原值直接跟1进行与运算就行了。要计算比特位为6的比特值，只需要将原值右移1位，再跟1进行与运算。以此类推，要计算第index位的比特值，只需要先右移(7-index)位，再跟1进行与运算即可。&lt;/p&gt;
&lt;p&gt;只要能够统计出截取出来的的字节数组中比特位的值为1的数量，接下来再减去不包含在对应比特索引中的比特值为1的数量，即可统计出给定的比特索引范围内比特值为1的数量。&lt;/p&gt;
&lt;p&gt;这么说有点拗口，我们以上述例子为例进行讲解吧。我们要统计出用户注册后前10天的登录天数，如果用位图存储用户登录状态，位图中的索引为注册天数的话，那么我们需要统计比特索引从0到9的比特值为1的数量，才能计算出该用户注册后前10天的登录天数。&lt;/p&gt;
&lt;p&gt;我们先计算出比特索引从0到9包含在哪一段字节数组中，前面说了，只需要将对应的索引除以8，再向下取整就行了。从而可以得知比特位索引从0到9对应的是下标从0到1的字节数组。&lt;/p&gt;
&lt;p&gt;接下来使用getrange命令截取该字节数组，假设其值如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l6BeTPv9fL8NDuRrz2jAspoEJRtIsoXuicoqiaUUPZjxJib1cT36p5JKiaQrMx8RGV0STV9EVibPGxlOpA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2787794729542302&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l6BeTPv9fL8NDuRrz2jAspoEJRtIsoXuicoqiaUUPZjxJib1cT36p5JKiaQrMx8RGV0STV9EVibPGxlOpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l6BeTPv9fL8NDuRrz2jAspo22Hsd8pBZpSYXmS3ecsM7kZXS15VCx6IR34TY2HypSSAmARS2WBKkA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.27285318559556787&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l6BeTPv9fL8NDuRrz2jAspo22Hsd8pBZpSYXmS3ecsM7kZXS15VCx6IR34TY2HypSSAmARS2WBKkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;722&quot; data-fail=&quot;0&quot;/&gt;假设比特索引0到9对应的字节数组的比特值情况如上所示，我们需要统计的是第一个字节（下标为0）中的0到7位中比特值为1的数量，再加上第二个字节（下标为1）中的第0到1位中比特值为1的数量。加起来刚好10位，也就是对应用户注册前10天的登录天数。当然我们也可以统计出这2个字节中的比特值为1的总数，再减去第二个字节的从2到7位（上述表格标红的地方）中比特值为1的数量，也可统计出该用户注册后前10天的登录天数。本文用的是第二种方法。&lt;/p&gt;
&lt;p&gt;接下来上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BIT_AMOUNT_IN_ONE_BYTE =8&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Jedis jedis;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; bitCountByBitIndex(String key, &lt;span&gt;long&lt;/span&gt; startBitIndex, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; endBitIndex) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; startByteIndex =&lt;span&gt; getByteIndexInTheBytes(startBitIndex);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; endByteIndex =&lt;span&gt; getByteIndexInTheBytes(endBitIndex);
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes =&lt;span&gt; jedis.getrange(key.getBytes(), startByteIndex, endByteIndex);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; totalBitInBytes =&lt;span&gt; getTotalBitInBytes(bytes);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; startBitIndexInFirstByte =&lt;span&gt; getBitIndexInTheByte(startBitIndex);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; endBitIndexInLastByte =&lt;span&gt; getBitIndexInTheByte(endBitIndex);
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; firstByte = bytes[0&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; lastByte = bytes[bytes.length-1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=7;i&amp;gt;(BIT_AMOUNT_IN_ONE_BYTE-1-startBitIndexInFirstByte);i--&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((firstByte&amp;gt;&amp;gt;i)&amp;amp;1)==1&lt;span&gt;){
                totalBitInBytes&lt;/span&gt;--&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;(BIT_AMOUNT_IN_ONE_BYTE-1-endBitIndexInLastByte);i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((lastByte&amp;gt;&amp;gt;i)&amp;amp;1)==1&lt;span&gt;){
                totalBitInBytes&lt;/span&gt;--&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; totalBitInBytes;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getTotalBitInBytes(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; b:bytes){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i&amp;lt; BIT_AMOUNT_IN_ONE_BYTE; i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((b&amp;gt;&amp;gt;i)&amp;amp;1)==1&lt;span&gt;){
                    count&lt;/span&gt;++&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getByteIndexInTheBytes(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;) offset/&lt;span&gt; BIT_AMOUNT_IN_ONE_BYTE;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getBitIndexInTheByte(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; offset){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)(offset-offset/ BIT_AMOUNT_IN_ONE_BYTE *&lt;span&gt; BIT_AMOUNT_IN_ONE_BYTE);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码就不注释了，整体思路已经在上面讲解了。&lt;/p&gt;
&lt;p&gt;当然要实现本文所述的功能，也不一定非要这么做，还是有其他的方案的。比如：可以将放入位图的offset统一乘以8（一个字节占8比特），这样一来就可以直接用redis的bitcount来统计对应索引范围内的比特值为1的数量了，当然这种方案的缺点也相当明显，就是浪费内存，因为原先只需要1比特存储的数据，现在需要8比特存储，所以这种方案不能很好地利用位图索引节省存储空间的特点。&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 15:06:00 +0000</pubDate>
<dc:creator>不才黄某</dc:creator>
<og:description>前言 在进入今天的主题前，先简单地解释下Redis中的位图到底是什么。Redis官方文档对于位图的介绍如下： 位图不是一个真实的数据类型，而是定义在字符串类型上的面向位的操作的集合。由于字符串类型是二</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hzjjames/p/redis_bit.html</dc:identifier>
</item>
<item>
<title>C++ list结构体变量排序 - Freedom_lyx</title>
<link>http://www.cnblogs.com/lyx5990/p/9455530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyx5990/p/9455530.html</guid>
<description>&lt;div class=&quot;line number1 index0 alt2&quot; readability=&quot;49&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;以下内容是自己整理的根据结构体里面的不同变量，对list排序的实例，若有问题可以留言。仅供参考。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream&amp;gt;&lt;br/&gt;#include &amp;lt;list&amp;gt;&lt;br/&gt;#include &amp;lt;algorithm&amp;gt;&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;//声明结构体&lt;br/&gt;typedef struct testListSort&lt;br/&gt;{&lt;br/&gt;　　int number;&lt;br/&gt;　　std::string name;&lt;br/&gt;　　char time[10];&lt;br/&gt;　　int datalen;&lt;br/&gt;}stuTest;&lt;/p&gt;
&lt;p&gt;//结构体list&lt;br/&gt;std::list&amp;lt;stuTest&amp;gt; listDataInfo;&lt;/p&gt;
&lt;p&gt;//比较函数:根据结构体里面的整型number排序&lt;br/&gt;bool sortStuInt(const stuTest&amp;amp; m1, const stuTest&amp;amp; m2)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;　　return m1.number &amp;lt; m2.number;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;//比较函数:根据结构体里面的字符串name排序&lt;br/&gt;bool comStuString(const stuTest&amp;amp; m1, const stuTest&amp;amp; m2)&lt;/p&gt;
&lt;p&gt;{&lt;br/&gt;　　if(m1.name.compare(m2.name) &amp;lt;= 0)&lt;br/&gt;　　{&lt;br/&gt;　　　　return true;&lt;br/&gt;　　}&lt;br/&gt;　　else&lt;br/&gt;　　{&lt;br/&gt;　　　　return false;&lt;br/&gt;　　}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;int main(void)&lt;br/&gt;{&lt;br/&gt;//仅对结构体里面的&lt;br/&gt;for (int i = 0; i &amp;lt; 10; i++)&lt;br/&gt;{&lt;br/&gt;//结构体整型赋值&lt;br/&gt;stuTest temp;&lt;br/&gt;temp.number = rand()%100;&lt;/p&gt;
&lt;p&gt;//结构体字符串赋值&lt;br/&gt;int num = rand()%100;&lt;br/&gt;char strChar[10];&lt;br/&gt;itoa(num,strChar,10);&lt;br/&gt;temp.name = strChar;&lt;/p&gt;
&lt;p&gt;listDataInfo.push_back(temp);&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;//按照结构体里面的整型数据，对list里面结构体排序&lt;br/&gt;listDataInfo.sort(sortStuInt);&lt;/p&gt;
&lt;p&gt;//按照结构体里面的字符串数据，对list里面结构体排序&lt;br/&gt;//listDataInfo.sort(comStuString);&lt;/p&gt;
&lt;p&gt;return 0;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;以上仅是对单个文件里面的list 按照结构体变量排序，如果在&lt;span&gt;类的成员变量&lt;/span&gt;中，声明上述比较函数sortStuInt、comStuString，并且在&lt;span&gt;类的其他成员函数&lt;/span&gt;调用的话，可能会有问题，这时可以把比较函数放到类前声明，在类的CPP中直接实现，再次在类的成员函数调用时就不会出错，具体原因不在此列出，可以自行尝试。以上内容纯属自我理解，有不准确的地方，请指出留言，相互学习。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 10 Aug 2018 15:04:00 +0000</pubDate>
<dc:creator>Freedom_lyx</dc:creator>
<og:description>以下内容是自己整理的根据结构体里面的不同变量，对list排序的实例，若有问题可以留言。仅供参考。 #include &lt;iostream&gt;#include &lt;list&gt;#incl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyx5990/p/9455530.html</dc:identifier>
</item>
<item>
<title>8个Python高效数据分析的技巧 - CoXie带你学编程</title>
<link>http://www.cnblogs.com/CoXieLearnPython/p/9457916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoXieLearnPython/p/9457916.html</guid>
<description>&lt;h4 id=&quot;一行代码定义list&quot;&gt;一行代码定义List&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180810224703579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是使用For循环创建列表和用一行代码创建列表的对比。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x = [1,2,3,4]
out = []
for item in x:
    out.append(item**2)
print(out)
[1, 4, 9, 16]
# vs.
x = [1,2,3,4]
out = [item**2 for item in x]
print(out)
[1, 4, 9, 16]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;lambda表达式&quot;&gt;Lambda表达式&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;厌倦了定义用不了几次的函数？ Lambda表达式是你的救星！ Lambda表达式用于在Python中创建小型，一次性和匿名函数对象。 它能替你创建一个函数。&lt;/p&gt;
&lt;p&gt;lambda表达式的基本语法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lambda arguments: expression&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，只要有一个lambda表达式，就可以完成常规函数可以执行的任何操作。 你可以从下面的例子中，感受lambda表达式的强大功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;double = lambda x: x * 2
print(double(5))
10&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;map和filter&quot;&gt;Map和Filter&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;一旦掌握了lambda表达式，学习将它们与Map和Filter函数配合使用，可以实现更为强大的功能。&lt;/p&gt;
&lt;p&gt;具体来说，map通过对列表中每个元素执行某种操作并将其转换为新列表。 在本例中，它遍历每个元素并乘以2，构成新列表。 请注意，list()函数只是将输出转换为列表类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Map
seq = [1, 2, 3, 4, 5]
result = list(map(lambda var: var*2, seq))
print(result)
[2, 4, 6, 8, 10]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Filter函数接受一个列表和一条规则，就像map一样，但它通过比较每个元素和布尔过滤规则来返回原始列表的一个子集。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Filter
seq = [1, 2, 3, 4, 5]
result = list(filter(lambda x: x &amp;gt; 2, seq))
print(result)
[3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;arange和linspace&quot;&gt;Arange和Linspace&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;Arange返回给定步长的等差列表。 它的三个参数start、stop、step分别表示起始值，结束值和步长， 请注意，stop点是一个“截止”值，因此它不会包含在数组输出中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# np.arange(start, stop, step)
np.arange(3, 7, 2)
array([3, 5])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Linspace和Arrange非常相似，但略有不同。 Linspace以指定数目均匀分割区间。 所以给定区间start和end，以及等分分割点数目num，linspace将返回一个NumPy数组。 这对绘图时数据可视化和声明坐标轴特别有用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# np.linspace(start, stop, num)
np.linspace(2.0, 3.0, num=5)
array([ 2.0,  2.25,  2.5,  2.75, 3.0])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;axis代表什么&quot;&gt;Axis代表什么？&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;在Pandas中，删除一列或在NumPy矩阵中求和值时，可能会遇到Axis。 我们用删除一列（行）的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df.drop('Column A', axis=1)
df.drop('Row A', axis=0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想处理列，将Axis设置为1，如果你想要处理行，将其设置为0。 但为什么呢？ 回想一下Pandas中的shape&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df.shape
(# of Rows, # of Columns)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从Pandas DataFrame中调用shape属性返回一个元组，第一个值代表行数，第二个值代表列数。如果你想在Python中对其进行索引，则行数下标为0，列数下标为1，这很像我们如何声明轴值。&lt;/p&gt;
&lt;h4 id=&quot;concatmerge和join&quot;&gt;Concat，Merge和Join&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;如果您熟悉SQL，那么这些概念对您来说可能会更容易。 无论如何，这些函数本质上就是以特定方式组合DataFrame的方式。 在哪个时间跟踪哪一个最适合使用可能很困难，所以让我们回顾一下。&lt;/p&gt;
&lt;p&gt;Concat允许用户在表格下面或旁边追加一个或多个DataFrame（取决于您如何定义轴）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180810225325247?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Merge将多个DataFrame合并指定主键（Key）相同的行。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180810225338244?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Join，和Merge一样，合并了两个DataFrame。 但它不按某个指定的主键合并，而是根据相同的列名或行名合并。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180810225349586?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;pandas-apply&quot;&gt;Pandas Apply&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Apply是为Pandas Series而设计的。如果你不太熟悉Series，可以将它想成类似Numpy的数组。&lt;/strong&gt;&lt;br/&gt;Apply将一个函数应用于指定轴上的每一个元素。 使用Apply，可以将DataFrame列（是一个Series）的值进行格式设置和操作，不用循环，非常有用！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df = pd.DataFrame([[4, 9],] * 3, columns=['A', 'B'])
 df
   A  B
0  4  9
1  4  9
2  4  9

df.apply(np.sqrt)
     A    B
0  2.0  3.0
1  2.0  3.0
2  2.0  3.0

 df.apply(np.sum, axis=0)
A    12
B    27

df.apply(np.sum, axis=1)
0    13
1    13
2    13&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;pivot-tables&quot;&gt;Pivot Tables&lt;/h4&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;最后是Pivot Tables。 如果您熟悉Microsoft Excel，那么你也许听说过数据透视表。 Pandas内置的pivot_table函数以DataFrame的形式创建电子表格样式的数据透视表,，它可以帮助我们快速查看某几列的数据。 下面是几个例子：非常智能地将数据按照“Manager”分了组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pd.pivot_table(df, index=[&quot;Manager&quot;, &quot;Rep&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180810225543145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;br/&gt;或者也可以筛选属性值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pd.pivot_table(df,index=[&quot;Manager&quot;,&quot;Rep&quot;],values=[&quot;Price&quot;])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180810225612843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018081022562596?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDIyMjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 14:59:00 +0000</pubDate>
<dc:creator>CoXie带你学编程</dc:creator>
<og:description>一行代码定义List 下面是使用For循环创建列表和用一行代码创建列表的对比。 Lambda表达式 厌倦了定义用不了几次的函数？ Lambda表达式是你的救星！ Lambda表达式用于在Python中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoXieLearnPython/p/9457916.html</dc:identifier>
</item>
<item>
<title>初始化和清理 - 嗜血蚂蚁</title>
<link>http://www.cnblogs.com/shixiemayi/p/9451765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shixiemayi/p/9451765.html</guid>
<description>&lt;p&gt;1、区别方法重载和重写：&lt;/p&gt;
&lt;p&gt;重载：方法名称一致，通过参数列表区别不同的方法； 发生于本类或者父类、子类；&lt;/p&gt;
&lt;p&gt;重写：方法返回值，方法名， 参数列表必须一致；发生于父类、子类&lt;/p&gt;
&lt;p&gt;方法重载时调用的类型转换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zifuchuan;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyTe8 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; a=6&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; b=7&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c=7&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; d=7&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; e=1.1f&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; f=1.2d&lt;span&gt;;
        test(a);
        test(b);
        test(c);
        test(d);
        test(e);
        test(f);

        test(&lt;/span&gt;1.3&lt;span&gt;);
        test(&lt;/span&gt;'g');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符类型被提升为int类型&lt;/span&gt;
        test(89);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常数89被当成int类型&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; h=10&lt;span&gt;;
        test2(h);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test(byte arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;short&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test(short arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test(int arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test1(long arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test(float arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test(double arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test2(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test2(long arg)&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test2(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; arg) {
        System.out.println(&lt;/span&gt;&quot;test2(double arg)&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知，类型转化规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;传入参数的数据类型（实际参数类型）小于方法中申明的参数类型，实际数据类型会被提升，其中字符类型比较特殊，会被提升为int类型 ；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;传入参数的数据类型（实际参数类型）大于方法中申明的参数类型，会报错，需要强制类型转化；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;常数89被当成int类型；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2、对象创建，初始化过程&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首次调用Dog类的静态方法（构造器也是静态方法）/静态域首次被访问时候，java解析器查找类路径定位Dog.class文件。载入Dog.class文件（这将创建一个Class对象），静态初始化相关的动作都会执行（静态域、静态代码块按照程序中的顺序依次初始化），且在Class对象首次加载的时候执行一次。如果有父类，则先找到父类的class文件并载入，再加载子类。以此类推，最终以从基类一直到导出类的顺序，分别载入class文件和当前类的静态初始化，&lt;/li&gt;
&lt;li&gt;当调用构造器创建Dog对象时候，先在堆上为Dog对象分配存储空间，并清零（也就将对象的域设置成了默认值，比如引用置为null）。如果有基类，继续为基类的对象分配存储空间并清零（导出类的构造器默认调用基类的构造器）。以此类推，最终从导出类到基类的顺序分配空间并清零。最顶层的基类对象分配存储空间并清零后，会执行本类域处的初始化操作，然后执行本类构造器。&lt;/li&gt;
&lt;li&gt;基类构造器完成后，导出类依次执行所有在字段处和非静态代码块的初始化动作。以此类推，最终从基类到导出类的顺序初始化。&lt;/li&gt;
&lt;li&gt;执行导出类构造器其余部分。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zifuchuan;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Beetle &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Insect{

    Beetle(){
        System.out.println(&lt;/span&gt;&quot;Beetle构造器初始化&quot;&lt;span&gt;);
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;Beetle静态代码块1&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x2=print(&quot;x2&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;Beetle静态代码块2&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(&lt;/span&gt;&quot;main函数执行&quot;&lt;span&gt;);
        Beetle beetle&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Beetle();
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Insect{

    {
        System.out.println(&lt;/span&gt;&quot;Insect非静态代码块1&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; first=print2(&quot;Insect非静态域&quot;&lt;span&gt;);

    Insect(){
        System.out.println(&lt;/span&gt;&quot;Insect构造器初始化&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x=print(&quot;x&quot;&lt;span&gt;);

    {
        System.out.println(&lt;/span&gt;&quot;Insect非静态代码块2&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; print2(String str){
        System.out.println(str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 47&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; print(String str){
        System.out.println(str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 47&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;x
Beetle静态代码块1
x2
Beetle静态代码块2
main函数执行
Insect非静态代码块1
Insect非静态域
Insect非静态代码块2
Insect构造器初始化
Beetle构造器初始化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、垃圾回收器如何工作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引用计数--java虚拟机从未采用的垃圾回收技术&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　引用计数的思想？&lt;/p&gt;
&lt;p&gt;　　每一个对象都含有一个引用计数器，当有新的引用连接至对象时候，引用计数加1；引用置空时候，引用计数减1。垃圾回收器在包含所有对象的列表上遍历，发现某个对象的引用计数器为0时，就是释放对象占用的资源。&lt;/p&gt;
&lt;p&gt;缺陷：存在循环引用，可能出现本来应该被回收的对象，由于引用计数不为0无法被回收的情况&lt;/p&gt;
&lt;p&gt;　　如何解决“引用计数”的缺陷？&lt;/p&gt;
&lt;p&gt;　　对于一切存活的对象，一定能够最终追溯到其存活在堆栈或静态存储区中的引用，这个引用可能会穿过数个对象层次。基于此前提，从堆栈或静态存储区开始遍历所有的引用就能找到存活的对象。这解决了“引用计数”的缺陷。以下“停止-复制”、”标记-清扫”基于该思想。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;停止-复制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　先暂停程序，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的是垃圾，被回收；对象被复制到新堆后是整齐排列的。&lt;/p&gt;
&lt;p&gt;缺陷：&lt;/p&gt;
&lt;p&gt;　　需要两个分离的堆来回复制；如果产生少量垃圾（不存活对象很少），甚至没有垃圾，垃圾回收器还是会将所有内存从一处复制另一处的堆，很浪费。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记-清扫&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　不暂停程序，找到存活对象设置一个标记，当全部标记工作完成时候，暂停程序并清理未被标记的垃圾；剩下的堆空间不是整齐排列的。解决了“停止-复制”的缺陷。&lt;/p&gt;
&lt;p&gt;JVM虚拟机会跟踪“停止-复制”的效果，如果对象很稳定，垃圾回收效率低，会切换到“标记-清扫”方式；JVM虚拟机会跟踪“标记-清扫”的效果，如果堆空间出现很多碎片，会切换回“停止-复制”的方式。这种方式工作方式通常称为“自适应”技术&lt;/p&gt;
</description>
<pubDate>Fri, 10 Aug 2018 14:51:00 +0000</pubDate>
<dc:creator>嗜血蚂蚁</dc:creator>
<og:description>1、区别方法重载和重写： 重载：方法名称一致，通过参数列表区别不同的方法； 发生于本类或者父类、子类； 重写：方法返回值，方法名， 参数列表必须一致；发生于父类、子类 方法重载时调用的类型转换： 可知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shixiemayi/p/9451765.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day28 Java容器类详解（十）LinkedHashMap详解 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9440313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9440313.html</guid>
<description>&lt;p&gt;　　今天来介绍一下容器类中的另一个哈希表———》LinkedHashMap。这是HashMap的关门弟子，直接继承了HashMap的衣钵，所以拥有HashMap的全部特性，并青出于蓝而胜于蓝，有着一些HashMap没有的特性。 接下来就一起来看看这个关门弟子到底有多大能耐&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180808220946866-35390732.png&quot; alt=&quot;&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;　　本文将从以下几点对LinkedHashMap进行介绍：&lt;/p&gt;
&lt;p&gt;　　1、LinkedHashMap简介与简单使用&lt;/p&gt;
&lt;p&gt;　　2、LinkedHashMap的结构以及与HashMap的对比&lt;/p&gt;
&lt;p&gt;　　3、LinkedHashMap的插入和删除&lt;/p&gt;
&lt;p&gt;　　4、LinkedHashMap的源码分析&lt;/p&gt;
&lt;p&gt;　　5、基于LinkedHashMap实现LRU缓存&lt;/p&gt;
&lt;p&gt;　　6、总结&lt;/p&gt;
&lt;p&gt;　　本文预计需食用二十分钟，请各位食客合理分配时间。（别慌别慌&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180808221009124-2051969669.png&quot; alt=&quot;&quot;/&gt;，虽然LinkedHashMap也是哈希表，但跟HashMap比起来，内容还是要少很多的，因为很多内容在HashMap中已经讲解过了，2333）&lt;/p&gt;
&lt;h2&gt;LinkedHashMap简介与简单使用&lt;/h2&gt;
&lt;p&gt;　　先来看看LinkedHashMap的继承结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180808101245908-953331148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LinkedHashMap属于Map大家族的一员，直接继承自HashMap，所以有着HashMap的全部特性，如高效查找元素，同时，LinkedHashMap保持了内部元素的顺序，有两种顺序模式，保持元素插入顺序或者访问顺序，因此适用于需保持元素顺序的场景。另外，由于LinkedHashMap有保持元素访问顺序的模式，所以也常被用作LRU缓存（Least-Recently-Used Cache，即最近最少使用缓存策略，后面会有介绍）。&lt;/p&gt;
&lt;h2&gt;LinkedHashMap的结构以及与HashMap的对比&lt;/h2&gt;
&lt;p&gt;　　LinkedHashMap中的结构相比HashMap更加复杂，首先它有着HashMap相同的结构，元素用数组+链表的形式存储，除此之外，所有元素还使用了双链表进行连接，相当于HashMap和LinkedList两种结构的结合体，也正是因为元素之间使用了链表连接，所有才能让其中的元素可以保持某种顺序。但也增加了维护这个链表的开销，每次进行增加和删除元素时，除了需要调整HashMap的结构，还需要调整链表结构，不过链表调整的开销并不大，除了数据量特别大的场景，一般情况下可以小到忽略不计。另一方面，由于所有元素使用链表相连，所以遍历的效率略高于HashMap，因为HashMap遍历时，需要每个桶中先遍历到链表尾部，然后再遍历到下一个桶，当元素不多而空桶数量很多时，就会有很多次的无效访问，所以理论上来说，LinkedHashMap的遍历效率是要比HashMap高的。说了这么多，好像LinkedHashMap处处要比HashMap好，为啥不都用LinkedHashMap呢？&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180808221040833-1789380034.png&quot; alt=&quot;&quot;/&gt;这个问题就跟LinkedList和ArrayList对比一样，两者都有其适用的场景，并没有绝对的孰优孰劣之分，所以还是要具体情况具体分析。&lt;/p&gt;
&lt;p&gt;　　好了，先来看看LinkedHashMap中的节点：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180809091632111-1447637691.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180809091643043-1084503690.png&quot; alt=&quot;&quot; width=&quot;485&quot; height=&quot;579&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　谜一样的继承关系，看完这个图，你也许会想，贵圈真乱，父类中的TreeNode继承自子类中的Entry，子类中的Entry又继承自父类中的Node。先别慌，这样做自然有它的道理，先来回顾一下Node的结构，Node是HashMap中的普通节点类，内部结构是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 指向下一个节点的引用
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
        ......省略部分代码  
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最上面的那个Entry是Map接口中的一个内部接口，只是规定了Entry该有的方法，并没有成员变量。在LinkedHashMap中，Entry内部类是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt; {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　增加了before和after引用，这样便可以和其他Entry一起组成一个双链表，节点不仅存储了键值对信息，还可以使用next，before，after来链接前后节点，next引用仅用于HashMap结构中链接同一个桶中的后一个元素，而before和after引用则是用来链接LinkedHashMap中的所有元素，将其链接成一个双链表的形式。接下来看一个跟HashMap结构的对比图就很清晰了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180809094429867-1344040040.png&quot; alt=&quot;&quot; width=&quot;1169&quot; height=&quot;1126&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180809094444983-674161244.png&quot; alt=&quot;&quot; width=&quot;1181&quot; height=&quot;1138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那再来回到之前的问题，为什么TreeNode要继承自LinkedHashMap中的Entry而不是直接继承自Node呢，毕竟在HashMap中并不需要使用到这样的链表性质，增加after和before两个引用只会浪费空间，首先，自然是为了复用代码，如果TreeNode直接继承自Node，则失去了链表的特性，LinkedHashMap继承HashMap后，则需要再使用另一个内部类来继承TreeNode来使得其具有链表特性，并且相关方法均需要重写，大大的增加了工作量，并且代码的可维护性会下降很多，另外，HashMap只会在桶中元素达到一定数量的时候才会将节点转换TreeNode，在哈希表散列良好的情况下，TreeNode是很少被使用到的，所以这一点点的空间浪费是值得的。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180810211517858-152407752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LinkedHashMap可以看成由两部分的组成，一部分与HashMap结构完全一致，另一部分则是一个双链表，由于LinkedHashMap是直接继承自HashMap的，所以哈希表的结构维护就在HashMap中的代码里进行，在LinkedHashMap中仅进行双链表的维护。这样也能很好的划分职能，使得代码结构也更加清晰。&lt;/p&gt;
&lt;p&gt;　　下面来通过代码感受一下两者的区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Map&lt;/span&gt;&amp;lt;String,Integer&amp;gt; linkedHashMap = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
        Map&lt;/span&gt;&amp;lt;String,Integer&amp;gt;  hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            linkedHashMap.put(&lt;/span&gt;&quot;I&quot; + i, i *&lt;span&gt; i);
            hashMap.put(&lt;/span&gt;&quot;I&quot; + i, i *&lt;span&gt; i);
        }

        System.out.println(&lt;/span&gt;&quot;hashMap 遍历：&quot;&lt;span&gt;);
        foreach(hashMap);
        System.out.println(&lt;/span&gt;&quot;linkedHashMap遍历：&quot;&lt;span&gt;);
        foreach(linkedHashMap);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; foreach(Map map){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object key : map.keySet()){
            System.out.println(&lt;/span&gt;&quot;key:&quot; + key.toString() + &quot; value:&quot; +&lt;span&gt; map.get(key).toString());
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;hashMap 遍历：
key:I9 value:&lt;/span&gt;81&lt;span&gt;
key:I0 value:&lt;/span&gt;0&lt;span&gt;
key:I1 value:&lt;/span&gt;1&lt;span&gt;
key:I2 value:&lt;/span&gt;4&lt;span&gt;
key:I3 value:&lt;/span&gt;9&lt;span&gt;
key:I4 value:&lt;/span&gt;16&lt;span&gt;
key:I5 value:&lt;/span&gt;25&lt;span&gt;
key:I6 value:&lt;/span&gt;36&lt;span&gt;
key:I7 value:&lt;/span&gt;49&lt;span&gt;
key:I8 value:&lt;/span&gt;64&lt;span&gt;
linkedHashMap遍历：
key:I0 value:&lt;/span&gt;0&lt;span&gt;
key:I1 value:&lt;/span&gt;1&lt;span&gt;
key:I2 value:&lt;/span&gt;4&lt;span&gt;
key:I3 value:&lt;/span&gt;9&lt;span&gt;
key:I4 value:&lt;/span&gt;16&lt;span&gt;
key:I5 value:&lt;/span&gt;25&lt;span&gt;
key:I6 value:&lt;/span&gt;36&lt;span&gt;
key:I7 value:&lt;/span&gt;49&lt;span&gt;
key:I8 value:&lt;/span&gt;64&lt;span&gt;
key:I9 value:&lt;/span&gt;81
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两个哈希表插入同样的元素，使用同样的方式进行遍历，HashMap得到的是无序的结果，而LinkedHashMap得到的是跟插入顺序一致的结果。而产生这样区别的根源就在于LinkedHashMap中的那个双链表。&lt;/p&gt;
&lt;p&gt;　　接下来我们通过LinkedHashMap的插入删除过程来了解双链表的维护过程。&lt;/p&gt;
&lt;h2&gt;LinkedHashMap的插入和删除&lt;/h2&gt;
&lt;p&gt;　　如果你没有看过代码，你也许会想，LinkedHashMap应该是通过重写put和remove方法来实现的，但事实上LinkedHashMap并没有覆盖插入和删除方法，这一点可以通过观察LinkedHashMap代码结构发现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180809103602451-776425537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　那么回到前面的栗子，既然没有覆盖put方法，调用LinkedHashMap中的put方法为什么会跟HashMap中的put方法得到的结果不一样呢？让我们再来看看put方法的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
                   &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
            n &lt;/span&gt;= (tab =&lt;span&gt; resize()).length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tab[i] &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);//newNode方法在LinkedHashMap中被覆盖
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                ((k &lt;/span&gt;= p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                e &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                e &lt;/span&gt;= ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        p.next &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st&lt;/span&gt;
&lt;span&gt;                            treeifyBin(tab, hash);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                        ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    p &lt;/span&gt;=&lt;span&gt; e;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
                V oldValue =&lt;span&gt; e.value;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    e.value &lt;/span&gt;=&lt;span&gt; value;
                afterNodeAccess(e);//关键方法A
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
            }
        }
        &lt;/span&gt;++&lt;span&gt;modCount;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
            resize();
        afterNodeInsertion(evict);//关键方法B
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　put方法调用的是putVal方法，在putVal方法的最后几行里，有这么两个方法值得注意，&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　　afterNodeAccess(e);&lt;br/&gt;　　&lt;br/&gt;　　&lt;/span&gt;afterNodeInsertion(evict);
&lt;/pre&gt;
&lt;p&gt;　　分别是在元素被访问之后和元素被插入之后调用，而这两个回调方法，在HashMap中并没有具体实现，只有一个空壳，留个LinkedHashMap来覆盖。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180810211536808-167356895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Callbacks to allow LinkedHashMap post-actions&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeAccess(Node&amp;lt;K,V&amp;gt;&lt;span&gt; p) { }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) { }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; afterNodeRemoval(Node&amp;lt;K,V&amp;gt; p) { }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在节点被移除后进行双链表的调整，移除调整其实很简单，就是把要移除的节点前一个节点的after引用指向后一个节点，把后一个节点的before引用指向前一个节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeRemoval(Node&amp;lt;K,V&amp;gt; e) {
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =&lt;span&gt;
            (LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
        p.before &lt;/span&gt;= p.after = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            b.after &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tail &lt;/span&gt;=&lt;span&gt; b;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            a.before &lt;/span&gt;=&lt;span&gt; b;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在节点被插入后进行双链表的调整，插入节点时会判断是否需要移除链表头节点，默认实现是不移除的，可以通过继承LinkedHashMap并覆盖removeEldestEntry方法来改变该特性&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt; evict) { 
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (evict &amp;amp;&amp;amp; (first = head) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; removeEldestEntry(first)) {
            K key &lt;/span&gt;=&lt;span&gt; first.key;
            removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在节点被访问之后进行双链表的调整（仅仅在accessOrder为true时进行，把当前访问的元素移动到链表尾部）&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; move node to last&lt;/span&gt;
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (accessOrder &amp;amp;&amp;amp; (last = tail) !=&lt;span&gt; e) {
            LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt;
                (LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
            p.after &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                b.after &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                a.before &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                last &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                p.before &lt;/span&gt;=&lt;span&gt; last;
                last.after &lt;/span&gt;=&lt;span&gt; p;
            }
            tail &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;++&lt;span&gt;modCount;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再来看看在LinkedHashMap中被覆盖的newNode方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    Node&amp;lt;K,V&amp;gt; newNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =
            &lt;span&gt;new&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, e);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建节点，然后链接到双链表的尾部&lt;/span&gt;
&lt;span&gt;        linkNodeLast(p);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; linkNodeLast(LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; last =&lt;span&gt; tail;
        tail &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            p.before &lt;/span&gt;=&lt;span&gt; last;
            last.after &lt;/span&gt;=&lt;span&gt; p;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在再来梳理一下逻辑，插入节点的时候，会调用覆盖过的newNode方法，将插入的元素链接的链表尾部，删除节点的时候，将该节点的前后节点相连即可，当节点被访问时，可以将其放到链表尾部（该特性后面会讲解）。如果对于双链表的插入删除还是不太了解，可以回头看看前面关于LinkedList的说明，里面有关于双链表结构调整的详细讲解。（理直气壮的偷懒）&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180810211549539-881258175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;LinkedHashMap的源码分析&lt;/h2&gt;
&lt;p&gt;　　先来看看它的几个内部类，节点类Entry在前面已经介绍过了，剩下的几个类有四个是迭代器类，三个是键、值以及键值对的集合类。先看看迭代器类，在LinkedHashMap中，也在内部实现了自己的迭代器，内部迭代器都继承自LinkedHashIterator类，该类代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedHashIterator {
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
        LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; current;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedModCount;

        LinkedHashIterator() {
            next &lt;/span&gt;=&lt;span&gt; head;
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode() {
            LinkedHashMap.Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            current &lt;/span&gt;=&lt;span&gt; e;
            next &lt;/span&gt;=&lt;span&gt; e.after;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt; current;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            K key &lt;/span&gt;=&lt;span&gt; p.key;
            removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个抽象类，实现了迭代器的主要方法，hashNext，remove，nextNode方法，相当于一个类模板，其他迭代器类只需要继承该类然后添加一个next方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedKeyIterator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; LinkedHashIterator
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;K&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; K next() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextNode().getKey(); }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedValueIterator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; LinkedHashIterator
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V next() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextNode().value; }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedEntryIterator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; LinkedHashIterator
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt; next() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextNode(); }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　怎么样，是不是贼简单。&lt;/p&gt;
&lt;p&gt;　　剩下三个集合视图类结构基本一致，跟HashMap中的对应集合视图其实基本是一毛一样的，不信可以对比一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HashMap中的EntrySet&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntrySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { HashMap.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EntryIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;) o;
            Object key &lt;/span&gt;=&lt;span&gt; e.getKey();
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; candidate =&lt;span&gt; getNode(hash(key), key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; candidate != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; candidate.equals(e);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry) {
                Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;) o;
                Object key &lt;/span&gt;=&lt;span&gt; e.getKey();
                Object value &lt;/span&gt;=&lt;span&gt; e.getValue();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeNode(hash(key), key, value, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; spliterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EntrySpliterator&amp;lt;&amp;gt;(HashMap.&lt;span&gt;this&lt;/span&gt;, 0, -1, 0, 0&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; action) {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size &amp;gt; 0 &amp;amp;&amp;amp; (tab = table) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tab.length; ++&lt;span&gt;i) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; e = tab[i]; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next)
                        action.accept(e);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LinkedHashMap中的EntrySet&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedEntrySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { LinkedHashMap.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedEntryIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;) o;
            Object key &lt;/span&gt;=&lt;span&gt; e.getKey();
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; candidate =&lt;span&gt; getNode(hash(key), key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; candidate != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; candidate.equals(e);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry) {
                Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;) o;
                Object key &lt;/span&gt;=&lt;span&gt; e.getKey();
                Object value &lt;/span&gt;=&lt;span&gt; e.getValue();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeNode(hash(key), key, value, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; spliterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, Spliterator.SIZED |&lt;span&gt;
                                            Spliterator.ORDERED &lt;/span&gt;|&lt;span&gt;
                                            Spliterator.DISTINCT);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; action) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (LinkedHashMap.Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
                action.accept(e);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　仅仅是在迭代器方法中返回各自的内部迭代器实例而已。其余逻辑基本一致。&lt;/p&gt;
&lt;p&gt;　　LinkedKeySet和LinkedValues也很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedKeySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;K&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { LinkedHashMap.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;K&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedKeyIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; contains(Object o) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsKey(o); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object key) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeNode(hash(key), key, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;K&amp;gt;&lt;span&gt; spliterator()  {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, Spliterator.SIZED |&lt;span&gt;
                                            Spliterator.ORDERED &lt;/span&gt;|&lt;span&gt;
                                            Spliterator.DISTINCT);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; action) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (LinkedHashMap.Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
                action.accept(e.key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedValues &lt;span&gt;extends&lt;/span&gt; AbstractCollection&amp;lt;V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { LinkedHashMap.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;V&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedValueIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; contains(Object o) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsValue(o); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;V&amp;gt;&lt;span&gt; spliterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, Spliterator.SIZED |&lt;span&gt;
                                            Spliterator.ORDERED);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; V&amp;gt;&lt;span&gt; action) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (LinkedHashMap.Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
                action.accept(e.value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看完内部类，我们再来看看它的几个构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的保持插入顺序的LinkedHashMap实例，使用指定的初始容量和装载因子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialCapacity, loadFactor);
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的保持插入顺序的LinkedHashMap实例，使用指定的初始容量和默认的装载因子（0.75）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialCapacity);
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的保持插入顺序的LinkedHashMap实例，使用默认的初始容量（16）和默认的装载因子（0.75）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedHashMap() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用指定Map的所有映射构造一个保持插入顺序的LinkedHashMap实例，使用默认的装载因子和可以容纳指定map中所有映射的合适的容量。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        putMapEntries(m, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用指定初始容量，指定装载因子和指定顺序模式来创建一个空的LinkedHashMap实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity,
                         &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor,
                         &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accessOrder) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialCapacity, loadFactor);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accessOrder =&lt;span&gt; accessOrder;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　跟HashMap中的构造函数也几无二致，除了一点，那就是多了一个特殊的成员变量，accessOrder，这个变量是干嘛的呢，其实是一个表示LinkedHashMap中元素存储顺序的标志，前面也提到过，LinkedHashMap中元素其实是可以按两种顺序进行存储的，一种是元素的插入顺序，另一种便是元素的访问顺序，如果accessOrder为true，则使用访问顺序，即最近访问的元素位于链表最后，如果accessOrder为false，则使用插入顺序，即最后被插入的元素位于链表最后。默认是使用插入顺序，当然，也可以通过最后一个构造函数来使用指定顺序。如果你足够细心的话，还会发现有这么一个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt; evict) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; possibly remove eldest&lt;/span&gt;
    LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; first;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据条件判断是否移除最近最少被访问的节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (evict &amp;amp;&amp;amp; (first = head) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; removeEldestEntry(first)) {
        K key &lt;/span&gt;=&lt;span&gt; first.key;
        removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; removeEldestEntry(Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; eldest) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　removeEldestEntry方法在默认情况下是返回false的，所以在插入节点的时候，默认是不会删除之前节点的，但我们可以通过继承来改变这一特性。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180810211614492-1679276571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;基于LinkedHashMap实现LRU缓存&lt;/h2&gt;
&lt;p&gt;　　首先还是对LRU缓存做一个相对简单的介绍：&lt;/p&gt;
&lt;p&gt;　　LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。&lt;/p&gt;
&lt;p&gt;　　其实是一个缓存淘汰策略，当缓存数量达到一个阈值时，优先淘汰最近最少被访问的数据。当我们使用LinkedHashMap来实现LRU缓存时，可以通过覆写&lt;code&gt;removeEldestEntry&lt;/code&gt;方法可以实现自定义策略的 LRU 缓存。比如我们可以根据节点数量判断是否移除最近最少被访问的节点，或者根据节点的存活时间判断是否移除该节点等。下面栗子所实现的缓存是基于判断节点数量是否超限的策略。在构造缓存对象时，传入最大节点数。当插入的节点数超过最大节点数时，移除最近最少被访问的节点。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LRUCache&amp;lt;K, V&amp;gt; &lt;span&gt;extends&lt;/span&gt; LinkedHashMap&amp;lt;K, V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_CACHE_SIZE = 100&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; limit;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LRUCache() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(MAX_CACHE_SIZE);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LRUCache(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cacheSize) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(cacheSize, 0.75f, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.limit =&lt;span&gt; cacheSize;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V save(K key, V val) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; put(key, val);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getOne(K key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; get(key);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; exists(K key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsKey(key);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断节点数是否超限
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; eldest
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 超限返回 true，否则返回 false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; removeEldestEntry(Map.Entry eldest) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size() &amp;gt;&lt;span&gt; limit;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;K, V&amp;gt;&lt;span&gt; entry : entrySet()) {
            sb.append(String.format(&lt;/span&gt;&quot;%s:%s &quot;&lt;span&gt;, entry.getKey(), entry.getValue()));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        LRUCache&lt;/span&gt;&amp;lt;String, Integer&amp;gt; cache = &lt;span&gt;new&lt;/span&gt; LRUCache&amp;lt;&amp;gt;(3&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            cache.save(&lt;/span&gt;&quot;I&quot; + i, i *&lt;span&gt; i);
        }

        System.out.println(&lt;/span&gt;&quot;插入10个键值对后，缓存内容为：&quot;&lt;span&gt;);
        System.out.println(cache &lt;/span&gt;+ &quot;\n&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;访问键值为I8的节点后，缓存内容为：&quot;&lt;span&gt;);
        cache.getOne(&lt;/span&gt;&quot;I8&quot;&lt;span&gt;);
        System.out.println(cache &lt;/span&gt;+ &quot;\n&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;插入键值为I1的键值对后，缓存内容：&quot;&lt;span&gt;);
        cache.save(&lt;/span&gt;&quot;I1&quot;, 1&lt;span&gt;);
        System.out.println(cache);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;插入10个键值对后，缓存内容为：
I7:&lt;/span&gt;49 I8:64 I9:81&lt;span&gt; 

访问键值为I8的节点后，缓存内容为：
I7:&lt;/span&gt;49 I9:81 I8:64&lt;span&gt; 

插入键值为I1的键值对后，缓存内容：
I9:&lt;/span&gt;81 I8:64 I1:1 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上述代码中，缓存大小设置为3，当在缓存中插入10个键值对后，只有最后3个被保存下来了，其他的都被移除了。然后通过访问键值为I8的节点，使得该节点被移到双向链表的最后位置。当我们再次插入一个键值对时，键值为I7的节点就会被淘汰掉。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader8&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;　　本文从 LinkedHashMap 哈希表+链表维护的角度对 LinkedHashMap 的源码进行了分析，并在文章的结尾基于 LinkedHashMap 实现了一个简单的 Cache。在日常开发中，LinkedHashMap 的使用频率虽不及 HashMap，但它也是不可或缺的重要实现。在 Java 集合框架中，HashMap、LinkedHashMap 和 TreeMap 三个映射类基于不同的数据结构，并实现了不同的功能。HashMap 底层基于拉链式的散列结构，并在 JDK 1.8 中引入红黑树优化过长链表的问题。基于这样结构，HashMap 可提供高效的增删改查操作。LinkedHashMap 在其之上，通过维护一条双向链表，实现了散列数据结构的有序遍历。TreeMap 底层基于红黑树实现，利用红黑树的性质，实现了键值对排序功能。TreeMap相关内容将会在后面的文章里进行讲解。&lt;/p&gt;
&lt;p&gt;　　最后是又臭又长的源码注解，大家可以选择自己感兴趣的部分进行阅读，最好在IDE中进行阅读，这样可以很方便的进行跳转。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180810211628611-1715713167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;178&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Consumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.BiConsumer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.BiFunction;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Map 接口的哈希表和链表实现，具有可预测的迭代顺序。此实现与 HashMap 的不同之处在于它维护了一个贯穿其所有条目的双向链表。
 * 此链接列表定义迭代排序，通常是键插入映射的顺序（插入顺序）。 请注意，如果将键重新插入到Map中，则插入顺序不会受到影响。
 * （如果在m.containsKey时调用 m.put（k，v），则将键k 重新插入到map m 中,会在调用之前立即返回true 。）
 *
 * 这种实现使客户免于{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; HashMap}（以及{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Hashtable}）提供的不确定的，通常是混乱的排序，并且不会导致类似{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; TreeMap}相关的成本增加。
 * 无论原始Map的实现如何，它都可用于生成与原始Map具有相同顺序的Map副本：
 *
 *     void foo(Map m) {
 *         Map copy = new LinkedHashMap(m);
 *         ...
 *     }
 *
 * 如果模块在输入上获取map，复制它，然后返回其顺序由副本确定的结果，则此技术特别有用。 （客户通常会欣赏按照提交的顺序返回的内容。）
 *
 * 提供了一个特殊的{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #LinkedHashMap（int，float，boolean）构造函数}来创建一个链接的哈希映射，其迭代顺序是其条目最后一次访问的顺序，
 * 从最近最少访问到最近最多访问（按存取顺序）。这种地图非常适合构建LRU缓存。调用{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; put}，{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; putIfAbsent}，{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; get}，
 * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; getOrDefault}，{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; compute}，{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; computeIfAbsent}，{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; computeIfPresent}或{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; merge}方法
 * 导致访问相应的条目（假设它在调用完成后存在）。 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; replace}方法仅在替换值时才会访问该条目。 {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; putAll}方法为指定映射中的
 * 每个映射生成一个条目访问，按照指定映射的条目集迭代器提供键 - 值映射的顺序。没有其他方法可以生成条目访问。
 * 特别是，对集合视图的操作不会影响支持映射的迭代顺序。
 *
 * TODO LRU缓存
 *
 * 可以重写{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #removeEldestEntry（Map.Entry）}方法，以强制在将新映射添加到Map中时自动删除过时映射的策略。
 *
 * 此类提供所有可选的Map操作，并允许null元素。 与HashMap一样，假设哈希函数在桶之间正确地分散元素，它将为基本操作（添加，包含和删除）提供了恒定时间
 * 性能，由于维护链表的额外费用，性能可能略低于HashMap的性能，但有一个例外：
 * 无论其容量如何，对LinkedHashMap的集合视图进行迭代需要与映射大小成比例的时间。而对HashMap的迭代可能更昂贵，需要与其容量成比例的时间。
 *
 * 链接的哈希映射有两个影响其性能的参数：初始容量和加载因子。它们的定义与 HashMap 完全相同。
 * 但请注意，对于此类，选择过高的初始容量值的惩罚不如 HashMap ，因为此类的迭代次数不受容量影响。
 *
 * 请注意，此实现未同步。如果多个线程同时访问链接的哈希映射，并且至少有一个线程在结构上修改了映射，则&amp;lt;em&amp;gt;必须&amp;lt;/ em&amp;gt;外部同步。
 * 这通常通过在自然封装地图的某个对象上进行同步来实现。如果不存在此类对象，
 * 则应使用{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Collections＃synchronizedMap Collections.synchronizedMap}方法“包装”映射。这最好在创建时完成，
 * 以防止意外地不同步访问地图：
 *  Map m = Collections.synchronizedMap（new LinkedHashMap（...））;
 *
 * 结构修改是指任何添加或删除一个或多个映射的操作，或者在访问顺序链接的哈希映射的情况下，影响迭代顺序。
 * 在插入有序链接散列映射中，仅更改与已包含在映射中的键相关联的值不是结构修改。在访问顺序链接哈希映射中，仅使用 get 查询地图是一种结构修改。
 *
 * 由该类的所有集合视图方法&amp;lt;tt&amp;gt; iterator &amp;lt;/ tt&amp;gt;方法返回的迭代器是 “fail-fast” 的：
 * 如果map在创建迭代器之后的任何时候进行结构修改，（除了通过迭代器自己的&amp;lt;tt&amp;gt; remove &amp;lt;/ tt&amp;gt;方法之外），
 * 迭代器将抛出{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; ConcurrentModificationException}。因此，在并发修改的情况下，迭代器快速而干净地失败，
 * 而不是在未来的未确定时间冒任意，非确定性行为的风险。
 *
 * 请注意，迭代器的快速失败行为无法得到保证，因为一般来说，在存在非同步并发修改的情况下，不可能做出任何硬性保证。
 * 失败快速的迭代器会尽最大努力抛出&amp;lt;tt&amp;gt; ConcurrentModificationException &amp;lt;/ tt&amp;gt;。因此，编写依赖于此异常的程序以确保其正确性是错误的：
 * 迭代器的故障快速行为应仅用于检测错误。
 *
 * 分裂器返回的分裂器所有此类的集合视图方法返回的集合的方法是后期绑定的，失败快速的和附加报告的{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator #OrderED}。
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedHashMap&amp;lt;K,V&amp;gt;
        &lt;span&gt;extends&lt;/span&gt; HashMap&amp;lt;K,V&amp;gt;
        &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实现说明。 此类的先前版本的内部结构略有不同。 因为超类HashMap现在为其某些节点使用树节点，所以类Entry现在被视为中间节点类，
     * 也可以转换为树形式。 这个类的名称Entry在其当前上下文中以多种方式混淆，但无法更改。 否则，即使它未被导出到此包之外，
     * 已知一些现有的源代码依赖于对removeEldestEntry的调用中的符号解析角案例规则，该删除由于模糊使用而抑制了编译错误。
     * 因此，我们保留名称以保留未修改的可编译性。 节点类的更改还需要使用两个字段（头部，尾部）而不是指向标头节点的指针来维护列表之前/之后的双向链接。
     * 此类以前还在访问，插入和删除时使用了不同类型的回调方法。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 普通 LinkedHashMap 条目的HashMap.Node子类.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt; {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 3801124242820219131L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 第一个条目
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; head;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 最后一个条目
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; tail;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 迭代顺序，true代表使用访问顺序进行迭代，false代表使用插入顺序进行迭代
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accessOrder;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部工具方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链接到链表尾部&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; linkNodeLast(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; last =&lt;span&gt; tail;
        tail &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; p;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            p.before &lt;/span&gt;=&lt;span&gt; last;
            last.after &lt;/span&gt;=&lt;span&gt; p;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用dst条目代替src条目&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; transferLinks(Entry&amp;lt;K,V&amp;gt;&lt;span&gt; src,
                               Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; dst) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; b = dst.before =&lt;span&gt; src.before;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; a = dst.after =&lt;span&gt; src.after;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; dst;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            b.after &lt;/span&gt;=&lt;span&gt; dst;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tail &lt;/span&gt;=&lt;span&gt; dst;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            a.before &lt;/span&gt;=&lt;span&gt; dst;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重载 HashMap 中的方法&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reinitialize() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.reinitialize();
        head &lt;/span&gt;= tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建条目并链接到链表尾部&lt;/span&gt;
    Node&amp;lt;K,V&amp;gt; newNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; e) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =
                &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, e);
        linkNodeLast(p);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代替节点&lt;/span&gt;
    Node&amp;lt;K,V&amp;gt; replacementNode(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; q = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)p;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; t =
                &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt;(q.hash, q.key, q.value, next);
        transferLinks(q, t);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }

    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; newTreeNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;new&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, next);
        linkNodeLast(p);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
    }

    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; replacementTreeNode(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; q = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)p;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; t = &lt;span&gt;new&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;(q.hash, q.key, q.value, next);
        transferLinks(q, t);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点移除之后，将其从双链表中拆分出来&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeRemoval(Node&amp;lt;K,V&amp;gt; e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unlink&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt; p =&lt;span&gt;
                (Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
        p.before &lt;/span&gt;= p.after = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            head &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            b.after &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            tail &lt;/span&gt;=&lt;span&gt; b;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            a.before &lt;/span&gt;=&lt;span&gt; b;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点插入之后判断是否需要将最早的元素进行删除&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeInsertion(&lt;span&gt;boolean&lt;/span&gt; evict) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; possibly remove eldest&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要同时满足三个条件才能在插入元素后对最早插入条目进行删除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (evict &amp;amp;&amp;amp; (first = head) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; removeEldestEntry(first)) {
            K key &lt;/span&gt;=&lt;span&gt; first.key;
            removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在节点被访问之后，判断是否需要将被访问过的节点移动到双链表的最末尾&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; move node to last&lt;/span&gt;
        Entry&amp;lt;K,V&amp;gt;&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当accessOrder成员变量为true并且该访问元素不是最后一个元素时，将其移动到双链表的末尾&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (accessOrder &amp;amp;&amp;amp; (last = tail) !=&lt;span&gt; e) {
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt;
                    (Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;)e, b = p.before, a =&lt;span&gt; p.after;
            p.after &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                b.after &lt;/span&gt;=&lt;span&gt; a;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                a.before &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                last &lt;/span&gt;=&lt;span&gt; b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (last == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                head &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                p.before &lt;/span&gt;=&lt;span&gt; last;
                last.after &lt;/span&gt;=&lt;span&gt; p;
            }
            tail &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;++&lt;span&gt;modCount;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写hashmap的internalWriteEntries方法，进行输出流的写入&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; internalWriteEntries(java.io.ObjectOutputStream s) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after) {
            s.writeObject(e.key);
            s.writeObject(e.value);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的保持插入顺序的LinkedHashMap实例，使用指定的初始容量和装载因子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialCapacity, loadFactor);
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的保持插入顺序的LinkedHashMap实例，使用指定的初始容量和默认的装载因子（0.75）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialCapacity);
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的保持插入顺序的LinkedHashMap实例，使用默认的初始容量（16）和默认的装载因子（0.75）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedHashMap() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用指定Map的所有映射构造一个保持插入顺序的LinkedHashMap实例，使用默认的装载因子和可以容纳指定map中所有映射的合适的容量。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        accessOrder &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        putMapEntries(m, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用指定初始容量，指定装载因子和指定顺序模式来创建一个空的LinkedHashMap实例。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity,
                         &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor,
                         &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accessOrder) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialCapacity, loadFactor);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accessOrder =&lt;span&gt; accessOrder;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this map maps one or more keys to the
     * specified value.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value value whose presence in this map is to be tested
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this map maps one or more keys to the
     *         specified value
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(Object value) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO 与hashmap的遍历方式进行比较
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; LinkedHashMap中遍历元素时都是使用链表的方式进行遍历&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after) {
            V v &lt;/span&gt;=&lt;span&gt; e.value;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v == value || (value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; value.equals(v)))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取指定key对应的value，不存在则返回null
     * 返回null时有两种可能，一种是该key没有对应的映射，另一种是该key对应的value是null，可以使用containsKey方法对这两种情况进行区分
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessOrder)
            afterNodeAccess(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取指定key对应的value，如果不存在则返回默认值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getOrDefault(Object key, V defaultValue) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultValue;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (accessOrder)
            afterNodeAccess(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清除元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clear();
        head &lt;/span&gt;= tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 如果此map应删除其最旧的条目，则返回true 。在将新条目插入Map后，put 和 putAll 将调用此方法。
     * 它为实现者提供了在每次添加新条目时删除最旧条目的机会。如果映射表示高速缓存，则此选项非常有用：它允许映射通过删除过时条目来减少内存消耗。
     *
     * 示例：此覆盖实现将允许map增长到100个条目，
     * 然后在每次添加新条目时删除最旧的条目，保持100个条目的稳定状态。
     *
     * private static final int MAX_ENTRIES = 100;
     * protected boolean removeEldestEntry（Map.Entry eldest）{
     * return size（）; MAX_ENTRIES;
     * }
     *
     * 此方法通常不会以任何方式修改地图，而是允许地图按其返回值的指示修改自身。 此方法直接修改map是允许的，但如果它这样做，
     * 它必须返回false（表示map不应该尝试任何进一步的修改）。在此方法中修改地图后返回 true 的效果未指定。此实现仅返回 false
     * （因此此映射的行为类似于普通映射 - 永远不会删除最旧的元素）。
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; eldest map中最近插入的条目，或者如果这是访问顺序地图，则是最近访问的条目。这是将被删除的条目，此方法返回 true 。
     *               如果在 put 或 putAll 调用之前映射为空，从而导致此调用，则这将是刚刚插入的条目;换句话说，如果map包含单个条目，
     *               则最老的条目也是最新的。
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 表示应从map中删除最年长的条目;  false 表示应该保留。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; removeEldestEntry(Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; eldest) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回包含该map所有key的{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Set}视图。 该集合由map支持，因此对map的更改将反映在集中，反之亦然。 如果在对集合进行迭代时修改了映射
     * （除了通过迭代器自己的remove 操作），迭代的结果是未定义的。 该集支持元素删除，它通过 Iterator.remove ，Set.remove ， removeAll
     * ，从地map中删除相应的映射。 retainAll 和 clear 操作。 它不支持 add 或 addAll 操作。 它的{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator}通常提供更快的顺序性能，
     * 但并行性能比{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HashMap}差得多。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;K&amp;gt;&lt;span&gt; keySet() {
        Set&lt;/span&gt;&amp;lt;K&amp;gt; ks =&lt;span&gt; keySet;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ks == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            ks &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedKeySet();
            keySet &lt;/span&gt;=&lt;span&gt; ks;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ks;
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedKeySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;K&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;K&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedKeyIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; contains(Object o) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsKey(o); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object key) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeNode(hash(key), key, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;K&amp;gt;&lt;span&gt; spliterator()  {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, Spliterator.SIZED |&lt;span&gt;
                    Spliterator.ORDERED &lt;/span&gt;|&lt;span&gt;
                    Spliterator.DISTINCT);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; action) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
                action.accept(e.key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }

&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Collection&amp;lt;V&amp;gt;&lt;span&gt; values() {
        Collection&lt;/span&gt;&amp;lt;V&amp;gt; vs =&lt;span&gt; values;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            vs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedValues();
            values &lt;/span&gt;=&lt;span&gt; vs;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vs;
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedValues &lt;span&gt;extends&lt;/span&gt; AbstractCollection&amp;lt;V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;V&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedValueIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; contains(Object o) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; containsValue(o); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;V&amp;gt;&lt;span&gt; spliterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, Spliterator.SIZED |&lt;span&gt;
                    Spliterator.ORDERED);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; V&amp;gt;&lt;span&gt; action) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
                action.accept(e.value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回包含该map中所有映射的Set视图，该set由map支持，因此对map的更改将反映在set中，反之亦然。 如果在对集合进行迭代时修改了映射
     * （除非通过迭代器自己的 remove 操作，或者对迭代器返回的映射条目执行 setValue 操作） ）迭代的结果是未定义的。 该集支持元素删除，
     * 它通过 Iterator.remove  Set.remove ， removeAll ，从地图中删除相应的映射。 retainAll 和 clear 操作。 它不支持 add 或
     *  addAll 操作。 它的{&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator}通常提供更快的顺序性能，但并行性能比{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HashMap}差得多。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet() {
        Set&lt;/span&gt;&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; es;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (es = entrySet) == &lt;span&gt;null&lt;/span&gt; ? (entrySet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedEntrySet()) : es;
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedEntrySet &lt;span&gt;extends&lt;/span&gt; AbstractSet&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size()                 { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear()               { &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clear(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; iterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedEntryIterator();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;) o;
            Object key &lt;/span&gt;=&lt;span&gt; e.getKey();
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; candidate =&lt;span&gt; getNode(hash(key), key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; candidate != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; candidate.equals(e);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry) {
                Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;) o;
                Object key &lt;/span&gt;=&lt;span&gt; e.getKey();
                Object value &lt;/span&gt;=&lt;span&gt; e.getValue();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; removeNode(hash(key), key, value, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Spliterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; spliterator() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, Spliterator.SIZED |&lt;span&gt;
                    Spliterator.ORDERED &lt;/span&gt;|&lt;span&gt;
                    Spliterator.DISTINCT);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; action) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
                action.accept(e);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Map overrides&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(BiConsumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; K, ? &lt;span&gt;super&lt;/span&gt; V&amp;gt;&lt;span&gt; action) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
            action.accept(e.key, e.value);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; replaceAll(BiFunction&amp;lt;? &lt;span&gt;super&lt;/span&gt; K, ? &lt;span&gt;super&lt;/span&gt; V, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; function) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (function == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mc =&lt;span&gt; modCount;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e = head; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.after)
            e.value &lt;/span&gt;=&lt;span&gt; function.apply(e.key, e.value);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; mc)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代器&lt;/span&gt;

    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedHashIterator {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; current;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedModCount;

        LinkedHashIterator() {
            next &lt;/span&gt;=&lt;span&gt; head;
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode() {
            Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            current &lt;/span&gt;=&lt;span&gt; e;
            next &lt;/span&gt;=&lt;span&gt; e.after;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; p =&lt;span&gt; current;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
            current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            K key &lt;/span&gt;=&lt;span&gt; p.key;
            removeNode(hash(key), key, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            expectedModCount &lt;/span&gt;=&lt;span&gt; modCount;
        }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedKeyIterator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; LinkedHashIterator
            &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;K&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; K next() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextNode().getKey(); }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedValueIterator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; LinkedHashIterator
            &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V next() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextNode().value; }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedEntryIterator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; LinkedHashIterator
            &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt; next() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextNode(); }
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，本篇就算完结啦，一周一篇的小目标也算是完成了，周末要去浪浪浪了，哈哈哈哈。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180810211649182-544929347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　后续还会继续更新，欢迎继续关注！&lt;/p&gt;

</description>
<pubDate>Fri, 10 Aug 2018 13:17:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>今天来介绍一下容器类中的另一个哈希表———》LinkedHashMap。这是HashMap的关门弟子，直接继承了HashMap的衣钵，所以拥有HashMap的全部特性，并青出于蓝而胜于蓝，有着一些Ha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9440313.html</dc:identifier>
</item>
</channel>
</rss>