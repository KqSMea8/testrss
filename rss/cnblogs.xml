<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RAC(ReactiveCocoa)使用方法(一) - soliloquy.local</title>
<link>http://www.cnblogs.com/soliloquy/p/7920551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soliloquy/p/7920551.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/28144edff618&quot;&gt;RAC(ReactiveCocoa)使用方法(一)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.jianshu.com/p/c990dd1f3f9c&quot;&gt;RAC(ReactiveCocoa)使用方法(二)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是rac&quot;&gt;什么是RAC？&lt;/h4&gt;
&lt;p&gt;最近回顾了一下&lt;code&gt;ReactiveCocoa&lt;/code&gt;的方法，也看了一些人的文章，现写篇文章总结一下。&lt;br/&gt;现在这个库最新支持Swift，如果你要是用&lt;code&gt;Cocoapods&lt;/code&gt;的话不指定版本它默认是下载Swift版本，如果依旧想用OC版本就指定一个版本，最好是V2.5版本及以下，否则可能会出现错误。最近我试的是V2.5，可以正常使用。&lt;br/&gt;项目中用&lt;code&gt;Cocoapods&lt;/code&gt;使用：&lt;code&gt;pod &quot;ReactiveCocoa&quot;, '~&amp;gt; 2.5'&lt;/code&gt;&lt;br/&gt;那什么是RAC勒？想必大家随便谷歌一下就一大片这个概念和文章。&lt;br/&gt;RAC具有函数响应式编程特性，由&lt;code&gt;Matt Diephouse&lt;/code&gt;开源的一个应用于iOS和OS X的新框架。&lt;/p&gt;
&lt;h6 id=&quot;部分参考来源&quot;&gt;&lt;a href=&quot;http://www.jianshu.com/p/87ef6720a096&quot;&gt;部分参考来源&lt;/a&gt;&lt;/h6&gt;
&lt;h4 id=&quot;为什么要使用rac&quot;&gt;为什么要使用RAC？&lt;/h4&gt;
&lt;p&gt;因为RAC具有高聚合低耦合的思想，使用RAC会让代码更简洁，逻辑更清晰。再结合MVVM架构，让你瞬间爽爆了！&lt;/p&gt;
&lt;p&gt;RAC有很多的类，为很多的UI控件都拓展了方法，使得开发大大的简便化，这里就简单的介绍开发过程中用到的方法。&lt;br/&gt;打开应用的初始ViewController，引入ReactiveCocoa的头文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#import &amp;lt;ReactiveCocoa/ReactiveCocoa.h&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制器中创建一个TextField，SB拖入更方便，然后如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[self.TextField.rac_textSignal subscribeNext:^(id x){
  NSLog(@&quot;x:%@&quot;, x);
}];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译运行，在输入框中输入文字。注意打印信息的输出应该和下面的类似。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2017-11-29 10:26:25.152197+0800 MVVM-Demo[1089:230607] x:a
2017-11-29 10:26:25.159596+0800 MVVM-Demo[1089:230607] x:ah
2017-11-29 10:26:25.385413+0800 MVVM-Demo[1089:230607] x:ahv
2017-11-29 10:26:25.576558+0800 MVVM-Demo[1089:230607] x:ahva
2017-11-29 10:26:25.764013+0800 MVVM-Demo[1089:230607] x:ahvah
2017-11-29 10:26:25.784379+0800 MVVM-Demo[1089:230607] x:ahvahv
2017-11-29 10:26:25.853596+0800 MVVM-Demo[1089:230607] x:ahvahvj
2017-11-29 10:26:25.868552+0800 MVVM-Demo[1089:230607] x:ahvahvja
2017-11-29 10:26:26.002545+0800 MVVM-Demo[1089:230607] x:ahvahvjav
2017-11-29 10:26:26.062553+0800 MVVM-Demo[1089:230607] x:ahvahvjavj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你看到这些打印信息，你是不是觉得很神奇，都没有监听TextField的方法，它咋就那么牛逼勒。其实RAC内部就帮你做了许多事情。你只要调用相应控件的RAC方法就可以监听到它们的状态了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;那么它是怎么监听怎么做到的勒？&lt;/code&gt;&lt;br/&gt;这里要讲几个很重要的RAC类，不涉及RAC原理，内部怎么实现还要大家去阅读源码了。&lt;/p&gt;
&lt;ul readability=&quot;5.9853181076672&quot;&gt;&lt;li readability=&quot;14.963295269168&quot;&gt;
&lt;h5 id=&quot;racsiganl&quot;&gt;RACSiganl&lt;/h5&gt;
&lt;p&gt;1、&lt;code&gt;RACSiganl&lt;/code&gt;信号类，表示将来有数据传递，有数据改变，信号内部接收到数据，就会马上发出数据，外部就可以接收到数据了。就像刚刚上面的例子一样。&lt;br/&gt;2、默认信号都是冷信号，就是这个值改变了它不会触发，只有订阅（调用信号RACSignal的subscribeNext订阅）了这个信号，这个信号才会变为热信号(值一改变就触发)，才会触发。&lt;/p&gt;
&lt;h6 id=&quot;racsiganl简单使用&quot;&gt;&lt;code&gt;RACSiganl简单使用:&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;```&lt;br/&gt;// 1.创建信号&lt;br/&gt;RACSignal &lt;em&gt;siganl = [RACSignal createSignal:^RACDisposable&lt;/em&gt; (id&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 每当有订阅者订阅信号，就会调用block。
// 2.发送信号
[subscriber sendNext:@&quot;我是一个信号📶&quot;];

// 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。
[subscriber sendCompleted];

return [RACDisposable disposableWithBlock:^{
    // 当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。
    // 执行完Block后，当前信号就不在被订阅了。
    NSLog(@&quot;dealloc&quot;);

}];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}];&lt;/p&gt;
&lt;p&gt;// 3.订阅信号,才会激活信号.&lt;br/&gt;[siganl subscribeNext:^(id x) {&lt;br/&gt;// block调用时刻：每当有信号发出数据，就会调用block.&lt;br/&gt;NSLog(@&quot;数据: &lt;a&gt;%@&quot;&lt;/a&gt;,x);&lt;br/&gt;}];&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
打印如下
 ```
2017-11-29 11:04:34.383754+0800 MVVM-Demo[1185:379135] 数据:我是一个信号📶
2017-11-29 11:04:34.383878+0800 MVVM-Demo[1185:379135] dealloc&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;h5 id=&quot;racsubscriber&quot;&gt;RACSubscriber&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;RACSubscriber&lt;/code&gt;订阅者，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;h5 id=&quot;racdisposable&quot;&gt;RACDisposable&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;RACDisposable&lt;/code&gt;用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 当你不想监听某个信号时，可以通过它主动取消订阅信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&quot;racsubject&quot;&gt;RACSubject&lt;/h5&gt;
&lt;code&gt;RACSubject&lt;/code&gt;信号提供者，自己可以充当信号，又能发送信号。通常用来代替代理，有了它，就不必要定义代理了。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h5 id=&quot;racreplaysubject&quot;&gt;RACReplaySubject&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;RACReplaySubject&lt;/code&gt;重复提供信号类，RACSubject的子类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RACReplaySubject&lt;/code&gt;与&lt;code&gt;RACSubject&lt;/code&gt;区别:&lt;br/&gt;&lt;code&gt;RACReplaySubject&lt;/code&gt;可以先发送信号，在订阅信号，&lt;code&gt;RACSubject&lt;/code&gt;就不可以。&lt;br/&gt;```&lt;/li&gt;
&lt;li&gt;如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以设置capacity数量来限制缓存的value的数量, 即只缓存最新的几个值。&lt;br/&gt;```&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;racreplaysubject使用步骤&quot;&gt;RACReplaySubject使用步骤:&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。&lt;/li&gt;
&lt;li&gt;可以先订阅信号，也可以先发送信号。&lt;/li&gt;
&lt;li&gt;订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock&lt;/li&gt;
&lt;li&gt;发送信号 sendNext:(id)value&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;racreplaysubject底层实现和racsubject不一样&quot;&gt;RACReplaySubject:底层实现和RACSubject不一样。&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。&lt;/li&gt;
&lt;li&gt;调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock&lt;/li&gt;
&lt;li&gt;如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。&lt;/li&gt;
&lt;li&gt;先保存值，在订阅值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    // 1.创建信号
    RACReplaySubject *replaySubject = [RACReplaySubject subject];

    // 2.发送信号
    [replaySubject sendNext:@1];
    [replaySubject sendNext:@2];

    // 3.订阅信号
    [replaySubject subscribeNext:^(id x) {

        NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);
    }];

    // 订阅信号
    [replaySubject subscribeNext:^(id x) {

        NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);
    }];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2017-11-29 11:02:07.468379+0800 MVVM-Demo[1158:370610] 第一个订阅者接收到的数据1
2017-11-29 11:02:07.468477+0800 MVVM-Demo[1158:370610] 第一个订阅者接收到的数据2
2017-11-29 11:02:07.468592+0800 MVVM-Demo[1158:370610] 第二个订阅者接收到的数据1
2017-11-29 11:02:07.468722+0800 MVVM-Demo[1158:370610] 第二个订阅者接收到的数据2&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;racsubject使用步骤&quot;&gt;RACSubject使用步骤&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。&lt;/li&gt;
&lt;li&gt;订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock&lt;/li&gt;
&lt;li&gt;发送信号 sendNext:(id)value&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;racsubject底层实现和racsignal不一样&quot;&gt;RACSubject:底层实现和RACSignal不一样。&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。&lt;/li&gt;
&lt;li&gt;调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。&lt;br/&gt;```&lt;br/&gt;// 1.创建信号&lt;br/&gt;RACSubject *subject = [RACSubject subject];&lt;br/&gt;// 2.订阅信号&lt;br/&gt;[subject subscribeNext:^(id x) {&lt;br/&gt;// 当信号发出新值，就会调用.&lt;br/&gt;NSLog(@&lt;a&gt;&quot;第一个订阅者%@&quot;&lt;/a&gt;,x);&lt;br/&gt;}];&lt;br/&gt;[subject subscribeNext:^(id x) {&lt;br/&gt;// 当信号发出新值，就会调用.&lt;br/&gt;NSLog(@&lt;a&gt;&quot;第二个订阅者%@&quot;&lt;/a&gt;,x);&lt;br/&gt;}];&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;// 3.发送信号&lt;br/&gt;[subject sendNext:@&quot;我是一个信号📶&quot;];&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* #####RACTuple
 `RACTuple `元组类, 类似NSArray,用来包装值.

* #####RACSequence
`RACSequence `集合类，用于代替NSArray, NSDictionary,可以使用它来快速遍历数组和字典。

* `RACSequence `和`RACTuple `简单使用

`NSArray`&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;NSArray *arr = @[@&quot;哈哈&quot;,@&quot;呵呵&quot;, @&quot;嘿嘿&quot;, @&quot;哼哼&quot;];
[arr.rac_sequence.signal subscribeNext:^(id x) {
    NSLog(@&quot;x: %@&quot;, x);
}];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;打印如下&lt;/code&gt;&lt;br/&gt;2017-11-29 11:19:27.081935+0800 MVVM-Demo[1267:428560] x: 哈哈&lt;br/&gt;2017-11-29 11:19:27.082227+0800 MVVM-Demo[1267:428560] x: 呵呵&lt;br/&gt;2017-11-29 11:19:27.082350+0800 MVVM-Demo[1267:428560] x: 嘿嘿&lt;br/&gt;2017-11-29 11:19:27.082664+0800 MVVM-Demo[1267:428560] x: 哼哼&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`原理：`
* 通过`arr.rac_sequence`把数据arr转化成集合RACSequence
* 通过`arr.rac_sequence.signal `把集合RACSequence转化成了信号
*通过subscribeNext订阅信号，把遍历集合

`NSDictionary `
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)
 NSDictionary *dict = @{@&quot;name&quot;: @&quot;soliloquy&quot;, @&quot;age&quot;: @26};
[dict.rac_sequence.signal subscribeNext:^(id x) {
    // 解包元组，会把元组的值，按顺序给参数里面的变量赋值
    RACTupleUnpack(NSString *key,NSString *value) = x;
    NSLog(@&quot;%@ %@&quot;,key,value);
}];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;打印如下&lt;/code&gt;&lt;br/&gt;2017-11-29 11:51:08.027070+0800 MVVM-Demo[1367:471752] name soliloquy&lt;br/&gt;2017-11-29 11:51:08.027526+0800 MVVM-Demo[1367:471752] age 26&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
`字典转模型`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NSArray &lt;em&gt;arr = @[&lt;br/&gt;@&lt;a&gt;{@&quot;name&quot;&lt;/a&gt;: @&quot;soliloquy&quot;, @&quot;age&quot;: @26},&lt;br/&gt;@&lt;a&gt;{@&quot;name&quot;&lt;/a&gt;: @&quot;ptl&quot;, @&quot;age&quot;: @21},&lt;br/&gt;];&lt;br/&gt;[arr.rac_sequence.signal subscribeNext:^(id x) {&lt;br/&gt;// 运用RAC遍历字典，x：字典&lt;br/&gt;Model&lt;/em&gt; item = [Model modelWithDict:x];&lt;br/&gt;[array addObject:item];&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;}];&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
`其他用法`&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;NSArray *arr = @[
                 @{@&quot;name&quot;: @&quot;soliloquy&quot;, @&quot;age&quot;: @26},
                 @{@&quot;name&quot;: @&quot;ptl&quot;, @&quot;age&quot;: @21},
                 ];

NSArray *ay = [[arr.rac_sequence map:^id(id value) {
    
    return [Persion modelWithDict: value];
    
}] array];

NSLog(@&quot;ay: %@&quot;, ay);

for (Persion *model in ay) {
    NSLog(@&quot;%@---%zd&quot;, model.name, model.age);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;打印如下&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2017-11-29 12:18:24.024939+0800 MVVM-Demo[1631:553078] ay: (&lt;br/&gt;&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
* #####RACCommand

`RACCommand `RAC 中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。
比如：监听按钮点击，网络请求

`RACCommand简单使用`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一、RACCommand使用步骤:&lt;br/&gt;1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock&lt;br/&gt;2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值&lt;br/&gt;3.执行命令 - (RACSignal *)execute:(id)input&lt;/p&gt;
&lt;p&gt;二、RACCommand使用注意:&lt;br/&gt;1.signalBlock必须要返回一个信号，不能传nil.&lt;br/&gt;2.如果不想要传递信号，直接创建空的信号[RACSignal empty];&lt;br/&gt;3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。&lt;br/&gt;4.RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。&lt;/p&gt;
&lt;p&gt;三、RACCommand设计思想&lt;br/&gt;1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。&lt;br/&gt;2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。&lt;/p&gt;
&lt;p&gt;四、如何拿到RACCommand中返回信号发出的数据。&lt;br/&gt;1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。&lt;br/&gt;2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。&lt;/p&gt;
&lt;p&gt;五、监听当前命令是否正在执行executing&lt;br/&gt;六、使用场景, 监听按钮点击，网络请求&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1.创建命令 强引用命令，不要被销毁，否则接收不到数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;self.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {&lt;br/&gt;// 创建空信号,必须返回信号&lt;br/&gt;// return [RACSignal empty];&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 2.创建信号,用来传递数据
    return [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {
        
        NSArray *arr = @[@&quot;123&quot;,@&quot;321&quot;, @&quot;132&quot;, @&quot;312&quot;];
        [subscriber sendNext:arr];
        // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。
        [subscriber sendCompleted];
        return nil;
    }];
    
}];

// 3.订阅RACCommand中的信号
[command.executionSignals subscribeNext:^(id x) {

    [x subscribeNext:^(id x) {

        NSLog(@&quot;数据为： %@&quot;,x);
    }];

}];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;打印如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2017-11-29 12:41:50.364091+0800 MVVM-Demo[1844:622694] 数据为： (
    123,
    321,
    132,
    312
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RAC高级用法&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号
    [self.command.executionSignals.switchToLatest subscribeNext:^(id x) {
        
        NSLog(@&quot;x: %@&quot;,x);
    }];
    
    // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。
    [[command.executing skip:1] subscribeNext:^(id x) {
        
        if ([x boolValue] == YES) {
            NSLog(@&quot;正在执行&quot;);
            
        }else{
            NSLog(@&quot;执行完成&quot;);
        }
        
    }];
   // 5.执行命令
    [self.conmmand execute:nil];
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;racmulticastconnection&quot;&gt;RACMulticastConnection&lt;/h5&gt;
&lt;code&gt;RACMulticastConnection&lt;/code&gt;用于当一个信号被多个订阅时，为了保证创建信号时避免多次调用创建信号中的block造成多次发生数据，可以使用这个该类处理。&lt;br/&gt;&lt;code&gt;RACMulticastConnection&lt;/code&gt;通过&lt;code&gt;RACSignal&lt;/code&gt;的-publish或者-muticast:方法创建.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;######RACMulticastConnection使用步骤:&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;创建信号&lt;br/&gt;&lt;code&gt;+ (RACSignal *)createSignal:(RACDisposable * (^)(id&amp;lt;RACSubscriber&amp;gt; subscriber))didSubscribe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建连接&lt;br/&gt;&lt;code&gt;RACMulticastConnection *connect = [signal publish];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 &lt;code&gt;[connect.signal subscribeNext:nextBlock];&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;连接&lt;br/&gt;&lt;code&gt;[connect connect];&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1.创建请求信号
RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {


    NSLog(@&quot;发送数据&quot;);

    return nil;
}];
// 2.订阅信号
[signal1 subscribeNext:^(id x) {

    NSLog(@&quot;接收数据&quot;);

}];
// 2.订阅信号
[signal1 subscribeNext:^(id x) {

    NSLog(@&quot;接收数据&quot;);

}];

// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求


// RACMulticastConnection:解决重复请求问题
// 1.创建信号
RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&amp;lt;RACSubscriber&amp;gt; subscriber) {


    NSLog(@&quot;发送请求&quot;);
    [subscriber sendNext:@&quot;我是数据源&quot;];

    return nil;
}];

// 2.创建连接
RACMulticastConnection *connect = [signal publish];

// 3.订阅信号，
// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:
[connect.signal subscribeNext:^(id x) {

    NSLog(@&quot;订阅者一:%@&quot;, x);

}];

[connect.signal subscribeNext:^(id x) {

    NSLog(@&quot;订阅者二:%@&quot;, x);

}];

// 4.连接,激活信号
[connect connect];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印如下&lt;br/&gt;```&lt;br/&gt;2017-11-29 13:13:40.735831+0800 MVVM-Demo[2088:721509] 发送数据&lt;br/&gt;2017-11-29 13:13:40.736024+0800 MVVM-Demo[2088:721509] 发送数据&lt;br/&gt;2017-11-29 13:13:40.736550+0800 MVVM-Demo[2088:721509] 发送请求&lt;br/&gt;2017-11-29 13:13:40.736688+0800 MVVM-Demo[2088:721509] 订阅者一:我是数据源&lt;br/&gt;2017-11-29 13:13:40.736777+0800 MVVM-Demo[2088:721509] 订阅者二:我是数据源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;``&lt;code&gt;可以看出&lt;/code&gt;RACSignal &lt;code&gt;被调了两次，每次订阅一次都会发送请求，这样就会导致多次请求，而使用&lt;/code&gt;RACMulticastConnection `就只有在创建信号时调了一次。&lt;/p&gt;
&lt;h6 id=&quot;racmulticastconnection底层原理&quot;&gt;RACMulticastConnection底层原理:&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;创建connect&lt;br/&gt;&lt;code&gt;connect.sourceSignal -&amp;gt; RACSignal(原始信号) connect.signal -&amp;gt; RACSubject&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[connect connect]&lt;/code&gt;内部会订阅RACSignal(原始信号)，并且订阅者是&lt;code&gt;RACSubject&lt;/code&gt;&lt;br/&gt;&lt;code&gt;订阅原始信号，就会调用原始信号中的didSubscribe&lt;/code&gt;&lt;br/&gt;&lt;code&gt;didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext&lt;/code&gt;&lt;br/&gt;*&lt;code&gt;RACSubject&lt;/code&gt;的&lt;code&gt;sendNext&lt;/code&gt;,会遍历RACSubject所有订阅者发送信号。&lt;br/&gt;&lt;code&gt;拿到第二步所有的订阅者，调用他们的nextBlock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 29 Nov 2017 06:57:00 +0000</pubDate>
<dc:creator>soliloquy.local</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soliloquy/p/7920551.html</dc:identifier>
</item>
<item>
<title>react native android6+拍照闪退或重启的解决方案 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/7920412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/7920412.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;android 6+权限使用的时候需要动态申请，那么在使用rn的时候要怎么处理拍照权限问题呢？本文提供的是一揽子rn操作相册、拍照的解决方案，请看正文的&lt;span&gt;&lt;strong&gt;提高班&lt;/strong&gt;&lt;/span&gt;部分。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;解决步骤&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、AndroidManifest.xml设置拍照权限：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.CAMERA&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、配置build.gradle：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置defaultConfig里面的targetSdkVersion&amp;gt;=23.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、在需要使用的地方或者程序启动之后的主页面的构造中申请相机权限，代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async requestCameraPermission() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Platform.OS == 'ios') &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请相机权限&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        const granted &lt;/span&gt;=&lt;span&gt; await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.CAMERA, {
            title: &lt;/span&gt;'申请摄像头权限'&lt;span&gt;,
            message: &lt;/span&gt;'一个很牛逼的应用想借用你的摄像头'&lt;span&gt;
        });
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (granted ===&lt;span&gt; PermissionsAndroid.RESULTS.GRANTED) {
            console.log(&lt;/span&gt;'现在你获得摄像头权限了'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'用户并不屌你'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
        console.warn(err);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拍照之前调用上面的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.requestCameraPermission(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请相机权限&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;提高班&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;多图选择、图片裁剪(支持ad/ios图片个数控制)推荐使用&lt;a href=&quot;https://github.com/syanbo/react-native-syan-image-picker&quot; target=&quot;_blank&quot;&gt;react-native-syan-image-picker&lt;/a&gt;，使用教程查看&lt;a href=&quot;http://www.cnblogs.com/vipstone/p/7804964.html&quot; target=&quot;_blank&quot;&gt;《react-native多图选择、图片裁剪(支持ad/ios图片个数控制)》&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;小技巧：react-native-syan-image-picker 版本V0.0.5 安卓6+ 拍照问题有点问题，我已经pull request，作者已经合并，稍后测试问题之后，即可发布，如果着急使用贴出解决代码。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.修改build.gradle如图：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/172074/201711/172074-20171129144641003-642863156.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、修改RNSyanImagePickerModule.java更新2.1.7配置，代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
.openGallery(PictureMimeType.ofImage())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全部.PictureMimeType.ofAll()、图片.ofImage()、视频.ofVideo()、音频.ofAudio()&lt;/span&gt;
.maxSelectNum(imageCount)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大图片选择数量 int&lt;/span&gt;
.minSelectNum(1)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最小选择数量 int&lt;/span&gt;
.imageSpanCount(4)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每行显示个数 int&lt;/span&gt;
.selectionMode(modeValue)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多选 or 单选 PictureConfig.MULTIPLE or PictureConfig.SINGLE&lt;/span&gt;
.previewImage(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否可预览图片 true or false&lt;/span&gt;
.previewVideo(&lt;span&gt;false&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否可预览视频 true or false&lt;/span&gt;
.enablePreviewAudio(&lt;span&gt;false&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否可播放音频 true or false&lt;/span&gt;
.isCamera(isCamera)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示拍照按钮 true or false&lt;/span&gt;
.imageFormat(PictureMimeType.PNG)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拍照保存图片格式后缀,默认jpeg&lt;/span&gt;
.isZoomAnim(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片列表点击 缩放效果 默认true&lt;/span&gt;
.sizeMultiplier(0.5f)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; glide 加载图片大小 0~1之间 如设置 .glideOverride()无效&lt;/span&gt;
.enableCrop(isCrop)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否裁剪 true or false&lt;/span&gt;
.compress(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否压缩 true or false&lt;/span&gt;
.glideOverride(160, 160)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int glide 加载宽高，越小图片列表越流畅，但会影响列表图片浏览的清晰度&lt;/span&gt;
.withAspectRatio(CropW, CropH)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int 裁剪比例 如16:9 3:2 3:4 1:1 可自定义&lt;/span&gt;
.hideBottomControls(isCrop)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示uCrop工具栏，默认不显示 true or false&lt;/span&gt;
.isGif(isGif)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示gif图片 true or false&lt;/span&gt;
.freeStyleCropEnabled(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 裁剪框是否可拖拽 true or false&lt;/span&gt;
.circleDimmedLayer(showCropCircle)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否圆形裁剪 true or false&lt;/span&gt;
.showCropFrame(showCropFrame)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示裁剪矩形边框 圆形裁剪时建议设为false   true or false&lt;/span&gt;
.showCropGrid(showCropGrid)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示裁剪矩形网格 圆形裁剪时建议设为false    true or false&lt;/span&gt;
.openClickSound(&lt;span&gt;false&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否开启点击声音 true or false&lt;/span&gt;
.cropCompressQuality(90)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 裁剪压缩质量 默认90 int&lt;/span&gt;
.minimumCompressSize(100)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小于100kb的图片不压缩 &lt;/span&gt;
.synOrAsy(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步true或异步false 压缩 默认同步&lt;/span&gt;
.rotateEnabled(&lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 裁剪是否可旋转图片 true or false&lt;/span&gt;
.scaleEnabled(&lt;span&gt;true&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 裁剪是否可放大缩小图片 true or false&lt;/span&gt;
.videoQuality(0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视频录制质量 0 or 1 int&lt;/span&gt;
.videoMaxSecond(15)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示多少秒以内的视频or音频也可适用 int &lt;/span&gt;
.videoMinSecond(10)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示多少秒以内的视频or音频也可适用 int &lt;/span&gt;
.recordVideoSecond(60)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;视频秒数录制 默认60s int&lt;/span&gt;
.forResult(PictureConfig.CHOOSE_REQUEST);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果回调onActivityResult code &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/172074/201711/172074-20171109092913184-583819138.gif&quot; alt=&quot;&quot;/&gt;      &lt;img src=&quot;http://images2017.cnblogs.com/blog/172074/201711/172074-20171109092923981-1603381299.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 29 Nov 2017 06:37:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/7920412.html</dc:identifier>
</item>
<item>
<title>JS组件系列——Gojs组件，前端图形化插件之利器 - 懒得安分</title>
<link>http://www.cnblogs.com/landeanfen/p/7910530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/landeanfen/p/7910530.html</guid>
<description>&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
&amp;lt;title&amp;gt;Draggable Link&amp;lt;/title&amp;gt;
&amp;lt;meta name=&quot;description&quot; content=&quot;Drag a link to reconnect it. Nodes have custom Adornments for selection, resizing, and reshaping.&quot; /&amp;gt;
&amp;lt;!-- Copyright 1998-2017 by Northwoods Software Corporation. --&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;script src=&quot;../../gojs/go-debug.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script id=&quot;code&quot;&amp;gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; init() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (window.goSamples) goSamples();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init for these samples -- you don't need to call this&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; objGo = go.GraphObject.make;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for conciseness in defining templates&lt;/span&gt;
&lt;span&gt;
    myDiagram &lt;/span&gt;=&lt;span&gt;
      objGo(go.Diagram, &lt;/span&gt;&quot;myDiagramDiv&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; must name or refer to the DIV HTML element&lt;/span&gt;
&lt;span&gt;        {
          grid: objGo(go.Panel, &lt;/span&gt;&quot;Grid&quot;&lt;span&gt;,
                  objGo(go.Shape, &lt;/span&gt;&quot;LineH&quot;, { stroke: &quot;lightgray&quot;, strokeWidth: 0.5&lt;span&gt; }),
                  objGo(go.Shape, &lt;/span&gt;&quot;LineH&quot;, { stroke: &quot;gray&quot;, strokeWidth: 0.5, interval: 10&lt;span&gt; }),
                  objGo(go.Shape, &lt;/span&gt;&quot;LineV&quot;, { stroke: &quot;lightgray&quot;, strokeWidth: 0.5&lt;span&gt; }),
                  objGo(go.Shape, &lt;/span&gt;&quot;LineV&quot;, { stroke: &quot;gray&quot;, strokeWidth: 0.5, interval: 10&lt;span&gt; })
                ),
          allowDrop: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; must be true to accept drops from the Palette&lt;/span&gt;
          &quot;draggingTool.dragsLink&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&quot;draggingTool.isGridSnapEnabled&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&quot;linkingTool.isUnconnectedLinkValid&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&quot;linkingTool.portGravity&quot;: 20&lt;span&gt;,
          &lt;/span&gt;&quot;relinkingTool.isUnconnectedLinkValid&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&quot;relinkingTool.portGravity&quot;: 20&lt;span&gt;,
          &lt;/span&gt;&quot;relinkingTool.fromHandleArchetype&quot;&lt;span&gt;:
            objGo(go.Shape, &lt;/span&gt;&quot;Diamond&quot;, { segmentIndex: 0, cursor: &quot;pointer&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(8, 8), fill: &quot;tomato&quot;, stroke: &quot;darkred&quot;&lt;span&gt; }),
          &lt;/span&gt;&quot;relinkingTool.toHandleArchetype&quot;&lt;span&gt;:
            objGo(go.Shape, &lt;/span&gt;&quot;Diamond&quot;, { segmentIndex: -1, cursor: &quot;pointer&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(8, 8), fill: &quot;darkred&quot;, stroke: &quot;tomato&quot;&lt;span&gt; }),
          &lt;/span&gt;&quot;linkReshapingTool.handleArchetype&quot;&lt;span&gt;:
            objGo(go.Shape, &lt;/span&gt;&quot;Diamond&quot;, { desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(7, 7), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
          rotatingTool: objGo(TopRotatingTool),  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; defined below&lt;/span&gt;
          &quot;rotatingTool.snapAngleMultiple&quot;: 15&lt;span&gt;,
          &lt;/span&gt;&quot;rotatingTool.snapAngleEpsilon&quot;: 15&lt;span&gt;,
          &lt;/span&gt;&quot;undoManager.isEnabled&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; when the document is modified, add a &quot;*&quot; to the title and enable the &quot;Save&quot; button&lt;/span&gt;
    myDiagram.addDiagramListener(&quot;Modified&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button = document.getElementById(&quot;SaveButton&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (button) button.disabled = !&lt;span&gt;myDiagram.isModified;
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idx = document.title.indexOf(&quot;*&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (myDiagram.isModified) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (idx &amp;lt; 0) document.title += &quot;*&quot;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (idx &amp;gt;= 0) document.title = document.title.substr(0&lt;span&gt;, idx);
      }
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Define a function for creating a &quot;port&quot; that is normally transparent.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The &quot;name&quot; is used as the GraphObject.portId, the &quot;spot&quot; is used to control how links connect&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; and where the port is positioned on the node, and the boolean &quot;output&quot; and &quot;input&quot; arguments&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; control whether the user can draw links from or to the port.&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; makePort(name, spot, output, input) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the port is basically just a small transparent square&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; objGo(go.Shape, &quot;Circle&quot;&lt;span&gt;,
               {
                  fill: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; not seen, by default; set to a translucent gray by showSmallPorts, defined below&lt;/span&gt;
                  stroke: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                  desiredSize: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Size(7, 7&lt;span&gt;),
                  alignment: spot,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; align the port on the main Shape&lt;/span&gt;
                  alignmentFocus: spot,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; just inside the Shape&lt;/span&gt;
                  portId: name,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; declare this object to be a &quot;port&quot;&lt;/span&gt;
                  fromSpot: spot, toSpot: spot,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; declare where links may connect at this port&lt;/span&gt;
                  fromLinkable: output, toLinkable: input,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; declare whether the user may draw links to/from here&lt;/span&gt;
                  cursor: &quot;pointer&quot;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; show a different cursor to indicate potential link point&lt;/span&gt;
&lt;span&gt;               });
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nodeSelectionAdornmentTemplate =&lt;span&gt;
      objGo(go.Adornment, &lt;/span&gt;&quot;Auto&quot;&lt;span&gt;,
        objGo(go.Shape, { fill: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, stroke: &quot;deepskyblue&quot;, strokeWidth: 1.5, strokeDashArray: [4, 2&lt;span&gt;] }),
        objGo(go.Placeholder)
      );

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nodeResizeAdornmentTemplate =&lt;span&gt;
      objGo(go.Adornment, &lt;/span&gt;&quot;Spot&quot;&lt;span&gt;,
        { locationSpot: go.Spot.Right },
        objGo(go.Placeholder),
        objGo(go.Shape, { alignment: go.Spot.TopLeft, cursor: &lt;/span&gt;&quot;nw-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
        objGo(go.Shape, { alignment: go.Spot.Top, cursor: &lt;/span&gt;&quot;n-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
        objGo(go.Shape, { alignment: go.Spot.TopRight, cursor: &lt;/span&gt;&quot;ne-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),

        objGo(go.Shape, { alignment: go.Spot.Left, cursor: &lt;/span&gt;&quot;w-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
        objGo(go.Shape, { alignment: go.Spot.Right, cursor: &lt;/span&gt;&quot;e-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),

        objGo(go.Shape, { alignment: go.Spot.BottomLeft, cursor: &lt;/span&gt;&quot;se-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
        objGo(go.Shape, { alignment: go.Spot.Bottom, cursor: &lt;/span&gt;&quot;s-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
        objGo(go.Shape, { alignment: go.Spot.BottomRight, cursor: &lt;/span&gt;&quot;sw-resize&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(6, 6), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; })
      );

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nodeRotateAdornmentTemplate =&lt;span&gt;
      objGo(go.Adornment,
        { locationSpot: go.Spot.Center, locationObjectName: &lt;/span&gt;&quot;CIRCLE&quot;&lt;span&gt; },
        objGo(go.Shape, &lt;/span&gt;&quot;Circle&quot;, { name: &quot;CIRCLE&quot;, cursor: &quot;pointer&quot;, desiredSize: &lt;span&gt;new&lt;/span&gt; go.Size(7, 7), fill: &quot;lightblue&quot;, stroke: &quot;deepskyblue&quot;&lt;span&gt; }),
        objGo(go.Shape, { geometryString: &lt;/span&gt;&quot;M3.5 7 L3.5 30&quot;, isGeometryPositioned: &lt;span&gt;true&lt;/span&gt;, stroke: &quot;deepskyblue&quot;, strokeWidth: 1.5, strokeDashArray: [4, 2&lt;span&gt;] })
      );

    myDiagram.nodeTemplate &lt;/span&gt;=&lt;span&gt;
      objGo(go.Node, &lt;/span&gt;&quot;Spot&quot;&lt;span&gt;,
        { locationSpot: go.Spot.Center },
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;location&quot;, &quot;loc&quot;&lt;span&gt;, go.Point.parse).makeTwoWay(go.Point.stringify),
        { selectable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, selectionAdornmentTemplate: nodeSelectionAdornmentTemplate },
        { resizable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, resizeObjectName: &quot;PANEL&quot;&lt;span&gt;, resizeAdornmentTemplate: nodeResizeAdornmentTemplate },
        { rotatable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, rotateAdornmentTemplate: nodeRotateAdornmentTemplate },
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;angle&quot;&lt;span&gt;).makeTwoWay(),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the main object is a Panel that surrounds a TextBlock with a Shape&lt;/span&gt;
        objGo(go.Panel, &quot;Auto&quot;&lt;span&gt;,
          { name: &lt;/span&gt;&quot;PANEL&quot;&lt;span&gt; },
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;desiredSize&quot;, &quot;size&quot;&lt;span&gt;, go.Size.parse).makeTwoWay(go.Size.stringify),
          objGo(go.Shape, &lt;/span&gt;&quot;Rectangle&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; default figure&lt;/span&gt;
&lt;span&gt;            {
              portId: &lt;/span&gt;&quot;&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the default port: if no spot on link data, use closest side&lt;/span&gt;
              fromLinkable: &lt;span&gt;true&lt;/span&gt;, toLinkable: &lt;span&gt;true&lt;/span&gt;, cursor: &quot;pointer&quot;&lt;span&gt;,
              fill: &lt;/span&gt;&quot;white&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; default color&lt;/span&gt;
              strokeWidth: 2&lt;span&gt;
            },
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;figure&quot;&lt;span&gt;),
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;fill&quot;&lt;span&gt;)),
          objGo(go.TextBlock,
            {
              font: &lt;/span&gt;&quot;bold 11pt Helvetica, Arial, sans-serif&quot;&lt;span&gt;,
              margin: &lt;/span&gt;8&lt;span&gt;,
              maxSize: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Size(160&lt;span&gt;, NaN),
              wrap: go.TextBlock.WrapFit,
              editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            },
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;text&quot;&lt;span&gt;).makeTwoWay())
        ),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; four small named ports, one on each side:&lt;/span&gt;
        makePort(&quot;T&quot;, go.Spot.Top, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;),
        makePort(&lt;/span&gt;&quot;L&quot;, go.Spot.Left, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;),
        makePort(&lt;/span&gt;&quot;R&quot;, go.Spot.Right, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;),
        makePort(&lt;/span&gt;&quot;B&quot;, go.Spot.Bottom, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;),
        { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle mouse enter/leave events to show/hide the ports&lt;/span&gt;
          mouseEnter: &lt;span&gt;function&lt;/span&gt;(e, node) { showSmallPorts(node, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;); },
          mouseLeave: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(e, node) { showSmallPorts(node, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;); }
        }
      );

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showSmallPorts(node, show) {
      node.ports.each(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(port) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (port.portId !== &quot;&quot;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't change the default port, which is the big shape&lt;/span&gt;
          port.fill = show ? &quot;rgba(0,0,0,.3)&quot; : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
      });
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; linkSelectionAdornmentTemplate =&lt;span&gt;
      objGo(go.Adornment, &lt;/span&gt;&quot;Link&quot;&lt;span&gt;,
        objGo(go.Shape,
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; isPanelMain declares that this Shape shares the Link.geometry&lt;/span&gt;
          { isPanelMain: &lt;span&gt;true&lt;/span&gt;, fill: &lt;span&gt;null&lt;/span&gt;, stroke: &quot;deepskyblue&quot;, strokeWidth: 0 })  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use selection object's strokeWidth&lt;/span&gt;
&lt;span&gt;      );

    myDiagram.linkTemplate &lt;/span&gt;=&lt;span&gt;
      objGo(go.Link,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the whole link panel&lt;/span&gt;
        { selectable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, selectionAdornmentTemplate: linkSelectionAdornmentTemplate },
        { relinkableFrom: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, relinkableTo: &lt;span&gt;true&lt;/span&gt;, reshapable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; },
        {
          routing: go.Link.AvoidsNodes,
          curve: go.Link.JumpOver,
          corner: &lt;/span&gt;5&lt;span&gt;,
          toShortLength: &lt;/span&gt;4&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;points&quot;&lt;span&gt;).makeTwoWay(),
        objGo(go.Shape,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the link path shape&lt;/span&gt;
          { isPanelMain: &lt;span&gt;true&lt;/span&gt;, strokeWidth: 2&lt;span&gt; }),
        objGo(go.Shape,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the arrowhead&lt;/span&gt;
          { toArrow: &quot;Standard&quot;, stroke: &lt;span&gt;null&lt;/span&gt;&lt;span&gt; }),
        objGo(go.Panel, &lt;/span&gt;&quot;Auto&quot;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;visible&quot;, &quot;isSelected&quot;&lt;span&gt;).ofObject(),
          objGo(go.Shape, &lt;/span&gt;&quot;RoundedRectangle&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the link shape&lt;/span&gt;
            { fill: &quot;#F8F8F8&quot;, stroke: &lt;span&gt;null&lt;/span&gt;&lt;span&gt; }),
          objGo(go.TextBlock,
            {
              textAlign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
              font: &lt;/span&gt;&quot;10pt helvetica, arial, sans-serif&quot;&lt;span&gt;,
              stroke: &lt;/span&gt;&quot;#919191&quot;&lt;span&gt;,
              margin: &lt;/span&gt;2&lt;span&gt;,
              minSize: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Size(10&lt;span&gt;, NaN),
              editable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            },
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;text&quot;&lt;span&gt;).makeTwoWay())
        )
      );

    load();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; load an initial diagram from some JSON text&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialize the Palette that is on the left side of the page&lt;/span&gt;
    myPalette =&lt;span&gt;
      objGo(go.Palette, &lt;/span&gt;&quot;myPaletteDiv&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; must name or refer to the DIV HTML element&lt;/span&gt;
&lt;span&gt;        {
          maxSelectionCount: &lt;/span&gt;1&lt;span&gt;,
          nodeTemplateMap: myDiagram.nodeTemplateMap,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; share the templates used by myDiagram&lt;/span&gt;
          linkTemplate: &lt;span&gt;//&lt;/span&gt;&lt;span&gt; simplify the link template, just in this Palette&lt;/span&gt;
&lt;span&gt;            objGo(go.Link,
              { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; because the GridLayout.alignment is Location and the nodes have locationSpot == Spot.Center,&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to line up the Link in the same manner we have to pretend the Link has the same location spot&lt;/span&gt;
&lt;span&gt;                locationSpot: go.Spot.Center,
                selectionAdornmentTemplate:
                  objGo(go.Adornment, &lt;/span&gt;&quot;Link&quot;&lt;span&gt;,
                    { locationSpot: go.Spot.Center },
                    objGo(go.Shape,
                      { isPanelMain: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, fill: &lt;span&gt;null&lt;/span&gt;, stroke: &quot;deepskyblue&quot;, strokeWidth: 0&lt;span&gt; }),
                    objGo(go.Shape,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the arrowhead&lt;/span&gt;
                      { toArrow: &quot;Standard&quot;, stroke: &lt;span&gt;null&lt;/span&gt;&lt;span&gt; })
                  )
              },
              {
                routing: go.Link.AvoidsNodes,
                curve: go.Link.JumpOver,
                corner: &lt;/span&gt;5&lt;span&gt;,
                toShortLength: &lt;/span&gt;4&lt;span&gt;
              },
              &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.Binding(&quot;points&quot;&lt;span&gt;),
              objGo(go.Shape,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the link path shape&lt;/span&gt;
                { isPanelMain: &lt;span&gt;true&lt;/span&gt;, strokeWidth: 2&lt;span&gt; }),
              objGo(go.Shape,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the arrowhead&lt;/span&gt;
                { toArrow: &quot;Standard&quot;, stroke: &lt;span&gt;null&lt;/span&gt;&lt;span&gt; })
            ),
          model: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; go.GraphLinksModel([  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; specify the contents of the Palette&lt;/span&gt;
            { text: &quot;Start&quot;, figure: &quot;Circle&quot;, fill: &quot;#00AD5F&quot;&lt;span&gt; },
            { text: &lt;/span&gt;&quot;Step&quot;&lt;span&gt; },
            { text: &lt;/span&gt;&quot;DB&quot;, figure: &quot;Database&quot;, fill: &quot;lightgray&quot;&lt;span&gt; },
            { text: &lt;/span&gt;&quot;???&quot;, figure: &quot;Diamond&quot;, fill: &quot;lightskyblue&quot;&lt;span&gt; },
            { text: &lt;/span&gt;&quot;End&quot;, figure: &quot;Circle&quot;, fill: &quot;#CE0620&quot;&lt;span&gt; },
            { text: &lt;/span&gt;&quot;Comment&quot;, figure: &quot;RoundedRectangle&quot;, fill: &quot;lightyellow&quot;&lt;span&gt; }
          ], [
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the Palette also has a disconnected Link, which the user can drag-and-drop&lt;/span&gt;
            { points: &lt;span&gt;new&lt;/span&gt; go.List(go.Point).addAll([&lt;span&gt;new&lt;/span&gt; go.Point(0, 0), &lt;span&gt;new&lt;/span&gt; go.Point(30, 0), &lt;span&gt;new&lt;/span&gt; go.Point(30, 40), &lt;span&gt;new&lt;/span&gt; go.Point(60, 40&lt;span&gt;)]) }
          ])
        });
  }


  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; TopRotatingTool() {
    go.RotatingTool.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  go.Diagram.inherit(TopRotatingTool, go.RotatingTool);

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* @override &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  TopRotatingTool.prototype.updateAdornments &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(part) {
    go.RotatingTool.prototype.updateAdornments.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, part);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; adornment = part.findAdornment(&quot;Rotating&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (adornment !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      adornment.location &lt;/span&gt;= part.rotateObject.getDocumentPoint(&lt;span&gt;new&lt;/span&gt; go.Spot(0.5, 0, 0, -30));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; above middle top&lt;/span&gt;
&lt;span&gt;    }
  };

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* @override &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  TopRotatingTool.prototype.rotate &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newangle) {
    go.RotatingTool.prototype.rotate.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, newangle + 90&lt;span&gt;);
  };
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of TopRotatingTool class&lt;/span&gt;


  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Show the diagram's model in JSON format that the user may edit&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; save() {
    saveDiagramProperties();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do this first, before writing to JSON&lt;/span&gt;
    document.getElementById(&quot;mySavedModel&quot;).value =&lt;span&gt; myDiagram.model.toJson();
    myDiagram.isModified &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; load() {
    myDiagram.model &lt;/span&gt;= go.Model.fromJson(document.getElementById(&quot;mySavedModel&quot;&lt;span&gt;).value);
    loadDiagramProperties();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do this after the Model.modelData has been brought into memory&lt;/span&gt;
&lt;span&gt;  }

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; saveDiagramProperties() {
    myDiagram.model.modelData.position &lt;/span&gt;=&lt;span&gt; go.Point.stringify(myDiagram.position);
  }
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadDiagramProperties(e) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set Diagram.initialPosition, not Diagram.position, to handle initialization side-effects&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; pos =&lt;span&gt; myDiagram.model.modelData.position;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pos) myDiagram.initialPosition =&lt;span&gt; go.Point.parse(pos);
  }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;init()&quot;&amp;gt;
&amp;lt;div id=&quot;sample&quot;&amp;gt;
  &amp;lt;div style=&quot;width:100%; white-space:nowrap;&quot;&amp;gt;
    &amp;lt;span style=&quot;display: inline-block; vertical-align: top; width:105px&quot;&amp;gt;
      &amp;lt;div id=&quot;myPaletteDiv&quot; style=&quot;border: solid 1px black; height: 620px&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/span&amp;gt;

    &amp;lt;span style=&quot;display: inline-block; vertical-align: top; width:80%&quot;&amp;gt;
      &amp;lt;div id=&quot;myDiagramDiv&quot; style=&quot;border: solid 1px black; height: 620px&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;p&amp;gt;&lt;span&gt;
    This sample demonstrates the ability &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; the user to drag around a Link as &lt;span&gt;if&lt;/span&gt;&lt;span&gt; it were a Node.
    When either end of the link passes over a valid port, the port is highlighted.
  &lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;&lt;span&gt;
    The link&lt;/span&gt;-&lt;span&gt;dragging functionality is enabled by setting some or all of the following properties:
    &lt;/span&gt;&amp;lt;a&amp;gt;DraggingTool.dragsLink&amp;lt;/a&amp;gt;, &amp;lt;a&amp;gt;LinkingTool.isUnconnectedLinkValid&amp;lt;/a&amp;gt;&lt;span&gt;, and
    &lt;/span&gt;&amp;lt;a&amp;gt;RelinkingTool.isUnconnectedLinkValid&amp;lt;/a&amp;gt;.
  &amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;&lt;span&gt;
    Note that a Link is present &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the &amp;lt;a&amp;gt;Palette&amp;lt;/a&amp;gt; so that it too can be dragged out and onto
&lt;span&gt;    the main Diagram.  Because links are not automatically routed when either end is not connected
    &lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; a Node, the route is provided explicitly when that Palette item is defined.
  &lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;&lt;span&gt;
    This also demonstrates several custom Adornments:
    &lt;/span&gt;&amp;lt;a&amp;gt;Part.selectionAdornmentTemplate&amp;lt;/a&amp;gt;, &amp;lt;a&amp;gt;Part.resizeAdornmentTemplate&amp;lt;/a&amp;gt;&lt;span&gt;, and
    &lt;/span&gt;&amp;lt;a&amp;gt;Part.rotateAdornmentTemplate&amp;lt;/a&amp;gt;.
  &amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;&lt;span&gt;
    Finally &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; sample demonstrates saving and restoring the &amp;lt;a&amp;gt;Diagram.position&amp;lt;/a&amp;gt; as a property
    on the &amp;lt;a&amp;gt;Model.modelData&amp;lt;/a&amp;gt; object that is automatically saved and restored when calling &amp;lt;a&amp;gt;Model.toJson&amp;lt;/a&amp;gt;&lt;span&gt;
    and &lt;/span&gt;&amp;lt;a&amp;gt;Model.fromJson&amp;lt;/a&amp;gt;.
  &amp;lt;/p&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;button id=&quot;SaveButton&quot; onclick=&quot;save()&quot;&amp;gt;Save&amp;lt;/button&amp;gt;
      &amp;lt;button onclick=&quot;load()&quot;&amp;gt;Load&amp;lt;/button&amp;gt;
      Diagram Model saved &lt;span&gt;in&lt;/span&gt;&lt;span&gt; JSON format:
    &lt;/span&gt;&amp;lt;/div&amp;gt;
    &amp;lt;textarea id=&quot;mySavedModel&quot; style=&quot;width:100%;height:300px&quot;&amp;gt;&lt;span&gt;
{ &lt;/span&gt;&quot;class&quot;: &quot;go.GraphLinksModel&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;linkFromPortIdProperty&quot;: &quot;fromPort&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;linkToPortIdProperty&quot;: &quot;toPort&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;nodeDataArray&quot;&lt;span&gt;: [
 ],
  &lt;/span&gt;&quot;linkDataArray&quot;&lt;span&gt;: [
 ]}
    &lt;/span&gt;&amp;lt;/textarea&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 29 Nov 2017 05:47:00 +0000</pubDate>
<dc:creator>懒得安分</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/landeanfen/p/7910530.html</dc:identifier>
</item>
<item>
<title>Gitlab自动触发Jenkins构建打包 - PeanutLike</title>
<link>http://www.cnblogs.com/bugsbunny/p/7919993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bugsbunny/p/7919993.html</guid>
<description>&lt;p&gt;在部门的测试环境中，开发人员一旦向gitlab仓库提交成功代码，gitlab就会自动触发jenkins构建项目。当然在构建后还可以添加项目部署或者自动化测试的脚本。这里只针对测试环境。&lt;/p&gt;

&lt;h2 id=&quot;安装gitlab-hook-plugin插件&quot;&gt;2.1 安装Gitlab Hook Plugin插件：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;系统管理-&amp;gt;管理插件-&amp;gt;可选插件-&amp;gt;选择安装 Gitlab Hook Plugin和Build Authorization Token Root Plugin插件。&lt;/strong&gt; 如果没有安装Build Authorization Token，后面gitlab在Test hook时会报403错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/F0A324F2D7034F7F8E0B9AC290FF0691/8354&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;生成随机token&quot;&gt;2.2 生成随机token：&lt;/h2&gt;
&lt;p&gt;在linux终端执行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# openssl rand -hex 12&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ed83c8d0506386f23e743695&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;创建测试project&quot;&gt;2.3 创建测试Project&lt;/h2&gt;
&lt;p&gt;在gitlab上已建好了bd-ci-test的项目，且Jenkins用户拥有该项目的相关读写权限。&lt;br/&gt;在jenkins新建bd-ci-test项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/1F6DC4B3CD5144D1A053B9078039486A/8348&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码管理选择git，添加jenkins用户在gitlab上的凭据(即用户名密码)，这里选择打包的分支为release分支，这里根据需求自己填写（默认为master分支）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/86BCC46384D44D0C85E8C06DBFA248D3/8352&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建触发器，填写刚刚生成的token：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/78EA8C6FA8EF45A786BF2F2491D83717/8350&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在git项目配置界面设置链接和token。这里要注意路径，根据部署jenkins的路径填写，不然会报404错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/7979364E452B4B0AB15C8350E6F47811/8349&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击测试，返回201的话就表示成功了。其他错误可以根据gitlab日志来排除原因gitlab/gitlab-rails/production.log：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/49002DD0527345E592E8340AE6A40841/8353&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;向gitlab提交代码&quot;&gt;4.1 向gitlab提交代码：&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;#vim a.txt 修改a.txt文件并提交&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#git add a.txt &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#git commit -m 'alter a.txt'&lt;/span&gt;
[&lt;span class=&quot;kw&quot;&gt;release&lt;/span&gt; 094f663] alter a.txt
 &lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt; files changed, 0 insertions(+), &lt;span class=&quot;kw&quot;&gt;2&lt;/span&gt; deletions(-)
&lt;span class=&quot;co&quot;&gt;#git push origin release&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Password&lt;/span&gt;: 
&lt;span class=&quot;kw&quot;&gt;Counting&lt;/span&gt; objects: 5, done.
&lt;span class=&quot;kw&quot;&gt;Delta&lt;/span&gt; compression using up to 4 threads.
&lt;span class=&quot;kw&quot;&gt;Compressing&lt;/span&gt; objects: 100% (2/2), &lt;span class=&quot;kw&quot;&gt;done.&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Writing&lt;/span&gt; objects: 100% (3/3), &lt;span class=&quot;kw&quot;&gt;283&lt;/span&gt; bytes, done.
&lt;span class=&quot;kw&quot;&gt;Total&lt;/span&gt; 3 (delta 0), &lt;span class=&quot;kw&quot;&gt;reused&lt;/span&gt; 0 (delta 0)
   &lt;span class=&quot;kw&quot;&gt;b32472e..094f663&lt;/span&gt;  release -&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; release&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;jenkins控制台输出信息&quot;&gt;4.2 jenkins控制台输出信息：&lt;/h2&gt;
&lt;p&gt;可以观察到jekins已经自动构建项目了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/f0f88f30d57d5a7f49cdf2a8b5161611/xmlnote/B623185C68AD44CAAA57735999DA24CD/8351&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 05:38:00 +0000</pubDate>
<dc:creator>PeanutLike</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bugsbunny/p/7919993.html</dc:identifier>
</item>
<item>
<title>一个RtspServer的设计与实现和RTSP2.0简介 - haibindev</title>
<link>http://www.cnblogs.com/haibindev/p/7918733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haibindev/p/7918733.html</guid>
<description>&lt;p&gt;  前段时间着手实现了一个RTSP Server，能够正常实现多路RTSP流的直播播放，因项目需要，只做了对H.264和AAC编码的支持，但是相信其他编码的实现基本逻辑也是想通的。这里我把主要设计和思考过程，以及实现框架分享一下。因为关注的是直播，这里只讨论&lt;strong&gt;RTSP直播&lt;/strong&gt;协议。&lt;/p&gt;
&lt;h2 id=&quot;rtsp协议概述与rtsp2.0&quot;&gt;RTSP协议概述与RTSP2.0&lt;/h2&gt;
&lt;p&gt;  众所周知，RTSP协议是一个流媒体协议，可以实现直播和点播形式的音频与视频流的播放。RTSP协议定义了多种服务器-客户端之间交互的接口，主要有OPTIONS，DESCRIBE，SETUP，PLAY，TEARDOWN，RECORD，ANNOUNCE。网络上已经有很多针对RTSP协议的文章，我这里不准备进行过多介绍，详细的协议定义，可以参见&lt;a href=&quot;https://www.ietf.org/rfc/rfc2326.txt&quot;&gt;RFC2326&lt;/a&gt;。RTSP并不包括具体数据的传输，该功能一般由RTP与RTCP协议来实现，并可以通过TCP或UDP两种底层传输方式进行。&lt;/p&gt;&lt;p&gt;  下图是典型的RTSP直播过程中服务端-客户端&lt;strong&gt;主要&lt;/strong&gt;交互过程：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129105125034-1438687276.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  当然，直播过程中也可能在服务器与客户端之间调用GET_PARAMETER等其他接口，上图偷懒省略了。上图绿色部分表示的是数据传输。之前说过，流媒体数据传输不是RTSP协议的内容，由RTP包来做。但是具体在实现上，RTP包可以通过UDP或TCP的方式来进行，而且这两种传输方式，区别其实还不小，下面具体说下。&lt;/p&gt;
&lt;h2 id=&quot;rtsp-数据传输流程&quot;&gt;RTSP 数据传输流程&lt;/h2&gt;
&lt;h3 id=&quot;rtsp-over-udp&quot;&gt;1. RTSP over UDP&lt;/h3&gt;
&lt;p&gt;  对于udp模式，客户端在发送PLAY以后，就开始建立udp端口，以接收服务器发来的RTP包，同样，服务器也会建立udp端口，并向客户端发送RTP包。这是网上大部分程序所采用的方式，优点是逻辑清晰，实现方便，不过缺点也很明显，就是udp所固有的，容易丢包，尤其是在高分辨率高码率下。&lt;/p&gt;&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129105219065-768162847.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rtsp-over-tcp&quot;&gt;2. RTSP over TCP&lt;/h3&gt;
&lt;p&gt;  对tcp模式，通过SETUP接口来指定传输方式，服务器返回同样数据以确定双方通过tcp方式来传输数据。不过跟udp最大的不同是，rtsp over tcp的形式，不再创建单独的tcp通道，而是直接使用之前rtsp通信所使用的tcp通道，流程如下所示：&lt;/p&gt;&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129105618675-235319144.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;  由于跟rtsp消息使用同一个tcp端口，为了区分，rtp以及rtcp包，增加了4个字节额外的字段，并通过特殊的标识'$'，与正常的rtsp消息进行了区分。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129110129175-1182051217.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;rtsp-live-server-设计与实现&quot;&gt;RTSP Live Server 设计与实现&lt;/h2&gt;
&lt;h3 id=&quot;程序框架&quot;&gt;1. 程序框架&lt;/h3&gt;
&lt;p&gt;  我这次所实现的RTSP Server，主要功能是采集摄像头和麦克风数据，进行h.264编码以及aac编码，并对外提供RTSP直播流服务。我在实际写代码中，也是首先实现了rtsp over udp的模式，然而，通过实际测试，我发现在高分辨率高码率情况下，由于h.264 NAL单元过大，会拆分成很多的rtp包，而udp不可靠的传输方式，总是难免丢包，在低码率的时候还不明显，高码率情况下，丢包导致的花屏会频繁出现，这样体验特别差。于是我重新实现了一份rtsp over tcp模式的代码，顺利解决了这个问题。&lt;/p&gt;&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129102710112-1597744473.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于h264在sdp中的描述&quot;&gt;2. 关于h264在sdp中的描述&lt;/h3&gt;
&lt;p&gt;  h264在sdp中的媒体信息,大多都是可以直接填写的，但是有两项数据需要根据编码后的数据来提取，就是profile-level-id和sprop-parameter-sets。这两项字符串数据的计算公式&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;profile-level-id = &quot;Base16(sps[1])&quot; + &quot;Base16(sps[2])&quot; + &quot;Base16(sps[3])&quot;&lt;/li&gt;
&lt;li&gt;sprop-parameter-sets = &quot;Base64(sps)&quot; + &quot;,&quot; + &quot;Base64(pps)&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;主要代码&quot;&gt;3. 主要代码&lt;/h3&gt;
&lt;p&gt;3.1 Rtsp服务接口&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129102819206-227941139.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;3.2 RtspSession在TCP通道里处理RTSP消息与RTP报文&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129102948737-1210783518.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行效果&quot;&gt;4. 运行效果&lt;/h3&gt;
&lt;p&gt;  同时用vlc和ffplay进行多路播放，以tcp请求的方式，效果如下，延迟极低。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129103007925-144629055.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于rtsp-2.0&quot;&gt;关于RTSP 2.0&lt;/h2&gt;
&lt;p&gt;  2016年IETF发布了新的RTSP标准，这就是就是RTSP2.0协议（&lt;a href=&quot;https://tools.ietf.org/html/rfc7826&quot;&gt;RFC7826&lt;/a&gt;），新标准还是有不少修改的，除了完善一些原协议的中的定义，还有一些我觉得比较重要的是，对接口method进行了修改，比如删除了&lt;strong&gt;RECORD&lt;/strong&gt;和&lt;strong&gt;ANNOUNCE&lt;/strong&gt;方法，新增了&lt;strong&gt;PLAY_NOTIFY&lt;/strong&gt;方法。&lt;br/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;删除了RECORD，这表示你不能再通过这个接口来控制服务器进行数据的录制了，可以选择在PLAY方法中，添加一些参数，来实现服务器对直播数据进行录制，还可以分隔录制。&lt;/li&gt;
&lt;li&gt;删除了ANNOUNCE，这意味着，不能像RTMP一样，客户端通过向服务器推送数据，来实现本机数据对外直播了，这可能需要其他的推送途径来进行替代了。&lt;/li&gt;
&lt;li&gt;至于PLAY_NOTIFY，它替代来原来Server向Client端发送ANNOUNCE方法，所实现的功能，也就是告诉客户端，需要根据新参数来调整直播播放状态。&lt;/li&gt;
&lt;li&gt;删除通过UDP传输RTSP消息的形式&lt;/li&gt;
&lt;li&gt;删除通过发PLAY消息来keep alive的方式（用SET_PARAMETER来做）&lt;/li&gt;
&lt;li&gt;RTSP Server也可向Client发TEARDOWN消息&lt;/li&gt;
&lt;li&gt;支持IPV6&lt;/li&gt;
&lt;li&gt;RTSP请求，支持&lt;strong&gt;pipelining&lt;/strong&gt;的形式，也就是聚合Request。比如可以不等服务器返回，把SETUP和PLAY一起发送，这样可以提高至少一个RTT的启动时间。当然需要在消息里加上相关字段。&lt;/li&gt;
&lt;li&gt;重写了状态机，完善了服务器对客户端来说在各个状态之间的转换和行为&lt;/li&gt;
&lt;li&gt;RTSP消息内支持URI了&lt;/li&gt;
&lt;li&gt;扩展了REDIRECT方法，等，等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254714/201711/254714-20171129103932472-1844601355.jpg&quot;/&gt;&lt;strong&gt;haibindev.cnblogs.com，合作请联系QQ。（转载请注明作者和出处~）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 05:16:00 +0000</pubDate>
<dc:creator>haibindev</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haibindev/p/7918733.html</dc:identifier>
</item>
<item>
<title>分布式缓存之Ehcache与terracotta - Terracotta服务器概念篇 - 程老板</title>
<link>http://www.cnblogs.com/cjh-notes/p/7912674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjh-notes/p/7912674.html</guid>
<description>&lt;h2&gt;1、介绍&lt;/h2&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;Terracotta服务器为Terracotta产品提供分布式数据平台。&lt;span class=&quot;tgt&quot; data-group=&quot;0-1&quot;&gt;Terracotta服务器集群被称为Terracotta服务器阵列(TSA)。&lt;span class=&quot;tgt&quot; data-group=&quot;0-2&quot;&gt;Terracotta服务器阵列可以从单个服务器，到一个用于高可用性(HA)的基本的双服务器串联，再到一个提供可配置的规模、高性能和深度故障转移覆盖的多服务器阵列。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;1-0&quot;&gt;Terracotta服务器的主要特性包括:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;2-0&quot;&gt;分布式内存数据管理：在内存中管理比数据网格多10-100x的数据&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;tgt&quot;&gt;不复杂的可伸缩性：简单的配置和部署选项，用于扩展以满足日益增长的需求并促进容量计划&lt;/li&gt;
&lt;li class=&quot;tgt&quot;&gt;高可用性：正常运行和服务的即时故障转移&lt;/li&gt;
&lt;li class=&quot;tgt&quot;&gt;可配置的健康监测：Terracotta健康检查器监控客户端和服务器的健康状况&lt;/li&gt;
&lt;li class=&quot;tgt&quot;&gt;持久化状态：自动永久存储所有当前共享内存数据，并在服务器重启后实现快速的恢复&lt;/li&gt;
&lt;li class=&quot;tgt&quot;&gt;节点自动重连：临时断开的服务器实例和客户端重新加入集群，而不需要操作员干预&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器目录说明 &lt;/p&gt;
&lt;p&gt;server&lt;br/&gt;└─bin -- 可执行文件，如启动服务器的文件 start-tc-server&lt;br/&gt;└─conf -- 配置文件&lt;br/&gt;└─lib&lt;br/&gt;└─plugins&lt;/p&gt;

&lt;h2&gt;2、配置文件&lt;/h2&gt;
&lt;p&gt;Terracotta配置文件是一个xml格式的文件，名为tc-config。&lt;/p&gt;
&lt;p&gt;该文件用于配置单个Terracotta服务器阵列(TSA)条带的所有成员。&lt;/p&gt;
&lt;p&gt;您可以使用工具包中提供的示例配置文件作为Terracotta配置的基础。一些示例中有描述配置元素的内联注释。&lt;/p&gt;

&lt;h3&gt;2.1 配置部分的解释&lt;/h3&gt;
&lt;table class=&quot;Default&quot; border=&quot;1&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell_Head&quot;&gt;
&lt;p&gt;&lt;span&gt;元素名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell_Head&quot;&gt;
&lt;p&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p&gt;&lt;span&gt;Servers&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;Servers部分定义了组成集群的所有服务器。通过配置和运行至少2个服务器，可以实现高可用性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Table_Cell&quot;&gt;&lt;span&gt;请注意，如果没有明确配置哪个服务器充当主动或被动的角色，这样可能会在集群的生命周期中发生变化。&lt;/span&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;span&gt;服务器部分中的每个服务器元素都是由name属性指定的名称标识的:&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;codeph&quot;&gt;&amp;lt;server ... name=&quot;&lt;span class=&quot;var-in-codeph&quot;&gt;ServerName&lt;span class=&quot;codeph&quot;&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_8_6_2_5_4_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;Plugins&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot; readability=&quot;6&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_8_6_2_5_4_4_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;Plugins部分通过注册和配置可提供给这些服务器的附加服务，以及提供对所有服务可用的通用配置信息，&lt;/span&gt;&lt;span&gt;扩展了列出的服务器的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;span&gt;使用扩展点是服务器使用您的应用程序端点（服务）的必要条件。&lt;/span&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_8_6_2_5_6_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot; readability=&quot;6&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_8_6_2_5_6_4_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;tc-properties部分公开了一个键-值对的列表，以进一步定制集群的行为。注意，这个部分通常是空的。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h3&gt;2.2 简单的配置示例&lt;/h3&gt;
&lt;p&gt;这是一个非常简单的服务器配置文件的示例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tc-config &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.terracotta.org/config&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;server &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;localhost&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;testServer0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;terracotta-kit-test/testServer0/logs&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;logs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tsa-port&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;26270&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tsa-port&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tsa-group-port&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;26271&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tsa-group-port&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tc-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这显示了标准配置的关键组件，但是只描述了一个没有使用扩展点的服务器。&lt;/p&gt;
&lt;p&gt;关键点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置名称空间http://www.terracotta.org/config。&lt;/li&gt;
&lt;li&gt;只有一个名为testServer0的服务器。（服务器名称很重要，因为它在启动服务器时会被使用；在实际部署中，应该用完整的主机名或服务器的IP地址替换localhost。）&lt;/li&gt;
&lt;li&gt;给出了一个日志目录的相对路径。（在实际部署中，应该用完整的主机名或服务器的IP地址替换localhost。）&lt;/li&gt;
&lt;li&gt;tsa-port是客户端连接到服务器时使用的端口(默认为9410)。&lt;/li&gt;
&lt;li&gt;尽管在这种情况下没有其他服务器(默认为9530)，但tsa-group端口是用于跨服务器通信的。&lt;/li&gt;
&lt;li&gt;在上面的示例配置中，不可能重新启动或故障转移，因为重新启动支持需要一个扩展点，该扩展点提供了该功能，而故障转移至少需要在集群中至少有两个服务器。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2.3 参数替换&lt;/h3&gt;
&lt;p&gt;参数替换提供了在Terracotta服务器配置文件中使用预定义的系统属性替换变量的方法。因此，可以根据特定于机器的属性来智能地填充大量的字段。参数替换通常用于主机名、IP地址和目录路径替换。&lt;/p&gt;
&lt;p&gt;可使用的参数替换如下：&lt;/p&gt;
&lt;table class=&quot;Default&quot; border=&quot;1&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell_Head&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_3_2_2&quot; class=&quot;Table_Cell_Head&quot;&gt;&lt;span&gt;参数名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell_Head&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_3_2_4&quot; class=&quot;Table_Cell_Head&quot;&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_2_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%h&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_2_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;完整的主机名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_4_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%i&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_4_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;IP地址　　　　&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_6_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%H&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_6_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;用户主目录&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_8_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%n&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_8_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_10_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%o&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_10_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;操作系统名称&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_12_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%a&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_12_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;处理器架构&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_14_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%v&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_14_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;操作系统版本&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_16_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%t&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot; readability=&quot;5&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_16_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;临时目录(在Linux或Solaris上，例如，/tmp)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_18_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%(property)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot; readability=&quot;5&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_18_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;JVM的Java系统属性(例如%(Java.home)，%(logs.path))&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;Table_Cell&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_20_2&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;%D&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;Table_Cell&quot; readability=&quot;5&quot;&gt;
&lt;p id=&quot;ww3_11_32_2_12_8_2_5_20_4&quot; class=&quot;Table_Cell&quot;&gt;&lt;span&gt;时间戳 (yyyyMMddHHmmssSSS)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以在适当的地方使用这些参数，包括期望字符串或值路径的元素或属性。&lt;/p&gt;

&lt;h2&gt;3、启动服务器&lt;/h2&gt;
&lt;p&gt;启动脚本参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;WebWorks_Number&quot;&gt;&lt;span class=&quot;codeph&quot;&gt;[-f /path/to/tc-config.xml] - 指定配置文件路径&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;WebWorks_Number&quot;&gt;&lt;span class=&quot;codeph&quot;&gt;&lt;span class=&quot;codeph&quot;&gt;[-n server_name] - 在配置了多个服务器的情况下指定启动服务器名称&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;On Windows:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd &amp;lt;path/to/terracotta/kit&amp;gt;/server/&lt;span&gt;bin
start&lt;/span&gt;-tc-server.bat -f &amp;lt;path/to/server/config&amp;gt;/tc-config.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; On Unix/Mac:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot; readability=&quot;9.7385496183206&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;39.417938931298&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd &amp;lt;path/to/terracotta/kit&amp;gt;/server/&lt;span&gt;bin
.&lt;/span&gt;/start-tc-server.&lt;span&gt;sh&lt;/span&gt; -f &amp;lt;path/to/server/config&amp;gt;/tc-config.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意：在启动Terracotta服务器前，请先检查需要的java版本。Terracotta5.x需要Java 8的支持。&lt;/p&gt;

&lt;p&gt;检查下面的信息日志，以确认服务器是否成功启动， &lt;code&gt;Terracotta Server instance has started up as ACTIVE node on 0:0:0:0:0:0:0:0:9410 successfully, and is now ready for work.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;windows下启动成功示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1283057/201711/1283057-20171129113314456-491926244.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Terracotta服务器下载地址：&lt;a href=&quot;http://www.terracotta.org/open-source/&quot; target=&quot;_blank&quot;&gt;http://www.terracotta.org/open-source/&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 29 Nov 2017 04:18:00 +0000</pubDate>
<dc:creator>程老板</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjh-notes/p/7912674.html</dc:identifier>
</item>
<item>
<title>从实战出发，谈谈 nginx 信号集 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/7919657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/7919657.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;之前工作时候，一台引流测试机器的一个 ngx_lua 服务突然出现了一些 HTTP/500 响应，从错误日志打印的堆栈来看，是不久前新发布的版本里添加的一个 Lua table 不存在，而有代码向其进行索引导致的。这令人百思不得其解，如果是版本回退导致的，那么为什么使用这个 Lua table 的代码没有被回退，偏偏定义这个 table 的代码被回退了呢？&lt;/p&gt;
&lt;p&gt;经过排查发现，当时 nginx 刚刚完成热更新操作，旧的 master 进程还存在，因为要准备机器重启，先切掉了引流流量（但有些请求还在），同时系统触发了 &lt;code&gt;nginx -s stop&lt;/code&gt;，这才导致了这个问题。&lt;/p&gt;
&lt;h2&gt;场景复现&lt;/h2&gt;
&lt;p&gt;下面我将使用一个原生的 nginx，在我的安装了 fedora26 的虚拟机上复现这个过程，我使用的 nginx 版本是目前最新的 &lt;code&gt;1.13.4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先启动 nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
alex@Fedora26-64: ~/bin_install/nginx
./sbin/nginx
alex@Fedora26-64: ~/bin_install/nginx
ps auxf | grep nginx
alex      6174  0.0  0.0  28876   428 ?        Ss   14:35   0:00 nginx: master process ./sbin/nginx
alex      6175  0.0  0.2  29364  2060 ?        S    14:35   0:00  \_ nginx: worker process
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 master 和 worker 都已经在运行。&lt;/p&gt;
&lt;p&gt;接着我们向 master 发送一个 &lt;code&gt;SIGUSR2&lt;/code&gt; 信号，当 nginx 核心收到这个信号后，就会触发热更新。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
alex@Fedora26-64: ~/bin_install/nginx
kill -USR2 6174
alex@Fedora26-64: ~/bin_install/nginx
ps auxf | grep nginx
alex      6174  0.0  0.1  28876  1996 ?        Ss   14:35   0:00 nginx: master process ./sbin/nginx
alex      6175  0.0  0.2  29364  2060 ?        S    14:35   0:00  \_ nginx: worker process
alex      6209  0.0  0.2  28876  2804 ?        S    14:37   0:00  \_ nginx: master process ./sbin/nginx
alex      6213  0.0  0.1  29364  2004 ?        S    14:37   0:00      \_ nginx: worker process
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到新的 master 和该 master fork 出来的 worker 已经在运行了，此时我们接着向旧 master 发送一个 &lt;code&gt;SIGWINCH&lt;/code&gt; 信号，旧 master 收到这个信号后，会向它的 worker 发送 &lt;code&gt;SIGQUIT&lt;/code&gt;，于是旧 master 的 worker 进程就会退出：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
alex@Fedora26-64: ~/bin_install/nginx
kill -WINCH 6174
alex@Fedora26-64: ~/bin_install/nginx
ps auxf | grep nginx
alex      6174  0.0  0.1  28876  1996 ?        Ss   14:35   0:00 nginx: master process ./sbin/nginx
alex      6209  0.0  0.2  28876  2804 ?        S    14:37   0:00  \_ nginx: master process ./sbin/nginx
alex      6213  0.0  0.1  29364  2004 ?        S    14:37   0:00      \_ nginx: worker process
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时只剩下旧的 master，新的 master 和新 master 的 worker 在运行，这和当时线上运行的情况类似。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接着我们使用 stop 命令：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
alex@Fedora26-64: ~/bin_install/nginx
./sbin/nginx -s stop
alex@Fedora26-64: ~/bin_install/nginx
ps auxf | grep nginx
alex      6174  0.0  0.1  28876  1996 ?        Ss   14:35   0:00 nginx: master process ./sbin/nginx
alex      6301  0.0  0.2  29364  2124 ?        S    14:49   0:00  \_ nginx: worker process
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们会发现，新的 master 和它的 worker 都已经退出，而旧的 master 还在运行，并产生了 worker 出来。这就是当时线上的情况了。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;事实上，这个现象和 nginx 自身的设计有关：当旧的 master 准备产生 fork 新的 master 之前，它会把 &lt;code&gt;nginx.pid&lt;/code&gt; 这个文件重命名为 &lt;code&gt;nginx.pid.oldbin&lt;/code&gt;，然后再由 fork 出来的新的 master 去创建新的 &lt;code&gt;nginx.pid&lt;/code&gt;，这个文件将会记录新 master 的 pid。nginx 认为热更新完成之后，旧 master 的使命几乎已经结束，之后它随时会退出，因此之后的操作都应该由新 master 接管。当然，在旧 master 没有退出的情况下通过向新 master 发送 &lt;code&gt;SIGUSR2&lt;/code&gt; 企图再次热更新是无效的，新 master 只会忽略掉这个信号然后继续它自己的工作。&lt;/p&gt;
&lt;h2&gt;问题分析&lt;/h2&gt;
&lt;p&gt;更不巧的是，我们上面提到的这个 Lua table，定义它的 Lua 文件早在运行 init_by_lua 这个 hook 的时候，就已经被 LuaJIT 加载到内存并编译成字节码了，那么显然旧的 master 必然没有这个 Lua table，因为它加载那部分 Lua 代码是旧版本的。&lt;/p&gt;
&lt;p&gt;而索引该 table 的 Lua 代码并没有在 init_by_lua 的时候使用到，这些代码都是在 worker 进程里被加载起来的，这时候项目目录里的代码都是最新的，所以 worker 进程加载的都是最新的代码，如果这些 worker 进程处理到相关的请求，就会出现 Lua 运行时错误，外部表现则是对应的 HTTP 500。&lt;/p&gt;
&lt;p&gt;吸收了这个教训之后，我们需要更加合理地关闭我们的 nginx 服务。 所以一个更加合理的 nginx 服务启动关闭脚本是必需的，网上流传的一些脚本并没有对这个现象做处理，我们更应该参考 NGINX 官方提供的脚本。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
stop() {
    echo -n $&quot;Stopping $prog: &quot;
    killproc $prog -QUIT
    retval=$?
    echo
    [ $retval -eq 0 ] &amp;amp;&amp;amp; rm -f $lockfile
    return $retval
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这段代码引自 NGINX 官方的 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;/etc/init.d/nginx&lt;/a&gt; 。&lt;/p&gt;
&lt;h2&gt;nginx 信号集&lt;/h2&gt;
&lt;p&gt;接下来我们来全面梳理下 nginx 信号集，这里不会涉及到源码细节，感兴趣的同学可以自行阅读相关源码。&lt;/p&gt;
&lt;p&gt;我们有两种方式来向 master 进程发送信号，一种是通过&lt;span&gt; &lt;code&gt;nginx -s signal&lt;/code&gt;&lt;/span&gt; 来操作，另一种是通过 kill 命令手动发送。&lt;/p&gt;
&lt;p&gt;第一种方式的原理是，产生一个新进程，该进程通过 &lt;span&gt;&lt;code&gt;nginx.pid&lt;/code&gt; &lt;/span&gt;文件得到 master 进程的 pid，然后把对应的信号发送到 master，之后退出，这种进程被称为 signaller。&lt;/p&gt;
&lt;p&gt;第二种方式要求我们了解&lt;span&gt; &lt;code&gt;nginx -s signal&lt;/code&gt;&lt;/span&gt; 到真实信号的映射。下表是它们的映射关系：&lt;/p&gt;
&lt;p&gt;operationsignalreloadSIGHUPreopenSIGUSR1stopSIGTERMquitSIGQUIThot updateSIGUSR2 &amp;amp; SIGWINCH &amp;amp; SIGQUIT&lt;/p&gt;
&lt;h2&gt;stop vs quit&lt;/h2&gt;
&lt;p&gt;stop 发送 SIGTERM 信号，表示要求强制退出，quit 发送 &lt;span&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;/span&gt;，表示优雅地退出。 具体区别在于，worker 进程在收到 &lt;span&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;/span&gt; 消息（注意不是直接发送信号，所以这里用消息替代）后，会关闭监听的套接字，关闭当前空闲的连接（可以被抢占的连接），然后提前处理所有的定时器事件，最后退出。没有特殊情况，都应该使用 quit 而不是 stop。&lt;/p&gt;
&lt;h2&gt;reload&lt;/h2&gt;
&lt;p&gt;master 进程收到 &lt;code&gt;SIGHUP&lt;/code&gt; 后，会重新进行配置文件解析、共享内存申请，等一系列其他的工作，然后产生一批新的 worker 进程，最后向旧的 worker 进程发送 &lt;code&gt;SIGQUIT&lt;/code&gt; 对应的消息，最终无缝实现了重启操作。&lt;/p&gt;
&lt;h2&gt;reopen&lt;/h2&gt;
&lt;p&gt;master 进程收到 &lt;code&gt;SIGUSR1&lt;/code&gt; 后，会重新打开所有已经打开的文件（比如日志），然后向每个 worker 进程发送 &lt;code&gt;SIGUSR1&lt;/code&gt; 信息，worker 进程收到信号后，会执行同样的操作。reopen 可用于日志切割，比如 NGINX 官方就提供了一个方案：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
$ mv access.log access.log.0
$ kill -USR1 `cat master.nginx.pid`
$ sleep 1
$ gzip access.log.0    # do something with access.log.0
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这里 &lt;code&gt;sleep 1&lt;/code&gt; 是必须的，因为在 master 进程向 worker 进程发送 &lt;code&gt;SIGUSR1&lt;/code&gt; 消息到 worker 进程真正重新打开 &lt;code&gt;access.log&lt;/code&gt; 之间，有一段时间窗口，此时 worker 进程还是向文件 &lt;code&gt;access.log.0&lt;/code&gt; 里写入日志的。通过 sleep 1s，保证了 &lt;code&gt;access.log.0&lt;/code&gt; 日志信息的完整性（如果没有 sleep 而直接进行压缩，很有可能出现日志丢失的情况）。&lt;/p&gt;
&lt;h2&gt;hot update&lt;/h2&gt;
&lt;p&gt;某些时候我们需要进行二进制热更新，nginx 在设计的时候就包含了这种功能，不过无法通过 nginx 提供的命令行完成，我们需要手动发送信号。&lt;/p&gt;
&lt;p&gt;通过上面的问题复现，大家应该已经了解到如何进行热更新了，我们首先需要给当前的 master 进程发送 &lt;span&gt;&lt;code&gt;SIGUSR2&lt;/code&gt;&lt;/span&gt;，之后 master 会重命名 &lt;code&gt;nginx.pid&lt;/code&gt; 到 &lt;code&gt;nginx.pid.oldbin&lt;/code&gt;，然后 fork 一个新的进程，新进程会通过 &lt;code&gt;execve&lt;/code&gt; 这个系统调用，使用新的 nginx ELF 文件替换当前的进程映像，成为新的 master 进程。新 master 进程起来之后，就会进行配置文件解析等操作，然后 fork 出新的 worker 进程开始工作。&lt;/p&gt;
&lt;p&gt;接着我们向旧的 master 发送 &lt;span&gt;&lt;code&gt;SIGWINCH&lt;/code&gt;&lt;/span&gt; 信号，然后旧的 master 进程则会向它的 worker 进程发送 &lt;code&gt;SIGQUIT&lt;/code&gt; 信息，从而使得 worker 进程退出。向 master 进程发送 &lt;span&gt;&lt;code&gt;SIGWINCH&lt;/code&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;/span&gt; 都会使得 worker 进程退出，但是前者不会使得 master 进程也退出。&lt;/p&gt;
&lt;p&gt;最后，如果我们觉得旧的 master 进程使命完成，就可以向它发送 &lt;span&gt;&lt;code&gt;SIGQUIT&lt;/code&gt;&lt;/span&gt; 信号，让其退出了。&lt;/p&gt;
&lt;h2&gt;worker 进程如何处理来自 master 的信号消息&lt;/h2&gt;
&lt;p&gt;实际上，master 进程再向 worker 进程通讯，不是使用 kill 函数，而是使用了通过管道实现的 nginx channel，master 进程向管道一端写入信息（比如信号信息），worker 进程则从另外一端收取信息，nginx channel 事件，在 worker 进程刚刚起来的时候，就被加入事件调度器中（比如 epoll，kqueue），所以当有数据从 master 发来时，即可被事件调度器通知到。&lt;/p&gt;
&lt;p&gt;nginx 这么设计是有理由的，作为一个优秀的反向代理服务器，nginx 追求的就是极致的高性能，而 signal handler 会中断 worker 进程的运行，使得所有的事件都被暂停一个时间窗口，这对性能是有一定损失的。&lt;/p&gt;
&lt;p&gt;很多人可能会认为当 master 进程向 worker 进程发送信息之后，worker 进程立刻会有对应操作回应，然而 worker 进程是非常繁忙的，它不断地处理着网络事件和定时器事件，当调用 nginx channel 事件的 handler 之后，nginx 仅仅只是处理了一些标志位。真正执行这些动作是在一轮事件调度完成之后。所以这之间存在一个时间窗口，尤其是业务复杂且流量巨大的时候，这个窗口就有可能被放大，这也就是为什么 NGINX 官方提供的日志切割方案里要求 sleep 1s 的原因。&lt;/p&gt;
&lt;p&gt;当然，我们也可以绕过 master 进程，直接向 worker 进程发送信号，worker 可以处理的信号有&lt;/p&gt;
&lt;p&gt;&lt;span&gt;signaleffectSIGINT&lt;/span&gt;强制退出&lt;span&gt;SIGTERM&lt;/span&gt;强制退出&lt;span&gt;SIGQUIT&lt;/span&gt;优雅退出&lt;span&gt;SIGUSR1&lt;/span&gt;重新打开文件&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;nginx 信号操作在日常运维中是最常见的，也是非常重要的，这个环节如果出现失误则可能造成业务异常，带来损失。所以理清楚 nginx 信号集是非常必要的，能帮助我们更好地处理这些工作。&lt;/p&gt;
&lt;p&gt;另外，通过这次的经验教训和对 nginx 信号集的认知，我们认为以下几点是比较重要的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;慎用 &lt;span&gt;&lt;code&gt;nginx -s stop&lt;/code&gt;&lt;/span&gt;，尽可能使用 &lt;span&gt;&lt;code&gt;nginx -s quit&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;热更新之后，如果确定业务没问题，尽可能让旧的 master 进程退出&lt;/li&gt;
&lt;li&gt;关键性的信号操作完成后，等待一段时间，避免时间窗口的影响&lt;/li&gt;
&lt;li&gt;不要直接向 worker 进程发送信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tech.upyun.com/article/257/%25E5%2590%25AF%25E7%2594%25A8%2520Brotli%2520%25E5%258E%258B%25E7%25BC%25A9%25E7%25AE%2597%25E6%25B3%2595%25EF%25BC%258C%25E5%25AF%25B9%25E6%25AF%2594%2520Gzip%2520%25E5%258E%258B%25E7%25BC%25A9%2520CDN%2520%25E6%25B5%2581%25E9%2587%258F%25E5%2586%258D%25E5%2587%258F%25E5%25B0%2591%252020%2525.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;启用 Brotli 压缩算法，对比 Gzip 压缩 CDN 流量再减少 20%&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tech.upyun.com/article/258/HTTPS%2520%25E4%25BC%25A0%25E8%25BE%2593%25E4%25BC%2598%25E5%258C%2596%25E8%25AF%25A6%25E8%25A7%25A3%25E4%25B9%258B%25E5%258A%25A8%25E6%2580%2581%2520TLS%2520Record%2520Size.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;HTTPS 传输优化详解之动态 TLS Record Size&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 04:03:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/7919657.html</dc:identifier>
</item>
<item>
<title>SQL 追踪 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4649515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4649515.html</guid>
<description>&lt;p&gt;SQL追踪（SQL Trace）是一个轻量级的追踪工具，按照事件（Events）记录数据库发生的消息，几乎对数据库性能没有什么影响。SQL Server内置一个Trace，称作默认追踪（Default Trace），默认追踪的ID是1，大家经常使用的SQL Server Profiler，就是利用SQL Trace记录数据库活动的一个工具。SQL Trace在SQL Server数据库引擎种出现的比较早，可以被性能和功能更卓越的扩展事件（Extended Events）取代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，查看默认追踪是否启用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认追踪是系统内置的，TraceID是1，默认是开启的，可以通过系统配置表 sys.configurations 进行查看，配置项ID（configuration_id）是1568：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images0.cnblogs.com/blog2015/628084/201507/152056119548283.png&quot; alt=&quot;&quot; width=&quot;863&quot; height=&quot;45&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字段 value=1，表示Default Trace是开启的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二，禁用或启用默认追踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果默认追踪被禁用，需要重新配置启用默认追踪：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exec&lt;/span&gt; sp_configure &lt;span&gt;'&lt;/span&gt;&lt;span&gt;show advanced options&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;reconfigure&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;exec&lt;/span&gt; sp_configure &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default trace enabled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;reconfigure&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果默认追踪已经启用，可以重新配置禁用默认追踪：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exec&lt;/span&gt; sp_configure &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default trace enabled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;reconfigure&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;

&lt;span&gt;exec&lt;/span&gt; sp_configure &lt;span&gt;'&lt;/span&gt;&lt;span&gt;show advanced options&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;reconfigure&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三，查看默认追踪的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认追踪记录的数据存储在文件中，可以从系统视图 sys.traces查看文件的路径，文件的大小（Size）和文件的更新方式等信息，追踪文件默认的扩展名是 .trc。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; id
    ,iif(status&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stopped&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; status
    ,path
    ,max_size
    ,start_time
    ,stop_time
    ,event_count
    ,max_files
    ,is_rowset
    ,is_rollover
    ,is_shutdown
    ,is_default
    ,buffer_count
    ,buffer_size &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; each_buffer_size
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.traces
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认追踪有5个跟踪文件，每一个文件的最大size默认是20MB，SQL Server负责维护这5个文件，当实例重启的时候或者到达文件Size最大值的时候，SQL Server创建新的文件，将最早的跟踪文件删除，依次滚动（Rollover）更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四，查看追踪文件的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数sys.fn_trace_gettable，用于从追踪文件中读取数据，以关系表的格式显式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sys.fn_trace_gettable ( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , number_files )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数filename：用于指定追踪文件的名称，其值可以从系统视图sys.traces 中的path获取；&lt;/p&gt;
&lt;p&gt;参数number_files：如果number_files 被指定为default，函数读取所有的滚动文件。&lt;/p&gt;
&lt;p&gt;函数返回的是关系表，有效字段是：追踪关联的事件绑定的字段，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; 
&lt;span&gt;from&lt;/span&gt; sys.fn_trace_gettable(N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\Log\log_4.trc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;default&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五，查看默认追踪记录的事件列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数fn_trace_geteventinfo(trace_id)返回追踪关联的事件列表，使用该函数可以查看默认追踪记录的事件和事件的特定字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; categ.name &lt;span&gt;as&lt;/span&gt;&lt;span&gt; category,
    te.trace_event_id &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_id, 
    te.name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_name,
    tc.trace_column_id &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_column_id,
    tc.name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; column_name,
    tc.type_name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; column_type
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sys.fn_trace_geteventinfo(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; gei
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.trace_columns tc 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; gei.columnid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;tc.trace_column_id
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.trace_events te 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; gei.eventid&lt;span&gt;=&lt;/span&gt;&lt;span&gt;te.trace_event_id
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.trace_categories categ
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; te.category_id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;categ.category_id
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; category,event_id,event_column_id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六，查看事件和Category&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Category用于组织事件（Event），在SQL Server 2012中，共有21个Category，180个Event，每个Event属于唯一的一个Category。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; tc.name &lt;span&gt;as&lt;/span&gt;&lt;span&gt; category,
    te.trace_event_id &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_id,
    te.name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.trace_categories tc 
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.trace_events te 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; tc.category_id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;te.category_id
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; category,event_id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;七，查看事件绑定的字段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQL Server 2012中，事件共有66个字段，但不是每个Event都能绑定所有的66个字段，每个Event能够绑定的字段是固定的，系统预先设置，用户不能修改，&lt;span&gt;视图 &lt;strong&gt;sys.trace_event_bindings&lt;/strong&gt; 用于显示每个事件绑定的字段。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; te.trace_event_id &lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_id, 
    te.name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; event_name,
    tc.trace_column_id &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; column_id,
    tc.name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; column_name,
    tc.type_name &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; column_type
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.trace_event_bindings teb 
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.trace_columns tc 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; teb.trace_column_id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;tc.trace_column_id
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.trace_events te 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; teb.trace_event_id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;te.trace_event_id
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; event_id,column_id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;八，使用SQL Server Profiler创建SQL Trace&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果用户需要创建自定义的追踪，那么可以使用系统提供的存储过程来实现，但是，使用TSQL代码创建追踪的过程十分繁琐，代码量庞大，整个过程不直观。大家知道，SQL Server Profiler是一个可视化用于查看数据库活动的工具，但是，它也是一个用于创建SQL Trace的工具。使用SQL Server Profiler创建SQL Trace的过程十分简单：选择相应的事件和事件的字段之后，导出SQL Trace  的定义即可。&lt;/p&gt;
&lt;p&gt;在创建SQL Trace之后，点击File-&amp;gt;Export-&amp;gt;Scipt Trace Definition，把SQL Server Profiler用于创建SQL Trace的脚本代码导出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201711/628084-20171129114545987-1990872997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导出的脚本如下，不能直接使用，必须修改一处代码：在创建Trace时，指定存储追踪数据的文件（File） 或 关系表（Table），仅此而已。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c4ccaf94-2d84-4a6f-b03c-298ec08e34da')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_c4ccaf94-2d84-4a6f-b03c-298ec08e34da&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c4ccaf94-2d84-4a6f-b03c-298ec08e34da&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c4ccaf94-2d84-4a6f-b03c-298ec08e34da',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c4ccaf94-2d84-4a6f-b03c-298ec08e34da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Create a Queue&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@rc&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@TraceID&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@maxfilesize&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@maxfilesize&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Client side File and Table cannot be scripted&lt;/span&gt;
&lt;span&gt;exec&lt;/span&gt; &lt;span&gt;@rc&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; sp_trace_create &lt;span&gt;@TraceID&lt;/span&gt; output, &lt;span&gt;0&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;InsertFileNameHere&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@maxfilesize&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt; 
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;@rc&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Set the events&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@on&lt;/span&gt; &lt;span&gt;bit&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@on&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;exec&lt;/span&gt; sp_trace_setevent &lt;span&gt;@TraceID&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;@on&lt;/span&gt;
&lt;span&gt;exec&lt;/span&gt; sp_trace_setevent &lt;span&gt;@TraceID&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;@on&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt;delete many commands here ---&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Set the Filters&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@intfilter&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@bigintfilter&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;
&lt;span&gt;exec&lt;/span&gt; sp_trace_setfilter &lt;span&gt;@TraceID&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%drop%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Set the trace status to start&lt;/span&gt;
&lt;span&gt;exec&lt;/span&gt; sp_trace_setstatus &lt;span&gt;@TraceID&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; display trace id for future references&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; TraceID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@TraceID&lt;/span&gt;
&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; finish

error: 
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; ErrorCode&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@rc&lt;/span&gt;&lt;span&gt;

finish: 
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;注：SQL Trace是被扩展事件取代的功能，在后续的版本中将会被移除，建议在以后的开发中使用扩展事件。&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/sql-trace/sql-trace&quot; target=&quot;_blank&quot;&gt;SQL Trace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms190292(v=sql.110).aspx&quot; target=&quot;_blank&quot;&gt;Server-wide Configuration Catalog Views (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ff848738(v=sql.110).aspx&quot; target=&quot;_blank&quot;&gt;System Trace Functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/gaizai/p/3358998.html&quot;&gt;SQL Server 默认跟踪（Default Trace）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhijianliutang/p/4113911.html&quot;&gt;SQL Server中关于跟踪（Trace)那点事&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 03:52:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4649515.html</dc:identifier>
</item>
<item>
<title>Android App插件式换肤实现方案 - Android开发8585</title>
<link>http://www.cnblogs.com/lzh-Linux/p/7919462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzh-Linux/p/7919462.html</guid>
<description>&lt;p&gt;目前很多app都具有换肤功能，用户可以根据需要切换不同的皮肤，为使我们的App支持换肤功能，给用户提供更好的体验，在这里对换肤原理进行研究总结，并选择一个合适的换肤解决方案。&lt;/p&gt;


&lt;p&gt;App换肤主要涉及的有页面中文字的颜色、控件的背景颜色、一些图片资源和主题颜色等资源。&lt;/p&gt;
&lt;p&gt;为了实现换肤资源不与原项目混淆，尽量降低风险，可以将这些资源封装在一个独立的Apk资源文件中。在App运行时，主程序动态的从Apk皮肤包中读取相应的资源，无需Acitvity重启即可实现皮肤的实时更换，皮肤包与原安装包相分离，从而实现插件式换肤。&lt;/p&gt;


&lt;h4&gt;1.     如何加载皮肤资源文件&lt;/h4&gt;
&lt;p&gt;使用插件式换肤，皮肤资源肯定不会在被封装到主工程中，要怎么加载外部的皮肤资源呢？&lt;/p&gt;
&lt;p&gt;先看下 Apk 的打包流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561894/201711/561894-20171129112116909-329161900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里流程中，有两个关键点&lt;br/&gt;&lt;strong&gt;1.R&lt;/strong&gt;&lt;strong&gt;文件的生成&lt;/strong&gt;&lt;br/&gt;    R文件是一个Java文件，通过R文件我们就可以找到对应的资源。R文件就像一张映射表，帮助我们找到资源文件。&lt;br/&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;资源文件的打包生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资源文件经过压缩打包，生成 resources 文件，通过R文件找到里面保存的对映的资源文件。在 App 内部，我们一般通过下面代码，获取资源：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
context.getResource.getString(R.string.hello);
context.getResource.getColor(R.color.black);
context.getResource.getDrawable(R.drawable.splash);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时获取 &lt;span lang=&quot;EN-US&quot;&gt;App 内部的资源，能我们家在皮肤资源什么思路吗？加载外部资源的 &lt;span lang=&quot;EN-US&quot;&gt;Resources 能通过类似的思路吗？&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;   我们查看下&lt;span lang=&quot;EN-US&quot;&gt;Resources 类的源码，发现 &lt;span lang=&quot;EN-US&quot;&gt;Resources 的构造函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
  public Resources(AssetManager assets, DisplayMetrics metrics, Configuration config) {
        this(assets, metrics, config, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO);
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里关键是第一个参数如何获取，第二和第三个参数可以通过 &lt;span lang=&quot;EN-US&quot;&gt;Activity 获取到。我们再去看下 &lt;span lang=&quot;EN-US&quot;&gt;AssetManager 的代码，同时会发现下面的这个&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Add an additional set of assets to the asset manager.  This can be
     * either a directory or ZIP file.  Not for use by applications.  Returns
     * the cookie of the added asset, or 0 on failure.
     * {@hide}
     */
  public final int addAssetPath(String path) {
        synchronized (this) {
            int res = addAssetPathNative(path);
            makeStringBlocks(mStringBlocks);
            return res;
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;AssetManager 可以加载一个zip 格式的压缩包，而 Apk 文件不就是一个 压缩包吗。我们通过反射的方法，拿到 AssetManager，加载 Apk 内部的资源，获取到 Resources 对象，这样再想办法，把 R文件里面保存的ID获取到，这样既可以拿到对应的资源文件了。理论上我们的思路时成立的。&lt;br/&gt;   我们看下，如何通过代码获取 Resources 对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
AssetManager assetManager = AssetManager.class.newInstance();
Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);
addAssetPath.invoke(assetManager, skinPkgPath);

Resources superRes = context.getResources();
Resources skinResource = new Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration());
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.     如何标记需要换肤的View&lt;/h4&gt;
&lt;p&gt;找到资源文件之后，我们要接着标记需要换肤的 View 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;找到需要换肤的 View&lt;/strong&gt;&lt;br/&gt;怎么寻找哪些是我们要关注的 View 呢？ 我们还是重 View 的创建时机寻找机会。我们添加一个布局文件时，会使用 LayoutInflater的 Inflater方法，我们看下这个方法是怎么讲一个View添加到Activity 中的。&lt;br/&gt;LayoutInflater 中有个接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public interface Factory {
        /**
         * Hook you can supply that is called when inflating from a LayoutInflater.
         * You can use this to customize the tag names available in your XML
         * layout files.
         * 
         * &amp;lt;p&amp;gt;
         * Note that it is good practice to prefix these custom names with your
         * package (i.e., com.coolcompany.apps) to avoid conflicts with system
         * names.
         * 
         * @param name Tag name to be inflated.
         * @param context The context the view is being created in.
         * @param attrs Inflation attributes as specified in XML file.
         * 
         * @return View Newly created view. Return null for the default
         *         behavior.
         */
        public View onCreateView(String name, Context context, AttributeSet attrs);
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据这里的注释描述，我们可以自己实现这个接口，在 &lt;strong&gt;onCreateView&lt;/strong&gt; &lt;strong&gt;方法中选择我们需要标记的View&lt;/strong&gt;，根据 AttributeSet 值，过滤不需要关注的View。&lt;br/&gt;&lt;strong&gt;标记 View 与对应的资源&lt;/strong&gt;&lt;br/&gt;我们在 View 创建时，通过过滤 Attribute 属性，找到我们要标记的 View ，下面我们就把这些View的属性记下来&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
for (int i = 0; i &amp;lt; attrs.getAttributeCount(); i++){
            String attrName = attrs.getAttributeName(i);
            String attrValue = attrs.getAttributeValue(i);
            if(!AttrFactory.isSupportedAttr(attrName)){
                continue;
            }  
            if(attrValue.startsWith(&quot;@&quot;)){
                try {
                    int id = Integer.parseInt(attrValue.substring(1));
                    String entryName = context.getResources().getResourceEntryName(id);
                    String typeName = context.getResources().getResourceTypeName(id);
                    SkinAttr mSkinAttr = AttrFactory.get(attrName, id, entryName, typeName);
                    if (mSkinAttr != null) {
                        viewAttrs.add(mSkinAttr);
                    }
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                } catch (NotFoundException e) {
                    e.printStackTrace();
                }
            }
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后把这些 View 和属性值，一起封装保存起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
if(!ListUtils.isEmpty(viewAttrs)){
            SkinItem skinItem = new SkinItem();
            skinItem.view = view;
            skinItem.attrs = viewAttrs;
            mSkinItems.add(skinItem);
            if(SkinManager.getInstance().isExternalSkin()){
                skinItem.apply();
            }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.     如何做到及时更新UI&lt;/h4&gt;
&lt;p&gt;由于我们把需要更新的View 以及属性值都保存起来了，更新的时候只要把他们取出来遍历一遍即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override
    public void onThemeUpdate() {
        if(!isResponseOnSkinChanging){
            return;
        }
        mSkinInflaterFactory.applySkin();
    }
//applySkin 的具体实现
public void applySkin(){
        if(ListUtils.isEmpty(mSkinItems)){
            return;
        }   
        for(SkinItem si : mSkinItems){
            if(si.view == null){
                continue;
            }
            si.apply();
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.     如何制作皮肤包&lt;/h4&gt;
&lt;p&gt;皮肤包制作相对简单&lt;br/&gt;1.创建独立工程 model，包名任意。&lt;br/&gt;2.添加资源文件到 model 中,不需要 java 代码&lt;br/&gt;3.运行 build.gradle 脚本，打包命令，生成apk文件，修改名称为 xxx.skin 皮肤包即可。&lt;/p&gt;

&lt;p&gt;根据以上换肤原理，在github上面选择了一个第三方开源框架ThemeSkinning，具体使用方法如下：&lt;/p&gt;
&lt;h3&gt;1. 集成步骤：&lt;/h3&gt;
&lt;p&gt;1)     添加依赖 compile 'com.solid.skin:skinlibrary:1.3.1'&lt;/p&gt;
&lt;p&gt;2)     使项目中的Application继承于SkinBaseApplication&lt;/p&gt;
&lt;p&gt;3)     使项目中的Activity继承于SkinBaseActivity，如果使用了Fragment则继承于SkinBaseFragment&lt;/p&gt;
&lt;p&gt;4)     在需要换肤的根布局上添加 xmlns:skin=&quot;http://schemas.android.com/android/skin&quot; ，然后在需要换肤的View上加上 skin:enable=&quot;true&quot;&lt;/p&gt;
&lt;p&gt;5)     新建一个项目模块（只包含有资源文件），其中包含的资源文件的name一定要和原项目中有换肤需求的View所使用的资源name一致。&lt;/p&gt;
&lt;p&gt;6)     打包皮肤文件，放入assets中的skin目录下（skin目录是自己新建的）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;7)       调用换肤方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 assets/skin 文件夹中的皮肤&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/561894/201711/561894-20171129113121331-975876076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.换肤属性的扩展&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;该开源库默认仅支持View的textColor和background两个属性的换肤，如果需要对其他属性进行换肤，那么就需要去自定义了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么如何自定义呢？看下面这个例子：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;ImageView大家应该都用过吧。它的src属性就是定义图片资源引用，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;新建一个ImageSrcAttr继承于 SkinAttr，然后重写apply方法。apply方法在换肤的时候就会被调用，代码的详细实现：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;public class&lt;/strong&gt; ImageSrcAttr &lt;strong&gt;extends SkinAttr {&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  @Override&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  public void apply(View view) {&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;      if (view instanceof ImageView) {&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;            ImageView iv = (ImageView) view;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;            if (RES_TYPE_NAME_DRAWABLE.equals(attrValueTypeName)) {&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;                Drawable drawable = SkinResourcesUtils.getDrawable(attrValueRefId);&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;                iv.setImageDrawable(drawable);&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;            }&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;        }      }&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;  }&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：attrValueRefId：就是资源id。SkinResourcesUtils是用来获取皮肤包里的资源，这里设置color或者drawable一定要使用本工具类。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当上面的工作完成之后，就到我们自己的Application的onCreate方法中加入         SkinConfig.addSupportAttr(&quot;src&quot;, new ImageSrcAttr());我们就可以正常使用了src属性了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;此外，对于动态创建的view，我们需要动态添加支持，调用&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;dynamicAddSkinEnableView(View view, String attrName, int attrValueResId)方法添加支持。&lt;/p&gt;
&lt;h3&gt;3.其他一些重要的api&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;SkinConfig.isDefaultSkin(context):判断当前皮肤是否是默认皮肤&lt;/li&gt;
&lt;li&gt;SkinManager.getInstance().restoreDefaultTheme(): 重置默认皮肤&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 29 Nov 2017 03:33:00 +0000</pubDate>
<dc:creator>Android开发8585</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzh-Linux/p/7919462.html</dc:identifier>
</item>
<item>
<title>利用docker搭建spark hadoop workbench - 梧留柒</title>
<link>http://www.cnblogs.com/wanly3643/p/7919090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanly3643/p/7919090.html</guid>
<description>&lt;pre&gt;
 java.lang.ClassCastException: cannot assign instance of scala.collection.immutable.List$SerializationProxy to field org.apache.spark.rdd.RDD.org$apache$spark$rdd$RDD$$dependencies_ of type scala.collection.Seq in instance of org.apache.spark.rdd.MapPartitionsRDD
&lt;/pre&gt;</description>
<pubDate>Wed, 29 Nov 2017 02:51:00 +0000</pubDate>
<dc:creator>梧留柒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanly3643/p/7919090.html</dc:identifier>
</item>
</channel>
</rss>