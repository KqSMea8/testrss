<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发编程原理与实战四：线程如何中断 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9344792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9344792.html</guid>
<description>&lt;p&gt;&lt;span&gt;如果你使用过杀毒软件，可能会发现全盘杀毒太耗时间了，这时你如果点击取消杀毒按钮，那么此时你正在中断一个运行的线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;java为我们提供了一种调用interrupt()方法来请求终止线程的方法，下面我们就一起来学习一下线程的中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个线程都有一个boolean类型标志，用来表明当前线程是否请求中断，当一个线程调用interrupt() 方法时，线程的中断标志将被设置为true。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过调用Thread.currentThread().isInterrupted()或者Thread.interrupted()来检测线程的中断标志是否被置位。这两个方法的区别是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread.currentThread().isInterrupted()是线程对象的方法，调用它后不清除线程中断标志位；而Thread.interrupted()是一个静态方法，调用它会清除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程中断标志位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread.currentThread().isInterrupted()：        对象方法        不清除中断标志位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread.interrupted()：                                        静态方法         清除中断标志位(设置为false)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说调用线程的interrupt() 方法不会中断一个正在运行的线程，这个机制只是设置了一个线程中断标志位，如果在程序中你不检测线程中断标志位，那么即使&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置了中断标志位为true，线程也一样照常运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说中断线程分为三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(一) ：中断非阻塞线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(二)：中断阻塞线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(三)：不可中断线程&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(一) ：中断非阻塞线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中断非阻塞线程通常有两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)采用线程共享变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种方式比较简单可行，需要注意的一点是共享变量必须设置为volatile，这样才能保证修改后其他线程立即可见。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptThreadTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程共享变量&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isStop = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;isStop) {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; beginTime =&lt;span&gt; System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;is running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程每隔一秒钟检测一次线程共享变量是否得到通知&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() - beginTime &amp;lt; 1000&lt;span&gt;) {}
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isStop) {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;is interrupted&quot;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        InterruptThreadTest itt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptThreadTest();
        itt.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程共享变量设置为true&lt;/span&gt;
        itt.isStop = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; (2) 采用中断机制 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptThreadTest2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里调用的是非清除中断标志位的isInterrupted方法&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Thread.currentThread().isInterrupted()) {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; beginTime =&lt;span&gt; System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;is running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程每隔一秒钟检测线程中断标志位是否被置位&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (System.currentTimeMillis() - beginTime &amp;lt; 1000&lt;span&gt;) {}
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.currentThread().isInterrupted()) {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;is interrupted&quot;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        InterruptThreadTest2 itt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptThreadTest2();
        itt.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程的中断标志位&lt;/span&gt;
&lt;span&gt;        itt.interrupt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;(二)：中断阻塞线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当线程调用Thread.sleep()、Thread.join()、object.wait()再或者调用阻塞的i/o操作方法时，都会使得当前线程进入阻塞状态。那么此时如果在线程处于阻塞状态是调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;interrupt() 方法设置线程中断标志位时会出现什么情况呢！ 此时处于阻塞状态的线程会抛出一个异常，并且会清除线程中断标志位(设置为false)。这样一来线程就能退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻塞状态。当然抛出异常的方法就是造成线程处于阻塞状态的Thread.sleep()、Thread.join()、object.wait()这些方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实例如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptThreadTest3 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里调用的是非清除中断标志位的isInterrupted方法&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Thread.currentThread().isInterrupted()) {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; is running&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; Thread.sleep begin&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; Thread.sleep end&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于调用sleep()方法清除状态标志位 所以这里需要再次重置中断标志位 否则线程会继续运行下去&lt;/span&gt;
&lt;span&gt;                Thread.currentThread().interrupt();
                e.printStackTrace();
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.currentThread().isInterrupted()) {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;is interrupted&quot;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        InterruptThreadTest3 itt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptThreadTest3();
        itt.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程的中断标志位&lt;/span&gt;
&lt;span&gt;        itt.interrupt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的地方就是 Thread.sleep()、Thread.join()、object.wait()这些方法，会检测线程中断标志位，如果发现中断标志位为true则抛出异常并且将中断标志位设置为false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以while循环之后每次调用阻塞方法后 都要在捕获异常之后，调用Thread.currentThread().interrupt()重置状态标志位。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(三)：不可中断线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一种情况是线程不能被中断的，就是调用synchronized关键字和reentrantLock.lock()获取锁的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果调用带超时的tryLock方法reentrantLock.tryLock(longtimeout, TimeUnit unit)，那么如果线程在等待时被中断，将抛出一个InterruptedException异常，这是一个非常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有用的特性，因为它允许程序打破死锁。你也可以调用reentrantLock.lockInterruptibly()方法，它就相当于一个超时设为无限的tryLock方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterruptThreadTest5 {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deathLock(Object lock1, Object lock2) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock1) {
                System.out.println(Thread.currentThread().getName()&lt;/span&gt;+ &quot; is running&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让另外一个线程获得另一个锁&lt;/span&gt;
                Thread.sleep(10&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 造成死锁&lt;/span&gt;
                &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock2) {
                    System.out.println(Thread.currentThread().getName());
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            System.out.println(Thread.currentThread().getName()&lt;/span&gt;+ &quot; is interrupted&quot;&lt;span&gt;);
            e.printStackTrace();
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String [] args) { 
        
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; InterruptThreadTest5 itt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptThreadTest5();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object lock1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Object lock2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable(){
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                itt.deathLock(lock1, lock2);
            }
        },&lt;/span&gt;&quot;A&quot;&lt;span&gt;); 
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable(){
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                itt.deathLock(lock2, lock1);
            }
        },&lt;/span&gt;&quot;B&quot;&lt;span&gt;); 
        
        t1.start();
        t2.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中断线程t1、t2&lt;/span&gt;
&lt;span&gt;        t1.interrupt();
        t2.interrupt();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其它学习文章参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/greta/p/5624839.html&quot; target=&quot;_blank&quot;&gt;如何正确地停止一个线程？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38663729/article/details/78232648&quot; target=&quot;_blank&quot;&gt;Java线程中断机制-如何中断线程&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Jul 2018 17:17:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9344792.html</dc:identifier>
</item>
<item>
<title>利用padding-top/padding-bottom百分比，进行占位和高度自适应 - daisy,gogogo</title>
<link>http://www.cnblogs.com/daisygogogo/p/9344727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daisygogogo/p/9344727.html</guid>
<description>&lt;p&gt;在css里面，padding-top,padding-bottom,margin-top,margin-bottom取值为百分比的时候，参照的是父元素的宽度。&lt;/p&gt;
&lt;p&gt;比如：父元素宽度是100px, 子元素padding-top:50%，那么padding-top的实际值就是100*50%=50px&lt;/p&gt;
&lt;p&gt;这个小小的知识点，其实有很大的用处，应用也很广泛，就是进行提前占位，避免资源加载时候的闪烁，还可以让高度自适应。&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;一般来说，想要自适应屏幕大小，我们设置元素的宽度自适应是完全没有问题的，比如希望一行显示5个元素，那么我们设置每个元素width:20%就可以了（box-sizing需要为border-box）。&lt;/p&gt;
&lt;p&gt;但是高度就比较尴尬了，因为高度都是被内容撑开的，一般不定，那么通过百分比来设置高度，就变得不是很实用。&lt;/p&gt;
&lt;p&gt;而且，对于图片等资源来说，加载是需要时间的，即便网页加载速度已经很快了，由于高度被图片撑开的过程，不可避免会出现闪烁，这时候我们的padding-top等就发挥大用处啦。&lt;/p&gt;
&lt;p&gt;如下面一段代码，图片的宽高比为1:1.3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item placeholder&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;img&quot;&lt;/span&gt;&lt;span&gt;
            src&lt;/span&gt;&lt;span&gt;=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1532110043386&amp;amp;di=dc7277a3b566e40a9d98d736f1613dd2&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fpic.qqtn.com%2Fup%2F2016-5%2F201605301928431736188.png&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item placeholder&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;img&quot;&lt;/span&gt;&lt;span&gt;
            src&lt;/span&gt;&lt;span&gt;=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1532110043386&amp;amp;di=dc7277a3b566e40a9d98d736f1613dd2&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fpic.qqtn.com%2Fup%2F2016-5%2F201605301928431736188.png&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们设置如下的样式，即可实现每个li的宽高比为1:1.3&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item {
    width: 20%;
}

.placeholder {
    padding-top: 26%;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上这时候，每个li的实际高度并没有受到约束，内容多高（图片）li就多高，想要实现宽高等比？&lt;/p&gt;
&lt;p&gt;我们需要设置图片的定位为绝对定位，并且为.item添加相对定位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item {
    width: 20%;
    position: relative;
}

.placeholder {
    padding-top: 26%;
}

.img {
    position: absolute;
    width: 100%;
    left: 0;
    top: 0;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就实现了我们想要的效果了。&lt;/p&gt;
&lt;p&gt;但是有一个问题，假如我们想要设置max-width的话，在上面样式的基础上，为.item添加max-width 是不起作用的，原因max-width只有在内容撑开高度的时候才起作用，而.item并不是被内容撑开的，为了解决这个问题，还可以使用伪类元素:after，:before，修改之后的样式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item {
    width: 20%;
    position: relative;    
}

.placeholder:after {
    content: '';
    display: block;
    padding-top: 130%; // 这里的比例是相当于自身来说的，由于宽高比是1:1.3，所以这里要设为130%
}

.img {
    position: absolute;
    width: 100%;
    left: 0;
    top: 0;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文就到这里结束，谢谢阅读。&lt;/p&gt;

</description>
<pubDate>Fri, 20 Jul 2018 16:23:00 +0000</pubDate>
<dc:creator>daisy,gogogo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daisygogogo/p/9344727.html</dc:identifier>
</item>
<item>
<title>在Unity项目中隐藏StringConst - Eran</title>
<link>http://www.cnblogs.com/eran/p/9344708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eran/p/9344708.html</guid>
<description>&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/478652/201807/478652-20180721000902488-266541034.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装&lt;code&gt;GlobalConst&lt;/code&gt;上层逻辑直接当做普通String字符串处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/478652/201807/478652-20180721000920524-1490924221.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;目前, 就我所知的Unity反编译. 如果采用静态破解IL2CPP项目 切入点一般都从关键字入手.&lt;/p&gt;
&lt;p&gt;比如搜索 &lt;code&gt;money&lt;/code&gt;,&lt;code&gt;exp&lt;/code&gt;,&lt;code&gt;attack&lt;/code&gt;等等.&lt;/p&gt;
&lt;p&gt;我主要是采用混淆代码的方式应对这种Hack. 但是混淆代码并不能对 &lt;code&gt;const string&lt;/code&gt;进行混淆.&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/478652/201807/478652-20180721000939081-457762281.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我之前的老项目. 可以看到虽然 变量名全部混淆了. 但是其引用的字符串仍旧是明文的. 并且暴露出许多敏感信息.&lt;/p&gt;
&lt;p&gt;所以 目前想出来这种方案.就是为了解决这个问题的.&lt;/p&gt;
&lt;h2 id=&quot;具体实现&quot;&gt;具体实现&lt;/h2&gt;
&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;(编辑阶段)通过GUI进行编辑相关的常量信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;(编辑阶段)生成一个cs文件,和一个加密后的二进制文件.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;(运行阶段)将二进制文件解析为Key-Value字典.其中Key为混淆后的Key,Value为真实Value&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;(运行阶段)用生成的cs文件.对Key-Value字典进行访问.从而得到真实的常量值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;核心代码&quot;&gt;核心代码&lt;/h3&gt;
&lt;p&gt;具体实现,每个人会有自己的不同.这里全贴出来没有什么意义. 只列一些我认为比较核心的代码&lt;/p&gt;
&lt;h4 id=&quot;gui部分&quot;&gt;GUI部分&lt;/h4&gt;
&lt;p&gt;GUI用的是&lt;code&gt;OdinInspector&lt;/code&gt;插件(推荐)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发起弹窗&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[MenuItem(&quot;常量表&quot;)]
private static void OpenStringConstWinodw()
{
    var instance = new GlobalStringEditWindow();
    var window = OdinEditorWindow.InspectObject(instance);
    window.position = GUIHelper.GetEditorWindowRect().AlignCenter(500, 700);
    instance.OnShow(window);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;弹出部分&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class GlobalStringEditWindow
{
  
    private OdinEditorWindow mSelfWindow;
    
    public List&amp;lt;StringConstWrap&amp;gt; stringConstList;

    public void OnShow(OdinEditorWindow _window)
    {
        mSelfWindow = _window;
        
        ...
        ** 此处省略从二进制文件解密出来,然后复写到stringConstList部分代码
        ...
    }


    [Button(&quot;保存并退出&quot;, ButtonSizes.Medium), GUIColor(0, 1, 0)]
    private void SaveAndClose()
    {
        var CSharpFileCreater = new ObfuscatorIDMappingHelper();

        stringConstList.ForEach(warp =&amp;gt;
        {
            var meta = new ObfusKeyValueMeta();
            meta.comment = warp.comment;
            meta.realKey = warp.key;
            meta.value = warp.value;
            meta.classPropertyName = meta.realKey;
            CSharpFileCreater.AddObfuscatorRes(meta);
        });

        //生成CS文件和*.byte文件
        CSharpFileCreater.GenerateFile(&quot;StringConst&quot;);

        Debug.Log(&quot;StringConst 保存成功&quot;);

        mSelfWindow.Close();
    }


    [Serializable]
    public struct StringConstWrap
    {
        [FoldoutGroup(&quot;$Name&quot;, false)]
        public string comment;

        [FoldoutGroup(&quot;$Name&quot;, false)]
        public string key;

        [FoldoutGroup(&quot;$Name&quot;, false)]
        public string value;

        private string Name =&amp;gt; comment ?? &quot;Empty&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;代码生成&quot;&gt;代码生成&lt;/h4&gt;
&lt;p&gt;代码生成部分,就是对应的我&lt;code&gt;CSharpFileCreater&lt;/code&gt;部分的内容.&lt;/p&gt;
&lt;p&gt;如果想使用模板类生成CS代码,可以参考以下几个Link&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.li0rtal.com/code-generation-fun-with-unity/&quot; class=&quot;uri&quot;&gt;http://www.li0rtal.com/code-generation-fun-with-unity/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Mtihc/Generate-Code-For-Unity&quot; class=&quot;uri&quot;&gt;https://github.com/Mtihc/Generate-Code-For-Unity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gamasutra.com/blogs/ByronMayne/20160121/258356/Code_Generation_in_Unity.php&quot; class=&quot;uri&quot;&gt;https://www.gamasutra.com/blogs/ByronMayne/20160121/258356/Code_Generation_in_Unity.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://forum.unity.com/threads/code-generation-with-unity.233661/&quot; class=&quot;uri&quot;&gt;https://forum.unity.com/threads/code-generation-with-unity.233661/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过我需要生成的代码部分很简单,所以反而直接生写会简单一些.&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private string GetFileString(string _className)
{
    var fileString = &quot;&quot;;
    fileString += &quot;namespace Code.AutoGenerate\n&quot;;
    fileString += &quot;{\n&quot;;
    fileString += &quot;    public class &quot; + _className + &quot;\n&quot;;
    fileString += &quot;    {\n&quot;;

    mObfuscatorResList.ForEach(meta =&amp;gt; { fileString += $&quot;        public const string {meta.classPropertyName} = \&quot;{meta.obfusKey}\&quot;;\n&quot;; });

    fileString += &quot;    }\n&quot;;
    fileString += &quot;}\n&quot;;

    return fileString;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将文本直接写入文件,直接用封装好的&lt;code&gt;File.WriteAllText(path, fileString);&lt;/code&gt;方法即可.&lt;/p&gt;
&lt;h4 id=&quot;二进制加密&quot;&gt;二进制加密&lt;/h4&gt;
&lt;p&gt;这部分我是将相应类首先序列化为Json,然后对Json文件进行ASE加密.再以二进制的方式存入本地&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;不要采用Unity内置的Json,或者说 所有需要使用到&lt;code&gt;[Serializable]&lt;/code&gt;标签的序列化方案. 因为设置了这个标签就意味着 变量名 是无法改变的,(应该是反序列化时候都需要反射找到对应的属性?).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量名无法改变 也就是 无法混淆. 那之前做的一切就相当于白费了 :)&lt;/p&gt;
</description>
<pubDate>Fri, 20 Jul 2018 16:11:00 +0000</pubDate>
<dc:creator>Eran</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eran/p/9344708.html</dc:identifier>
</item>
<item>
<title>Css Sprite(雪碧图、精灵图) - dawdler~Bo</title>
<link>http://www.cnblogs.com/dawdler/p/9344672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dawdler/p/9344672.html</guid>
<description>&lt;div class=&quot;article fmt article__content&quot; data-id=&quot;1190000015708982&quot; data-license=&quot;cc&quot; readability=&quot;47&quot;&gt;
&lt;h2 id=&quot;articleHeader0&quot;&gt;一、精灵图使用场景：&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img title=&quot;图片描述&quot; src=&quot;https://segmentfault.com/img/bVbd4Ex?w=927&amp;amp;h=389&quot; alt=&quot;图片描述&quot; data-src=&quot;/img/bVbd4Ex?w=927&amp;amp;h=389&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;articleHeader1&quot;&gt;二、Css Sprite（优点）&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;减少图片的字节。&lt;/li&gt;
&lt;li&gt;减少网页的http请求，从而大大的提高页面的性能。&lt;/li&gt;
&lt;li&gt;解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。&lt;/li&gt;
&lt;li&gt;更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;articleHeader2&quot;&gt;三、实现原理&lt;/h2&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;&lt;strong&gt;&lt;em&gt;css background-position&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;控制一个层可显示的区域范围大小，&lt;br/&gt;通过一个窗口进行背景图的滑动&lt;br/&gt;实例：&lt;br/&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img title=&quot;图片描述&quot; src=&quot;https://segmentfault.com/img/bVbd4It?w=414&amp;amp;h=161&quot; alt=&quot;图片描述&quot; data-src=&quot;/img/bVbd4It?w=414&amp;amp;h=161&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;hljs arduino&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;/&amp;gt;
        &amp;lt;title&amp;gt;&lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position&amp;lt;&amp;lt;/title&amp;gt;
        &amp;lt;link rel=&lt;span class=&quot;hljs-string&quot;&gt;&quot;stylesheet&quot; href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;index.css&quot;/&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;span &lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;oo span1&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span &lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;oo span2&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span &lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;oo span3&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span &lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;pp span4&quot;&amp;gt;&amp;lt;/span&amp;gt;
        &amp;lt;span &lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ll span5&quot;&amp;gt;&amp;lt;/span&amp;gt; 
        &amp;lt;span &lt;span class=&quot;hljs-keyword&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hh span6&quot;&amp;gt;&amp;lt;/span&amp;gt; 
        
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
.body{
    margin:&lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-keyword&quot;&gt;auto;
    &lt;span class=&quot;hljs-built_in&quot;&gt;text-align:center;
}
.oo{
    &lt;span class=&quot;hljs-built_in&quot;&gt;display:block;
    &lt;span class=&quot;hljs-built_in&quot;&gt;width:&lt;span class=&quot;hljs-number&quot;&gt;43px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;height:&lt;span class=&quot;hljs-number&quot;&gt;44px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;background:url(images/img_navsprites_hover.gif) no-repeat;
    margin:&lt;span class=&quot;hljs-number&quot;&gt;20px &lt;span class=&quot;hljs-keyword&quot;&gt;auto;
}
.span1{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;0;
    &lt;span class=&quot;hljs-built_in&quot;&gt;position:absolute;
    top:&lt;span class=&quot;hljs-number&quot;&gt;0px;
}
.span2{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;-47px &lt;span class=&quot;hljs-number&quot;&gt;0;
    &lt;span class=&quot;hljs-built_in&quot;&gt;position:absolute;
    top:&lt;span class=&quot;hljs-number&quot;&gt;0px;
    left:&lt;span class=&quot;hljs-number&quot;&gt;60px;
}
.span3{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;-94px &lt;span class=&quot;hljs-number&quot;&gt;0;
    &lt;span class=&quot;hljs-built_in&quot;&gt;position:absolute;
    top:&lt;span class=&quot;hljs-number&quot;&gt;0px;
    left:&lt;span class=&quot;hljs-number&quot;&gt;120px;
}
.span1:hover{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;-45px;
}
.span2:hover{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;-47px &lt;span class=&quot;hljs-number&quot;&gt;-45px;
}
.span3:hover{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;-94px &lt;span class=&quot;hljs-number&quot;&gt;-45px;
}
.pp{
    &lt;span class=&quot;hljs-built_in&quot;&gt;display:block;
    &lt;span class=&quot;hljs-built_in&quot;&gt;width:&lt;span class=&quot;hljs-number&quot;&gt;38px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;height:&lt;span class=&quot;hljs-number&quot;&gt;38px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;background:url(images/pwd-icons-&lt;span class=&quot;hljs-keyword&quot;&gt;new.png) no-repeat;
    margin:&lt;span class=&quot;hljs-number&quot;&gt;20px &lt;span class=&quot;hljs-keyword&quot;&gt;auto;
}
.span4{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;-48px &lt;span class=&quot;hljs-number&quot;&gt;-96px;
}
.ll{
    &lt;span class=&quot;hljs-built_in&quot;&gt;display:block;
    &lt;span class=&quot;hljs-built_in&quot;&gt;width:&lt;span class=&quot;hljs-number&quot;&gt;24px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;height:&lt;span class=&quot;hljs-number&quot;&gt;26px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;background:url(images/TB1eiXTXlTH8KJjy0FiXXcRsXXa&lt;span class=&quot;hljs-number&quot;&gt;-24&lt;span class=&quot;hljs-number&quot;&gt;-595.png) no-repeat;
    margin:&lt;span class=&quot;hljs-number&quot;&gt;20px &lt;span class=&quot;hljs-keyword&quot;&gt;auto;
}
.span5{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;0 &lt;span class=&quot;hljs-number&quot;&gt;-483px;
}
.hh{
    &lt;span class=&quot;hljs-built_in&quot;&gt;display:block;
    &lt;span class=&quot;hljs-built_in&quot;&gt;width:&lt;span class=&quot;hljs-number&quot;&gt;18px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;height:&lt;span class=&quot;hljs-number&quot;&gt;18px;
    &lt;span class=&quot;hljs-built_in&quot;&gt;background:url(images/toolbars.png) no-repeat;
    margin:&lt;span class=&quot;hljs-number&quot;&gt;20px &lt;span class=&quot;hljs-keyword&quot;&gt;auto;
}
.span6{
    &lt;span class=&quot;hljs-built_in&quot;&gt;background-&lt;span class=&quot;hljs-built_in&quot;&gt;position:&lt;span class=&quot;hljs-number&quot;&gt;-95px &lt;span class=&quot;hljs-number&quot;&gt;-211px;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;*&lt;/em&gt;*background-position:npx npx;&lt;br/&gt;（第一个值是调左右的，当你需要将背景图向右调的时候用正值， 向左则为负值 同理将背景图上下调动的时候上是用负值，下是正值）&lt;em&gt;*&lt;/em&gt;*&lt;br/&gt;&amp;lt;2&amp;gt;效果图如下：&lt;br/&gt;（这是原图）&lt;span class=&quot;img-wrap&quot;&gt;&lt;img title=&quot;图片描述&quot; src=&quot;https://segmentfault.com/img/bVbd4Lx?w=616&amp;amp;h=160&quot; alt=&quot;图片描述&quot; data-src=&quot;/img/bVbd4Lx?w=616&amp;amp;h=160&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（这是选完以后的图）&lt;br/&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img title=&quot;图片描述&quot; src=&quot;https://segmentfault.com/img/bVbd4LI?w=816&amp;amp;h=170&quot; alt=&quot;图片描述&quot; data-src=&quot;/img/bVbd4LI?w=816&amp;amp;h=170&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一幅图是原图与暗图的转换；选了第二幅图的锁；第四幅图的火车；第五幅图的小人。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader4&quot;&gt;刚入前端写的不好见谅！！！(^o^)/~&lt;/h3&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 20 Jul 2018 15:53:00 +0000</pubDate>
<dc:creator>dawdler~Bo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dawdler/p/9344672.html</dc:identifier>
</item>
<item>
<title>docker-compose 使用 - 谭普利特</title>
<link>http://www.cnblogs.com/Template/p/9344656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Template/p/9344656.html</guid>
<description>&lt;p&gt;Docker提供一个容器编排工具------》Docker Compose，它允许用户在一个模板（YAML格式）中定义一组相关联的应用容器，这组容器会根据配置模板中的&quot;--link&quot;等参数&lt;/p&gt;
&lt;p&gt;对启动的优先级自动排序，简单执行一条&quot;docker-compose up&quot;,就可以把同一个服务中的多个容器一次创建和启动。&lt;/p&gt;
&lt;p&gt;安装docker-compose：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -L https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/docker/compose/release/download/1.6.0/docker-compose-`uname -s`-`uname -r` &amp;gt; /usr/local/bin/docker-compose&lt;p&gt;chmod +x &lt;/p&gt;&lt;/span&gt;/usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用Docker Compose管理多个容器，首先需要把容器写到它的配置文件中，默认配置文件名为docker-compose.yml，我们可以通过“-f”选项指定配置文件。&lt;/p&gt;
&lt;p&gt;下面通过安装redmine来说明&lt;/p&gt;
&lt;p&gt;将docker run创建容器的指令改造为Docker Compose的配置文件&lt;/p&gt;
&lt;p&gt;postgresql容器创建和启动的命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# docker run --name postgresql-redmine -&lt;span&gt;d \
&lt;/span&gt;&amp;gt; --&lt;span&gt;env&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB_NAME=redmine_production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&amp;gt; --&lt;span&gt;env&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB_USER=redmine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&amp;gt; --&lt;span&gt;env&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB_PASS=password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&amp;gt; sameersbn/postgresql:&lt;span&gt;9.4&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它使用sameersbn/postgresql:9.4-12镜像创建了一个名字为postgresql-redmine的容器，并配置了三个环境变量。转换为Docker Compose配置文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;postgresql:
  image: sameersbn&lt;/span&gt;/postgresql:&lt;span&gt;9.4&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
  environment:
    &lt;/span&gt;- DB_NAME=&lt;span&gt;readmine_production
    &lt;/span&gt;- DB_USER=&lt;span&gt;redmine
    &lt;/span&gt;- DB_PASS=password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;redmine容器创建和启动的命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run --name redmine -d --link postgresql-redmine:postgresql --publish &lt;span&gt;10083&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; --&lt;span&gt;env&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;REDMINE_PORT=10083&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; sameersbn/redmine:&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它使用 sameersbn/redmine:3.2.0-4镜像创建了一个名字为redmine的容器，转换为Docker Compose配置文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;redmine:
  image: sameersbn&lt;/span&gt;/redmine:&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
  links:
    &lt;/span&gt;-&lt;span&gt; postgresql:postgresql
  ports:
    &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10083:80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  environment:
    &lt;/span&gt;- REDMINE_PORT=&lt;span&gt;10083&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建配置文件~/redmine/docker-compose.yml,合并内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;postgresql:
  image: sameersbn&lt;/span&gt;/postgresql:&lt;span&gt;9.4&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
  environment:
    &lt;/span&gt;- DB_NAME=&lt;span&gt;readmine_production
    &lt;/span&gt;- DB_USER=&lt;span&gt;redmine
    &lt;/span&gt;- DB_PASS=&lt;span&gt;password
        
redmine:
  image: sameersbn&lt;/span&gt;/redmine:&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
  links:
    &lt;/span&gt;-&lt;span&gt; postgresql:postgresql
  ports:
    &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10083:80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  environment:
    &lt;/span&gt;- REDMINE_PORT=&lt;span&gt;10083&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行新容器组的创建和启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，通过http://ip10083就可以访问网站。&lt;/p&gt;
&lt;p&gt;后续启动和停止就变得非常简单了：&lt;/p&gt;
&lt;p&gt;停止命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker-compose start
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 20 Jul 2018 15:45:00 +0000</pubDate>
<dc:creator>谭普利特</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Template/p/9344656.html</dc:identifier>
</item>
<item>
<title>用JAVA基础知识制作简易《订单系统》(适用于初学者学习) - 景小生</title>
<link>http://www.cnblogs.com/c0110/p/9344636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c0110/p/9344636.html</guid>
<description>&lt;p&gt;import java.util.Scanner;&lt;br/&gt;public class OrderingMsg {&lt;br/&gt;    public static void main(String[] args) throws Exception {&lt;br/&gt;    Scanner scanner = new Scanner(System.in);&lt;br/&gt;        String[] names = new String[6]; // 订餐人姓名&lt;br/&gt;        String[] dishMsgs = new String[6];// 选择菜品&lt;br/&gt;        int[] numbers = new int[6];// 菜品份数&lt;br/&gt;        int[] times = new int[6]; // 送餐时间&lt;br/&gt;        String[] addresses = new String[6];// 送餐地址&lt;br/&gt;        int[] states = new int[6];// 订单状态 0:已经预定 1：已经完成&lt;br/&gt;        double[] sumPrices = new double[6];// 总金额&lt;br/&gt;        int[] praiseNums = new int[6];&lt;br/&gt;        String[] dishNames = { &quot;北京烤鸭&quot;, &quot;麻婆豆腐&quot;, &quot;松鼠鱼&quot;, &quot;红烧带鱼&quot;, &quot;时令蔬菜&quot;, &quot;辣土豆丝&quot; };&lt;br/&gt;        double[] prices = { 88, 24, 38, 35, 15, 12 };&lt;br/&gt;        System.out.println(&quot;欢迎进入surper订餐系统&quot;);&lt;br/&gt;        int num = -1; // 输入0 默认返回主菜单&lt;br/&gt;        boolean isExit = false;// 默认不退出&lt;br/&gt;        do {&lt;br/&gt;        System.out.println(&quot;**********************&quot;);&lt;br/&gt;            System.out.println(&quot;1:我要订餐&quot;);&lt;br/&gt;            System.out.println(&quot;2:查看餐袋&quot;);&lt;br/&gt;            System.out.println(&quot;3:签收订单&quot;);&lt;br/&gt;            System.out.println(&quot;4:删除订单&quot;);&lt;br/&gt;            System.out.println(&quot;5:我要点赞&quot;);&lt;br/&gt;            System.out.println(&quot;6:退出系统&quot;);&lt;br/&gt;            System.out.println(&quot;**********************&quot;);&lt;br/&gt;            System.out.println(&quot;请选择：&quot;);&lt;br/&gt;            int choice = scanner.nextInt(); //选择你所需要的服务&lt;br/&gt;            switch (choice) {&lt;br/&gt;            case 1:&lt;br/&gt;                System.out.println(&quot;************我要订餐************&quot;);&lt;br/&gt;                boolean empty = false;//作一个标记&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) { // 订餐人的集合&lt;br/&gt;                    if (names[i] == null) {&lt;br/&gt;                        empty = true;//订单如果是空的，便可以往里加数据&lt;br/&gt;                        System.out.println(&quot;请输入订餐人的姓名：&quot;);&lt;br/&gt;                        names[i] = scanner.next(); // 获取订餐人的姓名&lt;br/&gt;                        System.out.println(&quot;您可以选择下列的菜品：&quot;);&lt;br/&gt;                        System.out.println(&quot;序号\t\t\t菜名\t\t\t单价\t\t\t点赞数&quot;);&lt;br/&gt;                        for (int j = 0; j &amp;lt; dishNames.length; j++) { // 遍历菜品&lt;br/&gt;                            String praiseNum = (praiseNums[j] &amp;gt; 0) ? praiseNums[j]&lt;br/&gt;                                    + &quot;个赞&quot;&lt;br/&gt;                                    : &quot;&quot;;&lt;br/&gt;                            System.out.println(j + 1 + &quot;\t\t\t&quot; + dishNames[j]&lt;br/&gt;                                    + &quot;\t\t\t&quot; + prices[j] + &quot;\t\t\t&quot;&lt;br/&gt;                                    + praiseNum);&lt;br/&gt;                        }&lt;br/&gt;                        // 用户开始点菜，并收集信息&lt;br/&gt;                        System.out.println(&quot;请您选择菜品的编号：&quot;);&lt;br/&gt;                        int choiceName = scanner.nextInt();&lt;br/&gt;                        System.out.println(&quot;请您输入点餐的份数：&quot;);&lt;br/&gt;                        int number = scanner.nextInt();&lt;br/&gt;                        System.out.println(&quot;请您输入送餐的地址：&quot;);&lt;br/&gt;                        String address = scanner.next();&lt;br/&gt;                        System.out.println(&quot;请您输入送餐的时间：&quot;);&lt;br/&gt;                        System.out.println(&quot;本店整点送餐：8点至20点&quot;);&lt;br/&gt;                        int time = scanner.nextInt();&lt;br/&gt;                        double sumPrice = prices[choiceName - 1] * number;&lt;br/&gt;                        double price = (sumPrice &amp;gt;=50) ? 0 : 5;//判断是否收取运费&lt;br/&gt;                        System.out.println(&quot;订单已生成！&quot;);&lt;br/&gt;                        System.out.println(&quot;您定的菜品是：&quot;+ dishNames[choiceName - 1] + &quot;\t&quot; + number+ &quot;份&quot;);&lt;br/&gt;                        System.out.print(&quot;餐费：&quot; + sumPrice);&lt;br/&gt;                        System.out.print(&quot;\t送餐费：&quot; + price);&lt;br/&gt;                        System.out.println(&quot;\t总费用：&quot; + (price + sumPrice));&lt;br/&gt;                        // 把输入的信息塞进数组中&lt;br/&gt;                        times[i] = time; // 时间&lt;br/&gt;                        addresses[i] = address; // 地址&lt;br/&gt;                        sumPrices[i] = (sumPrice + price); // 总金额&lt;br/&gt;                        dishMsgs[i] = dishNames[choiceName - 1]; // 定的菜品&lt;br/&gt;                        states[i] = 0; // 订餐的状态&lt;br/&gt;                        numbers[i] = number; // 份数&lt;br/&gt;                        break;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (!empty) {// 餐袋已经满了&lt;br/&gt;                    System.out.println(&quot;餐袋已经满了&quot;);&lt;br/&gt;                }&lt;br/&gt;                break;&lt;br/&gt;            case 2:&lt;br/&gt;                System.out.println(&quot;************查看餐袋************&quot;);&lt;br/&gt;                System.out.println(&quot;编号\t\t订餐人\t\t菜品(份数)\t\t送餐时间 \t\t送餐地址\t\t总金额\t\t状态\t\t点赞数量&quot;);&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) {&lt;br/&gt;                    if (names[i] != null) { // 有人订餐 的显示&lt;br/&gt;                        String state = (states[i] == 0) ? &quot;已经预定&quot; : &quot;已经完成&quot;; // 获取状态&lt;br/&gt;                        int time = times[i]; // 时间&lt;br/&gt;                        String sumPrice = sumPrices[i] + &quot;元&quot;; // 总金额&lt;br/&gt;                        String address = addresses[i]; // 地址&lt;br/&gt;                        String dishMsg = dishMsgs[i]; // 菜品&lt;br/&gt;                        int count = numbers[i];//份数&lt;br/&gt;                        System.out.println((i + 1) + &quot;\t\t&quot; + names[i] + &quot;\t\t&quot;+ dishMsg + &quot;(&quot; + count + &quot;)&quot; + &quot;\t\t&quot; + time+ &quot; \t\t&quot; + address + &quot;\t\t&quot; + sumPrice+ &quot;\t\t&quot; + state + &quot;\t\t&quot; + praiseNums[i]);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                break;&lt;br/&gt;            case 3:&lt;br/&gt;                System.out.println(&quot;************签收订单************&quot;);&lt;br/&gt;                System.out.println(&quot;请您输入需要签收的订单编号：&quot;);&lt;br/&gt;                int sign = scanner.nextInt(); &lt;br/&gt;                int flag = 0;// 作一个标记，来判断订单是否被签收&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) {&lt;br/&gt;                    if (names[i] != null &amp;amp;&amp;amp; states[i] == 0) {//有订单并且可以签收&lt;br/&gt;                        states[i] = 1;// 改变状态&lt;br/&gt;                        flag = 1;&lt;br/&gt;                        break; &lt;br/&gt;                    } else if (names[i] != null &amp;amp;&amp;amp; states[i] == 1) {//有订单，并且已被签收&lt;br/&gt;                        flag = 2;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (flag == 1) {&lt;br/&gt;                    System.out.println(&quot;订单已经签收！&quot;);&lt;br/&gt;                } else if (flag == 2) {&lt;br/&gt;                    System.out.println(&quot;订单不能重复签收！&quot;);&lt;br/&gt;                } else {&lt;br/&gt;                    System.out.println(&quot;没有找到您的订单！请您核对编号！&quot;);&lt;br/&gt;                }&lt;/p&gt;&lt;p&gt;                break;&lt;br/&gt;            case 4:&lt;br/&gt;                System.out.println(&quot;************删除订单************&quot;);&lt;br/&gt;                System.out.println(&quot;请您输入需要删除的订单编号：&quot;);&lt;br/&gt;                int dealNum = scanner.nextInt();&lt;br/&gt;                int deal = 0; // 作一个标记 来判断订单是否被签收以及是否存在&lt;br/&gt;                for (int i = 0; i &amp;lt; names.length; i++) {&lt;br/&gt;                    if (names[i] != null &amp;amp;&amp;amp; states[dealNum - 1] == 1) { //有订单，并且已签收，可以删除                            &lt;br/&gt;                        // 删除一条信息，将之后的所有信息，依次向前移&lt;br/&gt;                        for (int j = dealNum - 1; j &amp;lt; names.length - 1; j++) {&lt;br/&gt;                            names[j] = names[j + 1]; // 订餐人&lt;br/&gt;                            dishMsgs[j] = dishMsgs[j + 1];// 菜品&lt;br/&gt;                            times[j] = times[j + 1];// 时间&lt;br/&gt;                            addresses[j] = addresses[j + 1];// 地址&lt;br/&gt;                            states[j] = states[j + 1];// 状态&lt;br/&gt;                            numbers[j] = numbers[j + 1];// 份数&lt;br/&gt;                        }&lt;br/&gt;                        deal = 1;&lt;br/&gt;                        break;&lt;br/&gt;                    } else if (names[i] != null &amp;amp;&amp;amp; states[i] == 0) { // 右订单并且订单还没有签收，便不能删除&lt;br/&gt;                        deal = 2;&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                if (deal == 1) {&lt;br/&gt;                    System.out.println(&quot;订单已经被删除&quot;);&lt;br/&gt;                } else if (deal == 2) {&lt;br/&gt;                    System.out.println(&quot;订单还没有签收 不允许删除！&quot;);&lt;br/&gt;                } else {&lt;br/&gt;                    System.out.println(&quot;没有找到指定的订单！&quot;);&lt;br/&gt;                }&lt;br/&gt;                break;&lt;br/&gt;            case 5:&lt;br/&gt;                System.out.println(&quot;************我要点赞***************&quot;);&lt;br/&gt;                System.out.println(&quot;编号\t\t\t菜名\t\t\t价格&quot;);&lt;br/&gt;                for (int i = 0; i &amp;lt; dishNames.length; i++) { // 遍历所有的菜名&lt;br/&gt;                    String price = prices[i] + &quot;元&quot;; //价格&lt;br/&gt;                    String name = dishNames[i];//菜名&lt;br/&gt;                    System.out.println((i + 1) + &quot;\t\t\t&quot; + name + &quot;\t\t\t&quot;+ price);&lt;br/&gt;                }&lt;br/&gt;                System.out.println(&quot;请您输入点赞的菜品编号：&quot;);&lt;br/&gt;                int choiceNum = scanner.nextInt();&lt;br/&gt;                praiseNums[choiceNum - 1]++;// 点赞数累加&lt;br/&gt;                System.out.println(&quot;谢谢参与！点赞成功！&quot;);&lt;br/&gt;                break;&lt;br/&gt;            case 6:&lt;br/&gt;               // 退出系统&lt;br/&gt;                isExit = true;&lt;br/&gt;                break;&lt;br/&gt;            default:&lt;br/&gt;                // 退出系统&lt;br/&gt;                isExit = true;&lt;br/&gt;                break;&lt;br/&gt;            }&lt;br/&gt;            if (!isExit) { // 默认这是不退出&lt;br/&gt;                System.out.println(&quot;输入0返回主菜单！&quot;);&lt;br/&gt;                num = scanner.nextInt();&lt;br/&gt;            } else {&lt;br/&gt;                break; // 退出系统&lt;br/&gt;            }&lt;br/&gt;        } while (num == 0);&lt;br/&gt;        System.out.println(&quot;谢谢您的光临！！！！！&quot;);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Fri, 20 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>景小生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c0110/p/9344636.html</dc:identifier>
</item>
<item>
<title>JHipster生成微服务架构的应用栈（二）- 认证微服务示例 - 羽客</title>
<link>http://www.cnblogs.com/yorkwu/p/9330665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yorkwu/p/9330665.html</guid>
<description>&lt;blockquote readability=&quot;7.6942675159236&quot;&gt;
&lt;p&gt;本系列文章演示如何用JHipster生成一个微服务架构风格的应用栈。&lt;br/&gt;环境需求：安装好JHipster开发环境的CentOS 7.4（&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9274474.html&quot; target=&quot;_blank&quot;&gt;参考这里&lt;/a&gt;&lt;/em&gt;）&lt;br/&gt;应用栈名称：appstack&lt;br/&gt;认证微服务： uaa&lt;br/&gt;业务微服务：microservice1&lt;br/&gt;网关微服务：gateway&lt;br/&gt;实体名：role&lt;br/&gt;主机IP：192.168.220.120&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为业务微服务和网关微服务都会依赖uaa，所以首先生成uaa的工程代码。&lt;br/&gt;进入appstack/uaa目录，输入命令后回车：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd appstack/uaa/
$ jhipster&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令行输出jhipster启动信息&quot;&gt;命令行输出JHipster启动信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719165253645-1258004804.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;现在开始问答环节&quot;&gt;现在开始问答环节&lt;/h3&gt;
&lt;h5 id=&quot;which-type-of-application-would-you-like-to-create&quot;&gt;1.1 Which &lt;em&gt;type&lt;/em&gt; of application would you like to create?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择生成的微服务类型&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有4个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;这里选择&lt;code&gt;JHipster UAA server&lt;/code&gt;，这是一种基于OAuth认证机制的微服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180718200454604-708173420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;what-is-the-base-name-of-your-application&quot;&gt;1.2 What is the base name of your application?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;输入微服务的名称&lt;/strong&gt;&lt;br/&gt;默认名称是当前目录名&lt;code&gt;uaa&lt;/code&gt;，也可以自己输入名称。&lt;br/&gt;&lt;em&gt;注意：名称只能是大小写字母，数字和下划线的任意组合，不允许任何其它字符。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180718200856122-1167005900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;as-you-are-running-in-a-microservice-architecture-on-which-port-would-like-your-server-to-run-it-should-be-unique-to-avoid-port-conflicts.&quot;&gt;1.3 As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;输入微服务的端口号&lt;/strong&gt;&lt;br/&gt;默认端口号是&lt;code&gt;9999&lt;/code&gt;，也可以自己输入端口号，注意不要和别的微服务和进程的端口号冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180718201334227-1070904463.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;what-is-your-default-java-package-name&quot;&gt;1.4 What is your default Java package name?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;输入微服务的java包名&lt;/strong&gt;&lt;br/&gt;根据整个应用栈的目录层级，这里输入包名&lt;code&gt;com.mycompany.appstack&lt;/code&gt;。&lt;br/&gt;&lt;em&gt;注意：包名要符合Java标准规范的要求。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719111844856-857529919.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-service-discovery-server-do-you-want-to-use&quot;&gt;1.5 Which service discovery server do you want to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择一个服务发现组件&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有3个选项，使用上下键切换选项。&lt;br/&gt;根据&lt;strong&gt;微服务体系规划&lt;/strong&gt;，这里选择&lt;code&gt;JHipster Registry&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719111851884-1775725355.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-type-of-database-would-you-like-to-use&quot;&gt;1.6 Which &lt;em&gt;type&lt;/em&gt; of database would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择使用的数据库类型&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有4个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;可以看到支持的数据库类型很多，这里选择默认选项&lt;code&gt;SQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135206569-1491705716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-production-database-would-you-like-to-use&quot;&gt;1.7 Which &lt;em&gt;production&lt;/em&gt; database would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择生产环境中使用的数据库&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有5个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;可以看到目前支持5种SQL数据库，这里选择默认选项&lt;code&gt;MySQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135317048-1291307331.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-development-database-would-you-like-to-use&quot;&gt;1.8 Which &lt;em&gt;development&lt;/em&gt; database would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择开发环境中使用的数据库&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有3个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;H2调试起来简单，但为了和生产环境保持一致性，这里选择&lt;code&gt;MySQL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135427770-156826966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;do-you-want-to-use-the-spring-cache-abstraction&quot;&gt;1.9 Do you want to use the Spring cache abstraction?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;是否需要使用Spring Cache？&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有5个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;根据实际场景需要，可以选择不同缓存组件；这里简单起见，选择&lt;code&gt;No - Warning, when using an SQL database, this will disable the Hibernate 2nd level cache!&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719135734841-771228636.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;would-you-like-to-use-maven-or-gradle-for-building-the-backend&quot;&gt;1.10 Would you like to use Maven or Gradle for building the backend?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择使用Maven还是Gradle来构建微服务&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有2个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;根据自己的开发环境需要，选择相应的构建工具，这里选择默认选项&lt;code&gt;Maven&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140015608-1671063969.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;which-other-technologies-would-you-like-to-use&quot;&gt;1.11 Which other technologies would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择需要用到的技术组件&lt;/strong&gt;&lt;br/&gt;这是一个多选题，有4个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项，使用&lt;strong&gt;空格键&lt;/strong&gt;选中选项，使用&lt;strong&gt;a键&lt;/strong&gt;全选，使用&lt;strong&gt;i键&lt;/strong&gt;取消全选。&lt;br/&gt;根据自己的技术架构规划，选择相应的技术组件，也可以都不选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140116937-1174196637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;would-you-like-to-enable-internationalization-support&quot;&gt;1.12 Would you like to enable internationalization support?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;是否需要国际化支持？&lt;/strong&gt;&lt;br/&gt;默认选择是&lt;code&gt;Y&lt;/code&gt;，如果不需要，输入&lt;code&gt;n&lt;/code&gt;；这里选择默认选项&lt;code&gt;Y&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140231984-767920127.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;please-choose-the-native-language-of-the-application&quot;&gt;1.13 Please choose the native language of the application&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择国际化支持中的母语&lt;/strong&gt;&lt;br/&gt;这是一个单选题，有37个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项。&lt;br/&gt;&lt;em&gt;注意：这个问题和上一个问题(1.12)的选择有关联性，上一个问题如果选择&lt;code&gt;n&lt;/code&gt;，这个问题不会出现。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140404496-1180916656.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;please-choose-additional-languages-to-install&quot;&gt;1.14 Please choose additional languages to install&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择国际化支持中的其它语言&lt;/strong&gt;&lt;br/&gt;这是一个多选题，有37个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项，使用&lt;strong&gt;空格键&lt;/strong&gt;选中选项，使用&lt;strong&gt;a键&lt;/strong&gt;全选，使用&lt;strong&gt;i键&lt;/strong&gt;取消全选。&lt;br/&gt;根据自己的业务规划，选择相应的语言，也可以都不选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140508179-1398577723.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;besides-junit-and-jest-which-testing-frameworks-would-you-like-to-use&quot;&gt;1.15 Besides JUnit and Jest, which testing frameworks would you like to use?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;选择单元测试工具&lt;/strong&gt;&lt;br/&gt;这是一个多选题，有2个选项，使用&lt;strong&gt;上下键&lt;/strong&gt;切换选项，使用&lt;strong&gt;空格键&lt;/strong&gt;选中选项，使用&lt;strong&gt;a键&lt;/strong&gt;全选，使用&lt;strong&gt;i键&lt;/strong&gt;取消全选。&lt;br/&gt;根据自己的技术架构规划，选择相应的技术组件，也可以都不选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719140658447-1026914630.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h5 id=&quot;would-you-like-to-install-other-generators-from-the-jhipster-marketplace&quot;&gt;1.16 Would you like to install other generators from the JHipster Marketplace?&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;是否需要从JHipster市场中安装其它的开发工具？&lt;/strong&gt;&lt;br/&gt;默认选择是&lt;code&gt;N&lt;/code&gt;，如果需要启用，输入&lt;code&gt;y&lt;/code&gt;；这里选择默认选项&lt;code&gt;N&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719141910080-469950730.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击回车继续。&lt;/p&gt;
&lt;h3 id=&quot;问答结束开始生成工程代码&quot;&gt;问答结束，开始生成工程代码&lt;/h3&gt;
&lt;p&gt;这个过程，根据电脑性能和网速的不同，通常需要1-3分钟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719144015832-1062939446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，生成认证微服务工程代码成功完成。可以在appstack/uaa目录下查看所有生成的文件。&lt;/p&gt;

&lt;h3 id=&quot;启动一个数据库容器&quot;&gt;2.1 启动一个数据库容器&lt;/h3&gt;
&lt;p&gt;在命令行，任意目录下，启动一个mysql容器；如果本地没有mysql:5.7.13的镜像，容器启动时会自动去docker store下载镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker container run --name uaa-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d -p 32900:3306 mysql:5.7.13&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在数据库中创建schema&quot;&gt;2.2 在数据库中创建schema&lt;/h3&gt;
&lt;p&gt;通过客户端连接上刚启动的数据库容器，添加一个名为&lt;code&gt;uaa&lt;/code&gt;的schema。微服务启动时会自动在这个schema里面创建数据表。&lt;/p&gt;
&lt;h3 id=&quot;修改微服务的数据库配置&quot;&gt;2.3 修改微服务的数据库配置&lt;/h3&gt;
&lt;p&gt;spring.datasource.url中的端口号&lt;code&gt;32900&lt;/code&gt;，与步骤2.1中&lt;strong&gt;-p&lt;/strong&gt;参数指定的值保持一致。&lt;br/&gt;spring.datasource.url中的schema名称&lt;code&gt;uaa&lt;/code&gt;，与步骤2.2中添加的schema名称保持一致。&lt;br/&gt;spring.datasource.password的值&lt;code&gt;my-secret-pw&lt;/code&gt;，与步骤2.1中&lt;code&gt;MYSQL_ROOT_PASSWORD&lt;/code&gt;参数指定的值保持一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd uaa/
$ vi src/main/resources/config/application-dev.yml
# 修改数据库连接相关配置
spring:
    datasource:
        url: jdbc:mysql://localhost:32900/uaa?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false
        username: root
        password: my-secret-pw&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;构建&quot;&gt;3.1 构建&lt;/h3&gt;
&lt;p&gt;进入uaa目录，输入命令后回车：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ cd uaa/
$ mvn -Pdev package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一切正常，命令行会输出构建成功信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719144036321-1699610122.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动&quot;&gt;3.2 启动&lt;/h3&gt;
&lt;p&gt;进入uaa目录，输入命令后回车：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup ./target/uaa-0.0.1-SNAPSHOT.war &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;strong&gt;tail&lt;/strong&gt;命令，查看启动日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tail -f nohup.out&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一切正常，日志会输出启动成功信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719145129249-1508462915.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注册到jhipster-registry&quot;&gt;3.3 注册到JHipster Registry&lt;/h3&gt;
&lt;p&gt;启动完成后，可以通过浏览器访问&lt;code&gt;http://192.168.220.120:8761&lt;/code&gt;，登录名和密码默认都是&lt;code&gt;admin&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1428428/201807/1428428-20180719145656560-834218114.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在&lt;strong&gt;Instances Registered&lt;/strong&gt;区域，uaa已经注册。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9335968.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（一）- 准备工作&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;JHipster生成微服务架构的应用栈（二）- 认证微服务示例&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9335937.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（三）- 业务微服务示例&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9336241.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（四）- 网关微服务示例&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/yorkwu/p/9336251.html&quot; target=&quot;_blank&quot;&gt;JHipster生成微服务架构的应用栈（五）- 容器编排示例&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Jul 2018 15:28:00 +0000</pubDate>
<dc:creator>羽客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yorkwu/p/9330665.html</dc:identifier>
</item>
<item>
<title>Reactor模式理解 - wangyunfeifeifei</title>
<link>http://www.cnblogs.com/swust-wangyf/p/9344595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swust-wangyf/p/9344595.html</guid>
<description>&lt;p&gt;也可以叫反应器模式或者应答者模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;reactor模式简介&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们先了解一下阻塞I/O与非阻塞I/O&lt;/p&gt;
&lt;h3 id=&quot;io-是非常缓慢的&quot;&gt;I/O 是非常缓慢的&lt;/h3&gt;
&lt;p&gt;I/O绝对是计算机操作中最慢的。访问RAM的事件为ns级别，而访问磁盘或网络上的数据是ms级别的。&lt;/p&gt;
&lt;h3 id=&quot;阻塞io与非阻塞io&quot;&gt;阻塞I/O与非阻塞I/O&lt;/h3&gt;
&lt;p&gt;阻塞I/O的意思是，一个I/O相关的请求发送过来，相对应的函数调用，将阻塞的线程执行，直到操作完成&lt;br/&gt;非阻塞I/O的意思是，一个I/O请求，系统收到后立即返回,然后系统会主动有一个轮询，当I/O请求完毕时，开始执行I/O相关的函数调用。&lt;br/&gt;接下来我用一个经典的例子来描述这两种I/O的区别&lt;/p&gt;
&lt;p&gt;以一个餐饮为例，每一个人来就餐就是一个事件，他会先看一下菜单，然后点餐。就像一个网站会有很多的请求，要求服务器做一些事情。处理这些就餐事件的就需要我们的服务人员了。&lt;/p&gt;
&lt;p&gt;在多线程处理的方式会是这样的：&lt;/p&gt;
&lt;p&gt;一个人来就餐，一个服务员去服务，然后客人会看菜单，点菜。 服务员将菜单给后厨。&lt;/p&gt;
&lt;p&gt;二个人来就餐，二个服务员去服务……&lt;/p&gt;
&lt;p&gt;五个人来就餐，五个服务员去服务……&lt;/p&gt;
&lt;p&gt;这个就是多线程的处理方式，一个事件到来，就会有一个线程服务。很显然这种方式在人少的情况下会有很好的用户体验，每个客人都感觉自己是VIP，专人服务的。如果餐厅一直这样同一时间最多来5个客人，这家餐厅是可以很好的服务下去的。&lt;/p&gt;
&lt;p&gt;来了一个好消息，因为这家店的服务好，吃饭的人多了起来。同一时间会来10个客人，老板很开心，但是只有5个服务员，这样就不能一对一服务了，有些客人就要没有人管了。老板就又请了5个服务员，现在好了，又能每个人都受VIP待遇了。&lt;/p&gt;
&lt;p&gt;越来越多的人对这家餐厅满意，客源又多了，同时来吃饭的人到了20人，老板高兴不起来了，再请服务员吧，占地方不说，还要开工钱，再请人就攒不到钱了。怎么办呢？老板想了想，10个服务员对付20个客人也是能对付过来的，服务员勤快点就好了，伺候完一个客人马上伺候另外一个，还是来得及的。综合考虑了一下，老板决定就使用10个服务人员的线程池啦~~~&lt;/p&gt;
&lt;p&gt;但是这样有一个比较严重的缺点就是，如果正在接受服务员服务的客人点菜很慢，其他的客人可能就要等好长时间了。有些火爆脾气的客人可能就等不了走人了。&lt;/p&gt;
&lt;p&gt;而非阻塞I/O会选择这样做:&lt;/p&gt;
&lt;p&gt;老板后来发现，客人点菜比较慢，大部服务员都在等着客人点菜，其实干的活不是太多。老板能当老板当然有点不一样的地方，终于发现了一个新的方法，那就是：当客人点菜的时候，服务员就可以去招呼其他客人了，等客人点好了菜，直接招呼一声“服务员”，马上就有个服务员过去服务。嘿嘿，然后在老板有了这个新的方法之后，就进行了一次裁员，只留了一个服务员！这就是用单个线程来做多线程的事。&lt;/p&gt;
&lt;h3 id=&quot;事件多路分解器&quot;&gt;事件多路分解器&lt;/h3&gt;
&lt;p&gt;大多数现代操作系统提供了一种本机机制，该机制通过一种有效的方式处理并发和非阻塞资源.这种机制称为&lt;strong&gt;同步事件多路分解器&lt;/strong&gt;或&lt;strong&gt;事件通知借口&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用reactor模式时会发生什么&quot;&gt;使用Reactor模式时会发生什么&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;应用程序向&lt;strong&gt;事件多路分解器&lt;/strong&gt;提交请求来生成新的I/O操作。应用程序还指定一个处理程序，当操作完成时将调用该处理程序。向&lt;strong&gt;事件多路分解器&lt;/strong&gt;提交新请求是一种非阻塞调用，它立即将控制权返回给应用程序&lt;/li&gt;
&lt;li&gt;当一组I/O操作完成时，&lt;strong&gt;事件多路分解器&lt;/strong&gt;将新的事件推入&lt;strong&gt;Event Queue(事件队列)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;此时，&lt;strong&gt;Event Loop&lt;/strong&gt; 遍历&lt;strong&gt;Event Queue(事件队列)&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;对于每个事件，调用关联的处理程序。&lt;/li&gt;
&lt;li&gt;处理程序是应用程序代码的一部分，当它执行完成时将把控制权返还给&lt;strong&gt;Event Loop&lt;/strong&gt;.但是，在处理程序执行过程中可能会请求新的异步操作，从而导致新的操作被插入&lt;strong&gt;事件多路分解器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;Event Queue(事件队列)&lt;/strong&gt; 中所有项目被处理完时，循环将再次阻塞&lt;strong&gt;事件多路分解器&lt;/strong&gt; ,当有新事件可用时，&lt;strong&gt;事件多路分解器&lt;/strong&gt; 将出发另一个周期.&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 20 Jul 2018 15:18:00 +0000</pubDate>
<dc:creator>wangyunfeifeifei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swust-wangyf/p/9344595.html</dc:identifier>
</item>
<item>
<title>【react开发】使用swiper插件，loop:true时产生的问题解决方案 - 海瑞菌·博客</title>
<link>http://www.cnblogs.com/wuhairui/p/9343846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/9343846.html</guid>
<description>&lt;p&gt;这2天上班遇到的问题：react使用swiper3插件实现banner轮播，其中有个banner图有个click点击事件，而其他的是页面跳转。出现了一个问题：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;向右滑动到该帧时的&lt;/span&gt;&lt;span&gt;swiper，点击时未触发react的onClick方法。&lt;/span&gt;&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92676&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;因为昨天玩滑板时，手上受了点伤，所以今天没出去玩了，休息一天。于是正好拿来整理下一个技术点。&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;80%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;strong&gt;这里我们使用简单案例来说明：&lt;/strong&gt;&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;错误示范&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;我们先来看看错误代码（其实理论是正确的）：&lt;/p&gt;
&lt;p&gt;组件初始化一个banner数组&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/SZndEqK9_vtRB.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;render中渲染出轮询banner，并给每个banner绑定一个onClick事件，传入参数i&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/s6Nx4cWB_UfBI.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绑定的方法：点击后执行弹出当前为第几个banner&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/OXGDJehS_M6qj.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Swiper对象，初始化为轮播图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/j334IOtS_IJIz.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;照理来讲，我们分别点击这个swiper的每个banner应该会弹出1、2、1、2……的&lt;/p&gt;

&lt;p&gt;但是实际上：&lt;/p&gt;
&lt;p&gt;（点击1、2两图时触发了，但是点击第3图，click方法就没生效了）&lt;/p&gt;
&lt;p&gt;动态图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/QPY2dQxm_Vjep.gif&quot; alt=&quot;GIF.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们来分析一下原因吧：&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;原因&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;首先，banner只有2个，照理应该是2个swiper-slide，&lt;/p&gt;
&lt;p&gt;但是在初始化时使用了loop:true&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/NSARUnHs_2AGJ.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;便由swiper插件再复制生成了2个。因此有了4个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/pvtbKYnf_uJ3e.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而新的2个slide是swiper插件生成的，并没有绑定react的事件，所以点击之后没有触发到事件。&lt;/p&gt;
&lt;p&gt;怎么办呢？其实这样的效果已经无法完全使用react处理了。因为插件生成的swiper并不是虚拟dom了。&lt;/p&gt;
&lt;p&gt;所以这里需要使用到部分的dom操作。然后和react连接起来。&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;正确示范&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;来看看解决方案吧&lt;/p&gt;
&lt;p&gt;数据一样，第2图中，我们在slide中加入一个属性data-i，这个i就是我们之后要用到方法中参数&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/Ndz2Xmwk_rpFb.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们在初始化之后，给每个slide绑定一个click事件：&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击后拿到之前绑定的i，表示当前点击的是第几个banner，然后再调用组件对象的click方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/sXXjMFWL_sxYH.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（这里的_this代表当前react组件对象，因为前面声明了，这样就又可以从dom操作回到react操作了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/m2YLfbZP_C5dw.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;85638&quot; data-color=&quot;#ef7060&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-brushtype=&quot;text&quot;&gt;运行实例&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;现在我们来看看这个案例：&lt;/p&gt;
&lt;p&gt;请长按识别二维码（点击）打开：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;&lt;a href=&quot;http://coding.wuhairui.cn/react/1.html&quot;&gt;&lt;img src=&quot;https://bdn.135editor.com/files/users/93/938573/201807/JW72ZYGz_qkXh.png&quot; title=&quot;82f93fc4b1460f681cc53da6c57fb434.png&quot; alt=&quot;82f93fc4b1460f681cc53da6c57fb434.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;


</description>
<pubDate>Fri, 20 Jul 2018 14:11:00 +0000</pubDate>
<dc:creator>海瑞菌&amp;#183;博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/9343846.html</dc:identifier>
</item>
<item>
<title>MapReduce剥洋葱 - sunjavakai</title>
<link>http://www.cnblogs.com/sunjava/p/9343825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunjava/p/9343825.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、&lt;/strong&gt;&lt;strong&gt;大白话&lt;/strong&gt;&lt;strong&gt;MapReduce&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.什么是Map/Reduce，看下面的各种解释：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(1)MapReduce是hadoop的核心组件之一，hadoop要分布式包括两部分，一是分布式文件系统hdfs,一部是分布式计算框，就是mapreduce,缺一不可，也就是说，可以通过mapreduce很容易在hadoop平台上进行分布式的计算编程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2)Mapreduce是一种编程模型，是一种编程方法，抽象理论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3)下面是一个关于一个程序员是如何个妻子讲解什么是MapReduce？文章很长请耐心的看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我问妻子：“你真的想要弄懂什么是MapReduce？” 她很坚定的回答说“是的”。 因此我问道：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 你是如何准备洋葱辣椒酱的？（以下并非准确食谱，请勿在家尝试）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 我会取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机里研磨。这样就能得到洋葱辣椒酱了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 但这和MapReduce有什么关系？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 你等一下。让我来编一个完整的情节，这样你肯定可以在15分钟内弄懂MapReduce.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 好吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我：现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 我会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 没错，让我们把MapReduce的概念应用到食谱上。Map和Reduce其实是两种操作，我来给你详细讲解下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Map（映射）: 把洋葱、番茄、辣椒和大蒜切碎，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。 同样的，你把辣椒，大蒜和番茄一一地拿给Map，你也会得到各种碎块。 所以，当你在切像洋葱这样的蔬菜时，你执行就是一个Map操作。 Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把坏洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉坏洋葱而不会生产出任何的坏洋葱块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Reduce（化简）:在这一阶段，你将各种蔬菜碎都放入研磨机里进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将map操作的蔬菜碎聚集在了一起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 所以，这就是MapReduce?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 你可以说是，也可以说不是。 其实这只是MapReduce的一部分，MapReduce的强大在于分布式计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 分布式计算？ 那是什么？请给我解释下吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 没问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我： 假设你参加了一个辣椒酱比赛并且你的食谱赢得了最佳辣椒酱奖。得奖之后，辣椒酱食谱大受欢迎，于是你想要开始出售自制品牌的辣椒酱。假设你每天需要生产10000瓶辣椒酱，你会怎么办呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 我会找一个能为我大量提供原料的供应商。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我：是的..就是那样的。那你能否独自完成制作呢？也就是说，独自将原料都切碎？ 仅仅一部研磨机又是否能满足需要？而且现在，我们还需要供应不同种类的辣椒酱，像洋葱辣椒酱、青椒辣椒酱、番茄辣椒酱等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子： 当然不能了，我会雇佣更多的工人来切蔬菜。我还需要更多的研磨机，这样我就可以更快地生产辣椒酱了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我：没错，所以现在你就不得不分配工作了，你将需要几个人一起切蔬菜。每个人都要处理满满一袋的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断的从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块、和蒜蓉等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;妻子：但是我怎么会制造出不同种类的番茄酱呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我：现在你会看到MapReduce遗漏的阶段—搅拌阶段。MapReduce将所有输出的蔬菜碎都搅拌在了一起，这些蔬菜碎都是在以key为基础的 map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，就像洋葱一样。 所以全部的洋葱keys都会搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移到标记着番茄的研磨器里，并制造出番茄辣椒酱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上面都是从理论上来说明什么是MapReduce，那么咱们在MapReduce产生的过程和代码的角度来理解这个问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;：如果想统计下过去10年计算机论文出现最多的几个单词，看看大家都在研究些什么，那收集好论文后，该怎么办呢？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法一：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      我可以写一个小程序，把所有论文按顺序遍历一遍，统计每一个遇到的单词的出现次数，最后就可以知道哪几个单词最热门了。 这种方法在数据集比较小时，是非常有效的，而且实现最简单，用来解决这个问题很合适。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法二：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       写一个多线程程序，并发遍历论文。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　这个问题理论上是可以高度并发的，因为统计一个文件时不会影响统计另一个文件。当我们的机器是多核或者多处理器，方法二肯定比方法一高效。但是写一个多线程程序要比方法一困难多了，我们必须自己同步共享数据，比如要防止两个线程重复统计文件。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法三：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      把作业交给多个计算机去完成。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　我们可以使用方法一的程序，部署到N台机器上去，然后把论文集分成N份，一台机器跑一个作业。这个方法跑得足够快，但是部署起来很麻烦，我们要人工把程序copy到别的机器，要人工把论文集分开，最痛苦的是还要把N个运行结果进行整合（当然我们也可以再写一个程序）。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法四：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      让MapReduce来帮帮我们吧！ &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MapReduce本质上就是方法三，但是如何拆分文件集，如何copy程序，如何整合结果这些都是框架定义好的。我们只要定义好这个任务（用户程序），其它都交给MapReduce。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;map函数和reduce函数　　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二&lt;/strong&gt; &lt;strong&gt;MapReduce&lt;/strong&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;strong&gt;wordcount&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720220956470-294546640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编程实现wordcount&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_ae37d663-5286-4ebf-87e7-7fc38042653c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ae37d663-5286-4ebf-87e7-7fc38042653c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_ae37d663-5286-4ebf-87e7-7fc38042653c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

 * KEYIN：输入kv数据对中key的数据类型

 * VALUEIN：输入kv数据对中value的数据类型

 * KEYOUT：输出kv数据对中key的数据类型

 * VALUEOUT：输出kv数据对中value的数据类型

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WordCountMapper &lt;span&gt;extends&lt;/span&gt; Mapper&amp;lt;LongWritable, Text, Text, IntWritable&amp;gt;&lt;span&gt;{

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

          * map方法是提供给map task进程来调用的，map task进程是每读取一行文本来调用一次我们自定义的map方法

          * map task在调用map方法时，传递的参数：

          *             一行的起始偏移量LongWritable作为key

          *             一行的文本内容Text作为value

          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         @Override

         &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; map(LongWritable key, Text value,Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到一行文本内容，转换成String 类型&lt;/span&gt;
&lt;span&gt;
                   String line &lt;/span&gt;=&lt;span&gt; value.toString();

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将这行文本切分成单词&lt;/span&gt;
&lt;span&gt;
                   String[] words&lt;/span&gt;=line.split(&quot; &quot;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出&amp;lt;单词，1&amp;gt;&lt;/span&gt;

                   &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String word:words){

                            context.write(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Text(word), &lt;span&gt;new&lt;/span&gt; IntWritable(1&lt;span&gt;));

                   }

         }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

 * KEYIN：对应mapper阶段输出的key类型

 * VALUEIN：对应mapper阶段输出的value类型

 * KEYOUT：reduce处理完之后输出的结果kv对中key的类型

 * VALUEOUT：reduce处理完之后输出的结果kv对中value的类型

 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WordCountReducer &lt;span&gt;extends&lt;/span&gt; Reducer&amp;lt;Text, IntWritable, Text, IntWritable&amp;gt;&lt;span&gt;{

         @Override

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

          * reduce方法提供给reduce task进程来调用

          *

          * reduce task会将shuffle阶段分发过来的大量kv数据对进行聚合，聚合的机制是相同key的kv对聚合为一组

          * 然后reduce task对每一组聚合kv调用一次我们自定义的reduce方法

          * 比如：&amp;lt;hello,1&amp;gt;&amp;lt;hello,1&amp;gt;&amp;lt;hello,1&amp;gt;&amp;lt;tom,1&amp;gt;&amp;lt;tom,1&amp;gt;&amp;lt;tom,1&amp;gt;

          *  hello组会调用一次reduce方法进行处理，tom组也会调用一次reduce方法进行处理

          *  调用时传递的参数：

          *                     key：一组kv中的key

          *                     values：一组kv中所有value的迭代器

          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reduce(Text key, Iterable&amp;lt;IntWritable&amp;gt; values,Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个计数器&lt;/span&gt;

                   &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过value这个迭代器，遍历这一组kv中所有的value，进行累加&lt;/span&gt;

                   &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(IntWritable value:values){

                            count&lt;/span&gt;+=&lt;span&gt;value.get();

                   }

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出这个单词的统计结果&lt;/span&gt;
&lt;span&gt;
                   context.write(key, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IntWritable(count));

         }

}

 

 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WordCountJobSubmitter {

        

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException, InterruptedException {

                   Configuration conf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();

                   Job wordCountJob &lt;/span&gt;=&lt;span&gt; Job.getInstance(conf);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要：指定本job所在的jar包&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setJarByClass(WordCountJobSubmitter.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置wordCountJob所用的mapper逻辑类为哪个类&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setMapperClass(WordCountMapper.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置wordCountJob所用的reducer逻辑类为哪个类&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setReducerClass(WordCountReducer.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置map阶段输出的kv数据类型&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setMapOutputKeyClass(Text.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                   wordCountJob.setMapOutputValueClass(IntWritable.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置最终输出的kv数据类型&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.setOutputKeyClass(Text.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                   wordCountJob.setOutputValueClass(IntWritable.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要处理的文本数据所存放的路径&lt;/span&gt;
&lt;span&gt;
                   FileInputFormat.setInputPaths(wordCountJob, &lt;/span&gt;&quot;hdfs://192.168.77.70:9000/wordcount/srcdata/&quot;&lt;span&gt;);

                   FileOutputFormat.setOutputPath(wordCountJob, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Path(&quot;hdfs://192.168.77.70:9000/wordcount/output/&quot;&lt;span&gt;));

                  

                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交job给hadoop集群&lt;/span&gt;
&lt;span&gt;
                   wordCountJob.waitForCompletion(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

         }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、&lt;/strong&gt; &lt;strong&gt;MapReduce&lt;/strong&gt;&lt;strong&gt;过程详解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapReduce过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Input --》 Map --》 shuffle --》 Reduce  --》 Output&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221023497-599680482.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapReduce中，分片、分区、排序和分组（Group）的关系图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221033788-255919925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于HDFS中存储的一个文件，要进行Map处理前，需要将它切分成多个块，才能分配给不同的MapTask去执行。 分片的数量等于启动的MapTask的数量。默认情况下，分片的大小就是HDFS的blockSize。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map阶段的对数据文件的切片，使用如下判断逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;  protected long computeSplitSize(long blockSize, long minSize,&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;                                  long maxSize) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    return Math.max(minSize, Math.min(maxSize, blockSize));&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;  }&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;blockSize：默认大小是128M（&lt;span&gt;&lt;a href=&quot;https://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml#dfs.blockSize&quot; target=&quot;https://www.cnblogs.com/huqiaoblog/p/_blank&quot;&gt;dfs.blocksize&lt;/a&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;minSize：默认是1byte（mapreduce.input.fileinputformat.split.minsize）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221147561-1811192624.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maxSize：默认值是Long.MaxValue（mapreduce.input.fileinputformat.split.minsize）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221206186-1805488531.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此可以看出两个可以自定义的值（minSize和maxSize）与blockSize之间的关系如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当blockSize位于minSize和maxSize 之间时，认blockSize：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221219332-509415270.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当maxSize小于blockSize时，认maxSize：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221227779-1340679478.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当minSize大于blockSize时，认minSize：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221235322-1198081274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外一个极端的情况，maxSize小于minSize时，认minsize，可以理解为minSize的优先级比maxSize大：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221245180-234042056.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际使用中，建议不要去修改maxSize，通过调整minSize（使他大于blockSize）就可以设定分片（Split）的大小了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总之通过minSize和maxSize的来设置切片大小，使之在blockSize的上下自由调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么时候需要调整分片的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先要明白，HDFS的分块其实是指HDFS在存储文件时的一个参数。而这里分片的大小是为了业务逻辑用的。分片的大小直接影响到MapTask的数量，你可以根据实际的业务需求来调整分片的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在Reduce过程中，可以根据实际需求（比如按某个维度进行归档，类似于数据库的分组），把Map完的数据Reduce到不同的文件中。分区的设置需要与ReduceTaskNum配合使用。比如想要得到5个分区的数据结果。那么就得设置5个ReduceTask。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义Partitioner：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;public class URLResponseTimePartitioner extends Partitioner&amp;lt;Text, LongWritable&amp;gt;{&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    @Override&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    public int getPartition(Text key, LongWritable value, int numPartitions) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        String accessPath = key.toString();&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        if(accessPath.endsWith(&quot;.do&quot;)) {&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;            return 0;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        return 1;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后可以在job中设置partitioner：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;        job.setPartitionerClass(URLResponseTimePartitioner.class);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        //URLResponseTimePartitioner returns 1 or 0,so num of reduce task must be 2&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        job.setNumReduceTasks(2);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;两个分区会产生两个最终结果文件：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;[root@centos01 ~]# hadoop fs -ls /access/log/response-time17/12/19 14:53:55 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Found 3 items-rw-r--r--   2 root supergroup          0 2017-12-19 14:49 /access/log/response-time/_SUCCESS-rw-r--r--   2 root supergroup       7769 2017-12-19 14:49 /access/log/response-time/part-r-00000&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;-rw-r--r--   2 root supergroup      18183 2017-12-19 14:49 /access/log/response-time/part-r-00001&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;其中00000中存放着.do的统计结果，00001则存放其他访问路径的统计结果。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;[root@centos01 ~]# hadoop fs -cat /access/log/response-time/part-r-00001 |more17/12/19 14:55:41 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable//MyAdmin/scripts/setup.php     3857//css/console.css       356//css/result_html.css   628//images/male.png       268//js/tooltipster/css/plugins/tooltipster/sideTip/themes/tooltipster-sideTip-borderless.min.css  1806//js/tooltipster/css/tooltipster.bundle.min.css 6495//myadmin/scripts/setup.php     3857//phpMyAdmin/scripts/setup.php  3857//phpmyadmin/scripts/setup.php  3857//pma/scripts/setup.php 3857&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/404/search_children.js 3827&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/Dashboard.action       3877&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/Homepage.action        3877&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/WdatePicker.js  9371&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/calendar.js     22044&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/lang/zh-cn.js   1089&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/skin/WdatePicker.css    158&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/skin/default/datepicker.css     3486&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;/My97DatePicker/skin/default/img.gif    475&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;要想最终结果中按某个特性排序，则需要在Map阶段，通过Key的排序来实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，想让上述平均响应时间的统计结果按降序排列，实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键就在于这个用于OUTKey的Bean。它实现了Comparable接口，所以输出的结果就是按compareTo的结果有序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于这个类会作为&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;，所以它的&lt;/span&gt;&lt;span&gt;equals&lt;/span&gt;&lt;span&gt;方法很重要，会作为，需要按实际情况重写。这里重写的逻辑是&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;相等则表示是同一个&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;。（虽然&lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;相同的情况其实没有，因为之前的&lt;/span&gt;&lt;span&gt;responseTime&lt;/span&gt;&lt;span&gt;统计结果已经把&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;做了&lt;/span&gt;&lt;span&gt;group&lt;/span&gt;&lt;span&gt;，但是这里还是要注意有这么个逻辑。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序并不是依赖于key的equals！&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;  public class URLResponseTime implements WritableComparable&amp;lt;URLResponseTime&amp;gt;{&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    String url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;long&lt;/em&gt;&lt;em&gt; avgResponseTime;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; write(DataOutput out) &lt;/em&gt;&lt;em&gt;throws&lt;/em&gt;&lt;em&gt; IOException {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        out.writeUTF(url);&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        out.writeLong(avgResponseTime);&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; readFields(DataInput in) &lt;/em&gt;&lt;em&gt;throws&lt;/em&gt;&lt;em&gt; IOException {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.url = in.readUTF();&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.avgResponseTime = in.readLong();&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; compareTo(URLResponseTime urt) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.avgResponseTime &amp;gt; urt.avgResponseTime ? -1 : 1;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt; String getUrl() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; setUrl(String url) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.url = url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;long&lt;/em&gt;&lt;em&gt; getAvgResponseTime() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; avgResponseTime;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;void&lt;/em&gt;&lt;em&gt; setAvgResponseTime(&lt;/em&gt;&lt;em&gt;long&lt;/em&gt;&lt;em&gt; avgResponseTime) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt;.avgResponseTime = avgResponseTime;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    @Override&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; hashCode() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;final&lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; prime = 31;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;int&lt;/em&gt;&lt;em&gt; result = 1;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        result = prime * result + ((url == &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;) ? 0 : url.hashCode());&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; result;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    @Override&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt;boolean&lt;/em&gt;&lt;em&gt; equals(Object obj) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;&lt;em&gt; == obj)&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;true&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (obj == &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (getClass() != obj.getClass())&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        URLResponseTime other = (URLResponseTime) obj;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (url == &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;) {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (other.url != &lt;/em&gt;&lt;em&gt;null&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;                &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        } &lt;/em&gt;&lt;em&gt;else&lt;/em&gt;&lt;em&gt;if&lt;/em&gt;&lt;em&gt; (!url.equals(other.url))&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;            &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt;true&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    @Override&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;public&lt;/em&gt;&lt;em&gt; String toString() {&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;em&gt;return&lt;/em&gt;&lt;em&gt; url;&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    }&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;    &lt;br/&gt;}&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后就简单了，在Map和Reduce分别执行简单的写和读操作就行了，没有更多的处理，依赖于Hadoop MapReduce框架自身的特点就实现了排序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Mapreduce排序分组&quot; href=&quot;https://www.cnblogs.com/sunddenly/p/4009751.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/sunddenly/p/4009751.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、&lt;/strong&gt;&lt;strong&gt;Mapreduce&lt;/strong&gt; &lt;strong&gt;项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户行为日志清洗，分析出用户行为链。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现方式：根据用户曝光页面时间排序。（粗略）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义分区,分组,排序&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;job.setSortComparatorClass(LogDataSortComparator.&lt;strong&gt;class&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;job.setGroupingComparatorClass(LogDataGroupingComparator.&lt;strong&gt;class&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;job.setPartitionerClass(LogDataPartitioner.&lt;strong&gt;class&lt;/strong&gt;);  //自定义分区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221323823-1081956551.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221344536-234911102.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517115/201807/517115-20180720221357825-1209927334.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、&lt;/strong&gt;Hive 设置map 和 reduce 的个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hive 设置map 和 reduce 的个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/1130136248wlxk/articles/5352154.html&quot;&gt;https://www.cnblogs.com/1130136248wlxk/articles/5352154.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一、    控制hive任务中的map数: &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.    通常情况下，作业会通过input的目录产生一个或者多个map任务。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;主要的决定因素有： input的文件总个数，input的文件大小，集群设置的文件块大小(目前为128M, 可在hive中通过set dfs.block.size;命令查看到，该参数不能自定义修改)；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.    举例： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;a)    假设input目录下有1个文件a,大小为780M,那么hadoop会将该文件a分隔成7个块（6个128m的块和1个12m的块），从而产生7个map数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b)    假设input目录下有3个文件a,b,c,大小分别为10m，20m，130m，那么hadoop会分隔成4个块（10m,20m,128m,2m）,从而产生4个map数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;即，如果文件大于块大小(128m),那么会拆分，如果小于块大小，则把该文件当成一个块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.    是不是map数越多越好？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;答案是否定的。如果一个任务有很多小文件（远远小于块大小128m）,则每个小文件也会被当做一个块，用一个map任务来完成，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而且，同时可执行的map数是受限的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.    是不是保证每个map处理接近128m的文件块，就高枕无忧了？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;答案也是不一定。比如有一个127m的文件，正常会用一个map去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果map处理的逻辑比较复杂，用一个map任务去做，肯定也比较耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上面的问题3和4，我们需要采取两种方式来解决：即减少map数和增加map数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何合并小文件，减少map数？ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;    假设一个SQL任务：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         Select count(1) from popt_tbaccountcopy_mes where pt = ‘2012-07-04’;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         该任务的inputdir  /group/p_sdo_data/p_sdo_data_etl/pt/popt_tbaccountcopy_mes/pt=2012-07-04&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         共有194个文件，其中很多是远远小于128m的小文件，总大小9G，正常执行会用194个map任务。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         Map总共消耗的计算资源： SLOTS_MILLIS_MAPS= 623,020&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         我通过以下方法来在map执行前合并小文件，减少map数：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         set mapred.max.split.size=100000000;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    set mapred.min.split.size.per.node=100000000;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    set mapred.min.split.size.per.rack=100000000;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 再执行上面的语句，用了74个map任务，map消耗的计算资源：SLOTS_MILLIS_MAPS= 333,500&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         对于这个简单SQL任务，执行时间上可能差不多，但节省了一半的计算资源。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         大概解释一下，100000000表示100M, set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;这个参数表示执行前进行小文件合并，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         前面三个参数确定合并文件块的大小，大于文件块大小128m的，按照128m来分隔，小于128m,大于100m的，按照100m来分隔，把那些小于100m的（包括小文件和分隔大文件剩下的），&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         进行合并,最终生成了74个块。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         &lt;/span&gt;&lt;br/&gt;&lt;span&gt;如何适当的增加map数？ &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         当input的文件都很大，任务逻辑复杂，map执行非常慢的时候，可以考虑增加Map数，来使得每个map处理的数据量减少，从而提高任务的执行效率。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         假设有这样一个任务：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         Select data_desc,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                count(1),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                count(distinct id),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                sum(case when …),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                sum(case when ...),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                sum(…)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        from a group by data_desc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   如果表a只有一个文件，大小为120M，但包含几千万的记录，如果用1个map去完成这个任务，肯定是比较耗时的，这种情况下，我们要考虑将这一个文件合理的拆分成多个，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   这样就可以用多个map任务去完成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   set mapred.reduce.tasks=10;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   create table a_1 as &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   select * from a &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   distribute by rand(123); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   这样会将a表的记录，随机的分散到包含10个文件的a_1表中，再用a_1代替上面sql中的a表，则会用10个map任务去完成。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   每个map任务处理大于12M（几百万记录）的数据，效率肯定会好很多。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;br/&gt;&lt;span&gt;   看上去，貌似这两种有些矛盾，一个是要合并小文件，一个是要把大文件拆成小文件，这点正是重点需要关注的地方，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   根据实际情况，控制map数量需要遵循两个原则：使大数据量利用合适的map数；使单个map任务处理合适的数据量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、    控制hive任务的reduce数： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.    Hive自己如何确定reduce数： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;reduce个数的设定极大影响任务执行效率，不指定reduce个数的情况下，Hive会猜测确定一个reduce个数，基于以下两个设定：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hive.exec.reducers.bytes.per.reducer（每个reduce任务处理的数据量，默认为1000^3=1G） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;hive.exec.reducers.max（每个任务最大的reduce数，默认为999）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;计算reducer数的公式很简单N=min(参数2，总输入数据量/参数1)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;即，如果reduce的输入（map的输出）总大小不超过1G,那么只会有一个reduce任务；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如：select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;            /group/p_sdo_data/p_sdo_data_etl/pt/popt_tbaccountcopy_mes/pt=2012-07-04 总大小为9G多，因此这句有10个reduce&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.    调整reduce个数方法一： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;调整hive.exec.reducers.bytes.per.reducer参数的值；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;set hive.exec.reducers.bytes.per.reducer=500000000; （500M）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt; 这次有20个reduce&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         &lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.    调整reduce个数方法二； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;set mapred.reduce.tasks = 15;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt;这次有15个reduce&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.    reduce个数并不是越多越好； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;同map一样，启动和初始化reduce也会消耗时间和资源；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;另外，有多少个reduce,就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.    什么情况下只有一个reduce； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;很多时候你会发现任务中不管数据量多大，不管你有没有设置调整reduce个数的参数，任务中一直都只有一个reduce任务；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实只有一个reduce任务的情况，除了数据量小于hive.exec.reducers.bytes.per.reducer参数值的情况外，还有以下原因：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a)    没有group by的汇总，比如把select pt,count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04' group by pt; 写成 select count(1) from popt_tbaccountcopy_mes where pt = '2012-07-04';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这点非常常见，希望大家尽量改写。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b)    用了Order by&lt;/span&gt;&lt;br/&gt;&lt;span&gt;c)    有笛卡尔积&lt;/span&gt;&lt;br/&gt;&lt;span&gt;通常这些情况下，除了找办法来变通和避免，我暂时没有什么好的办法，因为这些操作都是全局的，所以hadoop不得不用一个reduce去完成；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同样的，在设置reduce个数的时候也需要考虑这两个原则：使大数据量利用合适的reduce数；使单个reduce任务处理合适的数据量；&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Jul 2018 14:05:00 +0000</pubDate>
<dc:creator>sunjavakai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunjava/p/9343825.html</dc:identifier>
</item>
</channel>
</rss>