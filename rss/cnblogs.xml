<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>移动端H5地图离线瓦片方案 - 李晓晖</title>
<link>http://www.cnblogs.com/naaoveGIS/p/8670183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/naaoveGIS/p/8670183.html</guid>
<description>&lt;p&gt;&lt;span&gt;文章版权由作者李晓晖和博客园共有，若转载请于明显处标明出处：http://www.cnblogs.com/naaoveGIS/&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;FirstParagraph&quot;&gt;移动端的网速和流量耗费是移动开发必须考虑的两个点。常规的瓦片展示方案是移动端实时请求在线瓦片服务（瓦片放在服务器端供直接读取，或者瓦片由地理服务器发布成WMTS服务等）。这个方案存在两个问题：&lt;/p&gt;
&lt;p class=&quot;FirstParagraph&quot;&gt;* 瓦片实时请求加载受限于移动端网速，容易导致加载卡顿现象&lt;/p&gt;
&lt;p class=&quot;FirstParagraph&quot;&gt;* 瓦片请求耗费手机流量。&lt;/p&gt;
&lt;p&gt;试想，如果我们将切图瓦片提前存放到移动设备上，每次瓦片请求时直接读取设备缓存瓦片，不仅可以提高瓦片加载效率，也可以规避流量的耗费。目前各大地图厂商也都提供了地图下载功能，使得手机即使在无网环境下依然可以照常使用地图。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;JS无法直接读取移动端本地文件，如何进行本地瓦片获取&lt;/li&gt;
&lt;li&gt;避免下载全部瓦片导致的数据量过大，如何实现瓦片基于单元网格（最小打包单元，相对稳定，避免使用责任网格打包后由于网格变动导致的重复工作量）的打包，如何基于单元网格瓦片生成责任网格的打包，并实现上传更新。&lt;/li&gt;
&lt;li&gt;瓦片为规则矩形，如何实现在移动端只显示不规则面（责任网格）内的地图信息，即裁剪显示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-source-line=&quot;14&quot;&gt;3.1方法描述&lt;/h2&gt;
&lt;ul data-source-line=&quot;15&quot;&gt;&lt;li&gt;与手机研发定义读取本地瓦片时的固定URL前缀，手机程序监听所有请求，当匹配上该固定前缀时，则表明手机程序需进行文件读取，如：&lt;br/&gt;&lt;code&gt;var offlineURL = &quot;http://mobile.test.com.cn/tile? &quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求参数带有瓦片级别、行、列、文件名参数。手机程序解析这些参数，读取本地对应瓦片，并将数据返回&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-source-line=&quot;18&quot;&gt;3.2优化&lt;/h2&gt;
&lt;p data-source-line=&quot;19&quot;&gt;请求参数中增加瓦片服务端获取URL，当手机本地没有寻找到对应瓦片时，则触发服务端获取的URL，从服务端获取瓦片后再缓存至手机本地,如:&lt;/p&gt;
&lt;pre data-source-line=&quot;20&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;var offlineURL = &lt;span class=&quot;hljs-string&quot;&gt;&quot;http://mobile.test.com.cn/tile?raw=&quot;
url = offlineURL+encodeURIComponent&lt;span class=&quot;hljs-list&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;url)+&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;amp;level=&quot;+level+
&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;amp;row=&quot;+row+&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;amp;col=&quot;+col+&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;amp;layername=&quot;+&lt;span class=&quot;hljs-list&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;this.get&lt;span class=&quot;hljs-list&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mobileCacheName&quot;)||&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;25&quot;&gt;对在线URL进行编码（可将URL中的特殊符号转换），便于手机程序获取raw参数对应的值。&lt;/p&gt;

&lt;h2 align=&quot;left&quot;&gt;4.1工具设计思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;获取瓦片切图的具体参数：包含各级别比例尺、切图原点、瓦片大小&lt;/li&gt;
&lt;li&gt;遍历网格图层获取图层各要素，获得各要素的四角范围&lt;/li&gt;
&lt;li&gt;通过切图参数以及要素的四角范围，算出该范围所对应的所有瓦片，将这些瓦片保留原有文件组织结构拷贝至目录文件夹下。遍历处理所有要素对应的四角范围瓦片。&lt;/li&gt;
&lt;li&gt;将目标文件夹压缩成一个文件&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;SourceCode&quot;&gt;        &lt;/p&gt;
&lt;pre data-source-line=&quot;32&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;　　　　public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-built_in&quot;&gt;int getXTileIndex(&lt;span class=&quot;hljs-keyword&quot;&gt;double x,&lt;span class=&quot;hljs-keyword&quot;&gt;double originx,&lt;span class=&quot;hljs-keyword&quot;&gt;double resolution,&lt;span class=&quot;hljs-keyword&quot;&gt;double &lt;span class=&quot;hljs-built_in&quot;&gt;size)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;double d = (x - originx) / (resolution * &lt;span class=&quot;hljs-built_in&quot;&gt;size);
            &lt;span class=&quot;hljs-built_in&quot;&gt;int index = (&lt;span class=&quot;hljs-built_in&quot;&gt;int)Math.Floor(Math.Abs(d));
            &lt;span class=&quot;hljs-keyword&quot;&gt;return index;
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-built_in&quot;&gt;int getYTileIndex(&lt;span class=&quot;hljs-keyword&quot;&gt;double y, &lt;span class=&quot;hljs-keyword&quot;&gt;double originy, &lt;span class=&quot;hljs-keyword&quot;&gt;double resolution, &lt;span class=&quot;hljs-keyword&quot;&gt;double &lt;span class=&quot;hljs-built_in&quot;&gt;size)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;double d = (y - originy) / (resolution * &lt;span class=&quot;hljs-built_in&quot;&gt;size);
            &lt;span class=&quot;hljs-built_in&quot;&gt;int index = (&lt;span class=&quot;hljs-built_in&quot;&gt;int)Math.Floor(Math.Abs(d));
            &lt;span class=&quot;hljs-keyword&quot;&gt;return index;
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;String calcPath(&lt;span class=&quot;hljs-keyword&quot;&gt;String dir,&lt;span class=&quot;hljs-built_in&quot;&gt;int level,&lt;span class=&quot;hljs-built_in&quot;&gt;int yindex,&lt;span class=&quot;hljs-built_in&quot;&gt;int xindex)
        {
            StringBuilder sb = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder(dir).Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\&quot;).Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;L&quot;);
            sb.Append(padLeft(Convert.ToString(level, &lt;span class=&quot;hljs-number&quot;&gt;16), &lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-string&quot;&gt;'0'));
            sb.Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\&quot;).Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;R&quot;).Append(padLeft(Convert.ToString(yindex, &lt;span class=&quot;hljs-number&quot;&gt;16), &lt;span class=&quot;hljs-number&quot;&gt;8, &lt;span class=&quot;hljs-string&quot;&gt;'0'));
            sb.Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\\&quot;).Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;C&quot;).Append(padLeft(Convert.ToString(xindex, &lt;span class=&quot;hljs-number&quot;&gt;16), &lt;span class=&quot;hljs-number&quot;&gt;8, &lt;span class=&quot;hljs-string&quot;&gt;'0'));
            sb.Append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;.png&quot;);
            &lt;span class=&quot;hljs-keyword&quot;&gt;return sb.ToString();
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;String padLeft(&lt;span class=&quot;hljs-keyword&quot;&gt;String &lt;span class=&quot;hljs-built_in&quot;&gt;str, &lt;span class=&quot;hljs-built_in&quot;&gt;int &lt;span class=&quot;hljs-built_in&quot;&gt;size, &lt;span class=&quot;hljs-built_in&quot;&gt;char symbol)
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-built_in&quot;&gt;str == &lt;span class=&quot;hljs-keyword&quot;&gt;null)
                &lt;span class=&quot;hljs-built_in&quot;&gt;str = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;;
            &lt;span class=&quot;hljs-built_in&quot;&gt;int str_size = &lt;span class=&quot;hljs-built_in&quot;&gt;str.Length;
            &lt;span class=&quot;hljs-built_in&quot;&gt;int pad_len = &lt;span class=&quot;hljs-built_in&quot;&gt;size - str_size;
            StringBuilder retvalue = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();
            &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-built_in&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; pad_len; i++)
            {
                retvalue.Append(symbol);
            }
            &lt;span class=&quot;hljs-keyword&quot;&gt;return retvalue.Append(&lt;span class=&quot;hljs-built_in&quot;&gt;str).ToString();
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-source-line=&quot;71&quot;&gt;4.2工具展示&lt;/h2&gt;
&lt;p data-source-line=&quot;72&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180329153812586-1294228406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 data-source-line=&quot;74&quot;&gt;5.1基于单元网格切片合成责任网格切片&lt;/h2&gt;
&lt;p data-source-line=&quot;75&quot;&gt;单元网格的切片组织如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180329153822406-212404016.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;384&quot;/&gt;&lt;br/&gt;即：网格编码_alllayers\level\row\col.png&lt;br/&gt;所以，服务端进行责任网格瓦片合并方法如下：&lt;/p&gt;
&lt;ul data-source-line=&quot;79&quot;&gt;&lt;li&gt;读取责任网格与单元网格的对应关系表，获取每个责任网格编码对应的所有单元网格编码&lt;/li&gt;
&lt;li&gt;在单元网格切片文件夹中找到所有对应的单元网格编码切片文件夹&lt;/li&gt;
&lt;li&gt;以增量覆盖方式，将各单元网格文件夹中的文件（从_allLayers文件夹至下）进行合并，合并后的文件存放至责任网格编码的文件夹下&lt;/li&gt;
&lt;li&gt;将各责任网格文件分别压缩&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-source-line=&quot;83&quot;&gt;5.2责任网格瓦片打包上传&lt;/h2&gt;
&lt;p data-source-line=&quot;84&quot;&gt;服务端修改更新配置，当移动端再次启动时，依据不同移动端所属的责任网格区域进行对应的瓦片下载和解压。&lt;/p&gt;

&lt;p data-source-line=&quot;86&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180329153829289-2003418305.png&quot; alt=&quot;&quot; width=&quot;654&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;FigurewithCaption&quot;&gt; &lt;/p&gt;

&lt;p data-source-line=&quot;88&quot;&gt;由于瓦片是规则四边形，而区域是不规则多边形，所以全图浏览时会出现太多不在区域范围内的数据。 这里可以使用遮罩的思想进行处理：制作一个很大的四边形，然后以区边界要素为内环，两者结合构成一个环状要素。叠加在地图上时，把多边形环要素设置为背景色，这可以变相实现遮罩效果。&lt;/p&gt;
&lt;p class=&quot;FigurewithCaption&quot;&gt; &lt;/p&gt;
&lt;p&gt;                                                                                 -----欢迎转载，但保留版权，请于明显处标明出处：&lt;a href=&quot;http://www.cnblogs.com/naaoveGIS/&quot;&gt;http://www.cnblogs.com/naaoveGIS/&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                                                                      　　　　  如果您觉得本文确实帮助了您，可以微信扫一扫，进行小额的打赏和鼓励，谢谢 ^_^&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                                                                                                                           &lt;img src=&quot;https://images2018.cnblogs.com/blog/656746/201803/656746-20180329153958963-509682322.png&quot; alt=&quot;&quot; width=&quot;114&quot; height=&quot;161&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 07:41:00 +0000</pubDate>
<dc:creator>李晓晖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/naaoveGIS/p/8670183.html</dc:identifier>
</item>
<item>
<title>python全栈开发-Day10 装饰器(闭合函数的应用场) - 天王盖地虎宝塔镇河妖</title>
<link>http://www.cnblogs.com/ManyQian/p/8670190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManyQian/p/8670190.html</guid>
<description>&lt;h2&gt;一、 装饰器&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;装饰器就是闭包函数的一种应用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　什么是闭包函数？我们再来回忆一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;闭包函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　定义在函数内部的函数，并且该函数包含对外部函数作用域（&lt;span&gt;强调：对全局作用域名字的引用不算闭包&lt;/span&gt;）名字的引用，该函数称为闭包函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说到作用域我们再回忆下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　作用域：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　全局范围：&lt;/span&gt;&lt;span&gt;内置+全局&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　全局有效，全局存活&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　局部范围：&lt;/span&gt;&lt;span&gt;局部&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　局部有效，局部存活&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　作用域关系是在函数定义阶段就规定死，与调用位置无关，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　也就是说，无论函数在哪儿调用，都必须回到当初定义函数时的位置找作用域关系&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一 、为何要用装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#开放封闭原则：
    #软件一旦上线后，就应该遵循开放封闭原则,对修改源代码是封闭的,对功能的扩展是开放的,也就是我们必须找到一种解决方法:
    #能够在不修改一个功能源代码以及调用方式的前提下,为其加上新功能.&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二 、什么是装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;#装饰器他人的器具，本身可以是任意可调用对象，被装饰者也可以是任意可调用对象。
#强调装饰器的原则：
    #1 、不修改被装饰对象的源代码 
    #2 、不修改被装饰对象的调用方式
#装饰器的目标：
    #在遵循1和2的前提下，为被装饰对象添加上新功能&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三 、装饰器的使用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;我们现在给下面函数增加一个运行时间的功能&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改一&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    start_time&lt;/span&gt;=&lt;span&gt;time.time()
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    stop_time&lt;/span&gt;=&lt;span&gt;time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;run time is %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %(stop_time-&lt;span&gt;start_time))

index()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能实现&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;评语：直接改源代码，这么搞被开了。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;再来一位童靴，来实现功能&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;修改二&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

start_time&lt;/span&gt;=&lt;span&gt;time.time()
index()
stop_time &lt;/span&gt;=&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;run time is %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (stop_time -&lt;span&gt; start_time))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;评语：有好多函数要实现这个功能，写N遍变这个代码，&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;后期维护一脸懵逼，还是被开。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;再来一位童靴,功能重复实现看我用强大的函数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;修订三：&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(func):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;func=index&lt;/span&gt;
    start_time=&lt;span&gt;time.time()
    func() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;index()&lt;/span&gt;
    stop_time =&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;run time is %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (stop_time -&lt;span&gt; start_time))

wrapper(index) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;评语:修改了原函数的调用方式,依然被开。。。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;终于来了位小牛的童靴，函数的值可以返回,然后我再把重新定义index&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;修订四：&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; outter(func): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;func=最原始的index&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; func=最原始的index&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; wrapper():
        start_time&lt;/span&gt;=&lt;span&gt;time.time()
        func()
        stop_time&lt;/span&gt;=&lt;span&gt;time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(stop_time-&lt;span&gt;start_time)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

index&lt;/span&gt;=outter(index)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新的index=wrapper&lt;/span&gt;
index()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;wrapper()  功能基本实现&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;评语：在原值没有返回值是没问题，但是有返回值的情况下，这么搞就会发现返回的是None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这次小牛牛童靴路过看到这情况，say这么搞！&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;修订五&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;假使这里返回123     返回值可以是任意类型 &lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;==============下面就是装饰器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; timmer(func):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;func=最原始的index&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; wrapper(*args,**kwargs):     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可变长参数&lt;/span&gt;
        start_time=&lt;span&gt;time.time()
        res&lt;/span&gt;=func(*args,**kwargs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用最原始的index&lt;/span&gt;
        stop_time=&lt;span&gt;time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(stop_time-&lt;span&gt;start_time)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;index()运行的返回值&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

index&lt;/span&gt;=timmer(index) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新的index=wrapper&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(index())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能已经实现,返回值123&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;评语：这里的装饰的功能已经实现，返回的值也得到,小牛牛不是白叫的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;天上五彩红光,大牛童靴出现!各位童靴火速围观!&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; timmer(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args,**&lt;span&gt;kwargs):
        start_time&lt;/span&gt;=&lt;span&gt;time.time()
        res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
        stop_time&lt;/span&gt;=&lt;span&gt;time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(stop_time-&lt;span&gt;start_time)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

@timmer &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;index=timmer(index)      装饰器的标准格式！&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123&lt;span&gt;

@timmer &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; home=timmer(home)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home(name):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome %s to home page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; index()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;home('egon')   &lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;评语：大牛就是大牛！大牛say：教你们绝技,不会的童靴可以照下面的模板实现：&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;无参装饰器模板&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; outer(func):     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;outer,inner名字功能随意&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

@outer            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;装饰器要在装饰函数的上方&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; duoduo():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;                      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四 、装饰器语法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;被装饰函数的正上方，单独一行&lt;/span&gt;
&lt;span&gt;@deco1
@deco2
@deco3
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;foo=deco1(deco2(deco3(foo)))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;这里的思想就是最上面装饰器，装饰的下面所有的函数(deco2,deco3,foo)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;然后deco2装饰(deco3,foo),最后deco3装饰foo&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;功能的不同,放的顺序也要注意,不然装饰的效果可能实现的就不对了！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、多个装饰器的使用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
current_user&lt;/span&gt;=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'login_time':None&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; auth(func):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; func=index&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; wrapper(*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; current_user[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]:   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里是认证过的,下次就不用认证&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;已经登陆过了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res

        uname&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
        pwd&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;密码&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; uname == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; pwd == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登陆成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            current_user[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;uname
            res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名或密码错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; timmer(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args,**&lt;span&gt;kwargs):
        start_time&lt;/span&gt;=&lt;span&gt;time.time()
        res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
        stop_time&lt;/span&gt;=&lt;span&gt;time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(stop_time-&lt;span&gt;start_time)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

@timmer &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timmer 统计的是auth+index的执行时间&lt;/span&gt;
@auth             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;我们只装饰index的话就要把@timmer紧跟index&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123&lt;span&gt;

@auth
@timmer     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里统计的就是home运行的时间&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home(name):
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome %s to home page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;index()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;home(&quot;duoduo&quot;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六、有参数的装饰器的使用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
current_user&lt;/span&gt;=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None,
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'login_time':None&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; auth(engine):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;道理还是那个道理，在外面包了一层engine的值&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; engine='file'  #这个值外面穿什么进来就是什么&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; auth2(func):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; func=index&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; wrapper(*args,**&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; engine == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; current_user[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;已经登陆过了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res

                uname&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
                pwd&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;密码&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; uname == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; pwd == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;登陆成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    current_user[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;uname
                    res&lt;/span&gt;=func(*args,**&lt;span&gt;kwargs)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名或密码错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; engine == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;engine 值得判断情况&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;基于MyQL的认证&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; engine == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ldap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;基于LDAP的认证&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; auth2     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里也要返回auth2的内存地址&lt;/span&gt;
&lt;span&gt;
@auth(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ldap&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;@auth2 #index=auth2(index) #index=wrapper&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;welcome to index page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123&lt;span&gt;


index() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; wrapper()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 29 Mar 2018 07:41:00 +0000</pubDate>
<dc:creator>天王盖地虎宝塔镇河妖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ManyQian/p/8670190.html</dc:identifier>
</item>
<item>
<title>HTTP缓存带来的“bug”--HTTP 协议 Cache-Control - cnsr</title>
<link>http://www.cnblogs.com/cnsr/p/8670164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnsr/p/8670164.html</guid>
<description>&lt;h3 id=&quot;问题描述&quot;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;先说背景。网站是用PHP开发的，未用任何框架，代码结构也非常简单。运行于阿里云服务器，并采用其CDN来做分发。根据业务需求，有的页面会判断用户浏览器类型，依此来选择PC或者手机端内容。&lt;/p&gt;
&lt;p&gt;在一次上线过程中，遇到比较诡异的问题：用PC和手机分别访问页面时，网页内容未根据浏览器类型来区分。而在开发环境，页面却能正常显示。仔细排查了代码，没有发现问题出在什么地方。而线上环境也不好调试，只能靠猜了。&lt;br/&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310609/201803/1310609-20180329144222417-323152990.jpg&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;解决过程&quot;&gt;解决过程&lt;/h3&gt;
&lt;p&gt;开发环境一切正常，说明代码出问题的可能性不大(当然后面发现还是代码的问题~)。而线上与开发环境的差别就在于多了一层CDN。会不会是CDN的问题？然而本人对CDN也是一知半解的，只知道是它会缓存源网站内容，并就近对用户进行内容分发，来加速访问。如果用户请求的内容CDN并未缓存，就会发生回源。对图片、css、js等静态资源，CDN缓存是理所应当的。但是对html内容，因为一般都是PHP动态生成的，会有一些业务逻辑，缓存这些内容就不太合适了。由于相关判断浏览器类型的代码是经过验证的，所以问题应该不在网站本身。考虑到上面CDN相关内容，我就在怀疑是不是CDN把html都缓存下来了，导致用户请求压根没到网站服务器。于是打开浏览器console，查看请求响应头，并把问题页的响应头和正常页面进行对比，果然发现了问题。正常页面每次刷新后，响应头里的Date字段都会改变；而问题页的Date字段一直没变化！也就是说问题页取到的内容一直都是CDN缓存。再次对比发现，正常页面还有Cache-Control相关内容，而问题页没有。于是推测CDN会根据响应头来决定是否会缓存内容。在问题页代码中增加缓存控制相关header后，果然正常了。然而问题又来了，正常页面的Cache-Control是哪里输出的呢？代码中并没有看到对应内容，估计是线上人为加了相关header，与开发环境代码不一致。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;一直以来对http响应头中的缓存控制相关内容都没有注意，遇到问题才发现它们的重要性。本次解决这个问题，主要是增加了以下header：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;fu&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Pragma: no-cache'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//兼容老版本协议 http1.0可能不识别Cache-Control&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Cache-Control: no-store, no-cache, must-revalidate'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//告诉浏览器/代理 不缓存内容&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Expires: Mon, 26 Jul 1970 05:00:00 GMT&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//把过期时间设置为以往的时间，基本等同于Cache-Control:no-cache&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面加上三行代码后基本可保证其内容不被缓存。&lt;/p&gt;
&lt;p&gt;阿里云CDN响应头中有几个关于缓存的字段需要注意：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;X-Cache,值包含HIT时，表示命中缓存；MISS则表示未命中，需要回源
X-Swift-SaveTime 缓存保存时间
X-Swift-CacheTime 缓存时长
Age 当前资源已缓存的时间，达到X-Swift-CacheTime时缓存过期，会回源&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 29 Mar 2018 07:39:00 +0000</pubDate>
<dc:creator>cnsr</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnsr/p/8670164.html</dc:identifier>
</item>
<item>
<title>虚拟机字节码执行引擎 - 一只黑色的猫</title>
<link>http://www.cnblogs.com/yangming1996/p/8670148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/8670148.html</guid>
<description>&lt;p&gt;所谓的「虚拟机字节码执行引擎」其实就是 JVM 根据 Class 文件中给出的字节码指令，基于栈解释器的一种执行机制。通俗点来说，也就是 JVM 解析字节码指令，输出运行结果的一个过程。接下来我们详细看看这部分内容。&lt;/p&gt;
&lt;h3 id=&quot;方法调用的本质&quot;&gt;方法调用的本质&lt;/h3&gt;
&lt;p&gt;在描述「字节码执行引擎」之前，我们先从汇编层面看看基于栈帧的方法调用是怎样的。（以 IA32 型 CPU 指令集为例）&lt;/p&gt;
&lt;p&gt;IA32 的程序中使用栈帧数据结构来支持过程调用（Java 语言中称作方法），每个过程对应一个栈帧，过程的调用对应与栈帧的入栈和出栈。某个时刻，只有位于栈顶的栈帧可用，它代表了某个方法正在执行中的各种状态。最顶端的栈帧用两个指针界定，栈指针，帧指针。他们对应于栈中的地址分别存储在寄存器 &lt;strong&gt;%ebp&lt;/strong&gt; 和 &lt;strong&gt;%esp&lt;/strong&gt; 中。栈中的大致结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/03/28/9XDl0e.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;栈指针始终指向栈顶元素，控制着栈中元素的出入栈，帧指针指向的是当前栈帧的底部，注意是当前栈帧，不是整个栈的底部。&lt;/p&gt;
&lt;p&gt;下面我们看看一段 C 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
void sayHello(int age)
{
    int x = 32;
    int y = 2323;
    age = x + y;
}

void main()
{
    int age = 22;
    sayHello(age);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单的一段代码，我们汇编生成相应的汇编代码，省略了部分链接代码，留下的是核心的部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $20, %esp
    movl    $22, -4(%ebp)
    movl    -4(%ebp), %eax
    movl    %eax, (%esp)
    call    sayHello
    leave
    ret
    
sayHello:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $16, %esp
    movl    $32, -4(%ebp)
    movl    $2323, -8(%ebp)
    movl    -8(%ebp), %eax
    movl    -4(%ebp), %edx
    addl    %edx, %eax
    movl    %eax, -12(%ebp)
    leave
    ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看 main 函数的汇编代码，main 函数里的前两个汇编指令和 sayHello 中的前两条指令是一样的，我们在留到后者里介绍。&lt;/p&gt;
&lt;p&gt;subl 指令将寄存器 %esp 中的地址减去 20，即栈指针向上扩展了 20 个字节（栈是倒着生长的），也就是为当前栈帧分配了 20 个字节大小。接着，movl 将值 20 写入地址 &lt;strong&gt;-4(%ebp)&lt;/strong&gt;，这个地址其实就是相对寄存器 %ebp 帧指针位置之上的四个字节处。假如 %ebp 的值为：0x14，那么 20 就被存储到地址 0x10 的栈地址中。&lt;/p&gt;
&lt;p&gt;接着一条 movl 指令将参数 age 的值取出来存入寄存器 %eax 中。&lt;/p&gt;
&lt;p&gt;这时就到了核心的 call 方法了，计算机中有程序计数器（PC）来指向下一条指令的位置，而常常我们的程序会调用到其他方法里，那么调用结束后又该如何恢复调用前的状态并继续执行呢？&lt;/p&gt;
&lt;p&gt;这里的解决办法是，call 指令的第一步就是将&lt;strong&gt;返回地址&lt;/strong&gt;压栈，然后跳向 sayHell 方法中执行，这里我们看不到它压栈的过程，被集成为一条指令了。&lt;/p&gt;
&lt;p&gt;然后跳向了 sayHello 方法的第一条指令开始执行，pushl 将寄存器 %ebp 中的地址压栈，这时候的 %ebp 是上一个栈帧的帧指针地址，这个操作其实是一个保存的动作。然后，movl 指令将帧指针指向栈指针的位置，也就是栈顶位置，继而将栈指针向上扩展 16 个字节。&lt;/p&gt;
&lt;p&gt;接着，将数值 32 和 2323 分别写入不同的栈地址中，这个地址相对于帧指针的地址，是可以计算出来的。&lt;/p&gt;
&lt;p&gt;后面的操作是将 x 和 y 分别写入寄存器 %eax 和 %edx，然后 add 指令做加法运算并存入寄存器 %eax 中。接着将结果压栈。&lt;/p&gt;
&lt;p&gt;leave 指令等效于以下两条指令之和：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;movl %ebp %esp
popl %ebp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么意思呢？&lt;/p&gt;
&lt;p&gt;把栈指针退回到帧指针的位置，也就是当前栈帧的底部，接着弹栈，这样的话整个 sayHello 所占用的栈帧就已经无法引用了，相当于释放了当前栈帧。&lt;/p&gt;
&lt;p&gt;ret 指令用于恢复调用前的状态，继续执行 main 方法。&lt;/p&gt;
&lt;p&gt;整个 IA32 的方法调用基本如上，对于 64 位的 x86-64 来说，增加了 16 个寄存器，优先使用寄存器进行参数的计算与传递，效率提高了。但是与这个基于栈的存储方式来说，劣势之处在于「可移植性差」，不同的机器的寄存器使用肯定是有所差别的。所以我们的 Java 毋庸置疑使用的是栈。&lt;/p&gt;
&lt;h3 id=&quot;运行时栈帧结构&quot;&gt;运行时栈帧结构&lt;/h3&gt;
&lt;p&gt;在 Java 中，一个栈帧对应一个方法调用，方法中需涉及到的局部变量、操作数，返回地址等都存放在栈帧中的。每个方法对应的栈帧大小在编译后基本已经确定了，方法中需要多大的局部变量表，多深的操作数栈等信息早以被写入方法的 Code 属性中了。所以运行期，方法的栈帧大小早已固定，直接计算并分配内存即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局部变量表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;局部变量表用来存放方法运行时用到的各种变量，以及方法参数。虚拟机规范中指明，局部变量表的容量用变量槽（slot）为最小单位，却没有指明一个 slot 的实际空间大小，只是说，每个 slot 应当能够存放任意一个 boolean，byte，char，short，int，float，reference 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照我的理解，一个 slot 相当于一个黑盒子，具体占几个字节适情况而定，但是这个黑盒子明确可以保存一个任意类型的变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;局部变量表不同于操作数栈，它采用索引机制访问元素，而不同于操作数栈的出入栈方式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void sayHello(String name){
        int x = 23;
        int y = 43;
        x++;
        x = y - 2;
        long z = 234;
        x = (int)z;
        String str = new String(&quot;hello wrold &quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们反编译看看它的局部变量表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/03/28/9XORij.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，局部变量表第一项是名为 this 的一个类引用，它指向堆中当前对象的引用。接着就是我们的方法参数，局部变量 x，y，z 和 str。&lt;/p&gt;
&lt;p&gt;这其实也间接说明了，我们的每个实例方法都默认传入了一个参数 this，指向当前类的实例引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作数栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作数栈也称作操作栈，它不像局部变量表采用的索引机制访问其中元素，而是标准的栈操作，入栈出栈，先入后出。操作数栈在方法执行之初为空，随着方法的一步一步运行，操作数栈中将不停的发生入栈出栈操作，直至方法执行结束。&lt;/p&gt;
&lt;p&gt;操作数栈是方法执行过程中很重要的一个部分，方法执行过程中各个中间结果都需要借助操作数栈进行存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个方法在调用另一个方法结束之后，需要返回调用处继续执行后续的方法体。那么调用其他方法的位置点就叫做「返回地址」，我们需要通过一定的手段保证，CPU 执行其他方法之后还能返回原来调用处，进而继续调用者的方法体。&lt;/p&gt;
&lt;p&gt;正如我们一开始介绍的汇编代码一样，这个返回地址往往会被提前压入调用者的栈帧中，当方法调用结束时，取出栈顶元素即可得到后续方法体执行入口。&lt;/p&gt;
&lt;h3 id=&quot;方法调用&quot;&gt;方法调用&lt;/h3&gt;
&lt;p&gt;方法调用算是本篇的一个核心内容了，它解决了虚拟机对目标调用方法的确定问题，因为往往一条虚拟机指令要求调用某个方法，但是该方法可能会有重载，重写等问题，那么虚拟机又该如何确定调用哪个方法呢？这就是本阶段要处理的唯一任务。&lt;/p&gt;
&lt;p&gt;首先我们要谈谈这个解析过程，从上篇文章中可以知道，当一个类初次加载的时候，会在解析阶段完成常量池中符号引用到直接引用的替换。这其中就包括方法的符号引用翻译到直接引用的过程，但这只针对部分方法，有些方法只有在运行时才能确定的，就不会被解析。我们称在类加载阶段的解析过程为「静态解析」。&lt;/p&gt;
&lt;p&gt;那么哪些方法是被静态解析了，哪些方法需要动态解析呢？&lt;/p&gt;
&lt;p&gt;比如下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object obj = new String(&quot;hello&quot;);
obj.equals(&quot;world&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Object 类中有一个 equals 方法，String 类中也有一个 equals 方法，上述程序显然调用的是 String 的 equals 方法。那么如果我们加载 Object 类的时候将 equals 符号引用直接指向了本身的 equals 方法的直接引用，那么上述的 obj 永远调用的都是 Object 的 equals 方法。那我们的多态就永远实现不了。&lt;/p&gt;
&lt;p&gt;只有那些，「编译期可知，运行时不变」的方法才可以在类加载的时候将其进行静态解析，这些方法主要有：&lt;strong&gt;private 修饰的私有方法，类静态方法，类实例构造器，父类方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其余的所有方法统称为「虚方法」，类加载的解析阶段不会被解析。这些方法的调用不存在问题，虚拟机直接根据直接引用即可找到方法的入口，但是「非虚方法」就不同了，虚拟机需要用一定的策略才能定位到实际的方法，下面我们一起来看看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态分派&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Father {
}
public class Son extends Father {
}
public class Daughter extends Father {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class Hello {
    public void sayHello(Father father){
        System.out.println(&quot;hello , i am the father&quot;);
    }
    public void sayHello(Daughter daughter){
        System.out.println(&quot;hello i am the daughter&quot;);
    }
    public void sayHello(Son son){
        System.out.println(&quot;hello i am the son&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    Father son = new Son();
    Father daughter = new Daughter();
    Hello hello = new Hello();
    hello.sayHello(son);
    hello.sayHello(daughter);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello , i am the father&lt;/p&gt;
&lt;p&gt;hello , i am the father&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道你答对了没有？这是一道很常见的面试题，考的就是你对方法重载的理解以及方法分派逻辑懂不懂。下面我们来分析一下：&lt;/p&gt;
&lt;p&gt;首先需要介绍两个概念，「静态类型」和「实际类型」。静态类型指的是包装在一个变量最外层的类型，例如上述 Father 就是所谓的静态类型，而 Son 或是 Daughter 则是实际类型。&lt;/p&gt;
&lt;p&gt;我们的编译器在生成字节码指令的时候会根据变量的&lt;strong&gt;静态类型&lt;/strong&gt;选择调用合适的方法。就我们上述的例子而言：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/03/28/9jPSX9.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个方法就是我们 main 函数中调用的两次 sayHello 方法，但是你会发现传入的参数类型是相同的，&lt;strong&gt;Father&lt;/strong&gt;，也就是调用的方法是相同的，都是这个方法：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;(LStaticDispathch/Father;)V&lt;/p&gt;
&lt;p&gt;也就是&lt;/p&gt;
&lt;p&gt;public void sayHello(Father father){}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有依赖静态类型来定位方法执行版本的分派动作称作「静态分派」，而方法重载是静态分派的一个典型体现。但需要注意的是，静态分派不管你实际类型是什么，它只根据你的静态类型进行方法调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态分派&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Father {
    public void sayHello(){
        System.out.println(&quot;hello world ---- father&quot;);
    }
}
public class Son extends Father {
    @Override
    public void sayHello(){
        System.out.println(&quot;hello world ---- son&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    Father son = new Son();
    son.sayHello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello world ---- son&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然，最终调用了子类的 sayHello 方法，我们看生成的字节码指令调用情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/03/29/9jn4L8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/03/29/9jnIeS.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没？编译器为我们生成的方法调用指令，选择调用的是静态类型的对应方法，但是为什么最终的结果却调用了是实际类型的对应方法呢？&lt;/p&gt;
&lt;p&gt;当我们将要调用某个类型实例的具体方法时，会首先将当前实例压入操作数栈，然后我们的 invokevirtual 指令需要完成以下几个步骤才能实现对一个方法的调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;弹出操作数栈顶部元素，判断其实际类型，记做 C&lt;/li&gt;
&lt;li&gt;在类型 C 中查找需要调用方法的简单名称和描述符相同的方法，如果有则返回该方法的直接引用&lt;/li&gt;
&lt;li&gt;否则，向 C 的父类再做搜索，有即返回方法的直接引用&lt;/li&gt;
&lt;li&gt;否则，抛出异常 java.lang.AbstractMethodError 异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们此处的示例调用的是子类 Son 的 sayHello 方法就不言而喻了。&lt;/p&gt;
&lt;p&gt;至于虚拟机为什么能这么准确高效的搜索某个类中的指定方法，各个虚拟机的实现各有不同，但最常见的是使用「虚方法表」，这个概念也比较简单，就是为每个类型都维护一张方法表，该表中记录了当前类型的所有方法的描述信息。于是虚拟机检索方法的时候，只需要从方法表中进行搜索即可，当前类型的方法表中没有就去父类的方法表中进行搜索。&lt;/p&gt;
&lt;h3 id=&quot;动态类型特性的支持&quot;&gt;动态类型特性的支持&lt;/h3&gt;
&lt;p&gt;动态类型语言的一个关键特征就是，&lt;strong&gt;类型检查发生在运行时&lt;/strong&gt;。也就是说，编译期间编译器是不会管你这个变量是什么类型，调用的方法是否存在的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object obj = new String(&quot;hello-world&quot;);
obj.split(&quot;-&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 中，两行代码是不能通过编译器的，原因就是，编译器检查变量 obj 的静态类型是 Object，而 Object 类中并没有 subString 这个方法，故而报错。&lt;/p&gt;
&lt;p&gt;而如果是动态类型语言的话，这段代码就是没问题的。&lt;/p&gt;
&lt;p&gt;静态语言会在编译期检查变量类型，并提供严格的检查，而动态语言在运行期检查变量实际类型，给了程序更大的灵活性。各有优劣，静态语言的优势在于安全，缺点在于缺乏灵活性，动态语言则是相反的。&lt;/p&gt;
&lt;p&gt;JDK1.7 提供了两种方式来支持 Java 的动态特性，invokedynamic 指令和 java.lang.invoke 包。这两者的实现方式是类似的，我们只介绍后者的基本内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//该方法是我自定义的，并非 invoke 包中的
public static MethodHandle getSubStringMethod(Object obj) throws NoSuchMethodException, IllegalAccessException {
    //定义了一个方法模板，规定了待搜索的方法的返回值和参数类型
    MethodType methodType = MethodType.methodType(String[].class,String.class);
    //查找符合指定方法简单名称和模板信息的方法
    return lookup().findVirtual(obj.getClass(),&quot;split&quot;,methodType).bindTo(obj);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args){
    Object obj = new String(&quot;hello-world&quot;);
    //定位方法，并传入参数执行方法
    String[] strs = (String[]) getSubStringMethod(obj).invokeExact(&quot;-&quot;);
    System.out.println(strs[0]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你看，虽然我们 obj 的静态类型是 Object，但是通过这种方式，我就是能够越过编译器的类型检查，直接在运行期执行我指定的方法。&lt;/p&gt;
&lt;p&gt;具体如何实现的我就不带大家看了，比较复杂，以后有机会单独写一篇文章学习一下。反正通过这种方式，我们可以不用管一个变量的静态类型是什么，只要它有我想要调的方法，我们就可以在运行期直接调用。&lt;/p&gt;
&lt;p&gt;总结一下，HotSpot 虚拟机基于操作数栈进行方法的解释执行，所有运算的中间结果以及方法参数等等，基本都伴随着出入栈的操作取出或存储。这种机制最大的优势在于，&lt;strong&gt;可移植性强&lt;/strong&gt;。不同于基于寄存器的方法执行机制，对底层硬件依赖过度，无法很轻易的跨平台，但是劣势也很明显，&lt;strong&gt;就是同样的操作需要相对更多的指令才能完成。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章中的所有代码、图片、文件都云存储在我的 GitHub 上：&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/SingleYam/overview_java&quot; class=&quot;uri&quot;&gt;https://github.com/SingleYam/overview_java&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：扑在代码上的高尔基，所有文章都将同步在公众号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180305113628126?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 07:37:00 +0000</pubDate>
<dc:creator>一只黑色的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/8670148.html</dc:identifier>
</item>
<item>
<title>Java面试总结（二） - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/8659977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/8659977.html</guid>
<description>&lt;p&gt;前几天去了几家公司面试，果然，基本全部倒在二面上，无语啊。。。不过幸好，到最后拿到了环球易购的offer，打算就这么好好呆着了，学习学习，努力努力，下面讲讲这几天的面试吧。&lt;br/&gt;　　先是恒大，一个组长面试，答的很一般吧，有些问题是确实不知道题意，如何设计一个多线程，用来表示一个红绿灯和车流的关系；还有人走迷宫的时候，如何用一个设计模式表示人的多样性和路的多样性；还有就是如何大批量向数据库插入数据，这个之前没关注过，没答出来，有点遗憾。还有就是薪资问题，来之前我以为恒大，这么牛逼的公司，要不要提高一下薪资要求，不过为了稳妥还是继续9-10k，面试官说刚毕业的，这边只能给到8k左右啊，，，，就这样，挂了。&lt;br/&gt;　　达飞金控一面问的问题真的太基础，基础到有点吓人，差不多也是那种set、list、map区别，抽象和接口什么的，答得一般吧。由于面试官在开会，开到了12点多，然后继续面试，同时还有另一个面试的在等，二面也聊得还算是蛮顺畅，问了如果不小心发送了两个重复的请求，由于不同机房，数据同步需要时间，那么如何解决这个请求；还有就是在一段文字中找出出现次数最多的字谜，总体上来的还算是一般偏上吧，答得也七七八八，然后就1点了，还有另外一个人在等面试，最后说等消息，到现在也没消息，又挂了。。。。蛇口那边的环境确实不错，面完下楼，好多外国人。还有就是达飞准备招人做风控、电商方面的业务，有需要的可以投一下。&lt;br/&gt;　　联想的有点，，，对着一张纸的题直接说出答案，这个面试官说答的还不错，然后是手写sql和上机笔试，sql没写对（考察分页，group by，having），其实不难的，只是平时不注意，上机的题也没全做出来（考察Java日期类的使用，有点古老），不过还好有个自己的网站二面还是过了，三面，额，可能做得东西跟自己想的不一样，当我说我想做分布式、高并发、高可用的东西之后，然后还问了部门manager并发量有多大，他说主要是给内部使用的，所以并发量不打，然后说等消息吧，就这么挂了，据说联想2020年在后海会落成一栋楼，感觉屌屌的，可惜了。。。。&lt;br/&gt;&lt;strong&gt;永远挂在二面的我啊&lt;/strong&gt;&lt;br/&gt;　　深圳想去的公司并且招人的，基本投完了，然后这么多都是倒在了二面，有点不甘心吧。在boss上偶然看到环球易购在招人，而且一直是自己梦寐以求的电商行业，就在boss上找环球易购的那些技术负责人，一个一个问，还好有位大佬理我，虽然不合适，但帮忙推到了另一个组，然后等HR电话，一直没答来，所以只能一直贯彻自己的方针：成功的三要素是，一坚持，二不要脸，三坚持不要脸，一直请问那位技术大佬，虽然特别不好意思。我们经常说，千里马常有而伯乐不常有，那么一只不要脸的普通马就只能自己争取了23333。&lt;br/&gt;　　周一去了环球易购，面试官挺直接的，感觉好像大概知道我实力如何什么的，直接问难度稍微大一点点的问题，有点慌，而且回答的也不是太好，双亲委派还记反了（尴尬），然后是部门经理，这个我回答的更惨，惨不忍睹，问了tomcat如何解析一个请求，意思是tomcat源码看过没，，，，真的超级慌，当初看了一会源码就没坚持下去直接放弃了。不过还好能HR面了（终于有家公司是HR面了），中间件毕竟是我特别想整的东西。周三接到了offer，开心的一晚睡不着（加上没工作作息时间混乱），导致今天体检血压一直高，，，，现在真是超级累。&lt;br/&gt;　　这年头找工作真的很累，最好不要像我一样裸辞，找不到工作心里真的很不舒服的，特别容易心态爆炸，有时候觉得自己表现的还不错，但就是没过，很离谱的那种，毕竟面试，运气缘分什么的占比更重。我是因为在上家公司加班太严重，而且任务太忙，根本没时间面试和学习所以裸辞的。&lt;br/&gt;　　下面是自己印象深刻的题吧，有面试的可以参考参考，答案不一定准确，因为我自己也是半斤八两，也欢迎大家帮忙提醒一下。&lt;/p&gt;
&lt;h3 id=&quot;mq事务如果消费者消费了如何回滚&quot;&gt;1.MQ事务，如果消费者消费了，如何回滚&lt;/h3&gt;
&lt;p&gt;　　分布式事务，是我计划下下一阶段要看的东西（下一个是分布式锁），没想到这么快就被问到了，最初看的不过也就CAP、BASE、2PC、3PC这些，MQ事务真的很少接触。即使没学过，那就按自己的理解来吧。假设有三个事务：A、B、C。&lt;br/&gt;（1）如果三个事务之前不需要彼此的依赖，可以执行完A的时候向消息队列发送一个prepareA，同理，B、C也一样，如果三个事务在本地都执行成功了，那么发送一次success，然后事务prepareA、prepareB、prepareC开始执行，如果有一个失败，则直接回滚所有。&lt;br/&gt;（2）如果事务B需要依赖A的结果、C需要依赖B的结果，那么A执行完后再执行B，B执行完再执行C，到最后，其中如果有一个失败，则回滚重试。&lt;br/&gt;　　这一块是真没接触过，即使百度了，感觉也有点抽象，还是先把ZooKeeper的分布式锁看完再整分布式事务的东西吧。百度的时候看到了一个比较类似的想法，说的比我好，可以看看。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201803270401061454579072.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/716d3ec567c0&quot;&gt;分布式事务之最终一致的Mq实现&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html&quot;&gt;聊聊分布式事务，再说说解决方案&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主线程如何捕获子线程的异常&quot;&gt;2.主线程如何捕获子线程的异常&lt;/h3&gt;
&lt;p&gt;　　这道题不是很理解他的意思，try catch不就行了？他说不是这个意思，我说用线程池的话可以用callable异步返回异常结果，他说这个不算吧，一脸懵逼的状态，事后百度了下发现考点是UncaughtExceptionHandler。。。大概意思就是把线程交给线程组，然后再线程组里重写异常捕获方法，即可在主线程捕获子线程的异常了，例子如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ThreadExcep &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ThreadGroup {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ThreadExcep&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;线程组的名字&quot;&lt;/span&gt;);
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;uncaughtException&lt;/span&gt;(Thread thread, Throwable exception) {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(thread.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
        exception.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;//example,   print   stack   trace&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        ThreadExcep excep = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ThreadExcep&lt;/span&gt;();
        Thread thread = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(excep, () -&amp;gt; {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;st&quot;&gt;&quot;空指针异常&quot;&lt;/span&gt;);
        });
        thread.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;11
java.lang.NullPointerException: 空指针一场
    at com.study.exception.ThreadExcep.lambda$main$0(ThreadExcep.java:26)
    at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而如果去掉exception.printStackTrace()，程序是不打印报错信息的。原因可以总结如下：&lt;br/&gt;（1）如果在主线程中创建一个子线程，默认情况下这两个线程同属于一个线程组，如果子线程发生异常，主线程可以直接使用try catch捕获的到。&lt;br/&gt;（2）同样是在主线程中创建一个子线程，如果声明了这个子线程是另一个线程组的，即调用了new Thread(ThreadGroup group, Runnable target)，则主线程中是无法直接捕获到子线程的发生的异常的，不过可以通过在声明一个线程组重写uncaughtException，然后把子线程放进去。&lt;br/&gt;不管怎么说，在主线程中捕获子线程的异常一般是不推荐的，&lt;strong&gt;线程设计的理念：“线程的问题应该线程自己本身来解决，而不要委托到外部。”&lt;/strong&gt;&lt;br/&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u013177446/article/details/53995040&quot;&gt;【Java 多线程】Java中主线程如何捕获子线程抛出的异常&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大批量插入数据库如何优化&quot;&gt;3.大批量插入数据库如何优化&lt;/h3&gt;
&lt;p&gt;　　大批量，之前都没怎么注意过，这个问题确实不会，网上参考了下别人的，大体上是这个意思：合并数据+事务的方法在较小数据量时，性能提高是很明显的，数据量较大时（1千万以上），性能会急剧下降，这是由于此时数据量超过了innodb_buffer的容量，每次定位索引涉及较多的磁盘读写操作，性能下降较快。而使用合并数据+事务+有序数据的方式在数据量达到千万级以上表现依旧是良好，在数据量较大时，有序数据索引定位较为方便，不需要频繁对磁盘进行读写操作，所以可以维持较高的性能。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201803270734461668777153.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_22855325/article/details/76087138&quot;&gt;数据库大批量SQL插入性能优化&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;spring-bean的生命周期&quot;&gt;4.Spring Bean的生命周期&lt;/h3&gt;
&lt;p&gt;　　Spring的源码确实要找个时间好好看看了，下面的是参考自《Spring实战的》内容。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20180327074909821094021.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;主要流程如下：&lt;br/&gt;(1).Spring对Bean进行实例化（相当于程序中的new Xx()）&lt;br/&gt;(2).Spring将值和Bean的引用注入进Bean对应的属性中&lt;br/&gt;(3).如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法（实现BeanNameAware清主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的）&lt;br/&gt;(4).如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等）&lt;br/&gt;(5).如果Bean实现了ApplicationContextAwaer接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把y应用上下文作为参数传入.(作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory )&lt;br/&gt;(6).如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）&lt;br/&gt;(7).如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。&lt;br/&gt;(8).如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )&lt;br/&gt;(9).经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁&lt;br/&gt;(10).如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法，作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;1.《Spring实战》&lt;br/&gt;2.&lt;a href=&quot;https://www.zhihu.com/question/38597960&quot;&gt;Spring中Bean的生命周期是怎样的？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;tomcat是如何解析一个请求的&quot;&gt;5.Tomcat是如何解析一个请求的&lt;/h3&gt;
&lt;p&gt;万万没想到啊，自己曾经研究过一点点tomcat的源码，现在却忘光了，留张图先吧，之后写源码分析的系列。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/201803270347291600753740.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;代理模式spring&quot;&gt;6.代理模式（Spring）&lt;/h3&gt;
&lt;p&gt;这题之后看Spring源码的时候再总结了。&lt;/p&gt;
&lt;h3 id=&quot;java类里的静态变量在jvm中哪个区&quot;&gt;7.Java类里的静态变量在JVM中哪个区&lt;/h3&gt;
&lt;p&gt;JDK8之前，静态成员变量确实存放在方法区；但JDK8之后就取消了“永久代”，取而代之的是“元空间”，永久代中的数据也进行了迁移，静态成员变量迁移到了堆中（方法区是JVM的规范，永久代是方法区的具体实现）。&lt;/p&gt;
&lt;h3 id=&quot;orm的好处为什么使用orm&quot;&gt;8.ORM的好处，为什么使用ORM&lt;/h3&gt;
&lt;p&gt;惊不惊喜，意不意外，大部分人都在用ORM，但是却很少关注为什么吧。Object-Relationl Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 。&lt;br/&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;br/&gt;（1）方便的使用面向对象来进行额外的操作，语句清晰&lt;br/&gt;（2）防注入&lt;br/&gt;（3）方便动态构造语句，对于不同的表的相同操作采用多态实现更优雅&lt;br/&gt;（4）一定程度方便重构数据层『比如改表名，字段名等』&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br/&gt;（1）不太容易处理复杂查询语句&lt;br/&gt;（2）性能较直接用SQL差，毕竟有个转化过程更。&lt;/p&gt;

&lt;p&gt;这些日子的面试过程，有基础的，有广度的，也暴露了自己很多很多缺点，2018还得继续努力，最怕的是比你厉害的人还比你努力吧，不过怎么说，希望各位在求职稳住心态，猥琐发育，前程似锦。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 07:29:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/8659977.html</dc:identifier>
</item>
<item>
<title>控制反转（ IoC）和依赖注入（DI） - vinter_he</title>
<link>http://www.cnblogs.com/vinter/p/8670032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vinter/p/8670032.html</guid>
<description>&lt;p&gt;tags： 容器 依赖注入 IOC DI 控制反转&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;引言：如果你看过一些框架的源码或者手册，像是laravel或者tp5之类的，应该会提到容器，依赖注入，控制反转等词汇。或者是某些面试官会问到这类问题。希望这篇文章能让你有所收获。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ioc控制反转-inversion-of-control&quot;&gt;1.1、IoC(控制反转 Inversion of Control)&lt;/h3&gt;
&lt;p&gt;简述：控制反转并不是一种技术，而是一种&lt;strong&gt;设计思想&lt;/strong&gt;。通过控制反转容器（以后称容器），改变了原本某些对象运行时依赖其他对象资源时需要自己进行获取（比如通过new ClassName），所造成的对象之间的强耦合（耦合的概念如果不理解，可以先去了解一下。）。&lt;/p&gt;
&lt;p&gt;　　所谓IoC，对于程序来说，就是构造了一个容器，比如在tp5中，这个容器叫Container，此容器来负责控制对象和对象间的关系。在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个），这样的话一个对象A和另一个对象B之间就有了很强的联系（也就是强耦合）。这种耦合体现在如果被依赖的资源类初始化的时候（也可能是其他时候）传入的参数变化了，你要修改两个类的代码，举例说明：&lt;br/&gt;　　&lt;br/&gt;&lt;em&gt;你本来用的是php本身的session机制，现在想改成也支持redis，并在初始化的时候增加一个参数来控制。这个时候你不止需要去修改类Session类的代码，还要去修改类A的代码。部分代码如下&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;co&quot;&gt;//原代码&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Session{
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;//balabala&lt;/span&gt;
    }
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;A&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;{
       &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;driver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Session&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    }
}

&lt;span class=&quot;co&quot;&gt;//需要增加一种redis方式后修改为&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Session{
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;string &lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt;=&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt; === &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
            &lt;span class=&quot;co&quot;&gt;//balabala&lt;/span&gt;
        }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt; === &lt;span class=&quot;st&quot;&gt;'redis'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{&lt;span class=&quot;co&quot;&gt;//增加了一种模式&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//balabala&lt;/span&gt;
        }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
            &lt;span class=&quot;co&quot;&gt;//balabala&lt;/span&gt;
        }
        
    }
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;A&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;{
        &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;driver = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Session&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'redis'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//我想使用redis了&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，不止我们修改了B的代码，还要去修改A的代码，这样如果依赖关系多起来的话，每次修改A依赖的对象，可能要处理A中很多条代码。会造成对象之间的强耦合。所以我们可以把A需要的东西，在A之前就创建出来，并通过构造函数参数传递给A。代码如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;A&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;//我想使用redis了&lt;/span&gt;
    }
}

&lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Session&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'redis'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//我想使用redis了&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;$a&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$driver&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;   &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法下更改A依赖的所有对象都通过构造方法或者其他方法的形式给A，这些对象本身机制更改的时候就无需修改A的代码了。但是每次自己使用A的时候都去看看A需要些什么在前面都new一遍，感觉上很low啊，不如我们搞一个管家（容器），如果发现你需要什么，管家就给你什么。这样所依赖的类的创建都由容器来控制，也就是说控制对象创建的不再是引用它的对象，而是容器。对于某个具体的对象而言，以前是它控制其他对象，需要什么自己处理，现在是所有对象都被容器控制，所以控制反转是一种控制权的转移。&lt;/p&gt;
&lt;h3 id=&quot;di依赖注入-dependency-injection-container&quot;&gt;1.2、DI(依赖注入 Dependency Injection Container)&lt;/h3&gt;
&lt;p&gt;　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入，或者叫依赖注入容器）来实现的。比如还是上面的例子，对象A需要操作Session，以前我们总是要在A中自己编写代码来获得一个Session对象，有了 容器这个管家我们就只需要告诉容器，A中需要一个Session对象，至于这个Session对象怎么构造，何时构造，A不需要知道。在系统运行时，容器会在适当的时候制造一个Session，通过构造方法注射到A当中，这样就完成了对各个对象之间关系的控制，而且这种关系是松耦合的。&lt;br/&gt;　　A需要依赖 Session才能正常运行，而这个Session是由容器注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ php有一个高级特性是反射（reflection），原理这里大概说一下，&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;反射可以在php运行中，提取出关于类、方法、属性、参数，注释等的详细信息，并可以动态的调用方法和类等。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反射允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，容器就是通过反射来实现注入的。&lt;/p&gt;
&lt;p&gt;总结：&lt;br/&gt;&lt;span&gt;控制反转是说创建对象的控制权进行转移，由原来的资源需求方，转移到了容器，依赖注入是说本来是资源需求方依赖资源，现在资源需求方依赖于容器对资源的注入，可以看出来依赖注入和控制反转说的其实是一个事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;顺便提一句，目前很多框架中都离不开反射功能。容器是一个典型的例子，容器在laravel和tp5中都是核心功能之一。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 07:23:00 +0000</pubDate>
<dc:creator>vinter_he</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vinter/p/8670032.html</dc:identifier>
</item>
<item>
<title>基于node写了个工具，可以在线制作“sorry，为所欲为”的 GIF(开源) - snailteam</title>
<link>http://www.cnblogs.com/snaildev/p/8669830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snaildev/p/8669830.html</guid>
<description>&lt;p&gt;一个生成gif并添加自定义字幕的工具&lt;/p&gt;
&lt;p&gt;client 微信小程序&lt;/p&gt;
&lt;p&gt;server nodejs + express&lt;/p&gt;
&lt;p&gt;欢迎 &lt;a href=&quot;https://github.com/SnailDev/SnailDev.GifMaker&quot; target=&quot;_blank&quot;&gt;star&amp;amp;fork&lt;/a&gt; 如果您有好的commit 也可以&lt;a href=&quot;https://github.com/SnailDev/SnailDev.GifMaker&quot; target=&quot;_blank&quot;&gt;pull request&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;参考于&lt;a href=&quot;https://github.com/xtyxtyx/sorry&quot;&gt;sorry&lt;/a&gt;, 由@xtyxtyx编写&lt;/p&gt;
&lt;p&gt;但本工具并不使用aegisub为模板视频创建字幕，采用的是FFmpeg 中的filter drawtext, 另，笔者还将继续深入了解FFmpeg,争取早日实现创作自动化。&lt;/p&gt;
&lt;p&gt;可生成如下案列：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SnailDev/SnailDev.GifMaker/blob/master/src/server/public/demo/gif/1.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/SnailDev/SnailDev.GifMaker/raw/master/src/server/public/demo/gif/1.gif&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开放接口：&lt;/p&gt;
&lt;p&gt;1.获取category&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gifmaker.develophelper.com/gif/category&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.制作gif&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST https://gifmaker.develophelper.com/gif/make
Content-Type: application/x-www-form-urlencoded
Body: tplid=1&amp;amp;                         // 模板ID
        quality=1&amp;amp;                       // 画质（暂时无效）                
        content=好啊##$@?$?@$##就算你是一流工程师##$@?$?@$##就算你出报告再完美##$@?$?@$##我叫你改报告你就要改##$@?$?@$##毕竟我是客户##$@?$?@$##客户了不起啊##$@?$?@$##sorry 客户真的了不起##$@?$?@$##以后叫他天天改报告##$@?$?@$##天天改 天天改  //字幕内容（以##$@?$?@$##作为分隔符）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.返回结果&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
&lt;/span&gt;&quot;m&quot;: 0,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; code 0 successful&lt;/span&gt;
&quot;d&quot;:{        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; d data&lt;/span&gt;
    &quot;gifurl&quot;: &quot;http://gifmaker.develophelper.com/cache/1_1a322f1b7dd9633e5433d0e0152e18a6a924cb23.gif&quot;&lt;span&gt;
},
&lt;/span&gt;&quot;e&quot;: &quot;&quot;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e errMsg&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;Structure&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;├─client                    // 客户端参考微信小程序结构
│
└─server                    // 服务端
   │
   ├─data                   // 模板配置目录
   │
   ├─public                 // 静态资源目录
   │  │
   │  ├─cache               // 动态生成的gif目录
   │  │
   │  └─demo                // 示例目录
   │
   ├─test                   // 测试目录
   │
   ├─app.js                 // 主程序入口
   │
   ├─gifmaker.js            // gif创建
   │
   ├─util.js                // 工具类
   │
   └─test                   // 测试目录
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;DependOn&lt;/h2&gt;
&lt;p&gt;server&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&quot;ffmpeg-static&quot;: &quot;^2.2.0&quot;&lt;span&gt;,
&lt;/span&gt;&quot;fluent-ffmpeg&quot;: &quot;^2.1.2&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;How to Use&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;制作视频模板 放到 data/template/ 目录下&lt;/li&gt;
&lt;li&gt;给data/category.js 和data/template.js 添加相关配置&lt;/li&gt;
&lt;li&gt;将做好的demo放到 public/demo/gif/下 缩略图放到 public/demo/thumbnail/下&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Interpretation&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    filter: &lt;/span&gt;&quot;drawtext&quot;,                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; filter类型 &lt;/span&gt;
&lt;span&gt;    options: {
        &lt;/span&gt;&quot;text&quot;: &quot;我就是饿死&quot;,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本内容&lt;/span&gt;
        &quot;x&quot;: &quot;(w-text_w)/2&quot;,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本出现的横坐标&lt;/span&gt;
        &quot;y&quot;: &quot;h-text_h-4&quot;,                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本出现的纵坐标&lt;/span&gt;
        &quot;enable&quot;: &quot;between(t,0,1.04)&quot;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本出现的时间范围&lt;/span&gt;
        'fontfile': 'msyhbd.ttc',           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体文件&lt;/span&gt;
        'fontcolor': 'white',               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体颜色&lt;/span&gt;
        &quot;fontsize&quot;: &quot;14&quot;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体大小&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;更多参考 &lt;a href=&quot;http://www.ffmpeg.org/ffmpeg-filters.html#drawtext-1&quot; rel=&quot;nofollow&quot;&gt;FFmpeg Filters Documentation&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;The MIT License (MIT). Please see &lt;a href=&quot;https://github.com/SnailDev/SnailDev.GifMaker/blob/master/LICENSE&quot;&gt;LICENSE&lt;/a&gt; for more information.&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 06:54:00 +0000</pubDate>
<dc:creator>snailteam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snaildev/p/8669830.html</dc:identifier>
</item>
<item>
<title>Spring Boot + Freemarker多语言国际化的实现 - Architist</title>
<link>http://www.cnblogs.com/kaleovon/p/8669642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaleovon/p/8669642.html</guid>
<description>&lt;p&gt;最近在写一些Web的东西，技术上采用了&lt;strong&gt;Spring Boot&lt;/strong&gt; + &lt;strong&gt;Bootstrap&lt;/strong&gt; + &lt;strong&gt;jQuery&lt;/strong&gt; + &lt;strong&gt;Freemarker&lt;/strong&gt;。过程中查了大量的资料，也感受到了前端技术的分裂，每种东西都有N种实现，组合起来，每种解决方案的资料却很有限。&lt;/p&gt;
&lt;p&gt;这篇文章记录下多语言国际化的实现，以支持中英文为例。&lt;/p&gt;
&lt;h2 id=&quot;首先是页面内容的国际化&quot;&gt;首先是页面内容的国际化&lt;/h2&gt;
&lt;p&gt;1.定义页面文本配置文件的路径，在&lt;strong&gt;application.properties&lt;/strong&gt;里添加&lt;code&gt;spring.messages.basename=i18n/messages&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.在&lt;em&gt;resources/&lt;/em&gt;目录下创建上述目录，添加3个配置文件&lt;strong&gt;messages.properties&lt;/strong&gt;、&lt;strong&gt;messages_zh.properties&lt;/strong&gt;、&lt;strong&gt;messages_en.properties&lt;/strong&gt;，分别对应默认，中文和英文配置，完整路径为&lt;em&gt;resources/i18n/messages.properties&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3.在配置文件里定义每条需要国际化的文本，比如中文 &lt;code&gt;index.title=麦希工具 - 您身边的助手&lt;/code&gt;，英文&lt;code&gt;Meta Tool - Your Best Assistant&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.在Freemarker文件里使用&lt;strong&gt;&amp;lt;@spring.message &quot;&quot;/&amp;gt;&lt;/strong&gt;来输出文本，比如&lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;@spring.message &quot;index.title&quot;/&amp;gt;&amp;lt;/title&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;再说下验证内容的国际化&quot;&gt;再说下验证内容的国际化&lt;/h2&gt;
&lt;p&gt;所谓验证内容，就是比如在填Form表单的时候，有些字段有格式或数值等的要求，表单提交时，应该验证数据是否符合要求。验证又分前端验证和后端验证，一般结合使用。&lt;/p&gt;
&lt;p&gt;前端用来验证格式（必须是数字/英文/邮件）等，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input type=&quot;text&quot; name=&quot;height&quot; id=&quot;height&quot; class=&quot;form-control col-2&quot; placeholder=&quot;&quot; pattern=&quot;^[1-9][0-9]{2}$&quot; required&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里pattern使用正则表达式，定义了输入框输入字符的范围和数量。&lt;/p&gt;
&lt;p&gt;后端用来验证数值（必须大于18岁）等，可以在Spring Boot的VO对象里，以添加注解的形式实现，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Min(value = 100, message = &quot;不能低于100cm&quot;)
    @Max(value = 250, message = &quot;不能高于250cm&quot;)
    private String height;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就出现了问题，即注解也应该采用配置文件的形式，以支持多语言切换，这就是验证内容的国际化。&lt;/p&gt;
&lt;p&gt;1.定义验证文本配置文件的路径，在&lt;strong&gt;application.properties&lt;/strong&gt;里添加&lt;code&gt;spring.messages.basename=i18n/messages,i18n/ValidationMessages&lt;/code&gt;，前面的是第一节的页面文本，后面的是验证文本&lt;/p&gt;
&lt;p&gt;2.在&lt;em&gt;resources/&lt;/em&gt;目录下创建上述目录，添加3个配置文件&lt;strong&gt;ValidationMessages.properties&lt;/strong&gt;、&lt;strong&gt;ValidationMessageszh.properties&lt;/strong&gt;、&lt;strong&gt;ValidationMessages_en.properties&lt;/strong&gt;，分别对应默认，中文和英文配置，完整路径为&lt;em&gt;resources/i18n/ValidationMessages.properties&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3.在配置文件里定义每条需要国际化的文本，比如中文 &lt;code&gt;vm.bmi.height.lower=不能低于100cm&lt;/code&gt;，英文&lt;code&gt;vm.bmi.height.lower=Can Not Lower Than 100cm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.与页面文本相比，这里要多做一步，即在代码里覆盖默认验证器的配置，在代码根目录添加以下文件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomConfiguration &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; WebMvcConfigurer {

    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; MessageSource messageSource;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Validator &lt;span class=&quot;fu&quot;&gt;getValidator&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;localValidatorFactoryBean&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; LocalValidatorFactoryBean &lt;span class=&quot;fu&quot;&gt;localValidatorFactoryBean&lt;/span&gt;() {
        LocalValidatorFactoryBean validator = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LocalValidatorFactoryBean&lt;/span&gt;();
        validator.&lt;span class=&quot;fu&quot;&gt;setValidationMessageSource&lt;/span&gt;(messageSource);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; validator;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.在接收表达的VO对象的属性上，使用验证文本作为提示&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BmiVo {

    &lt;span class=&quot;fu&quot;&gt;@Min&lt;/span&gt;(value = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, message = &lt;span class=&quot;st&quot;&gt;&quot;{vm.bmi.height.lower}&quot;&lt;/span&gt;)
    &lt;span class=&quot;fu&quot;&gt;@Max&lt;/span&gt;(value = &lt;span class=&quot;dv&quot;&gt;250&lt;/span&gt;, message = &lt;span class=&quot;st&quot;&gt;&quot;{vm.bmi.height.upper}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String height;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.在表单上添加验证失败后的提示，使用&lt;strong&gt;&amp;lt;@spring.bind &quot;&quot; /&amp;gt;&lt;/strong&gt;绑定VO对象的属性，使用&lt;strong&gt;&amp;lt;@spring.showErrors &quot;&quot;/&amp;gt;&lt;/strong&gt;显示属性验证失败的提示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;div-height&quot; class=&quot;form-group form-row align-items-center&quot;&amp;gt;
        &amp;lt;@spring.bind &quot;vo.height&quot; /&amp;gt;
        &amp;lt;label for=&quot;height&quot; class=&quot;col-form-label text-center offset-3 col-2&quot;&amp;gt;&amp;lt;@spring.message &quot;bmi.height&quot;/&amp;gt;&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;text&quot; name=&quot;height&quot; id=&quot;height&quot; class=&quot;form-control col-2&quot; placeholder=&quot;&quot; pattern=&quot;^[1-9][0-9]{2}$&quot; required&amp;gt;
        &amp;lt;span class=&quot;text-primary text-center col-1&quot;&amp;gt;cm&amp;lt;/span&amp;gt;
        &amp;lt;span class=&quot;text-danger col-4&quot;&amp;gt;&amp;lt;@spring.showErrors &quot;&quot;/&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就做到了页面内容和验证内容的多语言国际化支持，具体示例参看&lt;a href=&quot;http://metazion.net/&quot;&gt;Meta Tool&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 06:29:00 +0000</pubDate>
<dc:creator>Architist</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaleovon/p/8669642.html</dc:identifier>
</item>
<item>
<title>Sagit.Framework For IOS 开发框架入门教程6：网络请求STHttp - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/8665502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/8665502.html</guid>
<description>&lt;p&gt;IOS的文章，今天，再来补一篇，Sagit的教程；&lt;/p&gt;
&lt;p&gt;虽然感觉IOS的文章没什么观众，还是努力写吧，-_-〜&lt;/p&gt;
&lt;p&gt;Sagit 开源地址：&lt;a href=&quot;https://github.com/cyq1162/Sagit&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/Sagit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天主要是分享网络请求，即STHttp的用法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201803/17408-20180328181058646-548125255.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;STHttp为处理网络API请求的功能的源码。&lt;/p&gt;

&lt;p&gt;对于网络请求，Sagit目前是对AFNetworking做了一下二次封装！&lt;/p&gt;
&lt;p&gt;所以框架里有引用到这个第三方组件。&lt;/p&gt;
&lt;p&gt;封装完后，目前对外调用的API：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;void&lt;/span&gt;(^Success)(STModel *&lt;span&gt;result);
typedef &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(^Error)(NSString *&lt;span&gt;errMsg);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!提供基础的网络请求（get、post、upload(图片上传））&lt;/span&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; STHttp : NSObject

@property (nonatomic,strong) STMsgBox &lt;/span&gt;*&lt;span&gt;msgBox;

&lt;/span&gt;- (instancetype)init:(STMsgBox*&lt;span&gt;)msgBox;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)&lt;span&gt;get&lt;/span&gt;:(NSString *)url paras:(NSDictionary *&lt;span&gt;)paras success:(Success)succese;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)&lt;span&gt;get&lt;/span&gt;:(NSString *)url paras:(NSDictionary *&lt;span&gt;)paras success:(Success)success error:(Error)error;

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)post:(NSString *)url paras:(NSDictionary *&lt;span&gt;)paras success:(Success)success;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)post:(NSString *)url paras:(NSDictionary *&lt;span&gt;)paras success:(Success)success error:(Error)error;

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)upload:(NSString *)url data:(NSData *&lt;span&gt;)data success:(Success)success;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)upload:(NSString *)url data:(NSData *&lt;span&gt;)data success:(Success)success error:(Error)error;

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)upload:(NSString *)url paras:(NSDictionary *&lt;span&gt;)paras success:(Success)success;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)upload:(NSString *)url paras:(NSDictionary *&lt;span&gt;)paras success:(Success)success error:(Error)error;
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)setHeader:(NSString*)key v:(NSString*&lt;span&gt;)value;

&lt;/span&gt;+&lt;span&gt; (instancetype)share;
&lt;/span&gt;+&lt;span&gt; (instancetype)shareWithLoading;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;-(void)networkState;&lt;/span&gt;
&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有三个常用的方法：get、post、upload（图片）。&lt;/p&gt;

&lt;p&gt;对于该类的调用方式，有两种&lt;/p&gt;
&lt;h2&gt;1､在继承自STController的控制器下，直接用[self.http ...]&lt;/h2&gt;
&lt;p&gt;STController这个基类，默认实现的有两个子类接口（msgBox：消息弹窗、http：网络请求）&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[self.http &lt;span&gt;get&lt;/span&gt;:UrlQuestionRank paras:nil success:^(STModel *&lt;span&gt;result) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.success)
        {
            NSMutableArray&lt;/span&gt;&amp;lt;&lt;span&gt;id&lt;/span&gt;&amp;gt; *data=(NSMutableArray&amp;lt;&lt;span&gt;id&lt;/span&gt;&amp;gt;*)result.msg[&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            STFirstTable.source&lt;/span&gt;=&lt;span&gt;data;
            [STFirstTable reloadData];
        }
    }];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2､在任意地方，都可以全局的调用：用[Sagit.Http ...]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Sagit，是一个总类库的起始名称空间，很多常用功能，都是由Sagit打开头开始，后续会单独介绍。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取积分&lt;/span&gt;
                [Sagit.Http &lt;span&gt;get&lt;/span&gt;:UrlIntegralShareBlog paras:nil success:^(STModel *&lt;span&gt;result)
                 {
                     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result.success &amp;amp;&amp;amp;&lt;span&gt; result.msg)
                     {
                         NSString &lt;/span&gt;*data=(NSString*&lt;span&gt;)result.msg;
                         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &amp;amp;&amp;amp;&lt;span&gt; data.isInt)
                         {
                             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改当前积分总数&lt;/span&gt;
                             Sagit.Global.User.user.Integral=&lt;span&gt;data.integerValue;
                         }
                     }
                 }];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面，会和大伙分享 &lt;a href=&quot;http://www.itlinks.cn/&quot; target=&quot;_blank&quot;&gt;IT连App&lt;/a&gt; 中，应用到该相关的代码：&lt;/p&gt;
&lt;h3&gt;A、get用法：加载用户信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-(&lt;span&gt;void&lt;/span&gt;)loadUserInfo:(NSString*&lt;span&gt;)userID  loadComplete:(LoadComplete)loadComplete
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;[NSString isNilOrEmpty:self.Token])
    {
        NSMutableDictionary &lt;/span&gt;*dic=&lt;span&gt;nil;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;[NSString isNilOrEmpty:userID])
        {
            dic&lt;/span&gt;=@{&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UserID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:userID};
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测有没有缓存&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(userID)
        {
            PersonalModel &lt;/span&gt;*mode=[Sagit.Cache &lt;span&gt;get&lt;/span&gt;&lt;span&gt;:userID];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(mode)
            {
                loadComplete(mode);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
        [Sagit.Http &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;:UrlUserInfo paras:dic success:^(STModel *&lt;span&gt;result)
         {
             PersonalModel &lt;/span&gt;*user=&lt;span&gt;nil;
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(result.success)
             {
                 user &lt;/span&gt;=&lt;span&gt; [[PersonalModel alloc] initWithObject:result.msg];
             }
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(user &amp;amp;&amp;amp; userID==nil){self.User=&lt;span&gt;user;}
             &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
             {
                 [Sagit.Cache &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;:userID value:user];
             }
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(loadComplete!=&lt;span&gt;nil)
             {
                loadComplete(user);
             }
             
         }];
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(loadComplete!=&lt;span&gt;nil)
    {
        loadComplete(nil);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;木有效果图〜&lt;/p&gt;
&lt;h3&gt;B、post用法：登陆账号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)LoginClick:(UIButton *&lt;span&gt;)sender {
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(![self isMatch:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;手机号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; regex:RexMobile]
       &lt;/span&gt;|| ![self isMatch:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; regex:nil]
      )
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    NSMutableDictionary &lt;/span&gt;*para =&lt;span&gt; [self formData];
    [para setValue:@(UserAccountType) forKey:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;AccountType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    
    [self.http post:UrlLogin paras:para success:&lt;/span&gt;^(STModel *&lt;span&gt;result)
     {
         
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.success) {
            Sagit.Global.Token&lt;/span&gt;=(NSString *&lt;span&gt;)result.msg;
            [STNew(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;MainController&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) asRoot];
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            [self.msgBox prompt:(NSString &lt;/span&gt;*&lt;span&gt;)result.msg];
        }
    }];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;界面图：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201803/17408-20180328190424269-2131991345.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;C、upload用法：上传图片&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)headImageClick:(UIButton*&lt;span&gt;)btn
{
    [btn.imageView pick:&lt;/span&gt;^(NSData *data, UIImagePickerController *picker, NSDictionary&amp;lt;NSString *,&lt;span&gt;id&lt;/span&gt;&amp;gt; *&lt;span&gt;info)
     {
        [self.http upload:UrlUploadPhoto paras:@{&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;photo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:data,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;PhotoType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;} success:^(STModel *&lt;span&gt;result) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.success) {
                [self key:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;uploadPhoto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                [self.msgBox prompt:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;头像上传成功!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                [btn image:data];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; corner:YES];&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                [self.msgBox prompt:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;头像上传失败!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            }
        }];
        
    } edit:YES];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;界面图：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201803/17408-20180328190700082-1409335284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;STModel，是约定好格式的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201803/17408-20180328182757285-800099529.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; STModel : STModelBase
@property (nonatomic, assign) BOOL success;
@property (retain, nonatomic) &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&amp;lt;NSObject&amp;gt;&lt;span&gt; msg;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;msg，可以根据具体返回的数据，进行对应的类型转换。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17408/201803/17408-20180328191009547-1149863725.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面和大伙分享一下：IT连的都是扩展了点什么：&lt;/p&gt;
&lt;p&gt;A、对于定义API的URL，都简化了前缀&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 注册 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; UrlReg   @&quot;/user/register&quot;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* 登陆 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; UrlLogin  @&quot;/user/login&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将前缀的主机部分，由扩展功能完成。&lt;/p&gt;
&lt;p&gt;所以扩展重写了：reSetUrl函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; STHttp(IT)

&lt;/span&gt;-(NSString*)reSetUrl:(NSString *&lt;span&gt;)url
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(![url hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;amp;&amp;amp; ![url hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;([url startWith:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;/photos/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] || [url startWith:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;/qrcode/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
        {
            url&lt;/span&gt;=&lt;span&gt;[ImageHost append:url];
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            url&lt;/span&gt;=&lt;span&gt;[ApiHost append:url];
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  url;
}
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)reSetHeader
{
    [self setHeader:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;ver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; v:AppVersionNum];&lt;/span&gt;&lt;span&gt;
    [self setHeader:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;prod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; v:STNumString(AppProdType)];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Sagit.Global.Token)
    {
        [self setHeader:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; v:Sagit.Global.Token];
    }
}
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;)showError:(NSString*&lt;span&gt;)errMsg
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(self.msgBox!=&lt;span&gt;nil)
    {
        [self.msgBox alert:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;网络连接错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    }
}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B、扩展中重写了：reSetHeader功能，用于设置一些固定的请求头。&lt;/p&gt;
&lt;p&gt;C、扩展中重写了：showError，用于统一显示网络请求的错误信息。&lt;/p&gt;

&lt;p&gt;本篇虽然介绍的是网络请求，但分享的代码，也都是IT连里完整的功能模块了。&lt;/p&gt;
&lt;p&gt;Sagit框架，让IOS开发更简单，你值的拥有！！！&lt;/p&gt;
&lt;p&gt;顺便新开：IOS Sagit 开发框架 QQ群：702724292&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 06:10:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/8665502.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core MVC 2.1  顶级参数验证 - Sweet-Tang</title>
<link>http://www.cnblogs.com/tdfblog/p/asp-net-core-2-1-top-level-mvc-parameter-validation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tdfblog/p/asp-net-core-2-1-top-level-mvc-parameter-validation.html</guid>
<description>&lt;p&gt;本文讨论ASP.NET Core 2.1中与ASP.NET Core MVC / Web API控制器中的模型绑定相关的功能。虽说这是一个功能，但从我的角度来看，它更像是一个错误修复！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意，我使用的是 NET Core 2.1 Preview 1，正式版发布后，功能可能存在变动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;asp.net-core-2.0-模型验证&quot;&gt;ASP.NET Core 2.0 模型验证&lt;/h2&gt;
&lt;p&gt;模型验证是ASP.NET Core MVC 管线的重要组成部分。有很多方法可以注入到验证层（例如使用&lt;a href=&quot;https://github.com/JeremySkinner/FluentValidation/wiki/i.-ASP.NET-Core-integration&quot;&gt;FluentValidation&lt;/a&gt;），最常见的方法可能是使用来自&lt;code&gt;System.ComponentModel&lt;/code&gt;的验证标记来&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation&quot;&gt;修饰绑定模型&lt;/a&gt;。 例如：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class UserModel  
{
    [Required, EmailAddress]
    public string Email { get; set; }

    [Required, StringLength(1000)]
    public string Name { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果您在控制器的操作方法中使用&lt;code&gt;UserModel&lt;/code&gt;，&lt;code&gt;MvcMiddleware&lt;/code&gt;则会自动创建对象的新实例，绑定模型的属性并使用如下三个来源对其进行验证：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;em&gt;表单&lt;/em&gt; - 当使用POST将表单发送到服务器时，发送到HTTP请求的主体中；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;路由&lt;/em&gt; - 在匹配路由后从URL段或默认值中获取；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;查询字符串&lt;/em&gt; - 在URL的末尾传递。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.6190476190476&quot;&gt;
&lt;p&gt;请注意，目前，作为JSON发送的数据默认情况下不会被绑定。如果您希望绑定请求体中的JSON数据，则需要使用&lt;a href=&quot;https://andrewlock.net/model-binding-json-posts-in-asp-net-core/&quot;&gt;此处所述&lt;/a&gt;的&lt;code&gt;[FromBody]&lt;/code&gt;标记修饰模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在控制器Action方法中，可以简单地检查&lt;code&gt;ModelState&lt;/code&gt;属性，确定提供的数据是否有效：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CheckoutController : Controller  
{
    public IActionResult SaveUser(UserModel model)
    {
        if(!ModelState.IsValid)
        {
            // Something wasn't valid on the model
            return View(model);
        }

        // The model passed validation, do something with it
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是非常标准的MVC内容，但是如果您不想创建整个绑定模型，但仍想验证传入数据，该怎么办？&lt;/p&gt;
&lt;h2 id=&quot;asp.net-core-2.0-顶级参数&quot;&gt;ASP.NET Core 2.0 顶级参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DataAnnotation&lt;/code&gt;标记默认MVC验证系统使用的属性不必应用于类的属性，它们也可以应用于参数。这可能会导致您认为您可以完全替换&lt;code&gt;UserModel&lt;/code&gt;上面的示例中的以下内容：&lt;/p&gt;
&lt;p&gt;MVC默认验证系统使用的&lt;code&gt;DataAnnotation&lt;/code&gt;标记不一定应用于类的属性，它们同样可以应用于参数。这可能会导致您认为可以完全替换上面示例中的&lt;code&gt;UserModel&lt;/code&gt;，如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CheckoutController : Controller  
{
    public IActionResult SaveUser(
        [Required, EmailAddress] string Email 
        [Required, StringLength(1000)] string Name)
    {
        if(!ModelState.IsValid)
        {
            // Something wasn't valid on the model
            return View(model);
        }

        // The model passed validation, do something with it
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不幸的是，这是行不通的！在绑定属性时，验证属性将被忽略，并且&lt;code&gt;ModelState.IsValid&lt;/code&gt;始终是&lt;code&gt;true&lt;/code&gt;！&lt;/p&gt;
&lt;h2 id=&quot;asp.net-core-2.1中的顶级参数&quot;&gt;ASP.NET Core 2.1中的顶级参数&lt;/h2&gt;
&lt;p&gt;幸运的是，ASP.NET Core团队&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/6825&quot;&gt;意识到了这个问题&lt;/a&gt;，并且已经将&lt;a href=&quot;https://github.com/aspnet/Mvc/issues/6790&quot;&gt;修补程序合并为ASP.NET Core 2.1的一部分&lt;/a&gt;。因此，上一节中的代码的行为与您所期望的一样，参数经过验证，并相应地进行了&lt;code&gt;ModelState.IsValid&lt;/code&gt;更新。&lt;/p&gt;
&lt;p&gt;作为这项工作的一部分，您现在还可以使用&lt;code&gt;[BindRequired]&lt;/code&gt;标记修饰参数。当绑定非空值类型时，此标记很重要，因为使用&lt;code&gt;[Required]&lt;/code&gt;标记对这些属性并不能提供预期的行为。&lt;/p&gt;
&lt;p&gt;这意味着您现在可以执行以下操作，并确保&lt;code&gt;testId&lt;/code&gt;参数已从路由参数中正确绑定，并且&lt;code&gt;qty&lt;/code&gt;参数已从查询字符串中绑定。在ASP.NET Core 2.1之前，它甚至不能编译！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpGet(&quot;test/{testId}&quot;)]
public IActionResult Get([BindRequired, FromRoute] Guid testId, [BindRequired, FromQuery] int qty)  
{
    if(!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    // Valid and bound
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.9454545454545&quot;&gt;
&lt;p&gt;对于这个问题可以查阅我之前的博客：&lt;a href=&quot;http://www.cnblogs.com/tdfblog/p/required-and-bindrequired-in-asp-net-core-mvc.html&quot;&gt;《ASP.NET Core MVC中的 [Required]与[BindRequired]》&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在ASP.NET Core 2.0及以下版本中，应用于顶级参数的验证标记将被忽略，并且&lt;code&gt;ModelState&lt;/code&gt;不会更新。只考虑复杂模型类型的验证参数。&lt;/p&gt;
&lt;p&gt;在ASP.NET Core 2.1中，验证标记现在将在顶级参数上得到遵守。更重要的是，您可以将&lt;code&gt;[BindReqired]&lt;/code&gt;标记应用于参数。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 2.1 增加了很多&lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2018/02/02/asp-net-core-2-1-roadmap/&quot;&gt;新特性&lt;/a&gt;。这是一些不错的小改进之一，它使事情变得更容易，更一致 -- 我喜欢这种改变。&lt;/p&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://andrewlock.net/coming-in-asp-net-core-2-1-top-level-mvc-parameter-validation/&quot; class=&quot;uri&quot;&gt;https://andrewlock.net/coming-in-asp-net-core-2-1-top-level-mvc-parameter-validation/&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Mar 2018 06:08:00 +0000</pubDate>
<dc:creator>Sweet-Tang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tdfblog/p/asp-net-core-2-1-top-level-mvc-parameter-validation.html</dc:identifier>
</item>
</channel>
</rss>