<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core中使用GraphQL - 第五章 字段, 参数, 变量 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9926315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9926315.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181107224402155-920059218.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core中使用GraphQL&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;字段&quot;&gt;字段&lt;/h2&gt;
&lt;p&gt;我们已经很好的理解了GraphQL中的字段。在之前&lt;code&gt;HelloWorldQuery&lt;/code&gt;的例子中，我们添加了2个字段&lt;code&gt;hello&lt;/code&gt;和&lt;code&gt;howdy&lt;/code&gt;. 它们都是标量字段。正如GraphQL官网文档中声明的那样&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&quot;At its simplest, GraphQL is about asking for specific fields on objects&quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;简单来说，GraphQL就是询问对象中的一些特定字段&lt;/p&gt;
&lt;p&gt;来源: graphql.org&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们来为我们的实例程序添加一些复杂的类型。比如，现在我们需要编写一个库存系统，我们首先添加一个货物类&lt;code&gt;Item&lt;/code&gt;, 其代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Item  
{
    public string Barcode { get; set; }

    public string Title { get; set; }

    public decimal SellingPrice { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是我们不希望直接针对这个对象创建查询，因为它不是一个&lt;code&gt;GraphQL&lt;/code&gt;对象，它没有继承自&lt;code&gt;ObjectGraphType&lt;/code&gt;, 为了创建一个&lt;code&gt;GraphQL&lt;/code&gt;查询，我们需要创建一个新类&lt;code&gt;ItemType&lt;/code&gt;, 它继承自&lt;code&gt;ObjectGraphType&lt;/code&gt;类。&lt;/p&gt;
&lt;p&gt;另外&lt;code&gt;ObjectGraphType&lt;/code&gt;类是一个泛型类，所以这里我们需要指定它的泛型参数是&lt;code&gt;Item&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ItemType : ObjectGraphType&amp;lt;Item&amp;gt;  
{
    public ItemType()
    {
        Field(i =&amp;gt; i.Barcode);
        Field(i =&amp;gt; i.Title);
        Field(i =&amp;gt; i.SellingPrice);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有2点需要注意。首先我们不在针对字段进行类型声明了。&lt;code&gt;GraphQL&lt;/code&gt;库将实体类属性字段类型映射成&lt;code&gt;GraphQL&lt;/code&gt;的内置类型。例如这里&lt;code&gt;Barcode&lt;/code&gt;的类型&lt;code&gt;string&lt;/code&gt;会被映射成&lt;code&gt;GraphQL&lt;/code&gt;的内置类型&lt;code&gt;StringGraphType&lt;/code&gt;。其次这里我们使用了Lambda表达式设置了实体类属性和&lt;code&gt;GraphQL&lt;/code&gt;字段之间的映射， 这有点类似于数据库模型和ViewModel之间的转换的映射。&lt;/p&gt;
&lt;p&gt;下一步，我们需要在&lt;code&gt;HelloWorldQuery&lt;/code&gt;中注册&lt;code&gt;ItemType&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public HelloWorldQuery()  
{
    ...
    ...

    Field&amp;lt;ItemType&amp;gt;(
        &quot;item&quot;,
        resolve: context =&amp;gt;
        {
           return new Item {
                Barcode = &quot;123&quot;,
                Title = &quot;Headphone&quot;,
                SellingPrice = 12.99M
            };
        }
    ); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们暂时设置了一个硬编码的返回值。所以当查询&lt;code&gt;item&lt;/code&gt;对象的时候，这个硬编码的返回值会输出出来。&lt;/p&gt;
&lt;p&gt;现在我们启动项目，进入&lt;code&gt;GraphiQL&lt;/code&gt;界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181107224444540-216482338.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们设置查询为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;query {
    item{
        barcode
        sellingPrice
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行查询之后，结果是&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;item&quot;: {
      &quot;barcode&quot;: &quot;123&quot;,
      &quot;sellingPrice&quot;: 12.99
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改查询为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;query {
    item{
        barcode
        sellingPrice
        title
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行查询之后，结果是&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;item&quot;: {
      &quot;barcode&quot;: &quot;123&quot;,
      &quot;sellingPrice&quot;: 12.99,
      &quot;title&quot;: &quot;Headphone&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这说明我们的&lt;code&gt;GraphQL&lt;/code&gt;查询已经生效，api根据我们需要的字段返回了正确的返回值。&lt;/p&gt;
&lt;h2 id=&quot;参数&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;这里我们可以使用参数去除前面的硬编码。&lt;/p&gt;
&lt;p&gt;为了说明如何使用参数，这里我们首先创建一个数据源类&lt;code&gt;DataSource&lt;/code&gt;, 其代码如下&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class DataSource  
{
    public IList&amp;lt;Item&amp;gt; Items
    {
        get;
        set;
    }

    public DataSource()
    {
        Items = new List&amp;lt;Item&amp;gt;(){
            new Item { Barcode= &quot;123&quot;, Title=&quot;Headphone&quot;, SellingPrice=50},
            new Item { Barcode= &quot;456&quot;, Title=&quot;Keyboard&quot;, SellingPrice= 40},
            new Item { Barcode= &quot;789&quot;, Title=&quot;Monitor&quot;, SellingPrice= 100}
        };
    }

    public Item GetItemByBarcode(string barcode)
    {
        return Items.First(i =&amp;gt; i.Barcode.Equals(barcode));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里除了&lt;code&gt;Items&lt;/code&gt;集合，我们还添加了一个方法&lt;code&gt;GetItemByBarcode&lt;/code&gt;, 这个方法可以根据传递的&lt;code&gt;barcode&lt;/code&gt;参数返回第一个匹配的&lt;code&gt;Item&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后现在我们来修改之前的&lt;code&gt;item&lt;/code&gt;查询, 添加一个&lt;code&gt;arguments&lt;/code&gt;参数, 其代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;ItemType&amp;gt;(
    &quot;item&quot;,
    arguments: new QueryArguments(new QueryArgument&amp;lt;StringGraphType&amp;gt; { Name = &quot;barcode&quot; }),
    resolve: context =&amp;gt;
    {
        var barcode = context.GetArgument&amp;lt;string&amp;gt;(&quot;barcode&quot;);
        return new DataSource().GetItemByBarcode(barcode);
    }
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;是一个参数列表，里面可以包含必填参数和选填参数。针对每个参数，我们都需要指定它对应的类型，这里&lt;code&gt;Name&lt;/code&gt;属性是设置了当前参数的名称。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;resolve&lt;/code&gt;参数中, 你可以使用&lt;code&gt;context.GetArgument()&lt;/code&gt;方法获取查询中传递的参数值。&lt;/p&gt;
&lt;p&gt;现在我们重新启动项目，并在&lt;code&gt;GraphiQL&lt;/code&gt;中添加如下查询&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;query {  
  item (barcode: &quot;123&quot;) {
    title
    sellingPrice
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的查询结果&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;item&quot;: {
      &quot;title&quot;: &quot;Headphone&quot;,
      &quot;sellingPrice&quot;: 50
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个结果与我们预想的一样。&lt;/p&gt;
&lt;p&gt;但是这时候如果我们不传递&lt;code&gt;barcode&lt;/code&gt;参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;query {  
  item {
    title
    sellingPrice
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序就会报错&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;data&quot;: {
    &quot;item&quot;: null
  },
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;Error trying to resolve item.&quot;,
      &quot;locations&quot;: [
        {
          &quot;line&quot;: 2,
          &quot;column&quot;: 3
        }
      ],
      &quot;path&quot;: [
        &quot;item&quot;
      ],
      &quot;extensions&quot;: {
        &quot;code&quot;: &quot;INVALID_OPERATION&quot;
      }
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因是当前&lt;code&gt;barcode&lt;/code&gt;是一个可空项，程序查询时, &lt;code&gt;First&lt;/code&gt;方法会报错。所以这时候我们可以使用&lt;code&gt;NonNullGraphType&lt;/code&gt;来设置&lt;code&gt;barcode&lt;/code&gt;为一个必填项。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;QueryArgument&amp;lt;NonNullGraphType&amp;lt;StringGraphType&amp;gt;&amp;gt; { Name = &quot;barcode&quot; }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样重新启动项目后，继续使用之前报错的查询，&lt;code&gt;GraphiQL&lt;/code&gt;就会给出校验错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181107224455015-254781373.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;
&lt;p&gt;现在是时候将参数变成动态了。 我们不希望每次在查询中写死查询条件，我们希望这个查询参数是动态的，这时候我们就需要使用到变量。&lt;/p&gt;
&lt;p&gt;首先，这里我们需要确保我们的&lt;code&gt;GraphQL&lt;/code&gt;中间件可以接受参数，所以我们需要在&lt;code&gt;GraphQLRequest&lt;/code&gt;类中添加一个参数变量&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class GraphQLRequest
{
    public string Query { get; set; }
    public JObject Variables { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们需要修改&lt;code&gt;GraphQLMiddleware&lt;/code&gt;中间件的&lt;code&gt;InvokeAsync&lt;/code&gt;方法, 在其中添加一行代码设置&lt;code&gt;doc.Inputs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var result = await _executor.ExecuteAsync(doc =&amp;gt;
{
    doc.Schema = _schema;
    doc.Query = request.Query;

    doc.Inputs = request.Variables.ToInputs();

}).ConfigureAwait(false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们的&lt;code&gt;item&lt;/code&gt;查询已经支持动态参数了，我们可以运行程序，在&lt;code&gt;GraphiQL&lt;/code&gt;中设置如下查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;query($barcode: String!){  
  item(barcode: $barcode){
    title
    sellingPrice
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询中变量是以$开头的, 后面需要加上变量类型，因为之前我们这是了&lt;code&gt;barcode&lt;/code&gt;参数为必填项，所以&lt;code&gt;$barcode&lt;/code&gt;变量我们也要设置成必填。变量的必填设置是在变量类型后添加一个!号。&lt;/p&gt;
&lt;p&gt;最后，在&lt;code&gt;GraphiQL&lt;/code&gt;中，你可以使用QUERY VARIABLES面板中输入参数的值。如下图所示，最终结果正确的返回了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181107224501995-840569369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20V&quot;&gt;本文源代码：https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20V&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 22:43:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>ASP.NET Core中使用GraphQL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9926315.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：11. 在同一个硬盘上安装多个 Linux 发行版以及为 Linux 安装 Nvidia 显卡驱动 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop011.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇讲了，10月份是一个很开心的月份，因为在这个月里陆续发布了 Ubuntu 18.10 和 Fedora 29。在这一篇中，我将会展示如何在同一个硬盘中同时安装这两个操作系统，并为这两个系统安装 Nvidia 显卡驱动。本来，要尝试新系统，一个虚拟机就可以搞定的事，没必要在同一个硬盘安装多个系统这么麻烦。但是虚拟机中没有 Nvidia 的显卡，无法测试这两个新系统对显卡驱动的支持如何。所以，为了测试显卡驱动能否顺利安装，我还是选择了在实体机上安装这两个系统。当然，为了显示安装过程，为了方便截图，我还是在虚拟机中操作了一遍，安装过程的截图都来自于虚拟机。&lt;/p&gt;
&lt;p&gt;四年前，我写了一篇&lt;a href=&quot;https://www.cnblogs.com/youxia/p/linux007.html&quot;&gt;安装 Linux 时碰到的硬盘分区的陷阱及应对&lt;/a&gt;，提出了硬盘分区分为 msdos 分区和 gpt 分区两种，而 Legacy BIOS 只支持从 msdos 分区的硬盘启动，UEFI BIOS 只支持从 gpt 分区的硬盘启动。而且 UEFI BIOS 和 gpt 分区的硬盘，必须要操作系统能够支持才行。我四年前写这一篇的时候，正式因为 Ubuntu 的安装程序把硬盘改成了 gpt 分区而 WinXP 无法识别，害我折腾了很久。当然，现在不用担心这个问题了，因为不管是最新的 Win10，还是各个 Linux 发行版，对 UEFI BIOS 和 gpt 分区的硬盘的支持，都是没有问题的。在这一篇中，我同时探明了，如果要使用 UEFI 模式安装操作系统，硬盘的第一个分区一定要是 EFI 分区（其实其文件系统是 FAT32 格式），在 Linux 系统中，这个分区挂在到&lt;code&gt;/boot/efi&lt;/code&gt;目录。&lt;/p&gt;
&lt;p&gt;同样，四年前，我也写了一篇&lt;a href=&quot;https://www.cnblogs.com/youxia/p/linux018.html&quot;&gt;在同一个硬盘上安装多个 Linux 发行版及 Fedora 21 、Fedora 22 初体验&lt;/a&gt;。在这一篇中，我在同一个硬盘上安装了 CentOS、Fedora 和 Ubuntu 三个系统，当然，这时我采用的是 msdos 分区。同时，我抛出了一个错误的观点：因为使用 UEFI 模式安装操作系统时，每一个系统的第一个分区都必须是 EFI 分区，会产生冲突，所以要安装多个操作系统到同一个硬盘，只能使用 Legacy BIOS 和 msdos 分区。现在看来，这个观点当然是错的不能再错了，因为 Linux 和 Win10 共存的案例比比皆是，谁说两个在 EFI 分区会冲突的？其实 EFI 分区只有一个，只不过每个系统在 EFI 分区中有一个单独的文件夹而已。&lt;/p&gt;
&lt;p&gt;所以在这一篇中，我当然是使用 UEFI BIOS 和 gpt 分区来安装多个 Linux 发行版了。然后，我分别在这两个系统中安装 Nvidia 显卡驱动，当然是采取最简单的方式。事实证明，Fedora 中的第三方软件仓库 RPM Fusion 和 Ubuntu 中个人维护的软件仓库 PPA 是多么的方便。&lt;/p&gt;
&lt;h2 id=&quot;硬盘分区的设计&quot;&gt;硬盘分区的设计&lt;/h2&gt;
&lt;p&gt;通过前面的分析，可以看出，安装一个 Linux 发行版，最少需要把硬盘分成三个区，第一个 EFI 分区，挂载到&lt;code&gt;/boot/efi&lt;/code&gt;目录，第二个分区是存放 Linux 系统的主要位置，为 ext4 文件系统，挂载到&lt;code&gt;/&lt;/code&gt;根目录，第三个分区作为交换分区，交换分区可以不要，但是有一个肯定更好。EFI 分区和交换分区是可以多个 Linux 发行版共享的。所以，要同时安装 Fedora 29 和 Ubuntu 18.10，硬盘分四个区就可以了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个分区，EFI 分区，用于存放 EFI 文件。&lt;/li&gt;
&lt;li&gt;第二个分区，安装 Fedora 29，挂载到 Fedora 29 的根目录。&lt;/li&gt;
&lt;li&gt;第三个分区，安装 Ubuntu 18.10，挂载到 Ubuntu 18.10 的根目录。&lt;/li&gt;
&lt;li&gt;交换分区，被 Fedora 和 Ubuntu 共享。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先安装 Fedora 29，在安装过程中划出第一个分区和第二个分区，安装过程中不设置交换分区。&lt;/li&gt;
&lt;li&gt;再安装 Ubuntu 18.10，在安装过程中划出第三个分区和第四个分区，和 Fedora 29 公用第一个分区，不动第二个分区。&lt;/li&gt;
&lt;li&gt;两个系统都安装好之后，进入 Fedora 29，通过修改&lt;code&gt;/etc/fstab&lt;/code&gt;文件，指定交换分区为第四个分区，也就是两个系统公用这个交换分区。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;系统安装实战&quot;&gt;系统安装实战&lt;/h2&gt;
&lt;p&gt;先安装 Fedora 29，进入安装界面，选择手动分区，并且选择标准分区，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104222645815-881979854.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击自动创建，Fedora 29 的安装程序会为我们创建四个分区，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104222748020-1174224522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据前面的分析，我们把 Fedora 29 放到一整个分区中，不需要为&lt;code&gt;/boot&lt;/code&gt;目录单独分区，也不要交换分区。所以删除后两个分区，当然第二个分区也要调小一点，为后面安装 Ubuntu 留下空间，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104222923660-910868568.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点完成，继续安装系统。&lt;/p&gt;
&lt;p&gt;安装完成之后，进入系统，可以查看&lt;code&gt;/boot/efi&lt;/code&gt;目录下的文件，会发现里面有一个&lt;code&gt;fedora&lt;/code&gt;目录，查看&lt;code&gt;/boot&lt;/code&gt;目录，可以看到用于启动操作系统的 Linux 内核镜像和 initramfs 镜像文件在这里。查看&lt;code&gt;/etc/fstab&lt;/code&gt;文件，可以看到 Fedora 29 只挂载了两个分区，而且没有交换分区。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104223243759-189923616.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启计算机，开始安装 Ubuntu 18.10。&lt;/p&gt;
&lt;p&gt;进入安装界面，选择其它选项，以便手动进行分区操作。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104223426229-604112310.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 的安装程序已经自动识别出了前两个分区，而且知道第一个分区是 EFI 分区，第二个分区已经安装了 Fedora 29。这个真的很智能。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104223603769-1077092306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要做的，就是把剩下的空间再分成两个区。第三个分区安装 Ubuntu 18.10，第四个分区设置为交换分区。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104223711019-1146868581.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继续安装系统就可以了。&lt;/p&gt;
&lt;p&gt;系统安装完成后，重启电脑。可以通过 Grub 的启动界面选择我们要进入的系统，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104223837354-1490403948.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入 Ubuntu 系统，可以查看和系统启动有关的目录和文件，也可以查看&lt;code&gt;/etc/fstab&lt;/code&gt;文件，可以看到它有三个分区，和 Fedora 相比，就是多了一个交换分区。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104224233549-1930348315.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把该文件的最后一行加入到 Fedora 29 的&lt;code&gt;/etc/fstab&lt;/code&gt;文件中，就可以让 Fedora 29 也使用第四个分区作为交换空间了。使用&lt;code&gt;free&lt;/code&gt;命令可以查看内存使用情况和交换分区使用情况。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104225335325-302591600.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，在同一个硬盘上安装多个 Linux 发行版大功告成。&lt;/p&gt;
&lt;h2 id=&quot;关于启动菜单&quot;&gt;关于启动菜单&lt;/h2&gt;
&lt;p&gt;Linux 系统的启动是由 Grub 管理的，Grub 的系统探测功能很强大，只要硬盘上安装的系统都可以探测出来，探测的结果会存放在配置文件中，最后会以启动界面的形式展示出来。因为我们是先安装的 Fedora，后安装的 Ubuntu，所以启动界面是 Ubuntu 中的红色样式。如果我们先安装 Ubuntu，再安装 Fedora，那么启动菜单应该是 Fedora 的样式。&lt;/p&gt;
&lt;p&gt;配置文件放到哪里在呢？分别是&lt;code&gt;/boot/efi/EFI/ubuntu/grub.cfg&lt;/code&gt;和&lt;code&gt;/boot/efi/EFI/fedora/grub.cfg&lt;/code&gt;。这个配置文件不要手动编辑，是自动生成的。配置文件不仅在安装系统的时候可以生成，在更新系统的时候也可以生成，我们也可以手动更新。只要我们升级了内核，或者更新了 initramfs 镜像，或者修改了&lt;code&gt;/etc/default/grub&lt;/code&gt;配置文件，都要更新 Grub 的配置文件。关于这一点，我上一篇讲 Grub 的章节有讲到。现在我们在同一块硬盘上安装了多个 Linux 发行版，也就存在了多份 Grub 的配置文件，那么 Grub 究竟用的是哪一个呢？通过 Grub 的环境变量可以查看和设置。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180807222251927-146797524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 Grub 逆天的功能，请查看我上一篇中关于 Grub 的章节。另外，就是查看 Grub 的官方文档。&lt;/p&gt;
&lt;h2 id=&quot;安装-nvidia-显卡驱动&quot;&gt;安装 Nvidia 显卡驱动&lt;/h2&gt;
&lt;p&gt;安装 Nvidia 显卡驱动的方式有很多，其中一种就是去 Nvidia 的官网下载最新的驱动，然后自己编译安装。这个过程比较麻烦，主要有两个问题，一是编译需要一定的基础，二是每当你更新了内核，就需要重新编译一次。所以我这里选择简单的方式。简单的方式就是直接从软件仓库进行安装，Fedora 29 使用&lt;code&gt;dnf&lt;/code&gt;，Ubuntu 18.10 使用&lt;code&gt;apt-get&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Fedora 29 的官方软件仓库中是没有 Nvidia 的驱动的。不过我们可以使用第三方软件仓库 RPM Fusion。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104234715078-393952869.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过下面的界面，可以为 Fedora 29 启动 RPM Fusion 支持：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104234903527-766872180.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，通过&lt;code&gt;sudo dnf install akmod-nvidia&lt;/code&gt;就可以为 Fedora 29 安装 Nvidia 驱动了。下图界面可以提示安装成功，Fedora 29 用的版本是 410.66：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104235027828-102551369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 Ubuntu 对 Nvidia 显卡的驱动支持一直都不错，在 Ubuntu 的官方软件仓库中，一直都有 Nvidia 的软件包，直接安装就可以了。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181105002143656-504794862.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用软件包安装 Nvidia 的驱动还有一个好处，那就是如果驱动不能正确运行，也非常方便进行补救。只需要使用&lt;code&gt;Ctrl+Alt+F3&lt;/code&gt;切换一个虚拟控制台，进入字符界面，使用&lt;code&gt;sudo dnf remove&lt;/code&gt;命令或&lt;code&gt;sudo aptitude purge&lt;/code&gt;命令删除刚安装的软件包即可。&lt;/p&gt;
&lt;h2 id=&quot;fedora-29-的一些体验&quot;&gt;Fedora 29 的一些体验&lt;/h2&gt;
&lt;p&gt;Ubuntu 18.10 默认使用运行于 Xorg 的 Gnome，而 Fedora 29 默认使用运行于 Wayland 的 Gnome。不过可以在登录的时候进行选择。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104230216071-131899308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我还是喜欢 Xorg，Wayland 还是不太完美。例如，我在上面的操作系统安装过程中，本来是想使用&lt;code&gt;sudo gedit /etc/fstab&lt;/code&gt;来修改 Fedora 29 的&lt;code&gt;/etc/fstab&lt;/code&gt;文件，结果&lt;code&gt;gedit&lt;/code&gt;的图形界面启动不了，提示不能打开 display :0。最后我只能先&lt;code&gt;sudo dnf install vim&lt;/code&gt;安装一个 Vim，在使用&lt;code&gt;sudo vim /etc/fstab&lt;/code&gt;完成了这个操作。但是在运行于 Xorg 的 Gnome 中就没有这个问题，&lt;code&gt;gedit&lt;/code&gt;的图形界面启动很顺利。&lt;/p&gt;
&lt;p&gt;另外，运行于 Wayland 的 Gnome shell 不能重启。就是先按&lt;code&gt;Alf+F2&lt;/code&gt;键，会弹出一个对话框，输入&lt;code&gt;r&lt;/code&gt;，点确认，在 Xorg 中，Gnome shell 会重启，这对新安装了 extension、theme 的情况下特别有用。而在 Wayland 中是不能重启的。&lt;/p&gt;
&lt;p&gt;关于对系的美化，Fedora 29 要比 Ubuntu 18.10 支持得要好，其实它们都是用的 Gnome 3.30，所不同者，就是 Fedora 29 的官方软件仓库中自带的主题包要多一些。使用&lt;code&gt;sudo dnf search gtk-theme&lt;/code&gt;和&lt;code&gt;sudo dnf search icon-theme&lt;/code&gt;，可以看到目前流行的 adapta-gtk-theme 和 numix-icon-theme 都在里面。如下两图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104235743763-346304183.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181104235756265-2068080881.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，在 Fedora 29 中，要对系统进行美化，几个&lt;code&gt;sudo dnf install&lt;/code&gt;命令就搞定了。&lt;/p&gt;
&lt;p&gt;而 Ubuntu 的美化就要稍微麻烦一点，它的官方软件仓库里是没有什么主题包可用的。不过不用担心，我们可以去 github 上找，一般的主题都会对 Ubuntu 提供支持，以 PPA 的方式提供可直接安装的软件包。如下两图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181105002541874-1982253155.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181105002550646-1841187936.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，如果我们想把 Ubuntu 18.10 整成和上面相同的 Fedora 29 的界面，只需要以下几个命令就可以了：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo add-apt-repository ppa:tista/adapta
sudo add-apt-repository ppa:numix/ppa
sudo apt-get update
sudo apt-get install adapta-gtk-theme
sudo apt-get install numix-icon-theme-circle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一搞，这两个系统就完全没有区别了，因为它们都是用的 Gnome 3.30。&lt;/p&gt;
&lt;p&gt;新的系统对高分屏的支持也不错，可以直接在分辨率设置界面设置缩放倍数了。如下两图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181105000256124-1624439938.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201811/16576-20181105000307460-2125532415.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，如果我要是有一个 4K 屏的话，我把它的缩放比例设置为 200%，就可以得到和 1920x1080 一样大小的图形界面，但是字体显示会更加细腻。其实 Gnome 3 本来就支持高分屏，不过以前需要使用&lt;code&gt;gsettings set org.gnome.desktop.interface scaling-factor 2&lt;/code&gt;来手动设置，现在直接进入系统设置界面，对我们要更方便一点。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年11月08日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 20:34:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop011.html</dc:identifier>
</item>
<item>
<title>瞧一瞧！这儿实现了MongoDB的增量备份与还原（含部署代码） - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9917137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9917137.html</guid>
<description>&lt;h2&gt;一 需求描述&lt;/h2&gt;
&lt;p&gt;我们知道数据是公司的重要资产，业务的系统化、信息化就是数字化。数据高效的存储与查询是系统完善和优化的方向，而数据库的稳定性、可靠性是实现的基础。高可用和RPO（RecoveryPointObjective，复原点目标，指能容忍的最大数据丢失量）是衡量一个数据库优劣的重要指标。作为一个DBA，搭建数据库可靠性体系时，一定会要考虑对数据库进行容灾备份。例如，SQL Server类型的数据库，我们一定会部署作业，定期进行完整备份、差异备份和日志备份；MySQL 数据库同样如此，也是定期进行完整备份、binlog备份等。&lt;/p&gt;
&lt;p&gt;可能很多公司的DBA认为自己的数据库已采用了新的高可用方案，是多结点冗余了，不再需要冗余备份了，例如SQL Server 的AlwaysOn，MySQL的MHA。可是，我们还是要强调两点。&lt;/p&gt;
&lt;p&gt;1.墨菲定律：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。&lt;/p&gt;
&lt;p&gt;过往无数的惨痛教训说明，将损失放大的原因就是备份数据也损坏了（大家不重视，实际上很可能就没做）。&lt;/p&gt;
&lt;p&gt;2.容灾备份不仅仅可以解决物理故障，还可以将一些其它误操作回滚，将数据的损害降至最低。&lt;/p&gt;
&lt;p&gt;数据容灾备份是为数据的灾难恢复加固了最后一道保障墙。&lt;/p&gt;
&lt;p&gt;国务院信息化工作办公室领导编制的《重要信息系统灾难恢复指南》也对灾难恢复能力等级做了详细划分。&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;     灾难恢复能力等级&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;RTO&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;                     RPO&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2天以上&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1天至7天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;24小时以后&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1天至7天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;12小时以上&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数小时至1天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p align=&quot;center&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数小时至2天&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数小时至1天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p align=&quot;center&quot;&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数分钟至2天&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0至30分钟&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p align=&quot;center&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;180&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数分钟&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;204&quot;&gt;
&lt;p align=&quot;center&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;随着MongoDB使用的越来越普及，存储的数据越来越重要，对其进行定期备份很有必要。现在业内普遍流行的做法是每天定时进行一次全库备份，出故障时，进行全库还原。但是一天一次的备份，很难保证恢复后的数据时效性，RPO较差，会有几个小时的数据丢失。例如，每天5点进行完整备份，如果故障点是晚上20:00,那么就会丢失15个小时的数据。对比上面的“灾难恢复能力等级“”列表，会发现，我们的灾难能力等级比较低。&lt;/p&gt;
&lt;p&gt;如果每小时做一次全部备份，那么对存储空间的要求较高，还有就是对性能也会有影响。所以，&lt;span&gt;&lt;strong&gt;探究Mongodb的增量备还与原很有必要！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二 原理说明&lt;/h2&gt;
&lt;p&gt;关系型数据库，例如MySQL ,SQL Server 都有事务日志（或bin log），会将数据库的DML 、DDL、DCL等操作记录在事务文件中,可以通过日志备份来搭建增量容灾还原体系。MongoDB没有此类机制和数据文件，难以实现。但是MongoDB副本集有通过oplog（位于local数据库oplog.rs集合中） 实现节点间的同步，此集合记录了整个mongod实例在一段时间内的所有变更（插入/更新/删除）操作。基于此，是否可以考虑通过oplog.rs集合的备份还原来实现实例的增量备份与增量还原。&lt;/p&gt;
&lt;p&gt;查看mongodb备份命令Mongodump，其中有一个相关参数oplog。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Mongodump &lt;/strong&gt;&lt;strong&gt;中&lt;/strong&gt;&lt;strong&gt;--oplog&lt;/strong&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参数说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;--oplog&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Use oplog for taking a point-in-time snapshot&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;该参数的主要作用是在导出库集合数据的同时生成一个oplog.bson文件，里面存放了开始进行dump到dump结束之间所有的op log 操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181022204059487-1011211891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：--oplog选项只对全库导出有效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;相应的 Mongorestore 中与 &lt;span lang=&quot;EN-US&quot;&gt;Oplog 相关的参数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参数说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;oplogReplay&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;replay oplog for point-in-time restore&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;oplogLimit&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;only include oplog entries before the provided Timestamp&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;oplogFile&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;365&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;oplog file to use for replay of oplog&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; &lt;strong&gt;仔细观察oplogReplay参数下的还原过程，我们发现，是先还原数据库文件，再重放还原&lt;/strong&gt;&lt;strong&gt;oplog.bson种的数据。这就启发了我们，如果还原路径下，只有&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;oplog.bson文件，没有数据库备份文件，是不是只进行重放还原操作。如此，如果&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;oplog.bson中记录都是上次备份后的变化操作（op log），还原&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;oplog.bson&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;就可以实现了增量还原。&lt;strong&gt;考虑到副本集的变化操作（op log&lt;/strong&gt;&lt;strong&gt;）保存在&lt;/strong&gt;oplog.rs集合中，只要连续从oplog.rs导出操作的相关数据进行备份，就可以实现增量备份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即理论上，&lt;/strong&gt;从oplog.rs导出的数据完全可以替代mongodump过程中产生的oplog.bson，进行增量还原。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;实际生产中经过多次验证，也是完全可以。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;strong&gt;-----具体原理及验证内容还可参考本人博客 --https://www.cnblogs.com/xuliuzai/p/9832333.html&lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;三 代码实现【&lt;span&gt;&lt;em&gt;重点推荐&lt;/em&gt;】&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在容灾体系建设中，既有全库的完整备份也有增量备份。下面是我们的实现代码，因为MongoDB多是在Linux系统下部署，所以这些备份代码都是通过shell语言实现。这些代码大家只要稍微改动，调整部分参数，即可部署应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 实现完整（全库）备份的代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
sourcepath&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/data/mongodb/mongobin344/bin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
targetpath&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/data/mongodb_back/bkXXX_2XXXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
nowtime&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+%Y%m%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
start()
{
${sourcepath}&lt;/span&gt;/mongodump --host &lt;span&gt;172&lt;/span&gt;.XXX.XXX.XXX --port 2XXXX -u 用户名-p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --oplog --&lt;span&gt;gzip&lt;/span&gt; --authenticationDatabase &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --out ${targetpath}/&lt;span&gt;${nowtime}
}
execute()
{

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;================================ $(date) bakXXX 2XXXX mongodb back start  ${nowtime}=========&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

start
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $? -eq &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The MongoDB BackUp Successfully!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The MongoDB BackUp Failure&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ ! -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetpath}/${nowtime}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
  &lt;span&gt;mkdir&lt;/span&gt; ${targetpath}/&lt;span&gt;${nowtime}
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
execute

baktime&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-3 days&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+%Y%m%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetpath}/${baktime}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
  &lt;span&gt;rm&lt;/span&gt; -rf &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${targetpath}/${baktime}/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=======${targetpath}/${baktime}/===删除完毕==&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;

&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;================================ $(date) bakXXX 2XXXX mongodb back end ${nowtime}=========&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码说明：&lt;/p&gt;
&lt;p&gt;1.完整备份的脚本，通过crontab触发执行，每天执行一次。&lt;/p&gt;
&lt;p&gt;2.备份完整后，会将三天前的备份文件自动删除。&lt;/p&gt;
&lt;p&gt;3.sourcepath 定义了MongoDB 运行程序所在路径；targetpath定义了归档文件存放的文件夹（请提前创建）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 实现增量备份的代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#
# This &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; is used by cron to Backup the data of oplog collection,the collection is part of local DB.
# The oplog (operations log) is a special capped collection that keeps a rolling record of all operations 
# that modify the data stored &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; your databases.All replica set members contain a copy of the oplog, 
# &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the local.oplog.rs collection, &lt;span&gt;which&lt;/span&gt;&lt;span&gt; allows them to maintain the current state of the database.
# Each operation &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the oplog is idempotent. That is, oplog operations produce the same results 
# whether applied once or multiple times to the target dataset.
#
# We backup the collections by periodicity to restore the DB  &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;case&lt;/span&gt;&lt;span&gt; of  DB disaster 
# The version is defined V.&lt;/span&gt;&lt;span&gt;001&lt;/span&gt;&lt;span&gt;
# Version   ModifyTime                ModifyBy              Desc
# Ver001    &lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;         xuchangpei             Create the Scripts File
#
#
#&lt;/span&gt;!/bin/&lt;span&gt;bash

#### 请在此处输入关键参数，例如程序路径，账号，密码，实例端口###
command_linebin&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/mongodb/mongobin344/bin/mongo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
username&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
password&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户命名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
port&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mongo都被的端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
####
####comments0 start 第一次运行此脚本时，自动检查创建备份路径 ####
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ ! -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/mongodb_back/mongodboplog_back/mongo$port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
  &lt;span&gt;mkdir&lt;/span&gt; -p /data/mongodb_back/mongodboplog_back/&lt;span&gt;mongo$port
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; [ ! -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/mongodb_back/mongodboplog_back/log/$port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
  &lt;span&gt;mkdir&lt;/span&gt; -p /data/mongodb_back/mongodboplog_back/log/&lt;span&gt;$port
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;

bkdatapath&lt;/span&gt;=/data/mongodb_back/mongodboplog_back/&lt;span&gt;mongo$port
bklogpath&lt;/span&gt;=/data/mongodb_back/mongodboplog_back/log/&lt;span&gt;$port

####comments end ##

logfilename&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; -d today +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y%m%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===================================Message --=MongoDB 端口为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $port &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的差异备份开始，开始时间为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $(&lt;span&gt;date&lt;/span&gt; -d today +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log

ParamBakEndDate&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; +%&lt;span&gt;s)
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --本次备份时间参数中的结束时间为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $ParamBakEndDate &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log

DiffTime&lt;/span&gt;=$(&lt;span&gt;expr&lt;/span&gt; &lt;span&gt;65&lt;/span&gt; \* &lt;span&gt;60&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --备份设置的间隔时间为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $DiffTime &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log


ParamBakStartDate&lt;/span&gt;=$(&lt;span&gt;expr&lt;/span&gt; $ParamBakEndDate -&lt;span&gt; $DiffTime)
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --本次备份时间参数中的开始时间为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $ParamBakStartDate &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log

bkfilename&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; -d today +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

#### comments1 start 获取数据库中oplog记录的开始范围，防止导出的数据不完整 ####

command_line&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${command_linebin} localhost:$port/admin -u$username -p$password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

opmes&lt;/span&gt;=$(/bin/&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db.printReplicationInfo()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | $command_line --&lt;span&gt;quiet)

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $opmes &amp;gt;&lt;span&gt; opdoctime$port.tmplog

opbktmplogfile&lt;/span&gt;=&lt;span&gt;opdoctime$port.tmplog

#opstartmes&lt;/span&gt;=$(&lt;span&gt;grep&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oplog first event time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $opmes)

opstartmes&lt;/span&gt;=$(&lt;span&gt;grep&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oplog first event time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $opbktmplogfile | &lt;span&gt;awk&lt;/span&gt; -F &lt;span&gt;'&lt;/span&gt;&lt;span&gt;CST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | &lt;span&gt;awk&lt;/span&gt; -F &lt;span&gt;'&lt;/span&gt;&lt;span&gt;oplog first event time: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $2}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; | &lt;span&gt;awk&lt;/span&gt; -F &lt;span&gt;'&lt;/span&gt;&lt;span&gt; GMT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $1}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  )

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --oplog集合记录的开始时间为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;$opstartmes &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log

oplogRecordFirst&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$opstartmes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  +%&lt;span&gt;s)

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --oplog集合记录的开始时间为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $oplogRecordFirst &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log

##begin 比较备份参数的开始时间是否在oplog记录的时间范围内
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $oplogRecordFirst -&lt;span&gt;le $ParamBakStartDate ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --检查设置备份时间合理。备份参数的开始时间在oplog记录的时间范围内。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fatal Error --检查设置的备份时间不合理合理。备份参数的开始时间不在oplog记录的时间范围内。请调整oplog size或调整备份频率。本次备份可以持续进行，但还原时数据完整性丢失。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;

##end##

#### comments1 end  ####

dumpmsg&lt;/span&gt;=$(/data/mongodb/mongobin344/bin/mongodump -h localhost --port $port --authenticationDatabase admin -u$username -p$password -d local -c oplog.rs  --query &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{ts:{$gte:Timestamp(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;$ParamBakStartDate&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,1),$lte:Timestamp(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;$ParamBakEndDate&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,9999)}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -o $bkdatapath/&lt;span&gt;mongodboplog$bkfilename)

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;本次导出的具体信息如下：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $dumpmsg
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; $dumpmsg &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log

#### comments2 start  再次检查，防止导出oplog数据过程耗时过长，比如，我们一小时导出一份，每一次循环涵盖65分钟，如果导出执行过程耗时5分钟以上就可能导致导出的数据不完整。####
## 下面的70 是有上面的65&lt;/span&gt;+5而得，+&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 是允许导出耗时5分钟。这个逻辑有点绕，大家可以测测，这段逻辑看几分钟可以理解通透了。
DiffTime&lt;/span&gt;=$(&lt;span&gt;expr&lt;/span&gt; &lt;span&gt;70&lt;/span&gt; \* &lt;span&gt;60&lt;/span&gt;&lt;span&gt;)
AllowMaxDate&lt;/span&gt;=$(&lt;span&gt;expr&lt;/span&gt; $(&lt;span&gt;date&lt;/span&gt; +%s) -&lt;span&gt; $DiffTime)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $AllowMaxDate -&lt;span&gt;le $ParamBakStartDate ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --oplog记录导出时间在规定的DiffTime范围内。数据有效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fatal Error --oplog记录导出时间 超出了 规定的DiffTime范围。数据完整性等不到保证。请增大DiffTime参数或调整备份频率。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;

#### comments2 end ####

#### comments3 检查备份文件是否已经删除start ####
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$bkdatapath/mongodboplog$bkfilename&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
  &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message --检查此次备份文件已经产生.文件信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $bkdatapath/mongodboplog$bkfilename &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fatal Error --备份过程已执行，但是未检测到备份产生的文件，请检查！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
##### comments3 end ####

#### comments4 start 删除历史备份文件，保留3天，如需调整，请在持续设置
keepbaktime&lt;/span&gt;=$(&lt;span&gt;date&lt;/span&gt; -d &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-3 days&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+%Y%m%d%H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)*
&lt;span&gt;if&lt;/span&gt; [ -d $bkdatapath/&lt;span&gt;mongodboplog$keepbaktime ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
  &lt;span&gt;rm&lt;/span&gt; -rf $bkdatapath/&lt;span&gt;mongodboplog$keepbaktime
  &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message -- $bkdatapath/mongodboplog$keepbaktime 删除完毕&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $bklogpath/&lt;span&gt;$logfilename.log
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
### comments4 end 


&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;============================Message --MongoDB 端口为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $port &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的差异备份结束，结束时间为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; $(&lt;span&gt;date&lt;/span&gt; -d today +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y%m%d%H%M%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;gt;&amp;gt; $bklogpath/$logfilename.log
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码说明：&lt;/p&gt;
&lt;p&gt;1.增量备份的脚本，也是通过crontab触发执行，以上参数未修改前，建议每小时执行一次。&lt;/p&gt;
&lt;p&gt;2.备份完整后，会自动检查文件是否产生，并且会将三天前的备份文件删除。&lt;/p&gt;
&lt;p&gt;3.脚本会自动检查备份路径，不存在将自动产生。&lt;/p&gt;
&lt;p&gt;4.增量导出中开始时间和结束时间是最重要的参数，并且要对参数的合法性、有效性检查。例如，检查Oplog的记录是否完全涵盖输入的时间，防止出现希望导出08:00--09:00的数据，但是oplog集合中只有08:30--09:00的数据；防止导出过程耗时过长（例如超过定义的5分钟），导致数据不完整。代码中都会对这些异常进行判断和捕获。&lt;/p&gt;

&lt;h2&gt;四 功能测试验证&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1. 测试环境&lt;/strong&gt;&lt;/h3&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Item&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;ServerIP&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;Port&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;User DB&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;源库&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;172.XXX.XXX.124(Primary)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2XXX30&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;testoplog&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;备份还原库&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;172.XXX.XXX.124(Primary)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2XXX20&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;无&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;2. 完整备份与还原&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;step 1 在备份前，先向数据库testoplog插入部分数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107140223217-1786957581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 2 完整备份所有的数据库，执行的代码为上面的完整备份代码（保存到执行文件bkoplogtest_2XXX30），打印出执行过程如下截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181108004109405-136041771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 3 还原完整备份，执行的代码和打印执行过程如下：&lt;/p&gt;
&lt;p&gt;执行的命令：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongorestore -h 172.XXX.XXX.124 --port 2XXX20  --oplogReplay --authenticationDatabase 认证数据库-u 用户名-p '密码' --gzip /data/mongodb_back/testoplogbackfile/20181107&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;打印出的执行过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107163702966-14690828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 4 检查还原库的情况，检查库（testoplog）、表（testfullbefore01、testfullbefore02、testfullbefore03）是否还原。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107164132339-490464559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：完整还原后与原库完整备份时数据一致，符合测试预期。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt; 3. 增量备份与还原&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;增量备份与还原的测试案例描述&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;测试案例&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;第一次增量备份&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;第一次增量还原&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;第二次增量备份&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;第二次增量还原&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;源库&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;备份前，新建集合testdiffbk01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并插入10000笔数据&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 无操作&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;备份前，新建集合testdiffbk02&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并插入10000笔数据&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 无操作&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;还原库&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;无操作&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;还原后，检查testdiffbk01是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以及数据量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 无操作&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;还原后，检查testdiffbk02是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以及数据量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;step 1 第一次增量备份前，向源库中插入测试数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107195340945-1479518009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 2 第一次执行增量备份（执行增量备份的脚本，代码放置在执行文件mongodb_oplogbacktestoplog2XXXX.sh中）&lt;/p&gt;
&lt;h2&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107195640657-69634870.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;step 3 向源库中第二次插入测试数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107195735494-1363116325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 4 第二次执行增量备份&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107195842532-1892852197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两次增量备份产生的文件在 文件夹 /data/mongodb_back/mongodboplog_back/mongo27230 中，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107201351690-1838141352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 5 将完整备份所在路径下的文件清空，将第一次备份的产生的oplog.rs.bson 文件，copy至此路径下，并重命名为oplog.bson。【&lt;em&gt;&lt;strong&gt;即还原第一份增量备份&lt;/strong&gt;&lt;/em&gt;】&lt;/p&gt;
&lt;p&gt;清空指令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107201746480-276412176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Copy+ 重命名指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107201906095-1701568728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还原指令：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongorestore -h 172.XXX.XXX.124 --port 2XXX20 --oplogReplay --authenticationDatabase 验证数据库-u 用户名-p '密码' /data/mongodb_back/testoplogbackfile/20181107&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107202428767-1159408883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 7 验证第一次增量还原的数据，验证测试所用的集合testdiffbk01及数据,与原库第一次增量备份时一致，&lt;strong&gt;即已正常还原增量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107202604236-848123840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 8 将完整备份所在路径下的文件清空，将第二次增量备份的产生的oplog.rs.bson 文件，copy至此路径下，并重命名为oplog.bson。【&lt;em&gt;&lt;strong&gt;即还原第二份增量备份&lt;/strong&gt;&lt;/em&gt;】&lt;/p&gt;
&lt;p&gt;删除指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107202954600-1378468488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;copy + 重命名指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107203222465-371929014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还原增量备份的指令【与第一次执行的还原命令完全一样】&lt;/p&gt;
&lt;p&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongorestore -h 172.XXX.XXX.124 --port 2XXX20  --oplogReplay --authenticationDatabase 验证数据库-u 用户名-p '密码' /data/mongodb_back/testoplogbackfile/20181107&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107203518140-506665164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step 9  验证第二次增量还原的数据，验证测试所用的集合testdiffbk02及数据。结论：与原库第二次增量备份时一致，&lt;strong&gt;即已正常还原增量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181107203709921-1016083591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此次测试有完整备份与完整还原，还有两次增量备份月增量，详细演示增量还原方案的可行性和相关代码的可执行性，部署后满足生产所需。&lt;/p&gt;
&lt;h2&gt;五 注意事项&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一定要在还原完整备份的路径下，还原已备份oplog的增量文件。即先将已还原的完整备份文件删除，再将增量备份产生oplog.rs.bson文件copy至路径下，并且重命名为oplog.bson。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是在其他路径下，则报错，主要的错误信息为：&lt;/p&gt;
&lt;p&gt;2018-11-06T10:24:51.848+0800 &lt;strong&gt;checking for collection data in&lt;/strong&gt; /data/mongodb_back/bkrcs_test/oplog.bson&lt;br/&gt;2018-11-06T10:24:51.848+0800 &lt;strong&gt;Failed: no oplog file to replay; make sure you run mongodump with --oplog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;验证测试，完整备份（全库备份）的文件在 路径  &lt;strong&gt;/XXX/XXXX_back/bkrcs_2XXXX/20181105 &lt;/strong&gt;下 。&lt;/p&gt;
&lt;p&gt;如果我们将oplog的增量文件（oplog.rs集合导出的数据）/local/oplog.rs.bson 复制至 /XXX/XXXX_back/bkrcs_test/路径下，并重命名为oplog.bson&lt;/p&gt;
&lt;p&gt;执行restore命令报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181106110407701-792560039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们将/local/oplog.rs.bson复制至还原完整备份所在的路径下（ &lt;strong&gt;/XXX/XXXX_back/bkrcs_27XXX/20181105&lt;/strong&gt;），执行restore，测试不再报错。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201811/780228-20181106111838785-773571071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查新增数据也已同步过去。&lt;/p&gt;
&lt;p&gt;所以，还原时增量备份（oplog）一定要放置完整备份所在的文件夹下（copy前，先将完整备份完结删除）进行还原。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 17:43:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一 需求描述 我们知道数据是公司的重要资产，业务的系统化、信息化就是数字化。数据高效的存储与查询是系统完善和优化的方向，而数据库的稳定性、可靠性是实现的基础。高可用和RPO（RecoveryPoint</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9917137.html</dc:identifier>
</item>
<item>
<title>webpack4+express+mongodb+vue 实现增删改查 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/9926725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/9926725.html</guid>
<description>&lt;p&gt;在讲解之前，我们先来看看效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）整个页面的效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004220133-2036703397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 新增数据效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004245647-983419941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) 新增成功如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004303048-1473255869.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4) 编辑数据效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004355107-69457888.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5) 编辑成功效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004417822-1628548548.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6) 删除数据效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004437009-691536636.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7) 删除成功效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004456230-1415921852.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8) 查询效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181108004516028-1309944117.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如上的效果，下面我们还是和之前一样，先看看我们整个项目的架构如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### 目录结构如下：
demo1                                       # 工程名
&lt;/span&gt;|   |---&lt;span&gt; dist                               # 打包后生成的目录文件             
&lt;/span&gt;|   |---&lt;span&gt; node_modules                       # 所有的依赖包
&lt;/span&gt;|   |----&lt;span&gt;database                           # 数据库相关的文件目录
&lt;/span&gt;|   | |---&lt;span&gt;db.js                             # mongoose类库的数据库连接操作
&lt;/span&gt;|   | |---&lt;span&gt;user.js                           # Schema 创建模型
&lt;/span&gt;|   | |---&lt;span&gt;addAndDelete.js                   # 增删改查操作
&lt;/span&gt;|   |---&lt;span&gt; app
&lt;/span&gt;|   | |---&lt;span&gt;index
&lt;/span&gt;|   | | |--&lt;span&gt; views                           # 存放所有vue页面文件
&lt;/span&gt;|   | | | |--&lt;span&gt; list.vue                      # 列表数据
&lt;/span&gt;|   | | | |--&lt;span&gt; index.vue
&lt;/span&gt;|   | | |--&lt;span&gt; components                      # 存放vue公用的组件
&lt;/span&gt;|   | | |--&lt;span&gt; js                              # 存放js文件的
&lt;/span&gt;|   | | |--&lt;span&gt; css                             # 存放css文件
&lt;/span&gt;|   | | |--&lt;span&gt; store                           # store仓库
&lt;/span&gt;|   | | | |---&lt;span&gt; actions.js
&lt;/span&gt;|   | | | |---&lt;span&gt; mutations.js
&lt;/span&gt;|   | | | |---&lt;span&gt; state.js
&lt;/span&gt;|   | | | |--- mutations-&lt;span&gt;types.js
&lt;/span&gt;|   | | | |---&lt;span&gt; index.js
&lt;/span&gt;|   | | | |
|   | | |--&lt;span&gt; app.js                          # vue入口配置文件
&lt;/span&gt;|   | | |--&lt;span&gt; router.js                       # 路由配置文件
&lt;/span&gt;|   |---&lt;span&gt; views
&lt;/span&gt;|   | |--&lt;span&gt; index.html                        # html文件
&lt;/span&gt;|   |---&lt;span&gt; webpack.config.js                  # webpack配置文件 
&lt;/span&gt;|   |---&lt;span&gt; .gitignore  
&lt;/span&gt;|   |---&lt;span&gt; README.md
&lt;/span&gt;|   |---&lt;span&gt; package.json
&lt;/span&gt;|   |---&lt;span&gt; .babelrc                           # babel转码文件
&lt;/span&gt;|   |--- app.js                             # express入口文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上目录架构是我现在整个项目的架构图，其中database目录下存放 db.js ，该文件最主要是使用 mongoose 数据库连接操作，user.js 文件是创建一个Schema模型，也可以理解为表结构，addAndDelete.js 文件内部实现增删改查操作。&lt;/p&gt;
&lt;p&gt;如果对mongodb数据库相关的知识点不是很熟悉的话，可以先看下我之前写的一些关于mongodb文章(&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/category/1240772.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/category/1240772.html&lt;/a&gt;), 先在本地把数据库搭建起来后，再慢慢学习哦，我这边文章实现 vue+mongodb 实现增删改查也是基于上面这些文章的基础之上来进行的，特别是居于这篇 使用Mongoose类库实现简单的增删改查&lt;br/&gt;(&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9256605.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/9256605.html&lt;/a&gt;) 来进行的，增删改查操作及使用Schema 创建模型 都是居于这篇文章的基础之上再进行使用vue来重构下的。本篇文章也是依赖于饿了么vue组件进行开发的。&lt;/p&gt;
&lt;p&gt;先来分别讲下代码结构吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）使用express创建服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们在项目的根目录新建app.js, 该app.js 主要实现的功能是 启动 3001端口的服务器，并且使用 bodyParser进行解析数据，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express模块&lt;/span&gt;
const express = require('express'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建app对象&lt;/span&gt;
const app =&lt;span&gt; express();

const addAndDelete &lt;/span&gt;= require('./database/addAndDelete'&lt;span&gt;);

const bodyParser &lt;/span&gt;= require(&quot;body-parser&quot;&lt;span&gt;)

app.use(bodyParser.json());

app.use(bodyParser.urlencoded({ extended: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt; }));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用&lt;/span&gt;
app.use('/api'&lt;span&gt;, addAndDelete);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义服务器启动端口 &lt;/span&gt;
app.listen(3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'app listening on port 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入我们项目的根目录后，运行 node app.js 即可创建一个 http://127.0.0.1:3001 的服务器页面了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）数据库连接&lt;/strong&gt;&lt;br/&gt;在database/db.js 链接 mongodb://localhost:27017/dataDb 数据库。使用mongoose类库，如果不理解mongoose类库的话，可以返回来看我这篇文章（&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9256605.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/9256605.html&lt;/a&gt;）如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; mongoose = require('mongoose'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; DB_URL = 'mongodb://localhost:27017/dataDb'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 链接 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
mongoose.connect(DB_URL);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 链接成功 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
mongoose.connection.on(&lt;/span&gt;'connected', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  console.log(&lt;/span&gt;'Mongoose connection open to ' +&lt;span&gt; DB_URL);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链接异常&lt;/span&gt;
mongoose.connection.on('error', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err) {
  console.log(&lt;/span&gt;'Mongoose connection error:' +&lt;span&gt; err);
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链接断开&lt;/span&gt;
&lt;span&gt;
mongoose.connection.on(&lt;/span&gt;'disconnected', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  console.log(&lt;/span&gt;'Mongoose connection disconnected'&lt;span&gt;);
});
module.exports &lt;/span&gt;= mongoose;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）创建数据模型&lt;/strong&gt;&lt;br/&gt;在database/user.js 中使用 Schema创建一个模型，也就是说上面的 dataDb是数据库名称，这边使用schema创建的模型就是表结构的字段，有如下 name, age, sex 三个字段，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 定义一个user的Schema
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const mongoose &lt;/span&gt;= require('./db.js'&lt;span&gt;);
const Schema &lt;/span&gt;=&lt;span&gt; mongoose.Schema;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个模型&lt;/span&gt;
const UserSchema = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Schema({
  name: { type: String }, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性name，类型为String&lt;/span&gt;
  age: { type: Number, &lt;span&gt;default&lt;/span&gt;: 30 }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性age，类型为Number，默认值为30&lt;/span&gt;
&lt;span&gt;  sex: { type: String }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导出model模块&lt;/span&gt;
const User = module.exports = mongoose.model('User', UserSchema);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）实现增删改查路由接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下所有的增删改查的代码如下(如果代码看不懂的话，还是返回看这篇文章即可：&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9256605.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/9256605.html&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express 模块 &lt;/span&gt;
const express = require('express'&lt;span&gt;);

const router &lt;/span&gt;=&lt;span&gt; express.Router();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入user.js&lt;/span&gt;
const User = require('./user'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增一条数据 接口为add&lt;/span&gt;
router.post('/add', (req, res) =&amp;gt;&lt;span&gt; {
  const user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User({
    name: req.body.name,
    age: req.body.age,
    sex: req.body.sex
  });
  user.save((err, docs) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.send({ &lt;/span&gt;'code': 1, 'errorMsg': '新增失败'&lt;span&gt; });
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.send({ &lt;/span&gt;&quot;code&quot;: 0, 'message': '新增成功'&lt;span&gt; });
    }
  });
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询数据 &lt;/span&gt;
router.post('/query', (req, res) =&amp;gt;&lt;span&gt; {
  const name &lt;/span&gt;=&lt;span&gt; req.body.name,
    age &lt;/span&gt;=&lt;span&gt; req.body.age,
    sex &lt;/span&gt;=&lt;span&gt; req.body.sex;
  const obj &lt;/span&gt;=&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name !== ''&lt;span&gt;) {
    obj[&lt;/span&gt;'name'] =&lt;span&gt; name;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (age !== ''&lt;span&gt;) {
    obj[&lt;/span&gt;'age'] =&lt;span&gt; age;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sex !== ''&lt;span&gt;) {
    obj[&lt;/span&gt;'sex'] =&lt;span&gt; sex;
  }
  User.find(obj, (err, docs) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.send({ &lt;/span&gt;'code': 1, 'errorMsg': '查询失败'&lt;span&gt; });
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.send(docs);
    }
  });
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 _id 删除数据&lt;/span&gt;
router.post('/del', (req, res) =&amp;gt;&lt;span&gt; {
  const id &lt;/span&gt;=&lt;span&gt; req.body.id;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据自动分配的 _id 进行删除&lt;/span&gt;
  const whereid = { '_id'&lt;span&gt;: id };
  User.remove(whereid, (err, docs) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.send({ &lt;/span&gt;'code': 1, 'errorMsg': '删除失败'&lt;span&gt; });
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.send(docs);
    }
  })
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新数据&lt;/span&gt;
router.post('/update', (req, res) =&amp;gt;&lt;span&gt; {
  console.log(req.body)
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要更新的数据&lt;/span&gt;
  const id =&lt;span&gt; req.body.id,
    name &lt;/span&gt;=&lt;span&gt; req.body.name,
    age &lt;/span&gt;=&lt;span&gt; req.body.age,
    sex &lt;/span&gt;=&lt;span&gt; req.body.sex;
  const updateStr &lt;/span&gt;=&lt;span&gt; {
    name: name,
    age: age,
    sex: sex
  };
  const ids &lt;/span&gt;=&lt;span&gt; {
    _id: id
  };
  console.log(ids);
  User.findByIdAndUpdate(ids, updateStr, (err, docs) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.send({ &lt;/span&gt;'code': 1, 'errorMsg': '更新失败'&lt;span&gt; });
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.send(docs);
    }
  });
});
module.exports &lt;/span&gt;= router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5）搭建vue页面，如何通过页面的接口请求？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在app/index/views/list.vue 基本代码如下(所有的html代码是基于饿了么vue组件的，最主要一些form表单组件的用法及表格的插件及弹窗的插件)，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&amp;lt;style lang=&quot;stylus&quot;&amp;gt;&lt;span&gt;
  #list&lt;/span&gt;-&lt;span&gt;container 
    width &lt;/span&gt;100%
&amp;lt;/style&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;list-container&quot; style=&quot;margin:20px auto&quot;&amp;gt;
    &amp;lt;div style=&quot;width:100%;overflow:hidden;&quot;&amp;gt;
      &amp;lt;el-form ref=&quot;form&quot; label-width=&quot;80px&quot;&amp;gt;
        &amp;lt;div style=&quot;float:left;width:20%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;姓名&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;name&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;float:left;width:20%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;年龄&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;age&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;float:left;width:20%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;性别&quot;&amp;gt;
            &amp;lt;el-select v-model=&quot;sex&quot;&amp;gt;
              &amp;lt;el-&lt;span&gt;option
                v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&quot;item in options2&quot;&lt;span&gt;
                :key&lt;/span&gt;=&quot;item.value&quot;&lt;span&gt;
                :label&lt;/span&gt;=&quot;item.label&quot;&lt;span&gt;
                :value&lt;/span&gt;=&quot;item.value&quot;&amp;gt;
              &amp;lt;/el-option&amp;gt;
            &amp;lt;/el-select&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; style=&quot;margin-left:20px;&quot; @click=&quot;query(true)&quot;&amp;gt;查 询&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button type=&quot;success&quot; @click=&quot;newAdd&quot;&amp;gt;新 增&amp;lt;/el-button&amp;gt;
      &amp;lt;/el-form&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div style=&quot;width:90%; margin: 0 auto; border: 1px solid #ebebeb; border-radius: 3px;overflow:hidden;&quot;&amp;gt;
      &amp;lt;el-&lt;span&gt;table
        :data&lt;/span&gt;=&quot;tableData&quot;&lt;span&gt;
        style&lt;/span&gt;=&quot;width: 100%&quot;&amp;gt;
        &amp;lt;el-table-&lt;span&gt;column
          prop&lt;/span&gt;=&quot;name&quot;&lt;span&gt;
          label&lt;/span&gt;=&quot;姓名&quot;&lt;span&gt;
          width&lt;/span&gt;=&quot;180&quot;&amp;gt;
        &amp;lt;/el-table-column&amp;gt;
        &amp;lt;el-table-&lt;span&gt;column
          prop&lt;/span&gt;=&quot;age&quot;&lt;span&gt;
          label&lt;/span&gt;=&quot;年龄&quot;&lt;span&gt;
          width&lt;/span&gt;=&quot;180&quot;&amp;gt;
        &amp;lt;/el-table-column&amp;gt;
        &amp;lt;el-table-&lt;span&gt;column
          prop&lt;/span&gt;=&quot;sex&quot;&lt;span&gt;
          label&lt;/span&gt;=&quot;性别&quot;&amp;gt;
        &amp;lt;/el-table-column&amp;gt;
        &amp;lt;el-table-&lt;span&gt;column
          fixed&lt;/span&gt;=&quot;right&quot;&lt;span&gt;
          label&lt;/span&gt;=&quot;操作&quot;&lt;span&gt;
          width&lt;/span&gt;=&quot;100&quot;&amp;gt;
          &amp;lt;template slot-scope=&quot;scope&quot;&amp;gt;
            &amp;lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;editFunc(scope.row)&quot;&amp;gt;编辑&amp;lt;/el-button&amp;gt;
            &amp;lt;el-button type=&quot;text&quot; size=&quot;small&quot; @click=&quot;delFunc(scope.row)&quot;&amp;gt;删除&amp;lt;/el-button&amp;gt;
          &amp;lt;/template&amp;gt;
        &amp;lt;/el-table-column&amp;gt;
      &amp;lt;/el-table&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;el-&lt;span&gt;dialog
      title&lt;/span&gt;=&quot;新增&quot;&lt;span&gt;
      :visible.sync&lt;/span&gt;=&quot;dialogVisible&quot;&lt;span&gt;
      width&lt;/span&gt;=&quot;30%&quot;&amp;gt;
      &amp;lt;el-form label-width=&quot;40px&quot;&amp;gt;
        &amp;lt;div style=&quot;float:left;width:100%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;姓名&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;add.name&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;float:left;width:100%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;年龄&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;add.age&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;float:left;width:100%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;性别&quot;&amp;gt;
            &amp;lt;el-select v-model=&quot;add.sex&quot;&amp;gt;
              &amp;lt;el-&lt;span&gt;option
                v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&quot;item in options2&quot;&lt;span&gt;
                :key&lt;/span&gt;=&quot;item.value&quot;&lt;span&gt;
                :label&lt;/span&gt;=&quot;item.label&quot;&lt;span&gt;
                :value&lt;/span&gt;=&quot;item.value&quot;&amp;gt;
              &amp;lt;/el-option&amp;gt;
            &amp;lt;/el-select&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/el-form&amp;gt;
      &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt;
        &amp;lt;el-button @click=&quot;dialogVisible = false&quot;&amp;gt;取 消&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; @click=&quot;addConfirm&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt;
      &amp;lt;/span&amp;gt;
    &amp;lt;/el-dialog&amp;gt;
    &amp;lt;el-&lt;span&gt;dialog
      title&lt;/span&gt;=&quot;编辑&quot;&lt;span&gt;
      :visible.sync&lt;/span&gt;=&quot;dialogVisible2&quot;&lt;span&gt;
      width&lt;/span&gt;=&quot;30%&quot;&amp;gt;
      &amp;lt;el-form label-width=&quot;40px&quot;&amp;gt;
        &amp;lt;div style=&quot;float:left;width:100%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;姓名&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;update.name&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;float:left;width:100%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;年龄&quot;&amp;gt;
            &amp;lt;el-input v-model=&quot;update.age&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;float:left;width:100%&quot;&amp;gt;
          &amp;lt;el-form-item label=&quot;性别&quot;&amp;gt;
            &amp;lt;el-select v-model=&quot;update.sex&quot;&amp;gt;
              &amp;lt;el-&lt;span&gt;option
                v&lt;/span&gt;-&lt;span&gt;for&lt;/span&gt;=&quot;item in options2&quot;&lt;span&gt;
                :key&lt;/span&gt;=&quot;item.value&quot;&lt;span&gt;
                :label&lt;/span&gt;=&quot;item.label&quot;&lt;span&gt;
                :value&lt;/span&gt;=&quot;item.value&quot;&amp;gt;
              &amp;lt;/el-option&amp;gt;
            &amp;lt;/el-select&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/el-form&amp;gt;
      &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt;
        &amp;lt;el-button @click=&quot;dialogVisible = false&quot;&amp;gt;取 消&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; @click=&quot;editConfirm&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt;
      &amp;lt;/span&amp;gt;
    &amp;lt;/el-dialog&amp;gt;
    &amp;lt;el-&lt;span&gt;dialog
      title&lt;/span&gt;=&quot;提示&quot;&lt;span&gt;
      :visible.sync&lt;/span&gt;=&quot;dialogVisible3&quot;&lt;span&gt;
      width&lt;/span&gt;=&quot;30%&quot;&amp;gt;
      &amp;lt;div&amp;gt;是否确认删除?&amp;lt;/div&amp;gt;
      &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt;
        &amp;lt;el-button @click=&quot;dialogVisible3 = false&quot;&amp;gt;取 消&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; @click=&quot;delConfirm&quot;&amp;gt;确 定&amp;lt;/el-button&amp;gt;
      &amp;lt;/span&amp;gt;
    &amp;lt;/el-dialog&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {  
        formLabelWidth: &lt;/span&gt;'120px'&lt;span&gt;,
        name: &lt;/span&gt;''&lt;span&gt;,
        age: &lt;/span&gt;''&lt;span&gt;,
        sex: &lt;/span&gt;''&lt;span&gt;,
        options2: [
          {
            value: &lt;/span&gt;'1'&lt;span&gt;,
            label: &lt;/span&gt;'男'&lt;span&gt;
          }, {
            value: &lt;/span&gt;'2'&lt;span&gt;,
            label: &lt;/span&gt;'女'&lt;span&gt;
          }
        ],
        tableData: [],
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增页面&lt;/span&gt;
&lt;span&gt;        add: {
          name: &lt;/span&gt;''&lt;span&gt;,
          age: &lt;/span&gt;''&lt;span&gt;,
          sex: &lt;/span&gt;''&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改页面&lt;/span&gt;
&lt;span&gt;        update: {
          name: &lt;/span&gt;''&lt;span&gt;,
          age: &lt;/span&gt;''&lt;span&gt;,
          sex: &lt;/span&gt;''&lt;span&gt;
        },
        dialogVisible: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        dialogVisible2: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        dialogVisible3: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        row: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
        _id: &lt;/span&gt;''&lt;span&gt;
      }
    },
    created() {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.query();
    },
    methods: {
      setData(datas) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (datas.length &amp;gt; 0&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; datas.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (datas[i].sex * 1 === 1&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$set(datas[i], 'sex', '男'&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (datas[i].sex * 1 === 2&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$set(datas[i], 'sex', '女'&lt;span&gt;);
            }
          }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; datas;
      },
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询数据&lt;/span&gt;
&lt;span&gt;      query(isquery) {
        const obj &lt;/span&gt;=&lt;span&gt; {
          name: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name,
          age: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age,
          sex: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sex
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('/api/query', obj).then((res) =&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.ok) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tableData = res.body ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData(res.body) : [];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isquery) {
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
                message: &lt;/span&gt;'查询成功'&lt;span&gt;,
                type: &lt;/span&gt;'success'&lt;span&gt;
              });
            }
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isquery) {
              &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
                message: &lt;/span&gt;'查询失败'&lt;span&gt;,
                type: &lt;/span&gt;'warning'&lt;span&gt;
              });
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tableData =&lt;span&gt; [];
          }
        });
      },
      newAdd() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      },
      editFunc(row) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible2 = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._id =&lt;span&gt; row._id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$set(&lt;span&gt;this&lt;/span&gt;.$data.update, 'name'&lt;span&gt;, row.name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$set(&lt;span&gt;this&lt;/span&gt;.$data.update, 'age'&lt;span&gt;, row.age);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$set(&lt;span&gt;this&lt;/span&gt;.$data.update, 'sex'&lt;span&gt;, row.sex);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.row =&lt;span&gt; row;
      },
      delFunc(row) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible3 = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        console.log(row);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.row =&lt;span&gt; row;
      },
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编辑页面提交&lt;/span&gt;
&lt;span&gt;      editConfirm() {
        const id &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._id,
          name &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.update.name,
          age &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.update.age,
          sex &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.update.sex;
        const obj &lt;/span&gt;=&lt;span&gt; {
          id: id,
          name: name,
          age: age,
          sex: sex
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('/api/update', obj).then((res) =&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.ok) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除成功&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
              message: &lt;/span&gt;'更新成功'&lt;span&gt;,
              type: &lt;/span&gt;'success'&lt;span&gt;
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新请求下查询&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.query(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除成功&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
              message: &lt;/span&gt;'更新失败'&lt;span&gt;,
              type: &lt;/span&gt;'success'&lt;span&gt;
            });
          }
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible2 = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        });
      },
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除提交&lt;/span&gt;
&lt;span&gt;      delConfirm() {
        const obj &lt;/span&gt;=&lt;span&gt; {
          &lt;/span&gt;'id': &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.row._id
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('/api/del', obj).then((res) =&amp;gt;&lt;span&gt; {
          console.log(res.body)
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.body.ok) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除成功&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
              message: &lt;/span&gt;'删除成功'&lt;span&gt;,
              type: &lt;/span&gt;'success'&lt;span&gt;
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功后，触发重新查询下数据 &lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.query();
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除失败&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
              message: res.body.errorMsg,
              type: &lt;/span&gt;'warning'&lt;span&gt;
            });
          }
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible3 = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        });
      },
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增提交&lt;/span&gt;
&lt;span&gt;      addConfirm() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增的时候，姓名，年龄，性别 不能为空，这里就不判断了。。。&lt;/span&gt;
        const obj =&lt;span&gt; {
          name: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.add.name,
          age: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.add.age,
          sex: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.add.sex
        };
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('/api/add', obj).then((res) =&amp;gt;&lt;span&gt; {
          console.log(&lt;/span&gt;111&lt;span&gt;);
          console.log(res);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.body.code === 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
              message: &lt;/span&gt;'新增成功'&lt;span&gt;,
              type: &lt;/span&gt;'success'&lt;span&gt;
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功后，触发重新查询下数据 &lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.query();
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
              message: res.body.errorMsg,
              type: &lt;/span&gt;'warning'&lt;span&gt;
            });
          }
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dialogVisible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        });
      }
    }
  }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6. 解决跨域问题，及接口如何访问的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们是使用express启动的是 http://127.0.0.1:3001 服务器的，但是在我们的webpack中使用的是8081端口的，也就是说页面访问的是http://127.0.0.1:8081/ 这样访问的话，因此肯定会存在接口跨域问题的，因此我们需要在webpack中使用 devServer.proxy 配置项配置一下，如下代码配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  devServer: {
    port: &lt;/span&gt;8081&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; host: '0.0.0.0',&lt;/span&gt;
&lt;span&gt;    headers: {
      &lt;/span&gt;'X-foo': '112233'&lt;span&gt;
    },
    inline: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    overlay: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    stats: &lt;/span&gt;'errors-only'&lt;span&gt;,
    proxy: {
      &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://127.0.0.1:3001'&lt;span&gt;,
        changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否跨域&lt;/span&gt;
&lt;span&gt;      }
    }
  },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我list.vue页面所有的请求都是类似于这样请求的 this.$http.post('/api/query', obj); 因此当我使用 /api/query请求的话，它会被代理到 http://127.0.0.1:3001/api/query, 这样就可以解决跨域的问题了，同时我们在项目的根目录中的 将路由应用到 app.js 中，有如下这句代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const addAndDelete = require('./database/addAndDelete'&lt;span&gt;);
app.use(&lt;/span&gt;'/api', addAndDelete);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当请求http://127.0.0.1:3001/api/query的时候，会自动使用 addAndDelete.js 中的 /query的接口方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/webpack-all-demo/tree/master/webpack%2Bvue%2Bmongodb%2Bexpress&quot; target=&quot;_blank&quot;&gt;查看github代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 16:54:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>webpack4+express+mongodb+vue 实现增删改查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/9926725.html</dc:identifier>
</item>
<item>
<title>手把手教你写DI_2_小白徒手撸构造函数注入 - victor.x.qu</title>
<link>http://www.cnblogs.com/fs7744/p/9926523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fs7744/p/9926523.html</guid>
<description>&lt;p&gt;在上一节：&lt;a href=&quot;https://www.cnblogs.com/fs7744/p/9924569.html&quot;&gt;手把手教你写DI_1_DI框架有什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们已经知道我们要撸哪些东西了&lt;/p&gt;
&lt;p&gt;那么我们开始动工吧，这里呢，我们找小白同学来表演下&lt;/p&gt;
&lt;p&gt;小白同学 ：我们先定义一下我们的广告招聘纸有什么：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public abstract class ServiceDefintion  // 小白同学 ：我们换个名字，不叫 ServiceDescriptor ，撸也要撸出自己的标志嘛
{
    public abstract Type ServiceType { get; }
    public abstract Type ImplementationType { get; }
    public abstract Lifetime Lifetime { get; }
}

public enum Lifetime  // 小白同学 ：定义一下要支持的三种生命周期
{
    Singleton,
    Scoped,
    Transient
}

// 小白同学 ：搞个集合存放他们
public interface IServiceDefintions : IEnumerable&amp;lt;ServiceDefintion&amp;gt;
{
    void Add(ServiceDefintion serviceDefintion);
}

public class ServiceDefintions : IServiceDefintions
{
    private readonly List&amp;lt;ServiceDefintion&amp;gt; services = new List&amp;lt;ServiceDefintion&amp;gt;();

    public void Add(ServiceDefintion serviceDefintion)
    {
        if (serviceDefintion == null)
        {
            throw new ArgumentNullException(nameof(serviceDefintion));
        }
        services.Add(serviceDefintion);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，我们实现两种不同的广告类型&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TypeServiceDefintion : ServiceDefintion  // 小白同学 ：这种是只提供类型的，怎么建立实例需要我们解析生成，但是对使用DI的人来说，很方便，不用管怎么去new
{
    public override Type ServiceType { get; }
    public override Type ImplementationType { get; }
    public override Lifetime Lifetime { get; }

    public TypeServiceDefintion(Type serviceType, Type implementationType, Lifetime lifetime)
    {
        ServiceType = serviceType;
        ImplementationType = implementationType;
        Lifetime = lifetime;
    }
}

public interface IImplementationFactory
{
    Func&amp;lt;INamedServiceProvider, object&amp;gt; ImplementationFactory { get; }
}

public class DelegateServiceDefintion : ServiceDefintion, IImplementationFactory  // 小白同学 ：这种是用户自己new对象，少数特殊情况，用户会自己写特殊逻辑，所以我们需要提供支持
{
    public DelegateServiceDefintion(Type serviceType, Type implementationType, Lifetime lifetime,
        Func&amp;lt;IServiceProvider, object&amp;gt; implementationFactory)
    {
        ServiceType = serviceType;
        ImplementationType = implementationType;
        Lifetime = lifetime;
        ImplementationFactory = implementationFactory;
    }

    public override Type ServiceType { get; }

    public override Type ImplementationType { get; }

    public override Lifetime Lifetime { get; }

    public Func&amp;lt;IServiceProvider, object&amp;gt; ImplementationFactory { get; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学 ：好了，我们有服务定义描述了，来创建&lt;code&gt;IServiceProvider&lt;/code&gt;吧&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly IServiceDefintions services;

    public ServiceProvider(IServiceDefintions services)
    {
        this.services = services;
    }
    public object GetService(Type serviceType)
    {
        var defintion = TryGetDefintion(serviceType); // 小白同学 ：查找一下服务定义
        if (defintion != null)
        {
            switch (defintion.Lifetime)
            {
                case Lifetime.Singleton:
                    return null;  // 小白同学 ：啥？怎么处理？emm 后面说吧，脑容量不够啦

                case Lifetime.Scoped:
                    return null;  // 小白同学 ：啥？怎么处理？emm 后面说吧，脑容量不够啦

                case Lifetime.Transient:
                    if(defintion is DelegateServiceDefintion defi)
                    {
                        return defi.ImplementationFactory(this);
                        // 小白同学 ：haha, 不用我们做，真简单
                    }
                    else // 小白同学 ：TypeServiceDefintion
                    {
                        // 小白同学 ：啥？怎么处理？emm 后面说吧，脑容量不够啦
                    }

                default:
                    return null;
            }
        }
        else
        {
            return null;
        }
    }

    private ServiceDefintion TryGetDefintion(Type serviceType)
    {
        return services.FirstOrDefault(i =&amp;gt; i.ServiceType == serviceType);  //大神： what ? 每次都遍历一下？太low了吧？
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学 ：捂脸.gif 我们居然每次都遍历，简直太笨了，赶紧改下，免得大神吐槽&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly Dictionary&amp;lt;Type, ServiceDefintion&amp;gt; services;

    public ServiceProvider(IServiceDefintions services)
    {
        this.services = services.ToDictionary(i =&amp;gt; i.ServiceType);  
        //大神： what 1 ? 有相同的 ServiceType 怎么办？ 
    }

    private ServiceDefintion TryGetDefintion(Type serviceType)  //大神： what 2 ? 这个方法怎么这么怪
    {
        services.TryGetValue(serviceType, out var defintion);  
        return defintion;
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学 ：又被吐槽了，再改下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly Dictionary&amp;lt;Type, ServiceDefintion[]&amp;gt; services;  
    //大神： 呵呵，你就这样写吧，我打赌100块你后面肯定要改
    //小白同学: ......

    public ServiceProvider(IServiceDefintions services)
    {
        this.services = services.GroupBy(i =&amp;gt; i.ServiceType).ToDictionary(i =&amp;gt; i.Key, i =&amp;gt; i.ToArray());
    }

    private ServiceDefintion TryGetDefintion(Type serviceType) 
    {
        return services.TryGetValue(serviceType, out var defintion) ? defintion.LastOrDefault() : null;
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 好了，我们简单测试一下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void Test()
{
    var a = new ServiceDefintions();
    a.Add(new DelegateServiceDefintion(typeof(TransientTest),typeof(TransientTest),Lifetime.Transient,i =&amp;gt; this));
    var service = new ServiceProvider(a);

    var result0 = service.GetService(typeof(TransientTest));
    Assert.Same(this, result0);
}
// 大神： 你用this 去测瞬态？你确定this是瞬态的func 每次都会调用？
// 小白同学: 我。。。。。。我改&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void Test()
{
    var a = new ServiceDefintions();
    a.Add(new DelegateServiceDefintion(typeof(TransientTest),typeof(TransientTest),Lifetime.Transient,i =&amp;gt; new TransientTest()));
    var service = new ServiceProvider(a);

    var result0 = service.GetService(typeof(TransientTest));
    var result1 = service.GetService(typeof(TransientTest));
    Assert.NotNull(result0);
    Assert.NotNull(result1);
    Assert.NotSame(result0, result1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 我们来做TypeServiceDefintion 解析支持&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    public object GetService(Type serviceType)
    {
        ...

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                var d = defintion as TypeServiceDefintion;
                var constructor = d.ImplementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic); // 小白同学:  反射获取构造函数
                var ps = constructor.GetParameters();
                var args = new object[ps.Length];
                for (int j = 0; j &amp;lt; ps.Length; j++)
                {
                    var p = ps[j];
                    args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                }
                return constructor.Invoke(args);  // 小白同学:  创建;
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 你看我写的不错吧&lt;/p&gt;
&lt;p&gt;大神：呵呵，这样反射性能你考虑了吗？ 泛型你考虑了吗? 还有你每次都重新生成DelegateServiceDefintion？&lt;/p&gt;
&lt;p&gt;小白同学: 我知道反射该用IL或者表达式树处理，但观众不好看嘛&lt;/p&gt;
&lt;p&gt;大神：呵呵，你不会写吧，你看看人家lemon大神怎么写的 - &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/reflection/src/AspectCore.Extensions.Reflection/ConstructorReflector.cs&quot;&gt;file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小白同学: 好，我下来学习。 泛型不过是再动态生成一下类型嘛，这样就行啦&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    public object GetService(Type serviceType)
    {
        ...

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                var d = defintion as TypeServiceDefintion;
                var implementationType = serviceType.IsConstructedGenericType 
                    ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                    : d.ImplementationType;
                var constructor = implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic); // 小白同学:  反射获取构造函数
                .....
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 哦，还有缓存：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly Dictionary&amp;lt;Type, ConstructorInfo&amp;gt; cache = new Dictionary&amp;lt;Type, ConstructorInfo&amp;gt;();

    public object GetService(Type serviceType)
    {
        ...

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                ConstructorInfo constructor = null;
                if(cache.ContainsKey(serviceType))
                {
                    constructor = cache[serviceType];
                }
                else 
                {
                    var d = defintion as TypeServiceDefintion;
                    var implementationType = serviceType.IsConstructedGenericType 
                        ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                        : d.ImplementationType;
                    constructor = cache[serviceType] = implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic); // 小白同学:  反射获取构造函数
                }
                ....
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大神： .......我想自闭..... 你都不考虑多线程吗？&lt;/p&gt;
&lt;p&gt;小白同学: ！！！ 我，我，我，我换成它 &lt;code&gt;ConcurrentDictionary&amp;lt;Type, ConstructorInfo&amp;gt; cache&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大神：算你NB，&lt;code&gt;Singleton&lt;/code&gt; 和 &lt;code&gt;Scoped&lt;/code&gt; 你打算怎么做？&lt;/p&gt;
&lt;p&gt;小白同学: 简单， copy 一下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly ConcurrentDictionary&amp;lt;Type, ConstructorInfo&amp;gt; cache = new ConcurrentDictionary&amp;lt;Type, ConstructorInfo&amp;gt;();

    public object GetService(Type serviceType)
    {
        case Lifetime.Singleton:
                if(defintion is DelegateServiceDefintion defi)
                {
                    return defi.ImplementationFactory(this);
                }
                else
                {
                    ConstructorInfo constructor = cache.GetOrAdd(serviceType, i =&amp;gt; 
                    {
                        var d = defintion as TypeServiceDefintion;
                        var implementationType = serviceType.IsConstructedGenericType 
                            ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                            : d.ImplementationType;
                        return implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic);
                    });
                    ar ps = constructor.GetParameters();
                    var args = new object[ps.Length];
                    for (int j = 0; j &amp;lt; ps.Length; j++)
                    {
                        var p = ps[j];
                        args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                    }
                    return constructor.Invoke(args);  // 小白同学:  创建;
                }

        case Lifetime.Scoped:
                if(defintion is DelegateServiceDefintion defi)
                {
                    return defi.ImplementationFactory(this);
                }
                else
                {
                    ConstructorInfo constructor = cache.GetOrAdd(serviceType, i =&amp;gt; 
                    {
                        var d = defintion as TypeServiceDefintion;
                        var implementationType = serviceType.IsConstructedGenericType 
                            ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                            : d.ImplementationType;
                        return implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic);
                    });
                    ar ps = constructor.GetParameters();
                    var args = new object[ps.Length];
                    for (int j = 0; j &amp;lt; ps.Length; j++)
                    {
                        var p = ps[j];
                        args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                    }
                    return constructor.Invoke(args);  // 小白同学:  创建;
                }

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                ConstructorInfo constructor = cache.GetOrAdd(serviceType, i =&amp;gt; 
                {
                    var d = defintion as TypeServiceDefintion;
                    var implementationType = serviceType.IsConstructedGenericType 
                        ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                        : d.ImplementationType;
                    return implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic);
                });
                ar ps = constructor.GetParameters();
                var args = new object[ps.Length];
                for (int j = 0; j &amp;lt; ps.Length; j++)
                {
                    var p = ps[j];
                    args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                }
                return constructor.Invoke(args);  // 小白同学:  创建;
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大神：我！！！！！！！！！！ 我给你一刀！！！！！！！&lt;/p&gt;
&lt;p&gt;小白同学: 啊！！！！！！！！！&lt;/p&gt;
&lt;p&gt;由于小白同学受伤，本次节目中断，等小白同学养好伤，我们再继续&lt;/p&gt;
&lt;p&gt;下一章 小白徒手支持 &lt;code&gt;Singleton&lt;/code&gt; 和 &lt;code&gt;Scoped&lt;/code&gt; 生命周期&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 15:23:00 +0000</pubDate>
<dc:creator>victor.x.qu</dc:creator>
<og:description>小白徒手撸构造函数注入 在上一节：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fs7744/p/9926523.html</dc:identifier>
</item>
<item>
<title>动态SQL - 安心。</title>
<link>http://www.cnblogs.com/anxin0/p/9926500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anxin0/p/9926500.html</guid>
<description>&lt;h4 id=&quot;使用动态sql完成多条件查询&quot;&gt;使用动态SQL完成多条件查询&lt;/h4&gt;
&lt;p&gt;动态SQl是MyBatis的一个强大的特性,在使用JDBC操作数据时,如果查询条件过多,将字符串联成SQL语句是比较麻烦的一件事,且容易出错,有了动态SQL我们就可以使用动态SQL，动态SQL基于OGNL表达式,可使我们方便地在SQL语句中实现某些逻辑。好了废话不多说,接下来我们看下示例&lt;/p&gt;
&lt;p&gt;==在这里我们还是使用上一篇文章使用的示例,只是修改一下,大家可以先看一下上一篇文章==&lt;/p&gt;
&lt;p&gt;用于实现动态SQL的元素如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;if：利用if实现简单的条件选择&lt;/li&gt;
&lt;li&gt;choose(when,otherwise)：相当于Java中的switch语句，通常与when和otherwise搭配&lt;/li&gt;
&lt;li&gt;where：简化SQL语句中where的条件判断。&lt;/li&gt;
&lt;li&gt;set：解决动态更新语句 trim：可以灵活地去除多余的关键字&lt;/li&gt;
&lt;li&gt;foreach：迭代一个集合，通常用于in条件&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;使用if做多条件查询&quot;&gt;使用if做多条件查询&lt;/h5&gt;
&lt;p&gt;修改UserMapper.xml文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserList&quot; resultMap=&quot;userList&quot;&amp;gt;
    SELECT u.*,r.roleName FROM USER u,Role r WHERE u.userRole=r.id
    &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;
        AND u.userRole=#{userRole}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&quot;userName!=null and userName!=''&quot;&amp;gt;
        AND u.userName LIKE concat('%',#{userName},'%')
    &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的意思就是,如果有角色id就以角色id查询,有用户名字就以用户名字查询,若都没有就全部查询,这和我们之前JDBC中where条件加1==1的意思是一样的&lt;br/&gt;修改接口中的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserList(@Param(&quot;userRole&quot;)Integer roleId,@Param(&quot;userName&quot;)String userName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void testQuery(){
    SqlSession sqlSession=null; 
    try{
      sqlSession=MyBatisUtil.createSqlSession();
      //这里我们就写两个参数,看看会出现什么结果
      List&amp;lt;User&amp;gt; userList=sqlSession.getMapper(UserMapper.class).getUserList(2,null);
      for (User user: userList) {
            System.out.println(user.getUserName());
        }
    }catch (Exception ex){
        ex.printStackTrace();
    }finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用where&quot;&gt;使用where&lt;/h5&gt;
&lt;p&gt;where元素主要用来简化SQL语句中的where条件判断,并能智能地处理and和or,如果有多余的and或者or where会智能的去除,我们可以把他和if联合起来一块使用&lt;/p&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--注意开启自动映射--&amp;gt;
&amp;lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&amp;gt;
    SELECT * FROM USER
    &amp;lt;where&amp;gt;
    &amp;lt;if test=&quot;userName!=null and userName!=''&quot;&amp;gt;
       AND userName LIKE concat('%',#{userName},'%')
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;
            AND userRole=#{userRole}
        &amp;lt;/if&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用iftrim实现多条件查询&quot;&gt;使用if+trim实现多条件查询&lt;/h5&gt;
&lt;p&gt;trim元素也会自动识别其标签是否有返回值,若有返回值,会在自己包含前后加上某些前缀(比如我们的修改语句加set),也可在其后加上某些后缀(就像我们的修改语句最后一般会有个修改的条件) 后续我们会详细的讲前缀后缀的使用方法&lt;/p&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&amp;gt;
    SELECT * FROM USER
    &amp;lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&amp;gt;
        &amp;lt;if test=&quot;userName!=null and userName!=''&quot;&amp;gt;
            AND userName LIKE concat('%',#{userName},'%')
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;
        AND userRole=#{userRole}
        &amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;prefix：前缀，作用是通过自动识别是否有返回值后，在trim包含的内容上加上前缀，如此处的 where&lt;br/&gt;suffix：后缀，作用是在trim包含的内容上加上后缀&lt;br/&gt;prefixOverrides：对于trim包含内容的首部进行指定内容（如此处的&quot;and | or&quot;）的忽略&lt;br/&gt;suffixOverrides：对用trim包含的内容的首尾进行指定内容的忽略&lt;/p&gt;
&lt;h4 id=&quot;使用动态sql实现更新操作&quot;&gt;使用动态SQL实现更新操作&lt;/h4&gt;
&lt;p&gt;==使用if+set改造更新操作==&lt;/p&gt;
&lt;p&gt;set元素主要用于更新操作,它的主要功能和where元素差不多,主要是在包含的语句前面输出一个set,若包含的语句逗号结尾，自动忽略逗号&lt;br/&gt;在映射文件中编写修改语句&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;update id=&quot;modify&quot; parameterType=&quot;User&quot;&amp;gt;
    UPDATE USER
     &amp;lt;set&amp;gt;
         &amp;lt;if test=&quot;userCode!=null&quot;&amp;gt;userCode=#{userCode},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;userName!=null&quot;&amp;gt;userName=#{userName},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;userPassword!=null&quot;&amp;gt;userPassword=#{userPassword},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;phone!=null&quot;&amp;gt;phone=#{phone},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;address!=null&quot;&amp;gt;address=#{address},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;userRole=#{userRole},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;modifyBy!=null&quot;&amp;gt;modifyBy=#{modifyBy},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;modifyDate!=null&quot;&amp;gt;modifyDate=#{modifyDate},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;birthday!=null&quot;&amp;gt;birthday=#{birthday},&amp;lt;/if&amp;gt; 
    &amp;lt;/set&amp;gt;
    WHERE id=#{id}
&amp;lt;/update&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;==下面我们用if+trim修改SQl语句==&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;update id=&quot;modify&quot; parameterType=&quot;User&quot;&amp;gt;
    UPDATE USER
    &amp;lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; suffix=&quot;where id=#{id}&quot;&amp;gt;
             &amp;lt;if test=&quot;userCode!=null&quot;&amp;gt;userCode=#{userCode},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;userName!=null&quot;&amp;gt;userName=#{userName},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;userPassword!=null&quot;&amp;gt;userPassword=#{userPassword},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;phone!=null&quot;&amp;gt;phone=#{phone},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;address!=null&quot;&amp;gt;address=#{address},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;userRole=#{userRole},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;modifyBy!=null&quot;&amp;gt;modifyBy=#{modifyBy},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;modifyDate!=null&quot;&amp;gt;modifyDate=#{modifyDate},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;birthday!=null&quot;&amp;gt;birthday=#{birthday},&amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
&amp;lt;/update&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性的意思上面也都说过了,大家可以翻到上面看一下&lt;/p&gt;
&lt;h5 id=&quot;使用foreach完成复杂查询&quot;&gt;使用foreach完成复杂查询&lt;/h5&gt;
&lt;p&gt;上面我们已经讲过动态SQL的if,where,trim,set元素来处理一些简单查询操作,那么对于一些SQL语句中含有in条件,我们就需要使用foreach标签&lt;/p&gt;
&lt;p&gt;foreach主要用在构建in条件中，在sql语句中迭代一个集合。它的主要属性有，item、index、&lt;br/&gt;collection、separator、close、open。下面我们通过示例给大家进行详细介绍&lt;/p&gt;
&lt;p&gt;1.MyBatis入参为数组类型的foreach类型&lt;br/&gt;编写接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserByRoleId_foreach_array(Integer[] roleIds);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;resultMap id=&quot;userMapByRole&quot; type=&quot;User&quot;&amp;gt;
    &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
    &amp;lt;result property=&quot;userCode&quot; column=&quot;userCode&quot;/&amp;gt;
    &amp;lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&quot;getUserByRoleId_foreach_array&quot; resultMap=&quot;userMapByRole&quot;&amp;gt;
    SELECT * FROM USER WHERE userRole IN
    &amp;lt;foreach collection=&quot;array&quot; item=&quot;roleIds&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&amp;gt;
        #{roleIds}
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void testGetUserByRoleId_foreach_array(){
    SqlSession sqlSession=null;
    List&amp;lt;User&amp;gt; userList=new ArrayList&amp;lt;User&amp;gt;(); 
    Integer[] roleIds={2,3};
    try{
        sqlSession=MyBatisUtil.createSqlSession();
        userList=sqlSession.getMapper(UserMapper.class).getUserByRoleId_foreach_array(roleIds); 
    }catch (Exception ex){
        ex.printStackTrace();
    }finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }
    for (User user: userList) {
        System.out.println(user.getUserName()+&quot;\t&quot;+user.getAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个属性的意思:&lt;br/&gt;item：表示集合中每一个元素进行迭代时的名称&lt;br/&gt;index：指定一个名称，用于表示在迭代过程中，每次迭代到的位置&lt;br/&gt;open：表示该语句以什么开始（in语句以&quot;（&quot;开始）&lt;br/&gt;separator：表示在每次迭代之间以什么符号做分割符&lt;br/&gt;close：表示该语句以什么结束&lt;br/&gt;collection：必须指定，入参为单参类型是List时，collection属性值为list;入参为单参是数组时，为 array；若为多参，需封装Map&lt;br/&gt;parameterType可以不配置，MyBatis会自动封装为Map传入&lt;/p&gt;
&lt;p&gt;2.MyBatis入参为List类型的foreach迭代&lt;br/&gt;在接口中添加方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserByRoleId_foreach_list(List&amp;lt;Integer&amp;gt; roleList);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;resultMap id=&quot;userMapByRole&quot; type=&quot;User&quot;&amp;gt;
    &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
    &amp;lt;result property=&quot;userCode&quot; column=&quot;userCode&quot;/&amp;gt;
    &amp;lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&quot;getUserByRoleId_foreach_list&quot; resultMap=&quot;userMapByRole&quot;&amp;gt;
    SELECT * FROM USER WHERE userRole IN
    &amp;lt;foreach collection=&quot;list&quot; item=&quot;roleIds&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&amp;gt;
        #{roleIds}  
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void testGetUserByRoleId_foreach_array(){
    SqlSession sqlSession=null;
    List&amp;lt;User&amp;gt; userList=new ArrayList&amp;lt;User&amp;gt;();
    List&amp;lt;Integer&amp;gt; nums=new ArrayList&amp;lt;Integer&amp;gt;();
    nums.add(1);
    nums.add(2); 
    try{
     sqlSession=MyBatisUtil.createSqlSession();
      userList=sqlSession.getMapper(UserMapper.class).getUserByRoleId_foreach_list(nums);
     }catch (Exception ex){
      ex.printStackTrace();
    }finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }
    for (User user:  userList) {
        System.out.println(user.getUserName()+&quot;\t&quot;+user.getAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.MyBatis入参为Map类型的foreach迭代&lt;br/&gt;在上面两个示例中,我们都是以一个参数入参的,如果我们查询管理员并且是男性该怎么写那,这种多参数入参我们就可以使用Map入参的方式&lt;/p&gt;
&lt;p&gt;编写接口中的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserByConditionMap_foreach_map(Map&amp;lt;String,Object&amp;gt; conditionMap);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserByConditionMap_foreach_map&quot; resultMap=&quot;userMapByRole&quot;&amp;gt;
    SELECT * FROM USER WHERE gender=#{gender} AND userRole IN
    &amp;lt;foreach collection=&quot;roleIds&quot; item=&quot;roleMap&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&amp;gt;        
            #{roleMap}
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void testGetUserByRoleId_foreach_array(){
    SqlSession sqlSession = null;
    List&amp;lt;User&amp;gt; userList = new ArrayList&amp;lt;User&amp;gt;();
    Map&amp;lt;String, Object&amp;gt; param = new HashMap&amp;lt;String, Object&amp;gt;(); 
    List&amp;lt;Integer&amp;gt; roleList = new ArrayList&amp;lt;Integer&amp;gt;(); 
    roleList.add(1); 
    roleList.add(2); 
    param.put(&quot;gender&quot;,2); 
    param.put(&quot;roleIds&quot;,roleList); 
    try {
        sqlSession = MyBatisUtil.createSqlSession();
         userList = sqlSession.getMapper(UserMapper.class).getUserByConditionMap_foreach_map(param); 
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }   
    for (User user : userList) {
        System.out.println(user.getUserName() + &quot;\t&quot; + user.getAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;br/&gt;1.MyBatis接受的参数类型：基本类型、对象、List、数组、Map&lt;br/&gt;2.无论MyBatis的入参是哪种数据类型，MyBatis都会将参数放在一个Map中&lt;br/&gt;对于单参数入参的情况：&lt;br/&gt;若入参为基本类型：变量名作为key，变量值为value，此时生成的Map只有一个元素若入参为对象：对象的属性名做key，属性值为value&lt;br/&gt;若入参为List：默认“list”作为key，该List即为value&lt;br/&gt;若入参为数组：默认“array”作为key，该数组即为value&lt;br/&gt;若入参为Map：键值不变&lt;/p&gt;
&lt;h5 id=&quot;choosewhenotherwise&quot;&gt;choose（when,otherwise）&lt;/h5&gt;
&lt;p&gt;choose可以选择其中一种情况下的查询结果，流程和switch相同，通常都是搭配when,otherwise使用&lt;br/&gt;编写接口方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserList_choose(@Param(&quot;userName&quot;)String userName,@Param(&quot;userRole&quot;)Integer roleId,
                              @Param(&quot;userCode&quot;)String userCode,@Param(&quot;creationDate&quot;)Date creationDate);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserList_choose&quot; resultType=&quot;User&quot;&amp;gt;
    SELECT * from USER WHERE 1=1
    &amp;lt;choose&amp;gt;
        &amp;lt;when test=&quot;userName!=null and userName!=''&quot;&amp;gt;
            AND userName=#{userName}
        &amp;lt;/when&amp;gt;
        &amp;lt;when test=&quot;userCode!=null and userCode!=''&quot;&amp;gt;
            AND userCode LIKE concat('%',#{userCode},'%')
        &amp;lt;/when&amp;gt;
        &amp;lt;when test=&quot;userRole!=null and userRole!=''&quot;&amp;gt;
            AND userRole=#{userRole}
        &amp;lt;/when&amp;gt;
        &amp;lt;otherwise&amp;gt;
            AND YEAR(creationDate)=YEAR(#{creationDate}) 
        &amp;lt;/otherwise&amp;gt;
    &amp;lt;/choose&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个属性的意思:&lt;br/&gt;when元素:当其test属性中条件满足的时候,就会执行,一旦有一个条件满足,则跳出choose&lt;br/&gt;otherwise元素:当when中所有条件都不满足的时候,就会执行otherwise中的内容&lt;/p&gt;
&lt;p&gt;多敲几遍你就会明白其中的奥义,可能我写的文章还有许多地方不足,有什么问题大家可以留言讨论&lt;/p&gt;
&lt;p&gt;by安心&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>安心。</dc:creator>
<og:description>使用动态SQL完成多条件查询 动态SQl是MyBatis的一个强大的特性,在使用JDBC操作数据时,如果查询条件过多,将字符串联成SQL语句是比较麻烦的一件事,且容易出错,有了动态SQL我们就可以使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anxin0/p/9926500.html</dc:identifier>
</item>
<item>
<title>Java NIO：Buffer、Channel 和 Selector - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/9926490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/9926490.html</guid>
<description>&lt;h2 id=&quot;Buffer&quot;&gt;Buffer&lt;/h2&gt;
&lt;p&gt;一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。&lt;/p&gt;
&lt;p&gt;java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107221456546-861070919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实核心是最后的 ByteBuffer，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。&lt;/p&gt;
&lt;p&gt;我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。&lt;/p&gt;
&lt;p&gt;MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。&lt;/p&gt;
&lt;p&gt;我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。&lt;/p&gt;
&lt;h3 id=&quot;position%E3%80%81limit%E3%80%81capacity&quot;&gt;position、limit、capacity&lt;/h3&gt;
&lt;p&gt;就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107221701406-1091971180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。&lt;/p&gt;
&lt;p&gt;position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;position &lt;/strong&gt;的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。&lt;/p&gt;
&lt;p&gt;从写操作模式到读操作模式切换的时候（&lt;strong&gt;flip&lt;/strong&gt;），position 都会归零，这样就可以从头开始读写了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;limit&lt;/strong&gt;：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107222029411-1629396478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96%20Buffer&quot;&gt;初始化 Buffer&lt;/h3&gt;
&lt;p&gt;每个 Buffer 实现类都提供了一个静态方法 &lt;code&gt;allocate(int capacity)&lt;/code&gt; 帮助我们快速实例化一个 Buffer。如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ByteBuffer byteBuf = ByteBuffer.allocate(1024);
IntBuffer intBuf = IntBuffer.allocate(1024);
LongBuffer longBuf = LongBuffer.allocate(1024);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，我们经常使用 wrap 方法来初始化一个 Buffer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ByteBuffer wrap(byte[] array) {
    ...
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;%E5%A1%AB%E5%85%85%20Buffer&quot;&gt;填充 Buffer&lt;/h3&gt;
&lt;p&gt;各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 填充一个 byte 值
public abstract ByteBuffer put(byte b);
// 在指定位置填充一个 int 值
public abstract ByteBuffer put(int index, byte b);
// 将一个数组中的值填充进去
public final ByteBuffer put(byte[] src) {...}
public ByteBuffer put(byte[] src, int offset, int length) {...}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会java.nio.BufferOverflowException 异常。　　&lt;/p&gt;
&lt;p&gt;对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为读操作，因为数据是从外部（文件或网络等）读到内存中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int num = channel.read(buf);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述方法会返回从 Channel 中读入到 Buffer 的数据大小。&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC&quot;&gt;提取 Buffer 中的值&lt;/h3&gt;
&lt;p&gt;前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。&lt;/p&gt;
&lt;p&gt;如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。&lt;/p&gt;
&lt;p&gt;调用Buffer的flip()方法，可以从写模式切换到读模式，其实就是重新设置了一下position和limit的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer flip() {
    limit = position; // 将 limit 设置为实际写入的数据数量
    position = 0; // 重置 position 为 0
    mark = -1; // mark 之后再说
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应写操作的一系列put方法，读操作提供了一系列的get()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 根据 position 来获取数据
public abstract byte get();
// 获取指定位置的数据
public abstract byte get(int index);
// 将 Buffer 中的数据写入到数组中
public ByteBuffer get(byte[] dst)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;附一个经常使用的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
new String(buffer.array()).trim();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了将数据从Buffer读取出来使用，更常见的操作是将写入的数据输出到Channel中，如通过FileChannel将数据写入到文件中，通过SocketChannel将数据写入到网络发送到远程机器等。对应的，这种操作，我们称之为写操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int num = channel.write(buf);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC&quot;&gt;mark()、reset()&lt;/h3&gt;
&lt;p&gt;除了position、limit、capacity这三个基本属性外，还有一个常用的属性就是mark。&lt;/p&gt;
&lt;p&gt;mark用于临时保存position的值，每次调用mark()方法都会将mark设置为当前的position，便于后学需要的时候使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer mark() {
    mark = position;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer reset() {
    int m = mark;
    if (m &amp;lt; 0)
        throw new InvalidMarkException();
    position = m;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC&quot;&gt;rewind()、clear()、compact()&lt;/h3&gt;
&lt;p&gt;rewind()：会重置position为0，通常用于从头读写Buffer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　clear()：相当于重新实例化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常，我们会先填充Buffer，然后从Buffer读取数据，之后再重新往里填充新的数据，我们一般在填充之前先调用clear().&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer clear() {
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compact()：和clear()一样的是都是在准备往Buffer中填充新数据之前调用。&lt;/p&gt;
&lt;p&gt;clear()会重置几个属性，但是并不会将Buffer中的数据清空，只不过后面写的时候会覆盖之前的数据。&lt;/p&gt;
&lt;p&gt;而compact()方法调用之后，会先处理还没有读取的数据，也就是position到limit直接的数据，先将这些数据都移动到左边，然后在这个基础之上再开始写入。此时,limit还是等于capacity,position指向原来数据的右边。&lt;/p&gt;

&lt;h2&gt;Channel&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107224610788-1580870382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;FileChannel：文件通道，用于文件的读和写。&lt;/p&gt;
&lt;p&gt;DatagramChannel：用于UDP连接的接收和发送&lt;/p&gt;
&lt;p&gt;SocketChannel：TCP客户端&lt;/p&gt;
&lt;p&gt;ServerSocketChannel:TCP服务端，监听某个端口进来的请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107225318351-32434863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107225351491-527707889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;FileChannel&lt;/h3&gt;

&lt;p&gt;初始化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
FileInputStream inputStream = new FileInputStream(new File(&quot;/data.txt&quot;));
FileChannel fileChannel = inputStream.getChannel();　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，也可以从RandomAccessFile类中的getChannel来得到FileChannel。&lt;/p&gt;
&lt;p&gt;读取文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ByteBuffer buffer = ByteBuffer.allocate(1024);

int num = fileChannel.read(buffer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写入文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.put(&quot;随机写入一些内容到 Buffer 中&quot;.getBytes());
// Buffer 切换为读模式
buffer.flip();
while(buffer.hasRemaining()) {
    // 将 Buffer 中的内容写入文件
    fileChannel.write(buffer);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;SocketChannel&lt;/h3&gt;
&lt;p&gt;打开一个TCP链接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
SocketChannel socketChannel = SocketChannel&lt;br/&gt;　　.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 80));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然了，上面的这行代码等价于下面的两行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 打开一个通道
SocketChannel socketChannel = SocketChannel.open();
// 发起连接
socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 80));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 读取数据
socketChannel.read(buffer);

// 写入数据到网络连接中
while(buffer.hasRemaining()) {
    socketChannel.write(buffer);   
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ServerSocketChannel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 实例化
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
// 监听 8080 端口
serverSocketChannel.socket().bind(new InetSocketAddress(8080));

while (true) {
    // 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理
    SocketChannel socketChannel = serverSocketChannel.accept();
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们看到了SocketChannel的第二个实例化方式。&lt;/p&gt;
&lt;p&gt;到这里，我们应该能理解SocketChannel了，它不仅仅是TCP客户端，它代表的是一个网络通道，可读可写。&lt;/p&gt;
&lt;p&gt;ServerSocketChannel不和Buffer打交道了，因为它并不实际处理数据，一旦接到请求，就会实例化一个SocketChannel，之后再这个简介通道上传递的数据它就不管了，它会继续监听端口等待下一个连接。&lt;/p&gt;
&lt;h3&gt;DatagramChannel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监听端口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9090));

ByteBuffer buf = ByteBuffer.allocate(48);

channel.receive(buf);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;发送数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String newData = &quot;New String to write to file...&quot;
                    + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.put(newData.getBytes());
buf.flip();

int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Selector&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Selector建立在非阻塞的基础之上，大家经常听到的多路复用在java世界中指的就是它，用于实现一个线程管理多个Channel。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启Selector:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Selector selector = Selector.open();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，&lt;/span&gt;&lt;span&gt;FileChannel 不支持非阻塞&lt;/span&gt;&lt;span&gt;，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 将通道设置为非阻塞模式，因为默认都是阻塞模式的
channel.configureBlocking(false);
// 注册
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SelectionKey.OP_READ:对应 00000001，通道中有数据可以进行读取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SelectionKey.OP_WRITE:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;对应 00000100，可以往通道中写入数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SelectionKey.OP_CONNECT:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;对应 00001000，成功建立 TCP 连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SelectionKey.OP_ACCEPT:&lt;/span&gt;&lt;span&gt;对应 00010000，接受 TCP 连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 000&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 即十进制数值 17 即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注册方法返回值是 &lt;/span&gt;&lt;span&gt;SelectionKey&lt;/span&gt;&lt;span&gt; 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);

while(true) {
  // 判断是否有事件准备好
  int readyChannels = selector.select();
  if(readyChannels == 0) continue;

  // 遍历
  Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();
  Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = selectedKeys.iterator();
  while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于Selector，需要熟悉以下几个方法：&lt;/p&gt;
&lt;p&gt;select()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;调用此方法，会将&lt;/span&gt;&lt;span&gt;上次 select 之后的&lt;/span&gt;&lt;span&gt;准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;selectNow()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select(long timeout)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wakeup()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用 Buffer 的 &lt;/span&gt;&lt;span&gt;flip()&lt;/span&gt;&lt;span&gt; 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 15:16:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<og:description>Buffer 一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。 java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/9926490.html</dc:identifier>
</item>
<item>
<title>Flink 专题 -2 Checkpoint、Savepoint 机制 - 千狼</title>
<link>http://www.cnblogs.com/auguszero/p/9926394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/auguszero/p/9926394.html</guid>
<description>&lt;h2 id=&quot;checkpoint-保留策略&quot;&gt;1. checkpoint 保留策略&lt;/h2&gt;
&lt;p&gt;默认情况下，checkpoint 不会被保留，取消程序时即会删除他们，但是可以通过配置保留定期检查点，根据配置 当作业失败或者取消的时候 ，不会自动清除这些保留的检查点 。&lt;br/&gt;java :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CheckpointConfig config = env.getCheckpointConfig();
config.enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExternalizedCheckpointCleanup 可选项如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION：&lt;/strong&gt; 取消作业时保留检查点。请注意，在这种情况下，您必须在取消后手动清理检查点状态。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExternalizedCheckpointCleanup.DELETE_ON_CANCELLATION：&lt;/strong&gt; 取消作业时删除检查点。只有在作业失败时，检查点状态才可用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;checkpoint-配置&quot;&gt;2. Checkpoint 配置&lt;/h2&gt;
&lt;p&gt;与SavePoint 类似 ,checkpoint 保留的是元数据文件和一些数据文件&lt;br/&gt;默认情况下checkpoint 只保留 一份最新数据，如果需要进行checkpoint数据恢复 ，可以通过全局设置的方式设置该集群默认的checkpoint 保留数，以保证后期可以从checkpoint 点进行恢复 。 同时为了 及时保存checkpoint状态 还需要在服务级别设置 checkpoint 检查点的 备份速度 。&lt;br/&gt;全局配置:&lt;br/&gt;flink-conf.yaml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置 checkpoint全局设置保存点  
state.checkpoints.dir: hdfs:///checkpoints/
// 设置checkpoint 默认保留 数量  
state.checkpoints.num-retained: 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 如果将 checkpoint保存在hdfs 系统中 ， 需要设置 hdfs 元数据信息 : &lt;code&gt;fs.default-scheme:&lt;/code&gt;&lt;br/&gt;服务级别设置:&lt;br/&gt;java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置 checkpoint 保存目录  
env.setStateBackend(new RocksDBStateBackend(&quot;hdfs:///checkpoints-data/&quot;);
// 设置checkpoint 检查点间隔时间  
env.enableCheckpointing(5000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交任务之后 job 界面 和 hdfs 界面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过页面可以看出 checkpoint 备份方式是每5秒执行一次 ，保存当前所有task 状态元信息 和状态信息 。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;hdfs 信息 保存 jobId 为 0171897fa809692093b4a9b223cb35e4 最新的 20次 checkpoint 信息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483757/201811/1483757-20181107225544387-435829565.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483757/201811/1483757-20181107225551791-1484589207.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483757/201811/1483757-20181107225555071-1019883214.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;checkpoint-状态点恢复&quot;&gt;3. Checkpoint 状态点恢复&lt;/h2&gt;
&lt;p&gt;因为 flink checkpoint 目录 分别对应的是 jobId ， 每通过 flink run 方式 / 页面提交方式 都会重新生成 jobId ，那么如何通过checkpoint 恢复 失败任务或者重新执行保留时间点的 任务？&lt;/p&gt;
&lt;p&gt;flink 提供了 在启动 之时 通过设置 -s 参数指定checkpoint 目录 , 让新的jobId 读取该checkpoint 元文件信息和状态信息 ，从而达到指定时间节点启动 job 。启动方式如下 :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/flink -s /flink/checkpoints/0171897fa809692093b4a9b223cb35e4/chk-50/_metadata  -p  @Parallelism -c @Mainclass @jar  &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;savepoint-介绍&quot;&gt;Savepoint 介绍&lt;/h2&gt;
&lt;p&gt;Savepoint是通过Flink的检查点机制创建的流作业执行状态的一致图像。您可以使用Savepoints来停止和恢复，分叉或更新Flink作业。保存点由两部分组成：稳定存储（例如HDFS，S3，...）上的（通常是大的）二进制文件和（相对较小的）元数据文件的目录。稳定存储上的文件表示作业执行状态图像的净数据。Savepoint的元数据文件以（绝对路径）的形式包含（主要）指向作为Savepoint一部分的稳定存储上的所有文件的指针。&lt;/p&gt;
&lt;h2 id=&quot;savepoint-和-checkpoint-区别&quot;&gt;savepoint 和 checkpoint 区别&lt;/h2&gt;
&lt;p&gt;从概念上讲，Flink的Savepoints与Checkpoints的不同之处在于备份与传统数据库系统中的恢复日志不同。检查点的主要目的是在意外的作业失败时提供恢复机制。Checkpoint的生命周期由Flink管理，即Flink创建，拥有和发布Checkpoint - 无需用户交互。作为一种恢复和定期触发的方法，Checkpoint实现的两个主要设计目标是：i）being as lightweight to create （轻量级），ii）fast restore （快速恢复） 。针对这些目标的优化可以利用某些属性，例如，JobCode在执行尝试之间不会改变。&lt;/p&gt;
&lt;p&gt;与此相反，Savepoints由用户创建，拥有和删除。他们的用例是planned (计划) 的，manual backup( 手动备份 ) 和 resume（恢复） 。例如，这可能是您的Flink版本的更新，更改您的Job graph ，更改 parallelism ，分配第二个作业，如红色/蓝色部署，等等。当然，Savepoints必须在终止工作后继续存在。从概念上讲，保存点的生成和恢复成本可能更高，并且更多地关注可移植性和对前面提到的作业更改的支持。&lt;/p&gt;
&lt;h2 id=&quot;assigning-operator-ids-分配-operator-ids&quot;&gt;Assigning Operator IDs ( 分配 operator ids)&lt;/h2&gt;
&lt;p&gt;为了能够在将来升级你的程序在本节中描述。主要的必要更改是通过该uid(String)方法手动指定操作员ID 。这些ID用于确定每个运算符的状态。&lt;br/&gt;java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DataStream&amp;lt;String&amp;gt; stream = env.
  // Stateful source (e.g. Kafka) with ID
  .addSource(new StatefulSource())
  .uid(&quot;source-id&quot;) // ID for the source operator
  .shuffle()
  // Stateful mapper with ID
  .map(new StatefulMapper())
  .uid(&quot;mapper-id&quot;) // ID for the mapper
  // Stateless printing sink
  .print(); // Auto-generated ID&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果您未手动指定ID，则会自动生成这些ID。只要这些ID不变，您就可以从保存点自动恢复。生成的ID取决于程序的结构，并且对程序更改很敏感。因此，强烈建议手动分配这些ID。&lt;/p&gt;
&lt;h2 id=&quot;savepoint-state&quot;&gt;Savepoint State&lt;/h2&gt;
&lt;p&gt;触发保存点时，会创建一个新的保存点目录，其中将存储数据和元数据。可以通过配置默认目标目录或使用触发器命令指定自定义目标目录来控制此目录的位置&lt;/p&gt;
&lt;h3 id=&quot;保存savepoint&quot;&gt;保存Savepoint&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink savepoint :jobId [:targetDirectory]&lt;/code&gt;&lt;br/&gt;这将触发具有ID的作业的保存点:jobId，并返回创建的保存点的路径。您需要此路径来还原和部署保存点。&lt;/p&gt;
&lt;h3 id=&quot;在yarn-集群中保存savepoint&quot;&gt;在yarn 集群中保存Savepoint&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink savepoint :jobId [:targetDirectory] -yid :yarnAppId&lt;/code&gt;&lt;br/&gt;这将触发具有ID :jobId和YARN应用程序ID 的作业的保存点:yarnAppId，并返回创建的保存点的路径。&lt;/p&gt;
&lt;h3 id=&quot;使用-savepoint-取消job&quot;&gt;使用 Savepoint 取消job&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink cancel -s [:targetDirectory] :jobId&lt;/code&gt;&lt;br/&gt;这将以原子方式触发具有ID的作业的保存点:jobid并取消作业。此外，您可以指定目标文件系统目录以存储保存点。该目录需要可由JobManager和TaskManager访问。&lt;/p&gt;
&lt;h3 id=&quot;resuming-savepoint&quot;&gt;Resuming Savepoint&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink run -s :savepointPath [:runArgs]&lt;/code&gt;&lt;br/&gt;这将提交作业并指定要从中恢复的保存点。您可以指定保存点目录或_metadata文件的路径。&lt;/p&gt;
&lt;h3 id=&quot;允许未恢复状态启动&quot;&gt;允许未恢复状态启动&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink run -s :savepointPath -n [:runArgs]&lt;/code&gt;&lt;br/&gt;默认情况下，resume操作将尝试将保存点的所有状态映射回要恢复的程序。如果删除了运算符，则可以通过--allowNonRestoredState（short -n:)选项跳过无法映射到新程序的状态：&lt;/p&gt;
&lt;h3 id=&quot;全局配置&quot;&gt;全局配置&lt;/h3&gt;
&lt;p&gt;您可以通过state.savepoints.dir 配置文件设置默认savepoint 位置 。触发保存点时，此目录将用于存储保存点。您可以通过使用触发器命令指定自定义目标目录来覆盖默认值（请参阅:targetDirectory参数）。&lt;br/&gt;flink-conf.yaml&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# Default savepoint target directory
state.savepoints.dir: hdfs:///flink/savepoints&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考地址:&lt;/p&gt;
&lt;p&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.6/ops/state/state_backends.html&lt;br/&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.6/ops/state/checkpoints.html&lt;br/&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.6/ops/state/savepoints.html&lt;br/&gt;http://ju.outofmemory.cn/entry/370841&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 14:57:00 +0000</pubDate>
<dc:creator>千狼</dc:creator>
<og:description>CheckPoint 1. checkpoint 保留策略 默认情况下，checkpoint 不会被保留，取消程序时即会删除他们，但是可以通过配置保留定期检查点，根据配置 当作业失败或者取消的时候 ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/auguszero/p/9926394.html</dc:identifier>
</item>
<item>
<title>python基础学习（十二）变量进阶 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-variable-adv.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-variable-adv.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;变量的引用&quot;&gt;1. 变量的引用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;变量 和 数据 都是保存在 &lt;strong&gt;内存&lt;/strong&gt; 中的&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中 &lt;strong&gt;函数 的 参数传递&lt;/strong&gt; 以及 &lt;strong&gt;返回值&lt;/strong&gt; 都是靠 &lt;strong&gt;引用&lt;/strong&gt; 传递的&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;引用的概念&quot;&gt;1.1 引用的概念&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt; 和 &lt;strong&gt;数据&lt;/strong&gt; 是分开存储的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt; 保存在内存中的一个位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt; 中保存着&lt;strong&gt;数据&lt;/strong&gt;在内存中的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt; 中 &lt;strong&gt;记录数据的地址&lt;/strong&gt;，就叫做 &lt;strong&gt;引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;id()&lt;/code&gt; 函数可以查看变量中保存数据所在的 &lt;strong&gt;内存地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 &lt;strong&gt;修改了数据的引用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量 &lt;strong&gt;不再&lt;/strong&gt; 对之前的数据引用&lt;/li&gt;
&lt;li&gt;变量 &lt;strong&gt;改为&lt;/strong&gt; 对新赋值的数据引用&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;变量引用-的实例&quot;&gt;1.2 变量引用 的实例&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
a = 1

print(&quot;a的内存地址是：%d&quot; % id(a))

b = 2

print(&quot;b的内存地址是：%d&quot; % id(b))

c = 2
print(&quot;c的内存地址是：%d&quot; % id(c))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数的参数和返回值的传递&quot;&gt;1.3 函数的参数和返回值的传递&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，函数的 &lt;strong&gt;实参&lt;/strong&gt;/&lt;strong&gt;返回值&lt;/strong&gt; 都是是靠 &lt;strong&gt;引用&lt;/strong&gt; 来传递来的，写了小的例子尝试下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def test(num):

    print(&quot;-&quot; * 50)
    print(&quot;%d 在函数中的内存地址是 %d&quot; % (num, id(num)))
    
    result = 12
    
    print(&quot;返回值 %d 在内存中的地址是 %d&quot; % (result, id(result)))
    print(&quot;-&quot; * 50)
    
    return result

n = 100

print(&quot;%d在调用之前的内存地址是%d&quot; % (n, id(n)))

r = test(n)

print(&quot;调用函数后，实参 %d 的内存地址是 %d&quot; % (n, id(n)))
print(&quot;调用函数后，返回值 %d 的内存地址是 %d&quot; % (r, id(r)))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可变和不可变类型&quot;&gt;2. 可变和不可变类型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不可变类型&lt;/strong&gt;，内存中的数据不允许被修改：
&lt;ul&gt;&lt;li&gt;数字类型 &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;, &lt;code&gt;long(2.x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串 &lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;元组 &lt;code&gt;tuple&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可变类型&lt;/strong&gt;，内存中的数据可以被修改：
&lt;ul&gt;&lt;li&gt;列表 &lt;code&gt;list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字典 &lt;code&gt;dict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可变类型&lt;/strong&gt;的数据变化，是通过 &lt;strong&gt;方法&lt;/strong&gt; 来实现的&lt;/li&gt;
&lt;li&gt;如果给一个可变类型的变量，赋值了一个新的数据，&lt;strong&gt;引用会修改&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;变量 &lt;strong&gt;不再&lt;/strong&gt; 对之前的数据引用&lt;/li&gt;
&lt;li&gt;变量 &lt;strong&gt;改为&lt;/strong&gt; 对新赋值的数据引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;哈希-hash&quot;&gt;哈希 &lt;code&gt;(hash)&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Python&lt;/code&gt; 中内置有一个名字叫做 &lt;code&gt;hash(o)&lt;/code&gt; 的函数
&lt;ul&gt;&lt;li&gt;接收一个 &lt;strong&gt;不可变类型&lt;/strong&gt; 的数据作为 &lt;strong&gt;参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回&lt;/strong&gt; 结果是一个 &lt;strong&gt;整数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;哈希&lt;/code&gt; 是一种 &lt;strong&gt;算法&lt;/strong&gt;，其作用就是提取数据的 &lt;strong&gt;特征码（指纹）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相同的内容&lt;/strong&gt; 得到 &lt;strong&gt;相同的结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同的内容&lt;/strong&gt; 得到 &lt;strong&gt;不同的结果&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，设置字典的 &lt;strong&gt;键值对&lt;/strong&gt; 时，会首先对 &lt;code&gt;key&lt;/code&gt; 进行 &lt;code&gt;hash&lt;/code&gt; 已决定如何在内存中保存字典的数据，以方便 &lt;strong&gt;后续&lt;/strong&gt; 对字典的操作：&lt;strong&gt;增、删、改、查&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;键值对的 &lt;code&gt;key&lt;/code&gt; 必须是不可变类型数据&lt;/li&gt;
&lt;li&gt;键值对的 &lt;code&gt;value&lt;/code&gt; 可以是任意类型的数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201811/1156642-20181107220800640-471985362.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;局部变量和全局变量&quot;&gt;3. 局部变量和全局变量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt; 是在 &lt;strong&gt;函数内部&lt;/strong&gt; 定义的变量，&lt;strong&gt;只能在函数内部使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; 是在 &lt;strong&gt;函数外部定义&lt;/strong&gt; 的变量（没有定义在某一个函数内），&lt;strong&gt;所有函数&lt;/strong&gt; 内部 &lt;strong&gt;都可以使用这个变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示：在其他的开发语言中，大多 &lt;strong&gt;不推荐使用全局变量&lt;/strong&gt; —— 可变范围太大，导致程序不好维护！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;局部变量&quot;&gt;3.1 局部变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt; 是在 &lt;strong&gt;函数内部&lt;/strong&gt; 定义的变量，&lt;strong&gt;只能在函数内部使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;函数执行结束后，&lt;strong&gt;函数内部的局部变量，会被系统回收&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不同的函数，可以定义相同的名字的局部变量，但是 &lt;strong&gt;彼此之间&lt;/strong&gt; 不会产生影响&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;局部变量的作用&quot;&gt;局部变量的作用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在函数内部使用，&lt;strong&gt;临时&lt;/strong&gt; 保存 &lt;strong&gt;函数内部需要使用的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def test1():

    num = 1

    print(num)

    num = 22

    print(&quot;修改过后 %d&quot; % num)


def test2():

    num = 30

    print(num)


test1()
test2()

print(&quot;结束&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;局部变量的生命周期&quot;&gt;局部变量的生命周期&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;所谓 &lt;strong&gt;生命周期&lt;/strong&gt; 就是变量从 &lt;strong&gt;被创建&lt;/strong&gt; 到 &lt;strong&gt;被系统回收&lt;/strong&gt; 的过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt; 在 &lt;strong&gt;函数执行时&lt;/strong&gt; 才会被创建&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数执行结束后&lt;/strong&gt; 局部变量 &lt;strong&gt;被系统回收&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局部变量在生命周期&lt;/strong&gt; 内，可以用来存储 &lt;strong&gt;函数内部临时使用到的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;全局变量&quot;&gt;3.2 全局变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; 是在 &lt;strong&gt;函数外部定义&lt;/strong&gt; 的变量，所有函数内部都可以使用这个变量&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = 10


def test1():

    print(num)


def test2():

    num = 22

    print(num)


test1()
test2()

print(num)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：函数执行时，&lt;strong&gt;需要处理变量时&lt;/strong&gt; 会：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;首先&lt;/strong&gt; 查找 &lt;strong&gt;函数内部&lt;/strong&gt; 是否存在 &lt;strong&gt;指定名称 的局部变量&lt;/strong&gt;，&lt;strong&gt;如果有，直接使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果没有，查找 &lt;strong&gt;函数外部&lt;/strong&gt; 是否存在 &lt;strong&gt;指定名称 的全局变量&lt;/strong&gt;，&lt;strong&gt;如果有，直接使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果还没有，程序报错！&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;在函数中不能直接修改-全局变量的引用&quot;&gt;1) 在函数中不能直接修改 &lt;code&gt;全局变量的引用&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; 是在 &lt;strong&gt;函数外部定义&lt;/strong&gt; 的变量（没有定义在某一个函数内），&lt;strong&gt;所有函数&lt;/strong&gt; 内部 &lt;strong&gt;都可以使用这个变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示：在其他的开发语言中，大多 &lt;strong&gt;不推荐使用全局变量&lt;/strong&gt; —— 可变范围太大，导致程序不好维护！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在函数内部，可以 &lt;strong&gt;通过全局变量的引用获取对应的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;但是，&lt;strong&gt;不允许直接修改全局变量的引用&lt;/strong&gt; —— 使用赋值语句修改全局变量的值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = 10


def test1():

    print(&quot;test1&quot; + &quot;*&quot; * 50)

    num = 100

    print(num)


def test2():

    print(&quot;test2&quot; + &quot;*&quot; * 50)

    print(num)


test1()
test2()

print(&quot;over&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在函数内部修改全局变量的值&quot;&gt;2) 在函数内部修改全局变量的值&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果在函数中需要修改全局变量，需要使用 &lt;code&gt;global&lt;/code&gt; 进行声明&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = 10


def test1():

    print(&quot;test1&quot; + &quot;*&quot; * 50)

    global num
    num = 100

    print(num)


def test2():

    print(&quot;test2&quot; + &quot;*&quot; * 50)

    print(num)


test1()
test2()

print(&quot;over&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;全局变量定义的位置&quot;&gt;3) 全局变量定义的位置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为了保证所有的函数都能够正确使用到全局变量，应该 &lt;strong&gt;将全局变量定义在其他函数的上方&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a = 1


def test():

    print(a)
    print(b)
    print(c)


b = 2
test()
c = 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;全局变量命名的建议&quot;&gt;4) 全局变量命名的建议&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：&lt;/li&gt;
&lt;li&gt;全局变量名前应该增加 &lt;code&gt;g_&lt;/code&gt; 或者 &lt;code&gt;gl_&lt;/code&gt; 的前缀&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;提示：具体的要求格式，各公司要求可能会有些差异&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;gl_num = 33
gl_name = &quot;zfx&quot;


def test():

    num = 10

    print(num)
    print(gl_name)


test()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 07 Nov 2018 14:40:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念 在 中 变量 和 数据 是分开存储的 数据 保</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-variable-adv.html</dc:identifier>
</item>
<item>
<title>Spring知识点总结(三)之注解方式实现IOC和DI - 南岭寒</title>
<link>http://www.cnblogs.com/nanlinghan/p/9926154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanlinghan/p/9926154.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;    1. 注解概念&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        所谓注解就是给程序看的提示信息，很多时候都用来作为轻量级配置的方式。&lt;br/&gt;        关于注解的知识点，参看java基础课程中java基础加强部分的内容。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    2. Spring中的注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        Spring除了默认的使用xml配置文件的方式实现配置之外，也支持使用注解方式实现配置，这种方式效率更高，配置信息清晰，修改更方便，推荐使用。&lt;br/&gt;        &lt;br/&gt;        引入context名称空间：&lt;br/&gt;            在MyEclipse中导入spring-context-3.2.xsd约束文件，要求Spring来管理。&lt;br/&gt;            在applicationContext.xml文件中，引入该schema文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
                2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                3         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
                4         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                5         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                6         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
                7         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
                8         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
                9         &quot;&amp;gt;
               10     &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            **可以将以上头信息加入MyEclipse模版，方便后续自动生成。&lt;br/&gt;    &lt;br/&gt;   &lt;strong&gt;&lt;span&gt; 3. 使用类注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        使用Spring的类注解可以通过注解注册类为bean，省去了配置文件中的&amp;lt;bean&amp;gt;配置。&lt;br/&gt;        &lt;br/&gt;        a. 开启包扫描&lt;br/&gt;        在spring的配置文件中，开启包扫描，指定spring自动扫描哪些个包下的类。&lt;br/&gt;            &amp;lt;context:component-scan base-package=&quot;cn.tedu.beans&quot;/&amp;gt;&lt;br/&gt;        案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
                xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
                xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
                xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
                &quot;&amp;gt;
                &amp;lt;!-- 开启包扫描 --&amp;gt;
                &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;cn.tedu.beans&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
                &amp;lt;!--
                    &amp;lt;bean id=&quot;person&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;       
                    &amp;lt;bean id=&quot;cat&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Cat&quot;&amp;gt;&amp;lt;/bean&amp;gt;       
                    &amp;lt;bean id=&quot;dog&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Dog&quot;&amp;gt;&amp;lt;/bean&amp;gt;       
                     --&amp;gt;
            &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            &lt;br/&gt;        b. 使用注解注册bean&lt;br/&gt;            这个包中的类会在spring容器启动时自动被扫描，检测是否需要自动配置为bean.&lt;br/&gt;            在配置的包中的类上使用@Component注解，则这个类会自动被注册为bean，使用当前类的class为&amp;lt;bean&amp;gt;的class，通常情况下使用类名首字母小写为&amp;lt;bean&amp;gt;id。&lt;br/&gt;            案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
                
                @Component
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            &lt;br/&gt;        c. bean的id&lt;br/&gt;            可以使bean类实现BeanNameAware接口，并实现其中的setBeanName方法，spring容器会在初始化bean时，调用此方法告知当前bean的id。通过这个方式可以获取bean的id信息。&lt;br/&gt;            &lt;br/&gt;            通常情况下注解注册bean使用类名首字母小写为bean的id，但是如果类名的第二个字母为大写则首字母保留原样.&lt;br/&gt;                cn.tedu.beans.Person --&amp;gt; &amp;lt;bean id=&quot;person&quot; class=&quot;cn.tedu.beans.Person&quot;/&amp;gt;&lt;br/&gt;                cn.tedu.beans.NBA --&amp;gt; &amp;lt;bean id=&quot;NBA&quot; class=&quot;cn.tedu.beans.NBA&quot;/&amp;gt;&lt;br/&gt;            也可以通过在@Component中配置value属性，明确的指定当前类在注册到spring时bean的id&lt;br/&gt;            案例：&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 
&lt;span&gt; 8&lt;/span&gt;                 @Component(&quot;per&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         System.out.println(&quot;===&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;===&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            &lt;br/&gt;&lt;strong&gt;&lt;span&gt;    4. 使用属性注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        使用属性注解，可以为bean配置属性的注入过程，省去了在配置文件中进行注入配置的过程，更加便捷。&lt;br/&gt;        &lt;br/&gt;        a. 在配置文件中开启属性注解功能&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
                xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
                xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
                xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
                &quot;&amp;gt;
                &amp;lt;!-- 开启属性注解 --&amp;gt;
                &amp;lt;context:annotation-config&amp;gt;&amp;lt;/context:annotation-config&amp;gt;
            &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        b. 使用属性注解注入bean类型数据：&lt;br/&gt;            在bean中的属性上通过如下注解声明属性注入&lt;br/&gt;                @Autowired&lt;br/&gt;            也可以使用@Qualifier(value=&quot;dog1&quot;)注解,明确的指定,要注入哪个id的bean&lt;br/&gt;            &lt;br/&gt;            代码：&lt;br/&gt;           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
                
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
                
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
                    @Autowired
                    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
                    @Autowired
                    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cat cat;
                    
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog getDog() {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dog;
                    }
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDogx(Dog dog) {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
                    }
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat getCat() {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
                    }
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCat(Cat cat) {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cat =&lt;span&gt; cat;
                    }
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person [dog=&quot; + dog + &quot;, cat=&quot; + cat + &quot;]&quot;&lt;span&gt;;
                    }
                    
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
                        System.out.println(&lt;/span&gt;&quot;==============&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;====&quot;+&lt;span&gt;name);
                    }
                    
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;                &lt;br/&gt;        c. 属性注入bean类型数据的原理:&lt;br/&gt;            当spring容器解析xml时,发现开启了属性注解,则会在创建bean时,检测属性上是否存在@Autowired注解,如果发现该注解,则会通过当前属性的名称寻找是否存在该id的bean,如果存在则注入进来,如果不存在,再检查是否存在和当前属性类型相同的bean,如果由则注入进来,如果都没有则抛出异常.&lt;br/&gt;            &lt;br/&gt;            **也可以使用@Resource(name=&quot;id&quot;)指定注入给定id的bean，但是这种方式不建议大家使用。&lt;br/&gt;            &lt;br/&gt;        d. spring内置支持注入类型的注解方式的注入 - 非集合类型&lt;br/&gt;            spring中可以通过注解方式 注册bean，并可以通过@Autowired实现属性的自动注入，但注入的都是自定义的bean类型，如果类中包含例如 int long String等spring内置可注入的类型时，又该如何注入呢？ 可以使用@Value注解来实现注入。&lt;br/&gt;               &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 
&lt;span&gt; 8&lt;/span&gt;                 @Component(&quot;per&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     @Value(&quot;999&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     
&lt;span&gt;13&lt;/span&gt;                     @Value(&quot;zs&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cat cat;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     
&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog getDog() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDogx(Dog dog) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat getCat() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCat(Cat cat) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.cat =&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;, dog=&quot; +&lt;span&gt; dog
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                 + &quot;, cat=&quot; + cat + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         System.out.println(&quot;===&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;===&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     
&lt;span&gt;45&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            这种方式可以实现spring内置类型的注入，但是这种方式将注入的值写死在了代码中，后续如果希望改变注入的初始值，必须来修改源代码，此时可以将这些值配置到一个properties配置文件中，再在spring中进行引入。&lt;br/&gt;                &lt;br/&gt;            &lt;br/&gt;                &lt;br/&gt;                &lt;br/&gt;                &lt;br/&gt;            &lt;br/&gt;        e. spring内置支持注入类型的注解方式的注入 - 集合类型&lt;br/&gt;            需要将集合类型的数据配置到spring配置文件中，再通过@Value引入&lt;br/&gt;            配置过程：&lt;br/&gt;                将spring-util-3.2.xsd交给MyEclipse管理&lt;br/&gt;                在当前spring容器的配置文件中导入util名称空间&lt;br/&gt;                再通过适当的util标签注册数据&lt;br/&gt;            案例：&lt;br/&gt;           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt;  2&lt;/span&gt;                 &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt;  3&lt;/span&gt;                     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
&lt;span&gt;  4&lt;/span&gt;                     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
&lt;span&gt;  5&lt;/span&gt;                     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt;  6&lt;/span&gt;                     xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util/spring-util-3.2.xsd&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;                     &quot;&amp;gt;
&lt;span&gt; 14&lt;/span&gt;                     &amp;lt;!-- 开启属性注解 --&amp;gt;
&lt;span&gt; 15&lt;/span&gt;                     &amp;lt;context:annotation-config&amp;gt;&amp;lt;/context:annotation-config&amp;gt;
&lt;span&gt; 16&lt;/span&gt;                     &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;cn.tedu.beans&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;span&gt; 17&lt;/span&gt;                     &amp;lt;context:property-placeholder location=&quot;classpath:/person-data.properties&quot;/&amp;gt;
&lt;span&gt; 18&lt;/span&gt;                     
&lt;span&gt; 19&lt;/span&gt;                     &amp;lt;util:list id=&quot;l1&quot;&amp;gt;
&lt;span&gt; 20&lt;/span&gt;                         &amp;lt;value&amp;gt;北京&amp;lt;/value&amp;gt;
&lt;span&gt; 21&lt;/span&gt;                         &amp;lt;value&amp;gt;上海&amp;lt;/value&amp;gt;
&lt;span&gt; 22&lt;/span&gt;                         &amp;lt;value&amp;gt;广州&amp;lt;/value&amp;gt;
&lt;span&gt; 23&lt;/span&gt;                         &amp;lt;value&amp;gt;深证&amp;lt;/value&amp;gt;
&lt;span&gt; 24&lt;/span&gt;                     &amp;lt;/util:list&amp;gt;
&lt;span&gt; 25&lt;/span&gt;                     
&lt;span&gt; 26&lt;/span&gt;                     &amp;lt;util:set id=&quot;s1&quot;&amp;gt;
&lt;span&gt; 27&lt;/span&gt;                         &amp;lt;value&amp;gt;法师&amp;lt;/value&amp;gt;
&lt;span&gt; 28&lt;/span&gt;                         &amp;lt;value&amp;gt;射手&amp;lt;/value&amp;gt;
&lt;span&gt; 29&lt;/span&gt;                         &amp;lt;value&amp;gt;打野&amp;lt;/value&amp;gt;
&lt;span&gt; 30&lt;/span&gt;                         &amp;lt;value&amp;gt;战士&amp;lt;/value&amp;gt;
&lt;span&gt; 31&lt;/span&gt;                         &amp;lt;value&amp;gt;打野&amp;lt;/value&amp;gt;
&lt;span&gt; 32&lt;/span&gt;                         &amp;lt;value&amp;gt;坦克&amp;lt;/value&amp;gt;
&lt;span&gt; 33&lt;/span&gt;                         &amp;lt;value&amp;gt;打野&amp;lt;/value&amp;gt;
&lt;span&gt; 34&lt;/span&gt;                     &amp;lt;/util:set&amp;gt;
&lt;span&gt; 35&lt;/span&gt;                         
&lt;span&gt; 36&lt;/span&gt;                     &amp;lt;util:map id=&quot;m1&quot;&amp;gt;
&lt;span&gt; 37&lt;/span&gt;                         &amp;lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 38&lt;/span&gt;                         &amp;lt;entry key=&quot;k2&quot; value=&quot;v2&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 39&lt;/span&gt;                         &amp;lt;entry key=&quot;k3&quot; value=&quot;v3&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 40&lt;/span&gt;                         &amp;lt;entry key=&quot;k1&quot; value=&quot;v4&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 41&lt;/span&gt;                     &amp;lt;/util:map&amp;gt;       
&lt;span&gt; 42&lt;/span&gt;                 &amp;lt;/beans&amp;gt;
&lt;span&gt; 43&lt;/span&gt;             
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            再在类的属性中通过@Value注入赋值
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 
&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 
&lt;span&gt; 51&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 
&lt;span&gt; 56&lt;/span&gt;                 @Component(&quot;per&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     @Value(&quot;${id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     
&lt;span&gt; 61&lt;/span&gt;                     @Value(&quot;${name}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                     
&lt;span&gt; 64&lt;/span&gt;                     @Value(&quot;#{@l1}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; addr;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     
&lt;span&gt; 67&lt;/span&gt;                     @Value(&quot;#{@s1}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; jobs;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                     
&lt;span&gt; 70&lt;/span&gt;                     @Value(&quot;#{@m1}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt; map;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                     
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cat cat;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     
&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog getDog() {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDogx(Dog dog) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat getCat() {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCat(Cat cat) {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.cat =&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 
&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         System.out.println(&quot;==============&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;====&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;, addr=&quot; +&lt;span&gt; addr
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                                 + &quot;, jobs=&quot; + jobs + &quot;, map=&quot; + map + &quot;, dog=&quot; + dog + &quot;, cat=&quot;
&lt;span&gt; 99&lt;/span&gt;                                 + cat + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    5. 其他注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        a. @Scope(value=&quot;prototype&quot;)&lt;br/&gt;            配置修饰的类的bean是单例还是多例，如果不配置默认为单例&lt;br/&gt;            案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                 &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Scope;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                @Component
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 @Scope(&quot;prototype&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 
&lt;span&gt;10&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        b. @Lazy&lt;br/&gt;            配置修饰的类的bean采用懒加载机制&lt;br/&gt;            案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                 &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Lazy;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Scope;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                @Component
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Lazy
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         System.out.println(&quot;Dog...被创建出来了...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        c. @PostConstruct&lt;br/&gt;            在bean对应的类中 修饰某个方法 将该方法声明为初始化方法，对象创建之后立即执行。&lt;br/&gt;        d. @PreDestroy&lt;br/&gt;            在bean对应的类中 修饰某个方法 将该方法声明为销毁的方法，对象销毁之前调用的方法。&lt;br/&gt;            案例：&lt;br/&gt;             &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PostConstruct;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PreDestroy;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Component
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         System.out.println(&quot;Dog...被创建出来了...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    @PostConstruct
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         System.out.println(&quot;Dog的初始化方法。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    @PreDestroy
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destory(){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         System.out.println(&quot;Dog的销毁方法。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        e. @Controller @Service @Repository @Component&lt;br/&gt;            这四个注解的功能是完全相同的，都是用来修饰类，将类声明为Spring管理的bean的。&lt;br/&gt;            其中@Component一般认为是通用的注解&lt;br/&gt;            而@Controller用在软件分层中的控制层，一般用在web层&lt;br/&gt;            而@Service用在软件分层中的业务访问层，一般用在service层&lt;br/&gt;            而@Repository用在软件分层中的数据访问层，一般用在dao层&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 14:17:00 +0000</pubDate>
<dc:creator>南岭寒</dc:creator>
<og:description>1. 注解概念 所谓注解就是给程序看的提示信息，很多时候都用来作为轻量级配置的方式。 关于注解的知识点，参看java基础课程中java基础加强部分的内容。 2. Spring中的注解 Spring除了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanlinghan/p/9926154.html</dc:identifier>
</item>
</channel>
</rss>