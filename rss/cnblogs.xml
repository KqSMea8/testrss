<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【LeetCode题解】25_k个一组翻转链表（Reverse-Nodes-in-k-Group） - StrongXGP</title>
<link>http://www.cnblogs.com/xugenpeng/p/10023876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xugenpeng/p/10023876.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;4.4642857142857&quot;&gt;
&lt;p&gt;更多 LeetCode 题解笔记可以访问我的 &lt;a href=&quot;https://github.com/Genpeng/play-with-leetcode&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给出一个链表，每 &lt;em&gt;k&lt;/em&gt; 个节点一组进行翻转，并返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;k&lt;/em&gt; 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 &lt;em&gt;k&lt;/em&gt; 的整数倍，那么将最后剩余节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定这个链表：&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;em&gt;k&lt;/em&gt; = 2 时，应当返回: &lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;em&gt;k&lt;/em&gt; = 3 时，应当返回: &lt;code&gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明 :&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你的算法只能使用常数的额外空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你不能只是单纯的改变节点内部的值&lt;/strong&gt;，而是需要实际的进行节点交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;要求解这道题，先要构造一个辅助函数，这个函数的作用就是翻转链表（不包括首尾节点）。假设输入链表如下图所示，其中链表表头为 &lt;code&gt;begin&lt;/code&gt;，链表尾部为 &lt;code&gt;end&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181126233519719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过函数之后，链表的连接变为如下的形式，且将 &lt;code&gt;begin&lt;/code&gt; 作为函数的输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181126233537208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体的实现思路和 &lt;a href=&quot;https://blog.csdn.net/x273591655/article/details/83306135&quot;&gt;LeetCode 第206题&lt;strong&gt;翻转链表&lt;/strong&gt;&lt;/a&gt;是一致的，只是函数的输入和输出有些不同，这里不在赘言，直接给出函数的实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Java 版本
private ListNode reverse(ListNode begin, ListNode end) {
    ListNode prev = begin, curr = begin.next;
    ListNode first = curr;
    while (curr != end) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    begin.next = prev;
    first.next = curr;
    return first;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Python 版本
def reverse(begin, end):
    prev, curr, first = begin, begin.next, begin.next
    while curr != end:
        curr.next, prev, curr = prev, curr, curr.next
        begin.next, first.next = prev, curr
        return first&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有个上面的辅助函数之后，我们就可以利用它求解这道题。假设输入链表为 &lt;code&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5&lt;/code&gt; 且 &lt;code&gt;k=3&lt;/code&gt;，首先构造一个虚拟头节点 &lt;code&gt;dummy&lt;/code&gt;，用于统一后面的一系列操作。初始时，设变量 &lt;code&gt;i=0&lt;/code&gt;，当 &lt;code&gt;i+1&lt;/code&gt; 不能被3整除时，将 &lt;code&gt;head&lt;/code&gt; 指针向链表的下一个节点移动；当 &lt;code&gt;i+1&lt;/code&gt; 能被3整除时，调用上面的辅助函数，将 &lt;code&gt;begin&lt;/code&gt; 节点和 &lt;code&gt;head.next&lt;/code&gt; 节点之间的节点进行翻转。具体的操作可以看下面的图片演示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181126233554797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181126233614201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181126233627545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181126233650886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3gyNzM1OTE2NTU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后，将 &lt;code&gt;head&lt;/code&gt; 指针指向 &lt;code&gt;begin&lt;/code&gt; 指针的下一个节点（这里为 &lt;code&gt;4&lt;/code&gt;），即 &lt;code&gt;head = begin.next&lt;/code&gt;。如此循环往复，直到 &lt;code&gt;head&lt;/code&gt; 节点为 &lt;code&gt;null&lt;/code&gt;，则结束所有操作。&lt;/p&gt;
&lt;h2 id=&quot;java-实现&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // boundary judgement
        boolean hasNoOrOneNode = (head == null || head.next == null);
        if (hasNoOrOneNode || k == 1) {
            return head;
        }

        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode begin = dummy;
        int i = 0;
        while (head != null) {
            ++i;
            if (i % k == 0) {
                begin = reverse(begin, head.next);
                head = begin.next;
            } else {
                head = head.next;
            }
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode begin, ListNode end) {
        ListNode prev = begin, curr = begin.next;
        ListNode first = curr;
        while (curr != end) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        begin.next = prev;
        first.next = curr;
        return first;
    }
}
// Runtime: 3 ms
// Your runtime beats 100.00 % of java submissions.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        has_no_or_one_node = (not head or not head.next)
        if has_no_or_one_node or k == 1:
            return head
        
        dummy = ListNode(-1)
        dummy.next = head
        begin = dummy
        i = 0
        while head:
            i += 1
            if i % k == 0:
                begin = self._reverse(begin, head.next)
                head = begin.next
            else:
                head = head.next
        return dummy.next
    
    def _reverse(self, begin, end):
        prev, curr, first = begin, begin.next, begin.next
        while curr != end:
            curr.next, prev, curr = prev, curr, curr.next
        begin.next, first.next = prev, curr
        return first&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;思路-1&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;递归的思路和迭代的思路是一样的，也是对 k 个为一组的节点进行翻转，区别在于递归是按照从后往前的顺序分别对每组节点进行翻转，而迭代则是从前往后。&lt;/p&gt;
&lt;h2 id=&quot;java-实现-1&quot;&gt;Java 实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr = head;
        int i = 0;
        while (curr != null &amp;amp;&amp;amp; i &amp;lt; k) {
            ++i;
            curr = curr.next;
        }
        
        if (i == k) {
            curr = reverseKGroup(curr, k);
            while (i &amp;gt; 0) {
                ListNode tmp = head.next;
                head.next = curr;
                curr = head;
                head = tmp;
                --i;
            }
            head = curr;
        }
        return head;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python-实现-1&quot;&gt;Python 实现&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        curr = head
        i = 0
        while curr and i &amp;lt; k:
            curr = curr.next
            i += 1
        
        if i == k:
            curr = self.reverseKGroup(curr, k)
            while i &amp;gt; 0:
                head.next, head, curr = curr, head.next, head
                i -= 1
            head = curr
        return head&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;复杂度分析-1&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;时间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 26 Nov 2018 15:40:00 +0000</pubDate>
<dc:creator>StrongXGP</dc:creator>
<og:description>更多 LeetCode 题解笔记可以访问我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xugenpeng/p/10023876.html</dc:identifier>
</item>
<item>
<title>IDEA创建简单servlet程序 - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/10023875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/10023875.html</guid>
<description>&lt;h2&gt;创建项目&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126231212967-1451340338.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;630&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126231335579-396401477.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;631&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完后的目录结构为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126231435427-1943675892.png&quot; alt=&quot;&quot; width=&quot;288&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;web项目配置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在WEB-INF目录下新建两个文件夹，分别命名未classes和lib（classes目录用于存放编译后的class文件，lib用于存放依赖的jar包） &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126231725592-61052903.png&quot; alt=&quot;&quot; width=&quot;745&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目设置：File –&amp;gt; Project Structure…，进入 Project Structure窗口，点击 Modules –&amp;gt; 选中项目“JavaWeb” –&amp;gt; 切换到 Paths 选项卡 –&amp;gt; 勾选 “Use module compile output path”，将 “Output path” 和 “Test output path” 都改为之前创建的classes目录&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126231939981-1565189307.png&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 Modules –&amp;gt; 选中项目“JavaWeb” –&amp;gt; 切换到 Dependencies 选项卡 –&amp;gt; 点击右边的“+”，选择 “Library…”，选择tomcat的库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126232103370-1442077695.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126232252162-497827165.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126232415554-316042695.png&quot; alt=&quot;&quot; width=&quot;396&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126232516953-315700685.png&quot; alt=&quot;&quot; width=&quot;739&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4编写servlet程序&quot;&gt;编写servlet程序&lt;/h2&gt;
&lt;p&gt; 在src目录下创建servlet文件：起名为testDemo,自动生成的接口没有@Override需要自己加上，并且在doGet接口中添加内容&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126232719083-717017701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
@WebServlet(name = &quot;testDemo&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; testDemo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doPost(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
        response.setContentType(&lt;/span&gt;&quot;text/html&quot;&lt;span&gt;);

        PrintWriter out &lt;/span&gt;=&lt;span&gt; response.getWriter();
        out.println(&lt;/span&gt;&quot;&amp;lt;h1&amp;gt;hello world&amp;lt;/h1&amp;gt;&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改web.xml文件内容：在webapp标签内部加上以下内容：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;&lt;/span&gt;&lt;span&gt;
         version&lt;/span&gt;&lt;span&gt;=&quot;4.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;testDemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;5运行程序&quot;&gt;运行程序&lt;/h2&gt;
&lt;p&gt;配置Tomcat容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126233402185-302627630.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;607&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126233522689-1514399141.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好后运行程序，然后访问：http://localhost:8080/test&lt;/p&gt;
&lt;p&gt;得到结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181126233808073-1709369402.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Nov 2018 15:39:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>创建项目 创建完后的目录结构为： web项目配置 在WEB-INF目录下新建两个文件夹，分别命名未classes和lib（classes目录用于存放编译后的class文件，lib用于存放依赖的jar包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/10023875.html</dc:identifier>
</item>
<item>
<title>Python-定时爬取指定城市天气(一)-发送给关心的微信好友 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/10023491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/10023491.html</guid>
<description>&lt;h3&gt;一、背景&lt;/h3&gt;
&lt;p&gt;    上班的日子总是3点一线，家里，公司和上班的路径，对于一个特别懒得我来说，经常遇到上班路上下雨了，而我却没带伞，多么痛的领悟。最近对python有一种狂热的学习热情，写了4年多的C++代码，对于python我不能说简单，但是他做东西确实太快了，现有的第三方资源真的炒鸡多，用的我也是不亦乐乎。除了上班忘记带伞，每天重复性的工作还有很多，比如上下班打卡、每个礼拜的周报，还有如果有关心的女神，也可以做定时发送心里话，或者定时提醒等各种服务。有时候想如果有一个人能按时提醒我就好了，这种想法也就停留了那么几分钟就被自己pass掉了，因为别人也可能忘记啊。。。那么这件事是不是可以交给程序来做呢！毕竟程序可是会老老实实的做重复性的工作，而且他们乐此不疲。&lt;/p&gt;
&lt;p&gt;    上述问题的场景大多都是需要程序在指定时间、或者指定场合提醒我们该干什么了，本篇文章就定时天气提醒服务来做开篇，讲述使用Python怎么完成这样一个任务，既然这样，那我们就开始构思我们的程序吧&lt;/p&gt;
&lt;h3&gt;二、构思&lt;/h3&gt;
&lt;p&gt;    看过背景中的需求描述，要实现这个功能，我们需要解决以下这么几个问题：&lt;/p&gt;
&lt;p&gt;1、爬取天气信息，那么接下来就产生第二个问题了&lt;/p&gt;
&lt;p&gt;2、动态获取指定城市天气&lt;/p&gt;
&lt;p&gt;3、发送天气信息给指定微信好友&lt;/p&gt;
&lt;p&gt;4、定时触发爬取动作&lt;/p&gt;
&lt;p&gt;5、怎么关联微信账号&lt;/p&gt;
&lt;p&gt;    下面我们将一步一步解决上述几个问题，并实现我们的需求&lt;/p&gt;
&lt;h3&gt;三、爬取天气&lt;/h3&gt;
&lt;p&gt;    解决问题1：&lt;/p&gt;
&lt;p&gt;    对于使用过爬虫的同学来说，爬取天气信息并不难，之前也了解过一些爬取web信息的代码，简单的爬虫无非就是那么几步&lt;/p&gt;
&lt;p&gt;1、确定爬取的url，使用浏览器打开&lt;/p&gt;
&lt;p&gt;2、F12查看网页布局信息&lt;/p&gt;
&lt;p&gt;3、使用xpath或者bs4进行节点定位&lt;/p&gt;
&lt;p&gt;4、拿到页面信息&lt;/p&gt;
&lt;p&gt;5、自己拼接爬取到的信息&lt;/p&gt;
&lt;p&gt;6、写文件、写数据库、发送网络等等&lt;/p&gt;
&lt;p&gt;    这里贴下我之前写的几个简单爬虫：&lt;/p&gt;
&lt;p&gt;1、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/swarmbees/p/10017073.html&quot;&gt;Python-爬取校花网视频(单线程和多线程版本)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/swarmbees/p/10016919.html&quot;&gt;Python-爬取妹子图(单线程和多线程版本)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/swarmbees/p/10011898.html&quot;&gt;python爬虫Scrapy(一)-我爬了boss数据&lt;/a&gt;，这个应该还有个下篇，后面待续&lt;/p&gt;
&lt;p&gt;    下面是爬取城市天气的python方法，需要注意一点的是getWeath接口的参数city_code，这是一个全国城市编码，每个城市都是唯一的，这个表格我已经整理成了一个txt文档，后续放源码的时候会一并提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getWeath(city_code):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         url = f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.weather.com.cn/weather/{city_code}.shtml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         resp = requests.get(url, headers =&lt;span&gt; headers)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; BaseException as e:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     resp.encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     soup = BeautifulSoup(resp.text, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html.parser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     tagToday = soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_ = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一个包含class=&quot;tem&quot;的p标签即为存放今天天气数据的标签&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         temperatureHigh = tagToday.span.string  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;有时候这个最高温度是不显示的，此时利用第二天的最高温度代替。&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; AttributeError:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         temperatureHigh = tagToday.find_next(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).span.string  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取第二天的最高温度代替&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     temperatureLow = tagToday.i.string  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取最低温度&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     weather = soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_ = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wea&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).string &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取天气&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     wind = soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_ = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;win&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取风力&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     clothes = soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_ = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;li3 hot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;穿衣指数&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;温度&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:f&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{temperatureHigh}/{temperatureLow}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;天气&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:weather
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;风力&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:wind.i.string
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;穿衣&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:clothes.a.span.string + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + clothes.a.p.string}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     上述方法可以获取一个城市的天气信息，并储存在一个字典中，我们要发送给好友，还需要对其进行字符串处理，处理代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; strDic(dic):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     str_weather = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;        str_weather += key + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; dic[key]
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        str_weather += &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; str_weather
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    全国城市编码如下图所示，每个城市的编码都是一个9位的数字组成，获取天气信息时是通过指定该编码进行查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181126223406009-1846300285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四、发送给指定好友&lt;/h3&gt;
&lt;p&gt;    解决问题3：发送消息给好友&lt;/p&gt;
&lt;p&gt;    解决问题5：怎么关联微信账号，使用wechat_sender库&lt;/p&gt;
&lt;p&gt;    我们自己爬取到的天气信息怎么和微信能扯上关系呢，这个时候就要提到我之前写过的一篇文章&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/swarmbees/p/9996547.html&quot;&gt;微信聊天机器人-存储好友分享消息&lt;/a&gt;，没有看过的同学可以快速浏览一遍，简单来说就是登陆一个web版本的微信账号，在我们的电脑上，做这么一个机器人使用了库&lt;a href=&quot;https://wxpy.readthedocs.io/zh/latest/index.html&quot; target=&quot;_blank&quot;&gt;wxpy&lt;/a&gt;，要想和这个机器人勾搭上，那我们就需要请出我们今天的重磅嘉宾&lt;a href=&quot;https://wechat-sender.readthedocs.io/zh_CN/latest/index.html&quot; target=&quot;_blank&quot;&gt;wechat_sender&lt;/a&gt;，&lt;span&gt;&lt;span&gt;wechat_sender是基于&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;reference external&quot; href=&quot;https://github.com/youfou/wxpy&quot;&gt;&lt;span&gt;&lt;span&gt;wxpy&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;reference external&quot; href=&quot;https://github.com/tornadoweb/tornado&quot;&gt;&lt;span&gt;&lt;span&gt;tornado&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt; 实现的一个可以将你的网站，爬虫，脚本等其他应用中各种消息（日志，报警，运行结果等）发送到微信的工具包，有了他我们的消息就可以顺利的发送到我们的饿微信账户了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181126224424752-54277325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;交互流程&lt;/p&gt;
&lt;p&gt;    如上图所示，首先使用wxpy登陆微信机器人，当然这个机器人使用的是我们自己的微信账号，这里需要特别注意一点，&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/swarmbees/p/9996547.html&quot;&gt;微信聊天机器人-存储好友分享消息&lt;/a&gt;这篇文章中讲述的机器人进入命令状态是使用的embed()方法，在这里我们不能使用该接口了，我们需要换成上述交互流程的很关键的一步，使用listen接口进行监听，这样我们的web工具才能发送消息给机器人，建议仔细阅读一遍&lt;a href=&quot;https://wechat-sender.readthedocs.io/zh_CN/latest/index.html&quot; target=&quot;_blank&quot;&gt;wechat_sender&lt;/a&gt;说明文档，内容不多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181126224543620-582871096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登陆微信机器人&lt;/p&gt;
&lt;p&gt;    爬取到天气信息以后，使用wechat_sender中的Sender类直接发送消息给微信机器人，下属代码中尝试是用来多种发送消息的方式，代码中都有详细注释，可自行阅读&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; sendWeatherMsg(receivers, msg):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;receivers = [u'拉卡拉', u'证明给他看', u'李静']&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;receivers = u'李静,情绕指尖'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;          
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        #发送给指定好友 如果好友不存在 则发送给文件夹传输助手
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        Sender(receivers = u'证明给他看').send(msg)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        Sender(receivers = u'拉卡拉').send(msg)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        Sender(receivers = u'李静').send(msg)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;   &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;发送给指定接收的用户  &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;receivers = u'拉卡拉'&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接受者必须是监听对象的子集&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         sender = Sender(receivers = receivers, token = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;weather_report_123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         sender.send(msg)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果没有指定receivers则发送给文件传输助手&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        receivers = u'李静,情绕指尖'
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        sender = Sender(receivers = receivers, token = 'weather_report_123456789')
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;        
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        #有时候好使    有时候不好使
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        sender.send_to('@wss', u'拉卡拉') #消息发送失败 会默认发送给receivers的第一个用户 Sender和Listen
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        #sender.send_to(msg, u'证明给他看')
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;测试控制命令&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        receivers = u'拉卡拉'
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        sender = Sender(receivers = receivers, token = 'weather_report_123456789')
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        sender.send('@wss')#文如果没有指定receivers则发送给文件传输助手件传输助手
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; BaseException as e:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    登陆微信机器人&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/swarmbees/p/9996547.html&quot;&gt;微信聊天机器人-存储好友分享消息&lt;/a&gt;已经讲过，有不懂的同学可以回头看下，下边代码中第12行非常关键，这一行就是用来监听外部程序发送消息的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; bot = Bot(cache_path =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; receivers =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;receivers.append(bot.file_helper)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; receivers.append(bot.friends().search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;拉卡拉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; receivers.append(ensure_one(bot.friends().search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李静&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, city=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;西安&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;有可能搜索出多个结果&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; receivers.append(bot.friends().search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;证明给他看&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; receivers.append(bot.friends().search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;妈&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(receivers)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; listen(bot, receivers = receivers, token = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;weather_report_123456789&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关键一步&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、城市编码&lt;/h3&gt;
&lt;p&gt;    解决问题2，根据配置的城市名称动态获取城市编码，然后请求数据&lt;/p&gt;
&lt;p&gt;    由于没有接口可以直接获取城市编码，因此这里我们自己封装了一个类来进行管理城市名称和城市编码，拉取城市天气时，只要输入城市名称，那么城市编码即可通过该类获取到，具体代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; City(object):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self.city =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load(self, file):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; os.path.exists(file):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             with open(file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 cityInfo = f.readline().strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;&lt;span&gt; cityInfo:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     datas = cityInfo.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     self.city[datas[0]] = datas[1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     cityInfo = f.readline().strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; find_code(self, city_name):#根据城市名称，查找城市吧编码
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; city_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.city:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.city[city_name]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、定时任务 &lt;/h3&gt;
&lt;p&gt;    解决问题4：定时发送任务&lt;/p&gt;
&lt;p&gt;    我们的需求是每日定时拉取天气信息，并发送给指定好友，python有一个APScheduler库，支持定时任务，具体使用比较负责，我也没有仔细研究，这里我们只是需要使用一个定时任务，其他不做介绍，有兴趣的同学可自行研究。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;在研究定时任务的过程中，一直没有找到&lt;/span&gt;&lt;span&gt;BackgroundScheduler类add_job时，回调函数怎么传递参数，因此这里我封装了一个类，让定时任务和任务回调处于一个域内，这样参数就可以放在类的成员变量未知，不需要传递了，哪位大神如果会次操作，可以评论区指出，非常感谢&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyJob(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sendWeatherMsg&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; my_job &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.my_jobs:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             code = city_code.find_code(my_job[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             wea =&lt;span&gt; getWeath(code)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             strWea =&lt;span&gt; strDic(wea)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             title = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{}天气预报：\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(my_job[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             sendWeatherMsg(my_job[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;receivers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], title + strWea)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发送天气信息给文件助手&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; addMyJobs(self, json_job):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.my_jobs = json_job[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         scheduler =&lt;span&gt; BackgroundScheduler()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         scheduler.add_job(self.&lt;span&gt;__sendWeatherMsg&lt;/span&gt;, trigger = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cron&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hour = json_job[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         , minute = json_job[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;minute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], second = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5,10,15,20,25,30,35,40,45,50,55&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         scheduler.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    后期出现不同类型任务时，我们就需要在封装新的类。上述MyJob类有2个接口，一个是任务调度器回调接口，不需要我们调用，另一个是加载任务接口，这个任务参数是一个标准的json串，由任务触发时间和具体的任务列表组成，任务触发时间主要是给调度器使用，任务列表就是调度器触发时的回调函数需要执行的任务数量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; my_jobs =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my_jobs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hour&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6, 17&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;minute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;items&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:[{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receivers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件传输助手,李静,拉卡拉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;昌平&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    },{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;receivers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件传输助手,李静,拉卡拉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;海淀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如上述任务json串来说，我们的任务id为my_jobs，在每天的6.30和17.30，我们需要执行items列表所指出的任务，任务列表是一个列表，列表中存储的是具体任务，receivers代表任务执行完毕需要发送的好友，city是爬取的天气名称，测试效果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181126230626106-221364032.jpg&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;502&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983568/201811/983568-20181126230706786-2010268264.jpg&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;502&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    由于任务调度器不是一个阻塞性的程序，如果我们不在主线程进行阻塞程序，那么程序就会直接退出，如果阻塞了主线程，那么任务调度程序也将会被阻塞，因此这里在添加任务调度后，我们开启了一个子线程，主要就是为了不让主线程退出，这样做其实不合理，但是我们这里仅仅是为了掩饰，在下篇文章中这些问题我们在做进一步处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; city_code =&lt;span&gt; city_code.City()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; city_code.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city_code.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         my_job =&lt;span&gt; MyJob()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        my_job.addMyJobs(test_jobs)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         f = &lt;span&gt;lambda&lt;/span&gt; x : &lt;span&gt;lambda&lt;/span&gt; y : x+&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         t = Timer.Timer(f, 24 * 60 * 60)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建线程 一天给自己发一条消息&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        t.setDaemon(True)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        t.start()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        t.join()  #防止主主线程退出
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;SendWeatherMsg(my_msg)&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ResponseError as e:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(e.err_code, e.err_msg) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看错误号和错误消息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    喜欢的同学可以自己尝试完成下这个小程序，或者选择一个类似的场景进行处理，本篇文章中其实好友几个需要优化的地方，由于篇幅问题，我们在下篇中进行讲解&lt;/p&gt;
&lt;p&gt;1、定时任务做成windows服务，这样更优雅，随开机启动&lt;/p&gt;
&lt;p&gt;2、发送消息给微信好友换成发送邮件给指定邮箱&lt;/p&gt;
&lt;h3&gt;七、资源下载 &lt;/h3&gt;
&lt;p&gt;    需要全部代码的到csdn直接下载：&lt;a href=&quot;https://download.csdn.net/download/qq_30392343/10809337&quot; target=&quot;_blank&quot;&gt;Python-定时爬取指定城市天气(一)-发送给关心的微信好友&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转载声明：本站文章无特别说明，皆为原创，版权所有，转载请注明：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot; target=&quot;_blank&quot;&gt;朝十晚八&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 15:34:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>一、背景 上班的日子总是3点一线，家里，公司和上班的路径，对于一个特别懒得我来说，经常遇到上班路上下雨了，而我却没带伞，多么痛的领悟。最近对python有一种狂热的学习热情，写了4年多的C++代码，对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swarmbees/p/10023491.html</dc:identifier>
</item>
<item>
<title>分布式系统(微服务架构)的一致性和幂等性问题相关概念解析 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/10021538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/10021538.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;什么是分布式系统?关于这点其实并没有明确且统一的定义。在我看来,只要一个系统满足以下几点就可以称之为分布式系统&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统由物理上不同分布的多个机器节点组成&lt;/li&gt;
&lt;li&gt;系统的多个节点通过网络进行通信,协调彼此之间的工作。&lt;/li&gt;
&lt;li&gt;系统作为整体统一对外提供服务,其分布式细节对客户端透明。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想更好的理解分布式系统,并正确使用甚至构建分布式系统,需要理解其中的两个关键概念——分布式系统的数据一致性和分布式系统的幂等性。&lt;/p&gt;
&lt;h2 id=&quot;分布式系统的数据一致性&quot;&gt;1. 分布式系统的数据一致性&lt;/h2&gt;
&lt;p&gt;对于分布式系统,数据可能存在于不同的物理节点上,节点之间只能通过网络进行通信来协调彼此之间的状态,而网络通信需要时间并且其本身并不十分可靠,因而如何保持数据一致性成为了分布式系统的难题。对于不同的分布式系统,其一致性语义以及面对的一致性难题可能略有差别&lt;/p&gt;
&lt;h3 id=&quot;分布式存储系统中的一致性问题&quot;&gt;1.1 分布式存储系统中的一致性问题&lt;/h3&gt;
&lt;p&gt;在分布式存储系统中,为了保持系统的高可用,同时增加读操作的并发性,同一份数据会有多份副本,不同的副本存储于不同的节点上,如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172059290-1913670248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在并发环境下,因为存在多个客户端同时读取同一数据在不同节点上的副本,因而如何维护数据的一致性视图就非常重要,即对于使用该分布式系统的客户端而言,对于多副本数据的读写其表现应该和单份数据一样,通常系统是通过数据复制的方式来达到这一点的,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端将节点1中的副本A修改为10,系统将通过网络通信的方式将节点2和节点3中的副本A也更新为10。然而网络通信是需要时间的,假设在系统还未将节点1中的A值同步到节点2和节点3,此时另一个客户端访问了节点2和节点3,这个时候系统怎么办？&lt;/li&gt;
&lt;li&gt;甚至,考虑更极端的场景,节点之间的网络被断开,不同节点无法感知到彼此的存在,当然也就无法保持多副本数据的同一视图,那么这个时候系统又该怎么办？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;微服务应用的分布式一致性问题&quot;&gt;1.2 微服务应用的分布式一致性问题&lt;/h3&gt;
&lt;p&gt;微服务架构下,原有的单体应用按功能被拆分成一个个微服务应用,每个微服务应用被部署在不同的机器节点上,只完成原有单体应用的某一部分功能,操作属于该业务功能的数据库或表。彼此之前通过网络通信的方式协调彼此之间的工作,作为整体共同对外提供服务,因而一个业务功能的实现,可能会涉及到多个微服务的调用,操作物理上不同的多个数据库或表。比如对于下单并支付这个业务功能而言,需要调用下单微服务和支付微服务来共同完成。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172127547-580125325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于下单并支付这一业务功能,应用先调用订单微服务,在订单数据库中添加一条订单记录,成功后再调用支付微服务添加相应的支付记录,只有这两个微服务都调用成功,该业务功能才算执行成功。这个过程可能存在以下的问题:&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;订单微服务调用成功,订单记录已落地,但是支付微服务由于各种原因迟迟得不到响应,此时用户通过订单号查询只能查到订单记录而查不到支付记录,这对于已经成功付款的用户而言肯定是无法接受的,这种情况该怎么办？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;订单微服务调用成功,订单记录已落地,但是支付微服务调用失败,此时订单记录和支付记录所对应的业务状态不一致,这时候系统该怎么办?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对于一致性的正确理解&quot;&gt;1.3 对于一致性的正确理解&lt;/h3&gt;
&lt;p&gt;分布式存储系统的一致性问题,主要在于如何维持多副本的一致性视图上,即如何使多份数据对外表现的和一份数据一样。而微服务架构下的分布式应用系统,其一致性问题主要在于如何使不同微服务的数据对同一业务状态的描述保持一致,比如对于下单并支付这一业务操作而言,下单和支付要么同时成功,要么应该同时失败,而不应该一个成功一个失败,并且在这个过程中,某部分已经成功或失败的数据是否应该对客户端可见。在联系一下本地事务ACID中的一致性,我们可能会产生一定的混乱:它们讲的一致性是一个东西吗？先说下我的个人理解:不管是ACID的一致性还是不同分布式系统中的一致性,它们本质上讲的是一件事:数据的一致性,在于正确的反应现实世界,对发生于现实世界的事情的正确描述。这就要求,一致性的数据至少要满足以下两个条件:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.符合系统本身具有的约束条件,比如数据库中的数据要遵循主码,外码,check约束。&lt;/li&gt;
&lt;li&gt;2.与特定业务有关的所有数据,它们对业务执行状态的描述应该保持一致。比如从A账户转账100元到B账户这一业务操作,不管A账户和B账户是否在一个数据库,也不管这一业务操作是否执行成功,两个账户的总金额应该保持不变;如果有关账户金额的数据存储在分布式系统的多个不同的副本,则这些副本的数据应该一样。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从这个意义上,不管是单机数据库还是分布式存储系统还是微服务架构下的分布式应用,对一致性的追求本质上是一样的:在满足系统本身约束的前提下,对于发生的业务操作及其执行状态的一致性描述。只不过由于分布式系统数据的分布式存储以及网络通信状况的复杂,使得分布式系统要保持数据一致性相比单机应用要考虑更多复杂的因素,实现也要困难的多。很多文章把它们做了严格的区分,个人觉得很没有必要,也不利于对于一致性的正确理解,从哲学的角度看,是割裂了事物共性和个性之间的联系。&lt;/p&gt;
&lt;h2 id=&quot;分布式一致性模型&quot;&gt;2.分布式一致性模型&lt;/h2&gt;
&lt;p&gt;就好像单机数据库中为事务的隔离性设置了不同的级别,分布式系统中对数据的一致性级别也有分类。总的来说可以分为强一致性和弱一致性两大类,弱一致性中又可以继续细分为最终一致性,因果一致性,会话一致性,单调读一致性和单调写一致性等多种,不过弱一致性中只有最终一致性比较重要,其他的可以暂时忽略。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172149920-282613797.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;强一致性&lt;br/&gt;以带多副本的分布式存储系统为例,所有连接到分布式系统的客户端看到的某一数据的值都是一样的。当某个客户端修改了这个值,后续的所有客户端都能读取到这个更新的值,并且所有的更新操作都在这个新的值的基础上进行,直到这个值被再次修改,如下图所示,在A修改X前所有客户端都能读取到X的值为1,在A将X修改为2之后,所有客户端都能读取到这个更新后的值。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172207647-2045462794.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;最终一致性&lt;br/&gt;所有不能满足强一致性要求的都称为弱一致性,而最终一致性是其中比较强的一种。在最终一致性模型下,当数据项X被修改后,客户端并不一定能马上看到这个更新后的值(有些可能读取到了新值,有些读取到的可能还是旧值),但是在一段时间后,所有客户端都能读取到这个更新后的值并进行相关操作。最终一致性模型下,分布式数据最终能达到一致,但是需要经过一段时间,这段时间称为不一致窗口。&lt;br/&gt;如下图所示,在A将X修改为2后,在不一致窗口内只有B能读取到X=2,其他客户端读取到的依旧是X=1。但是在不一致窗口后,所有客户端都能读取到X=2。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172220854-1462412213.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;追求强一致性的约束cap定理&quot;&gt;3. 追求强一致性的约束——CAP定理&lt;/h2&gt;
&lt;p&gt;严格意义上来讲,真正的一致性模型只有一种——强一致性,这也是一种理想化的模型。它为分布式数据维护了完全一致的视图,使得一旦修改了数据后,所有客户端能够马上看到这个更新后的值并基于这个新值进行后续的操作,使得我们操作分布式数据和操作本地数据一样。在分布式系统中要实现一致性需要考虑其他因素,比如可用性和分区容忍性,而这些因素相互有制约,这种制约关系在CAP定理中被很好的进行了描述。&lt;/p&gt;
&lt;p&gt;CAP是&quot;Consistency&quot;,&quot;Availabilty&quot;,&quot;Partition Tolerance&quot;的简称,分别代表了:强一致性,可用性和分区容忍性,它们的含义分别如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强一致性:在分布式系统同一份数据有多副本的情况下,对于数据的操作效果和只有单份数据一样。&lt;/li&gt;
&lt;li&gt;可用性:客户端在任何时刻对数据的读/写操作都应该保证在时限内完成。&lt;/li&gt;
&lt;li&gt;分区容忍性:当分布式系统出现网络分区,不同分区间的机器无法进行网络通信时,系统仍然能够继续工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CAP定理的内容:对于一个分布式系统,无法同时实现强一致性,可用性和分区容忍性,即CAP三要素不可兼得。&lt;/p&gt;
&lt;h3 id=&quot;如何理解cap三要素不可兼得&quot;&gt;3.1 如何理解CAP三要素不可兼得&lt;/h3&gt;
&lt;p&gt;由于网络的不可靠性,网络分区的情况不可避免的会发生,当出现网络分区时,不同分区的机器无法进行通信。分布式系统必须能够在出现网络分区的情况下继续工作,因而对于分布式系统而言,P即分区容忍性是必须要具备的要素,那么问题就转化为了,在系统满足分区容忍性的前提下,为什么强一致性和可用性不可兼得。&lt;br/&gt;假设数据项A的三个副本分别存储在不同的物理节点,在某一时刻,系统状态如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172244053-1977360966.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当客户端将节点1上的A修改为2后,系统出现了网络分区,其中节点1和节点2在一个网络分区中,而节点3在另一个分区中&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172256855-469667955.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当有客户端尝试读取节点3上的A值时,系统将面临两难困境&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统等待节点3从节点1同步A的值,待数据一致后再返回客户端响应,但是因为节点3和节点1不在一个分区中,双方无法进行通信,导致系统无法在限定时间内给客户端返回读取结果,这明显不符合可用性的要求。&lt;/li&gt;
&lt;li&gt;系统立即返回一个A=1的旧值给客户端,由于A的值在不同节点上不一样,导致一致性的条件被破坏。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因而,对于满足分区容错性的系统而言,强一致性和可用性的要求难以同时被满足。其实这是很容易理解的,即使没有网络分区,因为不同节点上的数据需要经过网络通信来保持一致性,这个过程本身就比较花时间,当需要在给定很短的时限内基于客户端响应时,对于一致性的保证自然就比较弱。&lt;/p&gt;
&lt;h3 id=&quot;如何正确理解cap定理&quot;&gt;3.2 如何正确理解CAP定理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对于分布式系统而言CAP三要素不可兼得,但并不意味着在任何时刻都必须从中做出取舍,或者在构建分布式系统之初就选择其中两个而放弃另一个,这种看法具有片面性。&lt;/li&gt;
&lt;li&gt;由于网络分区出现的可能性非常小,系统在正常运行的情况下还是应该兼顾AC两者,在进入网络分区模式后才需要对P进行保证,从A和C中选择牺牲一个。&lt;/li&gt;
&lt;li&gt;A和C并不是一个硬币的两面,只能选择其中一个;A和C应该看成天平,系统可以选择向哪边倾斜,但另一边也应该一定程度的保留。&lt;/li&gt;
&lt;li&gt;对于A和C之间的选择,不应该粗粒度的整个系统级别进行选取,而应该针对系统中的不同子系统,针对性的采取不同的取舍策略。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一致性的妥协最终一致性和base原则&quot;&gt;4. 一致性的妥协——最终一致性和Base原则&lt;/h2&gt;
&lt;p&gt;由CAP定理可知,在分布式系统中过于追求数据的强一致性将导致可用性一定程度被牺牲,这意味着系统将不能很好的响应用户的请求,这会一定程度影响用户体验。因而对于大部分布式系统而言,应当在保证系统高可用的前提下去追求数据的一致性,BASE原则正是对这一思想的描述。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;BA(Basically Available)&lt;br/&gt;基本可用:系统在绝大部分时间应处于可用状态,允许出现故障损失部分可用性,但保证核心可用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;S(Soft State)&lt;br/&gt;软状态:数据状态不要求在任何时刻都保持一致,允许存在中间状态,而该状态不影响系统可用性。对于多副本的存储系统而言,就是允许副本之间的同步存在延时,并且在这个过程中系统依旧可以响应客户端请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;E(Eventual Consistency)&lt;br/&gt;最终一致性:尽管软状态不要求分布式数据在任何时刻都保持一致,但经过一定时间后,这些数据最终能达到一致性状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BASE理论的核心思想是:把分布式系统的可用性放在首位,放弃CAP中对数据强一致性的追求,只要系统能保证数据最终一致。&lt;/p&gt;
&lt;h3 id=&quot;capbase以及acid的关系&quot;&gt;4.1 CAP,BASE以及ACID的关系&lt;/h3&gt;
&lt;p&gt;CAP描述了对于一个分布式系统而言重要的三要素:数据一致性,可用性,分区容错性之间的制约关系,当你选择了其中的两个时,就不得不对剩下的一个做一定程度的牺牲。BASE和ACID都可以看做是对CAP三要素进行取舍后的某种特殊情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BASE强调可用性和分区容错性,放弃强一致性,这是大部分分布式系统的选择,比如NoSQL系统,微服务架构下的分布式系统&lt;/li&gt;
&lt;li&gt;ACID是单机数据的事务特性,因为不是分布式系统无需考虑分区容错,故而是选择了可用性和强一致性后的结果。&lt;br/&gt;它们之间的关系如下所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172311186-1011057077.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;分布式系统的幂等性&quot;&gt;5. 分布式系统的幂等性&lt;/h2&gt;
&lt;p&gt;幂等的概念来自于抽象代数,比如对于一元函数来说,满足以下条件&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126172328393-754601544.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即可称为满足幂等性。在计算机科学中,一个操作如果多次执行产生的影响与一次执行的影响相同,这样的操作即符合幂等性。在分布式系统中,服务消费方调用服务提供方的接口,多次调用的结果应该与一次调用的结果一样,这正是分布式环境下幂等性的语义。为什么幂等性对分布式系统而言如此重要？因为在分布式环境下,服务的调用一般采用http协议或者rpc的方式,即双方需要通过网络进行通信,而因为网络故障或者消息超时的存在,可能服务消费方已经成功调用了服务提供方的服务接口,但是消费方并没有收到来自对方的成功响应,导致消费方以为服务调用失败从而再次进行调用,也就是说网络的不可靠性导致了服务接口被多次调用的可能。分布式系统必须保证在这种情况下,即使接口被多次调用,它对系统产生的影响应该与该接口只被调用一次的结果一样。&lt;/p&gt;
&lt;h2 id=&quot;微服务架构的分布式一致性和幂等性问题&quot;&gt;6.微服务架构的分布式一致性和幂等性问题&lt;/h2&gt;
&lt;h3 id=&quot;微服务架构下的分布式一致性问题&quot;&gt;6.1 微服务架构下的分布式一致性问题&lt;/h3&gt;
&lt;p&gt;微服务架构下,处理一个业务请求可能需要调用多个微服务进行处理,以前面的下单并支付场景为例,完成该业务请求需要先后调用订单微服务的下单接口和支付微服务的支付接口,只有这两个接口都调用成功,该业务操作才算执行成功。那么微服务架构中是如何保证同属于一个业务单元的多个操作的原子性以及保证分布式数据一致性的?——答案是分布式事务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且根据遵循的一致性原则不同,可以分为刚性分布式事务和柔性分布式事务两大类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;遵循ACID原则的刚性事务&lt;br/&gt;刚性事务追求数据的强一致性,比如基于两阶段提交和三阶段提交的分布式事务就属于刚性事务,通过分布式事务,客户端可以看到描述业务执行状态的多个数据的一致性视图,比如下单并支付这个业务操作,客户端要么能够同时查询到下单和支付成功的信息,要么能够同时查询到下单和支付失败的信息,其他不一致的情况对于客户端而言都是不可见的。比如下单成功,支付还在处理;下单成功,支付失败,下单记录正在回滚。也就是说,当订单数据和支付数据不一致时,对于客户端的访问请求应该予以拒绝。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126231736174-597425335.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这当然导致了系统可用性的降低,加上刚性事务实现时会导致同步阻塞的问题,锁定资源等问题,会极大的影响系统的吞吐量和设计弹性,所以实际上微服务架构不太会采用刚性事务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;遵循BASE原则的柔性事务&lt;br/&gt;柔性事务只对数据的最终一致性进行保证,允许系统存在一定时间的数据不一致,比如订单记录已经被更新但是支付记录还没落地时,又比如订单记录更新成功但是支付失败订单记录回滚的过程。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181126231746183-1828715973.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个不一致窗口内,系统允许客户端对不一致的数据进行访问,因而系统的可用性相比而言会更好,加上其扩展性良好以及吞吐量的优势,一般微服务架构下都会采用柔性事务。柔性事务有多种不同的实现方式,比如基于可靠事件的模式,基于补偿的模式,基于Sagas长事务的模式等,具体的实现原理以及优缺点对比就放到下一篇在详解解释。&lt;/p&gt;
&lt;h3 id=&quot;微服务架构下的幂等性问题&quot;&gt;6.2 微服务架构下的幂等性问题&lt;/h3&gt;
&lt;h4 id=&quot;幂等性场景&quot;&gt;6.2.1 幂等性场景&lt;/h4&gt;
&lt;p&gt;在微服务架构下,不同微服务间会有大量的基于http,rpc或者mq消息的网络通信,接口的重复调用以及消息的重复消费可能会经常发生,比如以下这些情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用订单创建接口,第一次调用超时,调用方又尝试了一次,但其实第一次调用已经成功,只是调用方没有及时收到响应。&lt;/li&gt;
&lt;li&gt;订单支付完成后,需要向MQ发送一条消息,但该消息重复发送了两条。&lt;/li&gt;
&lt;li&gt;网络波动导致服务提供方的接口被调用了两次。&lt;/li&gt;
&lt;li&gt;用户在使用产品时,无意地触发多笔交易。&lt;/li&gt;
&lt;li&gt;某些未关闭的重试机制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;微服务架构应该具有幂等性,当接口被重复调用时,消息被重复消费时,对系统的产生的影响应该和接口被调用一次,消息被消费一次时一样。&lt;/p&gt;
&lt;h4 id=&quot;crud操作的幂等性分析&quot;&gt;6.2.2 CRUD操作的幂等性分析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;新增请求:不具备幂等性&lt;/li&gt;
&lt;li&gt;查询请求:重复查询不会影响系统状态,查询天然具备幂等性&lt;/li&gt;
&lt;li&gt;基于主键的更新请求&lt;br/&gt;要更新的值依赖于前值,不具备幂等性。比如&lt;code&gt;update goods set number=number-1 where id=1&lt;/code&gt;&lt;br/&gt;要更新的值不依赖于前值,具备幂等新。比如&lt;code&gt;update goods set number=newNumber where id=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除请求&lt;br/&gt;基于主键的物理删除(delete)删除具备幂等性&lt;br/&gt;基于主键的逻辑删除(update)也具有幂等性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结:通常只需要对新增请求和更新请求作幂等性保证。&lt;/p&gt;
&lt;h4 id=&quot;如何解决幂等性问题&quot;&gt;6.2.3 如何解决幂等性问题&lt;/h4&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;全局唯一ID&lt;br/&gt;根据业务生成一个全局唯一ID,在调用接口时会传入该ID,接口提供方会从相应的存储系统比如Redis中去检索这个全局ID是否存在,如果存在则说明该操作已经执行过了,将拒绝本次服务请求;否则将相应该服务请求并将全局ID存入存储系统中,之后包含相同业务ID参数的请求将被拒绝。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;去重表&lt;br/&gt;这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中,一个订单只会支付一次,可以建立一张去重表,将订单ID作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中,这样当出现重复支付时,数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;多版本并发控制&lt;br/&gt;适合对更新请求作幂等性控制,比如要更新商品的名字,这是就可以在更新的接口中增加一个版本号来做幂等性控制&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;boolean updateGoodsName(int id,String newName,int version);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库更新的SQL语句如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update goods set name=#{newName},version=#{version} where id=#{id} and version&amp;lt;${version}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;状态机控制&lt;br/&gt;适合在有状态机流转的情况下,比如订单的创建和付款,订单的创建肯定是在付款之前。这是可以添加一个int类型的字段来表示订单状态,创建为0,付款成功为100,付款失败为99,则对订单状态的更新就可以这样表示&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;update order set status=#{status} where id=#{id} and status&amp;lt;#{status}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;插入或更新&lt;br/&gt;在MySQL数据库中，如果在insert语句后面带上ON DUPLICATE KEY UPDATE 子句，而要插入的行与表中现有记录的惟一索引或主键中产生重复值,则对旧行进行更新;否则执行新纪录的插入。&lt;br/&gt;我们可以利用该特性防止记录的重复插入,比如good_id和category_id构成唯一索引,则重复执行多次该SQL,数据库中也只会有一条记录。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;insert into goods_category (goods_id,category_id,create_time,update_time) 
       values(#{goodsId},#{categoryId},now(),now()) 
       on DUPLICATE KEY UPDATE
       update_time=now()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;7. 参考资料&lt;/h2&gt;
&lt;p&gt;《大数据日知录》&lt;br/&gt;《微服务设计原理与架构》&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wangyan9110/article/details/70953273&quot;&gt;如何保证微服务接口的幂等性&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 15:34:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<og:description>[TOC] 前言 什么是分布式系统?关于这点其实并没有明确且统一的定义。在我看来,只要一个系统满足以下几点就可以称之为分布式系统 系统由物理上不同分布的多个机器节点组成 系统的多个节点通过网络进行通信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/10021538.html</dc:identifier>
</item>
<item>
<title>Linux组管理和权限管理 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10023825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10023825.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linux组基本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件&lt;/p&gt;
&lt;p&gt;有所有者、所在组、其它组的概念。&lt;/p&gt;

&lt;p&gt;1) 所有者&lt;/p&gt;
&lt;div&gt;2) 所在组&lt;a href=&quot;http://home.cnblogs.com/group/topic/8550.html&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;3) 其它组&lt;/p&gt;
&lt;p&gt;4) 改变用户所在的组&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件/目录 所有者&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者&lt;/p&gt;

&lt;p&gt;查看文件的所有者&lt;/p&gt;
&lt;p&gt;1) 指令：ls –ahl&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126231719350-509570536.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126231818338-2010002123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2) 应用实例&lt;/p&gt;
&lt;p&gt;修改文件所有者&lt;/p&gt;
&lt;p&gt;• 指令：&lt;/p&gt;
&lt;p&gt;   &lt;span&gt; chown 用户名 文件名&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126231911996-1483567244.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;357&quot;/&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;组的创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本指令&lt;/p&gt;
&lt;p&gt;groupadd 组名&lt;/p&gt;
&lt;p&gt;应用实例:&lt;/p&gt;
&lt;p&gt;创建一个组, ,monster&lt;/p&gt;
&lt;p&gt;创建一个用户 fox ，并放入到 monster组中&lt;/p&gt;

&lt;p&gt;创建一个组：&lt;/p&gt;
&lt;p&gt;groupadd   组名&lt;/p&gt;

&lt;p&gt;在组下创建用户名&lt;/p&gt;
&lt;p&gt;&lt;span&gt;useradd -g 组名 用户名&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。&lt;/p&gt;
&lt;p&gt;查看文件/目录所在组&lt;/p&gt;
&lt;p&gt;• 基本指令&lt;/p&gt;
&lt;p&gt;    ls –ahl&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt; 
&lt;p&gt;修改文件所在的组&lt;/p&gt;
&lt;p&gt;• 基本指令&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    chgrp 组名 文件名&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232138793-1463373898.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;其它组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。&lt;/p&gt;
&lt;/div&gt;


&lt;div readability=&quot;12&quot;&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;改变用户所在组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某&lt;/p&gt;
&lt;p&gt;个用户所在的组。&lt;/p&gt;
&lt;p&gt;改变用户所在组&lt;/p&gt;
&lt;p&gt;    1) usermod –g 组名 用户名&lt;/p&gt;
&lt;p&gt;    2) usermod –d 目录名 用户名 改变该用户登陆的初始目录。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232258679-1944269350.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 权限的基本介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232327914-1031158985.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;ls -l 中显示的内容如下：&lt;/p&gt;
&lt;p&gt;-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc&lt;/p&gt;
&lt;p&gt;0-9位说明&lt;/p&gt;
&lt;p&gt;1) 第0位确定文件类型(d, - , l , c , b)&lt;/p&gt;
&lt;p&gt;2) 第1-3位确定所有者（该文件的所有者）拥有该文件的权限。---User&lt;/p&gt;
&lt;p&gt;3) 第4-6位确定所属组（同用户组的）拥有该文件的权限，---Group&lt;/p&gt;
&lt;p&gt;4) 第7-9位确定其他用户拥有该文件的权限 ---Other&lt;/p&gt;
&lt;/div&gt;



&lt;div readability=&quot;24&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;rwx权限详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rwx作用到文件&lt;/p&gt;
&lt;p&gt;1) [ r ]代表可读(read): 可以读取,查看&lt;/p&gt;
&lt;p&gt;2) [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是&lt;/p&gt;
&lt;p&gt;对该文件所在的目录有写权限，才能删除该文件.&lt;/p&gt;
&lt;p&gt;3) [ x ]代表可执行(execute):可以被执行&lt;/p&gt;
&lt;p&gt;rwx作用到目录&lt;/p&gt;
&lt;p&gt;1) [ r ]代表可读(read): 可以读取，ls查看目录内容&lt;/p&gt;
&lt;p&gt;2) [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录&lt;/p&gt;
&lt;p&gt;3) [ x ]代表可执行(execute):可以进入该目录&lt;/p&gt;
&lt;/div&gt;


&lt;div readability=&quot;35&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;文件及目录权限实际案例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ls -l 中显示的内容如下：&lt;/p&gt;
&lt;p&gt;-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc&lt;/p&gt;
&lt;p&gt;10个字符确定不同用户能对文件干什么&lt;/p&gt;
&lt;p&gt;第一个字符代表文件类型： 文件 (-),目录(d),链接(l)&lt;/p&gt;
&lt;p&gt;其余字符每3个一组(rwx) 读(r) 写(w) 执行(x)&lt;/p&gt;
&lt;p&gt;第一组rwx : 文件拥有者的权限是读、写和执行&lt;/p&gt;
&lt;p&gt;第二组rw- : 与文件拥有者同一组的用户的权限是读、写但不能执行&lt;/p&gt;
&lt;p&gt;第三组r-- : 不与文件拥有者同组的其他用户的权限是读不能写和执行&lt;/p&gt;
&lt;p&gt;可用数字表示为: r=4,w=2,x=1 因此rwx=4+2+1=7&lt;/p&gt;
&lt;p&gt;1 文件：硬连接数或 目录：子目录数&lt;/p&gt;
&lt;p&gt;root 用户&lt;/p&gt;
&lt;p&gt;root 组&lt;/p&gt;
&lt;p&gt;1213 文件大小(字节)，如果是文件夹，显示 4096字节&lt;/p&gt;
&lt;p&gt;Feb 2 09:39 最后修改日期&lt;/p&gt;
&lt;p&gt;abc 文件名&lt;/p&gt;
&lt;/div&gt;



&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改权限&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本说明：&lt;/p&gt;
&lt;p&gt;    通过chmod指令，可以修改文件或者目录的权限。&lt;/p&gt;

&lt;p&gt;第一种方式：+ 、-、= 变更权限&lt;/p&gt;
&lt;p&gt;u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和)&lt;/p&gt;
&lt;p&gt;1) chmod u=rwx,g=rx,o=x 文件目录名&lt;/p&gt;
&lt;p&gt;2) chmod o+w 文件目录名&lt;/p&gt;
&lt;p&gt;3) chmod a-x 文件目录名&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232423621-1513714605.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232445032-1320747504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232449047-1529519826.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;第二种方式：通过数字变更权限&lt;/p&gt;
&lt;p&gt;r=4 w=2 x=1 rwx=4+2+1=7&lt;/p&gt;
&lt;p&gt;chmod u=rwx,g=rx,o=x 文件目录名&lt;/p&gt;
&lt;p&gt;相当于 chmod 751 文件目录名&lt;/p&gt;
&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt; 修改文件所有者-chown&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt; 
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p&gt;    chown newowner file 改变文件的所有者&lt;/p&gt;
&lt;p&gt;    chown newowner:newgroup file 改变用户的所有者和所有组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    -R 如果是目录 则使其下所有子文件或目录递归生效&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232539029-613489299.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232543694-168215623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改文件所在组-chgrp&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p&gt;    chgrp newgroup file 改变文件的所有组&lt;/p&gt;
&lt;p&gt;    -R 如果是目录 则使其下所有子文件或目录递归生效&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181126232620900-642353826.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

















</description>
<pubDate>Mon, 26 Nov 2018 15:27:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>Linux组基本 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件 有所有者、所在组、其它组的概念。 1) 所有者 2) 所在组 3) 其它组 4) 改变用户所在的组 文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10023825.html</dc:identifier>
</item>
<item>
<title>一个真正有能力的人 - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/10023789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/10023789.html</guid>
<description>&lt;p&gt;&lt;span&gt;“我要做我真正该做的事情”，我想这是普遍人的共性，有时候包括我自己。每个人都有一颗“英雄心”，想做真正高大尚的事情才能配得起自己（往往被自己高估）的身份。但是，他们不知道，一个人之所以有才，不只是因为他做了跟他才能匹配的事，很多时候可能只是做了跟他才能严重不匹配的事情。换个角度说，事情本身不代表才能，而是一个有才能的人把事情做得很有才能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201811/758472-20181126231905137-1738763576.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多时候，我经常收到一些类似于“这不是我该做的事情”的抱怨，但我只会反问一句“什么是你该做的事情？谁定义了这些事情的范围？”他们面对我的问题后通常会保持沉默，有的沉默是模糊的，有的沉默是反思的，有的沉默是不服的，所以我会继续跟他相互探讨，也有可能是我自己的想法有问题，我要把这种抱怨转化为相互探讨和驱动，因为我一直相信没有抱怨的团队是不健康的团队，就像不生病的人，不会有强大的免疫系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;曾经有位项目经理抱怨一直在做着不是项目经理该做的事情，言下之意感觉有点耽误了他做项目经理的才能。我用同样的问题反问他后，他保持了沉默，我看得出他多少还不接受，所以我继续跟他交流。每个人都有自己理想化的想法，理想化没有错，我们甚至可以把理想化作为目标去努力。但前提自己的理想化是否正确，是否自己思考的理性产物，还是别人或教科书的说教，就算是教科书的教条，那自身是否真正理解其核心思想又或者是否真正理解作者定义的背景，再者，作者是否一定正确。如果你经过了这些层面的思考，我很荣幸可以倾听你的想法和见解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;倾听了我的说辞后，他始终保持了沉默，但怨气明显减少，更多有点反思的味道。我继续说道，曾经有位项目经理跟我坦言过，他学习的那些知识都是证书都是套路，实践中60％以上几乎不可用。我想表达的不是否定这些知识，而是想提醒一下很多时候我们很容易陷入这种“理想状态”，其实说白了自身瓶颈的表现，不能让这种情绪所控制。有时候情绪不只是“感性”，他更多是“理性”的一面，因为它时刻提醒着我自身的问题，并驱动我更加理性。所以当我自己产生（任何）情绪的时候，我会给自己两分钟平复再做情绪的回播并用理性去分析我为什么会这样想，如果两分钟平复不了，给我自己一小时，一小时不行一天总该可以吧。为什么说冲动是魔鬼，理性即美德。所以，我们希望我们保持这种沟通，因为我也不确保我是正确的，我需要跟你这样的对话相互碰撞和反思，我们都能相互学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时此刻的他心情已经平复很多，更多是接受，我继续实话实说。其实，我觉得你现在做的都是项目经理的本职工作，虽然你可能觉得很繁琐，但我也看到了你持续的专业付出，并没有把抱怨投放在工作中，这是我最欣赏你的地方，所以我一直在学习你的这些优点。因为就是你持续了你的觉得配不上你工作的付出，所以项目得到了客户200％的赞赏和信任，并赢得了接下来的一系列机会，难道这不是项目经理的职责吗。此时此刻的他略显轻松并很好地交流了他在项目上其他的见解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这位项目经理是一个“脾气”相对暴躁的人，很容易发脾气，但他的项目管理能力很强，只不过每个人都会有自身不可见或不愿意待见的“短板”，作为同伴者，作为管理者，作为学习者，我跟他交流的这番言语同样是说给自己听的。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>“我要做我真正该做的事情”，我想这是普遍人的共性，有时候包括我自己。每个人都有一颗“英雄心”，想做真正高大尚的事情才能配得起自己（往往被自己高估）的身份。但是，他们不知道，一个人之所以有才，不只是因为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/10023789.html</dc:identifier>
</item>
<item>
<title>Extreme Drift赛车游戏C#源码详解（1） - 一清</title>
<link>http://www.cnblogs.com/xuyiqing/p/10022749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuyiqing/p/10022749.html</guid>
<description>&lt;p&gt;C#我只是一个&lt;span&gt;萌新&lt;/span&gt;，由于搞过Java，还是可以看懂C#的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偶然间&lt;/strong&gt;得到赛车游戏&lt;span&gt;Extreme Drift&lt;/span&gt;的源码&lt;/p&gt;
&lt;p&gt;接下来我会花一段时间来解读，这是一个我学习的过程，记录在博客&lt;/p&gt;
&lt;p&gt;等到我完全解读之后，我也许会考虑再加入联机功能等&lt;/p&gt;

&lt;p&gt;当然，这个游戏用的是&lt;strong&gt;Unity引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我先展示一下这个游戏的效果：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选车：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126202458363-726951310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后选图，进入比赛：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126202553027-1330927665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126202610046-1860703781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;WASD，SHIFT氮气，空格漂移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不得不说，车辆的手感非常不错！&lt;/p&gt;
&lt;p&gt;作为育碧的老玩家，讲真的，这个小游戏的手感比育碧的赛车手感好多了&lt;/p&gt;
&lt;p&gt;甚至就我感觉，车辆除了一些参数感觉需要调整，整体来看，手感和GTA5的感觉有点像&lt;/p&gt;

&lt;p&gt;不多说了，我打包出来一个Windows可运行的程序，双击就可以体验赛车游戏：&lt;/p&gt;

&lt;p&gt;链接：&lt;strong&gt;https://pan.baidu.com/s/1kF61eguRJf1Gd7aGn4w5jg&lt;/strong&gt;&lt;br/&gt;提取码：&lt;strong&gt;ks1l&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;源码的地址：花钱买的，免费分享了！&lt;/p&gt;

&lt;p&gt;链接：&lt;strong&gt;https://pan.baidu.com/s/1yiayLBXOBcSoJstHJQw33A&lt;/strong&gt;&lt;br/&gt;提取码：&lt;strong&gt;eyyq&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面正式开始查看源码：&lt;/p&gt;
&lt;p&gt;导入之后目录结构：并且会自动导入Unity自带资源ImageEffects&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126204100923-552797665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开Scenes的MainMenu场景，启动游戏：&lt;/p&gt;
&lt;p&gt;然而第一次启动在&lt;strong&gt;加载地图的时候&lt;/strong&gt;会报错，因为这一步：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    IEnumerator LoadLevelAsync()
    {

        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; WaitForSeconds(&lt;span&gt;0.4f&lt;/span&gt;&lt;span&gt;);
        sceneLoadingOperation &lt;/span&gt;= Application.LoadLevelAsync(currentLevelNumber + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        sceneLoadingOperation.allowSceneActivation &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!sceneLoadingOperation.isDone || sceneLoadingOperation.progress &amp;lt; &lt;span&gt;0.9f&lt;/span&gt;&lt;span&gt;)
        {
            menuLoadTime &lt;/span&gt;+=&lt;span&gt; Time.deltaTime;

            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里异步加载索引为currentLevelNumber+1的场景，然而，实际上不存在这个索引，所以，我们需要在&lt;strong&gt;Build Setting&lt;/strong&gt;设置好这些场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126204629534-859729092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在启动，就可以顺利游戏了！&lt;/p&gt;

&lt;p&gt;有六个场景，那么就先从主菜单MainMenu场景来看：&lt;/p&gt;
&lt;p&gt;负责UGUI的事件系统：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126205633390-164517356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Standalone Input Module:专为鼠标/键盘/控制器输入而设计：&lt;/p&gt;
&lt;p&gt;这里没有做什么多余操作，只是添加了这个组件，一个参数也没有改&lt;/p&gt;

&lt;p&gt;Touch Input Module：为触摸屏设备而设计，暂时与我无关&lt;/p&gt;

&lt;p&gt;接下来看UGUI部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312707/201811/1312707-20181126210735619-2132177179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个Canvas，里面有八个对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Top Panel是顶部的一个横条，右边有&lt;strong&gt;金币&lt;/strong&gt;和&lt;strong&gt;设置&lt;/strong&gt;选项&lt;/p&gt;
&lt;p&gt;观察金币，发现这只是一个简单的图片，而金币之内，包含GameScore对象，这个应该是处理金币的核心&lt;/p&gt;
&lt;p&gt;猜错了，观察GameScore对象发现，这也是一个简单的Text，那么金币相关功能应该是&lt;strong&gt;find&lt;/strong&gt;这个对象来处理的&lt;/p&gt;
&lt;p&gt;然后看设置，是一个Button，绑定了MainMenu里面的一个函数，而且播放点击声音，另外有一个Shadow组件：作用是给按钮添加阴影轮廓&lt;/p&gt;
&lt;p&gt;查看这个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SettingActive(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; activePanel)
    {
        menuPanels.Settings.gameObject.SetActive(activePanel);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，只是使另一个UI对象active，可以理解为：点击设置按钮后跳转到另一个页面&lt;/p&gt;

&lt;p&gt;MainMenu相当于是全屏幕，包含了左上的logo和底部的一个Panel：&lt;/p&gt;
&lt;p&gt;标题Tilt：一个简单的图片，在它下面的Image有点意思，是一个较亮的矩形，反复从右到左位移，配合Logo实现发光的效果&lt;/p&gt;
&lt;p&gt;实现机制：Image利用Aminator组件将自身和Tilt这个Logo绑定，实现循环动画&lt;/p&gt;
&lt;p&gt;然后就是底部的Panel，里面有四个对象，退出，资源，油管，选车进行下一步&lt;/p&gt;
&lt;p&gt;退出：绑定了Shadow、点击音效的一个按钮，以及一个MainMenu的函数：就是简单的退出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClickExitButton()
    {
        Application.Quit();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;资源和油管都是链接，本质一个按钮带Shadow和Audio，绑定OpenURL脚本的函数：传入URL，打开，简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OpenTab (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; URL) {
        Application.OpenURL(URL);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选车：一个简单的按钮，带Shadow，绑定MainMenu的一个函数：&lt;strong&gt;我在下面的注释中将会详细解释&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CurrentPanel(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; current)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里为什么要传一个INT呢？因为开头有定义
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public enum Panels { MainMenu = 0, SelectVehicle = 1, SelectLevel = 2, Settings = 3 }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;activePanel默认为0，这里传入的是1，就是选车&lt;/span&gt;
        activePanel =&lt;span&gt; (Panels)current;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;PlayerPrefs是数据持久化，从存档取出数据验证&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (currentVehicleNumber != PlayerPrefs.GetInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentVehicle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        {
            currentVehicleNumber &lt;/span&gt;= PlayerPrefs.GetInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentVehicle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环所有的车辆&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (VehicleSetting VSetting &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vehicleSetting)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前车激活状态，否则不激活&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (VSetting ==&lt;span&gt; vehicleSetting[currentVehicleNumber])
                {
                    VSetting.vehicle.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    currentVehicle &lt;/span&gt;=&lt;span&gt; VSetting;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    VSetting.vehicle.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传入值做一些操作&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (activePanel)
        {

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Panels.MainMenu:
                menuPanels.MainMenu.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectVehicle.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectLevel.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (menuGUI.wheelColor) menuGUI.wheelColor.gameObject.SetActive(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里传入的是1，进入选车&lt;/span&gt;
            &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Panels.SelectVehicle:
                menuPanels.MainMenu.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectVehicle.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectLevel.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Panels.SelectLevel:
                menuPanels.MainMenu.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectVehicle.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectLevel.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Panels.Settings:
                menuPanels.MainMenu.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectVehicle.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                menuPanels.SelectLevel.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;VehicleGarage：车库情景，下面有五个对象&lt;/p&gt;
&lt;p&gt;Top：顶部。左边一个logo：带有Outline的一个Text。中下是汽车的名字，也是一个Outline的Text&lt;/p&gt;
&lt;p&gt;然后是三个车辆性能信息，速度，刹车，氮气，都是简单的Text+Slider&lt;/p&gt;
&lt;p&gt;NextVehicle：绑定点击声音和MainMenu的一个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; NextVehicle()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (menuGUI.wheelColor) { menuGUI.wheelColor.gameObject.SetActive(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;); }

        currentVehicleNumber&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取模运算，防止越界&lt;/span&gt;
        currentVehicleNumber = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)Mathf.Repeat(currentVehicleNumber, vehicleSetting.Length);

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (VehicleSetting VSetting &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vehicleSetting)
        {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (VSetting ==&lt;span&gt; vehicleSetting[currentVehicleNumber])
            {
                VSetting.vehicle.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环到下一辆车赋值给当前&lt;/span&gt;
                currentVehicle =&lt;span&gt; VSetting;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                VSetting.vehicle.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PreviousVehicle是类似的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PreviousVehicle()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (menuGUI.wheelColor) { menuGUI.wheelColor.gameObject.SetActive(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;); }

        currentVehicleNumber&lt;/span&gt;--&lt;span&gt;;
        currentVehicleNumber &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)Mathf.Repeat(currentVehicleNumber, vehicleSetting.Length);

        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (VehicleSetting VSetting &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vehicleSetting)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (VSetting ==&lt;span&gt; vehicleSetting[currentVehicleNumber])
            {
                VSetting.vehicle.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                currentVehicle &lt;/span&gt;=&lt;span&gt; VSetting;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                VSetting.vehicle.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bottom下有四个对象：&lt;/p&gt;
&lt;p&gt;Back：一个按钮，返回上一场景，原理和上边的选车按钮一直，调用同一个函数&lt;/p&gt;
&lt;p&gt;Next：下一步地图选择页面，也和上面的原理一样，都是调用一个函数CurrentPanel&lt;/p&gt;
&lt;p&gt;CustomizeVehicle：自定义车辆，按钮绑定函数，点击后隐藏一些场景，开启自定义场景&lt;/p&gt;
&lt;p&gt;BuyNewVehicle：买车，默认是不激活的，点击后激活下一个对象BuyConfirm&lt;/p&gt;
&lt;p&gt;BuyConfirm：一个不激活的Panel，被激活后有两个选项，Yes的话掉MainMenu的函数，否则返回：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BuyVehicle()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;金币足够或者车辆未买才会执行&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((gameScore &amp;gt;= vehicleSetting[currentVehicleNumber].price) &amp;amp;&amp;amp; !&lt;span&gt;vehicleSetting[currentVehicleNumber].Bought)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据持久化&lt;/span&gt;
            PlayerPrefs.SetInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BoughtVehicle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentVehicleNumber.ToString(), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减钱&lt;/span&gt;
            gameScore -=&lt;span&gt; vehicleSetting[currentVehicleNumber].price;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止负数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (gameScore &amp;lt;= &lt;span&gt;0&lt;/span&gt;) { gameScore = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存金币数量&lt;/span&gt;
            PlayerPrefs.SetInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GameScore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, gameScore);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存车辆购买状态&lt;/span&gt;
            vehicleSetting[currentVehicleNumber].Bought = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            menuPanels.EnoughMoney.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CustomizeVehicle：自定义车辆，下面有三个对象&lt;/p&gt;
&lt;p&gt;Top:简单的一个顶部Logo，Colors里面有八个颜色对象，绑定了MainMenu的一个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ActiveCurrentColor(Image activeImage)
    {

        mainColor &lt;/span&gt;=&lt;span&gt; activeImage.color;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传参持久化数据&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (menuGUI.wheelColor.gameObject.activeSelf)
        {
            vehicleSetting[currentVehicleNumber].ringMat.SetColor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, mainColor);
            PlayerPrefsX.SetColor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VehicleWheelsColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; currentVehicleNumber, mainColor);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (menuGUI.smokeColor.gameObject.activeSelf)
        {
            vehicleSetting[currentVehicleNumber].smokeMat.SetColor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_TintColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Color(mainColor.r, mainColor.g, mainColor.b, &lt;span&gt;0.2f&lt;/span&gt;&lt;span&gt;));
            PlayerPrefsX.SetColor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VehicleSmokeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentVehicleNumber, &lt;span&gt;new&lt;/span&gt; Color(mainColor.r, mainColor.g, mainColor.b, &lt;span&gt;0.2f&lt;/span&gt;&lt;span&gt;));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bottom下面很多的对象，首先是一个返回，机制和函数上边提到了&lt;/p&gt;
&lt;p&gt;WheelColor、SmokeColor和RandomColor都是绑定MainMenu几个函数，这几个函数不难：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ActiveWheelColor(Image activeImage)
    {
        randomColorActive &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        activeImage.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        menuGUI.wheelColor &lt;/span&gt;=&lt;span&gt; activeImage;
        menuGUI.smokeColor.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ActiveSmokeColor(Image activeImage)
    {
        randomColorActive &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        activeImage.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        menuGUI.smokeColor &lt;/span&gt;=&lt;span&gt; activeImage;
        menuGUI.wheelColor.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RandomColor()
    {

        randomColorActive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

        menuGUI.wheelColor.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        menuGUI.smokeColor.gameObject.SetActive(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机数函数&lt;/span&gt;
        vehicleSetting[currentVehicleNumber].ringMat.SetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Color(Random.Range(&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.1f&lt;/span&gt;), Random.Range(&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.1f&lt;/span&gt;), Random.Range(&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.1f&lt;/span&gt;&lt;span&gt;)));
        vehicleSetting[currentVehicleNumber].smokeMat.SetColor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_TintColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Color(Random.Range(&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.1f&lt;/span&gt;), Random.Range(&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.1f&lt;/span&gt;), Random.Range(&lt;span&gt;0.0f&lt;/span&gt;, &lt;span&gt;1.1f&lt;/span&gt;), &lt;span&gt;0.2f&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持久化&lt;/span&gt;
        PlayerPrefsX.SetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VehicleWheelsColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentVehicleNumber, vehicleSetting[currentVehicleNumber].ringMat.GetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_Color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        PlayerPrefsX.SetColor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VehicleSmokeColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentVehicleNumber, vehicleSetting[currentVehicleNumber].smokeMat.GetColor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_TintColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是EnoughMoney，明天再看&lt;/p&gt;

</description>
<pubDate>Mon, 26 Nov 2018 15:06:00 +0000</pubDate>
<dc:creator>一清</dc:creator>
<og:description>C#我只是一个萌新，由于搞过Java，还是可以看懂C#的 偶然间得到赛车游戏Extreme Drift的源码 接下来我会花一段时间来解读，这是一个我学习的过程，记录在博客 等到我完全解读之后，我也许会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuyiqing/p/10022749.html</dc:identifier>
</item>
<item>
<title>线性筛素数 - 尹星寒</title>
<link>http://www.cnblogs.com/Yinxinghan/p/10023634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yinxinghan/p/10023634.html</guid>
<description>&lt;p&gt;转自我的博客，原文链接：http://blog.amaok.com/2018/prime_linear_sieve&lt;/p&gt;
&lt;p&gt;突然更新的学习笔记。&lt;/p&gt;
&lt;p&gt;最近做了一道在很大的范围里筛选出素数的神仙题，因为超时搞得很头疼，所以想来深入了解一下线性筛法，提高程序运行效率。&lt;/p&gt;
&lt;p&gt;我们常说的线性筛是指在线性时间内把素数表筛出来的过程，这里介绍两种筛法.&lt;/p&gt;
&lt;p&gt;一般筛法（埃拉托斯特尼筛法）：&lt;/p&gt;
&lt;p&gt;基本思想：素数的倍数一定不是素数&lt;/p&gt;
&lt;p&gt;实现方法：用一个长度为N+1的数组保存信息（0表示素数，1表示非素数），先假设所有的数都是素数（初始化为0），从第一个素数2开始，把2的倍数都标记为非素数（置为1），一直到大于N；然后进行下一趟，找到2后面的下一个素数3，进行同样的处理，直到最后，数组中依然为0的数即为素数。&lt;/p&gt;
&lt;p&gt;说明：整数1特殊处理即可。&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;p&gt;我们筛前20个数&lt;/p&gt;
&lt;p&gt;首先初始为（0代表不是素数，1代表是素数）&lt;/p&gt;
&lt;p&gt;0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1&lt;/p&gt;
&lt;p&gt;然后从2开始我们发现2被标记为素数，我们把2的倍数全部筛掉&lt;/p&gt;
&lt;p&gt;变为：&lt;/p&gt;
&lt;p&gt;0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0&lt;/p&gt;
&lt;p&gt;接着到3我们发现3仍然被标记，把3的倍数全部筛掉&lt;/p&gt;
&lt;p&gt;变为：&lt;/p&gt;
&lt;p&gt;0 1 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0&lt;/p&gt;
&lt;p&gt;接着一直重复下去就得到了最后的素数表：&lt;/p&gt;
&lt;p&gt;0 1 1 0 1 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 &lt;/p&gt;
&lt;p&gt;2 3 5 7 11 13 17 19&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXN = &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;；  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; get_list()  
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j;  
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;MAXN; i++) prime[i] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     prime[&lt;span&gt;0&lt;/span&gt;] = prime[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;2&lt;/span&gt;; i&amp;lt;MAXN; i++&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!prime[i]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (j=i*&lt;span&gt;2&lt;/span&gt;; j&amp;lt;MAXN; j+=i) prime[ j ] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调和级数证明可得复杂度为（nlglgn）,所以不能称之为线性筛，但是它的实际运行速度也不是特别慢&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们来介绍一波真正的线性筛（欧拉筛法）：&lt;/p&gt;
&lt;p&gt;我们发现在上面的筛法中有的数字是多个素数的倍数，也就是说它可能会被重复计算多次，比如说6同时是2与3的倍数，它在计算时就被访问了两次,这样会导致效率低下，所以在下面的算法中我们考虑如何优化这种情况。&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;任何一个合数都可以表示成一个质数和一个数的乘积&lt;/p&gt;
&lt;p&gt;假设A是一个合数，且A = x * y，这里x也是一个合数，那么有:&lt;/p&gt;
&lt;p&gt;A = x * y; (假设y是质数，x合数)&lt;/p&gt;
&lt;p&gt;x = a * b; (假设a是质数，且a &amp;lt; x——&amp;gt;&amp;gt;a&amp;lt;y) -&amp;gt; A = a b y = a Z (Z = b y)&lt;/p&gt;
&lt;p&gt;即一个合数(x)与一个质数(y)的乘积可以表示成一个更大的合数(Z)与一个更小的质数(a)的乘积，那样我们到每一个数，都处理一次，这样处理的次数是很少的，因此可以在线性时间内得到解。&lt;/p&gt;
&lt;p&gt;仍然按上面的例子模拟（这里0为是素数，1为非素数，p为记录的素数表）：&lt;/p&gt;
&lt;p&gt;初始：&lt;/p&gt;
&lt;p&gt;1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0&lt;/p&gt;
&lt;p&gt;p(empty)&lt;/p&gt;
&lt;p&gt;然后到2的位置，把2放入素数表,做当前范围内可以筛掉的处理（具体是怎样的看代码叭）：&lt;/p&gt;
&lt;p&gt;1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0&lt;/p&gt;
&lt;p&gt;p 2 到3，把3放入素数表，继续处理&lt;/p&gt;
&lt;p&gt;1 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0&lt;/p&gt;
&lt;p&gt;p 2 3 然后到了4，它不是个素数，也处理一下&lt;/p&gt;
&lt;p&gt;1 0 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0&lt;/p&gt;&lt;p&gt;p 2 3 .......&lt;/p&gt;
&lt;p&gt;然后一直搞下去，最后也能得到完整的素数表，这样虽然看起来复杂一些，但是实际上我们发现对于每个数的处理几乎是O(1)的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; get_list(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=maxn;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt;(!is_not_pr[i]) prime[++tot]=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;              &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=tot&amp;amp;&amp;amp;i*prime[j]&amp;lt;=maxn;j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                    is_not_pr[i*prime[j]]=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合数标为1，同时，prime[j]是合数i*prime[j]的最小素因子&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;                    &lt;span&gt;if&lt;/span&gt;(i%prime[j]==&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;即比一个合数大的质数和该合数的乘积可用一个更大的合数和比其小的质数相乘得到&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;             }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以说有了这两个东西后a掉那道题就很轻松了_(:зゝ∠)_&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 14:51:00 +0000</pubDate>
<dc:creator>尹星寒</dc:creator>
<og:description>转自我的博客，原文链接：http://blog.amaok.com/2018/prime_linear_sieve 突然更新的学习笔记。 最近做了一道在很大的范围里筛选出素数的神仙题，因为超时搞得很头</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yinxinghan/p/10023634.html</dc:identifier>
</item>
<item>
<title>003 ps的视图菜单 - 雪花飞旋</title>
<link>http://www.cnblogs.com/xuehuafeixuan/p/10023604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuehuafeixuan/p/10023604.html</guid>
<description>&lt;p&gt;　　每一次，都在徘徊中孤单，，，所以不徘徊，看是看不会的，动手起来。有句话就是，最好的时光是曾经，其次是现在。我感觉说错了 ，大概就是这个意思就行。&lt;/p&gt;
&lt;p&gt;　　好吧，今天开始视频教程的第二节，第一节应该是软件的下载和安装。这里复制上视频地址：&lt;a href=&quot;https://www.imooc.com/video/2149&quot; target=&quot;_blank&quot;&gt;https://www.imooc.com/video/2149&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　哎，刚想从桌面打开ps，发现没有，到开始菜单也没有找到，没办法，只好到安装目录下找了。我的安装在：D:\Program Files (x86)\photoshop\Adobe Photoshop CS4，里面有个蓝色的图标，就是它了。&lt;/p&gt;
&lt;p&gt;　　今天的内容是&lt;span&gt;视图菜单，小哥哥他首先是回顾上节内容，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下面就是新课了&lt;br/&gt;一、视图中的标尺&lt;/p&gt;
&lt;p&gt;  这个从字面意思上理解就行，相当于在图片四周放上刻度尺，反正觉得他在这里说得，，，他自己都乱了。标尺的作用就是，可以拉拉拉出横线，参考线的东东。画图的时候，为了把两件东西放得很平，就得用标尺，这个感觉像是个木匠。  当然，你对标尺呀，参考线呀，单位呀，不满意，直接双击两边的标尺，就是双击刻度尺就可以修改属性了。&lt;/p&gt;

&lt;p&gt;二、校样设置&lt;/p&gt;
&lt;p&gt;  这个词我也很陌生，大概意思是，打印机的，我指的是彩色打印机，别扯黑白的。就是说你图片的色彩特别多，可是打印机不一定能把全部色彩都打印出来，这有点像 ，你拍出来的照片很好看，美美哒，可是一冲洗就，，那个惨不忍睹。如果你在打印之前，用这个校样设置查看，就能看出打印出来后是什么样的。&lt;/p&gt;
&lt;p&gt;　　要说直观上有什么变化，就是点了这个，色彩没有那么鲜艳了。如果平常想去冲洗很好看的，请用高级打印机。&lt;/p&gt;
&lt;p&gt;三、图片放大缩小。&lt;/p&gt;
&lt;p&gt;　　在工具栏有个放大镜，点一下，在文件菜单下面有个选择放大或缩小的东西。其实我还是用得很少，要去找放大镜，我习惯用快捷键。&lt;span&gt;ctrl + +&lt;/span&gt;和 &lt;span&gt;Ctrl + -&lt;/span&gt;，也就是先按Ctrl不放，再按+号，就是放大，Ctrl不放，再按-号就缩小。&lt;/p&gt;
&lt;p&gt;　　如果觉得还不够方便，点击&lt;span&gt;“”窗口“”菜单&lt;/span&gt;，找到  &lt;span&gt;“ 导航器 ”&lt;/span&gt;，这个可好用了，能放大缩小，还能移动。&lt;/p&gt;

&lt;p&gt;四、工具窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055384/201811/1055384-20181126223612639-620670551.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　第一看到这个东西的，会感觉好多呀，密密麻麻的。其实我也很多掌握不了，知道有哪些分类就行，要用得时候去找一找&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　选择工具，这个经常用，就是选取所要操作的对象，你知道这个概念就行，后面会详细讲解&lt;/li&gt;
&lt;li&gt;绘制工具，说时候，我也不太会用，后面慢慢研究吧，我只要记住有这个分类，大概意思就是 铅笔呀，刷子之类的作用就行了&lt;/li&gt;
&lt;li&gt;矢量工具 ，我不会用，除非你已经是高手了&lt;/li&gt;
&lt;li&gt;查看工具，我会用放大镜放大图片查看，那个手手是用来抓图片的，体会体会，特别好用的。在使用过程中，估计用Ctrl + 空格，就是这个手抓饼了。  如果不习惯用放大镜，请把“”导航器“”打开，这个挺好用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;路子还长，要想自由，首先自己有能力。世间很多无奈的事情，很多无力的事情。但请别活在后悔的日子里，去做想做的事情，做爱想爱的人，去过想过的生活。有句话是什么，归来仍少年。&lt;/p&gt;

</description>
<pubDate>Mon, 26 Nov 2018 14:47:00 +0000</pubDate>
<dc:creator>雪花飞旋</dc:creator>
<og:description>每一次，都在徘徊中孤单，，，所以不徘徊，看是看不会的，动手起来。有句话就是，最好的时光是曾经，其次是现在。我感觉说错了 ，大概就是这个意思就行。 好吧，今天开始视频教程的第二节，第一节应该是软件的下载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuehuafeixuan/p/10023604.html</dc:identifier>
</item>
<item>
<title>Python 中的单例模式 - 皮皮虾打怪兽</title>
<link>http://www.cnblogs.com/new-rain/p/10023473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/new-rain/p/10023473.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.什么是单例模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。单例模式能控制一个类只能产生一个对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.为什么需要单例模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当每个实例都会占用资源，而且实例初始化会影响性能，这个时候就可以考虑使用单例模式，它给我们带来的好处是只有一个实例占用资源，并且只需初始化一次；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当有同步需要的时候，可以通过一个实例来进行同步控制，比如对某个共享文件（如日志文件）的控制，对计数器的同步控制等，这种情况下由于只有一个实例，所以不用担心同步问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.单例模式应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Python的logger就是一个单例模式，用以日志记录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Windows的资源管理器是一个单例模式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程池，数据库连接池等资源池一般也用单例模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网站计数器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;strong&gt;在 Python 中，实现单例模式的四种方式&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;使用模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;使用装饰器（decorator）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 __new__&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用元类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4.1 使用模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们真的想要一个单例类，可以考虑这样做：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mysingleton.py &lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; My_Singleton(object): 
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(self): 
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt; 
my_singleton &lt;/span&gt;= My_Singleton()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将上面的代码保存在文件 mysingleton.py 中，然后这样使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;from&lt;/span&gt; mysingleton &lt;span&gt;import&lt;/span&gt;&lt;span&gt; my_singleton
my_singleton.foo()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4.2 使用装饰器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    装饰器维护一个字典对象instances，缓存了所有单例类，只要单例不存在则创建，已经存在直接返回该实例对象。&lt;/p&gt;
&lt;p&gt;我们定义一个装饰器 singleton，它返回了一个内部函数 &lt;span&gt;wrapper&lt;/span&gt;，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，否则，直接返回 instances[cls]。&lt;/p&gt;

&lt;p&gt;使用装饰器实现单例模式的代码如下：&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; singleton(cls):
    instances &lt;/span&gt;=&lt;span&gt; {}

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cls &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; instances:
            instances[cls] &lt;/span&gt;= cls(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instances[cls]

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper


@singleton
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;26&quot;&gt;
&lt;p&gt;&lt;span&gt;4.3 使用__new__&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;__new__方法：  &lt;/strong&gt;&lt;/span&gt;__new__()方法用于定义创建对象时执行的操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;object类中的__new__()方法完成对象创建过程中的内存空间申请，对象属性初始化等一系列的操作。__new__是真正创建实例对象时用到的方法，所以重写基类的__new__方法，以此来保证创建对象的时候只生成一个实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意事项：    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.__new__()方法创建对象时自动运行。     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.覆盖object类中的__new__方法后创建对象    将执行覆盖后的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意事项：  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;__new__()方法仅仅是python开放出来给用户干预创建对象时的一个操作入口，该方法并不是直接完成分配内存、创建对象的操作，创建对象的操作由python底层统一管理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;使用__new__方法实现单例模式的代码如下：&lt;/p&gt;
&lt;div readability=&quot;19.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton(object):
    _instance &lt;/span&gt;=&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kw):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; cls._instance:
            cls._instance &lt;/span&gt;= super(Singleton, cls).&lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kw)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cls._instance

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass(Singleton):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

foo1 &lt;/span&gt;=&lt;span&gt; MyClass()
foo2 &lt;/span&gt;=&lt;span&gt; MyClass()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(foo1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(foo2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4.4 使用元类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;元类是用于创建类对象的类，类对象创建实例对象时一定会调用__call__方法，因此在调用__call__时候保证始终只创建一个实例即可，type是python中的一个元类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;元类（metaclass）可以控制类的创建过程，它主要做三件事：&lt;/p&gt;
&lt;p&gt;　　拦截类的创建&lt;/p&gt;
&lt;p&gt;　　修改类的定义&lt;/p&gt;
&lt;p&gt;　　返回修改后的类&lt;/p&gt;

&lt;p&gt;使用元类实现单例模式的代码如下：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton(type):
    _instances &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cls &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cls._instances:
            cls._instances[cls] &lt;/span&gt;= super(Singleton, cls).&lt;span&gt;__call__&lt;/span&gt;(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cls._instances[cls]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Python2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; class MyClass(object):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     __metaclass__ = Singleton&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Python3&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; MyClass(metaclass=&lt;span&gt;Singleton):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

foo1 &lt;/span&gt;=&lt;span&gt; MyClass()
foo2 &lt;/span&gt;=&lt;span&gt; MyClass()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(foo1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(foo2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 26 Nov 2018 14:27:00 +0000</pubDate>
<dc:creator>皮皮虾打怪兽</dc:creator>
<og:description>1.什么是单例模式 单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/new-rain/p/10023473.html</dc:identifier>
</item>
</channel>
</rss>