<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>lambda表达式&amp;方法引用 - 爱因斯坦&amp;霍金</title>
<link>http://www.cnblogs.com/xisuo/p/9705944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xisuo/p/9705944.html</guid>
<description>&lt;p data-source-line=&quot;131&quot;&gt;&lt;span&gt;本文将简单的介绍一下Lambda表达式和方法引用,这也是Java8的重要更新,Lambda表达式和方法引用最主要的功能是为流(专门负责迭代数据的集合)服务.&lt;/span&gt;&lt;/p&gt;

&lt;p data-source-line=&quot;136&quot;&gt;&lt;span&gt;可以把lambda表达式理解为简洁的匿名函数.&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;141&quot;&gt;&lt;span&gt;我们先声明一个函数式接口(函数式接口:就是只有一个抽象方法的接口. lambda表达式和方法引用,只能用在函数式接口上),比较一下lambda表达式和匿名函数&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;143&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cry();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String [] args){
                Animal dog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Animal() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cry() {
                        System.out.println(&lt;/span&gt;&quot;狗: 汪汪叫&quot;&lt;span&gt;);
                    }
                };

                dog.cry();
&lt;/span&gt;
                Animal cat  = () -&amp;gt; System.out.println(&quot;猫: 喵喵叫&quot;&lt;span&gt;);
                cat.cry();
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;143&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;143&quot;&gt;&lt;span&gt;一个Animal的接口,里面只有一个cry()的抽象方法, 分别用匿名函数和lambda表达式去实现这个接口. &lt;span&gt;使用lambda表达式的方法非常的简洁,只需要&lt;span&gt;一行.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;162&quot;&gt;&lt;span&gt;&lt;span&gt;lambda表达式语法&lt;/span&gt;: &lt;span&gt;参数 -&amp;gt; 具体的实现.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;162&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;164&quot;&gt;&lt;span&gt;函数式接口的方法叫做函数描述符,lambda表达式的参数和实现&lt;span&gt;必须&lt;/span&gt;和函数描述符的参数和返回值一一对应.cry()方法的参数和返回值都没有所以lambda表达式就是 &lt;/span&gt;&lt;span&gt;() -&amp;gt; System.out.println(&quot;猫: 喵喵叫&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;168&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;168&quot;&gt;&lt;span&gt;如果实现有多条语句的话,要写在{}中,并且以;结尾.&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;170&quot;&gt;() -&amp;gt; {&lt;/p&gt;
&lt;p data-source-line=&quot;172&quot;&gt;　　　　xxx;&lt;/p&gt;
&lt;p data-source-line=&quot;174&quot;&gt;　　　　yyy;&lt;/p&gt;
&lt;p data-source-line=&quot;176&quot;&gt;　　　　return &quot;ccc&quot;;&lt;/p&gt;
&lt;p data-source-line=&quot;178&quot;&gt;　　}&lt;/p&gt;
&lt;p data-source-line=&quot;183&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;183&quot;&gt;　　&lt;span&gt;列举一个高端一点的使用lambda表达式的方法.以Oracle的Emp(员工表)为例.&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;183&quot;&gt;&lt;span&gt;　　表结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Emp {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal empno;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ename;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String job;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal mgr;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date hiredate;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double sal;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal comm;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal deptno;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getEmpno() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; empno;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEmpno(BigDecimal empno) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.empno =&lt;span&gt; empno;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getEname() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ename;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEname(String ename) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ename = ename == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : ename.trim();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getJob() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; job;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setJob(String job) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.job = job == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : job.trim();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getMgr() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mgr;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMgr(BigDecimal mgr) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mgr =&lt;span&gt; mgr;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getHiredate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hiredate;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHiredate(Date hiredate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hiredate =&lt;span&gt; hiredate;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Double getSal() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sal;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSal(Double sal) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sal =&lt;span&gt; sal;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getComm() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; comm;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setComm(BigDecimal comm) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comm =&lt;span&gt; comm;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getDeptno() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deptno;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDeptno(BigDecimal deptno) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.deptno =&lt;span&gt; deptno;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;现在我们要写一个方法,过滤所有工资在3000以上的员工(可能有的人可能会想,我直接写sql不得了,费这么多劲干什么,所以我们以下的测试都假设数据是从redis查询出来的.需要手动写过滤条件)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Emp&amp;gt; filter(List&amp;lt;Emp&amp;gt;&lt;span&gt; listEmp){
        List&lt;/span&gt;&amp;lt;Emp&amp;gt; filterList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Emp emp :listEmp) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (emp.getSal()&amp;gt;3000&lt;span&gt;){
                filterList.add(emp);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filterList;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这么写的坏处是条件硬编码,如果光是改工资,我们可以把3000抽取为一个参数,但是如果要将条件改为小于呢,如果过滤的是员工的工作呢.&lt;span&gt;可能新手就会进行复制粘贴改一改条件&lt;/span&gt;,&lt;span&gt;但是当重复的代码达到一定的数量时,维护起来就是个&lt;/span&gt;&lt;span&gt;灾难.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;我们看看Java8提供的函数式编程,可以怎么解决这个方法.(当然使用匿名函数也可以,但是不够简洁).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把变化的的条件抽取出去,变为一个参数Predicate.具体的实现就是实现这个接口的test方法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Emp&amp;gt; filter1(List&amp;lt;Emp&amp;gt; listEmp, Predicate&amp;lt;Emp&amp;gt;&lt;span&gt; predicate){
        List&lt;/span&gt;&amp;lt;Emp&amp;gt; filterList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Emp emp :listEmp) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (predicate.test(emp)){
                filterList.add(emp);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filterList;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们利用了java.util.function这个包提供的Predicate接口.这就是一个标准的函数式接口&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;测试一下我们写的过滤方法,分别按照工资和工作名称进行过滤&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; List&amp;lt;Emp&amp;gt; filterSalEmp = empService.filter1(listEmp, Emp emp -&amp;gt; emp.getSal() &amp;gt; 3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;Emp&amp;gt; filterJobEmp = empService.filter1(listEmp, Emp emp -&amp;gt; &quot;SALMAN&quot;.equals(emp.getJob()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; Predicate接口的方法 boolean test(T t); 返回值是Boolean类型的,参数是任意类型   我们的实现 &lt;/span&gt;&lt;span&gt;Emp emp -&amp;gt; emp.getSal() &amp;gt; 3000 参数Emp ,返回Boolean类型的值 emp.getSal() &amp;gt; 3000  完全满足. &lt;span&gt;可以看到使用函数式接口编程提高了代码的灵活性和可重用性.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实lambda表达式的类型是可以从上下文中自己推断出来的,也就是说 上面的 lambda的参数  Emp emp  可以不带参数类型.写成下面这样&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; List&amp;lt;Emp&amp;gt; filterSalEmp = empService.filter1(listEmp, emp -&amp;gt; emp.getSal() &amp;gt; 3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;Emp&amp;gt; filterJobEmp = empService.filter1(listEmp, emp -&amp;gt; &quot;SALMAN&quot;.equals(emp.getJob()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;回到之前的例子:&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;String catCry = &quot;猫: 喵喵叫&quot;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Animal cat  = () -&amp;gt; System.out.println(catCry);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cat.cry();&lt;br/&gt;打印输出:&lt;/span&gt;&lt;span readability=&quot;4&quot;&gt;猫: 喵喵叫&lt;p&gt;lambda表达式可以使用局部变量,&lt;span&gt;但是必须是final类型的或事实上final类型的&lt;/span&gt;(不可改变).&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;lt;java8实战&amp;gt;&amp;gt;中的解释:&lt;/span&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第一，实例变量和局部变量背后的实现有一&lt;br/&gt;个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局&lt;br/&gt;部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线&lt;br/&gt;程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它&lt;br/&gt;的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了&lt;br/&gt;这个限制。&lt;br/&gt;第二，这一限制不鼓励你使用改变外部变量的典型命令式编程模式（我们会在以后的各章中&lt;br/&gt;解释，这种模式会阻碍很容易做到的并行处理）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;方法引用可以理解为lambda表达式的快捷写法,&lt;span&gt;它比lambda表达式更加的简洁,可读性更高.有更好的重用性.&lt;/span&gt;如果实现比较简单,一句话就可以实现,复用的地方又不多推荐使用lambda表达式,否则应该使用方法引用.  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法引用的格式  &lt;span&gt;类名::方法名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们使用方法引用的方式,重新实现上面刚刚过滤员工表的例子.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义两个条件类&lt;span&gt;,方法的参数和返回值定义的和predicate的函数名描述符一致&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmpConditionA {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(Emp emp) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; emp.getSal() &amp;gt; 3000&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;public class EmpConditionB{&lt;/span&gt;&lt;p&gt;&lt;span&gt;    public static boolean test(Emp emp) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        return &quot;engineer&quot;.equals(emp.getJob());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;实现方式: 使用类名::方法的方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;List&amp;lt;Emp&amp;gt; listEmp =&lt;span&gt; empService.listEmp();
List&lt;/span&gt;&amp;lt;Emp&amp;gt; filterSalEmp =&lt;span&gt; empService.filter1(listEmp, EmpConditionA::test);
List&lt;/span&gt;&amp;lt;Emp&amp;gt; filterJobEmp = empService.filter1(listEmp, EmpConditionB::test);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为这个方法调用的是第三方类的方法所以是&lt;span&gt;static&lt;/span&gt;的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还有两种调用方式: 一种是直接调用流中的实例的方式,还有一种是调用局部变量的方式.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接调用流中的实例的方式: 注意下面的Emp::getJob 就相当于集合中每一个emp对象都调用自己的getJob方法.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个例子是讲将集合转换为流,map()方法可以理解为对集合的每一个元素进行相应的操作,这里就是对每一个emp实例调用getJob方法.最后.collect(&lt;/span&gt;&lt;span&gt;Collectors.toList&lt;/span&gt;&lt;span&gt;())将流转换为新的list集合(关于流,笔者后面会继续更新相关的博客).&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;listEmp.stream().map(Emp::getJob).collect(Collectors.toList());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;调用局部变量的方式: 创建条件EmpconditionA的实例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EmpConditionA empConditionA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmpConditionA();
List&lt;/span&gt;&amp;lt;Emp&amp;gt; filterSalEmp = empService.filter1(listEmp, empConditionA::test);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 好了关于lambda表达式和方法引用就简单的介绍到这里,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;限于篇幅有些地方介绍的不是很详细,如果有疑问欢迎大家随时提问.&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 07:01:00 +0000</pubDate>
<dc:creator>爱因斯坦&amp;amp;霍金</dc:creator>
<og:description>本文将简单的介绍一下Lambda表达式和方法引用,这也是Java8的重要更新,Lambda表达式和方法引用最主要的功能是为流(专门负责迭代数据的集合)服务. 什么是lambda表达式 可以把lambd</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xisuo/p/9705944.html</dc:identifier>
</item>
<item>
<title>.Net版本依赖之坑引发的搜查 - 范存威</title>
<link>http://www.cnblogs.com/fancunwei/p/9706723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fancunwei/p/9706723.html</guid>
<description>&lt;p&gt;今天上午，一个客户反馈XX消息没有推送到第三方链接。于是我查看了推送日志列表，并没有今天的。接着登录服务器查询文件日志，看到了记录。我们的代码步骤是消息先推送到消息队列，消费消息队列时，记录文件日志，然后异步推送到第三方。&lt;/p&gt;

&lt;p&gt;经过一番寒彻骨的查询几个关键表，构造数据，并调试推送后，发现了问题源头，是Json版本依赖问题引发的坑，然后修改版本号发布解决了。下面让我们用一个简易的Demo重现下问题所在。&lt;/p&gt;

&lt;h2&gt;构建环境&lt;/h2&gt;
&lt;p&gt;首先新建基于.NetFrameWork 4.5.1版本的类库&lt;span&gt;ErrorSets.CommonE&lt;/span&gt;和控制台程序&lt;span&gt;ConsoleApp1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;341&quot; data-height=&quot;259&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7234228-a89dd699ac24236d.png&quot; width=&quot;341&quot; height=&quot;259&quot; format=&quot;image/png&quot; filesize=&quot;12309&quot; class=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;.Net FrameWork&lt;/p&gt;
&lt;/div&gt;
&lt;br/&gt;&lt;span&gt;然后&lt;/span&gt;&lt;span&gt;ErrorSets.CommonE&lt;/span&gt;&lt;span&gt;引入Newtonsoft.Json v11.0.2&lt;/span&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1097&quot; data-height=&quot;229&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7234228-44ea2827e2f1d60a.png&quot; width=&quot;1097&quot; height=&quot;229&quot; format=&quot;image/png&quot; filesize=&quot;38239&quot; class=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Newtonsoft.Json&lt;/p&gt;
&lt;/div&gt;
&lt;br/&gt;&lt;span&gt;然后模拟两个推送接口，一个是用Task包装的，一个是正常方法。&lt;/span&gt;

&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SeriEx&lt;/span&gt;
{&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;   public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TaskPostThird&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(object obj)&lt;/span&gt;
&lt;/span&gt;   {
      Task.Factory.StartNew(() =&amp;gt;
      {
       var data = JsonConvert.SerializeObject(obj);
       Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;TaskPostThird:{data}&quot;&lt;/span&gt;);
      });
   }
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;   public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PostThird&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(object obj)&lt;/span&gt;
&lt;/span&gt;   {
     var data = JsonConvert.SerializeObject(obj);
      Console.WriteLine($&lt;span class=&quot;hljs-string&quot;&gt;&quot;PostThird:{data}&quot;&lt;/span&gt;);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;ConsoleApp1&lt;/span&gt;引入Newtonsoft.Json v9.0.1&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1069&quot; data-height=&quot;246&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7234228-3b42a9f0a79cb26b.png&quot; width=&quot;1069&quot; height=&quot;246&quot; format=&quot;image/png&quot; filesize=&quot;61731&quot; class=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;br/&gt;&lt;span&gt;引入调用代码&lt;/span&gt;

&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; ConsoleApp1
{
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;  class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Program&lt;/span&gt;
  {&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;    static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;[] args)&lt;/span&gt;
&lt;/span&gt;    {
      var user = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; User() { Mobile = &lt;span class=&quot;hljs-string&quot;&gt;&quot;12546423&quot;&lt;/span&gt; };

      SeriEx.TaskPostThird(user);
      Console.WriteLine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;End&quot;&lt;/span&gt;);
      Console.ReadKey();
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;查看运行结果&lt;/h2&gt;
&lt;p&gt;当Main调用&lt;span&gt;SeriEx.TaskPostThird(user)&lt;/span&gt;时，结果令我们失望。既没有报错，也没有执行方法体内输出。&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;458&quot; data-height=&quot;251&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7234228-c2f90d0deedd5d12.png&quot; width=&quot;458&quot; height=&quot;251&quot; format=&quot;image/png&quot; filesize=&quot;5978&quot; class=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 26 Sep 2018 06:32:00 +0000</pubDate>
<dc:creator>范存威</dc:creator>
<og:description>前言 今天上午，一个客户反馈XX消息没有推送到第三方链接。于是我查看了推送日志列表，并没有今天的。接着登录服务器查询文件日志，看到了记录。我们的代码步骤是消息先推送到消息队列，消费消息队列时，记录文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fancunwei/p/9706723.html</dc:identifier>
</item>
<item>
<title>Word Embedding/RNN/LSTM - 侯凯</title>
<link>http://www.cnblogs.com/houkai/p/9706716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/houkai/p/9706716.html</guid>
<description>&lt;p&gt;Word Embedding是一种词的向量表示，比如，对于这样的“A B A C B F G”的一个序列，也许我们最后能得到：A对应的向量为[0.1 0.6 -0.5]，B对应的向量为[-0.2 0.9 0.7]。&lt;/p&gt;
&lt;p&gt;之所以希望把每个单词变成一个向量，目的还是为了方便计算，比如“求单词A的同义词”，就可以通过“求与单词A在cos距离下最相似的向量”来做到。&lt;/p&gt;
&lt;p&gt;那么如何进行词嵌入呢？目前主要有三种算法：&lt;/p&gt;
&lt;h2 id=&quot;embedding-layer&quot;&gt;Embedding Layer&lt;/h2&gt;
&lt;p&gt;Embedding Layer是与特定自然语言处理上的神经网络模型联合学习的单词嵌入。该嵌入方法将清理好的文本中的单词进行one hot编码（热编码），向量空间的大小或维度被指定为模型的一部分，例如50、100或300维。向量以小的随机数进行初始化。Embedding Layer用于神经网络的前端，并采用反向传播算法进行监督。&lt;/p&gt;
&lt;p&gt;被编码过的词映射成词向量，如果使用多层感知器模型MLP，则在将词向量输入到模型之前被级联。如果使用循环神经网络RNN，则可以将每个单词作为序列中的一个输入。&lt;/p&gt;
&lt;p&gt;这种学习嵌入层的方法需要大量的培训数据，可能很慢，但是可以学习训练出既针对特定文本数据又针对NLP的嵌入模型。&lt;/p&gt;
&lt;h2 id=&quot;word2vec-doc2vecdocument-to-vector&quot;&gt;Word2Vec/ Doc2Vec（Document to Vector）&lt;/h2&gt;
&lt;p&gt;Word2Vec是由Tomas Mikolov 等人在《Efficient Estimation of Word Representation in Vector Space》一文中提出，是一种用于有效学习从文本语料库嵌入的独立词语的统计方法。其核心思想就是基于上下文，先用向量代表各个词，然后通过一个预测目标函数学习这些向量的参数。&lt;/p&gt;
&lt;p&gt;该算法给出了两种训练模型，CBOW (Continuous Bag-of-Words Model) 和 Skip-gram (Continuous Skip-gram Model)。CBOW将一个词所在的上下文中的词作为输入，而那个词本身作为输出，也就是说，看到一个上下文，希望大概能猜出这个词和它的意思。通过在一个大的语料库训练，得到一个从输入层到隐含层的权重模型；而Skip-gram它的做法是，将一个词所在的上下文中的词作为输出，而那个词本身作为输入，也就是说，给出一个词，希望预测可能出现的上下文的词。&lt;/p&gt;
&lt;p&gt;通过在一个大的语料库训练，得到一个从输入层到隐含层的权重模型。给定xx预测xxx的模型的输入都是词的向量，然后通过中间各种深度学习DL的CNN或RNN模型预测下一个词的概率。通过优化目标函数，最后得到这些词汇向量的值。&lt;br/&gt;Word2Vec虽然取得了很好的效果，但模型上仍然存在明显的缺陷，比如没有考虑词序，再比如没有考虑全局的统计信息。&lt;/p&gt;
&lt;p&gt;Doc2Vec与Word2Vec的CBOW模型类似，也是基于上下文训练词向量，不同的是，Word2Vec只是简单地将一个单词转换为一个向量，而Doc2Vec不仅可以做到这一点，还可以将一个句子或是一个段落中的所有单词汇成一个向量，为了做到这一点，它只是将一个句子标签视为一个特殊的词。&lt;/p&gt;
&lt;h2 id=&quot;主题模型&quot;&gt;主题模型&lt;/h2&gt;
&lt;p&gt;LSA、LDA等主题模型，建立词和主题的关系。&lt;/p&gt;

&lt;p&gt;循环神经网络，是非线性动态系统，将序列映射到序列，主要参数有五个：$[W_{hv}, W_{hh}, W_{oh}, b_h, b_o, h_0] $，典型的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/rnn.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和普通神经网络一样，RNN有输入层输出层和隐含层，不一样的是RNN在不同的时间t会有不同的状态，其中t-1时刻隐含层的输出会作用到t时刻的隐含层.&lt;/li&gt;
&lt;li&gt;参数意义是: &lt;span class=&quot;math inline&quot;&gt;\(W_{hv}\)&lt;/span&gt;:输入层到隐含层的权重参数，&lt;span class=&quot;math inline&quot;&gt;\(W_{hh}\)&lt;/span&gt;:隐含层到隐含层的权重参数，&lt;span class=&quot;math inline&quot;&gt;\(W_{oh}\)&lt;/span&gt;：隐含层到输出层的权重参数，&lt;span class=&quot;math inline&quot;&gt;\(b_h\)&lt;/span&gt;:隐含层的偏移量,&lt;span class=&quot;math inline&quot;&gt;\(b_o\)&lt;/span&gt;输出层的偏移量，&lt;span class=&quot;math inline&quot;&gt;\(h_0\)&lt;/span&gt;:起始状态的隐含层的输出，一般初始为0.&lt;/li&gt;
&lt;li&gt;不同时间的状态共享相同的权重w和偏移量b&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;rnn的计算方式&quot;&gt;RNN的计算方式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/rnncc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给定一个损失函数 &lt;span class=&quot;math inline&quot;&gt;\(L(z,y) = \sum_{t=1}^T{L(z_t, y_t)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RNN因为加入了时间序列，因此训练过程也是和之前的网络不一样，RNN的训练使用的是BPTT(Back Prropagation Through TIme),该方法是由Werbo等人在1990年提出来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/rnnbp.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的算法也就是求解梯度的过程，使用的也是经典的BP算法，并没有什么新鲜的。但是值得一提的是，在 t-1 时刻对 &lt;span class=&quot;math inline&quot;&gt;\(h_{t−1}\)&lt;/span&gt;的求导值，也需加上t时刻的求导中对&lt;span class=&quot;math inline&quot;&gt;\(h_{t−1}\)&lt;/span&gt; 的求导值，因此BPTT也是一个链式的求导过程。&lt;/p&gt;
&lt;p&gt;但是因为上面算法中的第10行，在训练t时刻的时候，出现了t-1的参数，因此对单个的求导就变成了对整个之前状态的求导之和。&lt;/p&gt;
&lt;p&gt;也正是因为存在长依赖关系，BPTT无法解决长时依赖问题(即当前的输出与前面很长的一段序列有关，一般超过十步就无能为力了)，因为BPTT会带来所谓的梯度消失或梯度爆炸问题(the vanishing/exploding gradient problem)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/&quot;&gt;这篇文章&lt;/a&gt;很好的解释了为什么会产生梯度消失和为什么会梯度爆炸的问题，其实主要问题就是因为在BPTT算法中，以w为例，其求导过程的链太长，而太长的求导链在以tanh为激活函数（其求导值在0~1之间的BPTT中，连乘就会使得最终的求导为0，这就是梯度消失问题，也就是t时刻已经学习不到t-N时刻的参数了。当然，有很多方法去解决这个问题，如LSTMs便是专门应对这种问题的，还有一些方法，比如设计一个更好的初始参数以及更换激活函数（如换成ReLU激活函数）。&lt;/p&gt;
&lt;h2 id=&quot;参数量&quot;&gt;参数量&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;model.add(Embedding(output_dim=32, input_dim=2800, input_length=380))
model.add(SimpleRNN(units=16))
model.add(Dense(uints=256, activation=relu))
...
model.summary()
#output
simple_rnn_1 (SimpleRNN) param # 784
dense_1 (Dense) param # 4352&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：784=16+16&lt;em&gt;16+16&lt;/em&gt;32（ &lt;span class=&quot;math inline&quot;&gt;\(W_{hv}\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(W_{hh}\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(b_h\)&lt;/span&gt;）&lt;/p&gt;

&lt;p&gt;假设我们试着去预测“I grew up in France... I speak fluent French”最后的词。当前的信息建议下一个词可能是一种语言的名字，但是如果我们需要弄清楚是什么语言，我们是需要先前提到的离当前位置很远的 France的上下文的。这说明相关信息和当前预测位置之间的间隔就肯定变得相当的大。&lt;/p&gt;
&lt;p&gt;不幸的是，在这个间隔不断增大时，RNN会丧失学习到连接如此远的信息的能力。在理论上，RNN绝对可以处理&quot;长期依赖&quot;问题。人们可以仔细挑选参数来解决这类问题中的最初级形式，但在实践中，RNN 肯定不能够成功学习到这些知识。Bengio, et al.等人对该问题进行了深入的研究，他们发现一些使训练 RNN 变得非常困难的根本原因。&lt;/p&gt;
&lt;p&gt;然而，幸运的是，LSTM 并没有这个问题！&lt;/p&gt;
&lt;p&gt;LSTM 由Hochreiter &amp;amp; Schmidhuber (1997)提出，并在近期被Alex Graves进行了改良和推广。在很多问题，LSTM 都取得相当巨大的成功，并得到了广泛的使用。&lt;/p&gt;
&lt;p&gt;LSTM 通过刻意的设计来避免长期依赖问题。记住长期的信息在实践中是 LSTM 的默认行为，而非需要付出很大代价才能获得的能力！&lt;/p&gt;
&lt;p&gt;所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/simple%20rnn.webp-ss.jpg&quot;/&gt;&lt;br/&gt;LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于单一神经网络层，以一种非常特殊的方式进行交互。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/lstm%204.webp-ss.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心思想&quot;&gt;核心思想&lt;/h2&gt;
&lt;p&gt;LSTM 中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过一个称为忘记门层完成。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/lstm%20yiwang.webp-ss.jpg&quot;/&gt;&lt;br/&gt;下一步是确定什么样的新信息被存放在细胞状态中。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/lstm%20update.webp-ss.jpg&quot;/&gt;&lt;br/&gt;我们把旧状态与 &lt;span class=&quot;math inline&quot;&gt;\(f_t\)&lt;/span&gt; 相乘，丢弃掉我们确定需要丢弃的信息。接着加上 &lt;span class=&quot;math inline&quot;&gt;\(i_t * \tilde{C}_t\)&lt;/span&gt;。这就是新的候选值，根据我们决定更新每个状态的程度进行变化。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/lstm%20update2.webp-ss.jpg&quot;/&gt;&lt;br/&gt;最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态，但是也是一个过滤后的版本。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/lstm%20out.webp-ss.jpg&quot;/&gt;&lt;br/&gt;我们到目前为止都还在介绍正常的 LSTM。但是不是所有的 LSTM 都长成一个样子的。实际上，几乎所有包含 LSTM 的论文都采用了微小的变体。&lt;/p&gt;
&lt;p&gt;图中最上面的一条线的状态即 s(t) 代表了长时记忆，而下面的 h(t)则代表了工作记忆或短时记忆。&lt;/p&gt;
&lt;h2 id=&quot;参数量-1&quot;&gt;参数量&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;model.add(Embedding(output_dim=32, input_dim=2800, input_length=380))
model.add(LSTM(32))
model.add(Dense(uints=256, activation=relu))
...
model.summary()
#output
lstm_1 (LSTM) param # 8320&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：8320=(32+32)&lt;em&gt;32&lt;/em&gt;4+4*32（ &lt;span class=&quot;math inline&quot;&gt;\(W_o\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(W_C\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(W_i\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(W_f\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(b_o\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(b_C\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(b_i\)&lt;/span&gt; + &lt;span class=&quot;math inline&quot;&gt;\(b_f\)&lt;/span&gt;）。&lt;/p&gt;

&lt;p&gt;LSTM有很多变体，其中较大改动的是Gated Recurrent Unit (GRU)，这是由 Cho, et al. (2014)提出。它将忘记门和输入门合成了一个单一的 更新门。同样还混合了细胞状态和隐藏状态，和其他一些改动。最终的模型比标准的 LSTM模型要简单。效果和LSTM差不多，但是参数少了1/3，不容易过拟合。&lt;br/&gt;&lt;img src=&quot;http://par9irpgu.bkt.clouddn.com/gru.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot;&gt;理解 LSTM 网络&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 06:31:00 +0000</pubDate>
<dc:creator>侯凯</dc:creator>
<og:description>Embedding Layer是与特定自然语言处理上的神经网络模型联合学习的单词嵌入。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/houkai/p/9706716.html</dc:identifier>
</item>
<item>
<title>Keepalived详解之 - LVS(IPVS)管理工具ipvsadm使用指南 - icebug</title>
<link>http://www.cnblogs.com/dspace/p/9706436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dspace/p/9706436.html</guid>
<description>&lt;h4 id=&quot;ipvsadm是什么&quot;&gt;ipvsadm是什么?&lt;/h4&gt;
&lt;p&gt;ipvsadm是用来配置、维护或者查看Linux内核当中virtual server table的一个工具, LVS(Linux virtual server)能基于一个集群当中的两个或者多个节点来创建弹性网络服务, 集群中的处于激活状态的节点能将服务请求重定向到一组实际提供服务的主机当中, 提供包括TCP和UDP两种协议, 三种数据包转发模式(NAT / tunneling / direct routing), 和八种负载均衡算法(round robin, weighted round robin, least-connection, weighted least-connection, locality-based least-connection, locality-based least-connection with replication, destination-hashing, and source-hashing).&lt;/p&gt;
&lt;h4 id=&quot;使用方式&quot;&gt;使用方式&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ipvsadm提供两种基本的使用格式, 中括号表示可选, 两种命令格式分别对应virtual server和real server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;ipvsadm COMMOND [protocol] service-address [scheduling-method] [persistence options]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ipvsadm command [protocol] service-address server-address [packet-forwarding-method] [weight options]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一种命令格式用于配置虚拟服务(virtual service)和用于分配服务请求到真实服务器的算法, 另外一个可选项为用于持久化服务的持久化超时时间和网络掩码.&lt;/p&gt;
&lt;p&gt;第二种命令格式用于配置与一个已经存在的虚拟服务器相关联的真实服务器, 当指定一个真实服务器时, 数据包转发方式和该真实服务器相对于该虚拟服务器下面的其他真实服务器的权重需要指定, 否则会采用默认值.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装ipvsadm&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-40-96 ~]# yum instal -y ipvsadm&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;命令参数说明&quot;&gt;命令参数说明&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;惯例是大写表示用于virtual server, 小写表示用于real server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;   -A, --add-service 添加virtual server, virtual server必须唯一(IP+端口+协议用于区分一个唯一的虚拟服务)

   -E, --edit-service 编辑虚拟服务

   -D, --delete-service 删除一个虚拟服务, 包括与之关联的真实服务器

   -C, --clear 清空虚拟服务表

   -R, --restore 通过标准输入恢复虚拟服务表(IPVS table)

   -S, --save 以可以通过-R参数恢复的格式导出虚拟服务表到标准输出

   -a, --add-server 添加一个真实服务器到一个虚拟服务

   -e, --edit-server 在一个虚拟服务当中编辑一个真实服务器

   -d, --delete-server 从一个虚拟服务当中移除一个真实服务器

   -L, -l, --list 列出虚拟服务表, 默认是列出所有虚拟服务表, 若需要列出某服务表, 后面指定服务地址即可

   -Z, --zero 清零一个所有服务的数据包 / 字节 / 速率计数器
      &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看IPVS&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 10.10.88.188:7480 wlc persistent 1800
  -&amp;gt; 172.16.130.20:7480 Masq 1 0 0
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;保存IPVS&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;默认是输出到标准输出, 可以重定向到文本保存, 方便后期再导入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -S -n
-A -t 10.10.88.188:7480 -s wlc -p 1800
-a -t 10.10.88.188:7480 -r 172.16.130.20:7480 -m -w 1
[root@10-10-88-192 ~]# ipvsadm -S -n &amp;gt; ipvs_info
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;清空IPVS&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -C
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;恢复(restore)IPVS&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意: 默认是从标准输入进行恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# cat ipvs_info | ipvsadm -R
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 10.10.88.188:7480 wlc persistent 1800
  -&amp;gt; 172.16.130.20:7480 Masq 1 0 0
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;移除一个real server&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -d -t 10.10.88.188:7480 -r 172.16.130.20:7480
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 10.10.88.188:7480 wlc persistent 1800
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;注: 移除real server之后会先将destination(endpoint)移到trash(暂存垃圾桶), 过一段时间再删除, 若这个期间这个real server又可以访问了则会从trash中拿回来继续用, 具体说明见IPVS源码注释&lt;code&gt;https://elixir.bootlin.com/linux/v3.0/source/net/netfilter/ipvs/ip_vs_ctl.c&lt;/code&gt;, 下面为打开IPVS debug模式(debug_level=8)后&lt;code&gt;dmesg -Hew&lt;/code&gt;的输出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;[Sep26 11:08] IPVS: Enter: ip_vs_del_dest, net/netfilter/ipvs/ip_vs_ctl.c line 1079
[ +0.000007] IPVS: Moving dest 172.16.130.20:7480 into trash, dest-&amp;gt;refcnt=1
[ +0.000002] IPVS: Leave: ip_vs_del_dest, net/netfilter/ipvs/ip_vs_ctl.c line 1101
[ +11.076403] IPVS: Removing destination 0/172.16.130.20:7480 from trash&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;添加一个real server&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -a -t 10.10.88.188:7480 -r 172.16.130.22:7480 -m
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 10.10.88.188:7480 wlc persistent 1800
  -&amp;gt; 172.16.130.22:7480 Masq 1 0 0
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;添加一个virtual server&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -A -t 10.10.88.189:7480 -s wlc -p 1800
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 10.10.88.188:7480 wlc persistent 1800
  -&amp;gt; 172.16.130.22:7480 Masq 1 0 0
TCP 10.10.88.189:7480 wlc persistent 1800
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;移除一个virtual server&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -D -t 10.10.88.189:7480
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
TCP 10.10.88.188:7480 wlc persistent 1800
  -&amp;gt; 172.16.130.22:7480 Masq 1 0 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果直接移除virtual server的话, 若有real server, real server也会一并移除掉&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@10-10-88-192 ~]# ipvsadm -D -t 10.10.88.188:7480
[root@10-10-88-192 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port Forward Weight ActiveConn InActConn
[root@10-10-88-192 ~]#&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 26 Sep 2018 05:43:00 +0000</pubDate>
<dc:creator>icebug</dc:creator>
<og:description>ipvsadm是什么? ipvsadm是用来配置、维护或者查看Linux内核当中virtual server table的一个工具, LVS(Linux virtual server)能基于一个集群当</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dspace/p/9706436.html</dc:identifier>
</item>
<item>
<title>Docker系列之入门篇 - 潇十一郎</title>
<link>http://www.cnblogs.com/zhangxiaoyong/p/9706392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoyong/p/9706392.html</guid>
<description>&lt;h2&gt;认识容器&lt;/h2&gt;
&lt;p&gt;有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效、轻量、自给自足，还能保证部署在任何环境中的软件都能始终如一地运行。&lt;/p&gt;
&lt;p&gt;以上是官方的解释。嗯，看完是不是仍然一脸懵逼，不要紧，我们先看来一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926124327729-67879826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;推荐 先记忆 后理解，记忆什么？Docker组成的三个基本概念：&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;镜像 (Image）：Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926124417280-1916243767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926124532390-1059284122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;容器(Container)：容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926124151593-1930625206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926124553157-1642226443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仓库(Repository):如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。&lt;/p&gt;
&lt;p&gt;Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。&lt;/p&gt;
&lt;p&gt;仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 我们来看一下Docker的生命周期：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926124739216-484615525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，容器是由镜像实例化而来的，这和我们学习的面向对象的概念十分相似，我们可以把&lt;code&gt;镜像&lt;/code&gt;想象成&lt;code&gt;类&lt;/code&gt;,把&lt;code&gt;容器&lt;/code&gt;想象成类经过实例化后的&lt;code&gt;对象&lt;/code&gt;，先有了&quot;镜像类&quot;,然后可以实例化多个不同的容器1，容器2、容器3......，这样就非常好理解镜像和容器的关系了。&lt;/p&gt;

&lt;h2&gt; CentOS安装&lt;/h2&gt;
&lt;p&gt;⑴卸载旧版本(较旧版本的Docker被称为&lt;code&gt;docker&lt;/code&gt;或&lt;code&gt;docker-engine&lt;/code&gt;。如果已安装这些，请卸载它们以及相关的依赖项。)&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ sudo yum remove docker \
                  docker&lt;/span&gt;-&lt;span&gt;client \
                  docker&lt;/span&gt;-client-&lt;span&gt;latest \
                  docker&lt;/span&gt;-&lt;span&gt;common \
                  docker&lt;/span&gt;-&lt;span&gt;latest \
                  docker&lt;/span&gt;-latest-&lt;span&gt;logrotate \
                  docker&lt;/span&gt;-&lt;span&gt;logrotate \
                  docker&lt;/span&gt;-&lt;span&gt;selinux \
                  docker&lt;/span&gt;-engine-&lt;span&gt;selinux \
                  docker&lt;/span&gt;-engine
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;已安装docker，会进行删除操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926125927129-107936720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑵安装docker -ce(社区免费版)&lt;/p&gt;
&lt;p&gt;安装方式，使用存储库安装，在新主机上首次安装Docker CE之前，需要设置Docker存储库。之后，可以从存储库安装和更新Docker。&lt;/p&gt;
&lt;p&gt;安装所需的包。&lt;code&gt;yum-utils&lt;/code&gt;提供了&lt;code&gt;yum-config-manager&lt;/code&gt; 效用，并&lt;code&gt;device-mapper-persistent-data&lt;/code&gt;和&lt;code&gt;lvm2&lt;/code&gt;由需要 &lt;code&gt;devicemapper&lt;/code&gt;存储驱动程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo yum install -y yum-&lt;span&gt;utils \
  device&lt;/span&gt;-mapper-persistent-&lt;span&gt;data \
  lvm2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926131846602-744938428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;⑶使用以下命令设置稳定存储库。即使还想从边缘或测试存储库安装构建，始终需要稳定的存储 库&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo yum-config-&lt;span&gt;manager \
    &lt;/span&gt;--add-&lt;span&gt;repo \
    https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132019138-606823150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑷可选：启用边缘和测试存储库。这些存储库包含在&lt;code&gt;docker.repo&lt;/code&gt;上面的文件中，但默认情况下处于禁用状态。可以将它们与稳定存储库一起启用。&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$ sudo yum-config-manager --enable docker-ce-&lt;span&gt;edge

$ sudo yum&lt;/span&gt;-config-manager --enable docker-ce-&lt;span&gt;test

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;您可以通过运行带有标志的命令来禁用边缘或测试存储库 。要重新启用它，请使用该标志。以下命令禁用边缘存储库。yum-config-manager--disable--enable&lt;/span&gt;
&lt;span&gt;
$ sudo yum&lt;/span&gt;-config-manager --disable docker-ce-&lt;span&gt;edge

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：从Docker 17.06开始，稳定版本也会被推送到边缘并测试存储库。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132230229-1905627355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑸安装最新版本的Docker CE&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo yum install docker-ce
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132330276-2118765653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132540381-1303064357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;⑹启动Docker&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo systemctl start docker
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;⑺&lt;code&gt;docker&lt;/code&gt;通过运行&lt;code&gt;hello-world&lt;/code&gt; 映像验证是否已正确安装&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ sudo docker run hello-world
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132731479-1517029694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，docker在CentOS上的安装已经全部完成，我们可以查看下当前安装的docker版本信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132828491-805699624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Windows安装&lt;/h2&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot; target=&quot;_blank&quot;&gt;https://docs.docker.com/docker-for-windows/install/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132947184-219072949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926132959573-876932708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201809/762349-20180926133007713-141464936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　未完待续。。。docker全套VIP课程资源可以加入.NET全栈开发群 免费获取，群号：523490820&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 05:33:00 +0000</pubDate>
<dc:creator>潇十一郎</dc:creator>
<og:description>Dcoker是什么？ 概述 Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。运维人员利用 Docker 可以在隔离容器中并行运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoyong/p/9706392.html</dc:identifier>
</item>
<item>
<title>.NETCore 基于 dbfirst 体验快速开发项目 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/9706082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/9706082.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;今天出场是进化了多年的生成器工具，根据数据库结构（表、视图、存储过程、外键、各种类型、备注）快速生成一个项目，并自带后台管理系统。篇幅有限本文只讲解快速开发的使用过程，具体开发中的细节日后有空再详解。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet tool install genmy -g //根据mysql库生成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet tool install genms -g //根据sqlserver库生成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet tool install genpg -g //根据sqlserver库生成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dotnet tool是2.0增加的功能，类似 npm install -g，检查是否安装成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201809/31407-20180926113435527-277384574.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用假设使用-mysql-数据库作为生成对象&quot;&gt;使用(假设使用 mysql 数据库作为生成对象)&lt;/h2&gt;
&lt;h3 id=&quot;查看帮助&quot;&gt;查看帮助&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;genmy --help&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201809/31407-20180926113750708-1676186591.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mysql数据库&quot;&gt;mysql数据库&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201809/31407-20180926113940660-1002209582.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成代码&quot;&gt;生成代码&lt;/h3&gt;
&lt;p&gt;1、在桌面新建目录：dbfirst&lt;/p&gt;
&lt;p&gt;2、打开 dbfirst 目录，进入 cmd&lt;/p&gt;
&lt;p&gt;3、执行命令： genmy 127.0.0.1:3306 -U root -P root -D cccddd -N cd -R -A -S&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如无意外，项目生成完毕，如下图：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201809/31407-20180926114408978-602482807.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行代码&quot;&gt;运行代码&lt;/h3&gt;
&lt;p&gt;打开浏览器，访问 &lt;a href=&quot;http://localhost:5000&quot; class=&quot;uri&quot;&gt;http://localhost:5000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201809/31407-20180926115851032-1709022591.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这篇文章只用于演示降低使用门槛，作者重点关注数据库一块的开发，提高生产效率。欢迎有想法的小伙伴试用，讨论发表建议。&lt;/p&gt;
&lt;p&gt;目前支持三种数据库快速开发，postgresql、mysql、sqlserver。&lt;/p&gt;
&lt;p&gt;他们的开源地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/2881099/dotnetGen_postgresql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/dotnetGen_postgresql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/2881099/dotnetGen_mysql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/dotnetGen_mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/2881099/dotnetGen_sqlserver&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/dotnetGen_sqlserver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢支持开源的你们，谢谢观赏！！&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 03:54:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>简介 今天出场是进化了多年的生成器工具，根据数据库结构（表、视图、存储过程、外键、各种类型、备注）快速生成一个项目，并自带后台管理系统。篇幅有限本文只讲解快速开发的使用过程，具体开发中的细节日后有空再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/9706082.html</dc:identifier>
</item>
<item>
<title>云开发初探 —— 更简便的小程序开发模式 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9705948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9705948.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.875&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/1011618?fromSource=waitui&quot;&gt;李成熙heyli&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/5014?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;李成熙，腾讯云高级工程师。2014年度毕业加入腾讯AlloyTeam，先后负责过QQ群、花样直播、腾讯文档等项目。2018年加入腾讯云云开发团队。专注于性能优化、工程化和小程序服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/z5ckm906ul.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/yitwr1vpcy.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小程序诞生以来，业界关注小程序前端的技术演进较多，因此众多小程序前端的框架、工具也应运而生，前端开发效率大大提高，而后台的开发技术则关注不多，痛点不少，具体痛在哪里呢？&lt;/p&gt;
&lt;h2 id=&quot;小程序后台开发之痛&quot;&gt;小程序后台开发之痛&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/4a38coxge0.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个是脑袋瓜疼，怎么疼呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/6y1z6tu2q5.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着像腾讯云等的云服务商提供的云服务越来越便捷，业务上云已经是大势所趋。但是从简单地在云虚拟机上部署页面，到实现真正全面地上云，还是有很多区别。要真正实现全面的上云，要了解的东西非常多，当你第一次接触这些概念的时候，学的这些东西是一个接一个，让你应接不暇，往往分散了你的对业务的专注力。比如我自己，来腾讯云之后，为了对云服务有更好地了解，就去报了个腾讯云的课程。这课程系列分云架构师、云开发、云运维三门课程，还分初级、中级、高级，需要花费大量时间才能理清这些知识概念，并且还要花大量的时间去上机做实验。所以对于开发来说，要彻底搞清楚，还真的不是件容易事，绝对让你的脑袋疼。&lt;/p&gt;
&lt;p&gt;第二是肉疼，尤其是你老板肉疼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/ex6b3pdyty.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最开始当互联网还没有云服务商的时候，公司都得自己搭服务，不仅花大价钱买机器、买宽带流量，还得请人过来维护。如果在这种情况下要搞小程序开发，公司得请一个维护服务器硬件的、一个维护网络的，一个数据工程师，一个后台还有一个前端，刚好五个人。当云服务商开始进入变革整个市场的时候，我们就不用再自己维护硬件了，由云服务商来维护，因此我们可以少请一个维护硬件的，但还是得有一个运维去维护云服务。当云服务商将数据库、容器服务都抽象出来上云之后，咱们连专业的数据库维护都可以不请了，由后台或者云维兼岗就行。云服务商的不断发展，确实是让云服务的成本不断下降，但投入的钱还是很多呀，要投入的人还是不少，这几年生意难做，作为老板肯定是想投入成本、试错成本越少越好。&lt;/p&gt;
&lt;p&gt;第三个是肾疼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/ox5afhr57o.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家都知道，开发是一个走肾的工作。比如，这些年流行的前后端分离，虽然让专人专项，但却引入了联调这个事，所以也增加了肾的负担。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/mwig47wzfe.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里列出了三个前后端分离带来的麻烦。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;权责往往不清晰，有很多临界的位置，谁管都可以，容易引发扯皮。&lt;/li&gt;
&lt;li&gt;沟通时间增多，因为毕竟是两个人工作嘛，需要不少的沟通&lt;/li&gt;
&lt;li&gt;除了沟通，还需要两边的代码调试，看看数据、展示通不通，这个时间也很不可控，尤其是如果环境特别复杂，调起来不仅麻烦重重，还很有挫败感。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;无服务开发小程序是未来趋势&quot;&gt;无服务开发小程序是未来趋势&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/iv6r2omykw.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正因为小程序后台开发的麻烦重重，因此业内都想出了各种各样的开发方案，其中一种方案，“无服务开发小程序”，我们认为，将会是未来的趋势。但这个未来，其实今天已经到来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/z2vq1li9q0.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那什么是无服务开发呢？无服务，又称为 &lt;code&gt;Serverless&lt;/code&gt;。&lt;code&gt;Serverless&lt;/code&gt; 还处在一个比较初期的阶段，目前也没有权威和官方的定义，不同人不同公司有不同说法，今天我也不打算讲太复杂。顾名思义， &lt;code&gt;Serverless&lt;/code&gt; 就是指应用的开发不再需要考虑服务器这样的硬件基础设施，基于 &lt;code&gt;Serverless&lt;/code&gt; 架构的应用主要依赖于像腾讯云这样的云服务商提供的后台服务。比如说无服务云函数、云数据库、对象存储服务等等。简单来说，相当于你现在要开个水果店卖水果，以前你还得要租店面，搞水电、装修门面。现在这些都不用了，你就在一个已经搭好各种各样设施的超市里，租一个已经帮你搞好门面的架子或者箱子，卖得好你就租大一点，卖不好就租小一点，随时随地随你的心意，非常灵活。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/wvh133abw4.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么说无服务化开发是趋势呢？因为云服务的进程，已经从物理机，演进到 &lt;code&gt;IAAS&lt;/code&gt;，再到 &lt;code&gt;PAAS&lt;/code&gt;。&lt;code&gt;IAAS&lt;/code&gt; 就是包括像云虚拟机、私有网络、网络专线、负载均衡等等的基础服务；&lt;code&gt;PAAS&lt;/code&gt; 则更抽象一些，比如像云数据库、网络防护等等。基于 &lt;code&gt;IAAS&lt;/code&gt;、&lt;code&gt;PAAS&lt;/code&gt;，云服务商发展出 &lt;code&gt;Serverless&lt;/code&gt; 这类更高级的开发服务。因此呢，无服务开发就会是今后开发类似小程序这类轻量应用的新的开发趋势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/n5d0b408mr.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一句话概括就是说，有了无服务开发之后，你就不用再处理安装、运维，底层了，只管写接口、写逻辑就好。总得来说，虽然你管的东西越来越少，但开发效率却越来越高，开发出来的轻应用、小程序却是具备高性能、高可用、高扩展的特性。&lt;/p&gt;
&lt;p&gt;那无服务开发，具体怎么去解决刚刚提到的后台开发痛点呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/6b2k22w7f2.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一是让你更加关注你的业务逻辑。云服务许多好用但难理解的概念，什么冷备热备、弹性伸缩、负载均衡等等，通通都不用管，你只需要写好你的业务，服务好用户就行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/5azcdbjhbq.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二，更省人力更省资金，老板不再肉疼。因为有了无服务开发，运维工作也不用操心了，像小程序这类的轻应用，有一个全栈开发，或者一个前端，半个后台就可以轻松应付了，资金和人力的需求可谓大大节省。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/il4tyfbiab.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三，就是前端工程师向全栈工程师的转变。有了无服务开发，前端工程师其实也可以安全、高性能地去操作一些以前只有后台才敢操作的数据和逻辑，如果要开发的应用是像小程序一样轻量的、简单的，完全可以由前端工程师完成，除非是特别复杂的，可能才需要后台的介入。这样也省缺了先前提到的前后端联调的麻烦。&lt;/p&gt;
&lt;h2 id=&quot;小程序云开发&quot;&gt;小程序·云开发&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/wfjz8l84fn.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说了这么多无服务开发的概念、优点，在小程序无服务开发这一块，腾讯云有什么样的作品呢。这就是今天要重点介绍的，小程序·云开发，这就是腾讯云与微信联合研发后，交出的答卷。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/j21mk1dvg9.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;云开发，一共提供了三大能力，分别是存储、数据库、云函数。简而言之，就是提供了存文件、存数据和运行业务逻辑的能力。接下来，我会采取前后对比的方式，从方方面面去对比云开发和旧有的开发模式的不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/eznbwb7qca.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;旧开发模式&lt;/p&gt;
&lt;p&gt;首先是开发模式与架构上的对比。在云开发模式出来之前，旧的小程序后台开发模式就是上面这幅图，在小程序端发请求，往往你得引入额外封装好的 &lt;code&gt;SDK&lt;/code&gt;，然后你需要在云服务这边配置大量的运维产品才能做出性能、可用性非常好的产品。开发者要关心的内容，从前端、后台一直关心到运维这块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/zvtgo551dt.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云开发模式&lt;/p&gt;
&lt;p&gt;而云开发的全新模式，只要调用小程序原生的接口，就可以操作最基本的三大资源，而云开发背后又有腾讯云的基础服务作为支撑，本身就高可用、高性能、可扩展，你要关心的事情是大大减少了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/v5f6kifkgb.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;腾讯云控制台&lt;/p&gt;
&lt;p&gt;其次是资源管理平台的对比。以前你需要管理云资源，你需要在腾讯云的面板里，几十上百的产品里找到你需要的产品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/enh797f60s.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云开发控制台&lt;/p&gt;
&lt;p&gt;而云开发呢，你在小程序开发工具里，就可以找到云开发的控制面板入口。进入后，我们将你要关注的产品，做成一个独立面板供你使用，极为简洁方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/upimiguv5y.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;旧开发模式-上传文件&lt;/p&gt;
&lt;p&gt;第三，我们对比一下在小程序端调用资源。以上传文件为例，旧的开发模式，小程序端，你需要用 &lt;code&gt;wx.chooseImage&lt;/code&gt; 还有 &lt;code&gt;wx.uploadFile&lt;/code&gt; 小程序接口，后台要部署业务框架、路由，还有写逻辑上传到腾讯云的对象存储，你还要考虑这个后台服务的性能与安全，万一用户量峰值很大怎么办，有黑客攻击怎么办。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/uizcdjxvis.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云开发模式-上传文件&lt;/p&gt;
&lt;p&gt;而云开发的例子，则极为简单，十几行代码，就可以写出安全、性能好的代码上传逻辑！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/85kp0k5w0b.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设开发者是一个菜鸟，只懂 &lt;code&gt;JavaScript&lt;/code&gt; 基础，对比下来，传统的开发模式，前端耗时2分钟开发，1小时联调，后台框架、逻辑和联调一共8小时，运维，要花一整天时间去学，总共要花1142分钟，对比只要写2分钟就能完成的云开发模式，足足是云开发耗时的571倍！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/mkzeuiohub.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;旧开发模式-插入数据&lt;/p&gt;
&lt;p&gt;最后，我们来对比在服务端里插入数据。这里的服务端里指的包括有云函数、还有你自己买的服务器。旧模式下，小程序端要用一个 &lt;code&gt;wx.request&lt;/code&gt; 发送请求到后台，后台搭建好框架、路由等服务之后，开始写插入数据到腾讯云MongoDB实例的逻辑，自然也是需要考虑服务的性能与安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/iwaf2k35ss.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;云开发模式-插入数据&lt;/p&gt;
&lt;p&gt;而云开发的新模式，十几行代码，就可以开发出性能好、安全性高的插入数据逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/hrapkr1tpx.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设开发者是一个菜鸟，对比下来，传统的开发模式，前端要花31分钟进行开发与联调，后台要用6小时部署服务开发逻辑还要30分钟联调，而运维的话从学习到会用大概也得10小时，基本上是云开发模式耗时的1000多倍。&lt;/p&gt;
&lt;p&gt;从代码、耗时等多个方面去对比新旧两种开发模式，我们可以发现，云开发是绝对的碾压。&lt;/p&gt;
&lt;h2 id=&quot;小程序云开发背后的技术力量&quot;&gt;小程序·云开发背后的技术力量&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/pgmd2kdccn.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家现在知道了无服务开发是未来的开发新趋势，带有无服务特性的小程序云开发带来的各种各样的好处，那么腾讯云在背后，做了些什么技术进行支撑呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/pqo9dme07t.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;架构上，一个请求操作从小程序端，通过微信后台，一直到腾讯云这边的云开发服务层，云开发服务层调用的这些数据库、存储、云函数，其实都是基于腾讯云的各种基础服务。在这个请求通路上面，微信会将小程序的用户 &lt;code&gt;openid&lt;/code&gt;， 小程序 &lt;code&gt;appid&lt;/code&gt; 直接带过来，将用户的信息写到云函数、数据和文件元信息里面，为更方便的权限控制打下基础。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/k89qbs467k.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，既然是复用了腾讯云的基础资源，那自然是具备了云资源的特性。比如存储自动接入了 &lt;code&gt;CDN&lt;/code&gt; 加速, 数据库天然就带有自动备份、无损恢复等功能，云函数有弹性伸缩、多地可用的特性，能响应峰值不同的服务。而云开发服务层，我们也做了负载均衡、并且与微信后台进行就近接入，让性能更好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/hkz86bd5m8.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前云开发正式上线5天（注：9月10日深夜发布，掘金技术大会是在9月16日），我们的服务所支撑的 &lt;code&gt;API&lt;/code&gt; 日调用量最大的单个小程序，已经达到 &lt;code&gt;1000W+&lt;/code&gt; 的调用量了，这个调用量是什么概念呢？一般只有BAT，一些高频使用的独角兽开发的小程序才能达到这个调用量级。因此90%以上的小程序用我们这个服务都是没有问题的。&lt;/p&gt;
&lt;h2 id=&quot;推荐实践&quot;&gt;推荐实践&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/cpn2goqw6x.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲一项技术，除了讲功能、讲底层，其实更重要地说讲怎么去用这门技术去实践。接下来，我会介绍一些我们推荐的实践方式，但我只会是点到为止，我们其实更希望社区能基于云开发，做出更多更好的实践。&lt;/p&gt;
&lt;p&gt;第一点是资源操作的推荐实践。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/qovq3lxcjs.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;小程序端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/hpjtjoqz5h.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;服务端&lt;/p&gt;
&lt;p&gt;在小程序端操作资源方面，我们是使用小程序的原生接口进行操作，而在小程序端操作资源，由于安全的考虑问题，基本上操作存储、数据库等的资源只能写用户自己的数据，而读数据则根据规则来判断是否有权限。在服务端操作资源方面，我们使用 &lt;code&gt;wx-server-sdk&lt;/code&gt; 或者 &lt;code&gt;tcb-admin-node&lt;/code&gt; 来处理，前者是基于后者的能力进行了封装。在服务端使用这两个 &lt;code&gt;SDK&lt;/code&gt; 去操作资源，所拥有的权限是管理级的，就是意味着可以操作一切的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/trwmoun7zp.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边的图是数据库的权限控制，右边的图是存储的权限控制。这两个控制面板都有各自不同权限的一些推荐的使用场景，大家可以打开控制去读下面每个权限的灰色的解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/9eyyxd2f1n.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/ga2ej2igbh.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二点，是数据库的推荐实践。这里以腾讯乘车码为例，像这种交通的小程序，可能会面对弱网或者无网的情况，开发初期为了省事，将大量的配置信息都写在小程序端中。但随着向更多城市的推进，配置文件越来越大，小程序的包体积越来越大。正好这个时候云开发推出了，腾讯乘车码就采用云开发的数据库，将一些不一定要在离线环境使用的配置迁移到云开发，另外还采用云开发的存储服务来存放静态资源。这就大大压缩了乘车码小程序的体积，为其它新增功能腾挪了空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/orlqrkgw97.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三点，推荐使用云开发的存储存放小程序中所需要的静态资源。因为云开发的存储天然自带 &lt;code&gt;CDN&lt;/code&gt; 加速。比如在控制面版的存储中，文件的详情里获取的下载地址，就是 &lt;code&gt;CDN&lt;/code&gt; 已经加速的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/uefnjehy6b.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四点，是云函数的使用。目前云函数暂时不支持过于耗时、太复杂的操作，目前的超时时间为20s，函数包大小控制在20M左右。但其实这也已经能满足超过80%的需求，随着服务的逐步稳定，我们会考虑将这些限制进一步放宽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/4ypdleryte.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;云函数另一种用法就是，我们可以将相同的一些操作，比如用户管理、支付逻辑，按照业务的相似性，归类到一个云函数里，这样比较方便管理、排查问题以及逻辑的共享。甚至如果你的小程序的后台逻辑不复杂，请求量不是特别大，完全可以在云函数里面做一个单一的微服务，根据路由来处理任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/rdef4ndpws.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如这里就是传统的云函数用法，一个云函数处理一个任务，高度解耦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/dp4mts7n9e.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二幅架构图就是尝试将请求归类，一个云函数处理某一类的请求，比如有专门负责处理用户的，或者专门处理支付的云函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/4775ja12zs.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一幅图显示这里只有一个云函数，云函数里有一个分派任务的路由管理，将不同的任务分配给不同的本地函数处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/zt92vtcusx.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/uiur5xo5p7.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;云函数还有一种用法就是，可以作为中间路由，然后将 &lt;code&gt;appid&lt;/code&gt;, &lt;code&gt;openid&lt;/code&gt;，转发给原有的服务。这里以腾讯相册为例。具体怎么操作呢。比如腾讯相册之前将评论功能接入了云开发，但一些敏感操作，像删除、编辑评论，这个请求发送到云函数，然后云函数会将用户信息转发给相册原本的后台，然后再将该用户是否有权限返回来告诉云函数，如果有权限，就在云函数里删除评论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1011618/19pgy04kfd.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，如果你们想在云函数调用 &lt;code&gt;AI&lt;/code&gt; 服务，还有一些微信相关的操作，可以使用我封装的这两个 &lt;code&gt;SDK&lt;/code&gt;。第一个 &lt;a href=&quot;https://github.com/TencentCloudBase/image-node-sdk&quot;&gt;image-node-sdk&lt;/a&gt; 覆盖面比较全，覆盖了全部的腾讯云智能图像服务，下面的 &lt;a href=&quot;https://github.com/lcxfs1991/wx-js-utils&quot;&gt;wx-js-utils&lt;/a&gt;,也提供了微信支付、模板消息、用户信息获取等几个常用的接口。&lt;/p&gt;
&lt;p&gt;可以关注我的微博或者 &lt;code&gt;Github&lt;/code&gt; 获取最新云开发的资讯或者技术资料。&lt;/p&gt;
&lt;blockquote readability=&quot;0.42424242424242&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/87304?fromSource=waitui&quot;&gt;腾讯云是如何解决小程序开发的难题？&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1194659?fromSource=waitui&quot;&gt;小程序·云开发 项目开发经验分享&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1341928?fromSource=waitui&quot;&gt;小程序的全栈开发新时代&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1193232?fromSource=waitui&quot;&gt;微信“小程序云”（云开发）简介与初体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1128?fromSource=waitui&quot;&gt;【每日课程推荐】机器学习实战！快速入门在线广告业务及CTR相应知识&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1345700?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 03:33:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9705948.html</dc:identifier>
</item>
<item>
<title>脚手架vue-cli系列一：安装与规范 - 敲代码的小老头</title>
<link>http://www.cnblogs.com/yinn/p/9705857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yinn/p/9705857.html</guid>
<description>&lt;p&gt;我很喜欢Vue的一个重要原因就是因为它的vue-cli，这个工具可以让一个简单的命令行工具来帮助我快速地构建一个足以支撑实际项目开发的Vue环境，并不像Angular和React那样要在Yoman上找适合自己的第三方脚手架。vue-cli的存在将项目环境的初始化工作与复杂度降到了最低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.安装vue-cli&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vue-cli是一个npm的安装包，我们希望它能在本机的任意目录下创建项目，那么就得将它安装到node.js的全局运行目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 $ npm i vue-cli -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功后，我们就可以使用vue-cli来初始化Vue项目了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.使用vue-cli初始化项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vue-cli是一个很简单的指令，先打开它的帮助文件看看它的具体用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
  用法: vue &amp;lt;命令&amp;gt; [选项]

      命令:

         init         从指定模板中生成一个新的项目
         list         列出所有的可用的官方模板
         help [cmd]   显示所有[cmd]（命令）的帮助

      选项:

         -h, --help       输出用法信息
         -V, --version    输出版本号
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先用list指令来看看有哪些官方模板可用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
$ vue list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235070/201809/1235070-20180926112708165-176726299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些官方模板存在的意义在于提供强大的项目构建能力，用户可以尽可能快地进行开发。然而能否真正地发挥作用还在于用户如何组织代码和使用的其他库。&lt;/p&gt;
&lt;p&gt;将list指令的输出结果翻译一下，就可以清楚地了解这些官方模板应用于哪些使用场景：&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　browserify——拥有高级功能的Browserify + vueify用于正式开发；&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　browserify-simple——拥有基础功能的Browserify + vueify用于快速原型开发；&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●   pwa ——基于webpack模板的VUE CLI 渐进式网页应用模板&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　simple——适用于单页应用开发的最小化配置；&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　webpack——拥有高级功能的webpack + vue-loader用于正式开发；&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　webpack-simple——拥有基础功能的webpack + vue-loader用于快速原型开发。&lt;/p&gt;
&lt;p&gt;browserify的模板做得比较简陋，就算是用于正式开发还是会有些不足，配置的是Karma+Jasmine的单元测试框架，而browserify属于比较老旧的构建工具，估计官方提供这两个模板页是出于对经常使用browserify的开发人员提供一个熟悉环境的考虑。到了正式的项目开发时，我们还是会走上webpack的道路。&lt;/p&gt;
&lt;p&gt;所以我建议初学者可以跳过browserify的两个模板，直接使用webpack的两个模板。首先webpack-simple正如其名，配置了最简单的可直接支持ES6的Vue.js编译环境，可以应对那些要求时间短，结构相对简单的小型应用。如果对所有环境工具都非常熟悉，开发者也可以由这个模板入手，为项目底板定制更适应自身开发要求的环境。&lt;/p&gt;
&lt;p&gt;其次，webpack模板是一个非常赞的脚手架，将其分析透彻之后，就会知道Vue的官方开发团队在其中花了很大的功夫，将上文所叙述的开发、测试与生产环境做了非常完善的配置，从最大程度上简化了由于工具而引入项目的复杂度，也降低了开发人员对工具的学习成本，这个模板也将是本书中讲述的重点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来先看看这个vue-cli如何为我们创建项目。创建项目使用的是init命令，它会为我们自动创建一个新的文件夹，并将所需的文件、目录、配置和依赖都准备好，具体做法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
$ vue init webpack my-project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;init命令执行后会出一系列的交互式问题让我们选择，运行结果如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1235070/201809/1235070-20180926112913561-594039403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成以后直接按提示进入项目，安装npm的依赖包后就可以开始开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.深入vue-cli的工程模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vue-cli提供的脚手架只是一个最基础的，也可以说是Vue团队认为的工程结构的一种最佳实践。对于初学者或者以前曾从事AngularJS/React开发的用户来说，可能对开发环境有自已习惯性用法和熟悉的工具，但我建议用Vue来开发的话还是先按照官方推荐的来做，待我们掌握了Vue官方推荐的环境配置后再按照实际情况进行相应的调整，这样会少走一些弯路，节省不少时间。&lt;/p&gt;
&lt;p&gt;我们下面要讨论的工程结构都是围绕webpack-simple与webpack展开的，browserify也只是在这两个模板的基础上移植的一个版本，所以就不过多地赘述。&lt;/p&gt;
&lt;p&gt;webpack和webpack-simple这两个模板从文件结构上看几乎是一致的，只是一个是简化版，另一个是完全版。其实不然，webpack-simple是基于Webpack@2.1.0-beta.25进行配置的版本，而webpack模板则是基于Webpack ^1.3.2配置的。这两个版本暂时是互相不兼容的，而且使用的依赖包的版本也不一样，所以不要将webpack模板创建的项目文件结构复制到webpack-simple中进行直接的取代升级，而是需要将node_modules内安装的所有的依赖包删除，然后重新安装才有可能迁移成功，这一点是需要注意的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.webpack-simple模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下为webpack-simple模板构建的项目的工程目录结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
    ├── README.md
    ├── index.html
    ├── package.json
    ├── src
    │    ├── App.vue
    │    ├── assets
    │    │    └── logo.png
    │    └── main.js
    └── webpack.config.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 6.规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;webpack-simple只配置了Babel和Vue的编译器，其他的一无所有。这个模板值得一提的就是src目录，所有的Vue代码源程序都放置在这个目录中，五个模板构建出来的这个src目录都是一样的，只是在webpack模板中多了components目录用于存放公用组件。这个目录的结构与文件的组织应在开发前就进行约定，对于多人协作式项目，目录的使用与文件的命名都显得尤为重要。&lt;/p&gt;
&lt;p&gt;具体约定如下：&lt;/p&gt;
&lt;p&gt;（1）公共组件、指令、过滤器（多于三个文件以上的引用）将分别存放于src目录下的&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　components；&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　directives；&lt;/p&gt;
&lt;p class=&quot;kindle-cn-para-hang1&quot;&gt;●　filters。&lt;/p&gt;
&lt;p&gt;（2）以使用场景命名Vue的页面文件。&lt;/p&gt;
&lt;p&gt;（3）当页面文件具有私有组件、指令和过滤器时，则建立一个与页面同名的目录，页面文件更名为index.vue，将页面与相关的依赖文件放在一起。&lt;/p&gt;
&lt;p&gt;（4）目录由全小写的名词、动名词或分词命名，由两个以上的词组成，以“-”进行分隔。&lt;/p&gt;
&lt;p&gt;（5）Vue文件统一以大驼峰命名法命名，仅入口文件index.vue采用小写。&lt;/p&gt;
&lt;p&gt;（6）测试文件一律以测试目标文件名.spec.js命名。&lt;/p&gt;
&lt;p&gt;（7）资源文件一律以小写字符命名，由两个以上的词组成，以“-”进行分隔。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
    src
    ├── README.md
    ├── assets                 // 全局资源目录
    │    ├── images           // 图片
    │    ├── less             // less 样式表
    │    ├── css              // CSS 样式表
    │    └── fonts            // 自定义字体文件
    ├── components             // 公共组件目录
    │    ├── ImageInput.vue
    │    ├── Slider.vue
    │    └── ...
    ├── directives.js          // 公共指令
    ├── filters.js             // 公共过滤器
    ├── login                  // 场景：登录
    │    ├── index.vue        // 入口文件
    │    ├── LoginForm.vue    // 登录场景私有表单组件
    │    └── SocialLogin.vue
    ├── cart
    │    ├── index.vue
    │    ├── ItemList.vue
    │    └── CheckoutForm.vue
    ├── Discover.vue           // 场景入口文件
    ├── App.vue                // 默认程序入口
    └── main.js
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 26 Sep 2018 03:20:00 +0000</pubDate>
<dc:creator>敲代码的小老头</dc:creator>
<og:description>我很喜欢Vue的一个重要原因就是因为它的vue-cli，这个工具可以让一个简单的命令行工具来帮助我快速地构建一个足以支撑实际项目开发的Vue环境，并不像Angular和React那样要在Yoman上找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yinn/p/9705857.html</dc:identifier>
</item>
<item>
<title>周大侠啊 进击的 JavaScript（一） 之 类型转换 - 周大侠啊</title>
<link>http://www.cnblogs.com/zhoudaxiaa/p/9705675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoudaxiaa/p/9705675.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://zhoudaxiaa.com/?p=127&quot;&gt;周大侠啊 进击的 JavaScript（一） 之 类型转换&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说起-js-类型转换都是头疼吧晕晕的但是不行啊这东西很重要滴&quot;&gt;说起 js 类型转换，都是头疼吧，晕晕的，但是不行啊，这东西很重要滴！&lt;/h3&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JavaScript的数据类型分为六种，分别为null, undefined, boolean, string, number, object。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;object是引用类型，包含数组，其它的五种是基本类型或者是原始类型(原始值)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以用typeof方法打印来某个是属于哪个类型的。不同类型的变量比较或者运算，要先转类型，叫做类型转换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，&lt;code&gt;typeof null&lt;/code&gt; 返回 &lt;code&gt;&quot;object&quot;&lt;/code&gt;，它是一个特殊的对象值，含义是“非对象”。实际上，我们通常认为&lt;code&gt;null&lt;/code&gt;是自有类型的唯一成员。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;一显式转换&quot;&gt;一、显式转换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;parseInt()和parseFloat() 字符串转数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;js提供了&lt;code&gt;parseInt()&lt;/code&gt;和&lt;code&gt;parseFloat()&lt;/code&gt;两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是&lt;code&gt;NaN(Not a Number)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parseInt()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parseInt(&quot;1234blue&quot;);   //1234 
parseInt(&quot;0xA&quot;);   //10 
parseInt(&quot;22.5&quot;);   //22 
parseInt(&quot;blue&quot;);   //NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;parseInt()&lt;/code&gt;方法还有第二个参数，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。所以要解析十六进制的值，需如下调用&lt;code&gt;parseInt()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parseInt(&quot;AF&quot;,   16);   //175 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，对二进制、八进制，甚至十进制（默认模式），都可以这样调用&lt;code&gt;parseInt()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parseInt(&quot;10&quot;,   2);    //2 
parseInt(&quot;66&quot;,   8);    //54 
parseInt(&quot;10&quot;,   10);   //10 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;parseFloat&lt;/code&gt;字符串转&lt;strong&gt;浮点&lt;/strong&gt;数字，&lt;strong&gt;没有第二个参数&lt;/strong&gt;。&lt;br/&gt;下面是使用&lt;code&gt;parseFloat()&lt;/code&gt;方法的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parseFloat(&quot;1234blue&quot;);  //1234.0 
parseFloat(&quot;0xA&quot;);       //NaN 
parseFloat(&quot;22.5&quot;);      //22.5 
parseFloat(&quot;22.34.5&quot;);   //22.34 
parseFloat(&quot;0908&quot;);      //908 
parseFloat(&quot;blue&quot;);      //NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;toFixed() 数字转成字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据参数保留小数点后几位 会四舍五入，如果无参，默认为0；&lt;br/&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(66.55).toFixed();    //&quot;67&quot;
(66.64).toFixed(1);   //&quot;66.6&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;toExponenttial() 数字转成字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据参数保留小数点后几位 &lt;strong&gt;指数形式&lt;/strong&gt; 会四舍五入&lt;br/&gt;这个我不就不举例了，感兴趣的，自己百度下把。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number对象的 toString() 方法， 数字转字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据2 8 16 （范围2 - 36）分别转为二进制 八进制 十六进制字符串,，&lt;br/&gt;不带参，就默认为10， 转十进制。&lt;br/&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(6).toString(2);     //&quot;110&quot;
(66).toString(8);    //&quot;102&quot;
(66).toString(16);   //&quot;42&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下面三个构造函数，当没有使用 new 时，表示类型转换函数，使用new 时，表示转对象（创建一个对应对象），即转换得到的值 创建一个对应的对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它会把 “真值” 转为 &lt;code&gt;true&lt;/code&gt; ， “假值” 转为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Boolean()方法的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Boolean(&quot;&quot;);               //false   “假值”
Boolean(&quot;zdx&quot;);            //true    “真值” 
Boolean(66);               //true    “真值” 
Boolean(null);             //false   “假值”
Boolean(0);                //false   “假值”
Boolean(new Object());     //true    “真值” &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Number()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有以下规律：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;false&lt;/code&gt;、&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;&quot;&quot;&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;，转为0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt; ， 转1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字&lt;/strong&gt;转数字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全是数字的字符串&lt;/strong&gt;转数字&lt;br/&gt;//(如果是有效十六进制 会 转十进制数字)例:Number(&quot;0xf&quot;) //15&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组内全是数字（不能有逗号）&lt;/strong&gt;转数字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组内字符串全是数字（不能有逗号）&lt;/strong&gt;转数字&lt;/li&gt;
&lt;li&gt;其他都是 &lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实从 第五条那个开始，严谨一点是：&lt;br/&gt;对象类型，先调用valueOf() 方法，然后按照前四点转换返回的值。如果返回的值不是原始类型，则调用toString()方法，再按前四点转换返回的值。&lt;/p&gt;
&lt;p&gt;大栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Number(false);            //0 
Number(null);             //0 
Number(&quot;&quot;);               //0 
Number([]);               //0
Number(true);             //1 
Number(&quot;66&quot;);             //66 
Number(&quot;66f&quot;);            //NaN 
Number(new Object());     //NaN 
Number([66]);             //66
Number([&quot;66&quot;]);           //66       
Number([6,6]);            //NaN
Number([&quot;6f6&quot;]);          //NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;String()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String()可把任何值转换成字符串。它就是调用&lt;strong&gt;传进参数&lt;/strong&gt;的 &lt;code&gt;toString()&lt;/code&gt;方法。使用&lt;code&gt;String()&lt;/code&gt;转换成字符串和调用&lt;code&gt;toString()&lt;/code&gt;方法的唯一不同之处在于，对&lt;code&gt;null&lt;/code&gt;或&lt;code&gt;undefined&lt;/code&gt;值转换可以生成字符串而不引 发错误：&lt;/p&gt;
&lt;p&gt;String()方法的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String(null);            //&quot;null&quot; 

var   null   =   null; 
null.toString();        //报错

String(undefined);       //&quot;undefined&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Object()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个函数，使用 和 不使用 new 是一样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它会把原始值，根据它的类型，使用对应的构造函数，创建一个对象。&lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 和创建一个空对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Object(66);           //数字对象，等于  new Number(66)
Object(&quot;66&quot;);         //字符串对象，等于  new String(&quot;666&quot;)
Object(true);         //布尔对象， 等于  new Boolean(true)
Object(null);         //空对象，等于 new Object()
Object(undefined);    //空对象，等于 new Object()&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二隐式转换&quot;&gt;二、隐式转换&lt;/h2&gt;

&lt;h3 id=&quot;一所有类型-转为-布尔&quot;&gt;（一）、所有类型 转为 布尔&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JavaScript 的基础类型中 有布尔类型，这个类型的值，只有两个值---- true 和 false&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任意的JavaScript 的值都可以转换为布尔值。但只有下面这六个值会转为false：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;&quot;
0
-0
null
undefined
NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其他所有值，包括所有对象（数组）都会转换为 true。布尔值 false，和上面6个能转为false 的值，我们一般称为“假值”，其他值称为“真值”。（“真值”等价true，“假值”等价false）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意！！！在JavaScript 中 ，任何希望使用布尔值的地方，都会将操作数当作 “真假” 或 “假值” 对待（即把“真值”当true，“假值”当false）。这句话你现在不懂没事，看完下面的，或许你就懂了，哈哈。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二原始值-转为-数字&quot;&gt;（二）、原始值 转为 数字&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;字符串 转 数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当字符串里，全为数字时，转数字，其他都为NaN。空字符串就转0&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ &quot;666&quot;;    //666
+ &quot;66f&quot;;    //NaN
+ &quot;&quot;;       //0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;布尔转数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个比较简单了。&lt;br/&gt;true 转 1；false 转 0；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ true;   //1
+ false;  //&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;null 转数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;null 转 0。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ null;        //0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;undefined 和 NaN 转数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;undefined 和 NaN 都转 NaN。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ undefined;   //NaN
+ NaN;         //NaN&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;三原始值-转为-字符串&quot;&gt;（三）、原始值 转为 字符串&lt;/h3&gt;
&lt;p&gt;这个也比较简单，原始值 到 字符串，就原封不动的转（加个双引号）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;zdx&quot; + true;    //&quot;zdxtrue&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;四-引用类型-对象-转为-原始值&quot;&gt;（四）、 引用类型( 对象 )转为 原始值&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对象 转 布尔&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象 转 布尔 都为 true；等同于 Boolean()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;![];     //false    这里取反了，注意，取反会把操作值转布尔
!{};     //false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对象 转 数字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象 转 数字 ，首先调用 &lt;code&gt;valueOf()&lt;/code&gt;，如果返回的是原始值，再转数字（需要的话），并返回；否则调用 &lt;code&gt;toString()&lt;/code&gt;， 如果返回的是原始值，再转数字，并返回;否则 抛出一个类型错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ [];    //0
//[].valueOf();   返回数组本身[]，所以调用 [].toString(); 返回 空字符串&quot;&quot;,&quot;&quot;再转数字 0；
+ (new Date());   //1526008864094
//调用  (new Date()).valueOf(); 返回1526008864094&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对象 转 字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象 转 字符串 ，跟转数字的规则一样。只不过是转字符串。&lt;br/&gt;首先调用 &lt;code&gt;valueOf()&lt;/code&gt;，如果返回的是原始值，再转&lt;strong&gt;字符串&lt;/strong&gt;（需要的话），并返回；否则调用 &lt;code&gt;toString()&lt;/code&gt;， 如果返回的是原始值，再转&lt;strong&gt;字符串&lt;/strong&gt;，并返回;否则 抛出一个类型错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;66&quot; + [];    //&quot;66&quot;
&quot;66&quot; + {};    //&quot;66[object Object]&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：对象对原始值，除了布尔类型，其他都是先调用valueOf，然后根据需要调用toString。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;想知道，js 每个内置对象的&lt;code&gt;valueOf()&lt;/code&gt; 和 &lt;code&gt;toString()&lt;/code&gt;方法，可以翻到最下面，&lt;code&gt;附录&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三隐式转换-发生的地方&quot;&gt;三、隐式转换 发生的地方&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;隐式转换通常发生在表达式 和 运算符 。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;加减乘除&quot;&gt;（1）加减乘除：&lt;/h3&gt;
&lt;h4 id=&quot;加号&quot;&gt;加号 +&lt;/h4&gt;
&lt;h5 id=&quot;二元运算符用法两个操作数&quot;&gt;二元运算符用法（两个操作数）&lt;/h5&gt;
&lt;p&gt;可以对数字做加法， 也可以做字符串连接操作。&lt;br/&gt;&lt;strong&gt;当两个操作数 都是 数字 或 字符串时，计算是显然的。其他情况下，有如下规则&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对象转原始值，除了&lt;code&gt;Date&lt;/code&gt; 对象 直接调用&lt;code&gt;toString&lt;/code&gt;，其他对象，调用自身的&lt;code&gt;valueOf&lt;/code&gt; 方法，但有的对象自身没有&lt;code&gt;valueOf&lt;/code&gt;，或者得到的不是原始值，此时调用&lt;code&gt;toString&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;第一步转换后，如果其中一个是字符串的话，另一个操作数也转字符串，进行字符串连接。&lt;/li&gt;
&lt;li&gt;否则，都转为数字(或者NaN),进行加法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;栗子来了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 + new Date();     //&quot;1Fri May 11 2018 14:20:50 GMT+0800 (中国标准时间)&quot;

1 + new Number(2);    //3  (new Number).valueOf(); 返回2， 和1 做加法

&quot;66&quot; + 6;       //666    6 转 &quot;6&quot;

1 + {};         //&quot;1[object Object]&quot;   ({}).toString()

true + false;   //1    都转数字

1 + null;       //1    null 转数字

1 + undefined;  //NaN   undefined 转 NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际代码中，经常这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var x = 66;
x + &quot;&quot;;     //&quot;66&quot;    等价于 String(x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：两点！&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不要把对象字面量形式的值放在前面。&lt;/li&gt;
&lt;li&gt;从左到右的进行 + 运算。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;//对象字面量形式放在前面的结果比较复杂，不建议使用。（下面的结果不是唯一的）
{} + 1;     //1
{} + &quot;1&quot;;   //1
{} + {};    //&quot;[object Object][object Object]&quot;
{x:1} + {};  //NaN

//从左到右，逐个做 + 运算
1 + 2 + &quot;&quot;;    //&quot;3&quot;
1 + &quot;&quot; + 2;    //&quot;12&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;一元运算符用法一个操作数&quot;&gt;一元运算符用法（一个操作数）&lt;/h5&gt;
&lt;p&gt;把操作数转换为 &lt;strong&gt;数字（或者NaN），并返回它。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+ &quot;666&quot;;       //666   等价于 Number(&quot;666&quot;)
+ undefined;   //NaN&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;减号--&quot;&gt;减号 -&lt;/h4&gt;
&lt;p&gt;都是转数字，同一元加法，但是它会将结果转为 负数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- &quot;666&quot;;    //-666
- &quot;66f&quot;;    //NaN
1 - null;   //1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;乘号&quot;&gt;乘号 *&lt;/h4&gt;
&lt;p&gt;使用 Number()，强制转数字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 * &quot;666&quot;;     //666
1 * null;      //0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;除号&quot;&gt;除号 /&lt;/h4&gt;
&lt;p&gt;使用 Number()，强制转数字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;666&quot; / 1;     //666
1 / true;      //1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;求模&quot;&gt;求模 %&lt;/h4&gt;
&lt;p&gt;使用 Number()，强制转数字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;666&quot; % 666;     //0
1 / true;      //0&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;比较运算符&quot;&gt;（2）比较运算符 （&amp;gt; &amp;lt; &amp;gt;= &amp;lt;=）&lt;/h4&gt;
&lt;p&gt;比较运算符用来检测两个操作数（数字或字符串）的大小关系（数值大小或者&lt;strong&gt;字符串首个字符的16位Unicode的大小&lt;/strong&gt; ）。&lt;/p&gt;
&lt;p&gt;比较运算符的操作数可能是任意类型。但只有数字和字符串才能比较。因此，它会把别的操作数进行类型转换，规则如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对象转原始值，如果valueOf()返回原始值，直接比较，否则，调用toString()进行转换。&lt;/li&gt;
&lt;li&gt;转原始值后，如果两个操作数都是字符串，那么将按&lt;strong&gt;字符串首个字符的16位Unicode的大小&lt;/strong&gt; 进行比较。&lt;/li&gt;
&lt;li&gt;否则都转数字比较。Infinity比任何数字都大（除了自身），-Infinity 相反。如果一个操作数是NaN（或转NaN）,结果返回false。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;11 &amp;lt; 3;

&quot;11&quot; &amp;lt; &quot;3&quot;;   //true    &quot;11&quot; 首个字符串 &quot;1&quot; 的16位Unicode 值比 &quot;3&quot;的16位Unicode 小

//&quot;11&quot;.charCodeAt(0).toString(16) 31

//&quot;3&quot;.charCodeAt(0).toString(16)  33

&quot;11&quot; &amp;lt; 3;     //false   &quot;11&quot; 转 11，false

{} &amp;lt; 3;       //false   {}转原始值字符串，字符串转NaN， false

null &amp;lt; 3;     //true    null 转数字&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后要注意的是，&amp;lt;= 和 &amp;gt;= 比较时，并不根据 == 和 === 的规则（在下方）比较，它就仅仅表示 数值 或 字符串 之间的比较。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; null &amp;gt;= undefined    //false&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;in运算符&quot;&gt;（3）in运算符&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;把左操作数转 字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;in 运算符希望它的左操作数是一个&lt;strong&gt;字符串或可以转换为字符串&lt;/strong&gt;，右操作数是一个&lt;strong&gt;对象&lt;/strong&gt;。如果，右侧的对象拥有一个名为左侧操作数值的属性名，那么表达式返回true。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var point = { x:1, y:2};
&quot;x&quot; in point;    //true  point 有一个 x 的属性名

var arr = [a,b,c];
1 in arr;        //true   数组的索引就相当于 属性名&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;和&quot;&gt;（4）！ 和 ！！&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;！ 它会把操作值 转为 布尔值（“真值”为true，“假值”为false），对布尔值求反。（结果只有true，false）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(!&quot;&quot;);           //true
console.log(!0);            //true
console.log(!-0);           //true
console.log(!null);         //true
console.log(!undefined);    //true
console.log(!NaN);          //true
console.log(!false);        //true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;！！ 得到操作值 等价的 布尔值（“真值”为true，“假值”为false）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;等同于 Boolean()，经常称！！ 为强制转换。&lt;/strong&gt;&lt;br/&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(!!&quot;&quot;);           //false
console.log(!!0);            //false
console.log(!!-0);           //false
console.log(!!null);         //false
console.log(!!undefined);    //false
console.log(!!NaN);          //false
console.log(!!false);        //false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：“假值” 取反都是true， “真值”取反为false；“假值” 强制转换 都是 false， “真值”强制转换为 true&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;和-1&quot;&gt;（5）== 和 ===&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;都知道 == 是判断 左右值 是否想等的。而 === 不仅判断 右右值是否想等，还要判断，类型是否一样。结果返回布尔值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;== 的用法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;NaN是JavaScript中唯一一个不等于任何值的（包括它自己）。&lt;code&gt;(NaN == NaN) // false&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般对NaN的判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function isNaN(num){
    return typeof num === &quot;number&quot; &amp;amp;&amp;amp; num !== num;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意，跟js 自带的 isNaN 方法 不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;左右两边类型相同&quot;&gt;左右两边类型相同&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、原始值的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它们的比较，就是值的直接比较。&lt;br/&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.log(null == null);               //true
console.log(undefined == undefined);     //true
console.log(666 == 666);                 //true
console.log(666 == 1);                   //false
console.log(&quot;周大侠啊&quot; == &quot;周大侠啊&quot;);      //true
console.log(&quot;周大侠啊&quot; == &quot;大佬&quot;);         //false
console.log(true == true);               //true
console.log(true == false);              //false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、对象的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象和原始值不同，首先，它们是可变的-----它们的值是可修改的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var o = { x:1 };   //定义一个对象
o.x = 2;           //修改x的值

var a = [1,2,3];   //数组也是可修改的
a[0] = 0;          //修改数组第一个元素&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对象的比较并非值的比较，而是引用（内存地址）的比较。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var o1 = { x:1 };
var o2 = { x:1 };
console.log( o1 == o2 );    //false
//即使 对像的属性，值完全相同， 也不相等

var o3 = o1;
console.log( o1 == o3 );    //true
//o3 和  o1 引用的是同一对象。（即指向的是同一块储存地址）

//数组同上&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;左右两边类型不同&quot;&gt;左右两边类型不同&lt;/h4&gt;
&lt;p&gt;如果 == 两边的 类型不同，则比较时，有以下两个个规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;undefined等于null&lt;/li&gt;
&lt;li&gt;其他都转数字比较&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为什么undefined == null 呢？实际上，undefined 是派生自 null 的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象通过valueOf 或 toString 转换为原始值，原始值在对应转数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结:左右两边类型不同， == 在比较时，除了(null == undefined)，NaN，其他都是转为数字比较， 从来不会转为布尔值！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个大栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//1. undefined等于null
undefined == null; //ture

//2. 字符串和数字比较时，字符串转数字
&quot;0&quot; == 0;  //true
&quot;f&quot; == 0;  //false
//字符串转数字时，只有在字符串是纯数字时，转对应数字，其他都转为 NaN。

// 3. 字符串和布尔比较时，都转为数字
&quot;0&quot; == false;   //true
&quot;1&quot; == true;    //true

//4. 数字和布尔比较时，布尔转数字
1 == true;    //true
0 == false;   //true
//true 转 1， false 转0；

//5.对象 和 字符串，数字比较， 都转数字。
new String(&quot;66&quot;) == &quot;66&quot;;      //true
new String(&quot;zdx&quot;) == &quot;zdx&quot;;    //false
new String(&quot;66&quot;) == 66;        //true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;的用法&quot;&gt;=== 的用法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这个比较，首先，看两边类型是否一致，不一致， 直接false，一致的话，再根据 == 的使用规则， 进行比较。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;和-2&quot;&gt;（6）！= 和 ！==&lt;/h4&gt;
&lt;p&gt;这两个 运算 跟 取反（！） 操作是 &lt;strong&gt;不一样&lt;/strong&gt; 的！，注意区分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这两个运算，是在 == 和 === 比较过后的结果，进行取反（就是对 true 和 false 取反，因为，== 和 === 的返回值 只有 true 和 false）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单栗子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;0&quot; == 0;  //true
&quot;f&quot; === 0;  //false

&quot;0&quot; != 0;  //false
&quot;f&quot; !== 0;  //true&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;（7）&amp;amp;&amp;amp;、||&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&amp;amp; 逻辑与&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两侧都是布尔值， 进行布尔（AND）运算。&lt;/li&gt;
&lt;li&gt;否则它会先计算左侧表达式，如果为 “假值”，返回这个值，如果是“真值”，计算右侧表达式，并返回计算结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;true &amp;amp;&amp;amp; false;       //false
1 &amp;amp;&amp;amp; 2;              //2
null &amp;amp;&amp;amp; 2;           //null
1-1 &amp;amp;&amp;amp; 2;            //0
2-1 &amp;amp;&amp;amp; 0;            //0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，有时候就会这样写代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if( a==b ) start();
a == b &amp;amp;&amp;amp; start();    //效果同上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;|| 逻辑或&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它跟 &amp;amp;&amp;amp; 的行为是一样的，只是它的做的是布尔（OR）运算，返回的情况&lt;strong&gt;相反&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两侧都是布尔值， 进行布尔（OR）运算。&lt;/li&gt;
&lt;li&gt;否则它会先计算左侧表达式，如果为 “真值”，返回这个值，如果是“假值”，计算右侧表达式，并返回计算结果。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;true || false;       //true
1 || 2;              //1
null || 2;           //2
1-1 || 2;            //2
2-1 || 0;            //1&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;if-语句&quot;&gt;（8）if 语句&lt;/h4&gt;
&lt;p&gt;它会计算操作数（括号里）的值，把结果转为布尔类型。“真值” 表现为true ， “假值” 表现为false。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(3-2){
    console.log(666)
}
//666&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;h4 id=&quot;一object&quot;&gt;一、Object&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;返回对象本身。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;({x:1,y:2}).valueOf();    //{x: 1, y: 2},返回的是对象！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回 &quot;[object type]&quot;，其中type是对象的类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//这里使用函数的call方法，指定 this的指向
var toString = Object.prototype.toString;

toString.call(new Date); // [object Date]
toString.call(new String); // [object String]
toString.call(Math); // [object Math]

toString.call(undefined); // [object Undefined]
toString.call(null); // [object Null]&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;二boolean&quot;&gt;二、Boolean&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;返回布尔值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(true).valueOf();    //true , 返回的是原始值，Boolean类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回该对象的字符串形式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(true).toString();     //&quot;true&quot;，返回的是原始值，string类型&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;三date&quot;&gt;三、Date&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;返回存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(new Date()).valueOf();    //1525943413141  一串数字&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回一个美式英语日期格式的字符串.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(new Date()).toString();    //&quot;Fri May 11 2018 10:26:16 GMT+0800 (中国标准时间)&quot;  原始值，string类型&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;四number&quot;&gt;四、Number&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;返回数字值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(66).valueOf();    //66   返回的是原始值，Number类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回的是原始值，String类型&lt;br/&gt;根据2 8 16 （范围2 - 36）分别转为二进制 八进制 十六进制字符串,，&lt;br/&gt;不带参，就默认为10， 转十进制。&lt;br/&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(66).toString(2);    //&quot;1000010&quot;
(66).toString(8);    //&quot;102&quot;
(66).toString(16);   //&quot;42&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;五string&quot;&gt;五、String&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;返回字符串值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&quot;666&quot;).valueOf();    //&quot;666&quot;   返回的是原始值，String类型
(&quot;zdx&quot;).valueOf();    //&quot;zdx&quot;   返回的是原始值，String类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;和valueOf 效果一样，返回字符串值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&quot;666&quot;).toString();    //&quot;666&quot;   返回的是原始值，String类型
(&quot;zdx&quot;).toString();    //&quot;zdx&quot;   返回的是原始值，String类型&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;h4 id=&quot;六array&quot;&gt;六、Array&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;自身没有该方法，继承Object.prototype.valueOf。返回的是数组对象！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;([1,2,3]).valueOf();     //(3) [1, 2, 3]，&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回表示该数组的字符串，跟使用 Array.prototype.join(&quot;,&quot;)，效果等同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;([1,2,3]).toString();     //&quot;1,2,3&quot;,    原始值，string类型
([1,2,3]).join(&quot;,&quot;);      //&quot;1,2,3&quot;,&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;七function&quot;&gt;七、Function&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;自身没有该方法，继承Object.prototype.valueOf。&lt;br/&gt;返回的是函数,使用typeof 返回 function，但注意原始值没有function类型&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function a(){ console.log(666) };
a.valueOf();    //ƒ a(){ console.log(666) };  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回当前函数源代码的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function a(){ console.log(666) };
a.toString();    //&quot;function a(){ console.log(666) }&quot;;返回的是原始值，string类型&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;八error&quot;&gt;八、Error&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;自身没有该方法，继承Object.prototype.valueOf。&lt;br/&gt;返回Error 对象本身&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(new Error(&quot;fatal error&quot;)).valueOf();   //Error: fatal error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;返回一个指定的错误对象（Error object）的字符串表示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var e = new Error(&quot;fatal error&quot;);
print(e.toString()); // &quot;Error: fatal error&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;九math&quot;&gt;九、Math&lt;/h4&gt;
&lt;p&gt;它是全局对象， 不属于函数。&lt;br/&gt;&lt;strong&gt;1、valueOf&lt;/strong&gt;&lt;br/&gt;自身没有该方法，继承Object.prototype.valueOf。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Math.valueOf();     //返回Math 对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、toString&lt;/strong&gt;&lt;br/&gt;自身没有该方法，继承Object.prototype.toString。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Math.toString();    //&quot;[object Math]&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180514105345658?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTYwMTYx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 02:58:00 +0000</pubDate>
<dc:creator>周大侠啊</dc:creator>
<og:description>原文链接：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoudaxiaa/p/9705675.html</dc:identifier>
</item>
<item>
<title>GC调优入门笔记 - mozi_song</title>
<link>http://www.cnblogs.com/mozi-song/p/9700824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mozi-song/p/9700824.html</guid>
<description>&lt;p&gt;想给项目代码做做调优但有许多疑惑，比如有哪些参数要调、怎么调、使用什么工具、调优的效果如何定量测量等。发现Oracle的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html&quot; target=&quot;_blank&quot;&gt;这份资料&lt;/a&gt;不错，简洁直接，回答了我的许多问题，给了许多很实用的大方向上的指导。将其中精华记录下来，希望能给同样入门的朋友一些启示。&lt;/p&gt;
&lt;h2&gt;Garbage Collectors&lt;/h2&gt;
&lt;p&gt;垃圾收集器 (Garbage Collectors)是JVM中的内存管理工具。它的职责包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在年轻代为对象分配空间，并将存活比较久的对象移动到年老代；&lt;/li&gt;
&lt;li&gt;在堆占用率超过某阈值时触发concurrent marking phase，在年老代找到存活的对象；&lt;/li&gt;
&lt;li&gt;触发parallel copying，压缩活着的对象，释放垃圾空间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看起来有点抽象，并且貌似没提到年轻代的垃圾收集，其实已经在第一条中提到了：“将存活比较久的对象移动到年老代”，这里隐含了对年轻代进行存活对象登记和收集的过程。简而言之，垃圾收集器的职责是：&lt;strong&gt;给对象分配内存；收集年轻代垃圾；收集年老代垃圾&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;串/并行Garbage Collector的选择&lt;/h3&gt;
&lt;p&gt;一般来说，JVM会根据系统的物理配置等因素选择一个默认的垃圾处理器。但显然，不同的应用程序有不同的行为（如使用内存的频率、对象的平均存活时间）；也有不同的要求（如有界面的程序要求响应快速，而服务器端程序要求吞吐量高，能处理更多的请求）。所以，根据不同程序的特点，可能需要不同的垃圾处理器来管理。在此处，我们先从串/并行的角度浅浅地了解一下这个问题。&lt;/p&gt;
&lt;p&gt;垃圾处理器可以粗略地分为串行进行和并行进行的，即垃圾处理这个过程在单线程还是多线程中进行；在Java SE 1.4之前的版本不支持并行。根据Amdahl's law （程序能够通过并行来加速的程度取决于程序中必须串行运行的部分），如果GC是串行进行的，则一个并行的应用程序的加速程度会受到GC的影响。假设我们通过增加处理器个数的方式来加速一个应用程序，那么随着处理器个数的增多，GC拖后腿的程度也越来越厉害，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1154131/201809/1154131-20180925173340964-1082762386.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ＧＣ时间所占的百分比随处理器个数的变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是一个数学模拟图，模拟了一个理想（完全并行）的应用程序的吞吐量受GC时间的影响。横轴代表处理器个数，纵轴代表吞吐量，不同颜色的曲线代表GC百分比不同的程序。红色曲线表示一条在单CPU下GC时间占1%的程序，在处理器个数增加到32个时，GC占整个程序运行时间的百分比竟超过了20%。&lt;/p&gt;
&lt;p&gt;可以看到GC所占的时间百分比越大，拖后腿的程度就越厉害。这是一个很好理解的现象，因为GC是串行的，所以其运行时间不受处理器数量的影响。随着处理器的增多，应用程序本身的运行时间下降了，所以显得GC所占的时间百分比越来越大。&lt;/p&gt;
&lt;p&gt;因此，在小系统上开发应用时可以忽略的一些GC小问题，当扩展到大型系统上时就会变得十分可观，甚至成为性能瓶颈。但是，此时在垃圾处理器上做一些小文章就有可能极大地增加性能。比如考虑到上图反映的现象，或许我们可以考虑换一个并行的垃圾处理器以提高吞吐量。&lt;/p&gt;
&lt;p&gt;另一方面，&lt;strong&gt;小型应用如果不需要其他特殊的GC行为，通常使用串行垃圾处理器就够了&lt;/strong&gt;，选择其他垃圾处理器可能反而会引入额外的复杂性和开销。&lt;/p&gt;
&lt;h2&gt;分代模型&lt;/h2&gt;
&lt;p&gt;在处理垃圾时，需要先找到所有活着的对象，然后将剩下的作为垃圾进行处理。“找到所有活着的对象”这个过程需要耗费的时间与活着的对象数量成正比，这样的话，如果应用中本来就维护了大量的存活对象，那么找到活着的对象需要耗费大量的时间。为了优化这个过程，JVM程序员们基于一些经验提出了&lt;strong&gt;分代收集&lt;/strong&gt;的思想。在这些经验中，最重要的是&lt;strong&gt;分代假设&lt;/strong&gt;，即&lt;strong&gt;大部分对象都只存活很短的时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1154131/201809/1154131-20180926094638041-92080183.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象寿命的典型分布图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上图中，横轴代表总的字节分配数，即时间轴；纵轴代表不同时间下存活的对象所占字节数。左边的尖峰代表分配空间没多久就可以回收的对象，比如在某个loop中临时分配的对象，它们的寿命只有一个loop的时间；最右边代表存活很久的那些对象，比如初始化时就存在且一直活到程序结束的对象；在这两极之间，有一些用于中间计算的对象，即左边的尖峰右边的这个包。&lt;/p&gt;
&lt;p&gt;不同应用程序的对象寿命分布图是不一样的，但是许多应用的大致分布都符合上面这个图，这为分代收集奠定了一个很好的事实基础：&lt;strong&gt;大部分对象都在年轻时死去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如在一个公园里扫落叶，腾出空地让行人行走。有一些树掉叶子特别厉害，一小会儿地上就掉满了；而另外一些树每小时只掉一两片叶子。假设清洁工为了省力，每过一段时间就清扫一次，扫完了则回到椅子上休息。如果我是清洁工，肯定会选择集中打扫那些掉得厉害的树，而且可能会以比较高的频率打扫；至于那些掉得不厉害的树，只要偶尔看一下，等落满的时候再打扫就好了。如果每次都要把所有的树下打扫一遍，为了照顾那些掉得厉害的树我的打扫频率需要很高，我会很累，而且打扫时间也会变长，效率降低。&lt;/p&gt;
&lt;p&gt;除了串行收集器和G1之外，其他收集器默认使用以下分代模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1154131/201809/1154131-20180926100825662-1666189935.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认分代模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;模型分为年轻代和年老代，年轻代分为eden和两个survivor，virtual空间代表JVM向操作系统预订但还未实际分配的空间。&lt;/p&gt;
&lt;h2&gt;调优指标&lt;/h2&gt;
&lt;h3&gt;maximum pause time&lt;/h3&gt;
&lt;p&gt;pause time是指垃圾处理器停止应用程序的运行，专注于空间释放时所花的时间。如果使用的是并行垃圾处理器，可以通&lt;span&gt;过-XX:MaxGCPauseMillis=&amp;lt;nnn&amp;gt;这个命令行参数设定期望的&lt;span&gt;最大pause time。（如果未设置，默认没有最大时间要求）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;垃圾处理器会维护每次垃圾收集pause time的均值和方差，当均值与方差的和大于设置的&lt;span&gt;MaxGCPauseMillis&lt;/span&gt;参数时，垃圾处理器会认为停留时间目标未达到，然后调整堆的大小和其它的有关参数来试图达到目标。&lt;/p&gt;
&lt;p&gt;此处的maximum pause time和下面即将提到的throughput是一对相爱相杀的姐妹。通常减小堆size会优化pause time（扫描、处理时间减少），但是堆变小造成GC频率升高，从而导致throughput下降。对于这两者，垃圾处理器的处理方式是优先达到设置的pause time目标，其次再达到throughput目标。&lt;/p&gt;
&lt;h3&gt;throughput&lt;/h3&gt;
&lt;p&gt;吞吐量通过&lt;em&gt;GC时间比例&lt;/em&gt;测量。 GC时间比例 = GC时间 / (GC时间 + 应用运行时间)，其中的GC时间包括所有代的GC时间。如果使用的是并行垃圾处理器，吞吐量可以通过&lt;span&gt;-XX:GCTimeRatio=&amp;lt;nnn&amp;gt;设置，若&amp;lt;nnn&amp;gt;为19，则GC时间比例为1/(1+19)=5%，即垃圾处理的时间占总时间的5%。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;span&gt;GCTimeRatio&lt;/span&gt;未达到要求，垃圾收集器会增加年轻代和年老代的大小来降低&lt;span&gt;GCTimeRatio&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;footprint&lt;/h3&gt;
&lt;p&gt;内存占用（memory footprint）指程序运行时占用和引用的内存大小。&lt;/p&gt;
&lt;p&gt;如果前面两个目标达到了，垃圾处理器会自动收缩堆，直至其中一个目标不再满足（一定是throughput，因为堆变小会使停留时间变短），然后再试图满足这个目标。&lt;/p&gt;
&lt;h3&gt;promptness&lt;/h3&gt;
&lt;p&gt;及时性 (promptness)定义为对象死去之后到对象所占用的内存可以使用之前的时间。这个指标对分布式系统通常比较重要。&lt;/p&gt;
&lt;h2&gt;一般调优策略&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;如果堆已经达到&lt;span&gt;maximum heap size&lt;/span&gt;但throughput目标还未达到，说明设置的&lt;span&gt;maximum heap size&lt;/span&gt;太小，可以尝试将其设为接近物理内存但还不至于导致内存交换的值。如果还是达不到throughput目标，说明这个throughput目标对于当前平台上的内存大小来说过高了。&lt;/li&gt;
&lt;li&gt;如果throughput目标已经满足，但停留时间过长，则可以增加maximum pause time目标。但这样throughput目标有可能又得不到满足了，此时需要根据自己的判断作一个折中。&lt;/li&gt;
&lt;li&gt;如上文所说，throughput与pause time对堆大小的要求相反，是一对相互竞争的指标。它们之间的相互竞争可能造成的结果是：即使应用程序已经在稳定运行了，堆大小仍然在上下振动。这表明垃圾处理器努力在两者之间寻找一个平衡。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;度量&lt;/h2&gt;
&lt;p&gt;以上所说的throughput等指标需要根据应用的不同特性去测量。比如要测一个web server的throughput，可以用一个自己写的client load generator；测试Solaris系统上服务器的内存占用，可以用&lt;span&gt;pmap这个命令&lt;/span&gt;；若要测GC的停留时间，则可以通过命令行&lt;span&gt;参数-verbose:gc直接观察JVM的&lt;/span&gt;诊断输出。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文定性介绍了GC调优的一些初级概念，为实际调优奠定基础。但仅有这些模糊概念是远远不够的，在理论和实践上还会作出其它总结，欢迎关注。&lt;/p&gt;
&lt;h2&gt;参考资料/推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html&quot; target=&quot;_blank&quot;&gt;Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide&lt;/a&gt; 文中提到的资料，Oracle写的，具有官方指导意义&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot; target=&quot;_blank&quot;&gt;深入理解Java虚拟机&lt;/a&gt; 推荐看第4-5章，详细讲解了调优工具的使用以及几个调优实例&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1213964/&quot; target=&quot;_blank&quot;&gt;高质量Java程序设计&lt;/a&gt; 推荐看第3章，作者用一个xml parser的例子给出了调优实战讲解，可惜本书不再再版，也未找到电子版&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 02:50:00 +0000</pubDate>
<dc:creator>mozi_song</dc:creator>
<og:description>想给项目代码做做调优但有许多疑惑，比如有哪些参数要调、怎么调、使用什么工具、调优的效果如何定量测量等。发现Oracle的这份资料不错，简洁直接，回答了我的许多问题，给了许多很实用的大方向上的指导。将其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mozi-song/p/9700824.html</dc:identifier>
</item>
</channel>
</rss>