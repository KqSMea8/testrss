<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>tree：以树形结构显示目录下的内容 - 七月流星雨</title>
<link>http://www.cnblogs.com/scajy/p/9795394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scajy/p/9795394.html</guid>
<description>&lt;p&gt;tree命令&lt;/p&gt;
&lt;p&gt;　　1、命令详解&lt;/p&gt;
&lt;p&gt;　　　　　　【功能说明】&lt;/p&gt;
&lt;p&gt;　　　　　　　　tree命令的中文意思为“树”，功能是以树形结构列出指定目录下的所有内容包括所有文件、子目录及子目录里的目录和文件。&lt;/p&gt;
&lt;p&gt;　　　　　　【语法格式】　　　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　tree    [option]   [directory]
　　　　　　　　tree    [选项]      [目录]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　【说明】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;注意tree命令以及后面的选项和目录，每个元素之间都至少要有一个空格。&lt;/li&gt;
&lt;li&gt;tree命令后若不接选项和目录就会默认显示当前所在路径目录的目录结构。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　2、参数说明&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;参数选项&lt;/td&gt;
&lt;td&gt;解释说明（带 Δ 的为重点）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;显示所有文件，包括隐藏文件（以  “.” 点开头的文件 ）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只显示目录   Δ&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;只显示每个文件的全路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;不显示树枝，常与-f参数配合使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-L level&lt;/td&gt;
&lt;td&gt;遍历目录的最大层数，level 为大于0的正整数   Δ&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;-F&lt;/td&gt;
&lt;td&gt;在执行文件、目录、Socket符号链接、管道名称等不同类型文件的结尾，各自加上“*”、 &quot;/&quot;、&quot;=&quot;、&quot;@&quot;、&quot;|&quot;号、类似ls命令的-F选项&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　3、使用范例&lt;br/&gt;　　　　在讲解案例之前，先做准备工作&lt;/p&gt;
&lt;p&gt;　　　　第一步，安装tree命令&lt;/p&gt;
&lt;p&gt;　　　　首先检查系统是否安装了tree命令，如果不采用的是最小安装linux系统的方式，哪么tree命令有可能没有安装。此时可用yum命令安装tree命令：&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@1-230 ~]# rpm -qa tree            #查询tree命令是否安装&lt;/span&gt;&lt;br/&gt;&lt;span&gt;tree-1.6.0-10.el7.x86_64                      #如果没有显示就执行下面的命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[root@1-230 ~]# yum -y install tree     #安装tree命令的yum命令&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 　　　　第二步，调用系统字符集，防止树形结构显示乱码。&lt;/p&gt;
&lt;p&gt;　　　　 在使用树形结构时，很可能会因为字符集导致出现乱码问题，比如导致树形的树枝部分都是问号，例如：&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;[root@1-230 ~]# tree /usr/local/&lt;br/&gt;/usr/local/&lt;br/&gt;?..? bin&lt;br/&gt;?..? etc&lt;br/&gt;?..? games&lt;br/&gt;?..? include&lt;br/&gt;?..? lib&lt;br/&gt;?..? lib64&lt;br/&gt;?..? libexec&lt;br/&gt;?..? sbin&lt;br/&gt;?..? share&lt;br/&gt;?...?..? applications&lt;br/&gt;?...?..? info&lt;br/&gt;?...?..? man&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　  下面的命令为临时解决树结构乱码的方法&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;[root@1-230 ~]# LANG=en_US.UTF-8&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　4、案例范例&lt;/p&gt;
&lt;p&gt;　　　　1、不带任何参数执行tree命令&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;[root@1-230 etc]# cd ~                 #显示当前目录的结果&lt;br/&gt;[root@1-230 ~]# tree&lt;br/&gt;.       # &quot; . &quot; 以当前目录为起点&lt;br/&gt;└── anaconda-ks.cfg&lt;/p&gt;
&lt;p&gt;0 directories, 1 file&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　 2、以树形结构显示目录下的所有内容（-a的功能）&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;[root@1-230 ~]# tree -a      #带 -a 参数显示所有文件（包括隐藏文件）&lt;br/&gt;.&lt;br/&gt;├── anaconda-ks.cfg&lt;br/&gt;├── .bash_history             #在linux系统中，以&quot;  .  &quot;点号开头的文件为隐藏文件，默认不显示&lt;br/&gt;├── .bash_logout&lt;br/&gt;├── .bash_profile&lt;br/&gt;├── .bashrc&lt;br/&gt;├── .cshrc&lt;br/&gt;├── .pki&lt;br/&gt;│   └── nssdb&lt;br/&gt;├── .ssh&lt;br/&gt;│   ├── id_rsa&lt;br/&gt;│   ├── id_rsa.pub&lt;br/&gt;│   └── known_hosts&lt;br/&gt;├── .tcshrc&lt;br/&gt;└── .viminfo&lt;/p&gt;
&lt;p&gt;3 directories, 11 files&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　3、只列出目录下第一层目录的结构（-L 功能）&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@1-230 ~]# tree -L 1 /          #-L参数后接数字，表示查看目录的层数，不带-L选项默认显示所有层数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── bin -&amp;gt; usr/bin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── boot&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── dev&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── docker&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── etc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── home&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── lib -&amp;gt; usr/lib&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── lib64 -&amp;gt; usr/lib64&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── media&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── mnt&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── opt&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── proc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── root&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── run&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── sbin -&amp;gt; usr/sbin&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── scripts&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── server&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── srv&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── sys&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── tmp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;├── usr&lt;/span&gt;&lt;br/&gt;&lt;span&gt;└── var&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;22 directories, 0 files &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　4、只显示所有的目录（但不显示文件）。&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;[root@1-230 ~]# tree -d /usr/local/            #-d 参数表示只显示目录&lt;br/&gt;/usr/local/&lt;br/&gt;├── bin&lt;br/&gt;├── etc&lt;br/&gt;├── games&lt;br/&gt;├── include&lt;br/&gt;├── lib&lt;br/&gt;├── lib64&lt;br/&gt;├── libexec&lt;br/&gt;├── sbin&lt;br/&gt;├── share&lt;br/&gt;│   ├── applications&lt;br/&gt;│   ├── info&lt;br/&gt;│   └── man&lt;br/&gt;│   ├── man1&lt;br/&gt;│   ├── man1x&lt;br/&gt;│   ├── man2&lt;br/&gt;│   ├── man2x&lt;br/&gt;│   ├── man3&lt;br/&gt;│   ├── man3x&lt;br/&gt;│   ├── man4&lt;br/&gt;│   ├── man4x&lt;br/&gt;│   ├── man5&lt;br/&gt;│   ├── man5x&lt;br/&gt;│   ├── man6&lt;br/&gt;│   ├── man6x&lt;br/&gt;│   ├── man7&lt;br/&gt;│   ├── man7x&lt;br/&gt;│   ├── man8&lt;br/&gt;│   ├── man8x&lt;br/&gt;│   ├── man9&lt;br/&gt;│   ├── man9x&lt;br/&gt;│   └── mann&lt;br/&gt;└── src&lt;/p&gt;
&lt;p&gt;32 directories&lt;/p&gt;

&lt;p&gt;[root@1-230 ~]# tree -dL 1 /usr/local/          #-d参数只显示目录，-L参数显示层数，这里是1层。&lt;br/&gt;/usr/local/&lt;br/&gt;├── bin&lt;br/&gt;├── etc&lt;br/&gt;├── games&lt;br/&gt;├── include&lt;br/&gt;├── lib&lt;br/&gt;├── lib64&lt;br/&gt;├── libexec&lt;br/&gt;├── sbin&lt;br/&gt;├── share&lt;br/&gt;└── src&lt;/p&gt;
&lt;p&gt;10 directories&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　5、-f选项和-i选项的使用&lt;/p&gt;
&lt;p&gt;　　　　　　     使用-f选项可显示完整的路径名称，使用-i选项则不显示树枝部分，示例代码如下：&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;[root@1-230 ~]# tree -L 1 -f /usr/local/             # -f  显示内容的完整路径&lt;br/&gt;/usr/local&lt;br/&gt;├── /usr/local/bin&lt;br/&gt;├── /usr/local/etc&lt;br/&gt;├── /usr/local/games&lt;br/&gt;├── /usr/local/include&lt;br/&gt;├── /usr/local/lib&lt;br/&gt;├── /usr/local/lib64&lt;br/&gt;├── /usr/local/libexec&lt;br/&gt;├── /usr/local/sbin&lt;br/&gt;├── /usr/local/share&lt;br/&gt;└── /usr/local/src&lt;/p&gt;
&lt;p&gt;10 directories, 0 files&lt;/p&gt;

&lt;p&gt;[root@1-230 ~]# tree -L 1 -fi /usr/local/         # -i 不显示   “树枝”  ，当需要获取所有文件的完整路径时，这个命令很好用。&lt;br/&gt;/usr/local&lt;br/&gt;/usr/local/bin&lt;br/&gt;/usr/local/etc&lt;br/&gt;/usr/local/games&lt;br/&gt;/usr/local/include&lt;br/&gt;/usr/local/lib&lt;br/&gt;/usr/local/lib64&lt;br/&gt;/usr/local/libexec&lt;br/&gt;/usr/local/sbin&lt;br/&gt;/usr/local/share&lt;br/&gt;/usr/local/src&lt;/p&gt;
&lt;p&gt;10 directories, 0 files&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　6、使用tree命令区分目录和文件的方法（常用）&lt;/p&gt;
&lt;table border=&quot;2&quot; cellspacing=&quot;50&quot; cellpadding=&quot;50&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;[root@1-230 ~]# tree -L 1 -F /boot                      #使用-F参数会在目录后面添加   “/ ”，方便区分目录&lt;br/&gt;/boot&lt;br/&gt;├── config-3.10.0-514.el7.x86_64&lt;br/&gt;├── grub/&lt;br/&gt;├── grub2/&lt;br/&gt;├── initramfs-0-rescue-acfc6ac3b92c4b9d94570fde26f40941.img&lt;br/&gt;├── initramfs-3.10.0-514.el7.x86_64.img&lt;br/&gt;├── initramfs-3.10.0-514.el7.x86_64kdump.img&lt;br/&gt;├── initrd-plymouth.img&lt;br/&gt;├── symvers-3.10.0-514.el7.x86_64.gz&lt;br/&gt;├── System.map-3.10.0-514.el7.x86_64&lt;br/&gt;├── vmlinuz-0-rescue-acfc6ac3b92c4b9d94570fde26f40941*&lt;br/&gt;└── vmlinuz-3.10.0-514.el7.x86_64*&lt;/p&gt;
&lt;p&gt;2 directories, 9 files&lt;/p&gt;

&lt;p&gt;[root@1-230 ~]# tree -L 1 -F /boot/ |grep /$            #过滤以斜线结尾的所有内容，如果大家看不懂这方法，那么建议等学完grep命令在回头来看&lt;br/&gt;/boot/&lt;br/&gt;├── grub/&lt;br/&gt;├── grub2/&lt;/p&gt;

&lt;p&gt;[root@1-230 ~]# tree -L 1 -d /boot/                 #使用-d参数只显示目录树，这样可以轻松过滤内容中的目录。&lt;br/&gt;/boot/&lt;br/&gt;├── grub&lt;br/&gt;└── grub2&lt;/p&gt;
&lt;p&gt;2 directories&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 15 Oct 2018 15:56:00 +0000</pubDate>
<dc:creator>七月流星雨</dc:creator>
<og:description>tree命令 1、命令详解 【功能说明】 tree命令的中文意思为“树”，功能是以树形结构列出指定目录下的所有内容包括所有文件、子目录及子目录里的目录和文件。 【语法格式】 【说明】 2、参数说明 3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scajy/p/9795394.html</dc:identifier>
</item>
<item>
<title>springboot 中事件监听模式的一种实现 - mysgk</title>
<link>http://www.cnblogs.com/mysgk/p/9795484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysgk/p/9795484.html</guid>
<description>&lt;p&gt;前言: 事件监听模式是一种常用的设计模式，在springboot 中我们如何实现呢？&lt;br/&gt;首先我们要理解事件监听中需要的几个角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件发布者 （即事件源）&lt;/li&gt;
&lt;li&gt;事件监听者&lt;/li&gt;
&lt;li&gt;事件本身&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;废话不多说直接上代码&lt;/p&gt;

&lt;p&gt;事件本身需要继承&lt;strong&gt;ApplicationEvent&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yxd;

import java.util.List;
import java.util.Map;
import org.springframework.context.ApplicationEvent;

public class DemoEvent extends ApplicationEvent{

    private String type;
    private List&amp;lt;Map&amp;gt; msg;
    
    public DemoEvent(Object object, String type ,List&amp;lt;Map&amp;gt; msg) {
        super(object);
        this.msg = msg;
        this.type = type;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public List&amp;lt;Map&amp;gt; getMsg() {
        return msg;
    }

    public void setMsg(List&amp;lt;Map&amp;gt; msg) {
        this.msg = msg;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015233325948-113129810.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;事件源需要注入 &lt;strong&gt;ApplicationContext&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.yxd;

import java.util.List;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class DemoPublisher {

    @Autowired
    ApplicationContext applicationContext;
    
    public void publish(String type , List&amp;lt;Map&amp;gt; msg) {
        applicationContext.publishEvent(new DemoEvent(this,type, msg ));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015232954863-2034051224.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;监听者需要实现 &lt;strong&gt;ApplicationListener&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.yxd;

import java.util.List;
import java.util.Map;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class DemoListener1 implements ApplicationListener&amp;lt;DemoEvent&amp;gt; {

    @Override
    public void onApplicationEvent(DemoEvent event) {
        List&amp;lt;Map&amp;gt; msg = event.getMsg();
        String type = event.getType();
        System.out.println(&quot;listener1 接收到了 publisher 发送的消息类型 :&quot; + type +&quot;, 消息内容: &quot; + msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015233510153-310389711.png&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;package com.yxd;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Autowired
    DemoPublisher demoPublisher;

    @RequestMapping(&quot;testListener&quot;)
    public String testListener() {
        ArrayList&amp;lt;Map&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();        
        HashMap&amp;lt;String, String&amp;gt; m1 =  new HashMap&amp;lt;&amp;gt;();
        m1.put(&quot;1&quot;, &quot;2&quot;);
        HashMap&amp;lt;String, String&amp;gt; m2 =  new HashMap&amp;lt;&amp;gt;();
        m2.put(&quot;3&quot;, &quot;4&quot;);
        HashMap&amp;lt;String, String&amp;gt; m3 =  new HashMap&amp;lt;&amp;gt;();
        m3.put(&quot;5&quot;, &quot;6&quot;);       
        list.add(m1);
        list.add(m2);
        list.add(m3);
        demoPublisher.publish(&quot;测试消息&quot;,list);
        return &quot;消息发布成功&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015233701998-2085316357.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们访问接口&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015233741689-241027368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015233813479-1037116360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三个监听者都得到了消息。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201810/695883-20181015233918518-1736254657.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 15:41:00 +0000</pubDate>
<dc:creator>mysgk</dc:creator>
<og:description>前言: 事件监听模式是一种常用的设计模式，在springboot 中我们如何实现呢？ 首先我们要理解事件监听中需要的几个角色 事件发布者 （即事件源） 事件监听者 事件本身 废话不多说直接上代码 定义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mysgk/p/9795484.html</dc:identifier>
</item>
<item>
<title>SmartSql 常见问题 - Ahoo-Wang</title>
<link>http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-common-problem.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-common-problem.html</guid>
<description>&lt;h2 id=&quot;为什么不支持-linq&quot;&gt;为什么不支持 Linq?&lt;/h2&gt;
&lt;p&gt;SmartSql 希望 开发人员更多的接触 Sql ,获得绝对的控制权与安全感。所以目前没有计划支持 Code First 编程模式。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我想好了Sql怎么写，然后再来写Linq,完了可能还要再查看一下Linq输出的Sql是什么样的，这真是糟糕的体验。要想对Sql做绝对的优化，那么开发者必须对Sql有绝对的控制权。另外Sql本身很简单，为何要增加一层翻译器呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Codefirst 一个美好，却不切实际的想法。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对smartsql很感兴趣不知从何开始&quot;&gt;对SmartSql很感兴趣，不知从何开始？&lt;/h2&gt;
&lt;p&gt;请阅读示例项目：&lt;a href=&quot;https://github.com/Ahoo-Wang/SmartSql-Starter&quot; class=&quot;uri&quot;&gt;https://github.com/Ahoo-Wang/SmartSql-Starter&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;smartsql支持哪些数据库&quot;&gt;SmartSql支持哪些数据库？&lt;/h2&gt;
&lt;p&gt;只要是实现了ADO.NET的数据库驱动的数据库均支持，您只需要安装好对应的驱动即可。&lt;/p&gt;
&lt;h2 id=&quot;smartsql是否支持多数据库&quot;&gt;SmartSql是否支持多数据库？&lt;/h2&gt;
&lt;p&gt;支持，可以通过配置引入多个数据库实例：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var sqlServerMapper = MapperContainer.Instance.GetSqlMapper(&quot;SmartSqlMapConfig-SqlServer.xml&quot;);
var mySqlMapepr = MapperContainer.Instance.GetSqlMapper(&quot;SmartSqlMapConfig-MySql.xml&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;smartsql性能如何&quot;&gt;SmartSql性能如何？&lt;/h2&gt;
&lt;p&gt;SmartSql的性能与Dapper是保存同一级别的≈原生手写（另外多个其他ORM在自己的测试报告中写明比Dapper性能还高，&lt;strong&gt;请同学们保持好奇&lt;/strong&gt;），文档中的 SmartSql 性能对比测试报告是开放了源代码的，任何对于性能感兴趣的同学均可以clone源代码自己跑一遍性能测试。&lt;strong&gt;自己Run的性能测试才是真的测试！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;smartsql可用性如何&quot;&gt;SmartSql可用性如何？&lt;/h2&gt;
&lt;p&gt;SmartSql 已历经1年多的线上数十个微服务场景验证，其性能、可用性、生产力是得到验证的。&lt;/p&gt;
&lt;h2 id=&quot;对于简单curd配置&quot;&gt;对于简单CURD配置&lt;/h2&gt;
&lt;p&gt;作者还开源了一个代码生成器项目：SmartCode: &lt;a href=&quot;https://github.com/Ahoo-Wang/SmartCode&quot; class=&quot;uri&quot;&gt;https://github.com/Ahoo-Wang/SmartCode&lt;/a&gt; ,可以使用SmartCode生成解决方案，包括所有CURD操作的XML/Entity/IRepository!&lt;/p&gt;
&lt;h2 id=&quot;为什么选择xml作为配置语法&quot;&gt;为什么选择Xml作为配置语法&lt;/h2&gt;
&lt;p&gt;Xml 的标签语法用起来会比较灵活. 比如 筛选标签,嵌套复用,可读性.&lt;br/&gt;复杂查询场景用起来会非常舒爽,可读性也会比较好,代码层面不需要做任何处理,全部交给Xml .&lt;/p&gt;
&lt;h2 id=&quot;集群场景如何使用获得缓存一致性&quot;&gt;集群场景如何使用获得缓存一致性&lt;/h2&gt;
&lt;p&gt;SmartSql提供了Redis缓存插件,可通过NuGet安装:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package SmartSql.Cache.Redis&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;集群场景中sql配置很多copy怎么办&quot;&gt;集群场景中Sql配置很多Copy怎么办&lt;/h2&gt;
&lt;p&gt;SmartSql 提供了 ZooKeeper配置插件,通过NuGet安装:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package SmartSql.ZooKeeperConfig&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;另外作者还开源了ZooKeeper节点管理工具:&lt;a href=&quot;https://github.com/Ahoo-Wang/ZooKeeper-Admin&quot;&gt;ZooKeeper-Admin&lt;/a&gt;,可直接通过该管理工具直接配置. 关于&lt;a href=&quot;https://github.com/Ahoo-Wang/ZooKeeper-Admin&quot;&gt;ZooKeeper-Admin&lt;/a&gt;:&lt;/li&gt;
&lt;li&gt;使用 Asp.net Core 编写&lt;/li&gt;
&lt;li&gt;Docker安装:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;docker pull ahoowang/zookeeper.admin
docker run --name zooAdmin -p 80:80 ahoowang/zookeeper.admin&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;本地安装&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;git clone https://github.com/Ahoo-Wang/ZooKeeper-Admin.git
dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;我之前使用过mybatis感觉smartsql有种似曾相识的感觉&quot;&gt;我之前使用过MyBatis,感觉SmartSql有种似曾相识的感觉&lt;/h2&gt;
&lt;p&gt;是的,SmartSql编程模型多处借鉴了MyBatis,如果你之前使用过MyBatis,那么SmartSql将是你更好的选择,因为你几乎不需要有任何编程方式的转变就可以直接上手,并且拥有跨平台,高性能,以及众多你插件的支持.&lt;/p&gt;
&lt;h2 id=&quot;手写xml-很痛苦是否有智能提示&quot;&gt;手写Xml 很痛苦是否有智能提示&lt;/h2&gt;
&lt;p&gt;SmartSql 提供了Xml架构文档,可以获得输入智能提示的体验:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/457833/201810/457833-20181015230614526-556785279.png&quot; alt=&quot;智能提示&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 15:05:00 +0000</pubDate>
<dc:creator>Ahoo-Wang</dc:creator>
<og:description>常见问题 为什么不支持 Linq? SmartSql 希望 开发人员更多的接触 Sql ,获得绝对的控制权与安全感。所以目前没有计划支持 Code First 编程模式。 我想好了Sql怎么写，然后再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-common-problem.html</dc:identifier>
</item>
<item>
<title>刨根问底KVO原理 - Vanch</title>
<link>http://www.cnblogs.com/vanch/p/9795279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vanch/p/9795279.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;KVO( &lt;code&gt;NSKeyValueObserving&lt;/code&gt; )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改被观察者代码，利用 &lt;code&gt;runtime&lt;/code&gt; 实现运行中修改某一实例达到目的，保证了未侵入性。&lt;/p&gt;
&lt;p&gt;A对象指定观察B对象的属性后，当属性发生变更，A对象会收到通知，获取变更前以及变更的状态，从而做进一步处理。&lt;/p&gt;
&lt;p&gt;在实际生产环境中，多用于应用层观察模型层数据变动，接收到通知后更新，从而达成比较好的设计模式。&lt;/p&gt;
&lt;p&gt;另一种常用的用法是 &lt;code&gt;Debug&lt;/code&gt;，通过观察问题属性的变化，追踪问题出现的堆栈，更有效率的解决问题。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;
&lt;h3 id=&quot;观察回调&quot;&gt;观察回调&lt;/h3&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)observeValueForKeyPath:(nullable NSString *)keyPath 
                      ofObject:(nullable id)object 
                        change:(nullable NSDictionary&amp;lt;NSKeyValueChangeKey, id&amp;gt; *)change 
                       context:(nullable void *)context;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察者需要实现这个方法来接受回调，其中&lt;code&gt;keyPath&lt;/code&gt; 是 &lt;code&gt;KVC&lt;/code&gt; 路径， &lt;code&gt;object&lt;/code&gt; 是观察者，&lt;code&gt;context&lt;/code&gt; 区分不同观察的标识。&lt;/p&gt;
&lt;h4 id=&quot;改变字典&quot;&gt;改变字典&lt;/h4&gt;
&lt;p&gt;最关键的是改变字典，其中包含了 &lt;code&gt;NSKeyValueChangeKey&lt;/code&gt;，通过预定义的字符串来获取特定的数值。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;

FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeKindKey&lt;/code&gt; 中定义的是改变的类型，如果调用的是&lt;code&gt;Setter&lt;/code&gt;方法，那就是&lt;code&gt;NSKeyValueChangeSetting&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;剩余的三种分别是插入、删除、替换，当观察的属性属于集合类（这点会在之后讲），变动时就会通知这些类型。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;typedef NS_ENUM(NSUInteger, NSKeyValueChange) {
    NSKeyValueChangeSetting = 1,
    NSKeyValueChangeInsertion = 2,
    NSKeyValueChangeRemoval = 3,
    NSKeyValueChangeReplacement = 4,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeNewKey&lt;/code&gt; 获取变更的最新值，&lt;code&gt;NSKeyValueChangeOldKey&lt;/code&gt; 获取原始数值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeIndexesKey&lt;/code&gt; 如果观察的是集合，那这个键值返回索引集合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeNotificationIsPriorKey&lt;/code&gt; 如果设置了接受提前通知，那么修改之前会先发送通知，修改后再发一次。为了区分这两次，第一次会带上这个键值对，其内容为 &lt;code&gt;@1&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;字符串枚举&quot;&gt;字符串枚举&lt;/h4&gt;
&lt;p&gt;在注册类型时，苹果使用了&lt;code&gt;NS_STRING_ENUM&lt;/code&gt;宏。&lt;/p&gt;
&lt;p&gt;虽然这个宏在&lt;code&gt;ObjC&lt;/code&gt;下毫无作用，但是对于&lt;code&gt;Swift&lt;/code&gt;有优化&lt;br/&gt;，上面的定义会变成这样。&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;enum NSKeyValueChangeKey: String { 
    case kind
    case new
    case old
    case indexes 
    case notificationIsPrior
}
let dict: [NSKeyValueChangeKey : Any] = [......]
let kind = dict[.kind] as! Number&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符串枚举对于使用来说是非常直观和安全的。&lt;/p&gt;
&lt;h3 id=&quot;添加与删除&quot;&gt;添加与删除&lt;/h3&gt;
&lt;p&gt;对于普通对象，使用这两个方法就能注册与注销观察。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)addObserver:(NSObject *)observer 
         forKeyPath:(NSString *)keyPath 
            options:(NSKeyValueObservingOptions)options 
            context:(nullable void *)context;

- (void)removeObserver:(NSObject *)observer 
            forKeyPath:(NSString *)keyPath 
               context:(nullable void *)context;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以设置多种观察模式来匹配需求。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) {
    //可以收到新改变的数值
    NSKeyValueObservingOptionNew = 0x01,
    //可以收到改变前的数值
    NSKeyValueObservingOptionOld = 0x02,
    //addObserver后立刻触发通知，只有new，没有old
    NSKeyValueObservingOptionInitial = 0x04,
    //会在改变前与改变后发送两次通知
    //改变前的通知带有notificationIsPrior=@1，old
    NSKeyValueObservingOptionPrior = 0x08
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于不符合 &lt;code&gt;KVC&lt;/code&gt; 的访问器标准，苹果规定 &lt;code&gt;NSArray NSOrderedSet NSSet&lt;/code&gt; 不可以执行 &lt;code&gt;addObserver&lt;/code&gt; 方法，不然会抛出异常。针对 &lt;code&gt;NSArray&lt;/code&gt; 有特殊的方法，如下&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)addObserver:(NSObject *)observer 
 toObjectsAtIndexes:(NSIndexSet *)indexes 
         forKeyPath:(NSString *)keyPath 
            options:(NSKeyValueObservingOptions)options 
            context:(nullable void *)context;

- (void)removeObserver:(NSObject *)observer 
  fromObjectsAtIndexes:(NSIndexSet *)indexes 
            forKeyPath:(NSString *)keyPath 
               context:(nullable void *)context;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要的区别在于多了一个&lt;code&gt;ObjectsAtIndexes&lt;/code&gt;，其实做的事情是一样的，根据索引找到对象，再逐一建立观察关系。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;h3 id=&quot;runtime&quot;&gt;Runtime&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueObserving&lt;/code&gt; 与 &lt;code&gt;NSKeyValueCoding&lt;/code&gt; 一起定义在 &lt;code&gt;Foundation&lt;/code&gt; 库，而这个库是不开源的，我们先从苹果开发者文档中获取信息。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Automatic key-value observing is implemented using a technique called isa-swizzling.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看描述猜测苹果应该是通过重新设置被观察者的 &lt;code&gt;Class&lt;/code&gt; (&lt;code&gt;isa&lt;/code&gt; 中包含 &lt;code&gt;Class&lt;/code&gt; 信息)，该类继承了原类并且重载属性的 &lt;code&gt;Setter&lt;/code&gt; 方法，添加发通知的操作达到目的。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;@interface ConcreteSubject : NSObject
@property (nonatomic, strong) id obj;
@end

ConcreteSubject *sub = [ConcreteSubject new];

NSLog(@&quot;%s&quot;, class_getName(object_getClass(sub)));
//改变前 outprint--&amp;gt; ConcreteSubject

[sub addObserver:self forKeyPath:@&quot;obj&quot; options:NSKeyValueObservingOptionNew context:nil];
//执行观察方法

NSLog(@&quot;%s&quot;, class_getName(object_getClass(sub)));
//改变后 outprint--&amp;gt; NSKVONotifying_ConcreteSubject
NSLog(@&quot;%s&quot;, class_getName(object_getClass(class_getSuperclass(cls))));
//获取超类名 outprint--&amp;gt; ConcreteSubject

NSLog(@&quot;%s&quot;, class_getName(sub.class));
//获取类名 outprint--&amp;gt; ConcreteSubject

class_getMethodImplementation(cls, @selector(setObj:));
//imp = (IMP)(Foundation`_NSSetObjectValueAndNotify)

class_getMethodImplementation(cls, @selector(class));
//imp = (IMP)(Foundation`NSKVOClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试了一下果然 &lt;code&gt;Class&lt;/code&gt; 被替换了，变成加了 &lt;code&gt;NSKVONotifying_&lt;/code&gt; 前缀的新类。&lt;/p&gt;
&lt;p&gt;新类继承自原类，但是这个类的 &lt;code&gt;class&lt;/code&gt; 方法返回的还是原类，这保证了外部逻辑完整。&lt;/p&gt;
&lt;h3 id=&quot;反编译源码&quot;&gt;反编译源码&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;Runtime&lt;/code&gt; ，我们只能知道 &lt;code&gt;KVO&lt;/code&gt; 使用了一个继承了原类的类，并且替换了原方法的实现，&lt;code&gt;setObj: = _NSSetObjectValueAndNotify&lt;/code&gt; &lt;code&gt;class = _NSKVOClass&lt;/code&gt;。如果我们想进一步了解详情，只能通过反编译 &lt;code&gt;Foundation&lt;/code&gt; 来查找汇编代码。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里我使用了 &lt;code&gt;Hopper&lt;/code&gt; 工具，分析的二进制文件路径是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;替换的实现&quot;&gt;替换的实现&lt;/h3&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
void _NSKVOClass(id self,  SEL _cmd) {
    Class cls = object_getClass(self);
    Class originCls = __NSKVONotifyingOriginalClassForIsa(cls);
    if (cls != originCls) {
        return [originCls class];
    } else {
        Method method = class_getInstanceMethod(cls, _cmd);
        return method_invoke(self, method);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看原 &lt;code&gt;class&lt;/code&gt; 方法，获取了当前类和原类，如果不一致就返回原类，如果一致就执行原 &lt;code&gt;class&lt;/code&gt; 实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
void __NSSetObjectValueAndNotify(id self, SEL _cmd, id value) {
    //获取额外的变量
    void *indexedIvars = object_getIndexedIvars(object_getClass(self));
    //加锁
    pthread_mutex_lock(indexedIvars + 0x20);
    //从SEL获取KeyPath
    NSString *keyPath = [CFDictionaryGetValue(*(indexedIvars) + 0x18), _cmd) copyWithZone:0x0];
    //解锁
    pthread_mutex_unlock(indexedIvars + 0x20);
    
    //改变前发通知
    [self willChangeValueForKey:keyPath];
    //实现Setter方法
    IMP imp = class_getMethodImplementation(*indexedIvars, _cmd);
    (imp)(self, _cmd, value);
    //改变后发通知
    [self didChangeValueForKey:keyPath];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看改变后的 &lt;code&gt;Setter&lt;/code&gt; 方法，其中 &lt;code&gt;indexedIvars&lt;/code&gt; 是原类之外的成员变量，第一个指针是改变后的类，&lt;code&gt;0x20&lt;/code&gt; 的偏移量是线程锁，&lt;code&gt;0x18&lt;/code&gt; 地址储存了改变过的方法字典。&lt;/p&gt;
&lt;p&gt;在执行原方法实现前调用了 &lt;code&gt;willChangeValueForKey&lt;/code&gt; 发起通知，同样在之后调用 &lt;code&gt;didChangeValueForKey&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;添加观察方法&quot;&gt;添加观察方法&lt;/h3&gt;
&lt;p&gt;那么是在哪个方法中替换的实现呢？先看 &lt;code&gt;[NSObject addObserver:forKeyPath:options:context:]&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
void -[NSObject addObserver:forKeyPath:options:context:]
(void * self, void * _cmd, void * arg2, void * arg3, unsigned long long arg4, void * arg5) {
    pthread_mutex_lock(__NSKeyValueObserverRegistrationLock);
    *__NSKeyValueObserverRegistrationLockOwner = pthread_self();
    rax = object_getClass(self);
    rax = _NSKeyValuePropertyForIsaAndKeyPath(rax, arg3);
    [self _addObserver:arg2 forProperty:rax options:arg4 context:arg5];
    *__NSKeyValueObserverRegistrationLockOwner = 0x0;
    pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock);
    
    return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法很简单，根据 &lt;code&gt;KeyPath&lt;/code&gt; 获取具体属性后进一步调用方法。由于这个方法比较长，我特地整理成 &lt;code&gt;ObjC&lt;/code&gt; 代码，方便大家理解。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
- (void *)_addObserver:(id)observer 
           forProperty:(NSKeyValueProperty *)property 
               options:(NSKeyValueObservingOptions)option 
               context:(void *)context {
    //需要注册通知
    if (option &amp;amp; NSKeyValueObservingOptionInitial) {
        //获取属性名路径
        NSString *keyPath = [property keyPath];
        //解锁
        pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock);
        //如果注册了获得新值，就获取数值
        id value = nil;
        if (option &amp;amp; NSKeyValueObservingOptionNew) {
            value = [self valueForKeyPath:keyPath];
            if (value == nil) {
                value = [NSNull null];
            }
        }
        //发送注册通知
        _NSKeyValueNotifyObserver(observer, keyPath, self, context, value, 
        0 /*originalObservable*/, 1 /*NSKeyValueChangeSetting*/);
        //加锁
        pthread_mutex_lock(__NSKeyValueObserverRegistrationLock);
    } 
    //获取属性的观察信息
    Info *info = __NSKeyValueRetainedObservationInfoForObject(self, property-&amp;gt;_containerClass);
    //判断是否需要获取新的数值
    id _additionOriginalObservable = nil;
    if (option &amp;amp; NSKeyValueObservingOptionNew) {
        //0x15没有找到定义，猜测为保存是否可观察的数组

        id tsd = _CFGetTSD(0x15);
        if (tsd != nil) {
            _additionOriginalObservable = *(tsd + 0x10);
        }
    }
    //在原有信息上生成新的信息
    Info *newInfo = __NSKeyValueObservationInfoCreateByAdding
    (info, observer, property, option, context, _additionOriginalObservable, 0, 1);
    //替换属性的观察信息
    __NSKeyValueReplaceObservationInfoForObject(self, property-&amp;gt;_containerClass, info, newInfo);
    //属性添加后递归添加关联属性
    [property object:self didAddObservance:newInfo recurse:true];
    //获取新的isa
    Class cls = [property isaForAutonotifying];
    if ((cls != NULL) &amp;amp;&amp;amp; (object_getClass(self) != cls)) {
        //如果是第一次就替换isa
        object_setClass(self, cls);
    }
    //释放观察信息
    [newInfo release];
    if (info != nil) {
        [info release];
    }
    return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中有可能替换方法实现的步骤是获取 &lt;code&gt;isa&lt;/code&gt; 的时候，猜测当第一次创建新类的时候，会注册新的方法，接着追踪 &lt;code&gt;isaForAutonotifying&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;获取观察类&quot;&gt;获取观察类&lt;/h3&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;void * -[NSKeyValueUnnestedProperty _isaForAutonotifying]
    (void * self, void * _cmd) {
    rbx = self;
    r14 = *_OBJC_IVAR_$_NSKeyValueProperty._containerClass;
    if ([*(rbx + r14)-&amp;gt;_originalClass 
        automaticallyNotifiesObserversForKey:rbx-&amp;gt;_keyPath] != 0x0) {
            r14 = __NSKeyValueContainerClassGetNotifyingInfo(*(rbx + r14));
            if (r14 != 0x0) {
                    __NSKVONotifyingEnableForInfoAndKey(r14, rbx-&amp;gt;_keyPath);
                    rax = *(r14 + 0x8);
            }
            else {
                    rax = 0x0;
            }
    }
    else {
            rax = 0x0;
    }
    return rax;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;立刻发现了熟悉的方法！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;automaticallyNotifiesObserversForKey:&lt;/code&gt; 是一个类方法，如果你不希望某个属性被观察，那么就设为 &lt;code&gt;NO&lt;/code&gt;，&lt;code&gt;isa&lt;/code&gt; 返回是空也就宣告这次添加观察失败。&lt;/p&gt;
&lt;p&gt;如果一切顺利的话，将会执行&lt;code&gt;__NSKVONotifyingEnableForInfoAndKey(info, keyPath)&lt;/code&gt; 改变 &lt;code&gt;class&lt;/code&gt; 的方法，最终返回其 &lt;code&gt;isa&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;实质替换方法&quot;&gt;实质替换方法&lt;/h3&gt;
&lt;p&gt;由于该方法实在太长，且使用了&lt;code&gt;goto&lt;/code&gt;不方便阅读，所以依旧整理成伪代码。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
int __NSKVONotifyingEnableForInfoAndKey(void *info, id keyPath) {
    //线程锁加锁
    pthread_mutex_lock(info + 0x20);
    //添加keyPath到数组
    CFSetAddValue(*(info + 0x10), keyPath);
    //解锁
    pthread_mutex_unlock(info + 0x20);
    //判断原类实现能不能替换
    Class originClass = *info;
    MethodClass *methodClass = 
    __NSKeyValueSetterForClassAndKey(originClass, keyPath, originClass);
    if (![methodClass isKindOfClass:[NSKeyValueMethodSetter class]]) {
        swizzleMutableMethod(info, keyPath);
        return;
    }
    //判断Setter方法返回值
    Method method = [methodClass method];
    if (*(int8_t *)method_getTypeEncoding(method) != _C_VOID) {
        _NSLog(@&quot;KVO autonotifying only supports -set&amp;lt;Key&amp;gt;: methods that return void.&quot;);
        swizzleMutableMethod(info, keyPath);
        return;
    }
    //获取Setter方法参数
    char *typeEncoding = method_copyArgumentType(method, 0x2);
    char type = sign_extend_64(*(int8_t *)typeEncoding);
    SEL sel;//根据参数类型选择替换的方法
    switch (type) {
        case _C_BOOL: sel = __NSSetBoolValueAndNotify;
        case _C_UCHR: sel = __NSSetUnsignedCharValueAndNotify;
        case _C_UINT: sel = __NSSetUnsignedIntValueAndNotify;
        case _C_ULNG: sel = __NSSetUnsignedLongValueAndNotify;
        case _C_ULNG_LNG: sel = __NSSetUnsignedLongLongValueAndNotify;
        case _C_CHR: sel = __NSSetCharValueAndNotify;
        case _C_DBL: sel = __NSSetDoubleValueAndNotify;
        case _C_FLT: sel = __NSSetFloatValueAndNotify;
        case _C_INT: sel = __NSSetIntValueAndNotify;
        case _C_LNG: sel = __NSSetLongValueAndNotify;
        case _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify;
        case _C_SHT: sel = __NSSetShortValueAndNotify;
        case _C_USHT: sel = __NSSetUnsignedShortValueAndNotify;
        case _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify;
        case _C_ID: sel = __NSSetObjectValueAndNotify;
        case &quot;{CGPoint=dd}&quot;: sel = __NSSetPointValueAndNotify;
        case &quot;{_NSRange=QQ}&quot;: sel = __NSSetRangeValueAndNotify;
        case &quot;{CGRect={CGPoint=dd}{CGSize=dd}}&quot;: sel = __NSSetRectValueAndNotify;
        case &quot;{CGSize=dd}&quot;: sel = __NSSetSizeValueAndNotify;
        case *_NSKeyValueOldSizeObjCTypeName: sel = __CF_forwarding_prep_0;
        default;
    }
    //不支持的参数类型打印错误信息
    if (sel == NULL) {
        _NSLog(@&quot;KVO autonotifying only supports -set&amp;lt;Key&amp;gt;: methods that take id,
        NSNumber-supported scalar types, and some NSValue-supported structure types.&quot;)
        swizzleMutableMethod(info, keyPath);
        return;
    }
    //替换方法实现
    SEL methodSel = method_getName(method);
    _NSKVONotifyingSetMethodImplementation(info, methodSel, sel, keyPath);
    if (sel == __CF_forwarding_prep_0) {
        _NSKVONotifyingSetMethodImplementation(info, @selector(forwardInvocation:), 
         _NSKVOForwardInvocation, false);
        Class cls = *(info + 0x8);
        SEL newSel = sel_registerName(&quot;_original_&quot; + sel_getName(methodSel));
        Imp imp = method_getImplementation(method);
        TypeEncoding type = method_getTypeEncoding(method);
        class_addMethod(cls, newSel, imp, type);
    }
    swizzleMutableMethod(info, keyPath);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以表述为根据 &lt;code&gt;Setter&lt;/code&gt; 方法输入参数类型，匹配合适的 &lt;code&gt;NSSetValueAndNotify&lt;/code&gt; 实现来替换，从而实现效果。&lt;/p&gt;
&lt;p&gt;那么 &lt;code&gt;swizzleMutableMethod&lt;/code&gt; 是干嘛的呢？&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//替换可变数组集合的方法
int swizzleMutableMethod(void *info, id keyPath) {
    //NSKeyValueArray
    CFMutableSetRef getterSet = __NSKeyValueMutableArrayGetterForIsaAndKey(*info, keyPath);
    if ([getterSet respondsToSelector:mutatingMethods]) {
        mutatingMethods methodList = [getterSet mutatingMethods];
        replace methodList-&amp;gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify
        replace methodList-&amp;gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify
        replace methodList-&amp;gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify
        replace methodList-&amp;gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify
    }
    //NSKeyValueOrderedSet
    getterSet = __NSKeyValueMutableOrderedSetGetterForIsaAndKey(*info, keyPath);
    if ([getterSet respondsToSelector:mutatingMethods]) {
        mutatingMethods methodList = [getterSet mutatingMethods];
        replace methodList-&amp;gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify
        replace methodList-&amp;gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify
        replace methodList-&amp;gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify
        replace methodList-&amp;gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify
    }
    //NSKeyValueSet
    getterSet = __NSKeyValueMutableSetGetterForClassAndKey(*info, keyPath);
    if ([getterSet respondsToSelector:mutatingMethods]) {
        mutatingMethods methodList = [getterSet mutatingMethods];
        replace methodList-&amp;gt;addObject _NSKVOAddObjectAndNotify
        replace methodList-&amp;gt;intersectSet _NSKVOIntersectSetAndNotify
        replace methodList-&amp;gt;minusSet _NSKVOMinusSetAndNotify
        replace methodList-&amp;gt;removeObject _NSKVORemoveObjectAndNotify
        replace methodList-&amp;gt;unionSet _NSKVOUnionSetAndNotify
    }
    //改变新类的方法缓存
    __NSKeyValueInvalidateCachedMutatorsForIsaAndKey(*(info + 0x8), keyPath);
    return rax;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面提到的都是一对一，那如果我想观察一对多的集合类呢？就是通过 &lt;code&gt;KVC&lt;/code&gt; 中的 &lt;code&gt;mutableArrayValueForKey:&lt;/code&gt; 返回一个代理集合，改变这些代理类的实现做到的。具体的例子之后会介绍。&lt;/p&gt;
&lt;h3 id=&quot;创建新类&quot;&gt;创建新类&lt;/h3&gt;
&lt;p&gt;还有一个疑问就是替换的类是怎么创建的？具体方法在 &lt;code&gt;__NSKVONotifyingEnableForInfoAndKey&lt;/code&gt; 中实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
int __NSKVONotifyingCreateInfoWithOriginalClass(Class cls) {
    //拼接新名字
    const char *name = class_getName(cls);
    int length = strlen(r12) + 0x10;//16是NSKVONotifying_的长度
    char *newName = malloc(length);
    __strlcpy_chk(newName, &quot;NSKVONotifying_&quot;, length, -1);
    __strlcat_chk(newName, name, length, -1);
    //生成一个继承原类的新类
    Class newCls = objc_allocateClassPair(cls, newName, 0x68);
    free(newName);
    if (newCls != NULL) {
        objc_registerClassPair(newCls);
        //获取额外的实例变量表
        void *indexedIvars = object_getIndexedIvars(newCls);
        *indexedIvars = cls;            //记录原isa
        *(indexedIvars + 0x8) = newCls; //记录新isa
        //新建一个集合，保存观察的keyPath
        *(indexedIvars + 0x10) = CFSetCreateMutable(0x0, 0x0, _kCFCopyStringSetCallBacks);
        //新建一个字典，保存改变过的SEL
        *(indexedIvars + 0x18) = CFDictionaryCreateMutable(0x0, 0x0, 0x0,   
                                _kCFTypeDictionaryValueCallBacks);
        //新建一个线程锁
        pthread_mutexattr_init(var_38);
        pthread_mutexattr_settype(var_38, 0x2);
        pthread_mutex_init(indexedIvars + 0x20, var_38);
        pthread_mutexattr_destroy(var_38);
        //获取NSObject类默认的实现
        if (*__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectIMPLookupOnce == NULL) {
            static dispatch_once_t onceToken;
            dispatch_once(&amp;amp;onceToken, ^{
                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange = 
                class_getMethodImplementation([NSObject class],
                @selector(willChangeValueForKey:));

                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange = 
                class_getMethodImplementation([NSObject class], 
                @selector(didChangeValueForKey:));
            });
        }
        //设置是否替换过ChangeValue方法的flag
        BOOL isChangedImp = YES;
        if (class_getMethodImplementation(cls, @selector(willChangeValueForKey:)) == 
        *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange) {
            BOOL isChangedDidImp = 
                class_getMethodImplementation(cls, @selector(didChangeValueForKey:)) 
                != 
                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange;
            isChangedImp = isChangedDidImp ? YES : NO;
        }
        *(int8_t *)(indexedIvars + 0x60) = isChangedImp;
        
        //使用KVO的实现替换原类方法
        _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(_isKVOA),
         _NSKVOIsAutonotifying, false/*是否需要保存SEL到字典*/);

        _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(dealloc), 
         _NSKVODeallocate, false);

        _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(class), 
         _NSKVOClass, false);
    }
    return newCls;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;建立关系&quot;&gt;建立关系&lt;/h3&gt;
&lt;p&gt;还有一种情况就是观察的属性依赖于多个关系，比如 &lt;code&gt;color&lt;/code&gt; 可能依赖于 &lt;code&gt;r g b a&lt;/code&gt;，其中任何一个改变，都需要通知 &lt;code&gt;color&lt;/code&gt; 的变化。&lt;/p&gt;
&lt;p&gt;建立关系的方法是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或 &lt;code&gt;+ (NSSet *)keyPathsForValuesAffecting&amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回依赖键值的字符串集合&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码
+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key {
    char *str = &quot;keyPathsForValuesAffecting&quot; + key;
    SEL sel = sel_registerName(str);
    Method method = class_getClassMethod(self, sel);
    if (method != NULL) {
        result = method_invoke(self, method);
    } else {
        result = [self _keysForValuesAffectingValueForKey:key];
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得之前在 &lt;code&gt;_addObserver&lt;/code&gt; 方法中有这段代码吗？&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//属性添加后递归添加关联属性
[property object:self didAddObservance:newInfo recurse:true];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;NSKeyValueProperty&lt;/code&gt; 也是一个类簇，具体分为 &lt;code&gt;NSKeyValueProperty NSKeyValueComputedProperty NSKeyValueUnnestedProperty NSKeyValueNestedProperty&lt;/code&gt;，从名字也看出 &lt;code&gt;NSKeyValueNestedProperty&lt;/code&gt; 是指嵌套子属性的属性类，那我们观察下他的实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码
- (void)object:(id)obj didAddObservance:(id)info recurse:(BOOL)isRecurse {
    if (self-&amp;gt;_isAllowedToResultInForwarding != nil) {
        //获得关系键
        relateObj = [obj valueForKey:self-&amp;gt;_relationshipKey];
        //注册所有关系通知
        [relateObj addObserver:info 
                    forKeyPath:self-&amp;gt;_keyPathFromRelatedObject 
                       options:info-&amp;gt;options 
                       context:nil];
    } 
    //再往下递归
    [self-&amp;gt;_relationshipProperty object:obj didAddObservance:info recurse:isRecurse];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，实现的大致整体轮廓比较了解了，下面会讲一下怎么把原理运用到实际。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;应用原理&quot;&gt;应用原理&lt;/h2&gt;
&lt;h3 id=&quot;手动触发&quot;&gt;手动触发&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&lt;/code&gt; 返回是 &lt;code&gt;YES&lt;/code&gt;，那么注册的这个 &lt;code&gt;Key&lt;/code&gt; 就会替换对应的 &lt;code&gt;Setter&lt;/code&gt; ，从而在改变的时候调用 &lt;code&gt;-(void)willChangeValueForKey:(NSString *)key&lt;/code&gt; 与 &lt;code&gt;-(void)didChangeValueForKey:(NSString *)key&lt;/code&gt; 发送通知给观察者。&lt;/p&gt;
&lt;p&gt;那么只要把自动通知设为 &lt;code&gt;NO&lt;/code&gt;，并代码实现这两个通知方法，就可以达到手动触发的要求。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {
    if ([key isEqualToString:@&quot;object&quot;]) {
        return false;
    }
    
    return [super automaticallyNotifiesObserversForKey:key];
}

- (void)setObject:(NSObject *)object {
    if (object != _object) {
        [self willChangeValueForKey:@&quot;object&quot;];
        _object = object;
        [self didChangeValueForKey:@&quot;object&quot;];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果操作的是之前提到的集合对象，那么实现的方法就需要变为&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)willChange:(NSKeyValueChange)changeKind 
   valuesAtIndexes:(NSIndexSet *)indexes 
            forKey:(NSString *)key;
- (void)didChange:(NSKeyValueChange)changeKind 
  valuesAtIndexes:(NSIndexSet *)indexes 
           forKey:(NSString *)key;

- (void)willChangeValueForKey:(NSString *)key 
              withSetMutation:(NSKeyValueSetMutationKind)mutationKind 
                 usingObjects:(NSSet *)objects;
- (void)didChangeValueForKey:(NSString *)key 
             withSetMutation:(NSKeyValueSetMutationKind)mutationKind 
                usingObjects:(NSSet *)objects;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依赖键观察&quot;&gt;依赖键观察&lt;/h3&gt;
&lt;p&gt;之前也有提过构建依赖关系的方法，具体操作如下&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;+ (NSSet&amp;lt;NSString *&amp;gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key {
    if ([key isEqualToString:@&quot;color&quot;]) {
        return [NSSet setWithObjects:@&quot;r&quot;,@&quot;g&quot;,@&quot;b&quot;,@&quot;a&quot;,nil];
    }
    
    return [super keyPathsForValuesAffectingValueForKey:key];
}

//建议使用静态指针地址作为上下文区分不同的观察
static void * const kColorContext = (void*)&amp;amp;kColorContext;
- (void)viewDidLoad {
    [super viewDidLoad];

    [self addObserver:self forKeyPath:@&quot;color&quot; 
              options:NSKeyValueObservingOptionNew 
              context:kColorContext];
    self.r = 133;
}

- (void)observeValueForKeyPath:(NSString *)keyPath 
                      ofObject:(id)object 
                        change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change 
                       context:(void *)context {
    if (context == kColorContext) {
        NSLog(@&quot;%@&quot;, keyPath); 
        //outprint --&amp;gt; color
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可变数组与集合&quot;&gt;可变数组与集合&lt;/h3&gt;
&lt;p&gt;不可变的数组与集合由于内部结构固定，所以只能通过观察容器类内存地址来判断是否变化，也就是 &lt;code&gt;NSKeyValueChangeSetting&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;集合和数组的观察都很类似，我们先关注如果要观察可变数组内部插入移除的变化呢？&lt;/p&gt;
&lt;p&gt;先了解一下集合代理方法，&lt;code&gt;- (NSMutableArray *)mutableArrayValueForKey:&lt;/code&gt;，这是一个 &lt;code&gt;KVC&lt;/code&gt; 方法，能够返回一个可供观察的 &lt;code&gt;NSKeyValueArray&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;根据苹果注释，其搜索顺序如下&lt;/p&gt;
&lt;p&gt;1.搜索是否实现最少一个插入与一个删除方法&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;-insertObject:in&amp;lt;Key&amp;gt;AtIndex:
-removeObjectFrom&amp;lt;Key&amp;gt;AtIndex:
-insert&amp;lt;Key&amp;gt;:atIndexes:
-remove&amp;lt;Key&amp;gt;AtIndexes:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.否则搜索是否有 &lt;code&gt;set&amp;lt;Key&amp;gt;:&lt;/code&gt; 方法，有的话每次都把修改数组重新赋值回原属性。&lt;/p&gt;
&lt;p&gt;3.否则检查 &lt;code&gt;+ (BOOL)accessInstanceVariablesDirectly&lt;/code&gt;，如果是&lt;code&gt;YES&lt;/code&gt;，就查找成员变量&lt;code&gt;_&amp;lt;key&amp;gt; or &amp;lt;key&amp;gt;&lt;/code&gt;，此后所有的操作针对代理都转接给成员变量执行。&lt;/p&gt;
&lt;p&gt;4.最后进入保护方法&lt;code&gt;valueForUndefinedKey:&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一种方法&quot;&gt;第一种方法&lt;/h4&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)insertObject:(NSObject *)object inDataArrayAtIndex:(NSUInteger)index {
    [_dataArray insertObject:object atIndex:index];
}

- (void)removeObjectFromDataArrayAtIndex:(NSUInteger)index {
    [_dataArray removeObjectAtIndex:index];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    
    _dataArray = @[].mutableCopy;
    [self addObserver:self forKeyPath:@&quot;dataArray&quot; 
    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld |  
    NSKeyValueObservingOptionPrior context:nil];
    [self insertObject:@1 inDataArrayAtIndex:0];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实现了&lt;code&gt;insert&lt;/code&gt;与&lt;code&gt;remove&lt;/code&gt;方法，使得代理数组能够正常运作数组变量，&lt;code&gt;KVO&lt;/code&gt; 观察了代理数组的这两个方法，发出了我们需要的通知。&lt;/p&gt;
&lt;p&gt;这种方式使用了第一步搜索，比较容易理解，缺点是改动的代码比较多，改动数组必须通过自定义方法。&lt;/p&gt;
&lt;h4 id=&quot;第二种方法&quot;&gt;第二种方法&lt;/h4&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;@property (nonatomic, strong, readonly) NSMutableArray *dataArray;

@synthesize dataArray = _dataArray;

- (NSMutableArray *)dataArray {
    return [self mutableArrayValueForKey:@&quot;dataArray&quot;];
}

- (void)viewDidLoad {
    [super viewDidLoad];

    _dataArray = @[].mutableCopy;
    [self addObserver:self forKeyPath:@&quot;dataArray&quot; 
    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld |   
    NSKeyValueObservingOptionPrior context:nil];
    [self.dataArray addObject:@1];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式相对来说更简洁，修改数组的方法与平时一致，比较适合使用。&lt;/p&gt;
&lt;p&gt;下面说一下原理，首先我们没有实现对应的&lt;code&gt;insert&lt;/code&gt;与&lt;code&gt;remove&lt;/code&gt;方法，其次&lt;code&gt;readonly&lt;/code&gt;属性也没有&lt;code&gt;set&amp;lt;key&amp;gt;:&lt;/code&gt;方法，但我们实现了 &lt;code&gt;@synthesize dataArray = _dataArray;&lt;/code&gt; 所以根据第三步对代理数组的操作都会实际操作到实例变量中。&lt;/p&gt;
&lt;p&gt;然后重载了 &lt;code&gt;dataArray&lt;/code&gt; 的 &lt;code&gt;Getter&lt;/code&gt; 方法，保证了修改数组时必须调用主体是&lt;code&gt;self.dataArray&lt;/code&gt;，也就是代理数组，从而发送通知。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;问答&quot;&gt;问答&lt;/h2&gt;
&lt;h3 id=&quot;kvo的底层实现&quot;&gt;KVO的底层实现？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 就是通过 &lt;code&gt;Runtime&lt;/code&gt; 替换被观察类的 &lt;code&gt;Setter&lt;/code&gt; 实现，从而在发生改变时发起通知。&lt;/p&gt;
&lt;h3 id=&quot;如何取消系统默认的kvo并手动触发给kvo的触发设定条件改变的值符合某个条件时再触发kvo&quot;&gt;如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？&lt;/h3&gt;
&lt;p&gt;通过设置 &lt;code&gt;automaticallyNotifiesObserversForKey&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; 实现取消自动触发。&lt;/p&gt;
&lt;p&gt;符合条件再触发可以这么实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)setObject:(NSObject *)object {
    if (object == _object) return;

    BOOL needNotify = [object isKindOfClass:[NSString class]];
    if (needNotify) {
        [self willChangeValueForKey:@&quot;object&quot;];    
    }
    _object = object;
    if (needNotify) {
        [self didChangeValueForKey:@&quot;object&quot;];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;由于对汇编语言、反编译工具、&lt;code&gt;objc4&lt;/code&gt;开源代码的不熟悉，这篇文章写了一周时间，结构也有点混乱。&lt;/p&gt;
&lt;p&gt;所幸还是理顺了整体结构，在整理的过程中学会了很多很多。&lt;/p&gt;
&lt;p&gt;由于才疏学浅，其中对汇编和源码的解释难免出错，还望大佬多多指教！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;资料分享&quot;&gt;资料分享&lt;/h2&gt;
&lt;p&gt;ObjC中国的期刊 &lt;a href=&quot;https://objccn.io/issue-7-3/&quot;&gt;KVC和KVO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;杨大牛的 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/&quot;&gt;Objective-C中的KVC和KVO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/45cbd324ea65&quot;&gt;iOS开发技巧系列---详解KVC(我告诉你KVC的一切)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 14:52:00 +0000</pubDate>
<dc:creator>Vanch</dc:creator>
<og:description>介绍 KVO( )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改被观察者代码，利用 实现运行中修改某一实例达到目的，保证了未侵入性。 A对象指定观察B对象的属性后，当属性发生变更，A对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vanch/p/9795279.html</dc:identifier>
</item>
<item>
<title>让我头疼一下午的Excel合并单元格 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/excel_export.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/excel_export.html</guid>
<description>&lt;h3 id=&quot;excel导出常见问题&quot;&gt;Excel导出常见问题&lt;/h3&gt;
&lt;p&gt;excel导出其实不算什么难事&lt;/p&gt;
&lt;p&gt;在网上copy下模板代码，填充自己的业务数据，提供一个http接口基本就可以得到你要导出的数据了。&lt;/p&gt;
&lt;p&gt;但是，凡事都有例外，截止今天，excel导出我遇到的主要是两大类问题&lt;/p&gt;
&lt;p&gt;1、大数据量的excel数据，比如几十万条甚至更多的数据导出&lt;/p&gt;
&lt;p&gt;2、因为excel中内容的问题，导致导出后的excel不能直接打开，报错“由于一些内容不可取，Excel无法打开xxx.xlsx。是否要打开并修复此工作簿?”&lt;/p&gt;
&lt;p&gt;针对第一种大数据量问题，我遇到的主要问题是excel存储的记录上限和导出超时等问题&lt;/p&gt;
&lt;p&gt;解决方法是将导出格式为xls升级为xlsx，xls每个sheet最多支持65536条记录，xlsx最多支持1048576条记录；超时则可以采用前端直接返回，后端异步取数据并导出的方式避免超时。&lt;/p&gt;
&lt;p&gt;这种情况不是今天要介绍的重点，今天要介绍的第二种情况的解决思路。&lt;/p&gt;
&lt;h3 id=&quot;需求描述&quot;&gt;需求描述&lt;/h3&gt;
&lt;p&gt;1、层级关系最多为四级&lt;/p&gt;
&lt;p&gt;2、对于相同层级,如果内容相同需要纵向合并单元格，空白行不需要合并&lt;/p&gt;
&lt;p&gt;3、样例数据如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
一级目录1,二级目录1,三级目录1,四级目录2,

一级目录1,二级目录1,三级目录3,

一级目录1,二级目录1,三级目录5,

一级目录1,二级目录3,

一级目录1,二级目录5,三级目录5,

一级目录2,二级目录2,三级目录2,

一级目录2,二级目录2,三级目录3,

一级目录2,二级目录4,三级目录4,

一级目录2,二级目录7,

一级目录3,二级目录6,三级目录4,

一级目录3,二级目录6,三级目录10,

一级目录4,

一级目录5,二级目录8,三级目录6,
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解决思路&quot;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;将上面样例数据存入一个集合中，遍历每条记录并存放到相应的单元格。&lt;/p&gt;
&lt;p&gt;如果不需要合并单元格，到这里，就可以提供导出的Excel了。&lt;/p&gt;
&lt;p&gt;但是重点是合并单元格。&lt;/p&gt;
&lt;h3 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h3&gt;
&lt;h4 id=&quot;初步排查&quot;&gt;初步排查&lt;/h4&gt;
&lt;p&gt;自认为代码已经就位，调用接口，Excel文件也成功下载了，结果打开的那一刻一个对话框让我头疼了一下午。&lt;/p&gt;
&lt;p&gt;报错信息如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222634536-1927134110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一反应是肯定数据错乱了，估计是单元格之间相互挤占，数据肯定也是不堪入目。&lt;/p&gt;
&lt;p&gt;但是我按照智能的Excel提示，点击“打开并修复”后发现，数据没有我想的那么糟，甚至仔细看看，发现居然没有问题。&lt;/p&gt;
&lt;p&gt;有点小激动的同时，心里还是有点不爽，总不能让别人每次导出的时候都使用这个智能的“打开并修复”功能才能看导出的数据吧。&lt;/p&gt;
&lt;p&gt;但是光从这个报错信息来看确实没有什么线索，于是网上找了一通与“由于一些内容不可取，Excel无法打开xxx.xlsx。是否要打开并修复此工作簿?”有关的解决方法。虽然有不少人遇到过这样的问题，但是引起问题的原因不太一样，有些是因为sheet的命名包含特殊字符，有些是导出的Excel内容中有非法字符，还有说要在response的header中加入Content-length字段的。&lt;/p&gt;
&lt;h4 id=&quot;进一步排查&quot;&gt;进一步排查&lt;/h4&gt;
&lt;p&gt;搜了一通，没有什么进展，这时候想起来在刚刚点击“打开并修复”后，还弹出了一个对话框，于是点击对话框中的查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222643403-1930663000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到线索如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;

&amp;lt;recoveryLog xmlns=&quot;http://schemas.openxmlformats.org/spreadsheetml/2006/main&quot;&amp;gt;&amp;lt;logFileName&amp;gt;修复结果到 xxx.xml&amp;lt;/logFileName&amp;gt;&amp;lt;summary&amp;gt;在文件“/Users/jackie/Downloads/xxx.xlsx”中检测到错误&amp;lt;/summary&amp;gt;&amp;lt;removedRecords summary=&quot;以下是已删除记录的列表:&quot;&amp;gt;&amp;lt;removedRecord&amp;gt;已删除的记录: /xl/worksheets/sheet1.xml 的 合并单元格&amp;lt;/removedRecord&amp;gt;&amp;lt;/removedRecords&amp;gt;&amp;lt;/recoveryLog&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;排除了前面提到的种种非法字符的原因，看到线索里的“合并单元格”，基本可以断定这是因为在合并单元格的过程中出了问题。&lt;/p&gt;
&lt;h4 id=&quot;寻找问题根本原因&quot;&gt;寻找问题根本原因&lt;/h4&gt;
&lt;p&gt;结合合并单元格导致Excel表格无法打开的症状在网上搜索一通&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/14/0107/11/14931240_343269914.shtml%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%99%E5%87%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF&quot; class=&quot;uri&quot;&gt;http://www.360doc.com/content/14/0107/11/14931240_343269914.shtml这篇文章给出了解决思路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我将下载的Excel表格的后缀从xlsx改为zip并打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222652560-1495620231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开sheet1.xml文件，找到mergeCells标签，将其内容拷贝到XML在线格式化工具中查看&lt;/p&gt;
&lt;p&gt;经过人眼搜索，终于发现了问题所在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222700492-320280183.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    ...

    &amp;lt;mergeCell ref=&quot;B175:B189&quot;/&amp;gt;

    &amp;lt;mergeCell ref=&quot;B176:B190&quot;/&amp;gt;

    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里显然出现了&lt;strong&gt;覆盖合并&lt;/strong&gt;的情况，进而导致打开Excel报错的情况（后面经过测试发现，重复合并单元格也会出现同样的报错信息）&lt;/p&gt;
&lt;p&gt;顺着这个思路，排查代码，不断调试测试，考虑各种情况下的合并单元格场景，最终搞定了这个稍稍复杂的合并单元格的Excel导出功能。&lt;/p&gt;
&lt;h3 id=&quot;一点思考&quot;&gt;一点思考&lt;/h3&gt;
&lt;p&gt;虽然知道是合并单元格导致的问题，但是在实际调整代码时花费了几乎一个下午，曾经一度头大到不想思考。&lt;/p&gt;
&lt;p&gt;回头想想，在这个问题上有两大收获。&lt;/p&gt;
&lt;p&gt;1、排查问题的思路很重要&lt;/p&gt;
&lt;p&gt;问题的现象已经摆在眼前，排查了不是非法字符的原因，就应该寻找其他原因&lt;/p&gt;
&lt;p&gt;利用一切可以利用的手头信息比如上面简短而关键的报错日志信息。&lt;/p&gt;
&lt;p&gt;活用搜索引擎，这种问题肯定已经有前人踩过雷，去看下他们是怎么排雷的就好，不用自己再去研究排雷的具体方法了。&lt;/p&gt;
&lt;p&gt;2、写代码之前先想好&lt;/p&gt;
&lt;p&gt;现在想想这段合并单元格的代码是不是可以写的更加漂亮，我想应该是可以的，但是能不能从30行精简为10行甚至5行，我想这不太可能。&lt;/p&gt;
&lt;p&gt;因为这个导出合并时会遇到各种情况，比如连续相同的单元格何时合并，空白行如何保证不合并，某空白行区域前和后又如何实现合并等问题。&lt;/p&gt;
&lt;p&gt;所以，写这段代码前应该先梳理所有可能的场景包括一些特殊情况，尽其所能罗列所有的情况，这样才能保证在应对各种情形的数据时正常导出。&lt;/p&gt;
&lt;p&gt;代码稍后我会放到项目rome里&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/DMinerJackie/rome&quot; class=&quot;uri&quot;&gt;https://github.com/DMinerJackie/rome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对了，导出效果图呈上&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222716347-1419281418.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>Excel表格导出过很多次，这次栽倒在合并单元格手上，只好硬着头皮老老实实找出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/excel_export.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之八 ----- 责任链模式和命令模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9794886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9794886.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9704228.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了结构型模式的享元模式和代理模式。本篇则来学习下行为型模式的两个模式， 责任链模式(Chain of Responsibility Pattern)和命令模式（Command Pattern）。&lt;/p&gt;
&lt;h2 id=&quot;责任链模式&quot;&gt;责任链模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;责任链模式顾名思义，就是为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的理解的话就是进行层级处理。生活中比较常见的是请假、出差、加薪等申请等等，而工作中比较常见的就是拦截器和过滤器。如果请假申请是用以前的那种方式，发起者需要和每个负责人进行申请，会比较麻烦，但是现在一般是走OA流程，只需发起一个OA申请即可。这也是一种 这种就是典型的责任链模式，发起者只需将请求请求发送到职责链上即可，无需关心处理细节和请求的传递。&lt;/p&gt;
&lt;p&gt;责任链模式主要由这三个角色组成，请求接收者接口(Handler)、请求实现者类(ConcreteHandler)和请求发送者(Client)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求接收者接口：定义可以处理客户端请求事项的接口，包含“可链接下一个同样能处理请求”的对象引用。&lt;/li&gt;
&lt;li&gt;请求实现者类：实现请求处理接口，并判断对象本身是否能够处理本次请求，如果不能完成请求，则交由后继者来处理。&lt;/li&gt;
&lt;li&gt;请求发送者：将请求发送给第一个接收者对象，并等待请求的回复。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里为了方便理解，我们使用一个简单的示例来加以说明。&lt;br/&gt;在某公司的某个部门中，为了活跃部门气氛，主管便征求部门成员的意见，于是部门的成员踊跃提出建议，最终，主管采纳了 xuwujing 提倡的建议，并将此建议进行上报，申请活动经费。&lt;br/&gt;那么我们便可以根据这里例子来使用责任链模式进行开发，首先加速有三级的领导，他们有个共同的特性，就是可以处理各自级别的事情，那么我们便可以定义一个领导的抽象类，并定义一个抽象方法可以处理事情，并设置一个级别的参数，那么这个抽象类的代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
abstract class Learder{

   protected Learder learder;
   
   protected void setLearder(Learder learder){
       this.learder=learder;
   }
   
   protected Learder getLearder(){
       return learder;
   }
   
   abstract void handler(int  level);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义好该抽象类之后，我们需要设计不同的领导进行不同的处理，但是这些领导需要有个处理的能力，并且还要根据各自不同的权限进行处理，如果能够处理，到此流程就结束了，否则无法处理则转交给上级进行处理。&lt;br/&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Supervisor extends Learder{
    private String name;
    private String something;
    public Supervisor(String name,String something) {
       this.name=name;
       this.something=something;
   }
   
   @Override
   void handler(int level) {
       //如果级别在自己的处理范围之内
       if(level&amp;gt;1){
           System.out.println(&quot;主管同意了  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
       }else{
           System.out.println(&quot;主管未能处理  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!转交给上级!&quot;);
           getLearder().handler(level);
       }
   }
}


class BranchManager extends Learder{
    private String name;
    private String something;
    public BranchManager(String name,String something) {
       this.name=name;
       this.something=something;
   }
   
   @Override
   void handler(int level) {
       boolean flag=true;
       //如果级别在自己的处理范围之内
       if(level&amp;gt;0){
           //这就就直接设置同意了
           if(flag){
               System.out.println(&quot;部门经理同意了  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }else{
               System.out.println(&quot;部门经理不同意  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }
       }else{
           System.out.println(&quot;部门经理未能处理  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!转交给上级!&quot;);
           getLearder().handler(level);
       }
   }
}


class GeneralManager extends Learder{
    private String name;
    private String something;
    public GeneralManager(String name,String something) {
       this.name=name;
       this.something=something;
   }
   
   @Override
   void handler(int level) {
       boolean flag=false;
       //如果级别在自己的处理范围之内
       if(level&amp;gt;-1){
           //这就就直接设置不同意了
           if(flag){
               System.out.println(&quot;总经理同意了  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }else{
               System.out.println(&quot;总经理不同意  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }
           
       }else{
           System.out.println(&quot;总经理未能处理  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!转交给上级!&quot;);
           getLearder().handler(level);
       }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们再来根据所需要走的流程来进行代码测试。由于在编写请求类时，我们并未指定谁是谁的上级，所以这里我们需要指定上下级关系，让流程能够走下去。指定上级之后，我们再来设置处理该事件的级别，最后再来进行运行。&lt;br/&gt;那么测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
       String name = &quot;xuwujing&quot;;
       String something = &quot;去聚餐&quot;;
       String something2 = &quot;去旅游&quot;;
       Learder learder1 =new Supervisor(name, something);
       Learder learder2 =new BranchManager(name, something);
       Learder learder3 =new GeneralManager(name, something);
       learder1.setLearder(learder2);
       learder2.setLearder(learder3);
       learder1.handler(1);
       
       Learder learder4 =new Supervisor(name, something2);
       Learder learder5 =new BranchManager(name, something2);
       Learder learder6 =new GeneralManager(name, something2);
       learder4.setLearder(learder5);
       learder5.setLearder(learder6);
       learder4.handler(0);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        主管未能处理  xuwujing所述的&amp;lt;去聚餐&amp;gt;事情!转交给上级!
        部门经理同意了  xuwujing所述的&amp;lt;去聚餐&amp;gt;事情!
        主管未能处理  xuwujing所述的&amp;lt;去旅游&amp;gt;事情!转交给上级!
        部门经理未能处理  xuwujing所述的&amp;lt;去旅游&amp;gt;事情!转交给上级!
        总经理不同意  xuwujing所述的&amp;lt;去旅游&amp;gt;事情!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;责任链模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;耦合度低，请求者和执行者并没有必然的联系；&lt;br/&gt;灵活度高，可以通过内部成员来进行更改它们执行的次序；&lt;br/&gt;扩展性好，Handler的子类扩展非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;责任链模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;会在某程度上降低程序的性能，设置不当的话可能会出现循环调用。&lt;br/&gt;在链过长时，会降低代码的阅读性以及增加代码的复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要动态指定处理某一组请求时，在不确定接受者的的情况下，向多个对象发送请求时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然责任链模式很灵活，但是牺牲的是一定的性能，因为责任链模式是层级处理，在处理数据的有一定的延迟，所所以需要低延迟的情况下，不推荐使用责任链模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;命令模式&quot;&gt;命令模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令模式顾名思义，是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;br/&gt;也就是将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令模式主要由这三个角色组成，命令对象(command)、命令执行对象(received)和命令请求对象(invoker)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令对象：通过接口或抽象类声明实现的方法。&lt;/li&gt;
&lt;li&gt;命令执行对象：实现命令对象的方法，并将一个接收者和动作进行绑定，调用接收者相应的操作。&lt;/li&gt;
&lt;li&gt;命令请求对象：用于执行这个请求，可以动态的对命令进行控制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们依旧用一个简单的示例来进行说明。&lt;br/&gt;在某个学校中，学生需要听从老师的命令，比如老师可以让学生去打扫教室卫生，去完成未做完的作业等等命令，但是学生的时间有限，只能在某个时间范围内完成某一件事情，此时刚好有两个老师对学生 xuwujing 说出了命令，李老师先让 xuwujing 在放学后打扫教室，王老师让 xuwujing 在回家前把未做完的作业做完并交给他，但是学校的门禁的时间有限，于是 xuwujing 就只 打扫了教室，然后开溜了。。。&lt;br/&gt;那么根据这个示例，我们可以使用命令模式来完成。&lt;br/&gt;首先，先定义一个学生类，并指定该学生可以做的事情。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Student{
    void cleanClassRoom(String name){
        System.out.println(name+&quot; 开始打扫教室...&quot;);
    }
    void doHomeWork(String name){
        System.out.println(name+&quot; 开始做作业...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义一个 命令抽象类，并设置执行的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
abstract class Command{
    protected Student student;
    public Command(Student student){
        this.student = student;
    }
    abstract void execute(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继而再定义两个命令执行对象，分别设置所需执行的命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class LiTeacher extends Command{
    public LiTeacher(Student student) {
        super(student);
    }
    @Override
    void execute(String name) {
        student.cleanClassRoom(name);
    }
}

class WangTeacher extends Command{
    public WangTeacher(Student student) {
        super(student);
    }
    @Override
    void execute(String name) {
        student.doHomeWork(name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来定义一个命令请求对象，用于执行该请求，并对命令进行控制，比如新增命令、撤销命令和执行命令等等。&lt;br/&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Invoker {
    private List&amp;lt;Command&amp;gt; commands = new ArrayList&amp;lt;Command&amp;gt;();
    
    public void setCommand(Command command) {
        if(commands.size()&amp;gt;0) {
            System.out.println(&quot;不执行 WangTeacher 的命令!&quot;);
        }else {
            commands.add(command);
        }
    }
    
    public void executeCommand(String name) {
        commands.forEach(command-&amp;gt;{
            command.execute(name);
        });
    }
    
    public void undoCommand(Command command) {
        commands.remove(command);
        System.out.println(&quot;撤销该命令!&quot;);
    }   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来进行代码的测试。&lt;br/&gt;测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
        String name = &quot;xuwujing&quot;;
        Student student = new  Student();
        Command command1 = new LiTeacher(student);
        Command command2 = new WangTeacher(student);
        Invoker invoker =new Invoker();
        invoker.setCommand(command1);
        invoker.setCommand(command2);
        invoker.executeCommand(name);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不执行 WangTeacher 的命令!
xuwujing 开始打扫教室...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;命令模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;耦合度低，请求者和执行者并没有必然的联系；&lt;br/&gt;扩展性好，Command的子类可以非常容易地扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果命令过多的话，会增加系统的复杂度 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果在有类似&lt;code&gt;命令&lt;/code&gt;需要指定的，就可以用命令模式，比如记录日志、撤销操作命令等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;分享一首很轻快的轻音乐！&lt;/p&gt;

&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: https://github.com/xuwujing/java-study&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 13:35:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9794886.html</dc:identifier>
</item>
<item>
<title>一步步实现windows版ijkplayer系列文章之四——windows下编译ijkplyer版ffmpeg - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/9794811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/9794811.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9569960.html&quot;&gt;一步步实现windows版ijkplayer系列文章之一——Windows10平台编译ffmpeg 4.0.2，生成ffplay&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9681643.html&quot;&gt;一步步实现windows版ijkplayer系列文章之二——Ijkplayer播放器源码分析之音视频输出——视频篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9693983.html&quot;&gt;一步步实现windows版ijkplayer系列文章之三——Ijkplayer播放器源码分析之音视频输出——音频篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9794811.html&quot;&gt;一步步实现windows版ijkplayer系列文章之四——windows下编译ijkplyer版ffmpeg&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ijkplayer版本ffmpeg源码说明&quot;&gt;ijkplayer版本ffmpeg源码说明&lt;/h2&gt;
&lt;p&gt;ijkplayer使用了ffmpeg 3.4 release(接下来将此版本ffmpeg叫做ijkplayer-ffmpeg)，ijkplayer fork版本最后一个官方的commit详细信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;提交：
01e291a592452f27b3a4e811536aaaf94096e244 [01e291a]
父级：
03351cce88
作者：
Mark Thompson &amp;lt;sw@jkqxz.net&amp;gt;
日期：
2017年10月15日 GMT+8 下午7:45:15&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ijkplayer团队在此基础上做了不少的改动，同时官方的3.4 release也在做更新，最近的一个3.4小版本release是3.4.4，时间在2018年7月18号。把ijkplayer的FFmpeg fork版本拿到windows下面编译一直编译不过，拿官方的3.4最新代码却能编译成功，所以首先需要把两个branch进行一下merge。&lt;/p&gt;
&lt;h2 id=&quot;merge-ijkplayer-ffmpeg-到-ffmpeg3.4.4&quot;&gt;merge Ijkplayer-ffmpeg 到 ffmpeg3.4.4&lt;/h2&gt;
&lt;p&gt;ijkplayer-ffmpeg fork自 官方的&lt;a href=&quot;https://github.com/FFmpeg/FFmpeg&quot;&gt;ffmpeg&lt;/a&gt;，ijkplayer-ffmpeg可以提交pull request到官方ffmpeg，这不是我们自己能控制的。网上搜索了相关的资料，git如此强大，可以对两个fork的branch进行『移花接木』，现将过程记录如下：&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li&gt;github上将官方ffmpeg fork一份到自己的账户。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在本地将ijkplayer-ffmpeg仓库clone下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; https://github.com/Bilibili/FFmpeg.git&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;跳转到ijkplayer-ffmpeg 根目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; cd root_path_of_ijkplayer-ffmpeg&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将ijkplayer指定的tag检出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git checkout ff3.4--ijk0.8.7--20180103--001 -B ijkplayer       &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;删除本地仓库的origin部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote rm origin&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将官方ffmpeg origin添加到本地ijkplayer-ffmpeg：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote add origin https://github.com/harlanc/FFmpeg.git&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重命名本地branch ijkplayer&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git branch -m ijkplayer-temp&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将更新后的远端仓库拉取到本地：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git fetch&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将官方ffmpeg的3.4.4版本检出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git checkout n3.4.4 -B ijkplayer&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后将ijkplayer-temp merge到官方ffmpeg n3.4.4中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git merge ijkplayer-temp  &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终的结果没有冲突，直接将代码commit和push即可。&lt;/p&gt;
&lt;h2 id=&quot;在wingw中编译ijkplayer-ffmpeg&quot;&gt;在WinGW中编译ijkplayer-ffmpeg&lt;/h2&gt;
&lt;p&gt;将merge后的branch拷贝到windows环境中，同前面介绍的编译ffmpeg4.0.2一样进行编译，发现ijkplayer更新的ffmpeg代码存在不少问题，有一些bug，也有的缺失了windows部分的代码，做了一些改动，也有可能有问题，但最后编译通过了（具体可以看我的&lt;a href=&quot;https://github.com/harlanc/FFmpeg/tree/ijkplayer&quot;&gt;github&lt;/a&gt;）。ijkplayer-ffmpeg的android平台下，最终ffmpeg部分是生成了一个so动态库，libijkffmpeg.so，而且这个库还很小。使用ffmpeg的configure编译出来后是很多的dll和lib，想像ijkplayer一样将需要的.o文件打包成一个动态库，最后没有成功，先继续往前走吧，最关键的部分还没到，朝目标又近了一步，加油。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/msrose/2feacb303035d11d2d05&quot;&gt;Combining two git repositories&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 13:22:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/9794811.html</dc:identifier>
</item>
<item>
<title>你所要掌握的最简单基础的React渲染优化 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9794292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9794292.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、React的渲染机制&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;要掌握一两项React-render优化的方法不难,但是非常重要.无论是在实际项目中的一个小细节,还是迎合'面试官'的口味
&lt;h4&gt;&lt;span&gt;1.1 触发Render&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们知道React要更新视图,必须要触发Render.而这往往是影响性能最重要的一步(因为操作了dom).而React之所以这么出色,正是因为占其主导地位的diff算法采用了虚拟DOM(React V-dom),使得渲染性能大大提升。&lt;/p&gt;
&lt;p&gt;即便如此,我们在开发的时候也应该要注意一些性能的优化,比如&lt;strong&gt;避免无意义的render&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么,触发render的条件有哪些呢?&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首次加载组件&lt;/li&gt;
&lt;li&gt;使用了setState(更新了Props)&lt;/li&gt;
&lt;li&gt;Props更新了(父级传给子级的值改变了)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们完全可以避免2.3情况导致的一些性能问题&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.2 React Diff&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;虽然说React高效的Diff算法完美结合了虚拟DOM,让用户可以'无限制'刷新而不需要考虑任何性能问题.&lt;br/&gt;但diff算法还是需要一定的时间,如果你不在意触发render的细节,项目模块大了起来,自然就会影响性能了.&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.3 不做任何优化的例子&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我尝试着从实现以下功能:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不更新state的值,但是调用了&lt;code&gt;setState&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;传给子级的值不改变,即子级props实际上是没变化的&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 父级.js
import React from 'react'
import MockChild from './child/index.js'
export default class Demo5 extends React.Component{
    constructor(args){
        super(args)
        
        this.state = {
            'mockNum': 0
        }
    }
    handleClick(){
        this.setState({
            'mockNum': 0,
        })
    }
    render(){
        console.log('父级state ==============&amp;gt;', this.state)
        return(
            &amp;lt;div&amp;gt;
                &amp;lt;button onClick={this.handleClick.bind(this)}&amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;MockChild  mockNum={this.state.mockNum}/&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}

//子组件
render(){
    console.log('子级Props =============&amp;gt;', this.props)
    return(
        &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们反复点击按钮,虽然state的值并没有任何变化,但是我们看打印的结果！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015191747211-1249888166.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;render重复渲染了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能会疑问,我在项目并不会做这么一种无用功的！但实际上,当一个组件逻辑复杂起来之后,会产生各种各样的情况.比如:&lt;/p&gt;
&lt;p&gt;比如一个组件的中有个包含&lt;strong&gt;onChange&lt;/strong&gt;事件的&lt;code&gt;input&lt;/code&gt;,当我改变该输入框内容的时候调用了&lt;code&gt;setState&lt;/code&gt;,渲染视图的时候也会触发子组件的重新render.但我们明明没有做任何和子组件有联系的操作&lt;br/&gt;例如上面的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//父组件.js
state = {
    'mockValue': '123'    
}
handleChange(e){
    this.setState({
        'value': '123',
    })
}

//render
&amp;lt;input onChange={this.handleChange.bind(this)} /&amp;gt;
&amp;lt;MockChild /&amp;gt;

/*
* 子组件不做变化
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015194423502-324164727.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很不爽,真的！必须给安排掉.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015211037371-232547574.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、基础的React优化&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.1 生命周期: shouldComponentUpdate&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;可能没听过&lt;code&gt;shouldComponentUpdate&lt;/code&gt;,我们简单介绍一下它的执行周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015193558826-1118415996.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.8421052631579&quot;&gt;
&lt;p&gt;不熟悉React生命周期的可以看看这篇文章:&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9559117.html&quot; target=&quot;_blank&quot;&gt;《React生命周期执行顺序详解》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到它是在render渲染之前触发的,只要我们在这里加以判断就可以有效阻止'无用'的render触发.当然你说&lt;code&gt;componentWillReceiveProps&lt;/code&gt;也可以,当然！但是它只有props的更新判断,而有时候我们也不能放过未更改的state！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shouldComponentUpdate(nextProps, nextState){
    if(nextState !== this.state &amp;amp;&amp;amp; nextProps !== this.props) return true;
    return false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么简短的代码就可以解决冗余的render触发.当然有时候项目规模大了之后,就需要具体到某一个值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nextState.xxx !== this.state.xxx &amp;amp;&amp;amp; ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;2.2 PureComponent&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;先介绍&lt;strong&gt;PureComponent&lt;/strong&gt;的用法,实在是太简便了
&lt;pre&gt;
&lt;code&gt;import React, { PureComponent } from 'react'

export default class Demo5 extends PureComponent{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上就是把React.Component代替成PureComponent.&lt;/p&gt;
&lt;p&gt;可能会疑问那PureComponent应该是一个插件吧？为什么就在react包里？其实它是官方在&lt;strong&gt;React15.3&lt;/strong&gt;提出的一个'纯净的组件'&lt;/p&gt;
&lt;p&gt;在版本允许的情况下,还是建议使用PureComponent,既能优化render次数,也能减少&lt;strong&gt;shouldComponentUpdate&lt;/strong&gt;的代码。但是PureComponent只是执行了&lt;strong&gt;浅比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是浅比较呢?&lt;/p&gt;
&lt;p&gt;我们先来看看源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (this._compositeType === CompositeTypes.PureClass) {
  shouldUpdate = !shallowEqual(prevProps, nextProps)
  || !shallowEqual(inst.state, nextState);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到判断主要是通过&lt;code&gt;shallowEqual&lt;/code&gt;方法执行的（即可以判断state,也可以判断props）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shallowEqual&lt;/code&gt;具体作用是什么呢?实际上它使用了ES6的&lt;code&gt;Object.keys&lt;/code&gt;.只是做了以下这么几个判断:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新的和旧的props(state)是否两者都有相同的key?&lt;/li&gt;
&lt;li&gt;引用是否改变&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二种可能有点难以理解,什么是&lt;strong&gt;引用是否改变?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单地解释就是,是否有新的元素参与改变&lt;/p&gt;
&lt;p&gt;举个官方常用例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class App extends PureComponent {
  state = {
    items: [1, 2, 3]
  }
  handleClick = () =&amp;gt; {
    const { items } = this.state;
    items.pop();
    this.setState({ items });
  }
  render() {
    return (&amp;lt;div&amp;gt;
      &amp;lt;ul&amp;gt;
        {this.state.items.map(i =&amp;gt; &amp;lt;li key={i}&amp;gt;{i}&amp;lt;/li&amp;gt;)}
      &amp;lt;/ul&amp;gt;
      &amp;lt;button onClick={this.handleClick}&amp;gt;delete&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,我们点击delete的时候,虽然items数组执行了&lt;code&gt;pop()&lt;/code&gt;方法,删除最后一项！但是&lt;code&gt;li&lt;/code&gt;标签却没变少！那是因为&lt;code&gt;shallowEqual&lt;/code&gt;根本不吃你这套.它认为items还是同一个引用,所以给我&lt;code&gt;true&lt;/code&gt;！在通过！反过来就是&lt;code&gt;false&lt;/code&gt;了&lt;/p&gt;
&lt;p&gt;那要如果改变引用呢？&lt;br/&gt;我们可以这样尝试.(这也是解决浅比较常用的一个办法)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.setState({ 
    items: [].concat(items) 
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然,大多数情况我们都可以通过PureComponent解决啦！实在不行,还可以通过&lt;code&gt;componentWillReceiveProps&lt;/code&gt;进一步判断呢！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PureComponent&lt;/code&gt;更多的介绍可以看:&lt;a href=&quot;http://www.wulv.site/2017-05-31/react-purecomponent.html&quot; target=&quot;_blank&quot;&gt;《React PureComponent 使用指南》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 12:05:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、React的渲染机制 要掌握一两项React render优化的方法不难,但是非常重要.无论是在实际项目中的一个小细节,还是迎合'面试官'的口味 1.1 触发Render 我们知道React要更新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9794292.html</dc:identifier>
</item>
<item>
<title>JUnit源码分析 - 扩展 - 自定义Rule - coolstream</title>
<link>http://www.cnblogs.com/coolstream/p/9756334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coolstream/p/9756334.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule简述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Rule是JUnit 4.7之后新加入的特性，有点类似于拦截器，可以在测试类或测试方法执行前后添加额外的处理，本质上是对@BeforeClass, @AfterClass, @Before, @After等的另一种实现，只是功能上更灵活多变，易于扩展，且方便在类和项目之间共享。&lt;/p&gt;
&lt;p&gt;JUnit的Rule特性提供了两个注解@Rule和@RuleClass，大体上说@Rule可以与@Before及@After对应，@ClassRule可以与@BeforeClass及@AfterClass对应。自JUnit4.10起可以使用TestRule接口代替此前一直在用的MethodRule接口，实际项目中可以通过实现TestRule或继承自JUnit内置Rule类进行扩展。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在简述中已经提到Rule特性本身也是对@BeforeClass, @AfterClass, @Before, @After功能的另外实现，所以基本上这四种注解的使用场景都适用于Rule，同时JUnit内置的Rule类还能够提供这四种注解未提供的功能。总体上说Rule特性的适用场景包括但不限于如下需求：&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试类或测试方法执行前后添加初始化或环境清理操作&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试执行过程中收集错误信息且无需中断测试&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试结束后添加额外的测试结果校验功能&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试执行前后创建及删除测试执行过程中产生的临时文件或目录&lt;/p&gt;
&lt;p&gt;　　　　　- 对测试过程中产生的异常进行灵活校验&lt;/p&gt;
&lt;p&gt;　　　　　- 将多个Rules串接在一起执行&lt;/p&gt;
&lt;p&gt;　　　　　- 测试用例执行失败时重试指定次数&lt;/p&gt;

&lt;p&gt;从使用习惯上来说，对于简单项目，@BeforeClass, @AfterClass, @Before, @After等注解已经能够满足测试需求；对于复杂点的项目，从易扩展、易维护和方便复用的角度考虑最好使用Rule特性，方便添加和移除Rule实例，灵活性大大提高。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注解分类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JUnit中通过两个注解@Rule和@ClassRule来实现Rule扩展，这两个注解使用时需要放在实现了TestRule接口的Rule变量或返回Rule的方法之上,且修饰符都必须为public。&lt;/p&gt;
&lt;p&gt;二者具体区别如下：&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;- 被注解的变量或方法类型不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @Rule修饰的变量或方法的修饰符必须为public，非static&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @ClassRule修饰的变量或方法的修饰符必须为public static&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;- 注解的级别不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @Rule为变量或方法级注解，每个测试方法执行时都会调用被该注解修饰的Rule&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @ClassRule为类级注解，执行单个测试类时只会调用一次被该注解修饰的Rule&lt;/p&gt;
&lt;p&gt; 　　　　　&lt;span&gt;- 注解的对象限制不同&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @Rule无注解对象限制&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @ClassRule不能注解ErrorCollector(Verifier)&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TestRule接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TestRule是测试类或测试方法执行过程及报告信息的接口，可以在TestRule中添加初始化及环境清理的操作、监控测试执行的日志打印或UI截图操作、测试结果成功或失败校验操作等。TestRule仅定义了唯一的方法apply()，所以可以在TestRule实现类的apply()方法中加入测试项目需要的操作。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestRule {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
    &lt;span&gt;//在实现类的apply()中加入测试需要的操作，本质上是对Statement实例base的进一步封装&lt;/span&gt;
    Statement apply(Statement base, Description description);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit内置Rule&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;除了Rule特性外，JUnit还新增了一些核心Rule，均实现了TestRule接口，包括Verifier抽象类，ErrorCollector实现类，ExternalResource抽象类，TemporaryFolder实现类，TestWatcher抽象类，TestName实现类，ExpectedException实现类，Timeout实现类及RuleChain实现类(deprecated)。各接口实现类及类图参考如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1432399/201810/1432399-20181012155942527-596018700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　&lt;span&gt;- Verifier&lt;/span&gt;：所有测试结束后对测试执行结果添加额外的逻辑验证测试最终成功与否。该抽象类为子类提供一个接口方法verify()供扩展&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- ErrorCollector&lt;/span&gt;：是Verifier类的一个子类实现，用于在测试执行过程中收集错误信息，不会中断测试，最后调用verify()方法处理&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- ExternalResource&lt;/span&gt;：外部资源管理。该抽象类为子类提供了两个接口方法before()和after()，可以根据项目实际需要覆写扩展&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- TemporaryFolder&lt;/span&gt;：是抽象类ExternalResource的一个子类实现，用于在JUnit测试执行前后，创建和删除临时目录&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- TestWatcher&lt;/span&gt;：监视测试方法生命周期的各个阶段。该抽象类为子类提供了五个接口方法succeeded(), failed(), skipped(), starting()及finished()供扩展&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- TestName&lt;/span&gt;：是抽象类TestWatcher的一个子类实现，用于在测试执行过程中获取测试方法名称。在starting()中记录测试方法名，在getMethodName()中返回&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- ExpectedException&lt;/span&gt;：与@Test中的expected相对应，提供更强大灵活的异常验证功能，@Test只能修饰待测试方法，ExpectedException可以修饰待测试类&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- Timeout&lt;/span&gt;：与@Test中的timeout相对应，@Test只能修饰待测试方法，Timeout可以修饰待测试类&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- RuleChain&lt;/span&gt;：用于将多个Rules串在一起执行。RuleChain已经deprecated了，但是其源码实现比较有趣，所以本篇没有直接去掉。&lt;/p&gt;

&lt;p&gt;篇幅原因此处仅简要介绍这些Rules提供的功能，后续将在专门的Rule及TestRule实现类源码分析中详解其实现。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以下过程是以典型的单个待测试类调用BlockJUnit4ClassRunner执行测试为例进行分析，如果对源码分析无兴趣可直接跳到&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule扩展示例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;部分。&lt;/p&gt;

&lt;p&gt;分析Rule特性的源码实现之前需要先梳理Statement的概念及执行过程，tStatement是对原子级测试的封装，我们在JUnit Runner中看到的测试用例执行过程是顺序执行不同注解修饰的测试方法，即@BeforeClass-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass(此处以三个待测试方法为例)。那么JUnit是如何将这一系列串接在一起的呢？其设计思想就是通过Statement以责任链的模式将其层层封装，责任链中上个节点的Statement中都存在对下一个节点的引用。Statement可以说是JUnit的核心设计之一，理清了Statement的执行过程就抓住了JUnit实现原理的主线。&lt;/p&gt;
&lt;p&gt;Rule特性又是如何织入Statement的封装与执行过程的呢？我们知道Rule特性中有两个注解@ClassRule和@Rule用来修饰Rule变量或返回Rule的方法，这些变量或方法返回值的类型都需要实现TestRule接口，而TestRule中唯一定义的方法apply()的返回值类型就是Statement，所以JUnit中Rule特性的实现类同样是Statement的一种。根据BlockJUnit4ClassRunner的父类ParentRunner中的classBlock()方法中的调用，以及BlockJUnit4ClassRunner中methodBlock()方法中的调用，我们基本上可以梳理出@ClassRule和@Rule在整个Statement责任链中的执行顺序，以JUnit内置的Rule实现类ErrorCollector，TemporaryFolderr和TestName为例（含两个@Test修饰的待测试方法）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@ClassRule注解ErrorCollector类实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　执行顺序为：&lt;/p&gt;
&lt;p&gt;　　@BeforeClass-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass-&amp;gt;&lt;span&gt;@ClassRule(verify())&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@ClassRule注解TemporaryFolder类实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　执行顺序为：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@ClassRule(before())&lt;/span&gt;-&amp;gt;@BeforeClass-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass-&amp;gt;&lt;span&gt;@ClassRule(after())&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Rule注解TestName类实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　执行顺序为：&lt;/p&gt;
&lt;p&gt;　　@BeforeClass-&amp;gt;&lt;span&gt;@Rule(starting())&lt;/span&gt;-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;&lt;span&gt;@Rule(starting())&lt;/span&gt;-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass&lt;/p&gt;

&lt;p&gt;如果测试用例中@ClassRule和@Rule两个都存在，则按实际覆写的接口方法所处测试阶段顺序织入测试执行过程。&lt;/p&gt;
&lt;p&gt;上述部分是分析Statement的设计思想及Rule在Statement执行过程中的顺序，文字描述通常都比较晦涩，还是特出关键源码一步步解读比较好，此处的简析仅仅是希望对Statement和Rule有一些大致的概念，方便后续的源码解读。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Statement封装过程的关键代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Statement封装过程中有两个主要的方法classBlock()和methodBlock()，其中classBlock()是测试类级别的封装，也就是说测试类级注解@BeforeRule, @AfterRule以及@ClassRule修饰的方法在此处链式封装，methodBlock()是测试方法级别的封装，也就是说测试方法级别注解@Test(expected=xxx) , @Test(timeout=xxx), @Before, @After()及@Rule修饰的方法在此处链式封装。&lt;/p&gt;
&lt;p&gt;　　先看一下classBlock()的调用过程：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Statement classBlock(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RunNotifier notifier) {
        Statement statement &lt;/span&gt;=&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象&lt;/span&gt;&lt;/span&gt;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;areAllChildrenIgnored()) {
            statement &lt;/span&gt;=&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            statement &lt;/span&gt;=&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            statement &lt;/span&gt;=&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;classBlock()中写的很清楚，首先调用childrenInvoker()构造Statement的基本行为，如果所有的子测试都没有被Ignore则通过withBeforeClasses(), withAfterClasses()及withClassRules()继续封装。先放一下，分析完childrenInvoker()的调用过程再从这里接入。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Statement childrenInvoker(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RunNotifier notifier) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Statement() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; evaluate() {
                runChildren(notifier);
            }
        };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;childrenInvoker()的作用是构造基本的Statement行为，即执行所有的子测试runChildren()，在runChildren()中循环调用每个子测试runChild()。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runChildren(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RunNotifier notifier) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RunnerScheduler currentScheduler =&lt;span&gt; scheduler;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; T each : getFilteredChildren()) {
                currentScheduler.schedule(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        ParentRunner.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.runChild(each, notifier);
                    }
                });
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            currentScheduler.finished();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runChild(T child, RunNotifier notifier);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected &lt;span&gt;void runChild(&lt;span&gt;final&lt;span&gt; FrameworkMethod method, RunNotifier notifier) {
        Description description =&lt;span&gt; describeChild(method);
        &lt;span&gt;if&lt;span&gt; (isIgnored(method)) {
            notifier.fireTestIgnored(description);
        } &lt;span&gt;else&lt;span&gt; {
            Statement statement = &lt;span&gt;new&lt;span&gt; Statement() {
                @Override
                &lt;span&gt;public &lt;span&gt;void evaluate() &lt;span&gt;throws&lt;span&gt; Throwable {
                    methodBlock(method).evaluate();
                }
            };
            runLeaf(statement, description, notifier);
        }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为ParentRunner中只有runChild()的抽象方法，所以该方法的具体实现在其子类BlockJUnit4ClassRunner中，子类的runChild()中调用了测试方法级的层层封装methodBlock()。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected Statement methodBlock(&lt;span&gt;final&lt;span&gt; FrameworkMethod method) {
        Object test;
        &lt;span&gt;try&lt;span&gt; {
            test = &lt;span&gt;new&lt;span&gt; ReflectiveCallable() {
                @Override
                &lt;span&gt;protected Object runReflectiveCall() &lt;span&gt;throws&lt;span&gt; Throwable {
                    &lt;span&gt;return&lt;span&gt; createTest(method);
                }
            }.run();
        } &lt;span&gt;catch&lt;span&gt; (Throwable e) {
            &lt;span&gt;return &lt;span&gt;new&lt;span&gt; Fail(e);
        }

        Statement statement =&lt;span&gt; methodInvoker(method, test);
        statement =&lt;span&gt; possiblyExpectingExceptions(method, test, statement);
        statement =&lt;span&gt; withPotentialTimeout(method, test, statement);
        statement =&lt;span&gt; withBefores(method, test, statement);
        statement =&lt;span&gt; withAfters(method, test, statement);
        statement =&lt;span&gt; withRules(method, test, statement);
        &lt;span&gt;return&lt;span&gt; statement;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object createTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getTestClass().getOnlyConstructor().newInstance();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected&lt;span&gt; Statement methodInvoker(FrameworkMethod method, Object test) {
        &lt;span&gt;return &lt;span&gt;new&lt;span&gt; InvokeMethod(method, test);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　methodBlock()中首先在createTest()中通过反射构造实例，在将该实例及FrameworkMethod类对象method作为methodInvoker()的入参构造出基本的Statement类对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.internal.runners.statements.InvokeMethod
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InvokeMethod &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Statement {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; FrameworkMethod testMethod;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object target;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InvokeMethod(FrameworkMethod testMethod, Object target) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testMethod =&lt;span&gt; testMethod;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        testMethod.invokeExplosively(target);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;构造出基本的Statement类对象后，在执行后续操作对该Statement类对象进行层层封装。篇幅原因就不再对如下&lt;span&gt;possiblyExpectingExceptions等五个方法的调用过程作进一步解析，这些方法调用和下面将要讲解的classBlock()方法实现中的下半部分很相似，只是此处是测试方法级的封装调用，classBlock()中是测试类级的封装调用。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
Statement statement =&lt;span&gt; methodInvoker(method, test);　　　　　　　　　　　　&lt;span&gt;&lt;span&gt;//构造出测试方法基本的Statement类对象&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; possiblyExpectingExceptions(method, test, statement);　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Test(expected=xxx)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withPotentialTimeout(method, test, statement);　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Test(timeout=xxx), deprecated&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withBefores(method, test, statement);　　　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Before&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withAfters(method, test, statement);　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@After&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withRules(method, test, statement);　　　　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Rule&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的待测试方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再回到前面classBlock()中的分析过程，该方法的后半部分会对构造出的所有方法的基本statement类对象作进一步封装，依次为&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withBeforeClasses(), &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withAfterClasses&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;()及&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withClassRules()。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;span&gt;protected Statement classBlock(&lt;span&gt;final&lt;span&gt; RunNotifier notifier) {
        Statement statement =&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象
        &lt;span&gt;if (!&lt;span&gt;areAllChildrenIgnored()) {
            statement =&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass
            statement =&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass
            statement =&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule
        }
        &lt;span&gt;return&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Statement withBeforeClasses(Statement statement) {
        List&lt;/span&gt;&amp;lt;FrameworkMethod&amp;gt; befores =&lt;span&gt; testClass
                .getAnnotatedMethods(BeforeClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; befores.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RunBefores(statement, befores, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;withBeforeClasses()调用过程：&lt;/span&gt;提取出待测试类中用@BeforeClass注解的所有方法，再把这些方法和childrenInvoker()中构造出的基本Statement类对象作为入参用Statement的子类RunBefores重新封装并返回。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Statement withAfterClasses(Statement statement) {
        List&lt;/span&gt;&amp;lt;FrameworkMethod&amp;gt; afters =&lt;span&gt; testClass
                .getAnnotatedMethods(AfterClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; afters.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RunAfters(statement, afters, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;withAfterClasses()调用过程：&lt;/span&gt;提取出待测试类中用@AfterClass注解的所有方法，再把这些方法和&lt;span&gt;withBeforeClasses&lt;/span&gt;()中返回的Statement类对象作为入参用Statement的子类RunAfters重新封装并返回。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Statement withClassRules(Statement statement) {
        List&lt;/span&gt;&amp;lt;TestRule&amp;gt; classRules =&lt;span&gt; classRules();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; classRules.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunRules(statement, classRules, getDescription());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;withClassRules&lt;/span&gt;()调用过程：提取出待测试类中用@ClassRule注解的所有Rule类变量或返回值为Rule类的方法，再把这些变量和方法同&lt;span&gt;withAfterClasses()中返回的Statement类对象作为入参用Statement的子类RunRules重新封装并返回。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; classRules() {
        ClassRuleCollector collector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassRuleCollector();
        testClass.collectAnnotatedMethodValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        testClass.collectAnnotatedFieldValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.getOrderedRules();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassRuleCollector &lt;span&gt;implements&lt;/span&gt; MemberValueConsumer&amp;lt;TestRule&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;RuleContainer.RuleEntry&amp;gt; entries = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RuleContainer.RuleEntry&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(FrameworkMember member, TestRule value) {
            ClassRule rule &lt;/span&gt;= member.getAnnotation(ClassRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            entries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleContainer.RuleEntry(value, RuleContainer.RuleEntry.TYPE_TEST_RULE,
                    rule &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; ? rule.order() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; getOrderedRules() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (entries.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
            }
            Collections.sort(entries, RuleContainer.ENTRY_COMPARATOR);
            List&lt;/span&gt;&amp;lt;TestRule&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;TestRule&amp;gt;&lt;span&gt;(entries.size());
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RuleContainer.RuleEntry entry : entries) {
                result.add((TestRule) entry.rule);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　classRules()方法用于获取@ClassRule修饰的所有TestRule实现类。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.rules.RunRules&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunRules &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Statement {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Statement statement;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RunRules(Statement base, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules, Description description) {
        statement &lt;/span&gt;=&lt;span&gt; applyAll(base, rules, description);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        statement.evaluate();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Statement applyAll(Statement result, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules,
            Description description) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule each : rules) {
            result &lt;/span&gt;=&lt;span&gt; each.apply(result, description);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　RunRules类用于根据调用&lt;span&gt;classRules&lt;/span&gt;()获取到的所有TestRule实现类集合对withAfterRules()方法返回的Statement类实例进行重新封装。&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Runner验证Rule规则的关键代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文开始提到过@ClassRule和@Rule修饰的Rule类变量或方法有一定的限制，比如public修饰符, 是或非static, 实现自TestRule接口等，所以在测试用例执行前需要进行相应的验证，这个是由ParentRunner及其子类在其构造方法的初始化过程中完成的。Rule规则的校验主要通过四个&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例CLASS_RULE_METHOD_VALIDATOR，CLASS_RULE_VALIDATOR，RULE_METHOD_VALIDATOR及RULE_VALIDATOR调用各自的validate()方法来实现的，具体调用过程解析如下：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BlockJUnit4ClassRunner(Class&amp;lt;?&amp;gt; testClass) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InitializationError {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(testClass);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　BlockJUnit4ClassRunner构造方法初始化过程会调用父类ParentRunner的的构造方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ParentRunner(Class&amp;lt;?&amp;gt; testClass) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InitializationError {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testClass =&lt;span&gt; createTestClass(testClass);
        validate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　ParentRunner的构造方法中包含了validate()调用&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InitializationError {
        List&lt;/span&gt;&amp;lt;Throwable&amp;gt; errors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Throwable&amp;gt;&lt;span&gt;();
        collectInitializationErrors(errors);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;errors.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidTestClassError(testClass.getJavaClass(), errors);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　该validate()实现中包含&lt;span&gt;collectInitializationErrors&lt;/span&gt;()调用，子类BlockJUnit4ClassRunner覆写了父类ParentRunner的&lt;span&gt;collectInitializationErrors&lt;/span&gt;()方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;@Override
&lt;span&gt;protected &lt;span&gt;void collectInitializationErrors(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        &lt;span&gt;super&lt;span&gt;.collectInitializationErrors(errors);

        validatePublicConstructor(errors);
        validateNoNonStaticInnerClass(errors);
        validateConstructor(errors);
        validateInstanceMethods(errors);
        validateFields(errors);
        validateMethods(errors);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　子类BlockJUnit4ClassRunner中的&lt;span&gt;collectInitializationErrors()方法实现会先调用父类ParentRunner中的&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;collectInitializationErrors()。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; collectInitializationErrors(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        validatePublicVoidNoArgMethods(BeforeClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, errors);
        validatePublicVoidNoArgMethods(AfterClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, errors);
        validateClassRules(errors);
        applyValidators(errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　 &lt;span&gt;父类ParentRunner中的&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;collectInitializationErrors()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法实现中包含了&lt;span&gt;validateClassRules&lt;/span&gt;()调用。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateClassRules(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);
        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;validateClassRules&lt;/span&gt;()方法中包含了两个&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator&lt;/span&gt;实例&lt;span&gt;CLASS_RULE_VALIDATOR&lt;/span&gt;及&lt;span&gt;CLASS_RULE_METHOD_VALIDATOR&lt;/span&gt;各自的validate()方法调用，这两个方法会对@ClassRule修饰的变量或方法进行Rule规则校验。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateFields(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        RULE_VALIDATOR.validate(getTestClass(), errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateMethods(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;validateFields()方法中包含了&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例&lt;/span&gt;&lt;/span&gt;&lt;span&gt;RULE_VALIDATOR&lt;span class=&quot;pl-smi&quot;&gt;&lt;span&gt;&lt;span&gt;的validate()方法调用，validateMethods()&lt;span&gt;方法中包含了&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例&lt;span&gt;RULE_METHOD_VALIDATOR&lt;span class=&quot;pl-smi&quot;&gt;&lt;span&gt;&lt;span&gt;的validate()方法调用，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这两个方法会对@Rule修饰的变量或方法进行Rule规则校验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;//&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules&lt;/span&gt;.RuleMemberValidator 验证@ClassRule修饰的方法是否复合Rule特性规则&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator CLASS_RULE_METHOD_VALIDATOR =&lt;span&gt;
            classRuleValidatorBuilder()
            .forMethods()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeclaringClassMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeStatic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodMustBeATestRule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules.RuleMemberValidator &lt;/span&gt;&lt;/span&gt;验证@ClassRule修饰的作用域&lt;span&gt;是否复合Rule特性规则&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator CLASS_RULE_VALIDATOR =&lt;span&gt;
            classRuleValidatorBuilder()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeclaringClassMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeStatic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FieldMustBeATestRule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules.RuleMemberValidator &lt;/span&gt;&lt;/span&gt;验证@Rule修饰的方法是否复合Rule特性规则&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator RULE_METHOD_VALIDATOR =&lt;span&gt;
            testRuleValidatorBuilder()
            .forMethods()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeNonStaticOrAlsoClassRule())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodMustBeARule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules.RuleMemberValidator &lt;/span&gt;&lt;/span&gt;验证@Rule修饰的作用域&lt;span&gt;是否复合Rule特性规则&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator RULE_VALIDATOR =&lt;span&gt;
            testRuleValidatorBuilder()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeNonStaticOrAlsoClassRule())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FieldMustBeARule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上是四个&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例CLASS_RULE_METHOD_VALIDATOR，CLASS_RULE_VALIDATOR，RULE_METHOD_VALIDATOR及RULE_VALIDATOR的具体定义，其实从类名定义上就可以直观地看到这些实例具体的校验内容，篇幅原因不再详述。&lt;/span&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt; Rule特性织入Statement的关键代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Rule特性织入Statement的过程主要依赖两个语句及其涉及到的嵌套调用，这两个语句即是classBlock()方法中的statement = withClassRules(statement)和methodBlock()方法中的statement = withRules(statement)。下面依次对二者嵌套的调用过程进行解析。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;span&gt;protected Statement classBlock(&lt;span&gt;final&lt;span&gt; RunNotifier notifier) {
        Statement statement =&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象
        &lt;span&gt;if (!&lt;span&gt;areAllChildrenIgnored()) {
            statement =&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass
            statement =&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass
            &lt;span&gt;statement =&lt;/span&gt;&lt;span&gt;&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule&lt;/span&gt;
        }
        &lt;span&gt;return&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected Statement methodBlock(&lt;span&gt;final&lt;span&gt; FrameworkMethod method) {
        Object test;
        &lt;span&gt;try&lt;span&gt; {
            test = &lt;span&gt;new&lt;span&gt; ReflectiveCallable() {
                @Override
                &lt;span&gt;protected Object runReflectiveCall() &lt;span&gt;throws&lt;span&gt; Throwable {
                    &lt;span&gt;return&lt;span&gt; createTest(method);
                }
            }.run();
        } &lt;span&gt;catch&lt;span&gt; (Throwable e) {
            &lt;span&gt;return &lt;span&gt;new&lt;span&gt; Fail(e);
        }

        Statement statement =&lt;span&gt; methodInvoker(method, test);
        statement =&lt;span&gt; possiblyExpectingExceptions(method, test, statement);
        statement =&lt;span&gt; withPotentialTimeout(method, test, statement);
        statement =&lt;span&gt; withBefores(method, test, statement);
        statement =&lt;span&gt; withAfters(method, test, statement);
        &lt;span&gt;statement =&lt;/span&gt;&lt;span&gt;&lt;span&gt; withRules(method, test, statement);&lt;/span&gt;
        &lt;span&gt;return&lt;span&gt; statement;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　先来看methodBlock()中的withRules()调用，MethodRule接口从JUnit4.10开始已经deprecated，该接口相关的代码可以直接ignore。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Statement withRules(FrameworkMethod method, Object target, Statement statement) {
        RuleContainer ruleContainer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleContainer();
        CURRENT_RULE_CONTAINER.set(ruleContainer);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            List&lt;/span&gt;&amp;lt;TestRule&amp;gt; testRules =&lt;span&gt; getTestRules(target);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (MethodRule each : rules(target)) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(each &lt;span&gt;instanceof&lt;/span&gt; TestRule &amp;amp;&amp;amp;&lt;span&gt; testRules.contains(each))) {
                    ruleContainer.add(each);
                }
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule rule : testRules) {
                ruleContainer.add(rule);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            CURRENT_RULE_CONTAINER.remove();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ruleContainer.apply(method, describeChild(method), target, statement);
    }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建RunContainer实例，将其设置为当前线程局部变量的值，通过getTestRules()获取注解target的所有@Rule规则，并将其加入到新建的RunContainer实例中　　，ThreadLocal的内在机制会保证这一过程在并发环境下的的线程安全。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;RuleContainer&amp;gt; CURRENT_RULE_CONTAINER = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;RuleContainer&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; getTestRules(Object target) {
        RuleCollector&lt;/span&gt;&amp;lt;TestRule&amp;gt; collector = &lt;span&gt;new&lt;/span&gt; RuleCollector&amp;lt;TestRule&amp;gt;&lt;span&gt;();
        getTestClass().collectAnnotatedMethodValues(target, Rule.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        getTestClass().collectAnnotatedFieldValues(target, Rule.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　在apply()方法中通过调用getSortedEntries()对所有Rule进行排序处理，处理完成后返回封装Rule之后的Statement实例。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.RuleContainer&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Statement apply(FrameworkMethod method, Description description, Object target,
            Statement statement) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodRules.isEmpty() &amp;amp;&amp;amp;&lt;span&gt; testRules.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; statement;
        }
        Statement result &lt;/span&gt;=&lt;span&gt; statement;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RuleEntry ruleEntry : getSortedEntries()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ruleEntry.type ==&lt;span&gt; RuleEntry.TYPE_TEST_RULE) {
                result &lt;/span&gt;=&lt;span&gt; ((TestRule) ruleEntry.rule).apply(result, description);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                result &lt;/span&gt;=&lt;span&gt; ((MethodRule) ruleEntry.rule).apply(result, method, target);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;br/&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.RuleContainer&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;RuleEntry&amp;gt;&lt;span&gt; getSortedEntries() {
        List&lt;/span&gt;&amp;lt;RuleEntry&amp;gt; ruleEntries = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RuleEntry&amp;gt;&lt;span&gt;(
                methodRules.size() &lt;/span&gt;+&lt;span&gt; testRules.size());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (MethodRule rule : methodRules) {
            ruleEntries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleEntry(rule, RuleEntry.TYPE_METHOD_RULE, orderValues.get(rule)));
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule rule : testRules) {
            ruleEntries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleEntry(rule, RuleEntry.TYPE_TEST_RULE, orderValues.get(rule)));
        }
        Collections.sort(ruleEntries, ENTRY_COMPARATOR);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ruleEntries;
    }&lt;br/&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上是对方法进行Rule规则的封装，在classBlock()代码块中会上溯到&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;childrenInvoker()中的调用，测试方法级的Statement封装处理完之后，还需要继续进行测试类级的Statement封装。从开始贴出的classBlock()的代码块中可以看到&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;childrenInvoker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;()返回对所有测试方法的Statement封装之后，还会继续调用&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withBeforeClasses&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;(), &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withAfterClasses&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;()及withClassRules()进一步处理，这里对于&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withBeforeClasses()和&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withAfterClasses()的方法调用就不详细讲解了，下面看看withClassRules()方法的执行流程，这个是与Rule规则直接相关的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;span&gt;protected Statement classBlock(&lt;span&gt;final&lt;span&gt; RunNotifier notifier) {
        Statement statement =&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象
        &lt;span&gt;if (!&lt;span&gt;areAllChildrenIgnored()) {
            statement =&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass
            statement =&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass
            &lt;span&gt;statement =&lt;span&gt;&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule
        }
        &lt;span&gt;return&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Statement withClassRules(Statement statement) {
        List&lt;/span&gt;&amp;lt;TestRule&amp;gt; classRules =&lt;span&gt; classRules();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; classRules.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunRules(statement, classRules, getDescription());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;classRules()方法先获取所有@ClassRule规则，然后通过getOrderedRules()对所有@ClassRule规则进行排序。withClassRules()方法通过classRules()获取注解待测试类的所有排序后的@ClassRule规则，并将其作为RunRule类构造方法的入参进一步封装withAfterClasses()方法中返回的Statement实例。RunRule本身也是Statement的子类。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; classRules() {
        ClassRuleCollector collector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassRuleCollector();
        testClass.collectAnnotatedMethodValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        testClass.collectAnnotatedFieldValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.getOrderedRules();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassRuleCollector &lt;span&gt;implements&lt;/span&gt; MemberValueConsumer&amp;lt;TestRule&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;RuleContainer.RuleEntry&amp;gt; entries = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RuleContainer.RuleEntry&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(FrameworkMember member, TestRule value) {
            ClassRule rule &lt;/span&gt;= member.getAnnotation(ClassRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            entries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleContainer.RuleEntry(value, RuleContainer.RuleEntry.TYPE_TEST_RULE,
                    rule &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; ? rule.order() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; getOrderedRules() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (entries.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
            }
            Collections.sort(entries, RuleContainer.ENTRY_COMPARATOR);
            List&lt;/span&gt;&amp;lt;TestRule&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;TestRule&amp;gt;&lt;span&gt;(entries.size());
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RuleContainer.RuleEntry entry : entries) {
                result.add((TestRule) entry.rule);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.rules.RunRule
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunRules &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Statement {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Statement statement;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RunRules(Statement base, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules, Description description) {
        statement &lt;/span&gt;=&lt;span&gt; applyAll(base, rules, description);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        statement.evaluate();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Statement applyAll(Statement result, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules,
            Description description) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule each : rules) {
            result &lt;/span&gt;=&lt;span&gt; each.apply(result, description);　　　　　　　　　　　　　　　　　　&lt;span&gt;//各个Rule真正执行的地方&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule扩展示例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;根据上述Rule特性的源码分析可知，Rule的扩展主要有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现TestRule接口&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;继承自内置Rule抽象类(Verifier，ExternalResource or TestWatcher)&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;继承自内置Rule抽象类的子类(ErrorCollector，TemporaryFolder，TestName，ExpectedException，Timeout or RuleChain)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以第一种方式为例实现JUnit用例失败重试功能说明扩展Rule的一般用法，主要步骤如下：&lt;/p&gt;
&lt;p&gt;　　- 自定义Retry注解&lt;/p&gt;
&lt;p&gt;　　- 自定义Rule类实现TestRule接口&lt;/p&gt;
&lt;p&gt;　　- 在待测试类中使用自定义Rule&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//自定义Retry注解
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Retry {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; times();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//扩展Rule类
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.rules.TestRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.Description;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runners.model.Statement;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RetryRule &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestRule{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Statement apply(Statement statement, Description description) 
    {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Statement() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable 
            {
                Throwable retryThrowable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                Retry retry &lt;/span&gt;= description.getAnnotation(Retry.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(retry != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
                {
                    
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; times =&lt;span&gt; retry.times();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;times; i++&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                        {
                            statement.evaluate();
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Throwable t)
                        {
                            retryThrowable &lt;/span&gt;=&lt;span&gt; t;
                            System.err.println(&lt;/span&gt;&quot;Run method &quot; + description.getMethodName() + &quot;: failed for &quot; + (i+1) + &lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　((i+1) == 1 ? &quot; time&quot; : &quot; times &quot;&lt;span&gt;));
                        }
                    }
                    
                    System.err.println(&lt;/span&gt;&quot;Run method &quot; + description.getMethodName() + &quot; : exited after &quot; + times + &quot; attempts&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    statement.evaluate();
                }
            }    
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//待测试类
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.fail;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.FixMethodOrder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Rule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runners.MethodSorters;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRetryRuleTest 
{
    @Rule
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RetryRule retryRule = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RetryRule();
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMethodA() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        System.out.println(&lt;/span&gt;&quot;test methodA...&quot;&lt;span&gt;);
    }
    
    @Test
    @Retry(times&lt;/span&gt;=3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMethodB() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        fail();
        System.out.println(&lt;/span&gt;&quot;test methodB...&quot;&lt;span&gt;);
    }
    
    @Retry(times&lt;/span&gt;=5&lt;span&gt;)
    @Test(timeout&lt;/span&gt;=10&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMethodC() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;test methodC...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//测试执行结果
&lt;/span&gt;&lt;span&gt;test methodA...
Run method testMethodB: failed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 1&lt;span&gt; time
Run method testMethodB: failed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 2&lt;span&gt; times 
Run method testMethodB: failed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 3&lt;span&gt; times 
Run method testMethodB : exited after &lt;/span&gt;3&lt;span&gt; attempts
test methodC...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 当然扩展Rule除了以上三种方式外，还有其他的间接方式实现同样的效果，因为本篇的主旨是自定义Rule，所以其他的扩展方式暂不涉及。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事实上Rule特性实现的功能也可以通过其他的扩展方式完成，这个需要根据项目平台及小组技能栈来确定哪种方式更灵活。多了解些测试工具内部的实现原理和执行流程可以让我们更全面地评估同类开发或测试工具各自的优劣势，在遇到不同类型问题的时候选择成本更低、效果更好的解决方案。当然，对于优秀的开源框架，吸收其经典的设计思想也是自建高效框架的必由之路。&lt;/p&gt;

</description>
<pubDate>Mon, 15 Oct 2018 12:02:00 +0000</pubDate>
<dc:creator>coolstream</dc:creator>
<og:description>JUnit Rule简述 Rule是JUnit 4.7之后新加入的特性，有点类似于拦截器，可以在测试类或测试方法执行前后添加额外的处理，本质上是对@BeforeClass, @AfterClass,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coolstream/p/9756334.html</dc:identifier>
</item>
<item>
<title>Nginx可以做什么？看完这篇你就懂了 - Java修炼记</title>
<link>http://www.cnblogs.com/Javaba/p/9794068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Javaba/p/9794068.html</guid>
<description>&lt;p&gt;本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得，欢迎留言交流。&lt;/p&gt;
&lt;p&gt;Nginx能做什么&lt;/p&gt;
&lt;p&gt;——反向代理&lt;/p&gt;
&lt;p&gt;——负载均衡&lt;/p&gt;
&lt;p&gt;——HTTP服务器（动静分离）&lt;/p&gt;
&lt;p&gt;——正向代理&lt;/p&gt;
&lt;p&gt;以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做。&lt;/p&gt;
&lt;p&gt;反向代理&lt;/p&gt;
&lt;p&gt;反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。&lt;/p&gt;
&lt;p&gt;下面贴上一段简单的实现反向代理的代码&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;675&quot; data-height=&quot;206&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-c258566b65ab2bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-c258566b65ab2bbd.png&quot; data-original-width=&quot;675&quot; data-original-height=&quot;206&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;12086&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了&lt;/p&gt;
&lt;p&gt;负载均衡&lt;/p&gt;
&lt;p&gt;负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。&lt;/p&gt;
&lt;p&gt;1、RR（默认）&lt;/p&gt;
&lt;p&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。&lt;/p&gt;
&lt;p&gt;简单配置&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;675&quot; data-height=&quot;284&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-0d67f23a21ae99bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-0d67f23a21ae99bd.png&quot; data-original-width=&quot;675&quot; data-original-height=&quot;284&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;16086&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;负载均衡的核心代码为&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;676&quot; data-height=&quot;92&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-6b439d295cca3bcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-6b439d295cca3bcc.png&quot; data-original-width=&quot;676&quot; data-original-height=&quot;92&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;4939&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。&lt;/p&gt;
&lt;p&gt;2、权重&lt;/p&gt;
&lt;p&gt;指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;675&quot; data-height=&quot;96&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-97417b2e65ef3e8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-97417b2e65ef3e8d.png&quot; data-original-width=&quot;675&quot; data-original-height=&quot;96&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5880&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那么10次一般只会有1次会访问到8081，而有9次会访问到8080&lt;/p&gt;
&lt;p&gt;3、ip_hash&lt;/p&gt;
&lt;p&gt;上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;675&quot; data-height=&quot;114&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-fb6eb8d4c1e1f871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/675/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-fb6eb8d4c1e1f871.png&quot; data-original-width=&quot;675&quot; data-original-height=&quot;114&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5774&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4、fair（第三方）&lt;/p&gt;
&lt;p&gt;按后端服务器的响应时间来分配请求，响应时间短的优先分配。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;674&quot; data-height=&quot;113&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-e059e64f4f8fb737.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-e059e64f4f8fb737.png&quot; data-original-width=&quot;674&quot; data-original-height=&quot;113&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;5731&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;5、url_hash（第三方）&lt;/p&gt;
&lt;p&gt;按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;676&quot; data-height=&quot;134&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-c435577f5b2bee87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-c435577f5b2bee87.png&quot; data-original-width=&quot;676&quot; data-original-height=&quot;134&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;7646&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍&lt;/p&gt;
&lt;p&gt;HTTP服务器&lt;/p&gt;
&lt;p&gt;Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;673&quot; data-height=&quot;218&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-ecf3bf296c94d738.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/673/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-ecf3bf296c94d738.png&quot; data-original-width=&quot;673&quot; data-original-height=&quot;218&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;9861&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。&lt;/p&gt;
&lt;p&gt;动静分离&lt;/p&gt;
&lt;p&gt;动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;673&quot; data-height=&quot;553&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-461c4713c0fc56ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/673/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-461c4713c0fc56ba.png&quot; data-original-width=&quot;673&quot; data-original-height=&quot;553&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;30345&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活&lt;/p&gt;
&lt;p&gt;正向代理&lt;/p&gt;
&lt;p&gt;正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;674&quot; data-height=&quot;261&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7564501-241297776397fe9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7564501-241297776397fe9c.png&quot; data-original-width=&quot;674&quot; data-original-height=&quot;261&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;13511&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 11:24:00 +0000</pubDate>
<dc:creator>Java修炼记</dc:creator>
<og:description>本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得，欢迎留言交流。 Nginx能做什么 ——</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Javaba/p/9794068.html</dc:identifier>
</item>
</channel>
</rss>