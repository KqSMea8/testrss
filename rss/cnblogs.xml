<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Unity Shader】（六） ------ 复杂的光照（上） - 爱喝柠檬的二哈</title>
<link>http://www.cnblogs.com/BFXYMY/p/9786098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BFXYMY/p/9786098.html</guid>
<description>&lt;p&gt; 笔者使用的是 Unity 2018.2.0f2 + VS2017，建议读者使用与 Unity 2018 相近的版本，避免一些因为版本不一致而出现的问题。&lt;/p&gt;

&lt;p id=&quot;main-toc&quot;&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;%E5%89%8D%E8%A8%80-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#前言&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#%E5%89%8D%E8%A8%80&quot;&gt;前言&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;%E4%B8%80.%20%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#一.%20渲染路径&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#%E4%B8%80.%20%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84&quot;&gt;一. 渲染路径&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1%20%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1%20前向渲染&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1%20%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93&quot;&gt;1.1 前向渲染&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1.1%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1.1%20工作原理&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1.1%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot;&gt;1.1.1 工作原理&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1.2%20%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E6%BA%90%E6%95%B0%E7%9B%AE-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1.2%20逐像素光源数目&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1.2%20%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E6%BA%90%E6%95%B0%E7%9B%AE&quot;&gt;1.1.2 逐像素光源数目&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1.3%20%E5%85%89%E6%BA%90%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1.3%20光源处理方式&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1.3%20%E5%85%89%E6%BA%90%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&quot;&gt;1.1.3 光源处理方式&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1.4%20SH%20%E5%A4%84%E7%90%86-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1.4%20SH%20处理&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1.4%20SH%20%E5%A4%84%E7%90%86&quot;&gt;1.1.4 SH 处理&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1.5%20%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E7%9A%84%20Pass%20%E5%9D%97-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1.5%20前向渲染的%20Pass%20块&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1.5%20%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E7%9A%84%20Pass%20%E5%9D%97&quot;&gt;1.1.5 前向渲染的 Pass 块&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.1.6%20%E5%AF%B9%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E7%9A%84%E6%80%BB%E7%BB%93-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.1.6%20对前向渲染的总结&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.1.6%20%E5%AF%B9%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E7%9A%84%E6%80%BB%E7%BB%93&quot;&gt;1.1.6 对前向渲染的总结&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.2%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.2%20延迟渲染路径&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.2%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84&quot;&gt;1.2 延迟渲染路径&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.2.1%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.2.1%20工作原理&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.2.1%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot;&gt;1.2.1 工作原理&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;G-Buffer%20pass-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#G-Buffer%20pass&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#G-Buffer%20pass&quot;&gt;G-Buffer pass&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.2.2%20%E5%85%89%E6%BA%90%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.2.2%20光源处理方式&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.2.2%20%E5%85%89%E6%BA%90%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&quot;&gt;1.2.2 光源处理方式&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.2.3%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%9A%84%E7%BC%BA%E7%82%B9-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.2.3%20延迟渲染的缺点&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.2.3%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%9A%84%E7%BC%BA%E7%82%B9&quot;&gt;1.2.3 延迟渲染的缺点&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.2.4%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%9A%84%20Pass%20%E5%9D%97-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.2.4%20延迟渲染的%20Pass%20块&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.2.4%20%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%9A%84%20Pass%20%E5%9D%97&quot;&gt;1.2.4 延迟渲染的 Pass 块&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;1.2.5%20%E5%AF%B9%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#1.2.5%20对延迟渲染总结&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#1.2.5%20%E5%AF%B9%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93&quot;&gt;1.2.5 对延迟渲染总结&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;%C2%A0%E4%BA%8C.%20Unity%20%E4%B8%AD%E7%9A%84%E5%85%89%E6%BA%90-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html# 二.%20Unity%20中的光源&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#%C2%A0%E4%BA%8C.%20Unity%20%E4%B8%AD%E7%9A%84%E5%85%89%E6%BA%90&quot;&gt; 二. Unity 中的光源&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;2.1%20%E5%B9%B3%E8%A1%8C%E5%85%89-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#2.1%20平行光&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#2.1%20%E5%B9%B3%E8%A1%8C%E5%85%89&quot;&gt;2.1 平行光&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;2.2%20%E7%82%B9%E5%85%89%E6%BA%90-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#2.2%20点光源&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#2.2%20%E7%82%B9%E5%85%89%E6%BA%90&quot;&gt;2.2 点光源&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;2.3%20%E8%81%9A%E5%85%89%E7%81%AF-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#2.3%20聚光灯&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#2.3%20%E8%81%9A%E5%85%89%E7%81%AF&quot;&gt;2.3 聚光灯&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;%C2%A02.4%20%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%B1%E5%93%8D-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html# 2.4%20光源类型的影响&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#%C2%A02.4%20%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%B1%E5%93%8D&quot;&gt;2.4 光源类型的影响&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;%C2%A0%E4%B8%89%20.%E5%AE%9E%E8%B7%B5-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html# 三%20.实践&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#%C2%A0%E4%B8%89%20.%E5%AE%9E%E8%B7%B5&quot;&gt; 三 .实践&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;3.1%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#3.1%20准备工作&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#3.1%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&quot;&gt;3.1 准备工作&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;3.2%20%E5%AE%9A%E4%B9%89%20Base%20Pass-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#3.2%20定义%20Base%20Pass&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#3.2%20%E5%AE%9A%E4%B9%89%20Base%20Pass&quot;&gt;3.2 定义 Base Pass&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;3.3%20%E5%AE%9A%E4%B9%89%20Additional%20Pass-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#3.3%20定义%20Additional%20Pass&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#3.3%20%E5%AE%9A%E4%B9%89%20Additional%20Pass&quot;&gt;3.3 定义 Additional Pass&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;3.4%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#3.4%20完整代码&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#3.4%20%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81&quot;&gt;3.4 完整代码&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;%E5%9B%9B%20.%20%E6%80%BB%E7%BB%93-toc&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/BFXYMY/p/9786098.html#四%20.%20总结&quot; target=&quot;_self&quot; data-cke-saved-href=&quot;#%E5%9B%9B%20.%20%E6%80%BB%E7%BB%93&quot;&gt;四 . 总结&lt;/a&gt;&lt;/p&gt;
&lt;hr id=&quot;hr-toc&quot;/&gt;


&lt;p&gt;本文探讨的是场景中存在多种光源时的渲染情况，在本文之前，我曾经介绍过基础的光照模型原理，而本文也会基于这些基础来进行介绍，如果读者对光照模型不太了解，可以翻看我之前的文章&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_2&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/BFXYMY/p/9683608.html&quot;&gt;【Unity Shader】（三） ------ 光照模型原理及漫反射和高光反射的实现&lt;/a&gt;。本文也可以看作是对这一篇章的拓展和补充。由于完整的光照计算内容较多，所以分为两个部分介绍，本文介绍第一部分，下一篇介绍第二部分，最后会给出综合所有光照计算的完整 shader。&lt;/p&gt;



&lt;p&gt;渲染路径决定了光照在 shader 中是如何应用的，所以在计算光源时，需要在每个 Pass 块内指定它的渲染路径，Unity 才会为我们提供正确的光照信息。&lt;/p&gt;
&lt;p&gt;我们可以在Unity中的摄像机的看到它支持的渲染路径&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/04.png&quot; alt=&quot;&quot; width=&quot;382&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Forward （前向渲染）&lt;/li&gt;
&lt;li&gt;Deferred （延迟渲染）&lt;/li&gt;
&lt;li&gt;Legacy Vertex Lit （遗留的顶点照明渲染）&lt;/li&gt;
&lt;li&gt;Legacy Deferred （遗留的延迟渲染）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是四种渲染路径的部分属性对比，如果想了解更详细的信息，读者可以自行去 Unity 官方文档查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/01.png&quot; alt=&quot;&quot; width=&quot;855&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是：如果当前显卡不支持所设置的渲染路径，则 Unity 会自动使用更低一级的渲染路径&lt;/strong&gt;。本文注重介绍前两种渲染路径。&lt;/p&gt;
&lt;p&gt;我们需要在 shader 的每一个 Pass中指定它所使用的渲染路径，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;Pass{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   Tags {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它代码&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 其中 ForwardBase 就是渲染路径其中一种，下表是部分 LightMode 标签支持的渲染路径设置选项&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; align=&quot;center&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;标签名&lt;/th&gt;
&lt;th scope=&quot;col&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; Always&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 不管哪种渲染路径，该Pass总会渲染，但不计算光照&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; ForwardBase&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 用于&lt;strong&gt;前向渲染&lt;/strong&gt;。计算环境光、平行光、逐顶点/SH 和 LightMaps&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; ForwardAdd&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 用于&lt;strong&gt;前向渲染。&lt;/strong&gt;计算额外的逐像素光源，一个 Pass 对应一个光源&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; Deferred&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 用于&lt;strong&gt;延迟渲染。&lt;/strong&gt;渲染 G 缓冲 （G-buffer）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; ShadowCaster&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt; 把物体的深度信息渲染到阴影映射纹理或深度纹理中&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; PrepassBase&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 用于&lt;strong&gt;遗留的延迟渲染。&lt;/strong&gt;渲染法线和高光反射的指数部分&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt; PrepassFinal&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 用于&lt;strong&gt;遗留的延迟渲染。&lt;/strong&gt;通过合并纹理、光照和自发光来渲染得到最后的颜色&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt; Vertex、VertexLMRGBM 和 VertexLM&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 用于&lt;strong&gt;遗留的顶点照明渲染&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;我们同样可以在官方文档中查到其相关说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/02.png&quot; alt=&quot;&quot; width=&quot;807&quot; height=&quot;316&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 具体解释读者可以自行查看。&lt;/p&gt;

&lt;p&gt;只有正确地指定渲染路径，一些光照变量才会被正确地赋值，我们的计算结果才会正确。下面我们开始介绍这些渲染路径&lt;/p&gt;


&lt;h2&gt;1.1 前向渲染&lt;/h2&gt;

&lt;h3&gt;1.1.1 工作原理&lt;/h3&gt;
&lt;p&gt;前向渲染路径是我们最常用的一种渲染路径。在进行一次完整的前向渲染时，要计算&lt;strong&gt;颜色缓冲区和深度缓冲区&lt;/strong&gt;中的信息&lt;strong&gt;，&lt;/strong&gt;遍历每一个片元，进行深度测试，如果没有通过深度测试，则说明该片元不可见，则舍弃；如果通过深度测试，则计算光照，更新帧缓冲。我在之前的&lt;a href=&quot;https://www.cnblogs.com/BFXYMY/p/9717734.html&quot; target=&quot;_blank&quot;&gt;【Unity Shader】（五） ------ 透明效果之半透明效果的实现及原理&lt;/a&gt; 中介绍了深度测试的原理，如果读者对深度测试等知识点不太熟悉的话，可以翻看一下，本文就不再赘述了。&lt;/p&gt;
&lt;p&gt;假定一个物体在 &lt;strong&gt;N&lt;/strong&gt; 个&lt;strong&gt;逐像素光源&lt;/strong&gt;的影响范围内，上文已经提到，一个 Pass 块计算一个逐像素光源，那么在帧缓冲中把这些 Pass 块计算得到的光照结果混合起来就是最终的颜色值了。可以想象得到的是，如果场景中存在 N 个逐像素光源 和 M 个物体，那么就需要 N * M 个 Pass，那么很显然，随着 N 或 M 的逐渐增大，性能会逐渐下降。所以 Unity 会限制每个物体的逐像素光照项目。&lt;/p&gt;

&lt;h3&gt;1.1.2 逐像素光源数目&lt;/h3&gt;
&lt;p&gt; 读者可以查看和设置项目中的逐像素光源数目，Edit -&amp;gt; Project Setting - &amp;gt; Quality，在 Rendering 中的 Pixel Light Count&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/05.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;137&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般默认为 4 ，&lt;strong&gt;表示一个物体可以接收除最亮的平行光外的 4 个逐像素光照&lt;/strong&gt;。 &lt;/p&gt;

&lt;h3&gt;1.1.3 光源处理方式&lt;/h3&gt;
&lt;p&gt; 在 Unity 中，渲染一个物体时，会先计算哪些光源照亮了它，以及如何照亮（处理方式）。在前向渲染中，处理方式有3种：&lt;strong&gt;逐顶点处理，逐像素处理和球谐函数（Spherical Harmonics，SH）处理，&lt;/strong&gt;而如何处理则由光源的类型和渲染模式决定。光源类型是指该光源是平行光还是点光源等，而渲染模式则是指该光源是否是&lt;strong&gt;重要的（Important）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/06.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;361&quot;/&gt; &lt;/p&gt;
&lt;p&gt;Type 表示光源类型，平行光，点光源，聚光灯之类；Render Mode 表示渲染模式，有 &lt;strong&gt;Auto , Important , Not Important&lt;/strong&gt; 三类，而当你创建一个光源时，默认为 &lt;strong&gt;Auto ，&lt;/strong&gt;这表示 Unity 会自主帮我们判断这个光源的处理方式。而&lt;strong&gt;如果手动设置为 Important 则表示该光源是 “重要的” ，要进行逐像素处理。而 Not Important 则表示不重要，进行逐顶点或 SH 处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在前向渲染中，渲染一个物体的时候，Unity 会根据场景中各个光源的设置和影响程度来进行排序。我们可以在官方文档中看到这一段的阐述&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;In Forward Rendering, some number of brightest lights that affect each object are rendered in fully per-pixel lit mode. Then, up to 4 point lights are calculated per-vertex. The other lights are computed as Spherical Harmonics (SH), which is much faster but is only an approximation.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;即排序之后，一定数目的光源会进行逐像素处理，然后最多 4 个光源进行逐顶点处理。而其它的光源则会进行 SH 处理。SH 处理虽然很快，但是得到的值是一个粗略的近似值。我们同样引用官方的样例来解释这段话&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/08.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 假定存在光源 A-H，它们的颜色和光照强度一样，并且渲染模式为 Auto， 图中圆圈为物体，且在这 8 个光源的影响范围内。那么，Unity 会进行以下分组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/09.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中影响程度最大的 4 个光源 A - D 进行逐像素处理（因为距离相比其他光源更近），然后最多 4 个光源进行逐顶点处理（D - G），最后，剩下部分进行 SH 处理（G - H）。而我们可以注意到，这个顺序中，有部分重叠了，如 D 进行了逐像素处理，又进行了逐顶点处理，对此，官方做出了如下解释：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note that light groups overlap; for example last per-pixel light blends into per-vertex lit mode so there are less “light popping” as objects and lights move around.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以 D 为例，既进行了逐像素处理，又进行了逐顶点处理然后进行混合，是为了&lt;strong&gt;减少当光源四处移动时产生的 “光弹出”&lt;/strong&gt;（emmmm,这也许不是一个好的翻译，请原谅我英文水平的不足）。&lt;/p&gt;

&lt;p&gt;我们来总结一下 Unity 的判断规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最亮的&lt;strong&gt;平行光&lt;/strong&gt;总按逐像素处理&lt;/li&gt;
&lt;li&gt;设置为 Important 的光源按逐像素处理&lt;/li&gt;
&lt;li&gt;设置为 Not Important 的光源按逐顶点或者SH处理&lt;/li&gt;
&lt;li&gt;按以上规则得到的逐像素光源数目少于 &lt;strong&gt;Quality&lt;/strong&gt; 中设置的数目时，会有更多的光源以逐像素的方式渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.1.4 SH 处理&lt;/h3&gt;
&lt;p&gt;前文数处提到光源处理方式，前两种我在 &lt;a href=&quot;https://www.cnblogs.com/BFXYMY/p/9683608.html&quot; target=&quot;_blank&quot;&gt;【Unity Shader学习笔记】（三） ---------------- 光照模型原理及漫反射和高光反射的实现&lt;/a&gt;  中已经介绍过了，现在我们来看一下这个 SH 处理。&lt;/p&gt;
&lt;p&gt;官方原话：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Spherical Harmonics lights are very fast to render. They have a tiny cost on the CPU, and are actually free for the GPU to apply (that is, base pass always computes SH lighting; but due to the way SH lights work, the cost is exactly the same no matter how many SH lights are there).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大意为：SH 处理渲染是非常快的，对于CPU的消耗微小，可以自由应用GPU；因此，Base Pass （&lt;strong&gt;前向渲染中有两种 Pass ，分别为 Base Pass 和 Additional Pass&lt;/strong&gt;） 块中通常计算 SH 处理的光源，而且由于 SH 处理的工作方式，不管 Base Pass 块中有多少个 SH 处理的光源，它的消耗基本都是一样的。&lt;/p&gt;
&lt;p&gt; 同样需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SH 处理用于顶点而非像素，意味着不支持 Cookie 和 法线纹理&lt;/li&gt;
&lt;li&gt;SH 是非常低频的，这意味着无法实现清晰的灯光转换。也只影响漫反射光照（镜面高光的频率太低）。&lt;/li&gt;
&lt;li&gt;当 SH 光源靠近一些表面时，看起来会得到“错误的结果”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的来说，SH 处理对于小的，动态的物体来说，已经足够好了。&lt;/p&gt;

&lt;h3 id=&quot;1.1.5%20%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E7%9A%84%20Pass%20%E5%9D%97&quot;&gt;1.1.5 前向渲染的 Pass 块&lt;/h3&gt;
&lt;p&gt;前面我们说到前向前向渲染有两种 Pass ：Base Pass , Additional Pass。&lt;/p&gt;
&lt;p&gt;官方对此的解释为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/11.png&quot; alt=&quot;&quot; width=&quot;862&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我简单地做一个总结，大概如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/12.png&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是如果 Base Pass 中使用了 &lt;strong&gt;OnlyDirectional&lt;/strong&gt; 的 PassFlags，那么这个 Base Pass 块只会计算主平行光，环境光、光照探针和光照纹理，&lt;strong&gt;而 SH 和 逐顶点光源则不包含在内。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/13.png&quot; alt=&quot;&quot; width=&quot;842&quot; height=&quot;614&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Base Pass 一般会定义一个，当然也可以定义多个，如需要双面渲染的情况。&lt;strong&gt;一个 Base Pass 仅会执行一次&lt;/strong&gt;，所以环境光和自发光会放在 Base Pass 里面计算，因为我们只希望他们只计算一次。如果放在 Additional Pass 就有可能计算多次，然后叠加，得到错误的结果。&lt;/li&gt;
&lt;li&gt;Additional Pass 中，我们开启了混合 Blend one one，因为一个 Additional Pass 会被每个逐像素光源（除平行光）执行一次，我们希望它能够与上一次的光照结果在帧缓存中进行叠加，然后最终得到有多个光照的渲染效果。如果不开启混合，那么 Additional Pass 就会覆盖上一次的渲染效果，那么最终效果看起来就像是只受单个光源的影响。&lt;/li&gt;
&lt;li&gt;除了定义正确的 LightMode，我们也使用了编译指令。编译指令会保证 Unity 能够为相应的 Pass 生成所需要的 shader 变种，这些变种会处理不同条件下的渲染逻辑。简单的说，使用了编译指令之后，我们才可以在 Pass 中使用正确的光照变量。&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/15.png&quot; alt=&quot;&quot; width=&quot;880&quot; height=&quot;135&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;1.1.6 对前向渲染的总结&lt;/h3&gt;
&lt;p&gt;前向渲染是一种传统的渲染方式，工作原理也是比较简单的。通过上面的解释，我们也能够知道，前向渲染依赖于场景的复杂度，当场景中存在大量的实时光照时，程序的性能会快速下降。因为在多个光源中，每执行一个 Pass 都需要重新渲染 一遍，所以许多的计算实际上是重复了。为了解决这个问题，我们可以使用延迟渲染路径&lt;/p&gt;

&lt;h2&gt;1.2 延迟渲染路径&lt;/h2&gt;

&lt;h3&gt;1.2.1 工作原理&lt;/h3&gt;
&lt;p&gt;延迟渲染是一张更古老的渲染方法，相比于前向渲染，延迟渲染会利用额外的缓冲区，统称为 &lt;strong&gt;G （Geometry）缓冲（G - buffer）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来看一下官方对于 G 缓冲的定义：&lt;/p&gt;

&lt;h3&gt;G-Buffer pass&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;The g-buffer pass renders each GameObject once. Diffuse and specular colors, surface smoothness, world space normal, and emission+ambient+reflections+lightmaps are rendered into g-buffer textures. The g-buffer textures are setup as global shader properties for later access by shaders (CameraGBufferTexture0 .. CameraGBufferTexture3 names).&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大意为：&lt;strong&gt;G-buffer Pass 渲染每个GameObject一次。把物体漫反射和镜面反射颜色，表面平滑度，世界空间法线和自发光+环境光+反射+光照贴图渲染为G缓冲区纹理。G-buffer纹理被设置为全局着色器属性，以供稍后访问着色器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由此我们可以得知延迟渲染的工作原理为：包含两个 Pass，第一个 Pass 对每个片元进行深度测试，如果通过则把这些信息存储到 G 缓冲中；第二个 Pass 则利用 G 缓冲中各个片元信息进行光照计算，更新帧缓冲。&lt;/p&gt;

&lt;h3&gt;1.2.2 光源处理方式&lt;/h3&gt;
&lt;p&gt;在前向渲染中，光源的处理方法取决于多条规则，而在延迟渲染中，每个光源都可以按逐像素来处理，而且它的效率与光源数目无关。也就是延迟渲染不依赖于场景复杂度，而与屏幕空间大小有关。所以在这种情况下，点光源和聚光灯的消耗就会变得十分 “廉价”。&lt;/p&gt;
&lt;p&gt;所以，如果场景中实时光照数目较多且因此造成性能下降时，可以考虑使用延迟渲染。&lt;/p&gt;

&lt;h3&gt;1.2.3 延迟渲染的缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不支持真正的抗锯齿功能&lt;/li&gt;
&lt;li&gt;无法处理半透明物体&lt;/li&gt;
&lt;li&gt;显卡需要支持 MRT 、Shader Mode 3.0 以上、深度渲染纹理。&lt;/li&gt;
&lt;li&gt;在移动端，需要硬件支持 OpenGL ES 3.0 以上&lt;/li&gt;
&lt;li&gt;需要注意的是：如果摄像机的 Projection 设置为了 Orthographi（正交），那么摄像机会回退到前向渲染。因为延迟渲染不支持正交投影。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/16.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;222&quot;/&gt;

&lt;h3&gt;1.2.4 延迟渲染的 Pass 块&lt;/h3&gt;
&lt;p&gt;（1）第一个 Pass 用来渲染 G 缓冲，把物体的漫反射颜色、高光反射颜色、平滑度等信息存储到 G 缓冲中，对于每个物体来说，这个 Pass 只执行一次。&lt;/p&gt;
&lt;p&gt;（2）第二个 Pass 利用上一个 Pass 中的信息进行真正的光照计算，并存储到帧缓冲中。而默认 G 缓冲的渲染纹理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RT0，ARGB32格式：漫反射颜色（RGB），遮罩（A）&lt;/li&gt;
&lt;li&gt;RT1，ARGB32格式：镜面反射颜色（RGB），粗糙度（A）&lt;/li&gt;
&lt;li&gt;RT2，ARGB2101010格式：世界空间标准（RGB），未使用（A）&lt;/li&gt;
&lt;li&gt;RT3，ARGB2101010（非HDR）或ARGBHalf（HDR）格式：Emission + lighting + lightmaps + reflection probes&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;深度+模板缓冲区&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需要十分十分十分（说 3 遍）注意的是：读者可能在别的地方看过不同的布局，因为不同版本的 Unity，其内容可能会有所不同，上面列出的 Unity 2018.2 的，读者如果不是使用 2018.2 的话，可以到官方文档查看自己所用版本的默认布局。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;还有一点值得注意的是：在第二个 Pass 中计算光照时，默认仅可以使用 Unity 内置的 Standard 光照模型&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;1.2.5 对延迟渲染总结&lt;/h3&gt;
&lt;p&gt;延迟渲染适用于场景中存在较多实时光源且存在性能忧患的情况，延迟渲染不支持摄像机的正交投影，使用延迟渲染需要考虑硬件支持。&lt;/p&gt;



&lt;p&gt;一直以来，我们在渲染的路上都在和光照打交道，所以我们也应该熟悉一下 Unity 中的光源。&lt;/p&gt;
&lt;p&gt;Unity 中的光源有 4 种：平行光、点光源、聚光灯和面光源（仅在烘焙时使用），我们来学习前3种光源。&lt;/p&gt;

&lt;h2&gt;2.1 平行光&lt;/h2&gt;
&lt;p&gt;平行光是最简单的光源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;照亮范围没有限制，位置不唯一，几何属性只有方向，相当于 “太阳” 或 “月亮”。&lt;/li&gt;
&lt;li&gt;到场景中任何一点的方向都是一样的，光照强度不会随着距离而改变，即没有光照衰减的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/17.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 点光源&lt;/h2&gt;
&lt;p&gt;点光源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点光源位于空间中的一个点，并在所有方向上均匀地发出光&lt;/li&gt;
&lt;li&gt;撞击表面的光的方向是从接触点返回到光对象的中心的线，强度随着距光的距离而减小，在指定范围内达到零&lt;/li&gt;
&lt;li&gt;光强度与距离光源的距离的平方成反比。这被称为“平方反比定律”，类似于光在现实世界中的表现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/18.jpg&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;2.3 聚光灯&lt;/h2&gt;
&lt;p&gt;聚光灯是这 3 种光源中最复杂的一种。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由空间中的一块锥形区域定义，有空间范围限制&lt;/li&gt;
&lt;li&gt;光照衰减随物体逐渐远离点光源而逐渐减小，顶点处光照强度最强。边界处强度为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/19.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;2.4 光源类型的影响&lt;/h2&gt;
&lt;p&gt; 我们常用的光源属性有：&lt;strong&gt;光源位置、方向（光源到某一点的方向）、颜色、强度和衰减（到某一点的衰减，除了平行光，均与该点到光源的距离有关）。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;前面说了这么多理论知识，现在我们结合起来，来编写你们最想看到的代码吧。我们来实现一个前向渲染的 shader。在这个shader 中，我们采用 Blinn - Phong 模型，对于光照的计算，我在之前的文章已经介绍过了，所以这里只是贴出一些值得注意的地方，完整的代码在这一节的最后。&lt;/p&gt;

&lt;h2&gt;3.1 准备工作&lt;/h2&gt;
&lt;p&gt;创建场景，去掉天空盒子，保留平行光和摄像机；同时，为了做明显的对比，创建一个点光源，并把颜色调为红色或蓝色这种显眼的颜色&lt;/p&gt;
&lt;p&gt;创建Capsule，Materiral，shader 命名为 ForwardRendering。编辑 shader&lt;/p&gt;

&lt;h2&gt;3.2 定义 Base Pass&lt;/h2&gt;
&lt;p&gt;I. 定义 Properties 块，因为只计算光照，所以比较简单&lt;/p&gt;
&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    Properties {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         _Diffuse (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Diffuse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         _Specular (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Specular&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         _Gloss (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Gloss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Range(&lt;span&gt;8.0&lt;/span&gt;, &lt;span&gt;256&lt;/span&gt;)) = &lt;span&gt;20&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;II. 先定义第一个 Pass : Base Pass&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;        Pass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;             Tags { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; multi_compile_fwdbase    
&lt;span&gt; 8&lt;/span&gt;             
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt;11&lt;/span&gt;             
&lt;span&gt;12&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把 LightMode 定义为 ForwardBase，并添加编译指令 #pragma multi_compile_fwdbase&lt;/p&gt;

&lt;p&gt;III. 输入输出结构体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IV. 顶点着色器，进行简单的空间转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 
&lt;span&gt; 5&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 
&lt;span&gt; 7&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld, v.vertex).xyz;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;V. 片元着色器，对最亮的平行光，环境光，自发光等做计算。但此处我们不考虑自发光&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_Target {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 fixed3 worldLightDir =&lt;span&gt; normalize(_WorldSpaceLightPos0.xyz);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 
&lt;span&gt; 5&lt;/span&gt;                 fixed3 ambient =&lt;span&gt; UNITY_LIGHTMODEL_AMBIENT.xyz;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 
&lt;span&gt; 7&lt;/span&gt;                  fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, worldLightDir));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                  fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz -&lt;span&gt; i.worldPos.xyz);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                  fixed3 halfDir = normalize(worldLightDir +&lt;span&gt; viewDir);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                  fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, halfDir)), _Gloss);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;fixed&lt;/span&gt; atten = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4(ambient + (diffuse + specular) * atten, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里 atten 表示光照衰减值，因为是平行光，所以固定为 1&lt;/p&gt;
&lt;p&gt;至此 Base Pass 块基本定义完成。下面我们来定义 Additional Pass&lt;/p&gt;

&lt;h2&gt;3.3 定义 Additional Pass&lt;/h2&gt;

&lt;p&gt;I. 定义标签，同时注意&lt;strong&gt;一定要开启混合&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;        Pass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;             Tags { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardAdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            Blend One One
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; multi_compile_fwdadd
&lt;span&gt;10&lt;/span&gt;             
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt;13&lt;/span&gt;             
&lt;span&gt;14&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AutoLight.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; II. Additional Pass 中对光源的处理方式与 Base Pass 中基本一致，去掉了环境光，自发光，逐顶点光照，SH 光照部分，然后添加对不同光源类型的支持。因为在这里处理的光源可能是平行光，点光源和聚光灯中任意一种。所以我们需要对其进行判断，然后计算五个影响要素：&lt;strong&gt;位置，方向，颜色，强度和衰减&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;III. 对光源进行判断，得到光源方向，记得归一化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_Target {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                #ifdef USING_DIRECTIONAL_LIGHT
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                     fixed3 worldLightDir =&lt;span&gt; normalize(_WorldSpaceLightPos0.xyz);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;                     fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz -&lt;span&gt; i.worldPos.xyz);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                 &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; IV. 常规的光照计算&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, worldLightDir));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                 
&lt;span&gt;3&lt;/span&gt;     fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz -&lt;span&gt; i.worldPos.xyz);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     fixed3 halfDir = normalize(worldLightDir +&lt;span&gt; viewDir);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(&lt;span&gt;0&lt;/span&gt;, dot(worldNormal, halfDir)), _Gloss);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  V. 最后，处理不同光源的衰减&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;                #ifdef USING_DIRECTIONAL_LIGHT
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                     &lt;span&gt;fixed&lt;/span&gt; atten = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                     &lt;span&gt;#if&lt;/span&gt; defined (POINT)
&lt;span&gt; 5&lt;/span&gt;                         float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)).xyz;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                         &lt;span&gt;fixed&lt;/span&gt; atten =&lt;span&gt; tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;#elif&lt;/span&gt; defined (SPOT)
&lt;span&gt; 8&lt;/span&gt;                         float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                         &lt;span&gt;fixed&lt;/span&gt; atten = (lightCoord.z &amp;gt; &lt;span&gt;0&lt;/span&gt;) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + &lt;span&gt;0.5&lt;/span&gt;).w *&lt;span&gt; tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                         &lt;span&gt;fixed&lt;/span&gt; atten = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4((diffuse + specular) * atten, &lt;span&gt;1.0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到的是，点光源和聚光灯求衰减比较复杂，要通过复杂的数学表达式计算得到。因为这种计算操作较大，所以 Unity 选择&lt;strong&gt;使用一张纹理作为查找表（LUT），我们首先得到光源空间下的坐标，然后用这个坐标对衰减纹理进行采样得到衰减值。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最后，保存两部分的代码，查看效果，可以看到，平行光和点光源都照亮了物体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/20.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.4 完整代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; Shader &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unity/Custom/01--Forward Rendering&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    Properties {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         _Diffuse (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Diffuse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         _Specular (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Specular&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         _Gloss (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Gloss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Range(&lt;span&gt;8.0&lt;/span&gt;, &lt;span&gt;256&lt;/span&gt;)) = &lt;span&gt;20&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    SubShader {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         Tags { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RenderType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Opaque&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        Pass {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;             Tags { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             
&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; multi_compile_fwdbase    
&lt;span&gt; 17&lt;/span&gt;             
&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt; 20&lt;/span&gt;             
&lt;span&gt; 21&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;             
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            fixed4 _Diffuse;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            fixed4 _Specular;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt;&lt;span&gt; _Gloss;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;             
&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             
&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v) {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 
&lt;span&gt; 42&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 
&lt;span&gt; 44&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld, v.vertex).xyz;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 
&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_Target {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 fixed3 worldLightDir =&lt;span&gt; normalize(_WorldSpaceLightPos0.xyz);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 
&lt;span&gt; 53&lt;/span&gt;                 fixed3 ambient =&lt;span&gt; UNITY_LIGHTMODEL_AMBIENT.xyz;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 
&lt;span&gt; 55&lt;/span&gt;                  fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, worldLightDir));
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;                  fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz -&lt;span&gt; i.worldPos.xyz);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                  fixed3 halfDir = normalize(worldLightDir +&lt;span&gt; viewDir);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                  fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, halfDir)), _Gloss);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;                 &lt;span&gt;fixed&lt;/span&gt; atten = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 
&lt;span&gt; 63&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4(ambient + (diffuse + specular) * atten, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            ENDCG
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        Pass {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;             Tags { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardAdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;            Blend One One
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             
&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; multi_compile_fwdadd
&lt;span&gt; 78&lt;/span&gt;             
&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt; 81&lt;/span&gt;             
&lt;span&gt; 82&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AutoLight.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;             
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            fixed4 _Diffuse;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            fixed4 _Specular;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt;&lt;span&gt; _Gloss;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             
&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             
&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v) {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 
&lt;span&gt;104&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 
&lt;span&gt;106&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld, v.vertex).xyz;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 
&lt;span&gt;108&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_Target {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                #ifdef USING_DIRECTIONAL_LIGHT
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                     fixed3 worldLightDir =&lt;span&gt; normalize(_WorldSpaceLightPos0.xyz);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;                     fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz -&lt;span&gt; i.worldPos.xyz);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;                 
&lt;span&gt;119&lt;/span&gt;                 fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, worldLightDir));
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 
&lt;span&gt;121&lt;/span&gt;                 fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz -&lt;span&gt; i.worldPos.xyz);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 fixed3 halfDir = normalize(worldLightDir +&lt;span&gt; viewDir);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dot(worldNormal, halfDir)), _Gloss);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                #ifdef USING_DIRECTIONAL_LIGHT
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                     &lt;span&gt;fixed&lt;/span&gt; atten = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                 &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;                     &lt;span&gt;#if&lt;/span&gt; defined (POINT)
&lt;span&gt;129&lt;/span&gt;                         float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)).xyz;
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                         &lt;span&gt;fixed&lt;/span&gt; atten =&lt;span&gt; tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                     &lt;span&gt;#elif&lt;/span&gt; defined (SPOT)
&lt;span&gt;132&lt;/span&gt;                         float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                         &lt;span&gt;fixed&lt;/span&gt; atten = (lightCoord.z &amp;gt; &lt;span&gt;0&lt;/span&gt;) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + &lt;span&gt;0.5&lt;/span&gt;).w *&lt;span&gt; tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                     &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt;                         &lt;span&gt;fixed&lt;/span&gt; atten = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                     &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;                 &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4((diffuse + specular) * atten, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            ENDCG
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;     FallBack &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Specular&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;本文主要解释了光照在渲染中的关系和处理、渲染路径及其工作原理以及光源类型，影响属性等，可能你会感慨其复杂性，但不得不说，在学习 shader 的路上，这注定是不可避免且极其重要的一点。在第3节我们也实现了一个可以初步处理多光源的shader，不过即便如此，它还是欠缺的。我们会在下一篇章中介绍关于光照衰减和阴影的知识，届时我们便可以实现一个真正的完整的光照 shader 。&lt;/p&gt;
&lt;p&gt;本文可能比较啰嗦，毕竟理论知识较多，笔者的文笔也一般般，但仍然希望本文能够对你的学习有所帮助。&lt;/p&gt;
&lt;p&gt;路漫漫其修远兮，我也想躺着玩手机~~~~~&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7%EF%BC%88%E4%B8%8A%EF%BC%89/%E4%BC%91%E6%81%AF.jpg&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;900&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 17 Oct 2018 07:08:00 +0000</pubDate>
<dc:creator>爱喝柠檬的二哈</dc:creator>
<og:description>笔者使用的是 Unity 2018.2.0f2 + VS2017，建议读者使用与 Unity 2018 相近的版本，避免一些因为版本不一致而出现的问题。 目录 前言 一. 渲染路径 1.1 前向渲染</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BFXYMY/p/9786098.html</dc:identifier>
</item>
<item>
<title>关于MongoDB时间格式转换和时间段聚合统计的用法总结 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9802869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9802869.html</guid>
<description>&lt;h2&gt;一 . 背景需求&lt;/h2&gt;
&lt;p&gt;在日常的业务需求中，我们往往会根据时间段来统计数据。例如，统计每小时的下单量；每天的库存变化，这类信息数据对运营管理很重要。&lt;/p&gt;
&lt;p&gt;这类数据统计依赖于各个时间维度，年月日、时分秒都有可能。因为需求变化多样，并且表的设计有严格的规范，我们不可能将订单的下单时间分别拆分存储到 年、月、日、时、分、秒、毫秒列（字段）中。在实际应用中，我们一般都是通过转换函数进行时间转换的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;大家可能对关系型数据库（例如，SQL Server、MySQL）中的时间转换函数和依据时间段进行聚合操作比较熟悉了，但是对MongoDB中的时间转换和依据时间聚合比较陌生。所以，我们有必要花费一定时间进行梳理学习一下，拓展丰富自己的知识。&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;二 . SQL Server数据库关于时间的转换和聚合&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;为了清楚的了解这类需求，了解时间转换和统计，我们先从大家熟悉的SQL Server 入手。例如，我们将时间数据存储为datetime类型。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首先，回顾下SQL Server的时间转换函数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.通过&lt;strong&gt;YEAR(),MONTH(),DAY()&lt;/strong&gt; 获取年月日数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017105757088-2085298274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.通过&lt;strong&gt;DATEPART()&lt;/strong&gt; 函数 返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017105834277-1655481616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;strong&gt;datename ()&lt;/strong&gt; 返回代表指定日期的指定日期部分的字符串。此函数与DATEPART() 类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017105910128-1239396094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，还可以通过&lt;strong&gt;convert()&lt;/strong&gt; 等函数进行转换，再次不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过这些函数，我们可以进行时间格式的转换，在转换函数的基础上，可以进行时间段内数据量的统计。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例如：基于&lt;strong&gt;DATEPART()&lt;/strong&gt; 函数&lt;strong&gt;，&lt;/strong&gt; 统计2017-10-10到2017-11-10表中每天的数据量。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017110019315-1030447092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以基于&lt;strong&gt;convert()&lt;/strong&gt; 函数进行统计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017110037317-215306448.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;三 . MongoDB 数据库关于时间的转换和聚合&lt;/h2&gt;
&lt;p&gt;以上操作是在SQL Server上进行，如果在MongoDB中，应该借助什么的函数进行类似的转换和统计呢？&lt;/p&gt;
&lt;p&gt;如果查看显示 各种格式的时间，可以通过 &lt;span&gt;&lt;strong&gt;$dateToString&lt;/strong&gt;&lt;/span&gt; 进行转换。&lt;/p&gt;
&lt;p&gt;例如通过转换函数$dateToString，将集合temp_MongoDateTime中的字段Rec_CreateTime转换为 年 字段、月 字段、日 字段、年-月-日、和 时：分：秒：毫秒 字段&lt;/p&gt;
&lt;p&gt;代码为：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.temp_MongoDateTime.aggregate(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;   [&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;     {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;       $project: {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           &quot;_id&quot;:0,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           &quot;Rec_CreateTime&quot;:1,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;          Year: { $dateToString: { format: &quot;%Y&quot;, date: &quot;$Rec_CreateTime&quot; } },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;          Month: { $dateToString: { format: &quot;%m&quot;, date: &quot;$Rec_CreateTime&quot; } },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;          Day: { $dateToString: { format: &quot;%d&quot;, date: &quot;$Rec_CreateTime&quot; } },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;          yearMonthDay: { $dateToString: { format: &quot;%Y-%m-%d&quot;, date: &quot;$Rec_CreateTime&quot; } },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;          Time: { $dateToString: { format: &quot;%H:%M:%S:%L&quot;, date: &quot;$Rec_CreateTime&quot;} }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;       }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;     }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;   ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 查询效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017141432895-601366678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;除了$dateToString转换函数外，MongoDBDB 还有获取年月日、时分秒的函数，甚至还提供了处于一年中的多少天，一周的第几天等。&lt;/p&gt;
&lt;p&gt;主要函数为&lt;span&gt;&lt;strong&gt;$year、&lt;span class=&quot;nx&quot;&gt;$month、$dayOfMonth、 $hour、$minute、$second、$dayOfYear、$dayOfWeek &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span class=&quot;nx&quot;&gt;等。&lt;/span&gt;&lt;strong&gt;&lt;span class=&quot;nx&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们直接看下面的例子好了。执行代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.temp_MongoDateTime.aggregate(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;   [&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;     {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;       $project:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;         {&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           &quot;_id&quot;:0,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           &quot;Rec_CreateTime&quot;:1,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           year: { $year: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           month: { $month: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           day: { $dayOfMonth: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           hour: { $hour: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           minutes: { $minute: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           seconds: { $second: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           milliseconds: { $millisecond: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           dayOfYear: { $dayOfYear: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           dayOfWeek: { $dayOfWeek: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           week: { $week: &quot;$Rec_CreateTime&quot; }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;         }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;     }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;   ]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017141006226-1080969661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面的2个例子都是时间转换，如果按照时间段集合统计数据呢？其实基于上面的时间转换函数，借助MongoDB的聚合框架，同样可以轻松实现。&lt;/p&gt;
&lt;p&gt;例如统计1-12 月份，每个月份的数据量，即那个月是旺季。此时基于时间转换函数 &lt;em&gt;&lt;strong&gt;&lt;span&gt;$&lt;em&gt;&lt;strong&gt;month&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;，&lt;/strong&gt;&lt;/em&gt;执行代码如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.temp_MongoDateTime.aggregate(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    $match:{}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;},&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    $group:{_id:{&lt;span&gt;&lt;strong&gt;$month&lt;/strong&gt;&lt;/span&gt;:&quot;$Rec_CreateTime&quot;},&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    count:{$sum:1}}&lt;/em&gt;&lt;em&gt;  &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查询效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017110334232-577924067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面的数据显示：集合中的记录按月聚合，10月份有341笔；9月份有48笔。其中字段_id 代表了月份。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再举一个例子，例如统计 集合&lt;em&gt;temp_MongoDateTime&lt;/em&gt; 在 &lt;em&gt;2016-10-05 05:51:50 到 &lt;/em&gt;2018-10-06 05:51:50 这段时间内，0-24 小时内，每小时的分布情况。即，每天那个时辰（小时）下单量比较多。&lt;/p&gt;
&lt;p&gt;此时基于时间转换函数 &lt;span&gt;&lt;em&gt;&lt;strong&gt;$hour&lt;/strong&gt;&lt;/em&gt; &lt;span&gt;，&lt;/span&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.temp_MongoDateTime.aggregate(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;$match:{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&quot;Rec_CreateTime&quot;:{$gte:ISODate(&quot;2016-10-05 05:51:50&quot;),$lte:ISODate(&quot;2018-10-06 05:51:50&quot;)}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;       }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;},&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{$group:{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        _id:{ &lt;span&gt;&lt;strong&gt;$hour&lt;/strong&gt;&lt;/span&gt;: &quot;$Rec_CreateTime&quot; },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;         count:{$sum:1}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查询结果显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017110416191-261671264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再举一个关于时间聚合统计的例子，这个例子是基于时间转换函数&lt;em&gt;&lt;strong&gt;&lt;span&gt;$dateToString&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;的&lt;em&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;例如统计每天的数据量，即每天的数据分布情况。这个每天是按 年-月-日统计分布的。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.temp_MongoDateTime.aggregate(&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;$match:{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&quot;Rec_CreateTime&quot;:{$gte:ISODate(&quot;2016-10-05 05:51:50&quot;),$lte:ISODate(&quot;2018-10-06 05:51:50&quot;)}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;       }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;},&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{$group:{&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        _id:{ &lt;strong&gt;&lt;span&gt;$dateToString&lt;/span&gt;&lt;/strong&gt;: { format: &quot;%Y-%m-%d&quot;, date: &quot;$Rec_CreateTime&quot; } },&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;         count:{$sum:1}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        }&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查询效果显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201810/780228-20181017110451731-1739342278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四 . 总结&lt;/h2&gt;
&lt;p&gt;和关系型数据库 SQL Server 一样，MongoDB数据库通过自身的时间转换函数，例如， $dateToString、$year、&lt;span class=&quot;nx&quot;&gt;$month、$dayOfMonth、 $hour、$minute、$second、$dayOfYear、$dayOfWeek等，也可以轻松实现时间转换和基于时间段的聚合统计。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;nx&quot;&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 06:49:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一 . 背景需求 在日常的业务需求中，我们往往会根据时间段来统计数据。例如，统计每小时的下单量；每天的库存变化，这类信息数据对运营管理很重要。 这类数据统计依赖于各个时间维度，年月日、时分秒都有可能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9802869.html</dc:identifier>
</item>
<item>
<title>CSS3新特性回顾 - 赖同学</title>
<link>http://www.cnblogs.com/lbh2018/p/About_CSS3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbh2018/p/About_CSS3.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#css3-%E4%BB%8B%E7%BB%8D&quot;&gt;CSS3介绍&lt;/a&gt; (1) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E6%96%B0%E7%89%B9%E5%BE%81%E7%AE%80%E4%BB%8B&quot;&gt;新特征简介&lt;/a&gt; (2) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%BD%E9%A2%9D&quot;&gt;查看浏览器份额&lt;/a&gt; (3) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E4%BC%AA%E7%B1%BBpesudo-classes&quot;&gt;伪类&lt;/a&gt; (4) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E4%BC%AA%E5%85%83%E7%B4%A0&quot;&gt;伪元素&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#css3-%E5%8F%98%E5%BD%A2&quot;&gt;CSS3变形&lt;/a&gt; (1) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#border-radius&quot;&gt;border-radius&lt;/a&gt; (2) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#border&quot;&gt;border&lt;/a&gt; (3) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E8%8F%B1%E5%BD%A2%E5%92%8C%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2&quot;&gt;菱形和平行四边形&lt;/a&gt; (4) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E4%BA%94%E8%A7%92%E6%98%9F%E5%92%8C%E5%85%AD%E8%A7%92%E6%98%9F&quot;&gt;五角星和六角星&lt;/a&gt; (5) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E4%BA%94%E8%BE%B9%E5%BD%A2%E5%92%8C%E5%85%AD%E8%BE%B9%E5%BD%A2&quot;&gt;五边形和六边形&lt;/a&gt; (6) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%BF%83%E5%BD%A2%E5%92%8C%E8%9B%8B%E8%BE%B9%E5%BD%A2&quot;&gt;心形和蛋边形&lt;/a&gt; (7) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%A4%AA%E6%9E%81%E9%98%B4%E9%98%B3%E5%9B%BE&quot;&gt;太极阴阳图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#css3-%E8%89%B2%E5%BD%A9&quot;&gt;CSS3色彩&lt;/a&gt; (1) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%82&quot;&gt;透明背景图层&lt;/a&gt; (2) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F1&quot;&gt;颜色模式1&lt;/a&gt; (3) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F2&quot;&gt;颜色模式2&lt;/a&gt; (4) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98&quot;&gt;线性渐变&lt;/a&gt; (5) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98&quot;&gt;径向渐变&lt;/a&gt; (6) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E9%87%8D%E5%A4%8D%E6%80%A7%E6%B8%90%E5%8F%98&quot;&gt;重复性渐变&lt;/a&gt; (7) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C&quot;&gt;盒子阴影效果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#css3-%E8%BF%87%E6%B8%A1&quot;&gt;CSS3过渡&lt;/a&gt; (1) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%88%B6%E4%BD%9C%E7%BC%93%E6%85%A2%E5%8F%98%E9%95%BF%E7%9A%84%E6%96%B9%E5%BD%A2&quot;&gt;制作缓慢变长的方形&lt;/a&gt; (2) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E8%BF%87%E6%B8%A1%E7%9A%84timing-function%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3&quot;&gt;过渡的timing-function属性详解&lt;/a&gt; (3) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E4%BB%BF%E5%A4%A9%E7%8C%AB%E7%B1%BB%E5%88%AB%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E5%88%B6%E4%BD%9C&quot;&gt;仿天猫类别过渡效果制作&lt;/a&gt; (4) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E4%BB%BF%E5%A4%A9%E7%8C%AB%E4%B8%93%E9%A2%98%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B&quot;&gt;仿天猫专题过渡效果实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#css3-%E5%8A%A8%E7%94%BB&quot;&gt;CSS3动画&lt;/a&gt; (1) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84keyframes%E5%85%B3%E9%94%AE%E5%B8%A7%E8%AE%B2%E8%A7%A3&quot;&gt;动画中的@keyframes关键帧讲解&lt;/a&gt; (2) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%8A%A8%E7%94%BBanimation%E7%AC%A6%E5%90%88%E5%B1%9E%E6%80%A7%E8%AE%B2%E8%A7%A3&quot;&gt;动画animation符合属性讲解&lt;/a&gt; (3) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%8A%A8%E7%94%BB%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B%E5%88%B6%E4%BD%9C-loading%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C&quot;&gt;动画综合实例制作-loading加载动画制作&lt;/a&gt; (4) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#loading%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B2&quot;&gt;Loading动画效果实例2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#css3-%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88&quot;&gt;CSS3文字排版&lt;/a&gt; (1) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E5%88%B6%E4%BD%9C%E5%8F%91%E5%85%89%E5%AD%97%E7%AB%8B%E4%BD%93%E5%AD%97%E8%8B%B9%E6%9E%9C%E5%AD%97%E4%BD%93&quot;&gt;制作发光字，立体字，苹果字体&lt;/a&gt; (2) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E7%94%A8text-overflow%E8%A7%A3%E5%86%B3%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E9%97%AE%E9%A2%98&quot;&gt;用text-overflow解决文字排版问题&lt;/a&gt; (3) &lt;a href=&quot;https://www.cnblogs.com/lbh2018/p/about_CSS3.html#%E6%96%B0%E7%9A%84%E5%AD%97%E4%BD%93%E5%8D%95%E4%BD%8Drem&quot;&gt;新的字体单位rem&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;css3-介绍&quot;&gt;CSS3 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E4%BB%8B%E7%BB%8D/css%E4%BB%8B%E7%BB%8D.html&quot;&gt;开始实例&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;新特征简介&quot;&gt;新特征简介&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;强大的CSS选择器&lt;/li&gt;
&lt;li&gt;抛弃图片的视觉效果&lt;/li&gt;
&lt;li&gt;盒模型变化（多列布局和弹性盒模型）&lt;/li&gt;
&lt;li&gt;阴影效果&lt;/li&gt;
&lt;li&gt;Web字体和web Font 图标&lt;/li&gt;
&lt;li&gt;CSS33过渡与动画交互效果&lt;/li&gt;
&lt;li&gt;媒体查询&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;查看浏览器份额&quot;&gt;查看浏览器份额&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://tongji.baidu.com/data/browser&quot;&gt;点我查看&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;伪类pesudo-classes&quot;&gt;伪类（Pesudo Classes）&lt;/h3&gt;
&lt;h4 id=&quot;动态伪类选择器&quot;&gt;（1）动态伪类选择器&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E4%BB%8B%E7%BB%8D/%E5%8A%A8%E6%80%81%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8.html&quot;&gt;实例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;:link 设置a对象在未被访问前的样式表属性&lt;/p&gt;
&lt;p&gt;:visited 设置a对象在其链接地址已被访问过时的样式表属性&lt;/p&gt;
&lt;p&gt;:hover 设置对象在其鼠标悬停时的样式表属性&lt;/p&gt;
&lt;p&gt;:active 设置对象在被用户激活（在鼠标点击与释放之间发生的事件）时的样式表属性&lt;/p&gt;
&lt;p&gt;定义CSS时候的顺序不同，也会直接导致链接显示的效果不同。原因可能在于浏览器解释CSS时遵循的“就近原则”。正确的顺序：a:link、a:visited、a:hover、a:active&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;link:连接平常的状态&lt;/li&gt;
&lt;li&gt;visited:连接被访问过之后&lt;/li&gt;
&lt;li&gt;hover:鼠标放到连接上的时候&lt;/li&gt;
&lt;li&gt;active:连接被按下的时候&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;结构伪类选择器&quot;&gt;（2）结构伪类选择器&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E4%BB%8B%E7%BB%8D/%E7%BB%93%E6%9E%84%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8.html&quot;&gt;实例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;:first-child 选择某个元素第一个子元素&lt;/p&gt;
&lt;p&gt;:last-child 选择某个元素最后一个子元素&lt;/p&gt;
&lt;p&gt;:nth-child() 选择某个元素的一个或者多个特定的子元素&lt;/p&gt;
&lt;p&gt;:nth-last-child 选择某个元素的一个或者多个特定的子元素，从这个元素的最后一个子元素开始算&lt;/p&gt;
&lt;p&gt;:nth-of--type() 选择指定的元素&lt;/p&gt;
&lt;p&gt;:nth-last-of--type() 选择指定的元素，从元素的最后一个开始计算&lt;/p&gt;
&lt;p&gt;:first-of-type 选择一个上级元素下的第一个同类子元素&lt;/p&gt;
&lt;p&gt;:last-of-type 选择一个上级元素下的最后一个同类子元素&lt;/p&gt;
&lt;p&gt;:only-of-type 选择的是它父元素唯一一个子元素&lt;/p&gt;
&lt;p&gt;:empty 选择的元素里面没有内容&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;伪元素&quot;&gt;伪元素&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E4%BB%8B%E7%BB%8D/%E4%BC%AA%E5%85%83%E7%B4%A0.html&quot;&gt;实例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS 伪元素用于向某些选择设置特殊效果&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;:first-letter&lt;/td&gt;
&lt;td&gt;将特殊的样式添加到文本的首字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;:first-line&lt;/td&gt;
&lt;td&gt;将特殊的样式添加到文本的首行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;:before&lt;/td&gt;
&lt;td&gt;在某些元素之前插入某些内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;:after&lt;/td&gt;
&lt;td&gt;在某些元素之后插入某些内容&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;css3-变形&quot;&gt;CSS3 变形&lt;/h2&gt;
&lt;h3 id=&quot;border-radius&quot;&gt;（1）border-radius&lt;/h3&gt;
&lt;h4 id=&quot;半圆标准写法&quot;&gt;半圆+标准写法&lt;/h4&gt;
&lt;p&gt;左上角开始，顺时针&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/border-radius.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/KxZezZ&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/circle.png&quot; alt=&quot;半圆&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.demo5{
    width: 100px;
    height: 200px;
    border: 1px solid #ccc;
    background: #f66;
    margin: 50px auto;
    border-radius: 0px 100px 100px 0px;                                 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;border&quot;&gt;（2）border&lt;/h3&gt;
&lt;h4 id=&quot;三角形对话框&quot;&gt;三角形+对话框&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E4%B8%89%E8%A7%92%E5%BD%A2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/JaMZXq&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/triangle.png&quot; alt=&quot;三角形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.triangle{
    border-top:100px solid #ccc;
    border-bottom:100px solid transparent;
    border-right:100px solid transparent;
    border-left:100px solid transparent;    
    width: 0;
    height: 0;                              
    margin: 50px auto;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E4%B8%89%E8%A7%92%E5%BD%A2%E5%AF%B9%E8%AF%9D%E6%A1%86.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/mGpKEP&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/triangle-dialog.png&quot; alt=&quot;对话框&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style&amp;gt;
.triangle-dialog{
    background: #6a6;
    margin: 50px auto;
    width: 300px;
    height: 25px;
    line-height: 25px;
    padding: 10px;
    border-radius: 6px;
    color:#fff;
    position: relative;         
}
.triangle-dialog::before{
    content:'';
    border-left: 0px solid #6a6;
    border-top: 10px solid transparent; 
    border-right: 10px solid #6a6;
    border-bottom: 10px solid transparent;  
    position: absolute;
    left: -10px;    
    top: 10px;          
}
&amp;lt;/style&amp;gt;

html
&amp;lt;div class=&quot;triangle-dialog&quot;&amp;gt;
    你好！我是三角形对话框
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;菱形和平行四边形&quot;&gt;（3）菱形和平行四边形&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8E%E8%8F%B1%E5%BD%A2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/bxaKeR&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/diamond.png&quot; alt=&quot;菱形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.diamond {
    width: 200px;
    height: 200px;
    background: #6a6;
    margin: 100px auto;
    -webkit-transform: rotate(-45deg);
    -ms-transform: rotate(-45deg);
    -o-transform: rotate(-45deg);
    transform: rotate(-45deg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/rZpKLq&quot;&gt;演示&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/parallel.png&quot; alt=&quot;平行四边形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.parallel{
    width: 200px;
    height: 200px;
    background: #6a6;
    margin: 100px auto;
    /*skew 倾斜（x, y）*/
    -webkit-transform: skew(20deg);
    -ms-transform: skew(20deg);
    -o-transform: skew(20deg);
    transform: skew(20deg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五角星和六角星&quot;&gt;（4）五角星和六角星&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E6%98%9F%E5%BD%A2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/mGpKrP&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/star.png&quot; alt=&quot;五角星&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;
&amp;lt;style&amp;gt;
    #star{
        position: relative;
        width: 0;
        height: 0;
        border-bottom: 70px solid #f66;
        border-left: 100px solid transparent;
        border-right: 100px solid transparent;
        margin: 150px auto;
        -webkit-transform: rotate(35deg);
        -ms-transform: rotate(35deg);
        -o-transform: rotate(35deg);
        transform: rotate(35deg);
    }
    #star::before{
        position: absolute;
        top: -50px;
        left: -69px;
        content: '';
        width: 0;
        height: 0;
        border-bottom: 80px solid #f66;
        border-left: 30px solid transparent;
        border-right: 30px solid transparent;
        -webkit-transform: rotate(-35deg);
        -ms-transform: rotate(-35deg);
        -o-transform: rotate(-35deg);
        transform: rotate(-35deg);
    }
    #star::after{
        position: absolute;
        content: '';
        top: 4px;
        left: -105px;
        width: 0;
        height: 0;
        border-bottom: 70px solid #f66;
        border-left: 100px solid transparent;
        border-right: 100px solid transparent;
        -webkit-transform: rotate(-70deg);
        -ms-transform: rotate(-70deg);
        -o-transform: rotate(-70deg);
        transform: rotate(-70deg);
    }       
&amp;lt;/style&amp;gt;


&amp;lt;div id=&quot;star&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/mogen-david.png&quot; alt=&quot;六角星&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;        #mogen-david{
            position: relative;
            width: 0;
            height: 0;
            border-bottom: 100px solid #f66;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            margin: 100px auto;
        }   
        #mogen-david::before{
            position: absolute;
            content: '';
            top: 30px;
            left: -50px;
            width: 0;
            height: 0;
            border-top: 100px solid #f66;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五边形和六边形&quot;&gt;（5）五边形和六边形&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E4%BA%94%E8%BE%B9%E5%BD%A2%E4%B8%8E%E5%85%AD%E8%BE%B9%E5%BD%A2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/aaEjbv&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/pentagon.png&quot; alt=&quot;五边形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.pentagon{
    position: relative;
    margin: 100px auto;
    width: 54px;
    height: 0;
    border-top: 50px solid #f66;
    border-left: 18px solid transparent;
    border-right: 18px solid transparent;
}
.pentagon::after{
    content: '';
    position: absolute;
    top: -85px;
    left: -17px;
    width: 0;
    height: 0;
    border-bottom: 35px solid #f66;
    border-left: 45px solid transparent;
    border-right: 45px solid transparent;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/hexagon.png&quot; alt=&quot;六边形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.hexagon{
    position: relative;
    margin: 100px auto;
    width: 100px;
    height: 50px;
    background: #f66;
}   
.hexagon::before{
    content: '';
    top: -25px;
    position: absolute;
    width: 0;
    height: 0;
    border-bottom: 25px solid #f66;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
}
.hexagon::after{
    content: '';
    top: 50px;
    position: absolute;
    width: 0;
    height: 0;
    border-top: 25px solid #f66;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;心形和蛋边形&quot;&gt;（6）心形和蛋边形&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E5%BF%83%E5%BD%A2%E4%B8%8E%E8%9B%8B%E5%BD%A2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/BOJPNx&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/hearts.png&quot; alt=&quot;心形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;// 无圆心
.hearts{
    position: relative;
    margin: 50px auto;
    width: 50px;
    height: 80px;
    background: #f66;
    border-top-right-radius: 25px;
    border-top-left-radius: 25px;
    -webkit-transform: rotate(-45deg);
    -ms-transform: rotate(-45deg);
    -o-transform: rotate(-45deg);
    transform: rotate(-45deg);
}
.hearts:before{
    position: absolute;
    content: '';
    top: 15px;
    left: 15px;
    width: 50px;
    height: 80px;
    background: #f66;
    border-top-right-radius: 25px;
    border-top-left-radius: 25px;
    -webkit-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    transform: rotate(90deg);
}

// 有圆心
.hearts1::before{
    position: absolute;
    left: 50px;
    content: '';
    margin: 50px auto;
    width: 50px;
    height: 80px;
    background: #f66;
    border-radius: 50px 40px 0 0;
    -webkit-transform-origin:0 100% ;
    -ms-transform-origin:0 100% ;
    -o-transform-origin:0 100% ;
    transform-origin:0 100% ;
    -webkit-transform: rotate(-45deg);
    -ms-transform: rotate(-45deg);
    -o-transform: rotate(-45deg);
    transform: rotate(-45deg);
}   
.hearts1::after{
    position: absolute;
    content: '';
    margin: 50px auto;
    width: 50px;
    height: 80px;
    background: #f66;
    border-radius: 50px 40px 0 0;
    -webkit-transform-origin:100% 100% ;
    -ms-transform-origin:100% 100% ;
    -o-transform-origin:100% 100% ;
    transform-origin:100% 100% ;
    -webkit-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    -o-transform: rotate(45deg);
    transform: rotate(45deg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/ogival.png&quot; alt=&quot;蛋形&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.ogival{
    margin: 100px auto;
    width: 60px;
    height: 100px;
    background: #fa3;
    /*(x / y)*/
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;太极阴阳图&quot;&gt;（7）太极阴阳图&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8F%98%E5%BD%A2/%E5%A4%AA%E6%9E%81%E9%98%B4%E9%98%B3%E5%9B%BE.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/vzpaKe&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/taiji.png&quot; alt=&quot;太极阴阳图&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;body{
    background: rgb(193, 193, 193);
}
.taiji{
    position: relative;
    margin: 200px auto;
    width: 200px;
    height: 400px;
    background: #fff;
    border-radius: 200px;
    border-left: 200px solid #000;
}
.taiji:before{
    position: absolute;
    left: -100px;
    content: '';
    width: 100px;
    height: 100px;
    border:50px solid #fff;
    background: #000;
    border-radius: 200px;
}   
.taiji:after{
    position: absolute;
    left: -100px;
    top: 200px;
    content: '';
    width: 100px;
    height: 100px;
    border:50px solid #000;
    background: #fff;
    border-radius: 200px;
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;css3-色彩&quot;&gt;CSS3 色彩&lt;/h2&gt;
&lt;h3 id=&quot;透明背景图层&quot;&gt;透明背景图层&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%89%B2%E5%BD%A9/%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%E5%9B%BE%E5%B1%82.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/pOpZbm&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;opacity : value&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.show{
    margin: 50px auto;
    width: 200px;
    height: 200px;
    padding: 10px;
    text-align: center;
    opacity: 0.5;
    background: #fff;
    border-radius: 40px;
    -webkit-box-shadow: 3px 3px 5px #888;
    box-shadow: 3px 3px 5px #888;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;颜色模式1&quot;&gt;颜色模式1&lt;/h3&gt;
&lt;p&gt;（1）rgba(R, G, B, A)&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;正整数 | 百分数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;正整数 | 百分数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;正整数 | 百分数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;Alpha 透明度 ( 0~1 )&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;（2）hsla(H, S, L, A)&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;Hue(色调) ，红色：0 | 360，绿色：120，蓝色：240。 取值范围：0 ~ 360&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;Saturation(饱和度)。取值范围：0.0% ~ 100.0%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;Lightness(亮度)。取值范围：0.0% ~ 100.0%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;Alpha 透明度 ( 0~1 )&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;颜色模式2&quot;&gt;颜色模式2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%89%B2%E5%BD%A9/%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%BC%8F2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/JaMBWb&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;#main{
    margin: 100px auto;
    width: 800px;
    clear:both;
}
#main li{
    list-style: none;
    width: 240px;
    padding: 1px;
    border:1px solid rgba(255,0,0,0);
    cursor: pointer;
}
#main li:hover{
    border:1px solid rgba(255,0,0,0.8);
}
#main li:hover .img img{

    opacity: 0.7;
}
.img img {
    width: 240px;
    -webkit-transition: all .5s;
    -o-transition: all .5s;
    transition: all .5s;
}
.goods_title{
    margin: 10px;
    height: 50px;
    color:#666;
    overflow: hidden;
}
.price{
    margin: 10px;
    color:#f00;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;线性渐变&quot;&gt;线性渐变&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%89%B2%E5%BD%A9/%E7%BA%BF%E6%80%A7%E6%B8%90%E5%8F%98.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/xapJrR&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语法：linear-gradient( [ &amp;lt;point&amp;gt; || &amp;lt;angle&amp;gt; ,] ? &amp;lt;stop&amp;gt; , &amp;lt;stop&amp;gt; [,&amp;lt;stop&amp;gt;] * )&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&amp;lt;angle&amp;gt;&lt;/td&gt;
&lt;td&gt;用角度值指定渐变的方向（或角度）。to left (270deg) | to right (90deg) | to top(0deg) | to bottom(180deg) 分别代表渐变方向：右 -&amp;gt; 左，左 -&amp;gt; 右，下 -&amp;gt; 上，上 -&amp;gt; 下&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;color-stop&amp;gt;&lt;/td&gt;
&lt;td&gt;用于指定渐变的起止颜色&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;length&amp;gt;&lt;/td&gt;
&lt;td&gt;用长度值指定起止色位置。不允许负值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;percentage&amp;gt;&lt;/td&gt;
&lt;td&gt;用百分比指定起止色位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;lt;color&amp;gt;&lt;/td&gt;
&lt;td&gt;指定颜色&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.demo{
    margin: 50px auto;
    width: 260px;
    height: 200px;
    border:1px solid black;
    background-image: linear-gradient(to left,orange 100px, green 160px,red 260px);
    /*或者*/
    background-image: linear-gradient(270deg,orange 100px, green 160px,red 260px);
    background-image: linear-gradient(to left,orange 20%, green 40%x,red 100%);
    /*加前缀*/
    background-image: -webkit-linear-gradient(70deg,orange 100px, green 160px,red 260px);
    background-image:-o-linear-gradient(70deg,orange 100px, green 160px,red 260px);
    background-image:linear-gradient(70deg,orange 100px, green 160px,red 260px);    
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;径向渐变&quot;&gt;径向渐变&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%89%B2%E5%BD%A9/%E5%BE%84%E5%90%91%E6%B8%90%E5%8F%98.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/VGyBzM&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语法：radial-gradient( [&amp;lt;bg-position&amp;gt; || &amp;lt;angle&amp;gt;, ] ? [ &amp;lt;shape&amp;gt; || &amp;lt;size&amp;gt; ,] ? &amp;lt;color-stop&amp;gt; , &amp;lt;color-stop&amp;gt;[, &amp;lt;color-stop&amp;gt;]* )&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;/*circle 圆*/
.circle{
    background-image: radial-gradient(circle at right,orange,green);
}
/*ellipse 椭圆*/
.ellipse{
    background-image: radial-gradient(ellipse at right,orange,green);
}       
.circle{
    background-image: radial-gradient(circle at right top,orange,green);
}
.ellipse{
    background-image: radial-gradient(ellipse at right top,orange,green);
}   
/*x*/
.circle{
    background-image: radial-gradient(20px circle at center,orange,green);
}
/*x, y*/
.ellipse{
    background-image: radial-gradient(20px 30px ellipse at center,orange,green);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重复性渐变&quot;&gt;重复性渐变&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%89%B2%E5%BD%A9/%E9%87%8D%E5%A4%8D%E6%80%A7%E6%B8%90%E5%8F%98.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/YOYjrE&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.linear{
    width: 300px;   
    height: 300px;  
    margin: 20px auto;
    border:1px solid #ccc;  
    background-image: repeating-linear-gradient(orange 0px, green 40px,red 80px);
}
.circle{
    width: 300px;   
    height: 300px;  
    margin: 20px auto;
    border-radius: 50%;
    border:1px solid #ccc;  
    background-image: repeating-radial-gradient(orange 0px, green 30px,red 40px);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;盒子阴影效果&quot;&gt;盒子阴影效果&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%89%B2%E5%BD%A9/%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/ZMvjaG&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语法：box-shadow : h-shadow v-shadow blur spread color inset;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;h-shadow&lt;/td&gt;
&lt;td&gt;水平阴影的位置。允许负值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;v-shadow&lt;/td&gt;
&lt;td&gt;垂直阴影的位置。允许负值&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;blur&lt;/td&gt;
&lt;td&gt;模糊距离&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;spread&lt;/td&gt;
&lt;td&gt;阴影的尺寸&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;color&lt;/td&gt;
&lt;td&gt;阴影的颜色。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inset&lt;/td&gt;
&lt;td&gt;将外部阴影（outset）改为内部阴影&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;css3-过渡&quot;&gt;CSS3 过渡&lt;/h2&gt;
&lt;h3 id=&quot;制作缓慢变长的方形&quot;&gt;制作缓慢变长的方形&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%BF%87%E6%B8%A1/%E5%88%B6%E4%BD%9C%E7%BC%93%E6%85%A2%E5%8F%98%E9%95%BF%E7%9A%84%E6%96%B9%E5%BD%A2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/GXyBOG&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简写语法：transition: property duration delay timing-function;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;transition-property&lt;/td&gt;
&lt;td&gt;过渡属性（默认值为all）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;transition-duration&lt;/td&gt;
&lt;td&gt;过渡持续时间（默认值为0s）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;transition-timing-function&lt;/td&gt;
&lt;td&gt;过渡函数（默认值为ease函数）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;transition-delay&lt;/td&gt;
&lt;td&gt;过渡延迟时间（默认值为0s）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.demo{
    width: 100px;
    height: 100px;
    background: pink;
    cursor: pointer;
    /*过渡时间*/
    -webkit-transition-duration: 2s;
    -o-transition-duration: 2s;
    transition-duration: 2s;
    /*过渡属性*/
    -webkit-transition-property: height width;
    -o-transition-property: height width;
    transition-property:  height width;
    /*延迟时间*/
    -webkit-transition-delay: 1s;
    -o-transition-delay: 1s;
    transition-delay: 1s;
    /*过渡函数*/
    -webkit-transition-timing-function: ease;
    -o-transition-timing-function: ease;
    transition-timing-function: ease;
    /*简写形式*/
    -webkit-transition: height width 2s 1s ease;
    -o-transition: height width 2s 1s ease;
    transition: height width 2s 1s ease;    
}
.demo:hover{
    /*边框跟颜色也可以渐变*/
    width: 300px;
    height: 150px;
    background: #f66;
    border-radius: 40%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;过渡的timing-function属性详解&quot;&gt;过渡的timing-function属性详解&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%BF%87%E6%B8%A1/%E8%BF%87%E6%B8%A1%E7%9A%84timing-function%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3.html&quot;&gt;实例&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ease&lt;/td&gt;
&lt;td&gt;慢 -&amp;gt; 快 -&amp;gt; 慢&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;linear&lt;/td&gt;
&lt;td&gt;匀速&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ease-in&lt;/td&gt;
&lt;td&gt;开始慢 结束快&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ease-out&lt;/td&gt;
&lt;td&gt;开始快 结束慢&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ease-in-out&lt;/td&gt;
&lt;td&gt;慢 -&amp;gt; 快 -&amp;gt; 慢&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;step-start&lt;/td&gt;
&lt;td&gt;无视过渡时间，延迟时间结束后直接变化&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;仿天猫类别过渡效果制作&quot;&gt;仿天猫类别过渡效果制作&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%BF%87%E6%B8%A1/%E4%BB%BF%E5%A4%A9%E7%8C%AB%E7%B1%BB%E5%88%AB%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E5%88%B6%E4%BD%9C.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/oPpMpe&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.main{
    width: 200px;
    height: 200px;
    border: 1px solid #ccc;
    margin: 50px auto;
    font-family: 'Microsoft YaHei';
    cursor: pointer;
}
.main:hover img {
    right: 10px;
}
.m_title{
    text-align: left;
    font-size:20px;
    padding: 20px 10px 10px 10px;
}
.m_content{
    color:#11ccaa;
    padding: 0 10px 10px 10px;
}
.m_img{
    position: relative;
    text-align: right;
}
.m_img img{
    position: absolute;
    width: 100px;
    top: 0;
    right: 0;
    -webkit-transition: all 0.5s;
    -o-transition: all 0.5s;
    transition: all 0.5s;           
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;仿天猫专题过渡效果实例&quot;&gt;仿天猫专题过渡效果实例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E8%BF%87%E6%B8%A1/%E4%BB%BF%E5%A4%A9%E7%8C%AB%E4%B8%93%E9%A2%98%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/ZMvjrG&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.main{
    margin: 10px auto;
    width: 230px;
    border:1px solid #ccc;
    text-align: center;
    font-family: 'Microsoft YaHei';
    cursor: pointer;
}
.m_title{
    font-weight: 700;
    margin: 5px;
    font-size: 20px;
}
.m_content{
    color:#666;
    margin-bottom: 15px;
}
.main:hover img{
    -webkit-transform: scale(1.1);
    -ms-transform: scale(1.1);
    -o-transform: scale(1.1);
    transform: scale(1.1);
}
.m_img{
    position: relative;
    padding: 30px;
}
.m_img::before{
    position: absolute;
    content: '';
    top: 10px;
    left: 35px;
    width: 160px;
    height: 160px;
    background: #eee;
    border-radius: 50%;
    z-index: -1;
}
img{
    width: 120px;
    -webkit-transform: scale(1);
    -ms-transform: scale(1);
    -o-transform: scale(1);
    transform: scale(1);
    -webkit-transition: all 0.5s;
    -o-transition: all 0.5s;
    transition: all 0.5s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;css3-动画&quot;&gt;CSS3 动画&lt;/h2&gt;
&lt;h3 id=&quot;动画中的keyframes关键帧讲解&quot;&gt;动画中的@keyframes关键帧讲解&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BB%E4%B8%AD%E7%9A%84@keyframes%E5%85%B3%E9%94%AE%E5%B8%A7%E8%AE%B2%E8%A7%A3.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/vzpadd&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.rect{
    width: 100px;
    height: 100px;
    background: red;
    position: fixed;
    animation: myMove 2s infinite;
}
@keyframes myMove{
    0%{ top:0; left:20%;background:red; }
    25%{ top:0; left:80%; background:blue;}
    50%{ top:80%; left:80%; background:green;}
    75%{ top:80%; left:20%;background:black; }
    100%{ top:0; left:20%; background:red;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;动画animation符合属性讲解&quot;&gt;动画animation符合属性讲解&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BBanimation%E7%AC%A6%E5%90%88%E5%B1%9E%E6%80%A7%E8%AE%B2%E8%A7%A3.html&quot;&gt;实例&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*指定动画名字*/
-webkit-animation-name: myMove;
-o-animation-name: myMove;
animation-name: myMove;
/*动画延续时间*/
-webkit-animation-duration: 1s;
-o-animation-duration: 1s;
animation-duration: 1s;
/*动画运动函数*/
-webkit-animation-timing-function: ease;
-o-animation-timing-function: ease;
animation-timing-function: ease;
/*动画延迟时间*/
-webkit-animation-delay: 1s;
-o-animation-delay: 1s;
animation-delay: 1s;
/*动画循环次数(infinite 无限循环)*/
-webkit-animation-iteration-count: 3;
-o-animation-iteration-count: 3;
animation-iteration-count: 3;
/*动画顺序 normal|alternate*/
-webkit-animation-direction: alternate;
-o-animation-direction: alternate;
animation-direction: alternate;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;动画综合实例制作-loading加载动画制作&quot;&gt;动画综合实例制作-loading加载动画制作&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BB%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B%E5%88%B6%E4%BD%9C-loading%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/MqrBVY&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.spinner{
    margin: 100px auto;
    width: 60px;
    height: 60px;
    text-align: center;
    font-size:10px;
}
.spinner &amp;gt; div{
    background: #67cf22;
    height: 100%;
    width: 6px;
    display: inline-block;
    animation:myMove 1.2s infinite ease-in-out;
}
.spinner &amp;gt; div:nth-child(2){
    -webkit-animation-delay: -1.1s;
    -o-animation-delay: -1.1s;
    animation-delay: -1.1s;
}       
.spinner &amp;gt; div:nth-child(3){
    -webkit-animation-delay: -1s;
    -o-animation-delay: -1s;
    animation-delay: -1s;
}       
.spinner &amp;gt; div:nth-child(4){
    -webkit-animation-delay: -0.9s;
    -o-animation-delay: -0.9s;
    animation-delay: -0.9;
}       
.spinner &amp;gt; div:nth-child(5){
    -webkit-animation-delay: -0.8s;
    -o-animation-delay: -0.8s;
    animation-delay: -0.8;
}
@keyframes myMove{
    0%,40%,100%{-webkit-transform: scaleY(0.4);
    -ms-transform: scaleY(0.4);
    -o-transform: scaleY(0.4);
    transform: scaleY(0.4);}            
    20%{-webkit-transform: scaleY(1);
    -ms-transform: scaleY(1);
    -o-transform: scaleY(1);
    transform: scaleY(1);}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;loading动画效果实例2&quot;&gt;Loading动画效果实例2&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E5%8A%A8%E7%94%BB/Loading%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B2.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/wEqNKX&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.spinner{
    width: 60px;
    height: 60px;
    position: relative;
    margin: 100px auto;
}
.spinner &amp;gt; div{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: #67cf22;
    opacity: 0.6;
    animation: myLoading 2s infinite ease-in-out;
}
.spinner &amp;gt; div:nth-child(2){
    -webkit-animation-delay: -1s;
    -o-animation-delay: -1s;
    animation-delay: -1s;
}
@keyframes myLoading{
    0% ,100%{ transform: scale(0.0); }
    50% { transform: scale(1); }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;css3-文字排版&quot;&gt;CSS3 文字排版&lt;/h2&gt;
&lt;h3 id=&quot;制作发光字立体字苹果字体&quot;&gt;制作发光字，立体字，苹果字体&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88/%E5%88%B6%E4%BD%9C%E5%8F%91%E5%85%89%E5%AD%97%E7%AB%8B%E4%BD%93%E5%AD%97%E8%8B%B9%E6%9E%9C%E5%AD%97%E4%BD%93.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/jvYpzg&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语法：text-shadow: h-shadow v-shadow blur color;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/%E5%88%B6%E4%BD%9C%E5%8F%91%E5%85%89%E5%AD%97%E7%AB%8B%E4%BD%93%E5%AD%97%E8%8B%B9%E6%9E%9C%E5%AD%97%E4%BD%93.png&quot; alt=&quot;制作发光字立体字苹果字体&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;body{
    background: #666;
    text-align: center;
    font: 700 55px 'Microsoft YaHei'
}
.font1{
    color:#fff;
    text-shadow: 2px 2px 3px #000;
}
.font2{
    color:#fff;
    text-shadow: 0 0 20px red;
}
.font3{
    text-shadow: 0 1px 1px #fff;
}       
.font4{
    color:#fff;
    text-shadow: 1px 1px 0px rgba(197,223,248,0.8),
                 2px 2px 0px rgba(197,223,248,0.8),
                 3px 3px 0px rgba(197,223,248,0.8),
                 4px 4px 0px rgba(197,223,248,0.8),
                 5px 5px 0px rgba(197,223,248,0.8),
                 6px 6px 0px rgba(197,223,248,0.8);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;用text-overflow解决文字排版问题&quot;&gt;用text-overflow解决文字排版问题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LbhFront-end/About-CSS3/blob/master/code/CSS3%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88/%E7%94%A8text-overflow%E8%A7%A3%E5%86%B3%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E9%97%AE%E9%A2%98.html&quot;&gt;实例&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/MqrBGw&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;语法：text-overflow:clip|ellipsis|string;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LbhFront-end/About-CSS3/master/code/img/%E7%94%A8text-overflow%E8%A7%A3%E5%86%B3%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E9%97%AE%E9%A2%98.png&quot; alt=&quot;用text-overflow解决文字排版问题&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.demo{
    margin: 30px auto;
    width: 100px;
    padding: 10px;
    border:1px solid #ccc;
    height: 50px;
    /*clip 需要overflow:hidden支持，但是不加clip只要overflow:hidden却也可以实现效果*/
    text-overflow:clip; 
    overflow: hidden;

}       
.demo1{
    margin: 30px auto;
    width: 100px;
    padding: 10px;
    border:1px solid #ccc;
    height: 50px;
    
    -webkit-text-overflow:ellipsis; 
    text-overflow:ellipsis;
    overflow: hidden;
    /*关键 出现省略号 不换行*/
    white-space: nowrap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新的字体单位rem&quot;&gt;新的字体单位rem&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://pxtoem.com/&quot;&gt;px/em/rem换算地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://codepen.io/lbhfront-end/pen/oPpMdG&quot;&gt;演示&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;px&lt;/td&gt;
&lt;td&gt;它是一个绝对尺寸单位，是不能变动的&lt;/td&gt;
&lt;td&gt;像素单位 。 是显示屏上显示的每一个小点，为显示的最小单位。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;em&lt;/td&gt;
&lt;td&gt;1.em的值并不是固定不变的。2.em会继承父级元素字体的大小rem&lt;/td&gt;
&lt;td&gt;描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位，可以变动。一般浏览器字体大小默认为16px，则2em == 32px&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;rem&lt;/td&gt;
&lt;td&gt;相对于应用&amp;lt;html&amp;gt;根元素的字体尺寸 。&lt;/td&gt;
&lt;td&gt;1. 它是描述相对于当前根元素字体尺寸，除了描述对象与em不同其余都和em一样 。 2.如果要对网页根元素字体大小进行修改，需要在&amp;lt;html&amp;gt;标签中加上style=&quot;font-size:value&quot;属性&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 17 Oct 2018 06:15:00 +0000</pubDate>
<dc:creator>赖同学</dc:creator>
<og:description>1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lbh2018/p/About_CSS3.html</dc:identifier>
</item>
<item>
<title>高可用Redis(九)：Redis Sentinel - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/9803838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/9803838.html</guid>
<description>&lt;h2 id=&quot;主从复制高可用的问题&quot;&gt;1.主从复制高可用的问题&lt;/h2&gt;
&lt;p&gt;主从复制高可用的作用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.为master提供备份，当master宕机时，slave有完整的备份数据
2.对master实现分流，实现读写分离&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是主从架构有一个问题&lt;/p&gt;
&lt;p&gt;1.如果master宕机，故障转移需要手动完成或者由别的工具来完成，从slave中选择一个slave做为新的master&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;写能力和存储能力受限
只能在一个节点是写入数据
所有数据只能保存在一个节点上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141126029-629752756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图模拟了主从复制架构中一主两从情况下，master宕机，则slave从master同步数据也断开，此时client向master写入数据会失败，读写分离时读取数据正常，但不能更新数据&lt;/p&gt;
&lt;p&gt;master出现故障之后，手动进行故障转移步骤&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.选择一个slave，执行slave no one命令使之成为一个master
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141137430-1361658034.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2.对其余的slave执行slaveof new master命令，将这些slave指定为新的master的slave
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141150471-1681819750.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3.client会对新的master进行写入数据，从slave中读取原来的数据
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141203294-2138659270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的操作过程需要手动完成，或者编写脚本，由脚本来执行这个过程，但是这个过程是有问题的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;怎么判断一个Redis节点是有问题的，怎么通知client对新master进行写入操作
怎么保证一个完整的事务实现过程&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的过程就可以使用Redis Sentinel来实现&lt;/p&gt;
&lt;h2 id=&quot;redis-sentinel架构说明&quot;&gt;2.Redis Sentinel架构说明&lt;/h2&gt;
&lt;p&gt;Redis Sentinel的功能：对Redis节点进行监控，故障判断，故障转移，故障通知&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141211881-1582401590.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于Redis的主从架构，Redis Sentinel会运行几个sentinel进程&lt;/p&gt;
&lt;p&gt;sentinel进程不操作数据，而是对Redis故障进行判断和转移&lt;/p&gt;
&lt;p&gt;同时多个sentinel运行，即使一个sentinel进程运行异常，还有别的sentinel继续运行，可以保证对故障节点判断的准确性，同时保证Redis的高可用&lt;/p&gt;
&lt;p&gt;对于redis-cli来说，Redis cli不会再记录Redis的IP和端口，而是从sentinel获取Redis信息，然后进行连接Redis节点，进行数据写入和读取操作&lt;/p&gt;
&lt;p&gt;多个Redis Sentinel对所有的master和slave进行监控，会实时记录master和slave的地址信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141221315-1881829736.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;redis-sentinel故障转移步骤&quot;&gt;Redis Sentinel故障转移步骤：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1.当某个master发生故障，多个sentinel会监控到这个异常，这些sentinel会按照一定规则从多个slave中选中一个做为新的master,并通知别的slave从新的master中同步数据
2.当某个slave转换为新的master，sentinel会记录新的master的地址信息和slave的地址信息，通知Redis cli
3.Redis cli接收到新的master和slave的信息，就会向新的master写入数据，从slave中读取数据
4.等到原来的master重启之后，会变成新的master的slave,并从新的master同步数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141230706-1335593867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的步骤里，sentinel实现了Redis的故障自动发现，自动转移和自动通知&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：一套Redis sentinel集合可以通知master-name做为标识同时监控多套主从架构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;redis-sentinel安装配置&quot;&gt;3.Redis Sentinel安装配置&lt;/h2&gt;
&lt;h3 id=&quot;环境说明&quot;&gt;3.1 环境说明&lt;/h3&gt;
&lt;p&gt;实验在两台虚拟机上完成，IP地址分别为：192.168.81.100和192.168.81.101&lt;/p&gt;
&lt;p&gt;在两台虚拟机上运行4个redis-server,其中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;192.168.81.100的6379端口为master节点
192.168.81.100的6380端口为slave节点
192.168.81.101的6379端口和6380端口为slave节点&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在192.168.81.101的26379，26380，26381端口开启三个sentinel进行监控&lt;/p&gt;
&lt;h3 id=&quot;在192.168.81.100虚拟机上配置主从节点&quot;&gt;3.2 在192.168.81.100虚拟机上配置主从节点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# cd /etc/                            # 进入/etc目录
[root@localhost ~]# systemctl stop redis                # 关闭系统中运行的redis
[root@localhost etc]# cp redis.conf redis_6379.conf     # 复制redis配置文件，以端口区分，方便后面进行配置
[root@localhost etc]# cp redis.conf redis_6380.conf     # 复制redis配置文件，以端口区分，方便后面进行配置
[root@localhost etc]# vi redis_6379.conf                # 编辑redis-server配置文件，修改下面几行
    bind 0.0.0.0                                        # 修改bing选项，才能从系统外连接redis
    protected-mode yes                                  # 开启保存模式
    port 6379                                           # 指定redis运行的端口
    daemonize yes                                       # 以守护进程启动redis
    pidfile &quot;/var/run/redis_6379.pid&quot;                   # 指定redis运行时pid保存路径
    logfile &quot;/var/log/redis/redis_6379.log&quot;             # 指定redis运行时日志保存路径
    dir /var/lib/redis_6379                             # 指定redis运行时数据文件保存路径
    
[root@localhost etc]# vi redis_6380.conf                # 修改redis-server,修改下面几行
    bind 0.0.0.0
    port 6380                                           # 指定redis运行的端口
    daemonize yes
    pidfile &quot;/var/run/redis_6380.pid&quot;
    logfile &quot;/var/log/redis/redis_6380.log&quot;
    dir /var/lib/redis_6380
    slaveof 192.168.81.100 6379                         # 指定redis-server为192.168.81.100:6379的slave
    
[root@localhost etc]# redis-server /etc/redis_6379.conf     # 指定配置文件运行redis-server
[root@localhost etc]# redis-server /etc/redis_6380.conf     # 指定配置文件运行redis-server
[root@localhost etc]# ps aux | grep redis-server            # 查看redis-server是否运行
root       2548  0.3  1.7 155192 17720 ?        Ssl  23:14   0:00 redis-server 0.0.0.0:6379
root       2562  1.3  1.7 155192 17596 ?        Ssl  23:15   0:00 redis-server 0.0.0.0:6380
root       2567  0.0  0.0 112648   960 pts/3    R+   23:15   0:00 grep --color=auto redis-server
[root@localhost etc]# redis-cli -p 6380 info replication    # 进入6380端口运行redis客户端，并执行'info replication'命令
# Replication
role:slave                              # 角色为slave
master_host:192.168.81.100              # master为192.168.81.100
master_port:6379
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:1919
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在192.168.81.101虚拟机上配置从节点&quot;&gt;3.3 在192.168.81.101虚拟机上配置从节点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql ~]# cd /etc/                                # 操作同192.168.81.100相同
[root@mysql ~]# systemctl stop redis
[root@mysql etc]# cp redis.conf redis_6379.conf
[root@mysql etc]# cp redis.conf redis_6380.conf
[root@mysql etc]# vi redis_6379.conf
    bind 0.0.0.0
    protected-mode yes
    port 6379
    daemonize yes
    pidfile &quot;/var/run/redis_6379.pid&quot;
    logfile &quot;/var/log/redis/redis_6379.log&quot;
    dir /var/lib/redis_6379
    slaveof 192.168.81.100 6379                         # 指定redis-server为192.168.81.100:6379的slave
    
[root@mysql etc]# vi redis_6380.conf    
    bind 0.0.0.0
    port 6380
    daemonize yes
    pidfile &quot;/var/run/redis_6380.pid&quot;
    logfile &quot;/var/log/redis/redis_6380.log&quot;
    dir /var/lib/redis_6380
    slaveof 192.168.81.100 6379                         # 指定redis-server为192.168.81.100:6379的slave
    
[root@mysql etc]# redis-server /etc/redis_6379.conf     # 指定配置文件运行redis-server
[root@mysql etc]# redis-server /etc/redis_6380.conf     # 指定配置文件运行redis-server
[root@mysql ~]# ps aux | grep redis-server              # 查看redis-server是否运行
root       2178  0.2  0.8 155204 17728 ?        Ssl  15:10   0:02 redis-server 0.0.0.0:6379
root       2184  0.2  0.8 155204 17724 ?        Ssl  15:10   0:02 redis-server 0.0.0.0:6380
root       2411  0.0  0.0 112664   972 pts/2    R+   15:29   0:00 grep --color=auto redis-server
[root@mysql ~]# redis-cli -p 6379 info replication
# Replication
role:slave                              # 角色为slave
master_host:192.168.81.100              # master为192.168.81.100
master_port:6379
master_link_status:up
master_last_io_seconds_ago:6
master_sync_in_progress:0
slave_repl_offset:1961
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
[root@mysql ~]# redis-cli -p 6380 info replication   
# Replication
role:slave                              # 角色为slave
master_host:192.168.81.100              # master为192.168.81.100
master_port:6379
master_link_status:up
master_last_io_seconds_ago:2
master_sync_in_progress:0
slave_repl_offset:1975
slave_priority:100
slave_read_only:1
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在192.168.81.101虚拟机上配置并运行sentinel&quot;&gt;3.4 在192.168.81.101虚拟机上配置并运行sentinel&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@mysql etc]# cp redis-sentinel.conf sentinel_26379.conf    # 复制sentinel配置文件，方便区分
[root@mysql etc]# cp redis-sentinel.conf sentinel_26380.conf    # 复制sentinel配置文件，方便区分
[root@mysql etc]# cp redis-sentinel.conf sentinel_26381.conf    # 复制sentinel配置文件，方便区分
[root@mysql etc]# vi sentinel_26379.conf                        # 修改sentinel配置文件,修改下面几行
    daemonize yes                                               # 以守护进程方式启动
    port 26379                                                  # 指定端口
    protected-mode no                                           # 关闭保护模式
    sentinel monitor mymaster 192.168.81.100 6379 2             # 设置sentinel监控信息
    logfile /var/log/redis/sentinel_26379.log                   # 设置日志文件保存路径
[root@mysql etc]# vi sentinel_26380.conf 
    daemonize yes
    port 26380  
    protected-mode no  
    sentinel monitor mymaster 192.168.81.100 6379 2
    logfile /var/log/redis/sentinel_26380.log
[root@mysql etc]# vi sentinel_26381.conf 
    protected-mode no  
    port 26381
    daemonize yes  
    sentinel monitor mymaster 192.168.81.100 6379 2
    logfile /var/log/redis/sentinel_26381.log
[root@mysql etc]# redis-sentinel /etc/sentinel_26379.conf       # 指定配置文件，启动Redis Sentinel
[root@mysql etc]# redis-sentinel /etc/sentinel_26380.conf       # 指定配置文件，启动Redis Sentinel  
[root@mysql etc]# redis-sentinel /etc/sentinel_26381.conf       # 指定配置文件，启动Redis Sentinel
[root@mysql etc]# ps aux | grep sentinel                        # 查看Redis Sentinel是否运行
root       2709  0.9  0.2 142916  5464 ?        Ssl  15:49   0:00 redis-sentinel *:26379 [sentinel]
root       2713  1.1  0.2 142916  5472 ?        Ssl  15:49   0:00 redis-sentinel *:26380 [sentinel]
root       2717  2.0  0.2 142916  5476 ?        Rsl  15:49   0:00 redis-sentinel *:26381 [sentinel]
root       2721  0.0  0.0 112664   964 pts/2    R+   15:49   0:00 grep --color=auto sentinel
[root@mysql ~]# redis-cli -p 26379
127.0.0.1:26379&amp;gt; ping                                           # 执行ping操作
PONG
127.0.0.1:26379&amp;gt; info sentinel                                  # 查看所有sentinel的信息
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=192.168.81.100:6379,slaves=3,sentinels=3                   # 被监控的Redis主从架构命名为mymaster，被监控Redis节点的master为192.168.81.100L6379,有三个slave,同时有3个sentinel运行
127.0.0.1:26379&amp;gt; exit
[root@mysql ~]# grep -v '^#' /etc/sentinel_26379.conf | grep -v '^$'     #查看sentinel_26379配置文件，去除注释和空行，Redis Sentinel向配置文件中添加了几行内容
port 26379                                                  # sentinel运行的端口
dir &quot;/tmp&quot;
sentinel myid 9611958fc3e8b7c2be43385e44be88f87d725a77
sentinel monitor mymaster 192.168.81.100 6379 2             # sentinel监控的Redis节点名为mymaster,master地址为192.168.81.100:6379,quorem设置为2
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
logfile &quot;/var/log/redis/sentinel_26379.log&quot;
daemonize yes
sentinel known-slave mymaster 192.168.81.101 6379           # sentinel探测到的slave
sentinel known-slave mymaster 192.168.81.100 6380           # sentinel探测到的slave
sentinel known-slave mymaster 192.168.81.101 6380           # sentinel探测到的slave
sentinel known-sentinel mymaster 192.168.81.101 26380 17ca0cb82becb58bd24e5a87ee3b6e8e9a49caf1                    # Redis Sentinel深测到的别的运行的sentinel
sentinel known-sentinel mymaster 127.0.0.1 26381 fb9342f3007e2abff165f5c33de1d48cf089f062                    # Redis Sentinel深测到的别的运行的sentinel
sentinel current-epoch 0
[root@mysql ~]# grep -v '^#' /etc/sentinel_26380.conf | grep -v '^$'  
port 26380
dir &quot;/tmp&quot;
sentinel myid 17ca0cb82becb58bd24e5a87ee3b6e8e9a49caf1
sentinel monitor mymaster 192.168.81.100 6379 2
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
logfile &quot;/var/log/redis/sentinel_26380.log&quot;
daemonize yes
sentinel known-slave mymaster 192.168.81.101 6379
sentinel known-slave mymaster 192.168.81.101 6380
sentinel known-slave mymaster 192.168.81.100 6380
sentinel known-sentinel mymaster 127.0.0.1 26381 fb9342f3007e2abff165f5c33de1d48cf089f062
sentinel known-sentinel mymaster 192.168.81.101 26379 9611958fc3e8b7c2be43385e44be88f87d725a77
sentinel current-epoch 0
[root@mysql ~]# grep -v '^#' /etc/sentinel_26381.conf | grep -v '^$' 
port 26381
daemonize yes
dir &quot;/tmp&quot;
sentinel myid fb9342f3007e2abff165f5c33de1d48cf089f062
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
logfile &quot;/var/log/redis/sentinel_26381.log&quot;
sentinel known-sentinel mymaster 127.0.0.1 26380 17ca0cb82becb58bd24e5a87ee3b6e8e9a49caf1
sentinel known-sentinel mymaster 192.168.81.101 26379 9611958fc3e8b7c2be43385e44be88f87d725a77
sentinel current-epoch 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，3个sentinel已经正常运行了&lt;/p&gt;
&lt;h3 id=&quot;python客户端持续通过sentinel向redis写入数据读取数据&quot;&gt;3.5 python客户端持续通过sentinel向Redis写入数据，读取数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import random
import time
from redis.sentinel import Sentinel

sentinel = Sentinel([
    ('192.168.81.101',26379),
    ('192.168.81.101',26380),
    ('192.168.81.101',26381),
],socket_timeout=0.1)               # 传入Redis Sentinel集合

while True:
    try:
        master = sentinel.discover_master('mymaster')
        print('current master IP:',master)          # 打印当前master的IP地址和端口
        val = random.randint(0,10000)               # 获取10000以内随机整数
        key = 'k%d' % val
        m = sentinel.master_for('mymaster', socket_timeout=0.5)
        m.set(key,'val%d' % val)                    # 通过sentinel向master节点写入数据
        v = m.get(key)                              # 通过sentinel读取数据
        print('{0} value is {1}'.format(key,v))
        time.sleep(1)
    except Exception as e:
        print(&quot;get no val:&quot;,e)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;current master IP: ('192.168.81.100', 6379)
k6081 value is b'val6081'
current master IP: ('192.168.81.100', 6379)
k1778 value is b'val1778'
current master IP: ('192.168.81.100', 6379)
k4927 value is b'val4927'
current master IP: ('192.168.81.100', 6379)
k4074 value is b'val4074'
current master IP: ('192.168.81.100', 6379)
k1138 value is b'val1138'
current master IP: ('192.168.81.100', 6379)
k862 value is b'val862'
current master IP: ('192.168.81.100', 6379)
k4854 value is b'val4854'
current master IP: ('192.168.81.100', 6379)
k9233 value is b'val9233'
current master IP: ('192.168.81.100', 6379)
k6844 value is b'val6844'
current master IP: ('192.168.81.100', 6379)
k8089 value is b'val8089'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在192.168.81.100虚拟机上模拟master故障&quot;&gt;3.6 在192.168.81.100虚拟机上模拟master故障&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost etc]# redis-cli -p 6379                 # 连接6379端口连接redis-server
127.0.0.1:6379&amp;gt; info server                             # 执行命令查看当前redis-server的进程ID
# Server
redis_version:3.2.10
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:c8b45a0ec7dc67c6
redis_mode:standalone
os:Linux 3.10.0-514.el7.x86_64 x86_64
arch_bits:64
multiplexing_api:epoll
gcc_version:4.8.5
process_id:2548                                         # 192.168.81.100:6379这个master节点的进程ID为2548
run_id:8ae71ba92660697d52bfb74b99fb15ee82a7cf84
tcp_port:6379
uptime_in_seconds:6552
uptime_in_days:0
hz:10
lru_clock:12896355
executable:/etc/redis-server
config_file:/etc/redis_6379.conf
127.0.0.1:6379&amp;gt; exit
[root@localhost etc]# kill -9 2548                      # 在系统中kill掉2548这个进程
[root@localhost etc]# ps aux | grep redis-server        # 查看redis-server运行的进程，2548已经被终止
root       2562  0.2  1.7 155192 17756 ?        Ssl  Oct15   0:19 redis-server 0.0.0.0:6380
root       2651  0.0  0.0 112648   960 pts/3    S+   01:19   0:00 grep --color=auto redis-server&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看python代码执行结果&quot;&gt;3.7 查看python代码执行结果&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;current master IP: ('192.168.81.100', 6379)
1539597332.9189174 k6187 value is b'val6187'
current master IP: ('192.168.81.100', 6379)
1539597333.9236474 k1462 value is b'val1462'
current master IP: ('192.168.81.100', 6379)
get no val: Timeout connecting to server
current master IP: ('192.168.81.100', 6379)
get no val: Timeout connecting to server
current master IP: ('192.168.81.100', 6379)
get no val: Timeout connecting to server
...中间报错信息省略
get no val: No master found for 'mymaster'
get no val: No master found for 'mymaster'
get no val: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.
get no val: No master found for 'mymaster'
...中间报错信息省略
get no val: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.
current master IP: ('192.168.81.101', 6379)
1539597365.971147 k3568 value is b'val3568'
current master IP: ('192.168.81.101', 6379)
1539597366.974567 k7745 value is b'val7745'
current master IP: ('192.168.81.101', 6379)
1539597367.9783657 k6281 value is b'val6281'
current master IP: ('192.168.81.101', 6379)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;初始master是192.168.81.100:6379&lt;/code&gt;，在系统命令提示符中kill掉6379端口的redis-server后，python程序从&lt;code&gt;1539597333.9236474&lt;/code&gt;秒后一直抛出异常，直到&lt;code&gt;1539597365.971147&lt;/code&gt;秒，python程序通过sentinel获取到新的master为&lt;code&gt;192.168.81.101:6379&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1539597365.971147&lt;/code&gt;减去&lt;code&gt;1539597333.9236474&lt;/code&gt;恰好就是sentinel配置文件中&lt;code&gt;sentinel down-after-milliseconds mymaster&lt;/code&gt;选项设定的&lt;code&gt;30000毫秒&lt;/code&gt;，也就是30秒&lt;/p&gt;
&lt;h3 id=&quot;查看redis-sentinel的日志&quot;&gt;3.8 查看Redis Sentinel的日志&lt;/h3&gt;
&lt;p&gt;在192.168.81.101虚拟机上查看&lt;code&gt;/var/log/redis/sentinel_26379.log&lt;/code&gt;日志，下面的部分日志就是sentinel在切换master的记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4067:X 15 Oct 17:55:40.303 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:42.119 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:42.334 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:44.208 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:44.349 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:46.266 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:46.365 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:48.419 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:48.481 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:50.429 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:50.506 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:52.548 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:52.571 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:54.592 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:54.598 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:56.655 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:56.662 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:58.734 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:55:58.886 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:00.798 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:00.972 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:02.884 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:03.042 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:04.917 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:05.099 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:07.045 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:07.112 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:09.145 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:09.324 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:11.218 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:11.345 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:12.211 # +sdown master mymaster 192.168.81.100 6379
4067:X 15 Oct 17:56:12.345 # +new-epoch 8
4067:X 15 Oct 17:56:12.346 # +vote-for-leader fb9342f3007e2abff165f5c33de1d48cf089f062 8
4067:X 15 Oct 17:56:13.267 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:13.269 * +sentinel-address-switch master mymaster 192.168.81.100 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:13.289 # +odown master mymaster 192.168.81.100 6379 #quorum 2/2
4067:X 15 Oct 17:56:13.289 # Next failover delay: I will not start a failover before Mon Oct 15 18:02:13 2018
4067:X 15 Oct 17:56:13.440 # +config-update-from sentinel fb9342f3007e2abff165f5c33de1d48cf089f062 192.168.81.101 26381 @ mymaster 192.168.81.100 6379
4067:X 15 Oct 17:56:13.441 # +switch-master mymaster 192.168.81.100 6379 192.168.81.101 6379
4067:X 15 Oct 17:56:13.441 * +slave slave 192.168.81.101:6380 192.168.81.101 6380 @ mymaster 192.168.81.101 6379
4067:X 15 Oct 17:56:13.441 * +slave slave 192.168.81.100:6380 192.168.81.100 6380 @ mymaster 192.168.81.101 6379
4067:X 15 Oct 17:56:13.441 * +slave slave 192.168.81.100:6379 192.168.81.100 6379 @ mymaster 192.168.81.101 6379
4067:X 15 Oct 17:56:15.586 * +sentinel-address-switch master mymaster 192.168.81.101 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:15.604 * +sentinel-address-switch master mymaster 192.168.81.101 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:15.689 * +sentinel-address-switch master mymaster 192.168.81.101 6379 ip 127.0.0.1 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062
4067:X 15 Oct 17:56:15.693 * +sentinel-address-switch master mymaster 192.168.81.101 6379 ip 192.168.81.101 port 26381 for fb9342f3007e2abff165f5c33de1d48cf089f062&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的日志可以看出，&lt;code&gt;在17:56:13.441时间点sentinel把master从182.168.81.100:6379切换到192.168.81.101:6379&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-sentinel客户端连接python版&quot;&gt;4.Redis Sentinel客户端连接(python版)&lt;/h2&gt;
&lt;p&gt;Redis Sentinel的高可用指的是服务端的高可用，对于Redis服务端的master宕机，sentinel可以对故障实现自动发现，自动转移，自动通知。这个过程客户端是感知不到的&lt;/p&gt;
&lt;p&gt;Redis高可用即依赖于服务端的高可用，又依赖于客户端的高可用&lt;/p&gt;
&lt;p&gt;通过分析Redis Sentinel的请求响应流程，可以知道客户端实现高可用步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.客户端遍历sentinel节点集合，获取一个可用的sentinel节点，同时获取masterName
2.在可用的sentinel节点上执行sentinel的API，获取master的地址和端口
3.在sentinel内部，sentinel会按照一定频率在master或者slave上执行info命令，获取对应节点的信息
4.客户端获取到master的地址和端口，会执行role命令或者role replication命令，对master进行验证
5.当master出现故障，sentinel按照算法从slave中选出一个做为新的master，同时把其余的slave做为新的master的slave
6.sentinel维护一个频道，sentinel在这个频道中发布消息，指出新master的IP和端口
7.客户端订阅这个频道，接收消息后就知道新master的IP和端口，向新master连接进行数据处理&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141253851-1720819161.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python客户端接入Redis Sentinel需要两个参数：sentinel地址集合，masterName&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意的是Redis节点的配置文件中的&lt;code&gt;protected-mode&lt;/code&gt;必须设置为&lt;code&gt;yes&lt;/code&gt;，否则连接会失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from redis.sentinel import Sentinel

sentinel = Sentinel([
    ('192.168.81.101',26379),
    ('192.168.81.101',26380),
    ('192.168.81.101',26381),
],socket_timeout=0.1)

master = sentinel.discover_master('mymaster')
print(master)       # ('192.168.81.100', 6379)
slave = sentinel.discover_slaves('mymaster')
print(slave)        # [('192.168.81.100', 6380), ('192.168.81.101', 6379), ('192.168.81.101', 6380)]
        &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;redis-sentinel实现原理&quot;&gt;5.Redis Sentinel实现原理&lt;/h2&gt;
&lt;h3 id=&quot;redis-sentinel内部的三个定时任务&quot;&gt;5.1 Redis Sentinel内部的三个定时任务&lt;/h3&gt;
&lt;p&gt;Redis Sentinel内部有三个定时任务来对redid节点进行故障判断和转移&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.每10秒每个sentinel对master和slave执行&lt;code&gt;info&lt;/code&gt;命令，以发现slave节点和确认主从关系&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;sentinel在master节点执行&lt;code&gt;info replication&lt;/code&gt;命令，从命令执行结果中解析出slave节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141315283-1150118836.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2.每2秒每个sentinel通过master节点的channel交换信息(发布订阅)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;master节点上有一个发布订阅的channel频道：&lt;code&gt;__sentinel__:hello&lt;/code&gt;，用于所有sentinel之间进行信息交换&lt;/p&gt;
&lt;p&gt;一个sentinel发布消息，消息包含当前sentinel节点的信息，对其他sentinel节点的判断以及当前sentinel对master节点和slave节点的一些判断&lt;/p&gt;
&lt;p&gt;其他sentinel都可以接收到这条消息&lt;/p&gt;
&lt;p&gt;新加入sentinel节点时，sentinel节点之间可以相互感知，以达到信息交互的功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141327353-903705253.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3.每1秒每个sentinel对其他sentinel节点和Redis节点执行ping操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个sentinel都可以知道其他sentinel节点，当监控的master发生故障时，方便进行判断和新master的挑选，这个定时任务是master进行故障判定的依据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133627/201810/1133627-20181017141338288-406301294.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;主观下线和客观下线&quot;&gt;5.2 主观下线和客观下线&lt;/h3&gt;
&lt;p&gt;主观下线：每个sentinel节点对Redis节点失败的'偏见'&lt;/p&gt;
&lt;p&gt;在redis-sentinel配置文件中，有下面这种配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;
sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;timeout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个sentinel集合可以同时监控多个master,slave的节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sentinel对多个master，slave节点进行区分的标识就是master-name,ip和port是master节点的IP地址和端口,quorum是master客观下线之后sentinel进行判断的节点数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sentinel对master进行主观下线判断的时间，单们为毫秒&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;每个sentinel每秒对master和slave执行ping操作，当sentinel对master或slave在timeout定义的毫秒时间内没有回复，则sentinel会认为这个节点已经被主观下线了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面的例子中对sentinel的配置是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sentinel monitor mymaster 192.168.81.100 6379 2
sentinel down-after-milliseconds mymaster 30000
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sentinel集合监控名为mymaster的master,slave节点
被监控的master节点的IP地址是192.168.81.100，端口为6379，
sentinel会在`__sentinel__:hello`频道中交流对master节点的看法，如果sentinel节点都对master节点ping失败'达成共识'，sentinel个数超过quorum的个数，sentinel集合则会认为master节点客观下线
当两个sentinel对master节点执行ping操作，在30000毫秒(30秒)时间内没有得到回复，则认为节点已经被主观下线&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;quorum建议设置为：(sentinel节点数 / 2) + 1，可以根据应用场景进行设定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sentinel领导者选举&quot;&gt;5.3 sentinel领导者选举&lt;/h3&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;只需要一个sentinel节点就可以完成故障转移
通过`sentinel is-master-down-by-addr`命令来完成sentinel交换对master节点的失败判定和新master的选举&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成sentinel领导者选举步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.每个做主观下线的sentinel节点向其他sentinel节点发送命令，要求将自己设置为领导者
2.收到命令的sentinel节点如果没有同意同意其他sentinel节点发送的命令，那么将同意该请求，否则拒绝
3.如果该sentinel节点发现自己的票数已经超过sentinel集合半数且超过quorum，将成为领导者
4.如果此过程中有多个sentinel节点成为领导者，那么将等待一段时间重新进行选举
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;故障转移由sentinel领导者节点完成&quot;&gt;5.4 故障转移(由sentinel领导者节点完成)&lt;/h3&gt;
&lt;p&gt;故障转移步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.从slave节点中选出一个合适的节点作为新的master节点
2.对选出的slave节点执行`slaveof no one`命令，使成为新的master节点
3.向剩余的slave节点发送命令，让slave节点成为新master节点的slave节点，然后从新master节点同步数据
    数据同步规则和parallel-syncs参数有关
    如一个一主三从架构中，master故障，sentinel领导者从3个slave中选出一个作为新的master节点，剩余的两个slave节点会成为新master节点的slave，从新master节点同步同步数据
    master节点只需要生成一次RDB文件
        如果parallel-syncs参数设置为1，则剩余两个slave节点会按顺序从新master节点拷贝数据，一个slave切点拷贝完成，另外一个slave才会从新master节点拷贝数据
        如果parallel-syncs参数设置为2，则两个slave节点会同时从master节点进行数据拷贝，这无疑会加入新master的开销
4.sentinel领导者会把原来的master节点设置为slave节点，并保持对其'关注'，当原来的master节点恢复后，sentinel会使其去复制新master节点的数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;slave节点的选择&quot;&gt;5.5 slave节点的选择&lt;/h3&gt;
&lt;p&gt;slave节点选择规则&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.选择slave-priority(slave节点优先级)最高的slave节点，如果存在则返回，不存在则继续
2.选择复制偏移量(offset)最大的slave节点,offset最大说明对master的数据复制的最完整，如果存在则返回，不存在则继续
3.选择run_id最小的slave节点，run_id最小说明slave节点启动最早
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;6.总结：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Redis Sentinel是Redis的高可用实现方案：故障发现，故障自动转移，配置中心，客户端通知
Redis Sentinel是Redis 2.8版本开始才正式生产可用，之前版本不可用于生产
尽可以在不同物理机上部署Redis Sentinel所有节点，但是最好一个局域网内
Redis Sentinel中sentinel节点个数应该大于等于3，且最好为奇数，可以保证判断的公平
Redis Sentinel中的数据节点与普通数据节点没有区别
客户端初始化时连接的是Sentinel节点集合，不是具体的Redis节点，但是Sentinel只是配置中心不是代理
Redis Sentinel通过三个定时任务实现了Sentinel节点对于master，slave，其余sentinel节点的监控
Redis Sentinel在对节点做失败判定时分为主观下线和客观下线
看懂Redis Sentinel故障转移日志对于Redis Sentinel以及问题排查非常有帮助
Redis Sentinel实现读写分离高可用可以依赖Redis Sentinel节点的消息通知，获取Redis数据节点的状态变化&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 17 Oct 2018 06:14:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<og:description>1.主从复制高可用的问题 主从复制高可用的作用 1.为master提供备份，当master宕机时，slave有完整的备份数据 2.对master实现分流，实现读写分离 但是主从架构有一个问题 1.如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/9803838.html</dc:identifier>
</item>
<item>
<title>更快更强，深度学习新库fastai“落户”PyTorch - 爱生活，爱Python</title>
<link>http://www.cnblogs.com/qq2105154714/p/9800757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq2105154714/p/9800757.html</guid>
<description>&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/IryMFfJ.jpg!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;几天前，有人统计了历年ICLR论文录用者使用的深度学习框架，发现虽然TensorFlow还高居榜首，但PyTorch近一年来的使用数据已经翻了3倍，可以和TF比肩。这是个令人惊讶的消息，也让不少从业者开始正视这一发展趋势，筹备“双修”事宜。在下文中，论智给读者带来的是fast.ai发布的一个简便、好用的PyTorch库——对PyTorch感兴趣的读者不妨先从这个库开始试手。&lt;/p&gt;
&lt;p&gt;随着互联网和知识传播的深度结合，现在在线课程对许多人来说已经不是新鲜事物。在深度学习领域，最受学生欢迎的MOOC课程平台有三个：Fast.ai、deeplearning.ai /Coursera和Udacity。其中，因为Jeremy Howard化繁为简、实战为上的独特授课风格，Fast.ai给人的印象一直很“接地气”：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;研究如何快速、可靠地把最先进的深度学习应用于实际问题。&lt;/li&gt;
&lt;li&gt;提供Fast.ai库，它不仅是让新手快速构建深度学习实现的工具包，也是提供最佳实践的一个强大而便捷的资源。&lt;/li&gt;
&lt;li&gt;课程内容简洁易懂，以便尽可能多的人从研究成果和软件中收益。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;国庆期间，Fast.ai发布一个新的、面向深度学习的免费开源库——fastai。这是个PyTorch库，虽然还是预览版，但它目前已经为最重要的深度学习应用程序和数据类型提供了一致的API，且相比其他深度学习库，它在准确性和速度上有显着提高，同时所需的代码大大减少。&lt;/p&gt;
&lt;p&gt;感兴趣的开发者可以访问fastai的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/fastai/fastai/&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; 进行安装： &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/fastai/fastai/&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;github.com/fastai/fastai/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;fastai库&lt;/h2&gt;
&lt;p&gt;从去年宣布开发开始，历时18个月，fastai深度学习库v1.0终于和大家见面了。在项目启动之初，开发人员就曾介绍过PyTorch作为一个平台的优势：可以利用常规python代码的灵活性和各种函数构建、训练神经网络，可以解决更广泛的问题……&lt;/p&gt;
&lt;p&gt;现在，经过Fast.ai团队和PyTorch团队的共同努力，我们迎来了一个为计算机视觉、文本、表格数据、时间序列、协同过滤等常见深度学习应用提供单一一致界面的深度学习库。这意味着，如果你已经学会用fastai创建实用的计算机视觉（CV）模型，那你就可以用同样的方法创建自然语言处理（NLP）模型，或是软件支持的其他模型。&lt;/p&gt;
&lt;h2&gt;早期用户使用反馈&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GitHub上的语义代码搜索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fast.ai的课程是GitHub的数据科学家和高管（包括CEO在内）提高数据素养的一个重要途径，其中，Github的高级机器学习科学家Hithl Husain在过去两年中一直通过Fast.ai学习深度学习，他认为这些MOOC课程开启了Github的数据新时代，使数据科学家们更有信心解决机器学习中的最新问题。&lt;/p&gt;
&lt;p&gt;作为fastai的第一批使用者，Hithl Husain和他的同事Ho-Hsiang Wu最近发布了一个实验版工具“语义代码搜索”，允许开发者直接通过意义而不是关键词匹配来查找代码， &lt;strong&gt;这意味着最佳搜索结果不一定包含你搜索的单词&lt;/strong&gt; 。在 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//experiments.github.com/semantic-code-search&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;官方博客文章&lt;/a&gt; 中，他们介绍了自己弃用Tensorflow Hub转而投向fastai的原因，称后者能更轻松地访问最先进的架构（如AWD LSTMs）和技术（如随机重启循环学习率）。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/6vmMRfi.jpg!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                          语义代码搜索&lt;/p&gt;
&lt;p&gt;在过去的12个月里，Husain一直在体验预发布版本的fastai库。他表示：&lt;/p&gt;
&lt;p&gt;我之所以选择fast.ai，是因为它能在保证相同性能的情况下，用模块化、高级API实现最先进的技术和创新，同时减少计算量。语义代码搜索只是冰山一角，销售、营销、反欺诈，人们能用fastai为各行各业带去革命性的变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成音乐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Christine McLeavey Payne是从上一期Fast.ai深度学习课程中脱颖而出的一名学生。她的人生经历非常丰富：从旧金山交响乐团的古典钢琴师，到金融领域的HPC专家，再到斯坦福大学的神经科学和医学研究员。现在，她已经在OpenAI开启了又一段人生旅途，而在近期的OpenAI项目中，她用fastai创建了一个能生成钢琴曲和室内音乐的LSTM——Clara。&lt;/p&gt;
&lt;p&gt;fastai是一个了不起的资源，即便是我这样刚接触深度学习的新手，也能用短短几行代码就得到fastai模型。我不完全知道这些先进技术背后的原理，但我的模型能运行，而且训练用时更短，性能也更好。&lt;/p&gt;
&lt;p&gt;她的音乐生成模型基于上课期间她构建的一个语言模型，利用fastai库对NLP最新技术的支持，她在短短两周内就完成了这个音乐生成项目，并取得了很好的初步成果。这是fastai库实用性的一个典例，只需少量修改，开发者就能把文本分类模型改成音乐生成模型，这在实践中能节省大量时间和精力。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/qm2Erey.jpg!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                               IBM Watson高级研究员对音乐生成器Clara的评价&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;艺术创作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建筑师、投资者Miguel Pérez Michaus一直在用预发布版本的fastai进行他的“Style Reversion（风格还原）”实验。所谓“风格还原”，就是把风格迁移后的图像恢复成原本的样子，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/Jn2EBzm.jpg!web&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;                                                          风格还原&lt;/p&gt;
&lt;p&gt;他表示：“我喜欢用fastai创作，因为它能实现Keras不能实现的东西，比如生成‘不标准’的东西。”作为早期用户，他在过去12个月中目睹了fastai的更新迭代：&lt;/p&gt;
&lt;p&gt;我很幸运地体验了fastai的A测版本，虽然只是Alpha版，但它充分展示了自己的实用性和灵活性，而且允许我这样具有领域知识但没有正式计算机科学背景的人上手操作。fastai会变得越来越好。对于深度学习的未来，我个人有一点粗浅的认识，就是我们必须要详细掌握黑盒背后的真实技术原理，在这种情况下，我认为fastai会广受欢迎。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学术研究&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在NLP领域，波兰语一直是一个挑战，因为它是一种形态丰富的语言，如波兰语形容词会根据名词的数和性而变化。企业家Piotr Czapla和Marcin Kardas是深度学习咨询公司n-wave的联合创始人，基于 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//course.fast.ai/part2.html&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;Cutting Edge Deep Learning For Coders&lt;/a&gt; 这门课程中显示的思路，他们用fastai开发了一种新的波兰语文本分类算法，并在波兰顶级NLP学术竞赛中获得一等奖，有关这项新研究的论文即将发布。&lt;/p&gt;
&lt;p&gt;根据Czapla的说法，fastai库对他们的成功至关重要：&lt;/p&gt;
&lt;p&gt;fastai适合那些没有上百台服务器的普通人，这是我很喜欢它的一点。它支持快速开发和原型设计，并融入了所有最好的深度学习实践。同时，Fast.ai课程是我开始学习深度学习的指路明灯，从上课的那天起，我才开始思考深度学习能做什么。&lt;/p&gt;
&lt;h2&gt;示例：计算机视觉领域的迁移学习&lt;/h2&gt;
&lt;p&gt;Kaggle上有一个非常受欢迎的竞赛项目：Dogs vs Cats。参赛者需要编写一个算法来分类图像是包含狗还是猫。这也是Fast.ai课程中经常涉及的一个竞赛，因为它代表了一类重要问题：基于预训练模型的迁移学习。&lt;/p&gt;
&lt;p&gt;我们将以此为例，从 &lt;strong&gt;所需代码量、准确性和速度&lt;/strong&gt; 三个指标上比较Keras和fastai的差异。以下是用fastai进行2-stage微调时的所有代码——不仅要编写的代码非常少，设置的参数也非常少：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs haskell&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;data = data_from_imagefolder(&lt;span class=&quot;hljs-type&quot;&gt;Path('&lt;span class=&quot;hljs-title&quot;&gt;data/&lt;span class=&quot;hljs-title&quot;&gt;dogscats'),
    ds_tfms=get_transforms(), tfms=imagenet_norm, size=&lt;span class=&quot;hljs-number&quot;&gt;224)
&lt;span class=&quot;hljs-title&quot;&gt;learn = &lt;span class=&quot;hljs-type&quot;&gt;ConvLearner(&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;data, tvm.resnet34, metrics=accuracy)
&lt;span class=&quot;hljs-title&quot;&gt;learn.fit_one_cycle(&lt;span class=&quot;hljs-number&quot;&gt;6)
&lt;span class=&quot;hljs-title&quot;&gt;learn.unfreeze()
&lt;span class=&quot;hljs-title&quot;&gt;learn.fit_one_cycle(&lt;span class=&quot;hljs-number&quot;&gt;4, slice(&lt;span class=&quot;hljs-number&quot;&gt;1e-5,&lt;span class=&quot;hljs-number&quot;&gt;3e-4))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;下表是两个深度学习库的差异对比：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img0.tuicool.com/32yueyV.jpg!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Keras是现在最流行的训练神经网络的方法之一，以上数据虽然是片面的，但fastai的改进能从侧面说明Keras并不完美，它还有很大的改善空间。而无论是Keras还是其他深度学习库，要完成同样的任务，它们所需的代码量都远远超过fastai，相应的，它们的训练时间会更长，且模型性能不一定会更好。&lt;/p&gt;
&lt;p&gt;此外，fastai在NLP任务上也有强劲表现。下表是ULMFiT论文中的一幅截图，显示了文本分类算法ULMFiT与IMDb数据集中排名靠前的算法的相对误差：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/2eeuYrb.jpg!web&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                    文本分类性能总结&lt;/p&gt;
&lt;p&gt;fastai是目前唯一提供此算法的库，由于该算法是内置的，你可以直接参考上面的Dogs vs Cats代码复现论文结果。以下是训练ULMFiT语言模型的方法：&lt;/p&gt;
&lt;pre class=&quot;prettyprint hljs haskell&quot;&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;data = data_from_textcsv(&lt;span class=&quot;hljs-type&quot;&gt;LM_PATH, &lt;span class=&quot;hljs-type&quot;&gt;Tokenizer(), data_func=lm_data)
&lt;span class=&quot;hljs-title&quot;&gt;learn = &lt;span class=&quot;hljs-type&quot;&gt;RNNLearner.language_model(&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;data, drop_mult=0.3,
    pretrained_fnames=['lstm_wt103', 'itos_wt103'])
&lt;span class=&quot;hljs-title&quot;&gt;learn.freeze()
&lt;span class=&quot;hljs-title&quot;&gt;learn.fit_one_cycle(&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;1e-2, moms=(&lt;span class=&quot;hljs-number&quot;&gt;0.8,&lt;span class=&quot;hljs-number&quot;&gt;0.7))
&lt;span class=&quot;hljs-title&quot;&gt;learn.unfreeze()
&lt;span class=&quot;hljs-title&quot;&gt;learn.fit_one_cycle(&lt;span class=&quot;hljs-number&quot;&gt;10, &lt;span class=&quot;hljs-number&quot;&gt;1e-3, moms=(&lt;span class=&quot;hljs-number&quot;&gt;0.8,&lt;span class=&quot;hljs-number&quot;&gt;0.7), pct_start=&lt;span class=&quot;hljs-number&quot;&gt;0.25)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;来源： &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.fast.ai/2018/10/02/fastai-ai/&quot; rel=&quot;nofollow,noindex&quot; target=&quot;_blank&quot;&gt;www.fast.ai/2018/10/02/fastai-ai/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编译：Bot&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 06:03:00 +0000</pubDate>
<dc:creator>爱生活，爱Python</dc:creator>
<og:description>几天前，有人统计了历年ICLR论文录用者使用的深度学习框架，发现虽然TensorFlow还高居榜首，但PyTorch近一年来的使用数据已经翻了3倍，可以和TF比肩。这是个令人惊讶的消息，也让不少从业者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq2105154714/p/9800757.html</dc:identifier>
</item>
<item>
<title>Android开发 - 获取系统输入法高度的正确姿势 - ExampleCode</title>
<link>http://www.cnblogs.com/lloyd-zh/p/9803731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lloyd-zh/p/9803731.html</guid>
<description>&lt;h2 id=&quot;问题与解决&quot;&gt;问题与解决&lt;/h2&gt;
&lt;p&gt;在Android应用的开发中，有一些需求需要我们获取到输入法的高度，但是官方的API并没有提供类似的方法，所以我们需要自己来实现。&lt;/p&gt;
&lt;p&gt;查阅了网上很多资料，试过以后都不理想。&lt;/p&gt;
&lt;p&gt;比如有的方法通过监听布局的变化来计算输入法的高度，这种方式在Activity的配置中配置为&quot;android:windowSoftInputMode=&quot;adjustResize&quot;&quot;时没有问题，可以正确获取输入法的高度，因为布局此时确实会动态的调整。&lt;/p&gt;
&lt;p&gt;但是当Activity配置为&quot;android:windowSoftInputMode=&quot;adjustNothing&quot;&quot;时，布局不会在输入法弹出时进行调整，上面的方式就会扑街。&lt;/p&gt;
&lt;p&gt;不过经过一番探索和测试，终于发现了一种方式可以在即使设置为adjustNothing时也可以正确计算高度放方法。&lt;/p&gt;
&lt;p&gt;同时也感谢这位外国朋友：&lt;br/&gt;&lt;a href=&quot;https://github.com/siebeprojects/samples-keyboardheight/tree/master/app/src/main/java/com/siebeprojects/samples/keyboardheight&quot;&gt;GitHub地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实也就两个类，我也做了一些修改，解决了一些问题，这里也贴出来：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;KeyboardHeightObserver.java&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * The observer that will be notified when the height of 
 * the keyboard has changed
 */
public interface KeyboardHeightObserver {

    /** 
     * Called when the keyboard height has changed, 0 means keyboard is closed,
     * &amp;gt;= 1 means keyboard is opened.
     * 
     * @param height        The height of the keyboard in pixels
     * @param orientation   The orientation either: Configuration.ORIENTATION_PORTRAIT or 
     *                      Configuration.ORIENTATION_LANDSCAPE
     */
    void onKeyboardHeightChanged(int height, int orientation);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;KeyboardHeightProvider.java&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * The keyboard height provider, this class uses a PopupWindow
 * to calculate the window height when the floating keyboard is opened and closed. 
 */
public class KeyboardHeightProvider extends PopupWindow {

    /** The tag for logging purposes */
    private final static String TAG = &quot;sample_KeyboardHeightProvider&quot;;

    /** The keyboard height observer */
    private KeyboardHeightObserver observer;

    /** The cached landscape height of the keyboard */
    private int keyboardLandscapeHeight;

    /** The cached portrait height of the keyboard */
    private int keyboardPortraitHeight;

    /** The view that is used to calculate the keyboard height */
    private View popupView;

    /** The parent view */
    private View parentView;

    /** The root activity that uses this KeyboardHeightProvider */
    private Activity activity;

    /** 
     * Construct a new KeyboardHeightProvider
     * 
     * @param activity The parent activity
     */
    public KeyboardHeightProvider(Activity activity) {
        super(activity);
        this.activity = activity;

        LayoutInflater inflator = (LayoutInflater) activity.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
        this.popupView = inflator.inflate(R.layout.keyboard_popup_window, null, false);
        setContentView(popupView);

        setSoftInputMode(LayoutParams.SOFT_INPUT_ADJUST_RESIZE | LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
        setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);

        parentView = activity.findViewById(android.R.id.content);

        setWidth(0);
        setHeight(LayoutParams.MATCH_PARENT);

        popupView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

                @Override
                public void onGlobalLayout() {
                    if (popupView != null) {
                        handleOnGlobalLayout();
                    }
                }
            });
    }

    /**
     * Start the KeyboardHeightProvider, this must be called after the onResume of the Activity.
     * PopupWindows are not allowed to be registered before the onResume has finished
     * of the Activity.
     */
    public void start() {

        if (!isShowing() &amp;amp;&amp;amp; parentView.getWindowToken() != null) {
            setBackgroundDrawable(new ColorDrawable(0));
            showAtLocation(parentView, Gravity.NO_GRAVITY, 0, 0);
        }
    }

    /**
     * Close the keyboard height provider, 
     * this provider will not be used anymore.
     */
    public void close() {
        this.observer = null;
        dismiss();
    }

    /** 
     * Set the keyboard height observer to this provider. The 
     * observer will be notified when the keyboard height has changed. 
     * For example when the keyboard is opened or closed.
     * 
     * @param observer The observer to be added to this provider.
     */
    public void setKeyboardHeightObserver(KeyboardHeightObserver observer) {
        this.observer = observer;
    }
   
    /**
     * Get the screen orientation
     *
     * @return the screen orientation
     */
    private int getScreenOrientation() {
        return activity.getResources().getConfiguration().orientation;
    }

    /**
     * Popup window itself is as big as the window of the Activity. 
     * The keyboard can then be calculated by extracting the popup view bottom 
     * from the activity window height. 
     */
    private void handleOnGlobalLayout() {

        Point screenSize = new Point();
        activity.getWindowManager().getDefaultDisplay().getSize(screenSize);

        Rect rect = new Rect();
        popupView.getWindowVisibleDisplayFrame(rect);

        // REMIND, you may like to change this using the fullscreen size of the phone
        // and also using the status bar and navigation bar heights of the phone to calculate
        // the keyboard height. But this worked fine on a Nexus.
        int orientation = getScreenOrientation();
        int keyboardHeight = screenSize.y - rect.bottom;
        
        if (keyboardHeight == 0) {
            notifyKeyboardHeightChanged(0, orientation);
        }
        else if (orientation == Configuration.ORIENTATION_PORTRAIT) {
            this.keyboardPortraitHeight = keyboardHeight; 
            notifyKeyboardHeightChanged(keyboardPortraitHeight, orientation);
        } 
        else {
            this.keyboardLandscapeHeight = keyboardHeight; 
            notifyKeyboardHeightChanged(keyboardLandscapeHeight, orientation);
        }
    }

    private void notifyKeyboardHeightChanged(int height, int orientation) {
        if (observer != null) {
            observer.onKeyboardHeightChanged(height, orientation);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;此处以在Activity中的使用进行举例。&lt;/p&gt;
&lt;h4 id=&quot;实现接口&quot;&gt;实现接口&lt;/h4&gt;
&lt;p&gt;引入这两个类后，在当前Activity中实现接口KeyboardHeightObserver：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void onKeyboardHeightChanged(int height, int orientation) {
    String or = orientation == Configuration.ORIENTATION_PORTRAIT ? &quot;portrait&quot; : &quot;landscape&quot;;
    Logger.d(TAG, &quot;onKeyboardHeightChanged in pixels: &quot; + height + &quot; &quot; + or);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;定义并初始化&quot;&gt;定义并初始化&lt;/h4&gt;
&lt;p&gt;在当前Activity定义成员变量，并在onCreate()中进行初始化&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private KeyboardHeightProvider mKeyboardHeightProvider;

@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    ...
    mKeyboardHeightProvider = new KeyboardHeightProvider(this);
    new Handler().post(() -&amp;gt; mKeyboardHeightProvider.start());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;生命周期处理&quot;&gt;生命周期处理&lt;/h4&gt;
&lt;p&gt;初始化完成后，我们要在Activity中的生命周期中也要进行处理，以免内存泄露。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected void onResume() {
    super.onResume();
    mKeyboardHeightProvider.setKeyboardHeightObserver(this);
}

@Override
protected void onPause() {
    super.onPause();
    mKeyboardHeightProvider.setKeyboardHeightObserver(null);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    mKeyboardHeightProvider.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;此时我们就可以正确获取的当前输入法的高度了，即使android:windowSoftInputMode=&quot;adjustNothing&quot;时也可以正确获取到，这正是这个方法的强大之处，利用这个方法可以实现比如类似微信聊天的界面，流畅切换输入框，表情框等。&lt;/p&gt;
&lt;p&gt;如有更多疑问，请参考我的其它Android相关博客：&lt;a href=&quot;http://examplecode.cn/categories/Android%E5%BC%80%E5%8F%91/&quot;&gt;我的博客地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 05:59:00 +0000</pubDate>
<dc:creator>ExampleCode</dc:creator>
<og:description>问题与解决 在Android应用的开发中，有一些需求需要我们获取到输入法的高度，但是官方的API并没有提供类似的方法，所以我们需要自己来实现。 查阅了网上很多资料，试过以后都不理想。 比如有的方法通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lloyd-zh/p/9803731.html</dc:identifier>
</item>
<item>
<title>原创 | 入门数据分析--数据存储之常用数据库及区别 - 南瓜精</title>
<link>http://www.cnblogs.com/tongxuenihao/p/9803718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tongxuenihao/p/9803718.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;获取数据，除了通过外部获得，内部获取，也是一个主要获取数据的方式。&lt;strong&gt;内部数据主要是通过数据库存储的方式，将数据存下来，便于各个需求方再去提取应用。&lt;/strong&gt;&lt;strong&gt;那么，企业常用的存储数据的数据库都有哪些呢？不同的数据库的存储区别又有哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前市场上的数据库主要可以分为关系型数据库和非关系型数据库&lt;/strong&gt;，关系型数据库通过外键关联来建立表与表之间的关系，而非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库中，我们查询一条数据，结果出来一个数组，关系型数据库中，查询一条数据结果是一个对象。&lt;strong&gt;而目前商品化的数据库管理系统以关系型数据库为主导产品，技术也比较成熟。&lt;/strong&gt;接下来就让我们来了解下几个重要的数据库吧：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489417/201810/1489417-20181017135531568-401141532.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 Access数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是一个关系&lt;/span&gt;&lt;span&gt;型&lt;/span&gt;&lt;span&gt;数据库管理系统&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本地桌面型数据库&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;存储的数据量较少，&lt;/span&gt;&lt;span&gt;是小型的数据库&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询语句为&lt;/span&gt;SQL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 MYSQL数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;是一个关系&lt;/span&gt;&lt;span&gt;型&lt;/span&gt;&lt;span&gt;数据库管理系统&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是开源的&lt;/span&gt;&lt;span&gt;，总体拥有成本低；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持多种操作系统；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有安装简单、使用简单、管理也简单等特点。是很多初学者的首要选择&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;难担当大系统的数据仓库，运行速度慢，不够稳定，有掉线的情况&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;被广泛地应用在&lt;/span&gt;Internet上的中小型网站中&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询语句为&lt;/span&gt;SQL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt; &lt;strong&gt;SQL Server&lt;/strong&gt;&lt;strong&gt; &lt;span&gt;数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是一个关系&lt;/span&gt;&lt;span&gt;型&lt;/span&gt;&lt;span&gt;数据库管理系统&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是非开源的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中型的数据库；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行速度明显比&lt;/span&gt;MYSQL快N多（海量数据下这个优势显而易见）&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询语句为&lt;/span&gt;SQL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt; &lt;strong&gt;Oracle&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数据库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是一个关系&lt;/span&gt;&lt;span&gt;型数&lt;/span&gt;&lt;span&gt;据库管理系统&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不是开源的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持多种操作系统；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作比较复杂&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;价格比较昂贵；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Oracle的稳定性要比Sql server好&lt;span&gt;，&lt;/span&gt;Sql server的易用性和友好性方面要比Oracle好&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是基于服务器的大型数据库&lt;/span&gt;&lt;span&gt;，主要应用于银行、证券类业务等&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询语句为&lt;/span&gt;SQL。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5  Hive 数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;是非关系型数据库管理系统；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据规模大；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要进行离线的大数据分析；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询语句为&lt;/span&gt;HQL；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489417/201810/1489417-20181017135545586-1777605304.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;写到最后，简单了解常用的数据库及区别，主要目的在于可以帮助分析师在提取数据的时候，更加得心应手。&lt;strong&gt;充分利用数据库的优势，根据需求的不同判断使用适合的数据库去提取数据，善待不同的数据库&lt;/strong&gt;，嘿嘿！&lt;/p&gt;

</description>
<pubDate>Wed, 17 Oct 2018 05:56:00 +0000</pubDate>
<dc:creator>南瓜精</dc:creator>
<og:description>获取数据，除了通过外部获得，内部获取，也是一个主要获取数据的方式。内部数据主要是通过数据库存储的方式，将数据存下来，便于各个需求方再去提取应用。那么，企业常用的存储数据的数据库都有哪些呢？不同的数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tongxuenihao/p/9803718.html</dc:identifier>
</item>
<item>
<title>实例！软件缺陷数据度量和分析 - Vincent83</title>
<link>http://www.cnblogs.com/yingyingja/p/9803542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yingyingja/p/9803542.html</guid>
<description>&lt;p&gt;　　缺陷报告，是软件测试这个职位最重要得产出之一。甚至对软件测试这个行业你可以用比较狭隘的描述去定义他为：‘测试就是为了找到缺陷’。 测试人员报出的缺陷，可以很好的反应产品中的问题，修复了这些问题，就可以有效的降低产品风险。其实缺陷报告不单单能帮助研发团队发现问题，他也可以起到重要的过程反馈作用。&lt;/p&gt;
&lt;p&gt;　　缺陷报告是我们测试报告的两大核心要素之一，他与测试执行情况一起组成了我们测试报告的主要内容。那么缺陷报告，我们应该报告一些什么，是不是仅仅是缺陷数量呢？我们今天就来说说怎么用‘量化分析’的形式，来制作我们的缺陷报告。&lt;/p&gt;

&lt;p&gt;　　我们用一个实际项目缺陷报告来阐述这个课题，这个项目情况是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;该项目为一个COTS产品的定制性二次开发项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目周期计划为4个月，实际完成时间为6个月&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目是一个总体人员不到10人的小型项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;采用持续集成，高速迭代的研发方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　&lt;strong&gt;1.　&lt;/strong&gt;　我们要看到的第一个报表叫做‘&lt;strong&gt;缺陷到达率报告&lt;/strong&gt;’，见下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017121438447-948576552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　缺陷到达率指的是单位时间内，报出缺陷的数量。 上图按照每月报出的缺陷数量进行了统计，并且按严重级别进行了分类。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 缺陷到达率在前四个月内呈明显下降趋势&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 五月份的缺陷量回升主要体现在低严重级缺陷数量上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 缺陷数的严重级别成正态分布&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④ 六月份缺陷明显回升&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　结合着项目的实际我们对这个报表进行分析：后两个月的bug数量上升主要是因为在这段时间我们的测试分别引入了集中的回归测试和验收测试（我们将UAT测试中，客户报出的bug导入到了我们的缺陷管理系统内）。客户报出的缺陷方面，严重级偏高，这可能是因为客户对于缺陷严重级别的理解，与我们研发团队的理解并不一致所造成的。我们有可能需要跟客户就这个方面进行更好的交流和沟通。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.　　缺陷移除率分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017122016814-998487686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　缺陷移除率指的是我们在研发各阶段明确和解决的本阶段引入的缺陷的比例。&lt;/p&gt;
&lt;p&gt;　　在软件测试的基础理论里面我们强调，软件测试应该尽早的介入项目，一般要求在需求分析阶段就进行参与，并且我们要用静态测试的方法去对各阶段的产出进行测试。在本阶段我们就应该去追求去尽量明确本阶段所产生的问题缺陷。而缺陷移除率表现的就是我们在当阶段明确发现该阶段引入的缺陷及问题的能力，反过来他又能体现出有多少问题被从一个阶段遗留到了下一阶段。&lt;/p&gt;
&lt;p&gt;　　比如说，在需求阶段，我们的产出：需求文档里面就引入了10个缺陷，我们在当阶段通过需求评审测试等工作，发现并明确其中的2个缺陷。那么该阶段的缺陷移除率就是2/10=20%。而缺陷遗留率就是（10-2）/10=80%，有80%的缺陷被遗留进了下一个阶段。&lt;/p&gt;
&lt;p&gt;　　更直观的来说我们还可以做出下面的表格和图表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017130231853-2002835258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017130248366-1623949192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt;对我们以上的报表进行分析，我们可能可以得出以下结论：　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 需求阶段缺陷移除率较低，说明需求评审工作的缺失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 验收阶段报出需求问题数量可观，说明需求团队与用户的沟通不畅&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 单元测试整体发现缺陷数过低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④ 测试以外的人员缺陷报告数较低&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　　除此之外，通过实际项目调查我们发现，实际团队除测试小组的其他人员有着不爱报bug的倾向。实际上，一个项目的质量是应该与团队所有人员都息息相关的，而不仅仅是测试团队的任务。我们是不是应该更鼓励项目其他方面人员去主动提交缺陷，是值得我们思考的一个问题。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3.　　缺陷分布率分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017130757691-941822150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　缺陷分布率指的是针对不同的功能模块，所报出的缺陷数量。 上图是一个小型电子商务平台的缺陷分布率情况。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 商品浏览模块报出的总体缺陷量较多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 支付模块报出严重缺陷较多&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　这个图表在直观度上有所欠缺，而且也不能最准确的表述各模块的质量特征。这里我们可以做一次加权处理：比如不同严重级的缺陷，给他不同的分数，进行二次计算，再来重新统计。&lt;/p&gt;
&lt;p&gt;　　例：严重缺陷权值5，关键缺陷权值3，其他权值1，得出：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017131221206-942953277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到支付模块的占比上升了，他与浏览展示模块构成项目质量指标最值得关注的两大部分，从而可以指导我们测试资源的投入。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4.　　缺陷修复率分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017131438915-1591098815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　缺陷修复率指的在一定单位时间内，报出的，被修复的以及遗留的缺陷数量的对比。这是比较直观的一种报表。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 缺陷报出数量在经历了稳定下降之后，在项目后期迎来了回升&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 开发团队的bug修复能力在4月份出现滑坡，据调查是因为开发核心人员受到了抽调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 项目收尾时的bug遗留数量不容乐观，主要是由于最后两个月报出bug数量激增造成&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　通过这样报表展示和分析，我们也可以得出一些有用的结论：比如我们是否应该考虑将回归测试的动作前移；又比如我们可以发现团队核心成员的稳定性是一个项目成功的重要要素。&lt;/p&gt;

&lt;p&gt;　　其他还有很多形式的统计报表我们可以考虑，比如：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5.　　缺陷修复轮次统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017131711881-703229571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　缺陷修复轮次统计通过统计缺陷被激活的次数，来观察缺陷都需要经过多少轮的修复才能被关闭这样的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　解析：&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 项目大部分缺陷经历了多次修复&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 反映了开发与测试团队存在一定程度的沟通问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 部分原因在于测试团队的测试描述不充分&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;6.　　缺陷有效率统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017132144085-1548326721.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　缺陷有效率指的是我们报出的缺陷中间，有效缺陷的百分比。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt; &lt;span&gt;可以明显看到，测试环境问题已经很大程度影响到了测试的有效率&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;7.　　阶段缺陷分布统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017132334399-107720515.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　阶段缺陷分布指的是在一定时间阶段内，我们汇报的bug严重级别上又怎样的分布情况。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt; &lt;span&gt;5月份有明显的次严重级bug数上升 6月份有最严重级bug数上升&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;8.　　缺陷类型分布统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017132504210-1490948297.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt; &lt;span&gt;大部分缺陷类型集中为功能性，可能揭示了我们在其他质量指标的关注不足&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　9&lt;strong&gt;&lt;strong&gt;.　　测试活动缺陷率统计&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451355/201810/1451355-20181017132633401-543741229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 系统测试的效率并没有我们想象中的那么高（200多个缺陷中，只有不到40%来源于系统测试阶段）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 外部测试的缺陷数令人担忧（指的实际上UAT测试的结果）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 回归测试和探索性测试发现了系统测试没有发现的问题，说明他们都是非常有效而且必要的测试活动&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　以上我们讨论了在测试缺陷数据度量上，我们能够去考虑的报表统计的类型的思路，也结合着实际项目状况对每个报表进行了一定的解析。实际工作中，我们还可以做出很多别的类型的报表，只要我们认为该方面的统计数据可以给我们带来有用信息和思考的，我们都可以去对他进行汇报。&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　还有几点问题要谈到：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;首先：&lt;/strong&gt;我们的这个实例里，采样样本数量是偏小的，造成的问题是数据随机性会偏大，有可能出现失真的情况。如果项目规模够大，采样样本更多，我们的缺陷数据度量分析就能更准确的反映项目测试过程状态已经我们的产品质量特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;其次：&lt;/strong&gt;如果我们总是在项目结尾阶段才去做缺陷数据度量，那么他对于项目反馈的作用就非常有限了--毕竟项目都已经收尾了。其实我们在谈到测试报告时，应该知道测试报告不单单只有&lt;span&gt;&lt;strong&gt;测试完成报告&lt;/strong&gt;&lt;/span&gt;，还有&lt;span&gt;&lt;strong&gt;测试过程报告&lt;/strong&gt;&lt;/span&gt;。如果我们在测试过程报告里就引入缺陷数据度量，那么我们就能更好的对测试和研发过程进行反馈，从而达到过程改进的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;最后：&lt;/strong&gt;如果想要在测试报告时，能够收集到更多有用的缺陷数据，就要求我们在缺陷所包含的信息进行更详细的定义。比如说要求开发在解决缺陷的同时，明确的填入该缺陷所产生的根源阶段，这样我们才能统计出我们在第二个节点做出的缺陷泄露率/移除率报告。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 05:43:00 +0000</pubDate>
<dc:creator>Vincent83</dc:creator>
<og:description>缺陷报告，是软件测试这个职位最重要得产出之一。甚至对软件测试这个行业你可以用比较狭隘的描述去定义他为：‘测试就是为了找到缺陷’。 测试人员报出的缺陷，可以很好的反应产品中的问题，修复了这些问题，就可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yingyingja/p/9803542.html</dc:identifier>
</item>
<item>
<title>线段树详解 - Xenny</title>
<link>http://www.cnblogs.com/xenny/p/9801703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xenny/p/9801703.html</guid>
<description>&lt;p&gt;&lt;span&gt;我自己在学这些数据结构以及算法的时候，网上的博客很多都是给出一个大致思想，然后就直接给代码了，可能是我智商太低，思维跳跃没有那么大，没法直接代码实现，而且有些学完之后也没有得到深层次的理解和运用，还是停留在只会使用模板的基础上。所以我希望我写的东西能让更多的人看明白，我会尽量写详细，也会写出我初学的时候哪些地方没有理解或者难以运用，又是怎样去熟练的使用这些东西的。可能还是不能让所有的人都读明白，但我尽量做的更好。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;ul&gt;&lt;li&gt;线段树是怎样的树形结构?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　线段树是一种二叉搜索树，什么叫做二叉搜索树，首先满足二叉树，每个结点度小于等于二，即每个结点最多有两颗子树，何为搜索，我们要知道，线段树的每个结点都存储了一个区间，也可以理解成一个线段，而搜索，就是在这些线段上进行搜索操作得到你想要的答案。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线段树能够解决什么样的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。更可以扩充到二维线段树（矩阵树）和三维线段树（空间树）。对于一维线段树来说，每次更新以及查询的时间复杂度为O(logN)。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线段树和其他RMQ算法的区别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　常用的解决RMQ问题有ST算法，二者预处理时间都是O(NlogN)，而且ST算法的单次查询操作是O(1)，看起来比线段树好多了，但二者的区别在于线段树支持在线更新值，而ST算法不支持在线操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里也存在一个误区，刚学线段树的时候就以为线段树和树状数组差不多，用来处理RMQ问题和求和问题，但其实线段树的功能远远不止这些，我们要熟练的理解线段这个概念才能更加深层次的理解线段树。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　现在请各位不要带着线段树只是为了解决区间问题的数据结构，事实上，是线段树多用于解决区间问题，并不是线段树只能解决区间问题，首先，我们得先明白几件事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每个结点存什么，结点下标是什么，如何建树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面我以一个简单的区间最大值来阐述上面的三个概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017011254937-1072441805.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于A[1:6] = {1,8,6,4,3,5}来说，线段树如上所示，红色代表每个结点存储的区间，蓝色代表该区间最值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以发现，&lt;strong&gt;每个叶子结点的值就是数组的值，每个非叶子结点的度都为二，且左右两个孩子分别存储父亲一半的区间。每个父亲的存储的值也就是两个孩子存储的值的最大值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的每条结论应该都容易看出来。那么结点到底是如何存储区间的呢，以及如何快速找到非叶子结点的孩子以及非根节点的父亲呢，这里也就是理解线段树的重点以及难点所在，如同树状数组你理解了lowbit就能很快理解树状数组一样，线段树你只要理解了结点与结点之间的关系便能很快理解线段树的基本知识。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于一个区间[l,r]来说，最重要的数据当然就是区间的左右端点l和r，但是大部分的情况我们并不会去存储这两个数值，而是通过递归的传参方式进行传递。这种方式用指针好实现，定义两个左右子树递归即可，但是指针表示过于繁琐，而且不方便各种操作，大部分的线段树都是使用数组进行表示，那这里怎么快速使用下标找到左右子树呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于上述线段树，我们增加绿色数字为每个结点的下标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017013332469-105750075.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　则每个结点下标如上所示，这里你可能会问，为什么最下一排的下标直接从9跳到了12，道理也很简单，中间其实是有两个空间的呀！！虽然没有使用，但是他已经开了两个空间，这也是为什么无优化的线段树建树需要2*2&lt;sup&gt;k&lt;/sup&gt;（2&lt;sup&gt;k&lt;/sup&gt;&lt;sup&gt;-1&lt;/sup&gt; &amp;lt; n &amp;lt; &lt;span&gt;2&lt;sup&gt;k&lt;/sup&gt;&lt;/span&gt;)空间，一般会开到4*n的空间防止RE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　仔细观察每个父亲和孩子下标的关系，有发现什么联系吗？不难发现，每个左子树的下标都是偶数，右子树的下标都是奇数且为左子树下标+1，而且不难发现以下规律&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;l = fa*2 （左子树下标为父亲下标的两倍）&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;r = fa*2+1（右子树下标为父亲下标的两倍+1）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　具体证明也很简单，把线段树看成一个完全二叉树（空结点也当作使用）对于任意一个结点k来说，它所在此二叉树的log2（k） 层，则此层共有2&lt;sup&gt;log2(k)&lt;/sup&gt;个结点，同样对于k的左子树那层来说有2&lt;sup&gt;log2(k)+1&lt;/sup&gt;个结点，则结点k和左子树间隔了2*2&lt;sup&gt;log2(k)&lt;/sup&gt;-k + 2*(k-2&lt;sup&gt;log2(k)&lt;/sup&gt;)个结点&lt;/span&gt;&lt;span&gt;，然后这就很简单就得到k+&lt;span&gt;2*2&lt;sup&gt;log2(k)&lt;/sup&gt;-k + 2*(k-2&lt;sup&gt;log2(k)&lt;/sup&gt;)&lt;/span&gt; = 2*k的关系了吧，右子树也就等于左子树结点+1。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　是不是觉得其实很简单，而且因为左子树都是偶数，所以我们常用位运算来寻找左右子树&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;k&amp;lt;&amp;lt;1（结点k的左子树下标）&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;k&amp;lt;&amp;lt;1|1（结点k的右子树下标）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;span&gt;　　整理一下思绪，现在已经明白了数组如何存在线段树，结点间的关系，以及使用递归的方式建立线段树，那么具体如何建立线段树，我们来看代码，代码中不清楚的地方都有详细的注释说明。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;100005&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[maxn],t[maxn&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a为原来区间，t为线段树&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Pushup(&lt;span&gt;int&lt;/span&gt; k){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新函数，这里是实现最大值 ，同理可以变成，最小值，区间和等&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     t[k] = max(t[k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],t[k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归方式建树 build(1,1,n);&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; build(&lt;span&gt;int&lt;/span&gt; k,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k为当前需要建立的结点，l为当前需要建立区间的左端点，r则为右端点&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l == r)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左端点等于右端点，即为叶子节点，直接赋值即可&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         t[k] =&lt;span&gt; a[l];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = l + ((r-l)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         build(k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;,l,m);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归构造左儿子结点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         build(k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;,m+&lt;span&gt;1&lt;/span&gt;,r);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归构造右儿子结点&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         Pushup(k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新父节点&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　现在再来看代码，是不是觉得清晰很多了，使用递归的方法建立线段树，确实清晰易懂，各位看到这里也请自己试着实现一下递归建树，若是哪里有卡点再来看一下代码找到哪里出了问题。那线段树有没有非递归的方式建树呢，答案是有，但是非递归的建树方式会使得线段树的查询等操作和递归建树方式完全不一样，由简至难，后面我们再说非递归方式的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到现在你应该可以建立一颗线段树了，而且知道每个结点存储的区间和值，如果上述操作还不能实现或是有哪里想不明白，建议再翻回去看一看所讲的内容。不要急于看完，理解才更重要。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　基本操作有哪些，你应该也能想出来，在线的二叉搜索树，所拥有的操作当然有，更新和询问两种。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　1.点更新&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　如何实现点更新，我们先不急看代码，还是对于上面那个线段树，假使我把a[3]+7，则更新后的线段树应该变成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017094802223-550264929.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更新了a[3]后，则每个包含此值的结点都需要更新，那么有多少个结点需要更新呢？根据二叉树的性质，不难发现是log(k)个结点，这也正是为什么每次更新的时间复杂度为O(logN)，那应该如何实现呢，我们发现，无论你更新哪个叶子节点，最终都是会到根结点的，而把这个往上推的过程逆过来就是从根结点开始，找到左子树还是右子树包含需要更新的叶子节点，往下更新即可，所以我们还是可以使用递归的方法实现线段树的点更新&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归方式更新 update(p,v,1,n,1);&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; update(&lt;span&gt;int&lt;/span&gt; p,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p为下标，v为要加上的值，l，r为结点区间，k为结点下标&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l == r)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左端点等于右端点，即为叶子结点，直接加上v即可&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         a[k] += v,t[k] += v;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原数组和线段树数组都得到更新&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = l + ((r-l)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(p &amp;lt;= m)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要更新的结点在左子树区间&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             update(p,v,l,m,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要更新的结点在右子树区间&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             update(p,v,m+&lt;span&gt;1&lt;/span&gt;,r,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Pushup(k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新父节点的值&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　看完代码是不是很清晰，这里也建议自己再次手动实现一遍理解递归的思路。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　2.区间查询&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　说完了单点更新肯定就要来说区间查询了，我们知道线段树的每个结点存储的都是一段区间的信息 ，如果我们刚好要查询这个区间，那么则直接返回这个结点的信息即可，比如对于上面线段树，如果我直接查询[1,6]这个区间的最值，那么直接返回根节点信息返回13即可，但是一般我们不会凑巧刚好查询那些区间，比如现在我要查询[2,5]区间的最值，这时候该怎么办呢，我们来看看哪些区间是[2,5]的真子集，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017102253348-1647694310.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一共有5个区间，而且我们可以发现[4,5]这个区间已经包含了两个子树的信息，所以我们需要查询的区间只有三个，分别是[2,2],[3,3],[4,5]，到这里你能通过更新的思路想出来查询的思路吗? 我们还是从根节点开始往下递归，如果当前结点是要查询的区间的真子集，则返回这个结点的信息且不需要再往下递归了，这样从根节点往下递归，时间复杂度也是O(logN)。那么代码则为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归方式区间查询 query(L,R,1,n,1);&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; L,&lt;span&gt;int&lt;/span&gt; R,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[L,R]即为要查询的区间，l，r为结点区间，k为结点下标&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前结点的区间真包含于要查询的区间内，则返回结点信息且不需要往下递归&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t[k];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; res = -INF;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值变量，根据具体线段树查询的什么而自定义&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; mid = l + ((r-l)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(L &amp;lt;= m)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左子树和需要查询的区间交集非空&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             res = max(res, query(L,R,l,m,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(R &amp;gt; m)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子树和需要查询的区间交集非空，注意这里不是else if，因为查询区间可能同时和左右区间都有交集&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             res = max(res, query(L,R,m+&lt;span&gt;1&lt;/span&gt;,r,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; res;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前结点得到的信息&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　如果你能理解建树和更新的过程，那么这里的区间查询也不会太难理解。还是建议再次手动实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　3.区间更新&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　树状数组中的区间更新我们用了差分的思想，而线段树的区间更新相对于树状数组就稍微复杂一点，这里我们引进了一个新东西，Lazy_tag，字面意思就是懒惰标记的意思，实际上它的功能也就是偷懒= =，因为对于一个区间[L,R]来说，我们可能每次都更新区间中的没个值，那样的话更新的复杂度将会是O(NlogN)，这太高了，所以引进了Lazy_tag，这个标记一般用于处理线段树的区间更新。&lt;br/&gt;　　线段树在进行区间更新的时候，为了提高更新的效率，所以每次更新只更新到更新区间完全覆盖线段树结点区间为止，这样就会导致被更新结点的子孙结点的区间得不到需要更新的信息，所以在被更新结点上打上一个标记，称为lazy-tag，等到下次访问这个结点的子结点时再将这个标记传递给子结点，所以也可以叫延迟标记。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也就是说递归更新的过程，更新到结点区间为需要更新的区间的真子集不再往下更新，下次若是遇到需要用这下面的结点的信息，再去更新这些结点，所以这样的话使得区间更新的操作和区间查询类似，复杂度为O(logN)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Pushdown(&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新子树的lazy值，这里是RMQ的函数，要实现区间和等则需要修改函数内容&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(lazy[k]){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有lazy标记&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         lazy[k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;] += lazy[k];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新左子树的lazy值&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         lazy[k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;] += lazy[k];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新右子树的lazy值&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         t[k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;] += lazy[k];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树的最值加上lazy值&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         t[k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;] += lazy[k];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子树的最值加上lazy值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         lazy[k] = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lazy值归0&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归更新区间 update(L,R,v,1,n,1);&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; update(&lt;span&gt;int&lt;/span&gt; L,&lt;span&gt;int&lt;/span&gt; R,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[L,R]即为要更新的区间，l，r为结点区间，k为结点下标&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前结点的区间真包含于要更新的区间内&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         lazy[k] += v;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;懒惰标记&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         t[k] += v;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大值加上v之后，此区间的最大值也肯定是加v&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Pushdown(k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重难点，查询lazy标记，更新子树&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = l + ((r-l)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(L &amp;lt;= m)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左子树和需要更新的区间交集非空&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             update(L,R,v,l,m,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(m &amp;lt; R)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子树和需要更新的区间交集非空&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             update(L,R,v,m+&lt;span&gt;1&lt;/span&gt;,r,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Pushup(k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新父节点&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　注意看Pushdown这个函数，也就是当需要查询某个结点的子树时，需要用到这个函数，函数功能就是更新子树的lazy值，可以理解为平时先把事情放着，等到哪天要检查的时候，就临时再去做，而且做也不是一次性做完，检查哪一部分它就只做这一部分。是不是感受到了什么是Lazy_tag，实至名归= =。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　值得注意的是，使用了Lazy_tag后，我们再进行区间查询也需要改变。区间查询的代码则变为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归方式区间查询 query(L,R,1,n,1);&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; query(&lt;span&gt;int&lt;/span&gt; L,&lt;span&gt;int&lt;/span&gt; R,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[L,R]即为要查询的区间，l，r为结点区间，k为结点下标&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(L &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= R)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前结点的区间真包含于要查询的区间内，则返回结点信息且不需要往下递归&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t[k];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Pushdown(k);    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*每次都需要更新子树的Lazy标记&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; res = -INF;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值变量，根据具体线段树查询的什么而自定义&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; mid = l + ((r-l)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;m则为中间点，左儿子的结点区间为[l,m],右儿子的结点区间为[m+1,r]&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(L &amp;lt;= m)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左子树和需要查询的区间交集非空&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             res = max(res, query(L,R,l,m,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(R &amp;gt; m)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子树和需要查询的区间交集非空，注意这里不是else if，因为查询区间可能同时和左右区间都有交集&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             res = max(res, query(L,R,m+&lt;span&gt;1&lt;/span&gt;,r,k&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;|&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; res;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前结点得到的信息&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其实变动也不大，就是多了一个临时更新子树的值的过程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果你明白了上述线段树处理区间最值的所有操作，那么转变成求最小值以及区间和问题应该也能很快解决，请手动再实现一下查询区间最小值的线段树和查询区间和的线段树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　区间和线段树等代码不再给出，自行实现，若不能实现可以去网上搜索模板对比自己为何不能实现。这里便不再浪费篇幅讲述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我便是想说一下线段树还能处理的问题以及一些具体问题讲解。上述我们只是再讲线段树处理裸区间问题，但是大部分问题不会是让你直接更新查询，而是否真正理解线段树便在于思维是否能从区间跳到线段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　区间只是一个线段的一小部分，还有一些非区间问题也可以演变成一段一段的线段，然后再通过线段树进行各种操作。下面针对几道例题讲解一下线段树的其他具体用法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;下面三道题讲解并非自己所写，而是摘取了另一篇线段树的博客，特此声明，原博客地址：https://blog.csdn.net/whereisherofrom/article/details/78969718&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　1.区间染色&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　给定一个长度为n(n &amp;lt;= 100000)的木板，支持两种操作：&lt;br/&gt;　　1、P a b c       将[a, b]区间段染色成c；&lt;br/&gt;　　2、Q a b         询问[a, b]区间内有多少种颜色；&lt;br/&gt;　　保证染色的颜色数少于30种。&lt;br/&gt;　　对比区间求和，不同点在于区间求和的更新是对区间和进行累加；而这类染色问题则是对区间的值进行替换（或者叫覆盖），有一个比较特殊的条件是颜色数目小于30。&lt;br/&gt;　　我们是不是要将30种颜色的有无与否都存在线段树的结点上呢？答案是肯定的，但是这样一来每个结点都要存储30个bool值，空间太浪费，而且在计算合并操作的时候有一步30个元素的遍历，大大降低效率。然而30个bool值正好可以压缩在一个int32中，利用二进制压缩可以用一个32位的整型完美的存储30种颜色的有无情况。&lt;br/&gt;　　因为任何一个整数都可以分解成二进制整数，二进制整数的每一位要么是0，要么是1。二进制整数的第i位是1表示存在第i种颜色；反之不存在。&lt;br/&gt;　　数据域需要存一个颜色种类的位或和colorBit，一个颜色的lazy标记表示这个结点被完全染成了lazy，基本操作的几个函数和区间求和非常像，这里就不出示代码了。&lt;br/&gt;　　和区间求和不同的是回溯统计的时候，对于两个子结点的数据域不再是加和，而是位或和。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　2.区间第K大&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　给定n个数，每次询问问[l,r]区间内的第K大数，这个问题有很多方法，但是用线段树应该如何解决呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　利用了线段树划分区间的思想，线段树的每个结点存的不只是区间端点，而是这个区间内所有的数，并且是按照递增顺序有序排列的，建树过程是一个归并排序的过程，从叶子结点自底向上进行归并，对于一个长度为6的数组[4, 3, 2, 1, 5, 6]，建立线段树如图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017122945952-646112470.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从图中可以看出，线段树的任何一个结点存储了对应区间的数，并且进行有序排列，所以根结点存储的一定是一个长度为数组总长的有序数组，叶子结点存储的递增序列为原数组元素。&lt;br/&gt;　　每次询问，我们将给定区间拆分成一个个线段树上的子区间，然后二分枚举答案T，再利用二分查找统计这些子区间中大于等于T的数的个数，从而确定T是否是第K大的。&lt;br/&gt;　　对于区间K大数的问题，还有很多数据结构都能解决，这里仅作简单介绍。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　3.矩阵面积并&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　对于给定的n(n&amp;lt;=100000)个平行于XY轴的矩形，求他们的面积并。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017113320014-1208065318.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这是一个二维的问题，如果我告诉你这道题使用线段树解决，你该如何入手呢，首先线段树是一维的，所以我们需要化二维为一维，所以我们可以使用x的坐标或者y的坐标建立线段树，另一坐标用来进行枚举操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们用x的坐标来建树的化，那么我们把矩阵平行于x轴的线段舍去，则变成了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017113641647-1167080951.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每个矩形都剩下两条边，定义x坐标较小的为入边（值为+1），较大为出边（值为-1），然后用x的升序，记第i条线段的x坐标即为X[i]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017113840966-1991656451.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来将所有矩形端点的y坐标进行重映射(也可以叫离散化)，原因是坐标有可能很大而且不一定是整数，将原坐标映射成小范围的整数可以作为数组下标，更方便计算，映射可以将所有y坐标进行排序去重，然后二分查找确定映射后的值，离散化的具体步骤下文会详细讲解。如图所示，蓝色数字表示的是离散后的坐标，即1、2、3、4分别对应原先的5、10、23、25（需支持正查和反查）。假设离散后的y方向的坐标个数为m，则y方向被分割成m-1个独立单元，下文称这些独立单元为“单位线段”，分别记为&amp;lt;1-2&amp;gt;、&amp;lt;2-3&amp;gt;、&amp;lt;3-4&amp;gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017113928927-683305051.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以x坐标递增的方式枚举每条垂直线段，y方向用一个长度为m-1的数组来维护“单位线段”的权值，如图所示，展示了每条线段按x递增方式插入之后每个“单位线段”的权值。&lt;br/&gt;　　当枚举到第i条线段时，检查所有“单位线段”的权值，所有权值大于零的“单位线段”的实际长度之和(离散化前的长度)被称为“合法长度”，记为L，那么(X[i] - X[i-1]) * L，就是第i条线段和第i-1条线段之间的矩形面积和，计算完第i条垂直线段后将它插入，所谓&quot;插入&quot;就是利用该线段的权值更新该线段对应的“单位线段”的权值和（这里的更新就是累加）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181017114017087-1033235603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如图四-4-6所示：红色、黄色、蓝色三个矩形分别是3对相邻线段间的矩形面积和，其中红色部分的y方向由&amp;lt;1-2&amp;gt;、&amp;lt;2-3&amp;gt;两个“单位线段”组成，黄色部分的y方向由&amp;lt;1-2&amp;gt;、&amp;lt;2-3&amp;gt;、&amp;lt;3-4&amp;gt;三个“单位线段”组成，蓝色部分的y方向由&amp;lt;2-3&amp;gt;、&amp;lt;3-4&amp;gt;两个“单位线段”组成。特殊的，在计算蓝色部分的时候，&amp;lt;1-2&amp;gt;部分的权值由于第3条线段的插入(第3条线段权值为-1)而变为零，所以不能计入“合法长度”。&lt;br/&gt;　　以上所有相邻线段之间的面积和就是最后要求的矩形面积并。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;优化自然就是用线段树了，之前提到了降维的思想，x方向我们继续采用枚举，而y方向的“单位线段”则可以采用线段树来维护，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后通过一个扫描线来求扫描线覆盖的y的长度。线段的扫描按照x的大小从小到大扫描，求出当前扫描线覆盖的矩阵竖线的长度，然后乘以下条线段的跨度，则为这个区域矩阵覆盖的面积，具体关于扫描线的操作这里不再阐述。这里只讲明白如何建树。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;　　1.离散化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　离散化常用于二维状态在一维线段树建树，所谓离散化就是将无限的个体映射到有限个体中，提高算法效率，而且支持正查和反查（从开始遍历和从末尾遍历），可用Hash等实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　2.Lazy_tag&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这个标记就是用于线段树的区间更新，上面已经提到，便不再累赘，但是区间更新并不局限于使用Lazy_tag，还有一种不使用Lazy_tag的区间更新方法，会在提高篇中讲到。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　3.空间优化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　父节点k，左儿子k&amp;lt;&amp;lt;1，右儿子k&amp;lt;&amp;lt;1|1，则需要n&amp;lt;&amp;lt;2的空间，但我们知道并不是所有的叶子节点都占用到了2*n+1 —— 4*n的范围，造成了大量空间浪费。这时候就要考虑离散化，压缩空间。或者使用dfs序作为结点下标，父亲k，左儿子k+1，右儿子k+左儿子区间长度*2，具体实现不再累赘，可自行通过修改左右儿子的下标推出。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　4.多维推广&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　例如矩阵树，空间树，这些便是线段树的拓展，比如要在两种不同的参数找到最适变量，例如对于一个人的身高和体重，找到一定范围内且年龄最小的人，就可以用到多维推广了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　5.可持久化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　主席树。以后讲= =&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　6.非递归形式&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前面提到过这个概念，非递归形式的某些操作会快于递归形式，以后将会专门将非递归形式。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　7.子树收缩&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　就是子树继承的逆过程，继承是为了得到父节点信息，而收缩则是在回溯时候，如果两棵子树拥有相同数据的时候在将数据传递给父结点，子树的数据清空，这样下次在访问的时候就可以减少访问的结点数。&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;codevs 1080 （单点修改+区间查询）&lt;/li&gt;
&lt;li&gt;codevs 1081 （区间修改+单点查询）&lt;/li&gt;
&lt;li&gt;codevs 1082 （区间修改+区间查询）&lt;/li&gt;
&lt;li&gt;codevs 3981 （区间最大子段和）&lt;/li&gt;
&lt;li&gt;Bzoj 3813　  （区间内某个值是否出现过）&lt;/li&gt;
&lt;li&gt;Luogu P2894 （区间连续一段空的长度）&lt;/li&gt;
&lt;li&gt;codevs 2000 （区间最长上升子序列）&lt;/li&gt;
&lt;li&gt;codevs 3044 （矩阵面积求并）&lt;/li&gt;
&lt;li&gt;Hdu 1698 （区间染色+单次统计）&lt;/li&gt;
&lt;li&gt;Poj 2777 （区间染色+批量统计）&lt;/li&gt;
&lt;li&gt;Hdu 4419 （多色矩形面积并）&lt;/li&gt;
&lt;li&gt;Poj 2761 （区间第K大）&lt;/li&gt;
&lt;li&gt;Hdu 2305 （最值维护）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　暂时只写了这么多，这算是基本的线段树内容，主要就是要明白建树以及各种操作的过程，并且做题时候想这道题是否可以化成线段树建树来解决。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 05:07:00 +0000</pubDate>
<dc:creator>Xenny</dc:creator>
<og:description>我自己在学这些数据结构以及算法的时候，网上的博客很多都是给出一个大致思想，然后就直接给代码了，可能是我智商太低，思维跳跃没有那么大，没法直接代码实现，而且有些学完之后也没有得到深层次的理解和运用，还是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xenny/p/9801703.html</dc:identifier>
</item>
<item>
<title>挑战常规--这样写单例是错的！ - 我想嘿嘿</title>
<link>http://www.cnblogs.com/loveheihei/p/9803512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveheihei/p/9803512.html</guid>
<description>&lt;p&gt;&lt;span&gt;说到单例，网上教程和很多人信手拈来:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Single
{
        private volatile static Single instance;

        private Single()
        {
                System.out.println(&quot;创建单例&quot;);
        } 
        public static Single getInstance()
        {
                if (instance == null)
                {
                        synchronized (Single.class)
                        {
                                if (instance == null)
                                {
                                        instance = new Single();
                                }
                        }
                }
                return instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 自信满满，称之为&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;懒汉加载模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span&gt;言之节省内存，用时才会自动创建。在我看来，&lt;strong&gt;这种写法完全是错误的&lt;/strong&gt;，愚蠢至极，这不是脱裤子放屁，这是脱完裤子再提取裤子再放屁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正确写法就是最简单的:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Single
{
        private   static Single instance=new Single();

        private Single()
        {
                System.out.println(&quot;创建单例&quot;);
        } 
        public static Single getInstance()
        { 
                return instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;下面驳斥所谓的省内存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SingleTest
{
 
        public static void main(String[] args) throws  Exception
        { 
                System.out.println(&quot;启动线程&quot;);
                System.in.read();
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 首先，不用单例时，难道别的写法就会加载单例？&lt;strong&gt;没有引用使用单例类时，当然都不会加载单例。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477973/201810/1477973-20181017122218479-124990536.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看图，并不会加载创建单例，控制台也不会输出创建单例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，&lt;strong&gt;既然预定要使用单例，那么都会加载创建一次。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SingleTest
{
 
        public static void main(String[] args) throws  Exception
        { 
                System.out.println(&quot;启动线程&quot;);
                Single.getInstance();
                System.in.read();
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 看图,无论哪种模式单例都会被引用加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477973/201810/1477973-20181017122855405-154437545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;是不是用synchronized创建单例就没有用处了呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并不是&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;synchronized是用于解决多线程访问问题&lt;/strong&gt;&lt;span&gt;。&lt;strong&gt;带参数的单例创建才应该使用懒汉模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为并不能预期，什么时候参数被传入。简单模式下并不清楚传入什么参数，或参数对象未初始化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Single
{
        private volatile static Single instance ;   
        public Single(Context context)
        {
                System.out.println(&quot;创建单例&quot;);
        }
        public static Single getInstance(Context context)
        {
                if (instance == null)
                {
                        synchronized (Single.class)
                        {
                                if (instance == null)
                                {
                                        instance = new Single(context);
                                }
                        }
                }
                return instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 为什么说这个是为了解决多线程访问呢，先看如果不加锁会发生什么&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Single
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Single instance ;   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Single(Context context)
    {
        System.out.println(&lt;/span&gt;&quot;创建单例&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Single getInstance(Context context)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Single(context);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SingleTest
{

        public static void main(String[] args) throws Exception
        {
                ExecutorService pool = Executors.newCachedThreadPool();
                ArrayList&amp;lt;Callable&amp;lt;Void&amp;gt;&amp;gt; runners=new       ArrayList&amp;lt;&amp;gt;();
                for(int i=0;i&amp;lt;10;i++)
                {
                        runners.add(()-&amp;gt;{
                                Single.getInstance(new Context());
                                return null;
                        });
                }
                System.out.println(&quot;启动线程&quot;);
                pool.invokeAll(runners);
                pool.shutdown();
                System.in.read();
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 不加锁情况,结果看图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477973/201810/1477973-20181017124810781-1575383406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;加锁情况，结果看图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1477973/201810/1477973-20181017125038159-1784796614.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结，&lt;strong&gt;无参构造单例无需复杂的加入synchronized，而未确定的传参单例需要加synchronized&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;保证多线程访问安全。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思考，如果传入的参数确定，怎么写才最优呢？下面类似写法是否合理：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Single
{
        private   static Single instance =new Single(Context.instance);  
 
        public Single(Context context )
        {
                System.out.println(&quot;创建单例&quot;);
        }
        public static Single getInstance( )
        {
                 
                return instance;
        }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@WebListener
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyServletContextListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServletContextListener {
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextDestroyed(ServletContextEvent sce)  { 
      
    }
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent sce)  { 
        Single.getInstance(sce);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 17 Oct 2018 05:07:00 +0000</pubDate>
<dc:creator>我想嘿嘿</dc:creator>
<og:description>说到单例，网上教程和很多人信手拈来: 自信满满，称之为懒汉加载模式，言之节省内存，用时才会自动创建。在我看来，这种写法完全是错误的，愚蠢至极，这不是脱裤子放屁，这是脱完裤子再提取裤子再放屁。 正确写法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loveheihei/p/9803512.html</dc:identifier>
</item>
</channel>
</rss>