<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《我不是药神》 观影有感——为自己挣命 - 执迷于沿途风景的旅人</title>
<link>http://www.cnblogs.com/traveller-ly/p/9348557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/traveller-ly/p/9348557.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　单从电影的角度看，这确实是一部很好的电影。我一直觉得，电影就是讲故事，剧本是故事的框架，而演员是故事的血肉。无疑，这部电影骨架坚实，血肉丰满。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;但我今天不想谈这部电影的好与坏，只就故事的些许片段进行讨论。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;电影中有这样一幕，黄毛引开警察后被车撞死，在医院程勇质问警官“他只是想活着，有罪吗？”有罪吗？没有。但从某种程度上来说把他逼死的警官有罪吗？没有。我想起以前看过的一本小说，里面有过这样一句话，人的命，是靠自己挣的。黄毛为自己挣命，他无罪。那些警察也无罪，他们也在为自己挣命——那是他们的工作。那么，这里又有一个问题，他们，就该死吗？不该死。因为人有活着的权利，谁也没办法剥夺。他们不该死吗？他们为了活着去支持盗版，仿制品，给药品研发的公司带来了经济损害。这么一看后者好像根本没有道理，因为生命无价。但换个角度想， 他们某种程度上打击的药品研发公司的积极性，也就是说，客观上他们对药品研发造成了阻碍。因为，这种特效药的研发成本肯定不低，如果研究成果被简单的复制，那么研发还有什么进行的必要？或许有人会说，“那家公司为什么不在收回成本之后就降价呢？”因为那是一家公司而非慈善机构，收回成本后就降价，一样会打击生产积极性，之所以他们愿意花大成本来研制这种药，说白了，是为了钱，想要钱的欲望，贪念推动了这种药的产生——事实上，我认为人类社会的进步，科学的进步，都源自人类的欲望和需求。当需求被压缩，农耕社会夜很令人满足。回到那个问题，如果收回成本就降价，那和直接降价有区别吗？没有的。那么购买支持仿制药的人，有错吗，没有的。所以，那些要仿制药停产，追查仿制药的人——这些客观上逼死那些病人的人，也无错。双方不过都是在为自己挣命罢了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　或许很久很久以后，人类文明还没有毁灭，生产力达到了一个空前的高度，使得那些只存在于理论中的社会，能够实现，那时或许会有那时的各种问题，今天的问题，或许就不是问题了。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>执迷于沿途风景的旅人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/traveller-ly/p/9348557.html</dc:identifier>
</item>
<item>
<title>TypeScript在node项目中的实践 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/9348539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/9348539.html</guid>
<description>&lt;p&gt;TypeScript可以理解为是JavaScript的一个超集，也就是说涵盖了所有JavaScript的功能，并在之上有着自己独特的语法。&lt;br/&gt;最近的一个新项目开始了TS的踩坑之旅，现分享一些可以借鉴的套路给大家。&lt;/p&gt;
&lt;h2 id=&quot;为什么选择TS&quot;&gt;为什么选择TS&lt;/h2&gt;
&lt;p&gt;作为巨硬公司出品的一个静态强类型编译型语言，该语言已经出现了几年的时间了，相信在社区的维护下，已经是一门很稳定的语言。&lt;br/&gt;我们知道，JavaScript是一门动态弱类型解释型脚本语言，动态带来了很多的便利，我们可以在代码运行中随意的修改变量类型以达到预期目的。&lt;br/&gt;但同时，这是一把双刃剑，当一个庞大的项目出现在你的面前，面对无比复杂的逻辑，你很难通过代码看出某个变量是什么类型，这个变量要做什么，很可能一不小心就会踩到坑。&lt;/p&gt;
&lt;p&gt;而静态强类型编译能够带来很多的好处，其中最重要的一点就是可以帮助开发人员杜绝一些马虎大意的问题：&lt;br/&gt;&lt;img src=&quot;http://newimg88.b0.upaiyun.com/newimg88/2018/02/javascript-error-graph.png&quot; alt=&quot;image&quot; width=&quot;841&quot; height=&quot;521&quot;/&gt;&lt;br/&gt;&lt;em&gt;图为rollbar统计的数千个项目中数量最多的前十个异常&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不难看出，因为类型不匹配、变量为空导致的异常比你敢承认的次数要多。&lt;br/&gt;譬如&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/cblued/static/sample-error-code.1ci4jfvvt2t4ojs.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;而这一点在TS中得到了很好的改善，任何一个变量的引用，都需要指定自己的类型，而你下边在代码中可以用什么，支持什么方法，都需要在上边进行定义：&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/cblued/static/typescript-example.1ciuh4eh1v1sum.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这个提示会在开发、编译期来提示给开发者，避免了上线以后发现有问题，再去修改。&lt;/p&gt;
&lt;p&gt;另外一个由静态编译类型带来的好处，就是函数签名。&lt;br/&gt;还是就像上边所说的，因为是一个动态的脚本语言，所以很难有编辑器能够在开发期间正确地告诉你所要调用的一个函数需要传递什么参数，函数会返回什么类型的返回值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/cblued/static/js-function-call.1ci4kli9ou37kr.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而在TS中，对于一个函数，首先你需要定义所有参数的类型，以及返回值的类型。&lt;br/&gt;这样在函数被调用时，我们就可以很清晰的看到这个函数的效果：&lt;br/&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/cblued/static/ts-function-call.1ciuh6bsp2ujs1q.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是最基础的、能够让程序更加稳定的两个特性，当然，还有更多的功能在TS中的：&lt;a href=&quot;https://www.typescriptlang.org/docs/home.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;TypeScript | Handbook&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TypeScript在node中的应用&quot;&gt;TypeScript在node中的应用&lt;/h2&gt;
&lt;p&gt;在TS的官网中，有着大量的&lt;a href=&quot;https://www.typescriptlang.org/samples/index.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;示例&lt;/a&gt;，其中就找到了&lt;a href=&quot;https://github.com/Microsoft/TypeScript-Node-Starter#typescript-node-starter&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Express&lt;/a&gt;版本的例子，针对这个稍作修饰，应用在了一个 koa 项目中。&lt;/p&gt;
&lt;h3 id=&quot;环境依赖&quot;&gt;环境依赖&lt;/h3&gt;
&lt;p&gt;在使用TS之前，需要先准备这些东西：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;VS code&lt;/strong&gt;，同为巨硬公司出品，本身就是TS开发的，遂该编辑器是目前对TS支持度最高的一个&lt;/li&gt;
&lt;li&gt;Node.js 推荐8.11版本以上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm i -g typescript&lt;/code&gt;，全局安装TS，编译所使用的tsc命令在这里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm i -g nodemon&lt;/code&gt;，全局安装nodemon，在tsc编译后自动刷新服务器程序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以项目中使用的一些核心依赖：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;reflect-metadata&lt;/code&gt;： 大量装饰器的包都会依赖的一个基础包，用于注入数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;routing-controllers&lt;/code&gt;： 使用装饰器的方式来进行koa-router的开发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequelize&lt;/code&gt;： 抽象化的数据库操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sequelize-typescript&lt;/code&gt;： 上述插件的装饰器版本，定义实体时使用&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;项目结构&quot;&gt;项目结构&lt;/h3&gt;
&lt;p&gt;首先，放出目前项目的结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.
├── README.md
├── copy&lt;/span&gt;-static-&lt;span&gt;assets.ts
├── nodemon.json
├── package&lt;/span&gt;-&lt;span&gt;lock.json
├── package.json
├── dist
├── src
│   ├── config
│   ├── controllers
│   ├── entity
│   ├── models
│   ├── middleware
│   ├── public
│   ├── app.ts
│   ├── server.ts
│   ├── types
│   └── utils
├── tsconfig.json
└── tslint.json&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;src&lt;/code&gt;为主要开发目录，所有的TS代码都在这里边，在经过编译过后，会生成一个与&lt;code&gt;src&lt;/code&gt;同级的&lt;code&gt;dist&lt;/code&gt;文件夹，这个文件夹是&lt;code&gt;node&lt;/code&gt;引擎实际运行的代码。&lt;br/&gt;在&lt;code&gt;src&lt;/code&gt;下，主要代码分为了如下结构（依据自己项目的实际情况进行增删）：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;folder&lt;/th&gt;
&lt;th&gt;desc&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;controllers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于处理接口请求，原&lt;code&gt;apps&lt;/code&gt;、&lt;code&gt;routes&lt;/code&gt;文件夹。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;middleware&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;存放了各种中间件、全局 or 自定义的中间件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;code&gt;config&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;各种配置项的位置，包括端口、&lt;code&gt;log&lt;/code&gt;路径、各种巴拉巴拉的常量定义。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;code&gt;entity&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;这里存放的是所有的实体定义（使用了sequelize进行数据库操作）。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;code&gt;models&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用来自&lt;code&gt;entity&lt;/code&gt;中的实体进行&lt;code&gt;sequelize&lt;/code&gt;来完成初始化的操作，并将&lt;code&gt;sequelize&lt;/code&gt;对象抛出。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;code&gt;utils&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;存放的各种日常开发中提炼出来的公共函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;code&gt;types&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;存放了各种客制化的复合类型的定义，各种结构、属性、方法返回值的定义（目前包括常用的Promise版redis与qconf）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;controllers&quot;&gt;controllers&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;controllers只负责处理逻辑，通过操作model对象，而不是数据库来进行数据的增删改查&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;鉴于公司绝大部分的Node项目版本都已经升级到了&lt;code&gt;Node 8.11&lt;/code&gt;，理所应当的，我们会尝试新的语法。&lt;br/&gt;也就是说我们会抛弃&lt;code&gt;Generator&lt;/code&gt;，拥抱&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Koa&lt;/code&gt;、&lt;code&gt;Express&lt;/code&gt;写过接口的童鞋应该都知道，当一个项目变得庞大，实际上会产生很多重复的非逻辑代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
router.get('/', ctx =&amp;gt;&lt;span&gt; {})
router.get(&lt;/span&gt;'/page1', ctx =&amp;gt;&lt;span&gt; {})
router.get(&lt;/span&gt;'/page2', ctx =&amp;gt;&lt;span&gt; {})
router.get(&lt;/span&gt;'/page3', ctx =&amp;gt;&lt;span&gt; {})
router.get(&lt;/span&gt;'/pageN', ctx =&amp;gt; {})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而在每个路由监听中，又做着大量重复的工作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
router.get('/', ctx =&amp;gt;&lt;span&gt; {
  let uid &lt;/span&gt;= Number(ctx.cookies.get('uid'&lt;span&gt;))
  let device &lt;/span&gt;= ctx.headers['device'] || 'ios'&lt;span&gt;
  let { tel, name } &lt;/span&gt;=&lt;span&gt; ctx.query
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;几乎每一个路由的头部都是在做着获取参数的工作，而参数很可能来自&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;body&lt;/code&gt;甚至是&lt;code&gt;cookie&lt;/code&gt;及&lt;code&gt;query&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以，我们对原来koa的使用方法进行了一个较大的改动，并使用&lt;a href=&quot;https://github.com/typestack/routing-controllers&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;routing-controllers&lt;/a&gt;大量的应用装饰器来帮助我们处理大部分的非逻辑代码。&lt;/p&gt;
&lt;p&gt;原有router的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
module.exports = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (router) {
  router.get(&lt;/span&gt;'/', &lt;span&gt;function&lt;/span&gt;*&lt;span&gt; (next) {
    let uid &lt;/span&gt;= Number(&lt;span&gt;this&lt;/span&gt;.cookies.get('uid'&lt;span&gt;))
    let device &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.headers['device'&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.body =&lt;span&gt; {
      code: &lt;/span&gt;200&lt;span&gt;
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用了TypeScript与装饰器的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class {
  @Get(&lt;/span&gt;'/'&lt;span&gt;)
  async index (
    @CookieParam(&lt;/span&gt;'uid'&lt;span&gt;) uid: number,
    @HeaderParam(&lt;/span&gt;'device'&lt;span&gt;) device: string
  ) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      code: &lt;/span&gt;200&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了使接口更易于检索、更清晰，所以我们抛弃了原有的&lt;code&gt;bd-router&lt;/code&gt;的功能（依据文件路径作为接口路径、TS中的文件路径仅用于文件分层）。&lt;br/&gt;直接在&lt;code&gt;controllers&lt;/code&gt;下的文件中声明对应的接口进行监听。&lt;/p&gt;
&lt;h3 id=&quot;middleware&quot;&gt;middleware&lt;/h3&gt;
&lt;p&gt;如果是全局的中间件，则直接在class上添加&lt;code&gt;@Middleware&lt;/code&gt;装饰器，并设置&lt;code&gt;type: 'after|before'&lt;/code&gt;即可。&lt;br/&gt;如果是特定的一些中间件，则创建一个普通的class即可，然后在需要使用的&lt;code&gt;controller&lt;/code&gt;对象上指定&lt;code&gt;@UseBefore&lt;/code&gt;/&lt;code&gt;@UseAfter&lt;/code&gt;（可以写在class上，也可以写在method上）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有的中间件都需要继承对应的MiddlewareInterface接口，并需要实现&lt;code&gt;use&lt;/code&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; middleware/xxx.ts&lt;/span&gt;
import {ExpressMiddlewareInterface} from &quot;../../src/driver/express/ExpressMiddlewareInterface&quot;&lt;span&gt;

export class CompressionMiddleware implements KoaMiddlewareInterface {
  use(request: any, response: any, next&lt;/span&gt;?&lt;span&gt;: Function): any {
    console.log(&lt;/span&gt;&quot;hello compression ...&quot;&lt;span&gt;)
    next()
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; controllers/xxx.ts&lt;/span&gt;
&lt;span&gt;@UseBefore(CompressionMiddleware)
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; class { }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;entity&quot;&gt;entity&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文件只负责定义数据模型，不做任何逻辑操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样的使用了sequelize+装饰器的方式，entity只是用来建立与数据库之间通讯的数据模型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import { Model, Table, Column } from 'sequelize-typescript'&lt;span&gt;

@Table({
  tableName: &lt;/span&gt;'user_info_test'&lt;span&gt;
})
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; class UserInfo extends Model&amp;lt;UserInfo&amp;gt;&lt;span&gt; {
  @Column({
    comment: &lt;/span&gt;'自增ID'&lt;span&gt;,
    autoIncrement: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    primaryKey: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  })
  uid: number

  @Column({
    comment: &lt;/span&gt;'姓名'&lt;span&gt;
  })
  name: string

  @Column({
    comment: &lt;/span&gt;'年龄'&lt;span&gt;,
    defaultValue: &lt;/span&gt;0&lt;span&gt;
  })
  age: number

  @Column({
    comment: &lt;/span&gt;'性别'&lt;span&gt;
  })
  gender: number
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;因为sequelize建立连接也是需要对应的数据库地址、账户、密码、database等信息、所以推荐将同一个数据库的所有实体放在一个目录下，方便sequelize加载对应的模型&lt;/strong&gt;&lt;br/&gt;同步的推荐在config下创建对应的配置信息，并添加一列用于存放实体的key。&lt;br/&gt;这样在建立数据库链接，加载数据模型时就可以动态的导入该路径下的所有实体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; config.ts&lt;/span&gt;
export const config =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  mysql1: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... config&lt;/span&gt;
+   entity: 'entity1' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一列用来标识是什么实体的key&lt;/span&gt;
&lt;span&gt;  },
  mysql2: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... config&lt;/span&gt;
+   entity: 'entity2' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一列用来标识是什么实体的key&lt;/span&gt;
&lt;span&gt;  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils/mysql.ts&lt;/span&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sequelize({
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  modelPath: [path.reolve(__dirname, `../entity/&lt;span&gt;${config.mysql1.entity}`)]
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;model&quot;&gt;model&lt;/h3&gt;
&lt;p&gt;model的定位在于根据对应的实体创建抽象化的数据库对象，因为使用了sequelize，所以该目录下的文件会变得非常简洁。&lt;br/&gt;基本就是初始化sequelize对象，并在加载模型后将其抛出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sequelize({
  host: &lt;/span&gt;'127.0.0.1'&lt;span&gt;,
  database: &lt;/span&gt;'database'&lt;span&gt;,
  username: &lt;/span&gt;'user'&lt;span&gt;,
  password: &lt;/span&gt;'password'&lt;span&gt;,
  dialect: &lt;/span&gt;'mysql', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者一些其他的数据库&lt;/span&gt;
  modelPaths: [path.resolve(__dirname, `../entity/${configs.mysql1.entity}`)], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载我们的实体&lt;/span&gt;
  pool: { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接池的一些相关配置&lt;/span&gt;
    max: 5&lt;span&gt;,
    min: &lt;/span&gt;0&lt;span&gt;,
    acquire: &lt;/span&gt;30000&lt;span&gt;,
    idle: &lt;/span&gt;10000&lt;span&gt;
  },
  operatorsAliases: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  logging: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true会在控制台打印每次sequelize操作时对应的SQL命令&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;utils&quot;&gt;utils&lt;/h3&gt;
&lt;p&gt;所有的公共函数，都放在这里。&lt;br/&gt;同时推荐编写对应的索引文件(index.ts)，大致的格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils/get-uid.ts&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (): number {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 123&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils/number-comma.ts&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(): string {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '1,234'&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; utils/index.ts&lt;/span&gt;
export {&lt;span&gt;default&lt;/span&gt; as getUid} from './get-uid'&lt;span&gt;
export {&lt;/span&gt;&lt;span&gt;default&lt;/span&gt; as numberComma} from './number-comma'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每添加一个新的&lt;code&gt;util&lt;/code&gt;，就去&lt;code&gt;index&lt;/code&gt;中添加对应的索引，这样带来的好处就是可以通过一行来引入所有想引入的&lt;code&gt;utils&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import {getUid, numberComma} from './utils'
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;configs&quot;&gt;configs&lt;/h3&gt;
&lt;p&gt;configs下边存储的就是各种配置信息了，包括一些第三方接口URL、数据库配置、日志路径。&lt;br/&gt;各种balabala的静态数据。&lt;br/&gt;如果配置文件多的话，建议拆分为多个文件，然后按照&lt;code&gt;utils&lt;/code&gt;的方式编写索引文件。&lt;/p&gt;
&lt;h3 id=&quot;types&quot;&gt;types&lt;/h3&gt;
&lt;p&gt;这里存放的是所有的自定义的类型定义，一些开源社区没有提供的，但是我们用到的第三方插件，需要在这里进行定义，一般来说常用的都会有，但是一些小众的包可能确实没有TS的支持，例如我们有使用的一个&lt;code&gt;node-qconf&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; types/node-qconf.d.ts&lt;/span&gt;
export &lt;span&gt;function&lt;/span&gt; getConf(path: string): string | &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; getBatchKeys(path: string): string[] | &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; getBatchConf(path: string): string | &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; getAllHost(path: string): string[] | &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; getHost(path: string): string | &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;类型定义的文件规定后缀为 .d.ts&lt;/em&gt;&lt;br/&gt;types下边的所有文件可以直接引用，而不用关心相对路径的问题（其他普通的model则需要写相对路径，这是一个很尴尬的问题）。&lt;/p&gt;
&lt;h3 id=&quot;目前使用TS中的一些问题&quot;&gt;目前使用TS中的一些问题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://os4ty6tab.qnssl.com/cblued/static/issues.1ci8qk2dr12l4sc.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;327&quot;/&gt;&lt;br/&gt;当前GitHub仓库中，有2600+的开启状态的issues，筛选bug标签后，依然有900+的存在。&lt;br/&gt;所以很难保证在使用的过程中不会踩坑，但是一个项目拥有这么多活跃的issues，也能从侧面说明这个项目的受欢迎程度。&lt;/p&gt;
&lt;p&gt;目前遇到的唯一一个比较尴尬的问题就是：&lt;br/&gt;&lt;strong&gt;引用文件路径一定要写全。。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import module from '../../../../f**k-module'
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;初次尝试TypeScript，深深的喜欢上了这个语言，虽说也会有一些小小的问题，但还是能客服的:)。&lt;br/&gt;使用一门静态强类型编译语言，能够将很多bug都消灭在开发期间。&lt;/p&gt;
&lt;p&gt;基于上述描述的一个简单示例：&lt;a href=&quot;https://github.com/Jiasm/typescript-example&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;代码仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望大家玩得开心，如有任何TS相关的问题，欢迎来骚扰。&lt;code&gt;NPM loves U.&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;TypeScript在node项目中的实践&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/9348539.html</dc:identifier>
</item>
<item>
<title>Angular中sweetalert弹框的使用详解 - 半指温柔乐</title>
<link>http://www.cnblogs.com/le220/p/9348337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/le220/p/9348337.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近太忙了，项目中使用的弹框老板嫌太丑，让我们优化一下，我在网上找了一下，找到了sweetalert弹框，算是比较好看的弹框了。所以我就想办法将sweetalert用到项目中，在项目中引入sweetalert时，遇到诸多问题，但最终在我不懈坚持下，都解决了，实现了效果。具体用法请看下文。写的有问题的地方欢迎留言，我会及时更改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、下载文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;npm install &lt;span&gt;&lt;strong&gt;angular-sweetalert&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;npm install &lt;span&gt;&lt;strong&gt;sweetalert&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;/span&gt;npm &lt;span&gt;下载&lt;/span&gt;&lt;span&gt;angular-sweetalert&lt;/span&gt;&lt;span&gt;时，会附带下载&lt;/span&gt;&lt;span&gt;sweetalert&lt;/span&gt;&lt;span&gt;，但是只能用&lt;/span&gt;&lt;span&gt;sweetalert&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;js&lt;/span&gt;&lt;span&gt;必须通过&lt;/span&gt;&lt;span&gt;npm&lt;/span&gt;&lt;span&gt;下载&lt;/span&gt;&lt;span&gt;sweetalert&lt;/span&gt;&lt;span&gt;，引入下载的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;sweetalert.min.js&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、版本说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Angular V1.2.30&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Angular-sweetalert V1.0.4&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sweetalert V2.1.0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因为我们项目使用的&lt;/span&gt;angular&lt;span&gt;版本较低，所以相对应下载的&lt;/span&gt;&lt;span&gt;angular-sweetalert&lt;/span&gt;&lt;span&gt;版本也低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一定要注意版本，如果&lt;/span&gt;angular-sweetalert&lt;span&gt;版本过高，所依赖的文件&lt;/span&gt;&lt;span&gt;angular&lt;/span&gt;&lt;span&gt;版本过低，会导致引入报错。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、引入文件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;sweetalert/sweetalert.min.css&lt;/li&gt;
&lt;li&gt;angular/angular.min.js&lt;/li&gt;
&lt;li&gt;angular-sweetalert/SweetAlert.min.js&lt;/li&gt;
&lt;li&gt;sweetalert/sweetalert.min.js&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意:在&lt;/span&gt;app&lt;span&gt;中添加依赖模块‘&lt;/span&gt;&lt;span&gt;&lt;strong&gt;oitozero.ngSweetAlert&lt;/strong&gt;&lt;/span&gt;’&lt;/p&gt;
&lt;h2&gt;四、使用方法&lt;/h2&gt;
&lt;h3&gt;1&lt;span&gt;、基础用法&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;swal&lt;/strong&gt;&lt;/span&gt;(&quot;请选中数据再进行操作&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223223016-1920212006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2&lt;span&gt;、确认提示框&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;swal&lt;/strong&gt;&lt;/span&gt;({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             title: &quot;提交&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             text: &quot;确定提交吗&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;&lt;strong&gt;icon&lt;/strong&gt;&lt;/span&gt;: '&lt;span&gt;&lt;strong&gt;info&lt;/strong&gt;&lt;/span&gt;'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;            buttons&lt;/strong&gt;&lt;/span&gt;: {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                 cancel: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                 confirm: &quot;Confirm&quot;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223245789-324966729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3&lt;span&gt;、成功信息提示&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&lt;strong&gt;swal&lt;/strong&gt;&lt;/span&gt;(&quot;提交&quot;, &quot;提交成功成功&quot;, '&lt;span&gt;&lt;strong&gt;success&lt;/strong&gt;&lt;/span&gt;');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223313829-301920426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4&lt;span&gt;、错误信息提示&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&lt;strong&gt;swal&lt;/strong&gt;&lt;/span&gt;(&quot;删除&quot;, &quot;删除成功&quot;, '&lt;span&gt;&lt;strong&gt;error&lt;/strong&gt;&lt;/span&gt;');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223326459-1051060114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5&lt;span&gt;、&lt;/span&gt;&lt;span&gt;警告信息弹窗，&lt;/span&gt;“&lt;span&gt;确认&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;按钮带有一个函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;swal&lt;/strong&gt;&lt;/span&gt;({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    title: &quot;审批&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    text: &quot;确定通过审批吗&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;&lt;strong&gt;icon&lt;/strong&gt;&lt;/span&gt;: 'warning'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;   buttons&lt;/strong&gt;&lt;/span&gt;: {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       cancel: &quot;取消&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       confirm: &quot;确定&quot;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; }).&lt;span&gt;&lt;strong&gt;then&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(isConfirm){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isConfirm){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       httpService.post('/bill/add'&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         billNo: $scope.content.statementBillno,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;          systemNo: 'clearingservice'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;          approvalNo: 'cs001'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         userId: username,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         shopNo: $scope.content.storeId
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       }, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(data) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             commonService.state.go(&quot;clearingservice.statements.list&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      }, config.systemInfo.approval);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       &lt;span&gt;&lt;strong&gt;swal&lt;/strong&gt;&lt;/span&gt;(&quot;取消&quot;,&quot;没有审批&quot;,'error'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223407909-807626200.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;点击取消执行else&lt;span&gt;中的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223430037-1861746586.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击确定直接执行函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201807/1217233-20180721223457633-759281281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、相关问题&lt;/h2&gt;
&lt;h3&gt;1&lt;span&gt;、传函数错误&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Swal(“确定提交吗”,  function(){}, ‘error’ );  //&lt;span&gt;这种写法在我用的这个版本中是错误的，我的这个版本支持&lt;/span&gt;&lt;span&gt;&lt;strong&gt;then()&lt;/strong&gt;,&lt;/span&gt; &lt;span&gt;不支持直接在参数中写方法&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、API&lt;span&gt;问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在这个版本中以下写法只能实现&lt;/span&gt;&lt;strong&gt;title&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;strong&gt;&lt;span&gt;text&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的效果，其他属性都不起作用&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;swal({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;       title: &quot;确定删除吗？&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       text: &quot;你将无法恢复该虚拟文件！&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       type: &quot;warning&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       showCancelButton: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       confirmButtonColor: &quot;#DD6B55&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       confirmButtonText: &quot;确定删除！&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       closeOnConfirm: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   },
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       swal(&quot;删除！&quot;, &quot;你的虚拟文件已经被删除。&quot;, &quot;success&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这个版本中只能按照我最上面所列举的去实现，那是我在官方英文文档中发现的，中文文档太坑了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;官方文档：&lt;/span&gt;https://sweetalert.js.org/docs/&lt;/p&gt;

</description>
<pubDate>Sat, 21 Jul 2018 15:09:00 +0000</pubDate>
<dc:creator>半指温柔乐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/le220/p/9348337.html</dc:identifier>
</item>
<item>
<title>spring集成cxf实现webservice接口功能 - 架构师小跟班</title>
<link>http://www.cnblogs.com/xyhero/p/9348469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyhero/p/9348469.html</guid>
<description>&lt;p&gt;由于cxf的web项目已经集成了Spring，所以cxf的服务类都是在spring的配置文件中完成的。以下是步骤：&lt;br/&gt;第一步：建立一个web项目。&lt;br/&gt;第二步：准备所有jar包。将cxf_home\lib项目下的所有jar包全部copy到新项目的lib目录下，里面已经包含了spring3.0的jar包。&lt;br/&gt;第三步：在web.xml中配置cxf的核心servlet，CXFServlet。&lt;br/&gt;第四步：创建(最好是Copy)cxf-servlet.xml文件。这是一个spring的配置文件。&lt;/p&gt;
&lt;p&gt;1、web.xml中配置servlet&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158160/201807/1158160-20180721225943546-741287538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果没有提供给cxf默认的/WEB-INF/cxf-servlet.xml配置文件，则必须要在spring的配置文件中配置以下三行配置（import）。否则将不能加载名称为cxf的bean.从而启动失败。&lt;/p&gt;
&lt;p&gt;2、applicationContext.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;spring发布webservice服务配置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;import &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;classpath:META-INF/cxf/cxf.xml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;import &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;import &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入webservice服务 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 统一工号管理接口 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;UnifiedNoServiceBean&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.webservice.unifiedno.service.impl.UnifiedNoServiceImpl&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jaxws:server &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;UnifiedNoService&quot;&lt;/span&gt;&lt;span&gt; serviceClass&lt;/span&gt;&lt;span&gt;=&quot;com.webservice.unifiedno.service.UnifiedNoService&quot;&lt;/span&gt;&lt;span&gt; address&lt;/span&gt;&lt;span&gt;=&quot;/unifiedNoService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jaxws:serviceBean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;UnifiedNoServiceBean&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jaxws:serviceBean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jaxws:server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、&amp;lt;import&amp;gt;的三个文件是否需要全部引入根据cxf框架版本不同而不同&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、address的值为webservice注解的值：@WebService(serviceName = &quot;unifiedNoService&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、必须要在声明为serviceClass的接口上声明@WebSerive注解，因为，要使用了接口，在接口上添加的注解才会有效。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、serviceClass：必须为一个接口，并在接口上必须使用@WebService注解否则调用时会抛出异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5、serviceBean:是实际服务的类，必须是serviceClass的子类，此类上面即可以使用@WebService注解，也可以不使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6、address：访问地址，省去前面的ip:port，注意在此注册的类，必须要添加@WebService的注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、写接口及实现类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158160/201807/1158160-20180721230006979-1891959196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动项目，测试cxf是否配置成功：&lt;br/&gt;访问：http://localhost:8080/ins/services，会列出所有已经发布的webservice接口服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158160/201807/1158160-20180721230027849-2105721379.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;316&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、测试&lt;br/&gt;http://localhost:8080/ins/services/unifiedNoService?wsdl&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158160/201807/1158160-20180721230104087-623198198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java项目代码调用服务：&lt;/p&gt;
&lt;p&gt;使用纯Java项目调用&lt;br/&gt;1、根据客户端生成的代码来调用。（优选这种方式）&lt;br/&gt;请先生成然后在任意的Java项目中调用 。&lt;br/&gt;2、客户端只拥有一个接口，使用JaxWsProxyFactoryBean来调用。&lt;br/&gt;因为以下使用了JaxWsProxyFactoryBean,所以，仍然需要CXF的环境，而使用此环境就会造成Jar文件的大量冗余，所以大家要谨慎选择。&lt;/p&gt;
&lt;p&gt;1、注意，此处所说的是在Java项目中调用Spring的服务，并不是在JavaEE项目中调用。后期将会讲到如何在JavaEE项目中调用。&lt;br/&gt;2、建议从wsdl地址获取接口文件，也仅需要接口文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
JaxWsProxyFactoryBean client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JaxWsProxyFactoryBean();
client.setAddress(&lt;/span&gt;&quot;http://localhost:7777/xcxf2_web/ws/one&quot;&lt;span&gt;);
client.setServiceClass(IOneService.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
IOneService one &lt;/span&gt;= client.create(IOneService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
String ss &lt;/span&gt;= one.sayHi(&quot;OK你好&quot;&lt;span&gt;);
System.err.println(ss);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Spring项目中，通过配置文件调用：&lt;/p&gt;
&lt;p&gt;以下是使用Spring的配置文件调用：&lt;br/&gt;新建立一个Java项目，并加载cxf的所有包。&lt;br/&gt;只需要生成的接口文件。&lt;br/&gt;在classpath下新建立一个ClientBeans.xml文件.&lt;/p&gt;
&lt;p&gt;优点与缺点：&lt;br/&gt;此种情况，适合于一个Javaweb项目已经集成了Spring。并希望通过CXF配置的方式调用Web服务。&lt;br/&gt;此种情况，仍然需要导入CXF的大量jar包。&lt;br/&gt;这种情况也存在一定人优点，如可以将外部的Web服务通过配置文件注入(DI)到Action类中。&lt;/p&gt;
&lt;p&gt;说明：&lt;br/&gt;通过&amp;lt;jaxws:client/&amp;gt;来获取WebService，id就不用说了吧。&lt;br/&gt;address是不包含?wsdl的服务地址。&lt;br/&gt;serviceClass是本地的接口名，与服务接口名保持相同才可以。&lt;/p&gt;
&lt;p&gt;1、以下是ClientBeans.xml的文件的源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:jaxws&lt;/span&gt;&lt;span&gt;=&quot;http://cxf.apache.org/jaxws&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:jaxrs&lt;/span&gt;&lt;span&gt;=&quot;http://cxf.apache.org/jaxrs&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:cxf&lt;/span&gt;&lt;span&gt;=&quot;http://cxf.apache.org/core&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
                              http://www.springframework.org/schema/beans/spring-beans.xsd
            http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd
            http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd
            http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jaxws:client &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;helloClient&quot;&lt;/span&gt;&lt;span&gt;
                   address&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:9999/cxf2.4_spring_web/ws/helloworld&quot;&lt;/span&gt;&lt;span&gt;
                   serviceClass&lt;/span&gt;&lt;span&gt;=&quot;com.itcast.cxf.first.IHelloWorld&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jaxws:client&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、以下是CxfJavaClient.java的源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.itcast.cxfweb.java.client;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.itcast.cxf.first.IHelloWorld;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Java项目的客户端
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wangjianme
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CxfJavaClient {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取配置文件&lt;/span&gt;
        ApplicationContext ctx = 
            &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;ClientBeans.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get到接口类型并调用&lt;/span&gt;
        IHelloWorld hello = (IHelloWorld)ctx.getBean(&quot;helloClient&quot;&lt;span&gt;);
        String str &lt;/span&gt;= hello.sayHello(&quot;WJ&quot;&lt;span&gt;);
        System.err.println(str);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在本域使用jquery访问： －－查询所有用户：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
      $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          $(&lt;/span&gt;&quot;#btn1&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
              &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = &quot;http://localhost:7777/ws2/ws/user&quot;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; soap = '&amp;lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; '+
                         'xmlns:q0=&quot;http://service.ws2.itcast.cn/&quot; '+
                         'xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; '+
                         'xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;'+
                         '&amp;lt;soapenv:Body&amp;gt;&amp;lt;q0:getUsers/&amp;gt;&amp;lt;/soapenv:Body&amp;gt;&amp;lt;/soapenv:Envelope&amp;gt;'&lt;span&gt;;
              $.ajax({
                  url:url,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问的url&lt;/span&gt;
                  dataType:'xml',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的数据类型&lt;/span&gt;
                  type:'post',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求方式&lt;/span&gt;
                  contentType:'application/soap+xml;charset=UTF-8'&lt;span&gt;,
                  data:soap,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
                  success:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,status,xhr){
                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对返回后的数据进行解析&lt;/span&gt;
                      $(data).find(&quot;return&quot;).each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nm = $(&lt;span&gt;this&lt;/span&gt;).find(&quot;name&quot;&lt;span&gt;).text();
                          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; age = $(&lt;span&gt;this&lt;/span&gt;).find(&quot;age&quot;&lt;span&gt;).text();
                          alert(nm&lt;/span&gt;+&quot;,&quot;+&lt;span&gt;age);
                      });
                  },
                  error:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(xhr,status){
                      alert(&lt;/span&gt;&quot;出错了:&quot;+&lt;span&gt;status);
                  }
              });
          });
      });
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;向服务器保存用户：&lt;/p&gt;
&lt;p&gt;以下是jsclient.jsp的源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;%&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
      &amp;lt;script type=&quot;text/javascript&quot;&lt;span&gt; 
              src&lt;/span&gt;=&quot;&amp;lt;c:url value='/js/jquery-1.5.js'/&amp;gt;&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
        &amp;lt;label &lt;span&gt;for&lt;/span&gt;=&quot;name&quot;&amp;gt;姓名：&amp;lt;/label&amp;gt;
        &amp;lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;/&amp;gt;
        &amp;lt;br/&amp;gt;
        &amp;lt;a href=&quot;#&quot; id=&quot;ok&quot;&amp;gt;确定&amp;lt;/a&amp;gt;
  &amp;lt;/body&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;
      $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $(&lt;/span&gt;&quot;#ok&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = $(&quot;#name&quot;&lt;span&gt;).val();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($.trim(val)==&quot;&quot;&lt;span&gt;){
                alert(&lt;/span&gt;&quot;请输入名称&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = '&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;'+
                      '&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;'+
                      '&amp;lt;soap:Body&amp;gt;&amp;lt;ns2:sayHello xmlns:ns2=&quot;http://first.cxf.itcast.com/&quot;&amp;gt;'+
                      '&amp;lt;arg0&amp;gt;'+val+'&amp;lt;/arg0&amp;gt;'+
                      '&amp;lt;/ns2:sayHello&amp;gt;&amp;lt;/soap:Body&amp;gt;&amp;lt;/soap:Envelope&amp;gt;'&lt;span&gt;;
            $.ajax({
                contentType:&lt;/span&gt;'application/xml;charset=&quot;UTF-8&quot;'&lt;span&gt;,
                dataType:&lt;/span&gt;'xml'&lt;span&gt;,
                type:&lt;/span&gt;'post'&lt;span&gt;,
                url:&lt;/span&gt;'http://localhost:9999/cxf2.4_spring_web/ws/helloworld',        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接发向这个地址&lt;/span&gt;
&lt;span&gt;                data:str,
                success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$(data).find(&quot;return&quot;).each(function(){&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    alert($(this).text());&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;});                    //使用上面的方法也是可以的&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; ss = $(data).find(&quot;return&quot;&lt;span&gt;).first().text();
                    $(&lt;/span&gt;&quot;&amp;lt;div&amp;gt;&quot;&lt;span&gt;).html(ss)
                        .css(&lt;/span&gt;&quot;border&quot;,&quot;1px solid blue&quot;&lt;span&gt;)
                        .css({width:&lt;/span&gt;'50%'&lt;span&gt;}).
                        appendTo($(&lt;/span&gt;&quot;body&quot;&lt;span&gt;));
                    $(&lt;/span&gt;&quot;#name&quot;).val(&quot;&quot;&lt;span&gt;);
                }
            },&lt;/span&gt;&quot;xml&quot;&lt;span&gt;);
        });
      });
  &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 21 Jul 2018 15:07:00 +0000</pubDate>
<dc:creator>架构师小跟班</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyhero/p/9348469.html</dc:identifier>
</item>
<item>
<title>多进程（multiprocessing module） - Hme</title>
<link>http://www.cnblogs.com/horror/p/9348285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/horror/p/9348285.html</guid>
<description>&lt;h2&gt;1.1 多进程的概念&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;由于GIL的存在，python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，在python中大部分情况需要使用多进程。Python提供了非常好用的多进程包multiprocessing，只需要定义一个函数，Python会完成其他所有事情。借助这个包，可以轻松完成从单进程到&lt;strong&gt;并发执行&lt;/strong&gt;的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但在使用这些共享API的时候，我们要注意以下几点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a、在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b、Windows系统下，需要注意的是要想启动一个子进程，必须加上 if __name__ == &quot;__main__&quot;，进程相关的要写在这句下面。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.2 创建进程的两种方式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;直接创建：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_b60b9dde-fa55-44aa-a60f-0e348cb76619&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b60b9dde-fa55-44aa-a60f-0e348cb76619&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b60b9dde-fa55-44aa-a60f-0e348cb76619&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(name):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name,time.ctime())
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     p_list=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         p = Process(target=f, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alvin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        p_list.append(p)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        p.start()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        p.join()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo1&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类式调用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_869b5133-b71a-4272-bd5c-dca3e244f9d3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_869b5133-b71a-4272-bd5c-dca3e244f9d3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_869b5133-b71a-4272-bd5c-dca3e244f9d3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyProcess(Process):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         super(MyProcess, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;self.name = name&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.name,time.ctime())
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     p_list=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         p =&lt;span&gt; MyProcess()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        p.start()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        p_list.append(p)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        p.join()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo2&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;2.1 构造方法&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　 Process([group [, target [, name [, args [, kwargs]]]]])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　group: 线程组，目前还没有实现，库引用中提示必须是None； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　target: 要执行的方法； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　name: 进程名； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　args/kwargs: 要传入方法的参数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.2 实例方法&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　 is_alive()：返回进程是否在运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　start()：进程准备就绪，等待CPU调度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　terminate()：不管任务是否完成，立即停止工作进程&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.3 属性&lt;/h2&gt;
&lt;p&gt;　  　&lt;span&gt;authkey&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　daemon：和线程的setDeamon功能一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　exitcode(进程在运行时为None、如果为–N，表示被信号N结束）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　name：进程名字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　pid：进程号。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_f2b42030-67af-43df-a2f5-f1f36eb49d6b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2b42030-67af-43df-a2f5-f1f36eb49d6b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2b42030-67af-43df-a2f5-f1f36eb49d6b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;  multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo(i):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt; (p.is_alive(),i,p.pid)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     p_list=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         p = Process(target=foo, args=&lt;span&gt;(i,))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;p.daemon=True&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        p_list.append(p)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        p.start()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for p in p_list:&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     p.join()&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;main process end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;不同进程间内存是不共享的，要想实现两个进程间的数据交换，可以用以下方法：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.1 Queues 使用方法跟threading里的queue类似 --&amp;gt; 将q作为参数传递给子进程。&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_f6f3ef4a-ee2c-4152-95a5-edf2bbb0f788&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f6f3ef4a-ee2c-4152-95a5-edf2bbb0f788&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f6f3ef4a-ee2c-4152-95a5-edf2bbb0f788&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Queue
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(q,n):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     q.put([42, n, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     q =&lt;span&gt; Queue()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     p_list=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         p = Process(target=f, args=&lt;span&gt;(q,i))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        p_list.append(p)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        p.start()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.get())
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             i.join()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo1&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.2 Pipes --&amp;gt; 通过管道Pipe实现。&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_0bc8617b-7193-4ea0-9ff1-c45d6b143069&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0bc8617b-7193-4ea0-9ff1-c45d6b143069&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0bc8617b-7193-4ea0-9ff1-c45d6b143069&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Pipe
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(conn):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     conn.send([42, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    conn.close()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     parent_conn, child_conn =&lt;span&gt; Pipe()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     p = Process(target=f, args=&lt;span&gt;(child_conn,))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    p.start()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(parent_conn.recv())   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; prints &quot;[42, None, 'hello']&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     p.join()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo2&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.3 数据共享（Manager）&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Manager（）返回的管理器对象控制一个服务器进程，该进程保存Python对象并允许其他进程使用代理操作它们。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_b9adb0d2-1559-4dbe-97b0-cfd18838942a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b9adb0d2-1559-4dbe-97b0-cfd18838942a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b9adb0d2-1559-4dbe-97b0-cfd18838942a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Manager
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(d, l,n):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     d[n] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 2
&lt;span&gt; 6&lt;/span&gt;     d[0.25] =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    l.append(n)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(l)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    with Manager() as manager:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         d =&lt;span&gt; manager.dict()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         l = manager.list(range(5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         p_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             p = Process(target=f, args=&lt;span&gt;(d, l,i))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            p.start()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            p_list.append(p)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; res &lt;span&gt;in&lt;/span&gt;&lt;span&gt; p_list:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            res.join()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(l)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Demo&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.4 进程同步&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Without using the lock output from the different processes is liable to get all mixed up.　　如果不使用来自不同进程的锁定输出，则可能会混淆不清。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process, Lock
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(l, i):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    l.acquire()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        l.release()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     lock =&lt;span&gt; Lock()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; num &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Process(target=f, args=(lock, num)).start()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.5 进程池&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进程，那么程序就会等待，直到进程池中有可用进程为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程池中有两个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;apply&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;apply_async&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;  multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Pool
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Foo(i):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; i+100
&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Bar(arg):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--&amp;gt;exec done:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,arg)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; pool = Pool(5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     pool.apply_async(func=Foo, args=(i,),callback=&lt;span&gt;Bar)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;pool.apply(func=Foo, args=(i,))&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;pool.close()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; pool.join()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：&lt;strong&gt;协程是一种用户态的轻量级线程&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;协程的好处：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无需线程上下文切换的开销&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无需原子操作锁定及同步的开销&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;原子操作(atomic operation)是不需要synchronized&quot;，所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱，或者切割掉只执行部分。视作整体是原子性的核心。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;方便切换控制流，简化编程模型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无法利用多核资源：&lt;strong&gt;协程的本质是个单线程&lt;/strong&gt;,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4.1 使用yield实现协程操作&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; 1 import&lt;span&gt; time&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/span&gt;&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt; 2 import&lt;span&gt; queue&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer(name):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&amp;gt;starting eating baozi...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         new_baozi = &lt;span&gt;yield&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%s] is eating baozi %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name,new_baozi))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(1)&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; producer():
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  
&lt;span&gt;12&lt;/span&gt;     r = con.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     r = con2.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     n =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; n &amp;lt; 5&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         n +=1
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        con.send(n)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        con2.send(n)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[32;1m[producer]\033[0m is making baozi %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;n )
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     con = consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)　　　　# 创建生成器对象
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     con2 = consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)　　　 # 创建生成器对象
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     p = producer()　　　　　　　　# 执行producer函数&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;协程标准定义，即符合什么条件就能称之为协程：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;必须在只有一个单线程里实现并发&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;修改共享数据不需加锁&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;用户程序里自己保存多个控制流的上下文栈&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一个协程遇到IO操作自动切换到其它协程&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;基于上面这4点定义，我们刚才用yield实现的程并不能算是合格的线程，因为它有一点功能没实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.2 Greenlet&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;greenlet是一个用C实现的协程模块，相比与python自带的yield，它可以使你在任意函数之间随意切换，而不需把这个函数先声明为generator&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; greenlet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; greenlet
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test1():
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(12&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    gr2.switch()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(34&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    gr2.switch()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test2():
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(56&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    gr1.switch()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(78&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt; gr1 =&lt;span&gt; greenlet(test1)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; gr2 =&lt;span&gt; greenlet(test2)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; gr1.switch()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;感觉确实用着比generator还简单了，但好像还没有解决一个问题，就是遇到IO操作，自动切换，并不对。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.3 Gevent &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是&lt;strong&gt;Greenlet&lt;/strong&gt;, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[31;1m李闯在跟海涛搞...\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     gevent.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[31;1m李闯又回去跟继续跟海涛搞...\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2():
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1m李闯切换到了跟海龙搞...\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     gevent.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\033[32;1m李闯搞完了海涛，回来继续跟海龙搞...\033[0m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;gevent.joinall([
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    gevent.spawn(func1),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    gevent.spawn(func2),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;gevent.spawn(func3),&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; ])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;李闯在跟海涛搞...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;李闯切换到了跟海龙搞...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;李闯搞完了海涛，回来继续跟海龙搞...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;李闯又回去跟继续跟海涛搞...&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5.1 &lt;strong&gt;同步与异步的性能区别&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; task(pid):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Some non-deterministic task
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     gevent.sleep(0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Task %s done&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; pid)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; synchronous():
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1,10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        task(i)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; asynchronous():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     threads = [gevent.spawn(task, i) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    gevent.joinall(threads)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Synchronous:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;synchronous()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asynchronous:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; asynchronous()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面程序的重要部分是将task函数封装到Greenlet内部线程的&lt;code&gt;gevent.spawn&lt;/code&gt;。 初始化的greenlet列表存放在数组&lt;code&gt;threads&lt;/code&gt;中，此数组被传给&lt;code&gt;gevent.joinall&lt;/code&gt; 函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在 所有greenlet执行完后才会继续向下走。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.2 &lt;strong&gt;遇到IO阻塞时会自动切换任务（gevent 库中的 monkey 方法）--&amp;gt; 补丁&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　&lt;span&gt;　-------&amp;gt;能够最大程度监听IO阻塞，提高效率。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; gevent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; monkey
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;monkey.patch_all()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; gevent
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;  urllib.request &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlopen
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(url):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; url)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     resp =&lt;span&gt; urlopen(url)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     data =&lt;span&gt; resp.read()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d bytes received from %s.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (len(data), url))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;gevent.joinall([
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         gevent.spawn(f, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.python.org/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         gevent.spawn(f, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.yahoo.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         gevent.spawn(f, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; ])
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 21 Jul 2018 14:13:00 +0000</pubDate>
<dc:creator>Hme</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/horror/p/9348285.html</dc:identifier>
</item>
<item>
<title>golang - gob与rpc - CloudGeek</title>
<link>http://www.cnblogs.com/cloudgeek/p/9348267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudgeek/p/9348267.html</guid>
<description>&lt;p&gt;　　今天和大家聊聊golang中怎么使用rpc，rpc数据传输会涉及到gob编码，所以先讲讲gob，别担心，就算你完全没有接触过gob与rpc，只要知道rpc的中文是远程过程调用，剩下的我都能给你讲明白（带你入门不包你精通）！&lt;/p&gt;

&lt;p&gt;　　gob全称为：Go binary&lt;/p&gt;
&lt;p&gt;　　Golang自带的一个数据结构序列化编码/解码工具，也就是说gob可以讲go中的一个数据结构序列化成某种东西，还能反序列化！序列化成啥我们后面来看，不管是变成一个字符串，变成二进制流，变成啥先不管，反正作用就是序列化。&lt;/p&gt;
&lt;p&gt;　　Gob使用时我们需要关注Encoder和Decoder对象，顾名思义，一个是编码的时候用的，一个是解码的时候用的，我们看一下怎么获取这两个对象先：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AicibUllQlLBiaKNpZ2OF7t7XK7RjEwUeaRjG5TAYP0766JeoiaXXwFrBffMukiaMEfNwuRCblWSiaTG87Z2tEtW2jpg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.3472041612483745&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AicibUllQlLBiaKNpZ2OF7t7XK7RjEwUeaR53TmcgWic8Xebg3yJLtET2uBn9HDkpyhWz7FjYuiaPlR9kvicbFTXo57Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.43159203980099503&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以很明确，需要调用这两个函数来获取Encoder和Decoder对象。注意这里的参数是io.Writer和io.Reader接口类型，我们在上一讲介绍过这两个接口，所以这里需要的参数分别是实现了io.Writer和io.Reader接口类型的对象即可。&lt;/p&gt;
&lt;p&gt;　　Encoder和Decoder分别有一个主要的方法是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AicibUllQlLBiaKNpZ2OF7t7XK7RjEwUeaR8Lvs5sjBOc40B3iaYrNu9ElR7HQxqaibYic425UnLILp5eQiciaKibeCTQAA/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.13597430406852248&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AicibUllQlLBiaKNpZ2OF7t7XK7RjEwUeaRVlgYk3vJtZ37Q7x71zWEdp3emPca5UjTpueicIxR2Qo49lqM2fub8dQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.3190376569037657&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到这里我们已经可以得到如下结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Gob 使用 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象通过调用 Encode()方法实现编码操作；使用 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode()方法完成解码操作！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来我们试着用一下这个Encoder和Decoder，就轻轻松松入门gob了，来看第一个例子&lt;/p&gt;
&lt;p&gt;　　例1：数据结构与bytes.Buffer之间的转换（编码成字节切片）&lt;/p&gt;
&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;go language-go hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;bytes&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;encoding/gob&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;io&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; P &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;    X, Y, Z &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;    Name    &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Q &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    X, Y *&lt;span class=&quot;hljs-keyword&quot;&gt;int32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    Name &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;    data := P{&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CloudGeek&quot;&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;    buf := encode(data)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; q *Q&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;    q = decode(buf)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;    fmt.Printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%q: {%d,%d}\n&quot;&lt;/span&gt;, q.Name, *q.X, *q.Y)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(data &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;bytes&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Buffer&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; buf bytes.Buffer&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;    enc := gob.NewEncoder(&amp;amp;buf)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;    enc.Encode(data)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;buf&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;47&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(data &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;Q&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;48&lt;/span&gt;    d := data.(io.Reader)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;49&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;50&lt;/span&gt;    dec := gob.NewDecoder(d)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;51&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; q Q&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;52&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;53&lt;/span&gt;    dec.Decode(&amp;amp;q)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;54&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;q&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;55&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　例2：数据结构到文件的序列化和反序列化&lt;/p&gt;
&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;go language-go hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;encoding/gob&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Address &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;    City    &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;    Country &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; filePath &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    filePath = &lt;span class=&quot;hljs-string&quot;&gt;&quot;./address.gob&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;    encode()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;    pa := decode()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;    fmt.Println(*pa) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;    pa := &amp;amp;Address{&lt;span class=&quot;hljs-string&quot;&gt;&quot;Chengdu&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;China&quot;&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;    file, _ := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY, &lt;span class=&quot;hljs-number&quot;&gt;0666&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;defer&lt;/span&gt; file.Close()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;    enc := gob.NewEncoder(file)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;    enc.Encode(pa)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;Address&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;    file, _ := os.Open(filePath)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;defer&lt;/span&gt; file.Close()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; pa Address&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;43&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;44&lt;/span&gt;    dec := gob.NewDecoder(file)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;45&lt;/span&gt;    dec.Decode(&amp;amp;pa)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;46&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;pa&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;47&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面2个例子都不难，我去掉了错误处理之类的代码，尽量注释了每块代码，耐心看完这2个例子应该就能体会gob的encode和decode精髓了。&lt;/p&gt;
&lt;p&gt;理解gob是什么的基础上，如果你需要使用gob开发，建议详细看一下官方文档，了解一下更多的细节：https://golang.org/pkg/encoding/gob/&lt;/p&gt;


&lt;p&gt;　　如果你之前没有做过基于rpc通信的开发工作，直接去网上查rpc相关的知识点的时候很可能会一脸蒙圈，rest api咋就那么好理解，一个http请求过去就行了，rpc咋个回事，看不懂呀。。。&lt;/p&gt;
&lt;p&gt;　　所以我不会和多数教程一样为了追求详细或者展示自己技术多牛而去写很长的例子，扯一堆专业的概念，我们先最快的方式体验一下rpc调用的感觉！&lt;/p&gt;
&lt;p&gt;　　rpc服务端&lt;/p&gt;
&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;go language-go hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;net&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;net/rpc&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Args &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    A, B &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Arith &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(t *Arith)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Multiply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args *Args, reply *&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    *reply = args.A * args.B&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;    arith := &lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt;(Arith)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;    rpc.Register(arith)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;    rpc.HandleHTTP()&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;    l, _ := net.Listen(&lt;span class=&quot;hljs-string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;:1234&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;    http.Serve(l, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　rpc客户端&lt;/p&gt;
&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;19&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;go language-go hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;net/rpc&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Args &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;    A, B &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;    client, _ := rpc.DialHTTP(&lt;span class=&quot;hljs-string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1:1234&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;    args := &amp;amp;Args{&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; reply &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;    client.Call(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Arith.Multiply&quot;&lt;/span&gt;, args, &amp;amp;reply)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;    fmt.Printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Arith: %d*%d=%d\n&quot;&lt;/span&gt;, args.A, args.B, reply)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面2段程序很简短，可能你现在还不能理解其中的细节，但也请耐心看完，这个时候你应该能够心里有个rpc调用的概念了，客户端直接调用了服务器端的一个函数传递过去参数列表和接收返回值的对象，获得调用结果。&lt;/p&gt;


&lt;p&gt;　　下面我们再来看一些rpc相关的细节&lt;/p&gt;
&lt;p&gt;　　首先能够被rpc调用的方法应该看起来像这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;func (t *T) MethodName(argType T1, replyType *T2) error&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　大概解释一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数必须是可导出的(首字母大写)&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;必须有两个导出类型的参数，第一个参数用来接收参数，第二个参数是返回给客户端的结果参数，第二个参数必须是指针类型的&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;函数还要有一个返回值error&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;T1、T2能够被encoding/gob编码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　看到这里你应该对于rpc的作用有了一定的认识，go中rpc包的用法简单来看就是准备一个类型，绑定一堆符合规范的方法，然后注册给rpc服务，监听客户端连接，客户端通过rpc包提供的Call方法可以调用到server注册好的方法。更多细节可以看一下官方文档：https://golang.org/pkg/net/rpc/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/AicibUllQlLBhswTCFkibyAypNSFPngT4GjYsiclgvW6fHuqvtcgGZFwhSx3mA12pcsPmEgBKl8cO9MnQuCAkl39qA/640?wx_fmt=gif&quot; alt=&quot;&quot; data-ratio=&quot;0.7326565143824028&quot; data-type=&quot;gif&quot; data-w=&quot;591&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 14:09:00 +0000</pubDate>
<dc:creator>CloudGeek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudgeek/p/9348267.html</dc:identifier>
</item>
<item>
<title>Java多线程详解 - 谁将新樽辞旧月，今月曾经照古人</title>
<link>http://www.cnblogs.com/jiangwz/p/9051337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangwz/p/9051337.html</guid>
<description>&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;每个运行的程序就是一个进程，当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个进程。&lt;/p&gt;
&lt;p&gt;进程的特性：&lt;/p&gt;
&lt;p&gt;独立性：每一个进程都拥有自己的私有地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。&lt;/p&gt;
&lt;p&gt;动态性：程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。&lt;/p&gt;
&lt;p&gt;并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会有影响。&lt;/p&gt;
&lt;p&gt;并发性和并行性：&lt;/p&gt;
&lt;p&gt;并发性：在同一时刻只能有一条命令执行，但多个进程指令被快速轮换执行。&lt;/p&gt;
&lt;p&gt;并行性：在同一时刻，有多条指令在多个处理器上同时执行。&lt;/p&gt;
&lt;h3&gt;多线程的优势：&lt;/h3&gt;
&lt;p&gt;线程在程序中是独立的、并发的执行流，与分隔的进程相比，进程中线程之间的隔离程度要小。他们共享内存、文件句柄和其他每个进程应有的状态。&lt;/p&gt;
&lt;blockquote readability=&quot;7.8244972577697&quot;&gt;
&lt;p&gt;文件句柄：在文件I/O中，要从一个文件读取数据，应用程序首先要调用操作&lt;a href=&quot;https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0&quot; target=&quot;_blank&quot;&gt;系统函数&lt;/a&gt;并传送文件名，并选一个到该文件的路径来打开文件。该函数取回一个顺序号，即文件句柄（file handle），该文件句柄对于打开的文件是唯一的识别依据。要从文件中读取一块数据，应用程序需要调用函数ReadFile，并将文件句柄在内存中的地址和要拷贝的字节数传送给操作系统。当完成任务后，再通过调用系统函数来关闭该文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多个线程共享内存，极大地提高了程序的运行效率。&lt;/p&gt;
&lt;p&gt;多线程和多进程：&lt;/p&gt;
&lt;p&gt;当操作系统创建一个进程时，必须为该进程分配独立的内存空间，并分配大量的相关资源；但创建一个线程则简单得多，因此使用多线程来实现并发比使用多进程实现并发的性能高得多。&lt;/p&gt;
&lt;p&gt;进程之间不能共享内存，但线程之间共享内存非常容易。&lt;/p&gt;
&lt;p&gt;系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程并发比多进程效率高。&lt;/p&gt;
&lt;p&gt;java语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了java的多线程编程。&lt;/p&gt;
&lt;p&gt;java虚拟机本身就在后台提供了一个超级进程来回收垃圾。&lt;/p&gt;

&lt;p&gt;java使用Thread类代表线程，所有线程对象必须是Thread类或其子类的实例。&lt;/p&gt;

&lt;h3&gt;继承Thread类来创建并启动多线程：&lt;/h3&gt;
&lt;p&gt;继承Thread类，重写该类的run()方法，run()方法代表线程需要完成的任务。&lt;/p&gt;
&lt;p&gt;创建Thread子类的实例，也就是线程对象。&lt;/p&gt;
&lt;p&gt;调用线程对象的start()方法来启动该线程。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jiangwenzhang.mybootbill.learn;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @包名 com.jiangwenzhang.mybootbill.learn
 * @创建人 蒋文章
 * @日期 2018/5/19 0019
 * @时间 8:57
 * @描述
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadClass &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i ;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写run方法，run方法的方法体就是线程执行体&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当线程类继承Thread类时，直接使用this即可获取当前线程
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread对象的getName()返回当前该线程的名字
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此可以直接调用getName()方法返回当前线程的名&lt;/span&gt;
            System.out.println(getName() +  &quot; &quot; +&lt;span&gt; i);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100;  i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Thread的currentThread方法获取当前线程,currentThread方法返回当前正在执行的线程对象&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+  &quot; &quot; +&lt;span&gt; i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建、并启动第一条线程&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadClass().start();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建、并启动第二条线程&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadClass().start();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201805/1176316-20180519094625184-935921856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见程序有三个线程，一个主线程和我们创建的两个子线程。&lt;/p&gt;
&lt;p&gt;主线程的线程执行体不是 run() 方法确定的，而是 main() 方法确定的， main() 方法的方法体代表主线程的方法体。&lt;/p&gt;
&lt;p&gt;使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。&lt;/p&gt;
&lt;h3&gt;实现Runnable接口创建线程类：&lt;/h3&gt;
&lt;p&gt;步骤：定义Runnable接口的实现类，并重写run方法。创建Runnable实现类的实例，以此实例作为Thread的target来创建Thread对象，该Thread对象时线程对象。调用线程对象的start()方法启动线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SecondThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i ;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run方法同样是线程执行体&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当线程类实现Runnable接口时，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果想获取当前线程，只能用Thread.currentThread()方法。&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;  &quot; +&lt;span&gt; i);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100;  i++&lt;span&gt;)
        {
            System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;  &quot; +&lt;span&gt; i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                SecondThread st &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SecondThread();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过new Thread(target , name)方法创建新线程&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt; Thread(st , &quot;新线程1&quot;&lt;span&gt;).start();
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(st , &quot;新线程2&quot;&lt;span&gt;).start();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;通过加成Thread类获得线程对象使用this关键字获取当前线程对象，实现Runnable接口获得当前线程对象，则需要使用Thread.currentThread()方法。&lt;/p&gt;
&lt;p&gt;Runnable接口中只包含一个抽象方法，从Java8开始，Runnable接口使用@FunctionalInterface 修饰，也就是说Runnable接口是函数式接口，可以使用Lambda表达式创建Runnable对象。&lt;/p&gt;
&lt;h3&gt;使用Callable和Future创建线程&lt;/h3&gt;
&lt;p&gt;从Java5开始，Java提供了Callable接口，该接口提供了一个call()方法作为线程执行体，但call()方法比run()方法更强大。call()方法可以有返回值，可以生命抛出异常。&lt;/p&gt;
&lt;p&gt;因此可以提供一个Callable对象作为Thread的target，线程执行体就是Callable对象的call()方法。但是Callable接口是Java5新增的接口，而且Callable不是Runnable的子接口，所以Callable对象不能直接作为Thread的targer。而且call方法还有一个返回值，call()&lt;/p&gt;
&lt;p&gt; 方法并不是直接调用，它是作为线程执行体被调用的。&lt;/p&gt;
&lt;p&gt;Java5提供了Future接口代表Callable接口里的call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该类实现了Future接口，并实现了Runnable接口，可以作为Thread的target。&lt;/p&gt;
&lt;p&gt;创建并启动有返回值的线程步骤：&lt;/p&gt;
&lt;p&gt;创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，且有返回值，在创建Callable实现类的实例。从Java8快开始可以直接使用Lambda表达式创建Callable对象。&lt;/p&gt;
&lt;p&gt;使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值。&lt;/p&gt;
&lt;p&gt;使用FutureTask对象作为Thread对象的target创建并启动新线程。&lt;/p&gt;
&lt;p&gt;调用FutureTask对象的get()方法获取子线程执行结束后的返回值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThirdThread
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Callable对象&lt;/span&gt;
        ThirdThread rt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThirdThread();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先使用Lambda表达式创建Callable&amp;lt;Integer&amp;gt;对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用FutureTask来包装Callable对象&lt;/span&gt;
        FutureTask&amp;lt;Integer&amp;gt; task = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;Integer&amp;gt;((Callable&amp;lt;Integer&amp;gt;)() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; 100 ; i++&lt;span&gt; )
            {
                System.out.println(Thread.currentThread().getName()
                        &lt;/span&gt;+ &quot; 的循环变量i的值：&quot; +&lt;span&gt; i);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; call()方法可以有返回值&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        });
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 100 ; i++&lt;span&gt;)
        {
            System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot; 的循环变量i的值：&quot; +&lt;span&gt; i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实质还是以Callable对象来创建、并启动线程&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt; Thread(task , &quot;有返回值的线程&quot;&lt;span&gt;).start();
            }
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程返回值&lt;/span&gt;
            System.out.println(&quot;子线程的返回值：&quot; +&lt;span&gt; task.get());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建线程对比：&lt;/p&gt;
&lt;p&gt;继承Thread：&lt;/p&gt;
&lt;p&gt;不能再继承其他类，编写简单，直接使用this可以获得当前线程。&lt;/p&gt;
&lt;p&gt;实现Runnable / Callable：&lt;/p&gt;
&lt;p&gt;还可以继承其它类，多个线程共享同一个target对象，适合多个线程处理同一个资源的情况，访问当前线程必须使用 Thread.currentThread()&lt;/p&gt;
&lt;h2&gt;线程的生命周期&lt;/h2&gt;
&lt;h3&gt;新建和就绪状态&lt;/h3&gt;
&lt;p&gt;new了一个线程后处于新建状态，和其他Java对象一样由JVM为其分配内存，并初始化成员变量的值。&lt;/p&gt;
&lt;p&gt;调用了start()方法后，处于就绪状态，JVM为其创建方法调用栈和程序计数器。线程还没开始运行，只是表示可以运行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InvokeRun &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i ;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写run方法，run方法的方法体就是线程执行体&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用run方法时，Thread的this.getName返回的是该对象名字，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而不是当前线程的名字。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Thread.currentThread().getName()总是获取当前线程名字&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName()
                &lt;/span&gt;+  &quot; &quot; + i);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
&lt;span&gt;        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100;  i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Thread的currentThread方法获取当前线程&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName()
                &lt;/span&gt;+  &quot; &quot; +&lt;span&gt; i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用线程对象的run方法，
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 系统会把线程对象当成普通对象，run方法当成普通方法，
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以下面两行代码并不会启动两条线程，而是依次执行两个run方法&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvokeRun().run();
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvokeRun().run();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面程序创建线程后直接调用了run方法，结果是以单线程运行该程序，另外不能直接通过getName()方法获得当前执行线程的名字。&lt;/p&gt;
&lt;p&gt;调用了run方法后，线程不在处于新建状态。&lt;/p&gt;
&lt;h3&gt;运行和阻塞&lt;/h3&gt;
&lt;p&gt;就绪状态的线程获得了CPU，开始执行run方法的线程执行体，线程处于运行状态。如果只有一个CPU那只能有一个线程处于运行状态，多核CPU将会有多个线程并行。&lt;/p&gt;
&lt;p&gt;阻塞状态：电泳sleep()方法主动放弃处理器资源，或者调用了一个阻塞式IO方法，方法返回之前，线程被阻塞，或者线程试图获取一个同步监视器，但该同步监视器正被其它线程所持有，或者线程等待某个通知(notify)，或者程序调用了线程的suspeng()方法将线程挂起。&lt;/p&gt;
&lt;p&gt;当前正在执行的线程被阻塞之后，其它线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，需要重新等待线程调度器再度激活他。&lt;/p&gt;
&lt;p&gt;解除阻塞，重新就绪的情况：&lt;/p&gt;
&lt;p&gt;调用sleep()方法的线程经过了指定时间。&lt;/p&gt;
&lt;p&gt;线程调用的阻塞式IO方法已经返回。&lt;/p&gt;
&lt;p&gt;线程成功获得了试图取得的同步监视器。&lt;/p&gt;
&lt;p&gt;线程正在等待通知，其他线程发来了一个通知。&lt;/p&gt;
&lt;p&gt;处于挂起状态的线程被调用了resume()方法。&lt;/p&gt;
&lt;p&gt;线程在阻塞状态只能进入就绪状态，无法直接进入运行状态。就绪状态和运行状态转换通常不受程序控制，但是调用yield()方法可以让运行状态的线程转入就绪状态。&lt;/p&gt;
&lt;h3&gt;线程死亡：&lt;/h3&gt;
&lt;p&gt;线程结束的三种方式：&lt;/p&gt;
&lt;p&gt;run() / call() 执行完成。&lt;/p&gt;
&lt;p&gt;线程抛出一个未捕获的异常。&lt;/p&gt;
&lt;p&gt;直接调用该线程的stop()方法结束线程。&lt;/p&gt;
&lt;p&gt;当主线程结束，其他线程不受影响，并不会随之结束，一旦子线程启动就拥有和主线程相同的地位，不会受主线程影响。&lt;/p&gt;
&lt;p&gt;使用isAlive()方法测试线程是否已经死亡：线程处于就绪、运行、阻塞方法返回true，新建、死亡状态方法返回false。&lt;/p&gt;
&lt;p&gt;已死亡的线程不能使用start()方法使他重新启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StartDead &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i ;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写run方法，run方法的方法体就是线程执行体&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            System.out.println(getName() &lt;/span&gt;+  &quot; &quot; +&lt;span&gt; i);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程对象&lt;/span&gt;
        StartDead sd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StartDead();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 300;  i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Thread的currentThread方法获取当前线程&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName()
                &lt;/span&gt;+  &quot; &quot; +&lt;span&gt; i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;                sd.start();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断启动后线程的isAlive()值，输出true&lt;/span&gt;
&lt;span&gt;                System.out.println(sd.isAlive());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有当线程处于新建、死亡两种状态时isAlive()方法返回false。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当i &amp;gt; 20，则该线程肯定已经启动过了，如果sd.isAlive()为假时，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那只能是死亡状态了。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i &amp;gt; 20 &amp;amp;&amp;amp; !&lt;span&gt;sd.isAlive())

            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 试图再次启动该线程&lt;/span&gt;
&lt;span&gt;                sd.start();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180720145239856-1639406182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;控制线程&lt;/h2&gt;
&lt;h3&gt;join线程 &lt;/h3&gt;
&lt;p&gt;join()方法：让一个线程等待另一个线程完成的方法，某个线程执行六中调用其他线程的join方法时，调用线程将被阻塞，知道被join方法加入的join线程执行完。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JoinThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供一个有参数的构造器，用于设置该线程的名字&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JoinThread(String name)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写run()方法，定义线程执行体&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            System.out.println(getName() &lt;/span&gt;+ &quot;  &quot; +&lt;span&gt; i);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动子线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; JoinThread(&quot;新线程&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                JoinThread jt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JoinThread(&quot;被Join的线程&quot;&lt;span&gt;);
                jt.start();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; main线程调用了jt线程的join()方法，main线程
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须等jt执行结束才会向下执行&lt;/span&gt;
&lt;span&gt;                jt.join();
            }
            System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;  &quot; +&lt;span&gt; i);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721144509977-2038096040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;后台线程（守护线程、精灵线程）：&lt;/h3&gt;
&lt;p&gt;在后台运行的，他的任务是为其它的线程提供服务，这种线程被称为后台线程。JVM垃圾回收线程就是典型的后台线程。&lt;/p&gt;
&lt;p&gt;特征：如果所有前台线程都死亡，后台线程会自动死亡。&lt;/p&gt;
&lt;p&gt;调用Thread的setDeamon(true)方法将指定线程设置为后台线程‘’&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DaemonThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义后台线程的线程执行体与普通线程没有任何区别&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 1000 ; i++&lt;span&gt; )
        {
            System.out.println(getName() &lt;/span&gt;+ &quot;  &quot; +&lt;span&gt; i);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        DaemonThread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DaemonThread();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将此线程设置成后台线程&lt;/span&gt;
        t.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动后台线程&lt;/span&gt;
&lt;span&gt;        t.start();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 10 ; i++&lt;span&gt; )
        {
            System.out.println(Thread.currentThread().getName()
                &lt;/span&gt;+ &quot;  &quot; +&lt;span&gt; i);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----程序执行到此处，前台线程（main线程）结束------
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后台线程也应该随之结束&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721150232431-560393000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本来该线程应该运行到999，但是主线程也就是唯一的前台线程运行结束后，JVM自动退出，所以后台线程也结束。&lt;/p&gt;
&lt;h3&gt;线程休眠&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10 ; i++&lt;span&gt; )
        {
            System.out.println(&lt;/span&gt;&quot;当前时间: &quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用sleep方法让当前线程暂停1s。&lt;/span&gt;
            Thread.sleep(1000&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721150718836-1960622596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上程序中只有一个主线程。&lt;/p&gt;
&lt;p&gt;Thread还提供了一个yield()方法，让当前正在执行的线程暂停进入就绪状态但不阻塞，yield()方法调用之后，只有优先级不低于当前线程的线程才会获得执行机会。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;sleep()暂停后给他线程机会，不理会优先级，yield()只给优先级相同或更高的线程机会。&lt;/p&gt;
&lt;p&gt;sleep()方法是县城进入阻塞状态，经过阻塞时间进入就绪状态，yield()方法强制进入就绪状态。&lt;/p&gt;
&lt;p&gt;sleep()方法抛出异常。&lt;/p&gt;
&lt;p&gt;sleep()方法有更好的移植性，通常不建议使用yield()。&lt;/p&gt;
&lt;h3&gt;改变线程优先级&lt;/h3&gt;
&lt;p&gt;每个线程执行时都有一定的优先级，优先级高的线程会获得较多的执行机会。每个线程的默认优先级和创建他的父线程相同。默认主线程具有普通优先级。设置优先级为整数，1-10。但是不同系统的优先级并不相同，应尽量使用静态常量设置优先级。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PriorityTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个有参数的构造器，用于创建线程时指定name&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PriorityTest(String name)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 50 ; i++&lt;span&gt; )
        {
            System.out.println(getName() &lt;/span&gt;+  &quot;,其优先级是：&quot;
                + getPriority() + &quot;,循环变量的值为:&quot; +&lt;span&gt; i);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变主线程的优先级&lt;/span&gt;
        Thread.currentThread().setPriority(6&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 30 ; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 10&lt;span&gt;)
            {
                PriorityTest low  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PriorityTest(&quot;低级&quot;&lt;span&gt;);
                low.start();
                System.out.println(&lt;/span&gt;&quot;创建之初的优先级:&quot;
                    +&lt;span&gt; low.getPriority());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置该线程为最低优先级&lt;/span&gt;
&lt;span&gt;                low.setPriority(Thread.MIN_PRIORITY);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 20&lt;span&gt;)
            {
                PriorityTest high &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PriorityTest(&quot;高级&quot;&lt;span&gt;);
                high.start();
                System.out.println(&lt;/span&gt;&quot;创建之初的优先级:&quot;
                    +&lt;span&gt; high.getPriority());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置该线程为最高优先级&lt;/span&gt;
&lt;span&gt;                high.setPriority(Thread.MAX_PRIORITY);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;线程同步&lt;/h2&gt;
&lt;h3&gt;线程安全&lt;/h3&gt;
&lt;p&gt;典型问题：&lt;/p&gt;
&lt;p&gt;账户类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装账户编号、账户余额的两个成员变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Account(String accountNo , &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处省略了accountNo和balance的setter和getter方法

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accountNo的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountNo(String accountNo)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAccountNo()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accountNo;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; balance的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBalance(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面两个方法根据accountNo来重写hashCode()和equals()方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountNo.hashCode();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj !=&lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; obj.getClass() == Account.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        {
            Account target &lt;/span&gt;=&lt;span&gt; (Account)obj;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.getAccountNo().equals(accountNo);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取钱线程类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrawThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟用户账户&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前取钱线程所希望取的钱数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DrawThread(String name , Account account
        , &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; account;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.drawAmount =&lt;span&gt; drawAmount;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当多条线程修改同一个共享数据时，将涉及数据安全问题。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户余额大于取钱数目&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (account.getBalance() &amp;gt;=&lt;span&gt; drawAmount)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 吐出钞票&lt;/span&gt;
&lt;span&gt;            System.out.println(getName()
                &lt;/span&gt;+ &quot;取钱成功！吐出钞票:&quot; +&lt;span&gt; drawAmount);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
            {
                ex.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改余额&lt;/span&gt;
            account.setBalance(account.getBalance() -&lt;span&gt; drawAmount);
            System.out.println(&lt;/span&gt;&quot;\t余额为: &quot; +&lt;span&gt; account.getBalance());
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            System.out.println(getName() &lt;/span&gt;+ &quot;取钱失败！余额不足！&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DrawTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个账户&lt;/span&gt;
        Account acct = &lt;span&gt;new&lt;/span&gt; Account(&quot;1234567&quot; , 1000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟两个线程对同一个账户取钱&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; DrawThread(&quot;甲&quot; , acct , 800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DrawThread(&quot;乙&quot; , acct , 800&lt;span&gt;).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721161206276-675212290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注释线程休眠的运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721161414287-564517339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现这种错误是因为线程调度的不确定性。&lt;/p&gt;
&lt;p&gt;同步代码块：&lt;/p&gt;
&lt;p&gt;用账户类作为同步监视器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrawThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟用户账户&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前取钱线程所希望取的钱数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DrawThread(String name , Account account
            , &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; account;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.drawAmount =&lt;span&gt; drawAmount;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当多条线程修改同一个共享数据时，将涉及数据安全问题。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用account作为同步监视器，任何线程进入下面同步代码块之前，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须先获得对account账户的锁定——其他线程无法获得锁，也就无法修改它
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这种做法符合：“加锁 → 修改 → 释放锁”的逻辑&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (account)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户余额大于取钱数目&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (account.getBalance() &amp;gt;=&lt;span&gt; drawAmount)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 吐出钞票&lt;/span&gt;
&lt;span&gt;                System.out.println(getName()
                        &lt;/span&gt;+ &quot;取钱成功！吐出钞票:&quot; +&lt;span&gt; drawAmount);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
                {
                    ex.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改余额&lt;/span&gt;
                account.setBalance(account.getBalance() -&lt;span&gt; drawAmount);
                System.out.println(&lt;/span&gt;&quot;\t余额为: &quot; +&lt;span&gt; account.getBalance());
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                System.out.println(getName() &lt;/span&gt;+ &quot;取钱失败！余额不足！&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步代码块结束，该线程释放同步锁&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721161723858-1244138208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步方法：&lt;/p&gt;
&lt;p&gt;synchronize修饰的实例方法，就是同步方法，不用指定同步监视器，同步方法的同步监视器就是this。&lt;/p&gt;
&lt;p&gt;通过使用同步方法可以方便的实现线程安全的类。该类的对象可以被多个线程安全地访问，每个线程调用对象的任意方法都将得到正确的结果，每个线程调用该对象的任一方法之后该对象状态依然保持合理状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装账户编号、账户余额两个成员变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Account(String accountNo , &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accountNo的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountNo(String accountNo)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAccountNo()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accountNo;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此账户余额不允许随便修改，所以只为balance提供getter方法，&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供一个线程安全draw()方法来完成取钱操作&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户余额大于取钱数目&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (balance &amp;gt;=&lt;span&gt; drawAmount)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 吐出钞票&lt;/span&gt;
&lt;span&gt;            System.out.println(Thread.currentThread().getName()
                &lt;/span&gt;+ &quot;取钱成功！吐出钞票:&quot; +&lt;span&gt; drawAmount);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
            {
                ex.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改余额&lt;/span&gt;
            balance -=&lt;span&gt; drawAmount;
            System.out.println(&lt;/span&gt;&quot;\t余额为: &quot; +&lt;span&gt; balance);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            System.out.println(Thread.currentThread().getName()
                &lt;/span&gt;+ &quot;取钱失败！余额不足！&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面两个方法根据accountNo来重写hashCode()和equals()方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountNo.hashCode();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj !=&lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; obj.getClass() == Account.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        {
            Account target &lt;/span&gt;=&lt;span&gt; (Account)obj;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.getAccountNo().equals(accountNo);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上增加了取钱的方法，去掉了设置金额的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrawThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟用户账户&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前取钱线程所希望取的钱数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DrawThread(String name , Account account
        , &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; account;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.drawAmount =&lt;span&gt; drawAmount;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当多条线程修改同一个共享数据时，将涉及数据安全问题。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接调用account对象的draw方法来执行取钱
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步方法的同步监视器是this，this代表调用draw()方法的对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说：线程进入draw()方法之前，必须先对account对象的加锁。&lt;/span&gt;
&lt;span&gt;        account.draw(drawAmount);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实体类中设置取钱方法，而不是在run方法中实现逻辑，这样更符合面向对象思想。&lt;/p&gt;
&lt;p&gt;注意：不要线程安全类所有方法都进行同步，如果可变类有多线程和单线程两种运行环境，则应为该可变类提供两种版本。&lt;/p&gt;
&lt;p&gt;释放同步监视器的锁定&lt;/p&gt;
&lt;p&gt;线程进入同步代码块同步方法之前，必须先获得对同步监视器的锁定，会在以下几种情况释放对同步监视器的锁定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721164100027-2058168573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步锁&lt;/p&gt;
&lt;p&gt;通过显示定义同步锁对象来实现同步，同步锁Lock对象。&lt;/p&gt;
&lt;p&gt;Lock提供了比同步代码块和同步方法更广泛的锁定操作，Lock允许实现灵活的结构，可以具有差别很大的属性，并支持多个相关的Condition对象&lt;/p&gt;
&lt;p&gt;Lock是控制多个线程对共享资源进行访问的工具。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义锁对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装账户编号、账户余额的两个成员变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Account(String accountNo , &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accountNo的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountNo(String accountNo)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAccountNo()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accountNo;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此账户余额不允许随便修改，所以只为balance提供getter方法，&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供一个线程安全draw()方法来完成取钱操作&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加锁&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 账户余额大于取钱数目&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (balance &amp;gt;=&lt;span&gt; drawAmount)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 吐出钞票&lt;/span&gt;
&lt;span&gt;                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;取钱成功！吐出钞票:&quot; +&lt;span&gt; drawAmount);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    Thread.sleep(&lt;/span&gt;1&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
                {
                    ex.printStackTrace();
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改余额&lt;/span&gt;
                balance -=&lt;span&gt; drawAmount;
                System.out.println(&lt;/span&gt;&quot;\t余额为: &quot; +&lt;span&gt; balance);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;取钱失败！余额不足！&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改完成，释放锁&lt;/span&gt;
&lt;span&gt;            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面两个方法根据accountNo来重写hashCode()和equals()方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountNo.hashCode();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj !=&lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; obj.getClass() == Account.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        {
            Account target &lt;/span&gt;=&lt;span&gt; (Account)obj;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.getAccountNo().equals(accountNo);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Lock对象时每个Lock对象对应一个Account对象，一样可以保证对于同一个Account对象，同时只能有一个线程能进入临界区。&lt;/p&gt;
&lt;p&gt;ReentrantLock 具有可重入性，一个线程对已被加锁的ReentrantLock锁可以再次加锁，ReentrantLock对象会维持一个计数器追踪lock()方法的嵌套调用，线程在每次调用lock()后，必须显示的调用unlock()方法释放锁，所以一段被锁保护的代码可以嗲用另一个被相同锁保护的方法。&lt;/p&gt;
&lt;p&gt;死锁&lt;/p&gt;
&lt;p&gt;两个线程相互等待对方释放同步监视器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; foo( B b )
    {
        System.out.println(&lt;/span&gt;&quot;当前线程名: &quot; +&lt;span&gt; Thread.currentThread().getName()
            &lt;/span&gt;+ &quot; 进入了A实例的foo()方法&quot; );     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
        {
            ex.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;当前线程名: &quot; +&lt;span&gt; Thread.currentThread().getName()
            &lt;/span&gt;+ &quot; 企图调用B实例的last()方法&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ③&lt;/span&gt;
&lt;span&gt;        b.last();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; last()
    {
        System.out.println(&lt;/span&gt;&quot;进入了A类的last()方法内部&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bar( A a )
    {
        System.out.println(&lt;/span&gt;&quot;当前线程名: &quot; +&lt;span&gt; Thread.currentThread().getName()
            &lt;/span&gt;+ &quot; 进入了B实例的bar()方法&quot; );   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ②&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
        {
            ex.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;当前线程名: &quot; +&lt;span&gt; Thread.currentThread().getName()
            &lt;/span&gt;+ &quot; 企图调用A实例的last()方法&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ④&lt;/span&gt;
&lt;span&gt;        a.last();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; last()
    {
        System.out.println(&lt;/span&gt;&quot;进入了B类的last()方法内部&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DeadLock &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable
{
    A a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; A();
    B b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init()
    {
        Thread.currentThread().setName(&lt;/span&gt;&quot;主线程&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用a对象的foo方法&lt;/span&gt;
&lt;span&gt;        a.foo(b);
        System.out.println(&lt;/span&gt;&quot;进入了主线程之后&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        Thread.currentThread().setName(&lt;/span&gt;&quot;副线程&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用b对象的bar方法&lt;/span&gt;
&lt;span&gt;        b.bar(a);
        System.out.println(&lt;/span&gt;&quot;进入了副线程之后&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        DeadLock dl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeadLock();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以dl为target启动新线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(dl).start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用init()方法&lt;/span&gt;
&lt;span&gt;        dl.init();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721170429280-1230080252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;线程通信&lt;/h2&gt;
&lt;h3&gt;传统的线程通信&lt;/h3&gt;
&lt;p&gt;假设现在不同地点的存钱者和取钱者，需要不断地交替存取，不允许连续存两次或取两次，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装账户编号、账户余额的两个成员变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识账户中是否已有存款的旗标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Account(String accountNo , &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accountNo的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountNo(String accountNo)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAccountNo()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accountNo;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此账户余额不允许随便修改，所以只为balance提供getter方法，&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.balance;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag)
            {
                wait();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行取钱&lt;/span&gt;
&lt;span&gt;                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot; 取钱:&quot; +&lt;span&gt;  drawAmount);
                balance &lt;/span&gt;-=&lt;span&gt; drawAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot; +&lt;span&gt; balance);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将标识账户是否已有存款的旗标设为false。&lt;/span&gt;
                flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒其他线程&lt;/span&gt;
&lt;span&gt;                notifyAll();
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
        {
            ex.printStackTrace();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deposit(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (flag)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;①&lt;/span&gt;
&lt;span&gt;            {
                wait();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行存款&lt;/span&gt;
&lt;span&gt;                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot; 存款:&quot; +&lt;span&gt;  depositAmount);
                balance &lt;/span&gt;+=&lt;span&gt; depositAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot; +&lt;span&gt; balance);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将表示账户是否已有存款的旗标设为true&lt;/span&gt;
                flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒其他线程&lt;/span&gt;
&lt;span&gt;                notifyAll();
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
        {
            ex.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面两个方法根据accountNo来重写hashCode()和equals()方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountNo.hashCode();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj !=&lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; obj.getClass() == Account.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        {
            Account target &lt;/span&gt;=&lt;span&gt; (Account)obj;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.getAccountNo().equals(accountNo);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DrawThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟用户账户&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前取钱线程所希望取的钱数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DrawThread(String name , Account account
        , &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; account;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.drawAmount =&lt;span&gt; drawAmount;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复100次执行取钱操作&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            account.draw(drawAmount);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DepositThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟用户账户&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前取钱线程所希望存款的钱数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DepositThread(String name , Account account
        , &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; account;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.depositAmount =&lt;span&gt; depositAmount;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重复100次执行存款操作&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 100 ; i++&lt;span&gt; )
        {
            account.deposit(depositAmount);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DrawTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个账户&lt;/span&gt;
        Account acct = &lt;span&gt;new&lt;/span&gt; Account(&quot;1234567&quot; , 0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DrawThread(&quot;取钱者&quot; , acct , 800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DepositThread(&quot;存款者甲&quot; , acct , 800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DepositThread(&quot;存款者乙&quot; , acct , 800&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DepositThread(&quot;存款者丙&quot; , acct , 800&lt;span&gt;).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使用Condition控制线程通信&lt;/h3&gt;
&lt;p&gt;如果程序直接使用Lock对象保证线程同步，则系统不存在隐式的同步监视器，也就不能用wait()等方法进行线程通信。&lt;/p&gt;
&lt;p&gt;当使用Lock对象保证同步时，Java提供了一个Contidion类来协调，使用Contidion可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象。Contidion也可以唤醒其他处于等待的线程。&lt;/p&gt;
&lt;p&gt;Contidion将同步监视器方法(wait等)分解成截然不同的对象，以便通过这些对象与Lock对象组合使用，为每个对象提供多个等待集。&lt;/p&gt;
&lt;p&gt;Contidion实例被绑定在一个Lock对象上，要获得特定的Lock实例的Contidion实例，调用Lock对象的newContidion()方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显式定义Lock对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得指定Lock对象对应的Condition&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition cond  =&lt;span&gt; lock.newCondition();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装账户编号、账户余额的两个成员变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String accountNo;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识账户中是否已有存款的旗标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Account(String accountNo , &lt;span&gt;double&lt;/span&gt;&lt;span&gt; balance)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.balance =&lt;span&gt; balance;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accountNo的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountNo(String accountNo)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountNo =&lt;span&gt; accountNo;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAccountNo()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.accountNo;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此账户余额不允许随便修改，所以只为balance提供getter方法，&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getBalance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.balance;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; draw(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; drawAmount)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加锁&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag)
            {
                cond.await();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行取钱&lt;/span&gt;
&lt;span&gt;                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot; 取钱:&quot; +&lt;span&gt;  drawAmount);
                balance &lt;/span&gt;-=&lt;span&gt; drawAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot; +&lt;span&gt; balance);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将标识账户是否已有存款的旗标设为false。&lt;/span&gt;
                flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒其他线程&lt;/span&gt;
&lt;span&gt;                cond.signalAll();
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
        {
            ex.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用finally块来释放锁&lt;/span&gt;
        &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            lock.unlock();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deposit(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; depositAmount)
    {
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (flag)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
&lt;span&gt;            {
                cond.await();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行存款&lt;/span&gt;
&lt;span&gt;                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot; 存款:&quot; +&lt;span&gt;  depositAmount);
                balance &lt;/span&gt;+=&lt;span&gt; depositAmount;
                System.out.println(&lt;/span&gt;&quot;账户余额为：&quot; +&lt;span&gt; balance);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将表示账户是否已有存款的旗标设为true&lt;/span&gt;
                flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒其他线程&lt;/span&gt;
&lt;span&gt;                cond.signalAll();
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex)
        {
            ex.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用finally块来释放锁&lt;/span&gt;
        &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
        {
            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面两个方法根据accountNo来重写hashCode()和equals()方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountNo.hashCode();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj !=&lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; obj.getClass() == Account.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        {
            Account target &lt;/span&gt;=&lt;span&gt; (Account)obj;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.getAccountNo().equals(accountNo);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使用阻塞队列控制线程通信&lt;/h3&gt;
&lt;p&gt;Java5提供了BlockingQueue接口，主要用途是作为线程同步的工具。特征：当生产者线程像BlockingQueue中放入元素时，如果队列已满线程被阻塞，当消费者试图从BlockingQueue取出元素，如果队列空线程被阻塞。&lt;/p&gt;
&lt;p&gt;BlockingQueue还有基于数组、链表等的实现类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlockingQueueTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个长度为2的阻塞队列&lt;/span&gt;
        BlockingQueue&amp;lt;String&amp;gt; bq = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(2&lt;span&gt;);
        bq.put(&lt;/span&gt;&quot;Java&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与bq.add(&quot;Java&quot;、bq.offer(&quot;Java&quot;)相同&lt;/span&gt;
        bq.put(&quot;Java&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与bq.add(&quot;Java&quot;、bq.offer(&quot;Java&quot;)相同&lt;/span&gt;
        bq.put(&quot;Java&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ① 阻塞线程。&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序会一直阻塞。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Producer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Producer(BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bq =&lt;span&gt; bq;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        String[] strArr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]
        {
            &lt;/span&gt;&quot;Java&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Struts&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Spring&quot;&lt;span&gt;
        };
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 999999999 ; i++&lt;span&gt; )
        {
            System.out.println(getName() &lt;/span&gt;+ &quot;生产者准备生产集合元素！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试放入元素，如果队列已满，线程被阻塞&lt;/span&gt;
                bq.put(strArr[i % 3&lt;span&gt;]);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){ex.printStackTrace();}
            System.out.println(getName() &lt;/span&gt;+ &quot;生产完成：&quot; +&lt;span&gt; bq);
        }
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Consumer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Consumer(BlockingQueue&amp;lt;String&amp;gt;&lt;span&gt; bq)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bq =&lt;span&gt; bq;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            System.out.println(getName() &lt;/span&gt;+ &quot;消费者准备消费集合元素！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试取出元素，如果队列已空，线程被阻塞&lt;/span&gt;
&lt;span&gt;                bq.take();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){ex.printStackTrace();}
            System.out.println(getName() &lt;/span&gt;+ &quot;消费完成：&quot; +&lt;span&gt; bq);
        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BlockingQueueTest2
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个容量为1的BlockingQueue&lt;/span&gt;
        BlockingQueue&amp;lt;String&amp;gt; bq = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动3条生产者线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(bq).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(bq).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producer(bq).start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动一条消费者线程&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(bq).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;线程组和未处理异常&lt;/h2&gt;
&lt;p&gt;ThreadGroup代表线程组，Java允许程序直接对线程组进行控制，对线程组的控制相当于同时控制这批线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供指定线程名的构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyThread(String name)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供指定线程名、线程组的构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyThread(ThreadGroup group , String name)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(group, name);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 20 ; i++&lt;span&gt; )
        {
            System.out.println(getName() &lt;/span&gt;+ &quot; 线程的i变量&quot; +&lt;span&gt; i);
        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadGroupTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取主线程所在的线程组，这是所有线程默认的线程组&lt;/span&gt;
        ThreadGroup mainGroup =&lt;span&gt; Thread.currentThread().getThreadGroup();
        System.out.println(&lt;/span&gt;&quot;主线程组的名字：&quot;
            +&lt;span&gt; mainGroup.getName());
        System.out.println(&lt;/span&gt;&quot;主线程组是否是后台线程组：&quot;
            +&lt;span&gt; mainGroup.isDaemon());
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MyThread(&quot;主线程组的线程&quot;&lt;span&gt;).start();
        ThreadGroup tg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ThreadGroup(&quot;新线程组&quot;&lt;span&gt;);
        tg.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;tg线程组是否是后台线程组：&quot;
            +&lt;span&gt; tg.isDaemon());
        MyThread tt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MyThread(tg , &quot;tg组的线程甲&quot;&lt;span&gt;);
        tt.start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MyThread(tg , &quot;tg组的线程乙&quot;&lt;span&gt;).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721210206867-1516658094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为主线程设置异常处理器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MyExHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Thread.UncaughtExceptionHandler
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现uncaughtException方法，该方法将处理线程的未处理异常&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; uncaughtException(Thread t, Throwable e)
    {
        System.out.println(t &lt;/span&gt;+ &quot; 线程出现了异常：&quot; +&lt;span&gt; e);
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExHandler
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置主线程的异常处理器&lt;/span&gt;
&lt;span&gt;        Thread.currentThread().setUncaughtExceptionHandler
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyExHandler());
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = 5 / 0;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
        System.out.println(&quot;程序正常结束！&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721210329736-212463665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;线程池&lt;/h2&gt;
&lt;p&gt; 系统启动一个线程的成本是比较高的，当程序中需要创建大量生存期限很短的线程时，更应该考虑使用线程池。&lt;/p&gt;
&lt;h3&gt;Java8改进的线程池&lt;/h3&gt;
&lt;p&gt;Java5增加的Executors工厂类来产生线程池，该工厂类提供一下几个静态工厂方法创建线程池&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721210756844-77423258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用完一个线程池后，应该调用该线程池的shutdown()方法，该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不再接受新任务，但会将以前所有已提交的任务执行完成。&lt;/p&gt;
&lt;p&gt;也可以调用shutdownNow()方法关闭线程池，该方法会试图停止所有正在执行的活动任务，，暂停处理正在等待的任务，并返回等待执行的任务列表。&lt;/p&gt;
&lt;p&gt;使用线程池执行线程步骤：&lt;/p&gt;
&lt;p&gt;调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。&lt;/p&gt;
&lt;p&gt;创建Runnable实现类或Callable实现类的实例，作为线程执行任务。&lt;/p&gt;
&lt;p&gt;调用ExecutorService对象的submit()方法来提交Run那边了实例或Callable实例。&lt;/p&gt;
&lt;p&gt;当不想提交任务时，调用ExecutorService对象得shutdown()方法来关闭线程池。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建足够的线程来支持4个CPU并行的线程池
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个具有固定线程数（6）的线程池&lt;/span&gt;
        ExecutorService pool = Executors.newFixedThreadPool(6&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用Lambda表达式创建Runnable对象&lt;/span&gt;
        Runnable target = () -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100 ; i++&lt;span&gt; )
            {
                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;的i值为:&quot; +&lt;span&gt; i);
            }
        };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向线程池中提交两个线程&lt;/span&gt;
&lt;span&gt;        pool.submit(target);
        pool.submit(target);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭线程池&lt;/span&gt;
&lt;span&gt;        pool.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Java8增强的ForkJoinPool&lt;/h3&gt;
&lt;p&gt;Java7提供了ForkJoinPool将一个任务拆分成多个小任务并行计算，再把多个小任务的结果合并成总的计算结果。。ForkJoinPool是ExecutorService的实现类，是一种特殊的线程池。&lt;/p&gt;
&lt;p&gt;Java8拓展了ForkJoinPool的功能，增加了通用池的功能。ForkJoinPool是一个抽象类，有两个抽象子类：RecursiveAction和RecursiveTask&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承RecursiveAction来实现&quot;可分解&quot;的任务&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; PrintTask &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RecursiveAction
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个“小任务”只最多只打印50个数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THRESHOLD = 50&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; start;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印从start到end的任务&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; PrintTask(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.start =&lt;span&gt; start;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.end =&lt;span&gt; end;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; compute()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当end与start之间的差小于THRESHOLD时，开始打印&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(end - start &amp;lt;&lt;span&gt; THRESHOLD)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start ; i &amp;lt; end ; i++&lt;span&gt; )
            {
                System.out.println(Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;的i值：&quot; +&lt;span&gt; i);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将大任务分解成两个小任务。&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; middle = (start + end) / 2&lt;span&gt;;
            PrintTask left &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintTask(start, middle);
            PrintTask right &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintTask(middle, end);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并行执行两个“小任务”&lt;/span&gt;
&lt;span&gt;            left.fork();
            right.fork();
        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ForkJoinPoolTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        ForkJoinPool pool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForkJoinPool();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交可分解的PrintTask任务&lt;/span&gt;
        pool.submit(&lt;span&gt;new&lt;/span&gt; PrintTask(0 , 300&lt;span&gt;));
        pool.awaitTermination(&lt;/span&gt;2&lt;span&gt;, TimeUnit.SECONDS);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭线程池&lt;/span&gt;
&lt;span&gt;        pool.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721213031165-8877417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用RecursiveTask对一个长度为100的数组的元素值进行累加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承RecursiveTask来实现&quot;可分解&quot;的任务&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; CalTask &lt;span&gt;extends&lt;/span&gt; RecursiveTask&amp;lt;Integer&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个“小任务”只最多只累加20个数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THRESHOLD = 20&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arr[];
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; start;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 累加从start到end的数组元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; CalTask(&lt;span&gt;int&lt;/span&gt;[] arr , &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.arr =&lt;span&gt; arr;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.start =&lt;span&gt; start;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.end =&lt;span&gt; end;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Integer compute()
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当end与start之间的差小于THRESHOLD时，开始进行实际累加&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(end - start &amp;lt;&lt;span&gt; THRESHOLD)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start ; i &amp;lt; end ; i++&lt;span&gt; )
            {
                sum &lt;/span&gt;+=&lt;span&gt; arr[i];
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当end与start之间的差大于THRESHOLD时，即要累加的数超过20个时
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将大任务分解成两个小任务。&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; middle = (start + end) / 2&lt;span&gt;;
            CalTask left &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalTask(arr , start, middle);
            CalTask right &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalTask(arr , middle, end);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并行执行两个“小任务”&lt;/span&gt;
&lt;span&gt;            left.fork();
            right.fork();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把两个“小任务”累加的结果合并起来&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; left.join() + right.join();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ①&lt;/span&gt;
&lt;span&gt;        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sum
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[100&lt;span&gt;];
        Random rand &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化100个数字元素&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 , len = arr.length; i &amp;lt; len ; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp = rand.nextInt(20&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对数组元素赋值，并将数组元素的值添加到sum总和中。&lt;/span&gt;
            total += (arr[i] =&lt;span&gt; tmp);
        }
        System.out.println(total);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个通用池&lt;/span&gt;
        ForkJoinPool pool =&lt;span&gt; ForkJoinPool.commonPool();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交可分解的CalTask任务&lt;/span&gt;
        Future&amp;lt;Integer&amp;gt; future = pool.submit(&lt;span&gt;new&lt;/span&gt; CalTask(arr , 0&lt;span&gt; , arr.length));
        System.out.println(future.get());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭线程池&lt;/span&gt;
&lt;span&gt;        pool.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1176316/201807/1176316-20180721213541571-2095547468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;线程相关的类&lt;/h2&gt;
&lt;h3&gt;ThreadLocal&lt;/h3&gt;
&lt;p&gt;线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立的改变自己的副本，而不会和其他线程副本产生冲突。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定义一个ThreadLocal类型的变量，该变量将是一个线程局部变量
    每个线程都会保留该变量的一个副本 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; name = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个初始化name成员变量的构造器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Account(String str)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.set(str);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面代码用于访问当前线程的name副本的值&lt;/span&gt;
        System.out.println(&quot;---&quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.get());
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name的setter和getter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name.get();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String str)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.set(str);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个Account类型的成员变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Account account;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyTest(Account account, String name)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.account =&lt;span&gt; account;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环10次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 10 ; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当i == 6时输出将账户名替换成当前线程名&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (i == 6&lt;span&gt;)
            {
                account.setName(getName());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出同一个账户的账户名和循环变量&lt;/span&gt;
&lt;span&gt;            System.out.println(account.getName()
                &lt;/span&gt;+ &quot; 账户的i值：&quot; +&lt;span&gt; i);
        }
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动两条线程，两条线程共享同一个Account&lt;/span&gt;
        Account at = &lt;span&gt;new&lt;/span&gt; Account(&quot;初始名&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        虽然两条线程共享同一个账户，即只有一个账户名
        但由于账户名是ThreadLocal类型的，所以每条线程
        都完全拥有各自的账户名副本，所以从i == 6之后，将看到两条
        线程访问同一个账户时看到不同的账户名。
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; MyTest(at , &quot;线程甲&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MyTest(at , &quot;线程乙&quot;&lt;span&gt;).start ();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;线程安全的集合类&lt;/h3&gt;
&lt;p&gt;线程安全的集合类可以分为：&lt;/p&gt;
&lt;p&gt;以Concurrent开头的集合类，，CopyOnWrite开头的集合类&lt;/p&gt;
&lt;p&gt;Concurrent开头的集合类代表了支持并发访问的集合支持多个线程并发写入访问，写入操作都是线程安全的，但读取操作却不锁定。&lt;/p&gt;
&lt;p&gt;当多个线程访问一个公共集合，可以使用ConcurrentLinkedQueue。ConcurrentLinkedQueue不允许null。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap最多支持16个线程并发写入，多余时需要等待。&lt;/p&gt;
&lt;p&gt;CopyOnWriteArraySet底层封装了CopyOnWriteArrayList，因此实现机制完全类似。CopyOnWriteArrayList采用复制底层数组的方式实现写操作。&lt;/p&gt;
&lt;h3&gt;Java9新增的发布-订阅框架&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PubSubTest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个SubmissionPublisher作为发布者&lt;/span&gt;
        SubmissionPublisher&amp;lt;String&amp;gt; publisher = &lt;span&gt;new&lt;/span&gt; SubmissionPublisher&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建订阅者&lt;/span&gt;
        MySubscriber&amp;lt;String&amp;gt; subscriber = &lt;span&gt;new&lt;/span&gt; MySubscriber&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册订阅者&lt;/span&gt;
&lt;span&gt;        publisher.subscribe(subscriber);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布几个数据项&lt;/span&gt;
        System.out.println(&quot;开发发布数据...&quot;&lt;span&gt;);
        List.of(&lt;/span&gt;&quot;Java&quot;, &quot;Kotlin&quot;, &quot;Go&quot;, &quot;Erlang&quot;, &quot;Swift&quot;, &quot;Lua&quot;&lt;span&gt;)
            .forEach(im &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交数据&lt;/span&gt;
&lt;span&gt;            publisher.submit(im);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){}
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布结束&lt;/span&gt;
&lt;span&gt;        publisher.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布结束后，为了让发布者线程不会死亡，暂停线程&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt;(&quot;fkjava&quot;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&quot;fkjava&quot;&lt;span&gt;.wait();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex){}
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建订阅者&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; MySubscriber&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Subscriber&amp;lt;T&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布者与订阅者之间的纽带&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Subscription subscription;
    @Override  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅时触发该方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onSubscribe(Subscription subscription)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subscription =&lt;span&gt; subscription;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始请求数据&lt;/span&gt;
        subscription.request(1&lt;span&gt;);
    }
    @Override  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收到数据时触发该方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onNext(T item)
    {
        System.out.println(&lt;/span&gt;&quot;获取到数据: &quot; +&lt;span&gt; item);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求下一条数据&lt;/span&gt;
        subscription.request(1&lt;span&gt;);
    }
    @Override &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅出错时触发该方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onError(Throwable t)
    {
        t.printStackTrace();
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&quot;fkjava&quot;&lt;span&gt;)
        {
            &lt;/span&gt;&quot;fkjava&quot;&lt;span&gt;.notifyAll();
        }
    }
    @Override  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅结束时触发该方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onComplete()
    {
        System.out.println(&lt;/span&gt;&quot;订阅结束&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;(&quot;fkjava&quot;&lt;span&gt;)
        {
            &lt;/span&gt;&quot;fkjava&quot;&lt;span&gt;.notifyAll();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 21 Jul 2018 13:57:00 +0000</pubDate>
<dc:creator>谁将新樽辞旧月，今月曾经照古人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangwz/p/9051337.html</dc:identifier>
</item>
<item>
<title>从静态代码扫描引擎PMD源码学习-多线程任务模型和File过滤设计 - phinehasz</title>
<link>http://www.cnblogs.com/zhhiyp/p/9348082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhhiyp/p/9348082.html</guid>
<description>&lt;p&gt;不知不觉在工作中研究PMD并定制规则已经4个月左右了。其实PMD有许多值得我学习的源码，不过出于时间并不曾动笔。今天简单记录总结一下PMD的多线程和File过滤设计的源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MultiThreadProcessor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractPMDProcessor {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ExecutorService executor;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; CompletionService&amp;lt;Report&amp;gt;&lt;span&gt; completionService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Future&amp;lt;Report&amp;gt;&amp;gt; tasks = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MultiThreadProcessor(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; PMDConfiguration configuration) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(configuration);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         executor = Executors.newFixedThreadPool(configuration.getThreads(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PmdThreadFactory());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         completionService = &lt;span&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;&amp;gt;&lt;span&gt;(executor);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runAnalysis(PmdRunnable runnable) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; multi-threaded execution, dispatch analysis to worker threads&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        tasks.add(completionService.submit(runnable));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; collectReports(List&amp;lt;Renderer&amp;gt;&lt;span&gt; renderers) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Collect result analysis, waiting for termination if needed&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tasks.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt; Report report =&lt;span&gt; completionService.take().get();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.renderReports(renderers, report);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ie) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException ee) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             Throwable t =&lt;span&gt; ee.getCause();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) t;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Error) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (Error) t;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;PmdRunnable exception&quot;&lt;span&gt;, t);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            executor.shutdownNow();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是MultiThreadProcessor，多线程执行类。&lt;/p&gt;
&lt;p&gt;关键类是CompletionService，PMD使用实现了Callable接口的PMDRunnable类来封装线程的具体运行，在这个类的call方法里进行重写。今天的核心不是call里的代码，核心是这种任务式提交的多线程操作的常见写法。也就是结合CompletionService。&lt;/p&gt;
&lt;p&gt;我们知道，如果实现了Callable接口，那么使用者是想获得结果的，而结果是Future对象，PMD代码中的Report就是call的返回，使用Future来泛型封装。&lt;/p&gt;
&lt;p&gt;CompletionService内部维护一个BlockQuene队列，通过ExecutorCompletionService&amp;lt;&amp;gt;&lt;span&gt;(executor)&lt;/span&gt;来传入一个executor，也就是一个线程池。&lt;/p&gt;
&lt;p&gt;这里使用jdk自带的Executors.newFixedThreadPool来创建固定大小的线程池，也就是上限啦。&lt;/p&gt;
&lt;p&gt;如果自己使用callable接口来向池子submit，返回future需要自己管理，而CompletionService则可以完美管理，应当每次都使用该类。&lt;/p&gt;
&lt;p&gt;通过&lt;span&gt;completionService.submit(runnable)&lt;/span&gt;，提交callable实例，获得Future对象，我们通过一个集合List存储，但实际上我们后续并不真正要遍历使用每一个Future。&lt;/p&gt;
&lt;p&gt;注意，submit是让线程开始启动。&lt;/p&gt;
&lt;p&gt;线程运行后，如何拿结果？&lt;/p&gt;
&lt;pre&gt;
&lt;span readability=&quot;2&quot;&gt;&lt;span&gt;使用completionService.take().get();获得call方法最终返回的结果类对象。&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;4&quot;&gt;&lt;span&gt;completionService.take就是获得Future对象,但这里已经是异步操作.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;通过submit启动了一个线程,take操作会获得先运行完的线程的结果Future实例,这是这个服务类内部代码所实现的.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;通过get获得Future封装的对象report&lt;/span&gt;&lt;br/&gt;&lt;span&gt;至此,一连串标准操作,非常舒服.&lt;/span&gt;&lt;br/&gt;---------------------------------------------------------------&lt;br/&gt;&lt;span&gt;接下来是,文件的Filter篇:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;最近在给PMD增加exclude的功能.发现他的FileUtil类里写了以后要做exclude功能的注释...结果6.x版本也还没实现啊..然后我做了半天左右实现好了.(参数传入)&lt;/span&gt;&lt;p&gt;&lt;span&gt;实际上PMD的文件过滤是基于Filter实现,也和FilenameFilter有关.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;核心来自于jdk的File.list(FilenameFilter filter)&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;DataSource&amp;gt;&lt;span&gt; collectFiles(String fileLocations, FilenameFilter filenameFilter) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         List&amp;lt;DataSource&amp;gt; dataSources = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (String fileLocation : fileLocations.split(&quot;,&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            collect(dataSources, fileLocation, filenameFilter);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSources;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;DataSource&amp;gt; collect(List&amp;lt;DataSource&amp;gt;&lt;span&gt; dataSources, String fileLocation,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            FilenameFilter filenameFilter) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(fileLocation);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;file.exists()) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;File &quot; + file.getName() + &quot; doesn't exist&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;file.isDirectory()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileLocation.endsWith(&quot;.zip&quot;) || fileLocation.endsWith(&quot;.jar&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                ZipFile zipFile;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     zipFile = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipFile(fileLocation);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     Enumeration&amp;lt;? &lt;span&gt;extends&lt;/span&gt; ZipEntry&amp;gt; e =&lt;span&gt; zipFile.entries();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (e.hasMoreElements()) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         ZipEntry zipEntry =&lt;span&gt; e.nextElement();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (filenameFilter.accept(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, zipEntry.getName())) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                             dataSources.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipDataSource(zipFile, zipEntry));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ze) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Archive file &quot; + file.getName() + &quot; can't be opened&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 dataSources.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileDataSource(file));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Match files, or directories which are not excluded.
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; FUTURE Make the excluded directories be some configurable option&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             Filter&amp;lt;File&amp;gt; filter = &lt;span&gt;new&lt;/span&gt; OrFilter&amp;lt;&amp;gt;&lt;span&gt;(Filters.toFileFilter(filenameFilter),
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; AndFilter&amp;lt;&amp;gt;&lt;span&gt;(Filters.getDirectoryFilter(), Filters.toNormalizedFileFilter(
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                             Filters.buildRegexFilterExcludeOverInclude(&lt;span&gt;null&lt;/span&gt;, Collections.singletonList(&quot;SCCS&quot;&lt;span&gt;)))));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             FileFinder finder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileFinder();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             List&amp;lt;File&amp;gt; files = finder.findFilesFrom(file, Filters.toFilenameFilter(filter), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File f : files) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 dataSources.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileDataSource(f));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSources;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是PMD来collect的核心代码.dataSource其实就是一个File再次封装的类.&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;collectFiles这个方法就是,传入source路径,一个目录,一个文件路径皆可.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;再传入一个过滤类FilenameFilter,在PMD当前实现里是直接传入基于Language代码语言来做的后缀扩展名extension过滤FilenameFilter,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;最后是传入一个集合,就是做封装的盒子.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;因为路径参数是逗号分隔的,所以先做遍历,然后对每个路径进行调用collect方法.&lt;br/&gt;&lt;span&gt;&lt;span&gt;接下来是核心,collect传入一个FilenameFilter,然后过滤这个路径下的File.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实也是简单的实现.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后再回到,如果我想增加一个过滤目录的功能怎么办?看似我可以在主代码里传入一个exclude的FilenameFilter,实际上它这个collect返回了dataSource,很不利于再次分析.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;也就是说,这块代码其实没什么向后兼容的可能了.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;既然PMD的作者,写死了,那我也就稍做修改.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Filter的精髓其实是OrFilter和AndFilter这种类,理解也很简单,一个OrFilter里维护一个Filter的List,只要有一个返回true,那就返回true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AndFilter里维护着Filter的List,全部返回true才会返回true.我记得apache commons里也有类似的io的file的Filter类.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以后如果想自己做这种功能,也可以用apache的包.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实Filter也很简单,就讲这么多.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 21 Jul 2018 13:18:00 +0000</pubDate>
<dc:creator>phinehasz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhhiyp/p/9348082.html</dc:identifier>
</item>
<item>
<title>ASP.NET  OAuth 2.0 新手上路 - KiSs_小白</title>
<link>http://www.cnblogs.com/xiaobai123/p/9348074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobai123/p/9348074.html</guid>
<description>&lt;h2&gt;OAuth2.0资料&lt;/h2&gt;
&lt;p&gt;初衷：一直想整理授权系列demo,让自己项目高端大尚，列出新手授权系列,帮助小白程序员不用在为授权头疼      &lt;/p&gt;
&lt;p&gt;        OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站）在特定的时段（例如，接下来的 2 小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。&lt;/p&gt;
&lt;p&gt;以上概念来自：&lt;a class=&quot;uri&quot; href=&quot;https://zh.wikipedia.org/wiki/OAuth&quot;&gt;https://zh.wikipedia.org/wiki/OAuth&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细理论知识,参考文章如下文章,本文章重在实践&lt;/p&gt;
&lt;p&gt;1.&lt;a class=&quot;uri&quot; href=&quot;http://www.cnblogs.com/lanxiaoke/p/6358332.html&quot;&gt;http://www.cnblogs.com/lanxiaoke/p/6358332.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a class=&quot;uri&quot; href=&quot;https://www.cnblogs.com/selimsong/p/8037717.html&quot;&gt;https://www.cnblogs.com/selimsong/p/8037717.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a class=&quot;uri&quot; href=&quot;http://www.cnblogs.com/xishuai/p/aspnet-webapi-owin-oauth2.html&quot;&gt;http://www.cnblogs.com/xishuai/p/aspnet-webapi-owin-oauth2.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;项目实践开发&lt;/h2&gt;
&lt;p&gt;步骤1和步骤2都行，看官乐意就行&lt;/p&gt;
&lt;p&gt;步骤1&lt;/p&gt;
&lt;p&gt;通过NuGet安装&lt;/p&gt;
&lt;p&gt;Microsoft.Owin.Security.OAuth&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Owin Microsoft.Owin.Host.SystemWeb(重点)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;步骤2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Owin Microsoft.Owin.Host.SystemWeb(重点)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Microsoft.Owin.Security.OAuth&lt;/p&gt;
&lt;p&gt;Microsoft.Owin.Security.Cookies（可忽略）&lt;/p&gt;
&lt;p&gt;Microsoft.AspNet.Identity.Owin&lt;/p&gt;
&lt;p&gt;重点在于步骤1少了一个核心dll,少了这个核心dll无法启动部署owin&lt;/p&gt;
&lt;p&gt;新增Startup.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[assembly: OwinStartup(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(OAuth2.Startup))]
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; OAuth2
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configuration(IAppBuilder app)
        {
            ConfigureAuth(app);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Owin Microsoft.Owin.Host.SystemWeb 通过这个dll,程序启动时候注册，如果不引用,该方法不会生效,看官可以打个断点试一试&lt;/p&gt;
&lt;p&gt;新增Startup.Auth.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; OAuth2
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureAuth(IAppBuilder app)
        {
            app.UseOAuthBearerAuthentication(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OAuthBearerAuthenticationOptions()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从url中获取token，兼容hearder方式
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Provider = new QueryStringOAuthBearerProvider(&quot;access_token&quot;)&lt;/span&gt;
&lt;span&gt;            });
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; OAuthOptions = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OAuthAuthorizationServerOptions
            {
                AllowInsecureHttp &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                TokenEndpointPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PathString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 access_token 认证服务请求地址&lt;/span&gt;
                AuthorizeEndpointPath = &lt;span&gt;new&lt;/span&gt; PathString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/authorize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 authorization_code 认证服务请求地址&lt;/span&gt;
                AccessTokenExpireTimeSpan = TimeSpan.FromSeconds(&lt;span&gt;3600&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;access_token 过期时间&lt;/span&gt;
&lt;span&gt;
                Provider &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; OpenAuthorizationServerProvider(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;access_token 相关认证服务&lt;/span&gt;
                AuthorizationCodeProvider = &lt;span&gt;new&lt;/span&gt; OpenAuthorizationCodeProvider(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;authorization_code 认证服务&lt;/span&gt;
                RefreshTokenProvider = &lt;span&gt;new&lt;/span&gt; OpenRefreshTokenProvider() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;refresh_token 认证服务&lt;/span&gt;
&lt;span&gt;            };

            app.UseOAuthBearerTokens(OAuthOptions); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示 token_type 使用 bearer 方式&lt;/span&gt;
&lt;span&gt;


        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryStringOAuthBearerProvider : OAuthBearerAuthenticationProvider
    {
        &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; QueryStringOAuthBearerProvider(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            _name &lt;/span&gt;=&lt;span&gt; name;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task RequestToken(OAuthRequestTokenContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; context.Request.Query.Get(_name);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(value))
            {
                context.Token &lt;/span&gt;=&lt;span&gt; value;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;眼光犀利的同学肯定注意到这两个类名相同,命名空间也相同,为什么没有报错  请注意关键字 partial &lt;/p&gt;
&lt;p&gt;OpenAuthorizationServerProvider示例代码  详细见demo，只提代码需要注意地方&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 验证 client 信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; clientId;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; clientSecret;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;context.TryGetBasicCredentials(out clientId, out&lt;/span&gt;&lt;span&gt;&lt;span&gt; clientSecret)&lt;/span&gt;)
            {
                context.TryGetFormCredentials(&lt;/span&gt;&lt;span&gt;out&lt;/span&gt; clientId, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; clientSecret);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clientId != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xishuai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || clientSecret != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                context.SetError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid_client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client or clientSecret is not valid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            context.Validated();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517088/201807/517088-20180721191525879-848720314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; BaseString()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; clientId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xishuai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; clientSecret = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToBase64String(Encoding.ASCII.GetBytes(clientId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; clientSecret));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
验证生效如图 按照如下格式 key:value,然后base64编码 
&lt;/pre&gt;
&lt;pre&gt;
context.TryGetBasicCredentials 否则解析不了 验证不通过
&lt;/pre&gt;
&lt;p&gt;OpenAuthorizationCodeProvider示例代码 详细见demo&lt;/p&gt;
&lt;p&gt;OpenRefreshTokenProvider 示例代码 详细见demo&lt;/p&gt;
&lt;p&gt;新增ValueController.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueController : ApiController
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values  access_token验证才能访问&lt;/span&gt;
&lt;span&gt;        [Authorize]
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Index()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
        &lt;br/&gt;//获取授权code
        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpResponseMessage Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; code)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseMessage()
            {
                Content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(code, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
        }&lt;/span&gt;&lt;span&gt;

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新增OAuthon2Controller.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OAuthon2Controller : Controller
    {
        //根据你项目端口
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; HOST_ADDRESS = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:60903&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: OAuthon2   直接获取授权code链接,方便获取code&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Index()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; clientId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xishuai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{HOST_ADDRESS}/authorize?grant_type=authorization_code&amp;amp;response_type=code&amp;amp;client_id={clientId}&amp;amp;redirect_uri={HttpUtility.UrlEncode($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;{HOST_ADDRESS}/api/authorization_code&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; url;
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据获取的url,   在将红色部分url复制出来到浏览器中可以获取到code&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517088/201807/517088-20180721192917688-456596673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在code有了  将获取access_token&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201807/517088-20180721193031349-2001485113.png&quot; alt=&quot;1&quot; width=&quot;600&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;grant_type:authorization_code&lt;/p&gt;
&lt;p&gt;code:图上红色url返回给你的&lt;/p&gt;
&lt;p&gt;client_id:xishuai 可以理解为appid  自定义,因为代码中固定了,你可以改&lt;/p&gt;
&lt;p&gt;redirect_uri:这个链接你也能改的,接受code 在ValueController.cs   （action：api/authorization_code）&lt;/p&gt;
&lt;p&gt;http://localhost:60903/api/authorization_code&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个地方需要注意  需要和你获取code redirect_uri保持一致就行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;string url = $&quot;{HOST_ADDRESS}/authorize?grant_type=authorization_code&amp;amp;response_type=code&amp;amp;client_id={clientId}&amp;amp;redirect_uri={HttpUtility.UrlEncode($&quot;{HOST_ADDRESS}/api/authorization_code&quot;)}&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后你就拿到access_token 去调用 api/Value/Index&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;2&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201807/517088-20180721193630939-1365279960.png&quot; alt=&quot;2&quot; width=&quot;600&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果这个地方你输入错,会获取失败&lt;/p&gt;
&lt;p&gt;Authorization     Bearer后面空格 在输入access_token &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yaols/OAuth2.git&quot;&gt;源码下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 13:16:00 +0000</pubDate>
<dc:creator>KiSs_小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobai123/p/9348074.html</dc:identifier>
</item>
<item>
<title>机器学习——前馈神经网络 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/9347233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/9347233.html</guid>
<description>&lt;h2&gt;一、神经网络基础&lt;/h2&gt;
&lt;h3&gt;1. 神经元模型&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;神经网络中最基本的单元是&lt;strong&gt;神经元模型&lt;/strong&gt;（neuron）。&lt;/p&gt;
&lt;p&gt;细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170503746-1240148319.png&quot;&gt;&lt;img title=&quot;神经元&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170504216-1816094552.png&quot; alt=&quot;神经元&quot; width=&quot;640&quot; height=&quot;281&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 激活函数&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170504596-164101268.png&quot;&gt;&lt;img title=&quot;激活函数&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170504931-1948715496.png&quot; alt=&quot;激活函数&quot; width=&quot;640&quot; height=&quot;289&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更多激活函数参考： &lt;a title=&quot;https://www.jianshu.com/p/22d9720dbf1a&quot; href=&quot;https://www.jianshu.com/p/22d9720dbf1a&quot;&gt;https://www.jianshu.com/p/22d9720dbf1a&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3. 感知机（Perceptron）&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;       感知机（Perceptron）是由两层神经元组成的一个简单模型，但只有输出层是M-P神经元，即只有输出层神经元进行激活函数处理，也称为功能神经元（functional neuron）；输入层只是接受外界信号（样本属性）并传递给输出层（输入层的神经元个数等于样本的属性数目），而没有激活函数。这样一来，感知机与之前线性模型中的对数几率回归的思想基本是一样的，都是通过对属性加权与另一个常数求和，再使用sigmoid函数将这个输出值压缩到0-1之间，从而解决分类问题。&lt;span&gt;不同的是感知机的输出层应该可以有多个神经元，&lt;/span&gt;从而可以实现多分类问题，同时两个模型所用的参数估计方法十分不同。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170505249-546185697.png&quot;&gt;&lt;img title=&quot;感知机&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170505542-2000218273.png&quot; alt=&quot;感知机&quot; width=&quot;544&quot; height=&quot;401&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;感知机权重学习过程&lt;/h4&gt;
&lt;p&gt;感知机的学习采用随机梯度下降算法（SGD）该算法的说明可以参考：&lt;a title=&quot;http://www.cnblogs.com/NeilZhang/p/8454890.html&quot; href=&quot;http://www.cnblogs.com/NeilZhang/p/8454890.html&quot;&gt;http://www.cnblogs.com/NeilZhang/p/8454890.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170505857-1614522124.png&quot;&gt;&lt;img title=&quot;感知机学习&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170506267-704863059.png&quot; alt=&quot;感知机学习&quot; width=&quot;584&quot; height=&quot;480&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;        其中 η∈（0，1）称为学习率&lt;/span&gt;，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。&lt;/p&gt;
&lt;h4&gt;局限性：&lt;/h4&gt;
&lt;p&gt;       感知机&lt;span&gt;只有输出层神经元进行激活函数处理&lt;/span&gt;，即只拥有一层功能神经元，其学习能力非常有限。 可以证明若二类模式是线性可分的，即存在一个线性超平面能将他们分开，则感知机的学习一定会收敛（converge）而求得适当的权向量w = （w1，w2,w3…..）; 否则感知机学习过程将会发生震荡，w难以稳定下来，不能求得合适解。&lt;/p&gt;
&lt;p&gt;     要解决非线性可分问题需要考虑使用多层功能神经元，即神经网络。（神经网络发展史上经典问题：异或问题单层网络不能解决）&lt;/p&gt;

&lt;h3&gt;4.神经网络&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;多层神经网络的拓扑结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170506651-1708328846.png&quot;&gt;&lt;img title=&quot;多层神经网络&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170507089-967410838.png&quot; alt=&quot;多层神经网络&quot; width=&quot;640&quot; height=&quot;347&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在神经网络中，输入层与输出层之间的层称为隐含层或隐层（hidden layer），隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“&lt;span&gt;多层前馈神经网络&lt;/span&gt;”（multi-layer feedforward neural network），该结构满足以下几个特点：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;* 每层神经元与下一层神经元之间完全互连&lt;/p&gt;
&lt;p&gt;* 神经元之间不存在同层连接&lt;/p&gt;
&lt;p&gt;* 神经元之间不存在跨层连接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170507480-960810396.png&quot;&gt;&lt;img title=&quot;前馈神经网络&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170507947-1641271357.png&quot; alt=&quot;前馈神经网络&quot; width=&quot;614&quot; height=&quot;303&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在环或回路，而不是指该网络只能向前传播而不能向后传播&lt;/p&gt;

&lt;h2&gt;二、误差逆传播算法（BP神经网络算法）&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;      神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170508469-723810469.png&quot;&gt;&lt;img title=&quot;BP算法&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170508998-1949233232.png&quot; alt=&quot;BP算法&quot; width=&quot;618&quot; height=&quot;384&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上图的网络中有(d+l+1)*q+l个参数需要确定：输入层到隐层的d×q个权重，隐层到输出层q×l个权重、q个隐层神经元的阈值、l个输出神经元的阈值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;       上图为一个单隐层前馈神经网络的拓扑结构，&lt;span&gt;BP神经网络算法也使用梯度下降法（gradient descent），以单个样本的均方误差的负梯度方向对权重进行调节（&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/8454890.html&quot;&gt;sgd算法&lt;/a&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170509256-1433593312.png&quot;&gt;&lt;img title=&quot;gongsi&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170509458-1379013265.png&quot; alt=&quot;gongsi&quot; width=&quot;299&quot; height=&quot;96&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       学习率η∈（0，1）控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把η设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。&lt;/p&gt;
&lt;p&gt;      可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：&lt;/p&gt;
&lt;h3&gt;1. 误差函数&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170509827-1809668240.png&quot;&gt;&lt;img title=&quot;均方差&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721170510304-1098817722.png&quot; alt=&quot;均方差&quot; width=&quot;640&quot; height=&quot;274&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2. 具体推导过程&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201524887-20516834.jpg&quot;&gt;&lt;img title=&quot;推导2&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201525271-2085811284.jpg&quot; alt=&quot;推导2&quot; width=&quot;640&quot; height=&quot;480&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其它参数的推算过程相似，参考《机器学习》中神经网络的介绍。&lt;/p&gt;
&lt;p&gt;上述算法的推导是基于每次仅针对一个训练样例更新权重和阈值（&lt;span&gt;标准BP算法&lt;/span&gt;），这种算法参数更新十分频繁，可能会出现“抵消”现象。累计BP算法针对累计误差最小化，每次读取整个数据集一遍后才对参数进行更新，其参数更新的频率低得多。&lt;/p&gt;

&lt;h3&gt;3. 过拟合&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中λ∈（0,1）用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201525493-389241851.png&quot;&gt;&lt;img title=&quot;过拟合&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201526005-2076965602.png&quot; alt=&quot;过拟合&quot; width=&quot;490&quot; height=&quot;86&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;4. 全局最小与局部最小&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201526518-1246230728.png&quot;&gt;&lt;img title=&quot;局部最小&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201527315-955444686.png&quot; alt=&quot;局部最小&quot; width=&quot;603&quot; height=&quot;360&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。因此在现实任务中，通常使用以下策略尽可能地去接近全局最小。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;* &lt;span&gt;&lt;strong&gt;局部极小解&lt;/strong&gt;&lt;/span&gt;：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。&lt;/p&gt;
&lt;p&gt;* &lt;strong&gt;&lt;span&gt;全局最小解&lt;/span&gt;&lt;/strong&gt;：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跳出局部最小的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。&lt;/li&gt;
&lt;li&gt;使用“模拟退火”技术&lt;/li&gt;
&lt;li&gt;使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;三、神经网络可视化&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;推荐一个在线测试神经网络的网站：&lt;a title=&quot;http://playground.tensorflow.org/&quot; href=&quot;http://playground.tensorflow.org/&quot;&gt;http://playground.tensorflow.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下图为上述网站通过两个神经元解决异或问题：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201527996-996607858.png&quot;&gt;&lt;img title=&quot;疑惑问题&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201807/918077-20180721201528459-549142918.png&quot; alt=&quot;疑惑问题&quot; width=&quot;640&quot; height=&quot;282&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;参考：&lt;/h3&gt;
&lt;p&gt;《机器学习》 周志华&lt;/p&gt;
&lt;p&gt;激活函数： &lt;a title=&quot;https://blog.csdn.net/u011826404/article/details/53767428&quot; href=&quot;https://blog.csdn.net/u011826404/article/details/53767428&quot;&gt;https://blog.csdn.net/u011826404/article/details/53767428&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随机梯度下降与批梯度下降： &lt;a title=&quot;http://www.cnblogs.com/NeilZhang/p/8454890.html&quot; href=&quot;http://www.cnblogs.com/NeilZhang/p/8454890.html&quot;&gt;http://www.cnblogs.com/NeilZhang/p/8454890.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Jul 2018 12:18:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/9347233.html</dc:identifier>
</item>
</channel>
</rss>