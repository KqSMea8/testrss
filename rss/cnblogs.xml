<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>以太坊(Ethereum) - 节点时间未同步和区块同步失败案例分析 - 秦鹏飞</title>
<link>http://www.cnblogs.com/feiqihang/p/9229315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feiqihang/p/9229315.html</guid>
<description>&lt;pre&gt;
......
&lt;span&gt;const&lt;/span&gt;&lt;span&gt; (
    bodyCacheLimit      &lt;/span&gt;= &lt;span&gt;256&lt;/span&gt;&lt;span&gt;
    blockCacheLimit     &lt;/span&gt;= &lt;span&gt;256&lt;/span&gt;&lt;span&gt;
    maxFutureBlocks     &lt;/span&gt;= &lt;span&gt;256&lt;/span&gt;&lt;span&gt;
    maxTimeFutureBlocks = 30&lt;/span&gt;&lt;span&gt;
    badBlockLimit       &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
    triesInMemory       &lt;/span&gt;= &lt;span&gt;128&lt;/span&gt;&lt;span&gt;
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BlockChainVersion ensures that an incompatible database forces a resync from scratch.&lt;/span&gt;
    BlockChainVersion = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
)
 
&lt;/span&gt;&lt;span&gt;...... 
 
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; insertChain will execute the actual chain insertion and event aggregation. The
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; only reason this method exists as a separate one is to make locking cleaner
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; with deferred statements.&lt;/span&gt;
func (bc *BlockChain) insertChain(chain types.Blocks) (&lt;span&gt;int&lt;/span&gt;, []&lt;span&gt;interface&lt;/span&gt;{}, []*&lt;span&gt;types.Log, error) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do a sanity check that the provided chain is actually ordered and linked&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt; len(chain); i++&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; chain[i].NumberU64() != chain[i-&lt;span&gt;1&lt;/span&gt;].NumberU64()+&lt;span&gt;1&lt;/span&gt; || chain[i].ParentHash() != chain[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].Hash() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Chain broke ancestry, log a messge (programming error) and skip insertion&lt;/span&gt;
            log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Non contiguous block insert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, chain[i].Number(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, chain[i].Hash(),
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, chain[i].ParentHash(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prevnumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, chain[i-&lt;span&gt;1&lt;/span&gt;].Number(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prevhash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, chain[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].Hash())
​
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, nil, nil, fmt.Errorf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;non contiguous insert: item %d is #%d [%x…], item %d is #%d [%x…] (parent [%x…])&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i-&lt;span&gt;1&lt;/span&gt;, chain[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].NumberU64(),
                chain[i&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;].Hash().Bytes()[:&lt;span&gt;4&lt;/span&gt;], i, chain[i].NumberU64(), chain[i].Hash().Bytes()[:&lt;span&gt;4&lt;/span&gt;], chain[i].ParentHash().Bytes()[:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;])
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pre-checks passed, start the full block imports&lt;/span&gt;
    bc.wg.Add(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    defer bc.wg.Done()
​
    bc.chainmu.Lock()
    defer bc.chainmu.Unlock()
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; A queued approach to delivering events. This is generally
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; faster than direct delivery and requires much less mutex
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; acquiring.&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; (
        stats         &lt;/span&gt;=&lt;span&gt; insertStats{startTime: mclock.Now()}
        events        &lt;/span&gt;= make([]&lt;span&gt;interface&lt;/span&gt;{}, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, len(chain))
        lastCanon     &lt;/span&gt;*&lt;span&gt;types.Block
        coalescedLogs []&lt;/span&gt;*&lt;span&gt;types.Log
    )
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start the parallel header verifier&lt;/span&gt;
    headers := make([]*&lt;span&gt;types.Header, len(chain))
    seals :&lt;/span&gt;= make([]&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;, len(chain))
​
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, block :=&lt;span&gt; range chain {
        headers[i] &lt;/span&gt;=&lt;span&gt; block.Header()
        seals[i] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
    abort, results :&lt;/span&gt;=&lt;span&gt; bc.engine.VerifyHeaders(bc, headers, seals)
    defer close(abort)
​
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Iterate over the blocks and insert when the verifier permits&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i, block :=&lt;span&gt; range chain {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the chain is terminating, stop processing blocks&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; atomic.LoadInt32(&amp;amp;bc.procInterrupt) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt; {
            log.Debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Premature abort during blocks processing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the header is a banned one, straight out abort&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; BadHashes[block.Hash()] {
            bc.reportBlock(block, nil, ErrBlacklistedHash)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, ErrBlacklistedHash
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait for the block's verification to complete&lt;/span&gt;
        bstart :=&lt;span&gt; time.Now()
​
        err :&lt;/span&gt;= &amp;lt;-&lt;span&gt;results
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err ==&lt;span&gt; nil {
            err &lt;/span&gt;=&lt;span&gt; bc.Validator().ValidateBody(block)
        }
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; err ==&lt;span&gt; ErrKnownBlock:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Block and state both already known. However if the current block is below
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this number we did a rollback and we should reimport it nonetheless.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; bc.CurrentBlock().NumberU64() &amp;gt;=&lt;span&gt; block.NumberU64() {
                stats.ignored&lt;/span&gt;++
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
            }
​
        &lt;/span&gt;&lt;span&gt;case err == consensus.ErrFutureBlock:
            // Allow up to MaxFuture second in the future blocks. If this limit is exceeded
            // the chain is discarded and processed at a later time if given.
            max := big.NewInt(time.Now().Unix() + maxTimeFutureBlocks)
            if block.Time().Cmp(max) &amp;gt; 0 {
                return i, events, coalescedLogs, fmt.Errorf(&quot;future block: %v &amp;gt; %v&quot;, block.Time(), max)
            }
            bc.futureBlocks.Add(block.Hash(), block)
            stats.queued++
            continue&lt;/span&gt;&lt;span&gt;
​
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; err == consensus.ErrUnknownAncestor &amp;amp;&amp;amp;&lt;span&gt; bc.futureBlocks.Contains(block.ParentHash()):
            bc.futureBlocks.Add(block.Hash(), block)
            stats.queued&lt;/span&gt;++
            &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
​
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; err ==&lt;span&gt; consensus.ErrPrunedAncestor:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Block competing with the canonical chain, store in the db, but don't process
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; until the competitor TD goes above the canonical TD&lt;/span&gt;
            currentBlock :=&lt;span&gt; bc.CurrentBlock()
            localTd :&lt;/span&gt;=&lt;span&gt; bc.GetTd(currentBlock.Hash(), currentBlock.NumberU64())
            externTd :&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;(big.Int).Add(bc.GetTd(block.ParentHash(), block.NumberU64()-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;), block.Difficulty())
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; localTd.Cmp(externTd) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err = bc.WriteBlockWithoutState(block, externTd); err !=&lt;span&gt; nil {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
                }
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Competitor chain beat canonical, gather all blocks from the common ancestor&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; winner []*&lt;span&gt;types.Block
​
            parent :&lt;/span&gt;= bc.GetBlock(block.ParentHash(), block.NumberU64()-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; !&lt;span&gt;bc.HasState(parent.Root()) {
                winner &lt;/span&gt;=&lt;span&gt; append(winner, parent)
                parent &lt;/span&gt;= bc.GetBlock(parent.ParentHash(), parent.NumberU64()-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;0&lt;/span&gt;; j &amp;lt; len(winner)/&lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt; {
                winner[j], winner[len(winner)&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-j] = winner[len(winner)-&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;j], winner[j]
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Import all the pruned blocks to make the state available&lt;/span&gt;
&lt;span&gt;            bc.chainmu.Unlock()
            _, evs, logs, err :&lt;/span&gt;=&lt;span&gt; bc.insertChain(winner)
            bc.chainmu.Lock()
            events, coalescedLogs &lt;/span&gt;=&lt;span&gt; evs, logs
​
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
            }
​
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; err !=&lt;span&gt; nil:
            bc.reportBlock(block, nil, err)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create a new statedb using the parent block and report an
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; error if it fails.&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; parent *&lt;span&gt;types.Block
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
            parent &lt;/span&gt;= bc.GetBlock(block.ParentHash(), block.NumberU64()-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            parent &lt;/span&gt;= chain[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
        }
        state, err :&lt;/span&gt;=&lt;span&gt; state.New(parent.Root(), bc.stateCache)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process block using the parent state as reference point.&lt;/span&gt;
        receipts, logs, usedGas, err :=&lt;span&gt; bc.processor.Process(block, state, bc.vmConfig)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            bc.reportBlock(block, receipts, err)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Validate the state using the default validator&lt;/span&gt;
        err =&lt;span&gt; bc.Validator().ValidateState(block, parent, state, receipts, usedGas)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            bc.reportBlock(block, receipts, err)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
        }
        proctime :&lt;/span&gt;=&lt;span&gt; time.Since(bstart)
​
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write the block to the chain and get the status.&lt;/span&gt;
        status, err :=&lt;span&gt; bc.WriteBlockWithState(block, receipts, state)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i, events, coalescedLogs, err
        }
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; status {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CanonStatTy:
            log.Debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Inserted new block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.Number(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.Hash(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uncles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(block.Uncles()),
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;txs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, len(block.Transactions()), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.GasUsed(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elapsed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, common.PrettyDuration(time.Since(bstart)))
​
            coalescedLogs &lt;/span&gt;=&lt;span&gt; append(coalescedLogs, logs...)
            blockInsertTimer.UpdateSince(bstart)
            events &lt;/span&gt;=&lt;span&gt; append(events, ChainEvent{block, block.Hash(), logs})
            lastCanon &lt;/span&gt;=&lt;span&gt; block
​
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only count canonical blocks for GC processing time&lt;/span&gt;
            bc.gcproc +=&lt;span&gt; proctime
​
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SideStatTy:
            log.Debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Inserted forked block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.Number(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.Hash(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.Difficulty(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elapsed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                common.PrettyDuration(time.Since(bstart)), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;txs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, len(block.Transactions()), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, block.GasUsed(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uncles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(block.Uncles()))
​
            blockInsertTimer.UpdateSince(bstart)
            events &lt;/span&gt;=&lt;span&gt; append(events, ChainSideEvent{block})
        }
        stats.processed&lt;/span&gt;++&lt;span&gt;
        stats.usedGas &lt;/span&gt;+=&lt;span&gt; usedGas
        stats.report(chain, i, bc.stateCache.TrieDB().Size())
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Append a single chain head event if we've progressed the chain&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; lastCanon != nil &amp;amp;&amp;amp; bc.CurrentBlock().Hash() ==&lt;span&gt; lastCanon.Hash() {
        events &lt;/span&gt;=&lt;span&gt; append(events, ChainHeadEvent{lastCanon})
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, events, coalescedLogs, nil
}
 &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Jun 2018 07:24:00 +0000</pubDate>
<dc:creator>秦鹏飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feiqihang/p/9229315.html</dc:identifier>
</item>
<item>
<title>（7）ASP.NET CORE微服务 Micro-Service ---- 利用Polly+AOP+依赖注入封装的降级框架 - 情话布墨</title>
<link>http://www.cnblogs.com/qhbm/p/9229301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qhbm/p/9229301.html</guid>
<description>&lt;h3&gt;创建简单的熔断降级框架&lt;/h3&gt;
&lt;p&gt;要达到的目标是： &lt;span&gt;参与降级的方法参数要一样&lt;/span&gt;，当HelloAsync执行出错的时候执行HelloFallBackAsync方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
　　[HystrixCommand(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloFallBackAsync&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]  &lt;br/&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HelloAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+name);&lt;br/&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　}
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HelloFallBackAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+name); &lt;br/&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、编写 HystrixCommandAttribute &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; AspectCore.DynamicProxy;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; hystrixtest1
{
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;限制这个特性只能标注到方法上&lt;/span&gt;
&lt;span&gt;　　[AttributeUsage(AttributeTargets.Method)]     
　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixCommandAttribute : AbstractInterceptorAttribute
　　{         
　　　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HystrixCommandAttribute(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fallBackMethod)
　　　　{             
　　　　　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.FallBackMethod =&lt;span&gt; fallBackMethod;
　　　　}          
　　　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FallBackMethod { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }         
　　　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
　　　　{    
　　　　　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;             
　　　　　　{                 
　　　　　　　　&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; next(context);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行被拦截的方法&lt;/span&gt;
&lt;span&gt;　　　　　　}
　　　　　　&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
　　　　　　{
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.ServiceMethod被拦截的方法。context.ServiceMethod.DeclaringType被拦截方法所在的类
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.Implementation实际执行的对象p
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.Parameters方法参数值
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果执行失败，则执行FallBackMethod
　　　　　　　　
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用降级方法
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.调用降级的方法（根据对象获取类，从类获取方法）&lt;/span&gt;
　　　　　　　　&lt;span&gt;var&lt;/span&gt; fallBackMethod = context.ServiceMethod.DeclaringType.GetMethod(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.FallBackMethod);
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.调用降级的方法&lt;/span&gt;
　　　　　　　　Object fallBackResult =&lt;span&gt; fallBackMethod.Invoke(context.Implementation, context.Parameters);
　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.把降级方法的返回值返回&lt;/span&gt;
　　　　　　　　context.ReturnValue =&lt;span&gt; fallBackResult;
　　　　　　}
　　　　}
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、编写类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要public类&lt;/span&gt;&lt;span&gt;
{
　　[HystrixCommand(nameof(HelloFallBackAsync))]        &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HelloAsync(&lt;span&gt;string&lt;/span&gt; name)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要是虚方法&lt;/span&gt;&lt;span&gt;
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;name);
　　　　String s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;　　　　//&lt;/span&gt;&lt;span&gt; s.ToString(); &lt;br/&gt;　　　　return &quot;ok&quot;;&lt;/span&gt;&lt;span&gt;
　　}
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HelloFallBackAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+name);               &lt;br/&gt;　　　　&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　}
　　[HystrixCommand(nameof(AddFall))]         &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
　　{
　　　　String s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;    &lt;br/&gt;　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s.ToArray();   &lt;br/&gt;　　　　return i + j;&lt;/span&gt;&lt;span&gt;
　　}
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AddFall(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
　　{
　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
　　}
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、创建代理对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ProxyGeneratorBuilder proxyGeneratorBuilder = &lt;span&gt;new&lt;/span&gt; ProxyGeneratorBuilder(); &lt;br/&gt;&lt;span&gt;using&lt;/span&gt; (IProxyGenerator proxyGenerator =&lt;span&gt; proxyGeneratorBuilder.Build())
{
　　Person p &lt;/span&gt;= proxyGenerator.CreateClassProxy&amp;lt;Person&amp;gt;&lt;span&gt;();
　　Console.WriteLine(p.HelloAsync(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yzk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result);
　　Console.WriteLine(p.Add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码还支持多次降级，方法上标注[HystrixCommand]并且virtual即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要public类&lt;/span&gt;&lt;span&gt;
{
　　[HystrixCommand(nameof(Hello1FallBackAsync))]&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HelloAsync(&lt;span&gt;string&lt;/span&gt; name)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要是虚方法&lt;/span&gt;&lt;span&gt;
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name);           &lt;br/&gt;　　　　String s = &lt;span&gt;null&lt;/span&gt;;            &lt;br/&gt;　　　　s.ToString();               &lt;br/&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　}
　　[HystrixCommand(nameof(Hello2FallBackAsync))]      &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Hello1FallBackAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello降级1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name);                  &lt;br/&gt;　　　　String s = &lt;span&gt;null&lt;/span&gt;;    &lt;br/&gt;　　　　s.ToString();               &lt;br/&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fail_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　}
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Hello2FallBackAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
　　{
　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello降级2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fail_2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
　　}
　　[HystrixCommand(nameof(AddFall))]         &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
　　{
　　　　String s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;　　　　s.ToString();               &lt;br/&gt;&lt;span&gt;　　　　return&lt;/span&gt; i +&lt;span&gt; j;
　　}
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AddFall(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
　　{
&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;细化框架&lt;/h3&gt;
&lt;p&gt;上面明白了了原理，然后直接展示写好的更复杂的HystrixCommandAttribute，讲解代码。&lt;/p&gt;
&lt;p&gt;这是杨中科老师维护的开源项目&lt;/p&gt;
&lt;p&gt;github最新地址 https://github.com/yangzhongke/RuPeng.HystrixCore&lt;/p&gt;
&lt;p&gt;Nuget地址：https://www.nuget.org/packages/RuPeng.HystrixCore&lt;/p&gt;

&lt;p&gt;重试：MaxRetryTimes表示最多重试几次，如果为0则不重试，RetryIntervalMilliseconds 表示重试间隔的毫秒数；&lt;/p&gt;
&lt;p&gt;熔断：EnableCircuitBreaker是否启用熔断，ExceptionsAllowedBeforeBreaking表示熔断前出现允许错误几次，MillisecondsOfBreak表示熔断多长时间（毫秒）；&lt;/p&gt;
&lt;p&gt;超时：TimeOutMilliseconds执行超过多少毫秒则认为超时（0表示不检测超时）&lt;/p&gt;
&lt;p&gt;缓存：CacheTTLMilliseconds 缓存多少毫秒（0 表示不缓存），用“类名+方法名+所有参数值 ToString拼接”做缓存Key（唯一的要求就是参数的类型ToString对于不同对象一定要不一样）。&lt;/p&gt;
&lt;p&gt;用到了缓存组件：Install-Package Microsoft.Extensions.Caching.Memory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; AspectCore.DynamicProxy;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Polly;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RuPeng.HystrixCore
{
    [AttributeUsage(AttributeTargets.Method)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixCommandAttribute : AbstractInterceptorAttribute
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最多重试几次，如果为0则不重试 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MaxRetryTimes { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重试间隔的毫秒数 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
　　　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RetryIntervalMilliseconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; 

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否启用熔断 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
　　　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; EnableCircuitBreaker { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 熔断前出现允许错误几次 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
　　　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExceptionsAllowedBeforeBreaking { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;; 

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 熔断多长时间（毫秒） 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
　　　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MillisecondsOfBreak { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;; 

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行超过多少毫秒则认为超时（0表示不检测超时） 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
　　　　 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TimeOutMilliseconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 缓存多少毫秒（0表示不缓存），用“类名+方法名+所有参数ToString拼接”做缓存Key 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CacheTTLMilliseconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于CircuitBreaker要求同一段代码必须共享同一个Policy对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;而方法上标注的Attribute 对于这个方法来讲就是唯一的对象，一个方法对应一个方法上标注的Attribute对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般我们熔断控制是针对一个方法，一个方法无论是通过几个 Person 对象调用，无论是谁调用，只要全局出现ExceptionsAllowedBeforeBreaking次错误，就会熔断，这是框架的实现，你如果认为不合理，自己改去。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们在Attribute上声明一个Policy的成员变量，这样一个方法就对应一个Policy对象。&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Policy policy;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Microsoft.Extensions.Caching.Memory.IMemoryCache memoryCache = &lt;span&gt;new&lt;/span&gt; Microsoft.Extensions.Caching.Memory.MemoryCache(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Caching.Memory.MemoryCacheOptions());

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt;  
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fallBackMethod&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;降级的方法名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;         
        &lt;span&gt;public&lt;/span&gt; HystrixCommandAttribute(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fallBackMethod)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.FallBackMethod =&lt;span&gt; fallBackMethod;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FallBackMethod { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个HystrixCommand中保持一个policy对象即可 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实主要是CircuitBreaker要求对于同一段代码要共享一个policy对象 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据反射原理，同一个方法就对应一个HystrixCommandAttribute，无论几次调用， 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;而不同方法对应不同的HystrixCommandAttribute对象，天然的一个policy对象共享  
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为同一个方法共享一个policy，因此这个CircuitBreaker是针对所有请求的。             
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Attribute也不会在运行时再去改变属性的值，共享同一个policy对象也没问题             &lt;/span&gt;
　　　　　　　&lt;span&gt;lock&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为Invoke可能是并发调用，因此要确保policy赋值的线程安全 &lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (policy == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    policy &lt;/span&gt;= Policy.NoOpAsync();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个空的Policy                     &lt;/span&gt;
　　　　　　　　　　　　&lt;span&gt;if&lt;/span&gt; (EnableCircuitBreaker) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先保证熔断&lt;/span&gt;
&lt;span&gt;                    {
                        policy &lt;/span&gt;= policy.WrapAsync(Policy.Handle&amp;lt;Exception&amp;gt;&lt;span&gt;().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)));
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (TimeOutMilliseconds &amp;gt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制是否超时&lt;/span&gt;
&lt;span&gt;                    {
                        policy &lt;/span&gt;= policy.WrapAsync(Policy.TimeoutAsync(() =&amp;gt;&lt;span&gt; TimeSpan.FromMilliseconds(TimeOutMilliseconds), Polly.Timeout.TimeoutStrategy.Pessimistic));
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (MaxRetryTimes &amp;gt; &lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果出错等待MaxRetryTimes时间在执行&lt;/span&gt;
&lt;span&gt;                    {
                        policy &lt;/span&gt;= policy.WrapAsync(Policy.Handle&amp;lt;Exception&amp;gt;().WaitAndRetryAsync(MaxRetryTimes, i =&amp;gt;&lt;span&gt; TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)));
                    }
                    Policy policyFallBack &lt;/span&gt;=&lt;span&gt; Policy
                    .Handle&lt;/span&gt;&amp;lt;Exception&amp;gt;()  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出错了报错   如果出错就尝试调用降级方法&lt;/span&gt;
                    .FallbackAsync(&lt;span&gt;async&lt;/span&gt; (ctx, t) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里拿到的就是ExecuteAsync(ctx =&amp;gt; next(context), pollyCtx);这里传的 pollyCtx &lt;/span&gt;
                        AspectContext aspectContext = (AspectContext)ctx[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aspectContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fallBackMethod = context.ServiceMethod.DeclaringType.GetMethod(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.FallBackMethod);
                        Object fallBackResult &lt;/span&gt;=&lt;span&gt; fallBackMethod.Invoke(context.Implementation, context.Parameters);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能如下这样，因为这是闭包相关，如果这样写第二次调用Invoke的时候context指向的 
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还是第一次的对象，所以要通过Polly的上下文来传递AspectContext 
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.ReturnValue = fallBackResult;                         &lt;/span&gt;
                        aspectContext.ReturnValue =&lt;span&gt; fallBackResult;
                    }, &lt;/span&gt;&lt;span&gt;async&lt;/span&gt; (ex, t) =&amp;gt;&lt;span&gt; { });
                    policy &lt;/span&gt;=&lt;span&gt; policyFallBack.WrapAsync(policy);
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把本地调用的AspectContext传递给Polly，主要给FallbackAsync中使用，避免闭包的坑 &lt;/span&gt;
            Context pollyCtx = &lt;span&gt;new&lt;/span&gt; Context();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Context是polly中通过Execute给FallBack、Execute等回调方法传上下文对象使用的&lt;/span&gt;
            pollyCtx[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aspectContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = context;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context是aspectCore的上下文 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Install-Package Microsoft.Extensions.Caching.Memory             &lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (CacheTTLMilliseconds &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用类名+方法名+参数的下划线连接起来作为缓存key &lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; cacheKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HystrixMethodCacheManager_Key_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; context.ServiceMethod.DeclaringType &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.ServiceMethod + &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, context.Parameters);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试去缓存中获取。如果找到了，则直接用缓存中的值做返回值 &lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (memoryCache.TryGetValue(cacheKey, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; cacheValue))
                {
                    context.ReturnValue &lt;/span&gt;=&lt;span&gt; cacheValue;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果缓存中没有，则执行实际被拦截的方法 &lt;/span&gt;
                    &lt;span&gt;await&lt;/span&gt; policy.ExecuteAsync(ctx =&amp;gt;&lt;span&gt; next(context), pollyCtx);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入缓存中 &lt;/span&gt;
                    &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cacheEntry =&lt;span&gt; memoryCache.CreateEntry(cacheKey))
                    {
                        cacheEntry.Value &lt;/span&gt;= context.ReturnValue;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值放入缓存                         &lt;/span&gt;
                        cacheEntry.AbsoluteExpiration = DateTime.Now +&lt;span&gt; TimeSpan.FromMilliseconds(CacheTTLMilliseconds);
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有启用缓存，就直接执行业务方法 &lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; policy.ExecuteAsync(ctx =&amp;gt;&lt;span&gt; next(context), pollyCtx);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;框架不是万能的，不用过度框架，过度框架带来的复杂度陡增，从人人喜欢变成人人恐惧。&lt;/p&gt;

&lt;h3&gt;结合 &lt;strong&gt;asp.net core&lt;/strong&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;在asp.net core项目中，可以借助于asp.net core的依赖注入，简化代理类对象的注入，不用再自己调用ProxyGeneratorBuilder 进行代理类对象的注入了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package AspectCore.Extensions.DependencyInjection
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改Startup.cs的ConfigureServices方法，把返回值从void改为IServiceProvider&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; AspectCore.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton&lt;/span&gt;&amp;lt;Person&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services.BuildAspectCoreServiceProvider();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其 中 services.AddSingleton&amp;lt;Person&amp;gt;(); 表 示 把Person注 入 。&lt;/p&gt;
&lt;p&gt;BuildAspectCoreServiceProvider是让aspectcore接管注入。&lt;/p&gt;
&lt;p&gt;在Controller中就可以通过构造函数进行依赖注入了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Person p;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(Person p)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.p =&lt;span&gt; p;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过反射扫描所有Service类，只要类中有标记了CustomInterceptorAttribute的方法都算作服务实现类。为了避免一下子扫描所有类，所以 RegisterServices 还是手动指定从哪个程序集中加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    RegisterServices(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.GetType().Assembly, services); &lt;span&gt;return&lt;/span&gt;&lt;span&gt; services.BuildAspectCoreServiceProvider();
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterServices(Assembly asm, IServiceCollection services)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历程序集中的所有public类型&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (Type type &lt;span&gt;in&lt;/span&gt;&lt;span&gt; asm.GetExportedTypes())
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断类中是否有标注了CustomInterceptorAttribute的方法&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; hasCustomInterceptorAttr = type.GetMethods().Any(m =&amp;gt; m.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(CustomInterceptorAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasCustomInterceptorAttr)
        {
            services.AddSingleton(type);
        }
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注：此文章是我看杨中科老师的&lt;a&gt;.Net Core微服务第二版和&lt;/a&gt;&lt;a&gt;.Net Core微服务第二版课件整理出来的&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jun 2018 07:22:00 +0000</pubDate>
<dc:creator>情话布墨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qhbm/p/9229301.html</dc:identifier>
</item>
<item>
<title>RabbitMQ入门：主题路由器(Topic Exchange) - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/9229007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/9229007.html</guid>
<description>&lt;p&gt;上一篇博文中，我们使用direct exchange 代替了fanout exchange，这次我们来看下topic exchange。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Topic Exchange介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;topic exchange和direct exchange类似，都是通过routing key和binding key进行匹配，不同的是topic exchange可以为routing key设置多重标准。&lt;/p&gt;
&lt;p&gt;direct路由器类似于sql语句中的精确查询；topic 路由器有点类似于sql语句中的模糊查询。&lt;/p&gt;
&lt;p&gt;还记得吗？我们在《&lt;a href=&quot;https://www.cnblogs.com/sam-uncle/p/9208008.html&quot; target=&quot;_blank&quot;&gt;RabbitMQ入门：发布/订阅（Publish/Subscribe）&lt;/a&gt;》中对exchange的分类进行过介绍：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Direct：完全根据key进行投递的，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。
&lt;strong&gt;Topic：对key进行模式匹配后进行投递，符号”#”匹配一个或多个词，符号”&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;”只匹配”abc.def”。&lt;/strong&gt;
Fanout：不需要key，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。
Headers:我们可以不考虑它。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是官网给出的工作模型（P代表生产者，X代表exhange，红色的Q代表队列，C代表消费者）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180626143102259-1916971308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来分析下这个模型。&lt;/p&gt;
&lt;p&gt;它发送的消息是用来描述动物的。路由键有三个单词：&amp;lt;speed&amp;gt;.&amp;lt;color&amp;gt;.&amp;lt;species&amp;gt;,第一个单词描述了速度，第二个描述了颜色，第三个描述了物种。&lt;br/&gt;有三个绑定键，Q1绑定键为*.orange.*（关注所有颜色为orange的动物）； Q2的绑定键有两个，分别是*.*.rabbit（关注所有的兔子）和lazy.#（关注所有速度为lazy的动物）。&lt;/p&gt;
&lt;p&gt;因此，路由键为quick.orange.rabbit的消息将发送到Q1和Q2，路由键为quick.orange.fox的消息将发送到Q1，路由键为lazy.brown.fox的消息将发送到Q2。路由键为lazy.pink.rabbit的消息将发送到Q2，但是注意，它只会到达Q2一次，尽管它匹配了两个绑定键。路由键为quick.brown.fox的消息因为不和任意的绑定键匹配，所以将会被丢弃。&lt;/p&gt;
&lt;p&gt;如果有人手一抖发了个lazy.orange.male.rabbit这种四个单词的，这个怎么办呢？ 由于它和lazy.#匹配，因此将发送到Q2。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、代码示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看下代码&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;3&quot;&gt;生产者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogTopicSender {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exchange名字&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String EXCHANGE_NAME = &quot;topicExchange&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建连接和通道&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.为通道声明topic类型的exchange&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.发送消息到指定的exchange,队列指定为空,由exchange根据情况判断需要发送到哪些队列&lt;/span&gt;
            String routingKey = &quot;info&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String routingKey = &quot;log4j.error&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String routingKey = &quot;logback.error&quot;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String routingKey = &quot;log4j.warn&quot;;&lt;/span&gt;
            String msg = &quot; hello rabbitmq, I am &quot; +&lt;span&gt; routingKey;
            channel.basicPublish(EXCHANGE_NAME, routingKey, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, msg.getBytes());
            System.out.println(&lt;/span&gt;&quot;product send a msg: &quot; +&lt;span&gt; msg);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.关闭连接&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;消费者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogTopicReciver {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建连接和通道&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.为通道声明topic类型的exchange&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(LogTopicSender.EXCHANGE_NAME, BuiltinExchangeType.TOPIC);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.创建随机名字的队列&lt;/span&gt;
            String queueName =&lt;span&gt; channel.queueDeclare().getQueue();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.建立exchange和队列的绑定关系&lt;/span&gt;
            String[] bindingKeys = { &quot;#&quot;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String[] bindingKeys = { &quot;log4j.*&quot;, &quot;#.error&quot; };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String[] bindingKeys = { &quot;*.error&quot; };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            String[] bindingKeys = { &quot;log4j.warn&quot; };&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; bindingKeys.length; i++&lt;span&gt;) {
                channel.queueBind(queueName, LogTopicSender.EXCHANGE_NAME, bindingKeys[i]);
                System.out.println(&lt;/span&gt;&quot; **** LogTopicReciver keep alive ,waiting for &quot; +&lt;span&gt; bindingKeys[i]);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.通过回调生成消费者并进行监听&lt;/span&gt;
            Consumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleDelivery(String consumerTag, Envelope envelope,
                        com.rabbitmq.client.AMQP.BasicProperties properties, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取消息内容然后处理&lt;/span&gt;
                    String msg = &lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;*********** LogTopicReciver&quot; + &quot; get message :[&quot; + msg + &quot;]&quot;&lt;span&gt;);
                }
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6.消费消息&lt;/span&gt;
            channel.basicConsume(queueName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, consumer);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;启动消费者，作为消费者1&lt;/li&gt;
&lt;li&gt;分别将String[] bindingKeys = { &quot;#&quot; };改为String[] bindingKeys = { &quot;log4j.*&quot;, &quot;#.error&quot; };/String[] bindingKeys = { &quot;*.error&quot; };/String[] bindingKeys = { &quot;log4j.warn&quot; };，然后启动作为消费者2、消费者3、消费者4&lt;/li&gt;
&lt;li&gt;启动4次生产者，routing key分别为String routingKey = &quot;info&quot;;、String routingKey = &quot;log4j.error&quot;;、String routingKey = &quot;logback.error&quot;;、String routingKey = &quot;log4j.warn&quot;;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;观察控制台log
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;生产者：
product send a msg:  hello rabbitmq, I am info
product send a msg:  hello rabbitmq, I am log4j.error
product send a msg:  hello rabbitmq, I am logback.error
product send a msg:  hello rabbitmq, I am log4j.warn

消费者1：
 &lt;/span&gt;**** LogTopicReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am info]
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am log4j.error]
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am logback.error]
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am log4j.warn]

消费者2：
 &lt;/span&gt;**** LogTopicReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt; log4j.*
 **** LogTopicReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; #.error
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am log4j.error]&lt;br/&gt;*********** LogTopicReciver get message :[ hello rabbitmq, I am logback.error]
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am log4j.warn]

消费者3：
 &lt;/span&gt;**** LogTopicReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt; *&lt;span&gt;.error
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am log4j.error]
&lt;/span&gt;***********&lt;span&gt; LogTopicReciver get message :[ hello rabbitmq, I am logback.error]

消费者4：
 &lt;/span&gt;**** LogTopicReciver keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; log4j.warn
&lt;/span&gt;*********** LogTopicReciver get message :[ hello rabbitmq, I am log4j.warn]
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;观察RabbitMQ管理页面&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180626150822185-1164316394.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180626150844734-1723803368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180626150900627-1888846261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 26 Jun 2018 07:13:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/9229007.html</dc:identifier>
</item>
<item>
<title>微信小程序之wepy自动化架构搭建（fly+wepy-plugin-replace） - 隔壁家的老黄</title>
<link>http://www.cnblogs.com/ychl/p/9229201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ychl/p/9229201.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文章秉着自动化工程项目的思想搭建的，基础架子完全按照&lt;a href=&quot;https://tencent.github.io/wepy/document.html#/&quot;&gt;wepy官网&lt;/a&gt;搭建，在基础上增加配置达到自动化项目。新增动flxio拦截器自动处理接口，新增根据环境变量来改变运行时的参数。&lt;/p&gt;

&lt;p&gt;小程序拦截器个人不是很满意，在网上就寻找到了fly.js &lt;a href=&quot;mailto:感谢作者大大@wendux&quot;&gt;感谢作者大大@wendux&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;一个支持所有JavaScript运行环境的基于Promise的、支持请求转发、强大的http请求库。可以让您在多个端上尽可能大限度的实现代码复用，它有如下特点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install flyio --save&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增staticEnv.js 配置接口种类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const base = &quot;/api-login&quot;
const common = &quot;/api-common&quot;
const elevator = &quot;/api-elevator&quot;
const workorder = &quot;/api-workorder&quot;
const device = &quot;/api-device&quot;
const authcontract = &quot;/api-auth-contract&quot;
const contract = &quot;/api-contract&quot;
const events = &quot;/api-events&quot;
export {
  base,
  common,
  elevator,
  workorder,
  device,
  authcontract,
  contract,
  events
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增错误代码判断errorCode.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Tips from './Tips';

export function errorCodeHandler(errorcode, message) {
  switch (errorcode) {
  case 13001:
    Tips.alert('注册时未填写公司信息！');
    break;
  case 31001:
    Tips.alert('公司待审核！');
    break;
  case 13004:
    Tips.alert('公司待审核！');
    break;
  case 13005:
    Tips.alert('公司待审核！');
    break;
    //登录超时errorCodeHandler
  case 12009:
    Tips.alert(message);
    wx.navigateTo({
      url: '/pages/login/index'
    });
    break;
  case 3008:
    Tips.alert(message);
    wx.navigateTo({
      url: '/pages/login/index'
    });
    break;
  default:
    if (message) {
      Tips.alert(message);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增http.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
import Fly from 'flyio/dist/npm/wx' //npm引入方式
import { base, common, elevator, workorder, device, authcontract, contract, events } from '../api/staticEnv'
import Tips from './Tips';
import { errorCodeHandler } from './errorCode'
//创建fly实例
const fly = new Fly()

//配置请求baseURL
fly.config.baseURL = BASE_API

//添加请求拦截器
fly.interceptors.request.use((config) =&amp;gt; {
  Tips.loading();
  // 判断是否存在token，如果存在的话，则每个http header都加上token
  const token = wx.getStorageSync('token')
  if (token) {
    config.headers.tokenStr = token;
  }
  // 统一添加接口种类  &quot;http://api.p1.ettda.com/api-login&quot;
  switch (config.proxy) {
  case 'base':
    config.url = base + config.url;
    break;
  case 'common':
    config.url = common + config.url;
    break;
  case 'elevator':
    config.url = elevator + config.url;
    break;
  case 'workorder':
    config.url = workorder + config.url;
    break;
  case 'device':
    config.url = device + config.url;
    break;
  case 'authcontract':
    config.url = authcontract + config.url;
    break;
  case 'contract':
    config.url = contract + config.url;
    break;
  case 'events':
    config.url = events + config.url;
    break;
  default:
    break;
  }
  return config;
})

//添加响应拦截器，响应拦截器会在then/catch处理之前执行
fly.interceptors.response.use(
  response =&amp;gt; {
    Tips.loaded();
    //返回错误代码处理前端页面提示
    if (response.data.code != 0) {
      errorCodeHandler(response.data.code, response.data.message);
      return Promise.reject(response.data)
    }
    return response.data;
  },
  error =&amp;gt; {
    if (error.response) {
      Tips.error('出错啦,请稍后再试！')
    }
    return Promise.reject(error); // 返回接口返回的错误信息
  });


export default fly;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import fly from '@/utils/http'
import qs from 'qs'

const config = {
  proxy: 'base' // 接口种类
};

export async function requestLogin(params) {
  return await fly.post('/login', qs.stringify(params), config)
}
&amp;lt;!--wpy文件调用--&amp;gt;

requestLogin({
    username: 'username',
    password: 'password'
}).then(res =&amp;gt; {
    console.log(res);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的fly拦截器我们就完成l，主要公司业务接口毕竟多，我的想法就是模块化每个api种类来维护，使用拦截器就很好的组装接口，节省大家开发时间和减少重复工作。&lt;/p&gt;

&lt;p&gt;为 plugins 添加 replace 对象，支持单个或者多个规则，多个规则可以以 Array 或者 Object 实现，filter 的对象为生成后文件的路径， 例如'dist/app.js'，每个规则也同时支持多个替换条目，同样是以 Array 或者 Object 实现。&lt;/p&gt;
&lt;h3 id=&quot;简介-1&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;多环境对于每个公司来说都是需要的，测试环境，正式环境等等。以前我们都是每次发布时候都手动修改api接口地址，可这样的重复无聊的工作我们就应该交给工具来实现。我们要有一个工程化的思想去构建整个项目，减少小伙伴在开发中遇到的无趣工作和节约他们的时间。所以我寻找到了上面的wepy-plugin-replace插件。&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;wepy.config.js中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;plugins: {
    replace: {
      filter: /\.js$/,
      config: {
        find: /BASE_API/,
        replace: function (matchs, word) {
            return process.env.NODE_ENV === 'production' ? '&quot;https://api.a.com/&quot;' : '&quot;https://api.a.com/dev/&quot;'
        }
      }
    }
}

//if判断中也需要新增
if (prod) {
    module.exports.plugins = {
        replace: {
          filter: /\.js$/,
          config: {
            find: /BASE_API/,
            replace: function (matchs, word) {
                return process.env.NODE_ENV === 'production' ? '&quot;https://api.a.com/&quot;' : '&quot;https://api.a.com/dev/&quot;'
            }
          }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;package.json中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;dev&quot;: &quot;cross-env NODE_ENV=development env_config=dev wepy build --watch&quot;,
&quot;build&quot;: &quot;cross-env NODE_ENV=production env_config=test wepy build --no-cache&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-1&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;npm run dev或者npm run build。插件就会自动匹配BASE_API然后替换成当前env_config匹配的api接口地址。在http.js中就简单的提现了，同时你也可以使用到其他方式上,&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;前端工程化是前端架构中重要的一环，主要就是为了解决如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量。所以这个文章同样适用于其他地方，希望文章能帮到大家。本人搭建的wepy整体项目已托管到&lt;a href=&quot;https://github.com/huanglong6828/wepy-automation&quot;&gt;github&lt;/a&gt;上，对你有帮助给star&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jun 2018 07:07:00 +0000</pubDate>
<dc:creator>隔壁家的老黄</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ychl/p/9229201.html</dc:identifier>
</item>
<item>
<title>DSSM：深度语义匹配模型（及其变体CLSM、LSTM-DSSM） - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/9229190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/9229190.html</guid>
<description>&lt;p&gt;在NLP领域，语义相似度的计算一直是个难题：搜索场景下Query和Doc的语义相似度、feeds场景下Doc和Doc的语义相似度、机器翻译场景下A句子和B句子的语义相似度等等。本文通过介绍DSSM、CNN-DSSM、LSTM-DSSM等深度学习模型在计算语义相似度上的应用，希望给读者带来帮助。&lt;/p&gt;

&lt;p&gt;以搜索引擎和搜索广告为例，最重要的也最难解决的问题是语义相似度，这里主要体现在两个方面：召回和排序。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;召回&lt;/strong&gt;时，传统的文本相似性如 BM25，无法有效发现语义类 Query-Doc 结果对，如&quot;从北京到上海的机票&quot;与&quot;携程网&quot;的相似性、&quot;快递软件&quot;与&quot;菜鸟裹裹&quot;的相似性。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;排序&lt;/strong&gt;时，一些细微的语言变化往往带来巨大的语义变化，如&quot;小宝宝生病怎么办&quot;和&quot;狗宝宝生病怎么办&quot;、&quot;深度学习&quot;和&quot;学习深度&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DSSM（Deep Structured Semantic Models）&lt;/strong&gt; 为计算语义相似度提供了一种思路。&lt;/p&gt;
&lt;p&gt;本文的最后，笔者结合自身业务，对 DSSM 的使用场景做了一些总结，不是所有的业务都适合用 DSSM。&lt;/p&gt;

&lt;p&gt;DSSM [1]（Deep Structured Semantic Models）的原理很简单，通过搜索引擎里 Query 和 Title 的海量的点击曝光日志，用 DNN 把 Query 和 Title 表达为低维语义向量，并通过 cosine 距离来计算两个语义向量的距离，最终训练出语义相似度模型。该模型既可以用来&lt;strong&gt;预测两个句子的语义相似度&lt;/strong&gt;，又可以&lt;strong&gt;获得某句子的低维语义向量表达&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;DSSM 从下往上可以分为三层结构：&lt;strong&gt;输入层、表示层、匹配层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626112503455-1656332124.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;输入层&quot;&gt;2.1 输入层&lt;/h2&gt;
&lt;p&gt;输入层做的事情是把句子映射到一个向量空间里并输入到 DNN 中，这里&lt;strong&gt;英文和中文的处理方式有很大的不同&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;英文&quot;&gt;（1）英文&lt;/h3&gt;
&lt;p&gt;英文的输入层处理方式是通过&lt;strong&gt;Word Hashing&lt;/strong&gt;。举个例子，假设用 letter-trigams 来切分单词（3 个字母为一组，#表示开始和结束符），boy 这个单词会被切为 #-b-o, b-o-y, o-y-#&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626112749594-655625141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样做的好处有两个：首先是&lt;strong&gt;压缩空间&lt;/strong&gt;，50 万个词的 one-hot 向量空间可以通过 letter-trigram 压缩为一个 3 万维的向量空间。其次是&lt;strong&gt;增强范化能力&lt;/strong&gt;，三个字母的表达往往能代表英文中的前缀和后缀，而前缀后缀往往具有通用的语义。&lt;/p&gt;
&lt;p&gt;这里之所以用 3 个字母的切分粒度，是综合考虑了&lt;strong&gt;向量空间&lt;/strong&gt;和&lt;strong&gt;单词冲突&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626112953845-424731613.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以 50 万个单词的词库为例，2 个字母的切分粒度的单词冲突为 1192（冲突的定义：至少有两个单词的 letter-bigram 向量完全相同），而 3 个字母的单词冲突降为 22 效果很好，且转化后的向量空间 3 万维不是很大，综合考虑选择 3 个字母的切分粒度。&lt;/p&gt;
&lt;h2 id=&quot;中文&quot;&gt;（2）中文&lt;/h2&gt;
&lt;p&gt;中文的输入层处理方式与英文有很大不同，首先中文&lt;strong&gt;分词&lt;/strong&gt;是个让所有 NLP 从业者头疼的事情，即便业界号称能做到 95%左右的分词准确性，但分词结果极为不可控，往往会在分词阶段引入误差。所以这里我们不分词，而是仿照英文的处理方式，对应到中文的最小粒度就是单字了。（曾经有人用偏旁部首切的，感兴趣的朋友可以试试）&lt;/p&gt;
&lt;p&gt;由于&lt;strong&gt;常用的单字为 1.5 万左右&lt;/strong&gt;，而常用的双字大约到百万级别了，所以这里出于向量空间的考虑，采用字向量（one-hot）作为输入，向量空间约为 1.5 万维。&lt;/p&gt;
&lt;h2 id=&quot;表示层&quot;&gt;2.2 表示层&lt;/h2&gt;
&lt;p&gt;DSSM 的表示层采用 BOW(Bag of words)的方式，相当于把字向量的位置信息抛弃了，整个句子里的词都放在一个袋子里了，不分先后顺序。当然这样做会有问题，我们先为 CNN-DSSM 和 LSTM-DSSM 埋下一个伏笔。紧接着是一个含有多个隐层的 DNN，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626114115273-1341400749.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用 Wi 表示第 i 层的权值矩阵，bi 表示第 i 层的 bias 项。则第一隐层向量 l1（300 维），第 i 个隐层向量 li（300 维），输出向量 y（128 维）可以分别表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626114155532-320916178.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用 tanh 作为隐层和输出层的激活函数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626114208907-2004338612.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终输出一个 128 维的低纬语义向量。&lt;/p&gt;
&lt;h2 id=&quot;匹配层&quot;&gt;2.3 匹配层&lt;/h2&gt;
&lt;p&gt;Query 和 Doc 的语义相似性可以用这&lt;strong&gt;两个语义向量(128 维) 的 cosine 距离(即余弦相似度)&lt;/strong&gt; 来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626114325996-933995981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;strong&gt;softmax&lt;/strong&gt; 函数可以把 Query 与正样本 Doc 的语义相似性转化为一个后验概率：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626114355996-2004042576.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 r 为 softmax 的平滑因子，D 为 Query 下的正样本，D-为 Query 下的负样本（采取随机负采样），D 为 Query 下的整个样本空间。&lt;/p&gt;
&lt;p&gt;在训练阶段，通过&lt;strong&gt;极大似然估计&lt;/strong&gt;，我们最小化损失函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626114521129-1359454939.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;残差会在表示层的 DNN 中反向传播，最终通过随机梯度下降（SGD）使模型收敛，得到各网络层的参数{Wi,bi}。&lt;/p&gt;
&lt;h2 id=&quot;优缺点&quot;&gt;2.4 优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br/&gt;DSSM 用字向量作为输入既可以&lt;strong&gt;减少切词的依赖&lt;/strong&gt;，又可以提高模型的范化能力，因为每个汉字所能表达的语义是可以复用的。另一方面，传统的输入层是用 Embedding 的方式（如 Word2Vec 的词向量）或者主题模型的方式（如 LDA 的主题向量）来直接做词的映射，再把各个词的向量累加或者拼接起来，由于 Word2Vec 和 LDA 都是&lt;strong&gt;无监督的训练&lt;/strong&gt;，这样&lt;strong&gt;会给整个模型引入误差&lt;/strong&gt;，&lt;strong&gt;DSSM 采用统一的有监督训练，不需要在中间过程做无监督模型的映射，因此精准度会比较高。&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br/&gt;上文提到 DSSM 采用词袋模型（BOW），因此丧失了语序信息和上下文信息。另一方面，DSSM 采用弱监督、端到端的模型，预测结果不可控。&lt;/p&gt;

&lt;p&gt;针对 DSSM 词袋模型丢失上下文信息的缺点，&lt;strong&gt;CLSM&lt;/strong&gt;[2]（convolutional latent semantic model）应运而生，又叫 CNN-DSSM。CNN-DSSM 与 DSSM 的区别主要在于输入层和表示层。&lt;/p&gt;
&lt;h2 id=&quot;输入层-1&quot;&gt;3.1 输入层&lt;/h2&gt;
&lt;h3 id=&quot;英文-1&quot;&gt;（1）英文&lt;/h3&gt;
&lt;p&gt;英文的处理方式，除了上文提到的 letter-trigram，CNN-DSSM 还在输入层增加了word-trigram&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626115519589-62330508.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如上图所示，word-trigram其实就是一个包含了上下文信息的滑动窗口。&lt;/strong&gt; 举个例子：把&amp;lt;&lt;code&gt;s&lt;/code&gt;&amp;gt; online auto body ... &amp;lt;&lt;code&gt;s&lt;/code&gt;&amp;gt;这句话提取出前三个词&amp;lt;&lt;code&gt;s&lt;/code&gt;&amp;gt; online auto，之后再 &lt;strong&gt;==分别对==这三个词进行 letter-trigram 映射到一个 3 万维的向量空间里，然后把三个向量 concat 起来，最终映射到一个 9 万维的向量空间里。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;中文-1&quot;&gt;（2）中文&lt;/h3&gt;
&lt;p&gt;英文的处理方式（word-trigram letter-trigram）在中文中并不可取，因为英文中虽然用了 word-ngram 把样本空间拉成了百万级，但是经过 letter-trigram 又把向量空间降到可控级别，只有 3&lt;code&gt;*&lt;/code&gt;30K（9 万）。而中文如果用 word-trigram，那向量空间就是百万级的了，显然还是字向量（1.5 万维）比较可控。&lt;/p&gt;
&lt;h2 id=&quot;表示层-1&quot;&gt;3.2 表示层&lt;/h2&gt;
&lt;p&gt;CNN-DSSM 的表示层由一个卷积神经网络组成，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626140527022-278090599.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;卷积层convolutional-layer&quot;&gt;（1）卷积层——Convolutional layer&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;卷积层的作用是提取滑动窗口下的上下文特征。&lt;/strong&gt; 以下图为例，假设输入层是一个 302&lt;code&gt;*&lt;/code&gt;90000（302 行，9 万列）的矩阵，代表 302 个字向量（Query 的和 Doc 的长度一般小于 300，这里少了就补全，多了就截断），每个字向量有 9 万维。而卷积核是一个 3&lt;code&gt;*&lt;/code&gt;90000 的权值矩阵，卷积核以步长为 1 向下移动，得到的 feature map 是一个 300&lt;code&gt;*&lt;/code&gt;1 的矩阵，feature map 的计算公式是(输入层维数 302-卷积核大小 3 步长 1)/步长 1=300。而这样的卷积核有 300 个，所以形成了 300 个 300&lt;code&gt;*&lt;/code&gt;1 的 feature map 矩阵。&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1501555869244_9824_1501555870293.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;根据论文原文也可以这样理解&quot;&gt;&lt;strong&gt;根据论文原文也可以这样理解：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;每个英文单词经过 word hash 之后都可以由一个30K大小的向量表示，我们的卷积可以理解为一维卷积，窗口大小为3，即将待卷积部分三个单词拼接成一个90K的向量，而卷积核为一个 90K&lt;code&gt;*&lt;/code&gt;300 的矩阵，每次卷积输出一个 1&lt;code&gt;*&lt;/code&gt;300 的向量。&lt;/p&gt;
&lt;h3 id=&quot;池化层max-pooling-layer&quot;&gt;（2）池化层——Max pooling layer&lt;/h3&gt;
&lt;p&gt;池化层的作用是为句子找到&lt;strong&gt;全局的上下文特征&lt;/strong&gt;。池化层以 Max-over-time pooling 的方式，每个 feature map 都取最大值，得到一个 300 维的向量。Max-over-pooling 可以解决可变长度的句子输入问题（因为不管 Feature Map 中有多少个值，只需要提取其中的最大值）。不过我们在上一步已经做了句子的定长处理（固定句子长度为 302），所以就没有可变长度句子的问题。最终池化层的输出为各个 Feature Map 的最大值，即一个 300&lt;code&gt;*&lt;/code&gt;1 的向量。这里多提一句，之所以 Max pooling 层要保持固定的输出维度，是因为下一层全链接层要求有固定的输入层数，才能进行训练。&lt;/p&gt;
&lt;h3 id=&quot;全连接层semantic-layer&quot;&gt;（3）全连接层——Semantic layer&lt;/h3&gt;
&lt;p&gt;最后通过全连接层把一个 300 维的向量转化为一个 128 维的低维语义向量。全连接层采用 tanh 函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626142550814-1252382231.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;匹配层-1&quot;&gt;3.3 匹配层&lt;/h2&gt;
&lt;p&gt;CNN-DSSM 的匹配层和 DSSM 的一样，这里省略。&lt;/p&gt;
&lt;h2 id=&quot;优缺点-1&quot;&gt;3.4 优缺点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CNN-DSSM 通过卷积层提取了==滑动窗口下的上下文信息==，又通过池化层提取了==全局的上下文信息==，上下文信息得到较为有效的保留。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于间隔较远的上下文信息，难以有效保留。&lt;/strong&gt; 举个例子，I grew up in France... I speak fluent French，显然 France 和 French 是具有上下文依赖关系的，但是由于 CNN-DSSM 滑动窗口（卷积核）大小的限制，导致无法捕获该上下文信息。&lt;/p&gt;

&lt;p&gt;针对 CNN-DSSM 无法捕获较远距离上下文特征的缺点，有人提出了用&lt;strong&gt;LSTM-DSSM&lt;/strong&gt;[3]（Long-Short-Term Memory）来解决该问题。不过说 LSTM 之前，要先介绍它的&quot;爸爸&quot;&quot;RNN。&lt;/p&gt;
&lt;h2 id=&quot;rnn&quot;&gt;4.1 RNN&lt;/h2&gt;
&lt;p&gt;RNN（Recurrent Neural Networks）可以被看做是同一神经网络的多次复制，每个神经网络模块会把消息传递给下一个。如果我们将这个循环展开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626142910077-895842182.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设输入 xi 为一个 Query 中几个连续的词，hi 为输出。那么上一个神经元的输出 h(t-1) 与当前细胞的输入 Xt 拼接后经过 tanh 函数会输出 ht，同时把 ht 传递给下一个细胞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626143131248-798300031.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不幸的是，在这个间隔不断增大时，RNN 会逐渐丧失学习到远距离信息的能力。因为 RNN 随着距离的加长，会导致&lt;strong&gt;梯度消失&lt;/strong&gt;。简单来说，&lt;strong&gt;由于求导的链式法则，直接导致梯度被表示为连乘的形式，以至梯度消失（几个小于 1 的数相乘会逐渐趋向于 0）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;lstm&quot;&gt;4.2 LSTM&lt;/h2&gt;
&lt;p&gt;LSTM[4](（Long-Short-Term Memory）是一种 RNN 特殊的类型，可以学习长期依赖信息。我们分别来介绍它最重要的几个模块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626143253896-687816956.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;细胞状态&quot;&gt;（0）细胞状态&lt;/h3&gt;
&lt;p&gt;细胞状态这条线可以理解成是一条信息的传送带，只有一些少量的线性交互。在上面流动可以保持信息的不变性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626143339469-1032589589.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;遗忘门&quot;&gt;（1）遗忘门&lt;/h3&gt;
&lt;p&gt;遗忘门[5]由 Gers 提出，它用来控制细胞状态 cell 有哪些信息可以通过，继续往下传递。如下图所示，上一层的输出 h(t-1) concat 上本层的输入 xt，经过一个 sigmoid 网络（遗忘门）产生一个从 0 到 1 的数值 ft，然后与细胞状态 C(t-1) 相乘，最终决定有多少细胞状态可以继续往后传递。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626145124011-729475638.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;输入门&quot;&gt;（2）输入门&lt;/h3&gt;
&lt;p&gt;输入门决定要新增什么信息到细胞状态，这里包含两部分：一个 sigmoid 输入门和一个 tanh 函数。sigmoid 决定输入的信号控制，tanh 决定输入什么内容。如下图所示，上一层的输出 h(t-1) concat 上本层的输入 xt，经过一个 sigmoid 网络（输入门）产生一个从 0 到 1 的数值 it，同样的信息经过 tanh 网络做非线性变换得到结果 Ct，sigmoid 的结果和 tanh 的结果相乘，最终决定有哪些信息可以输入到细胞状态里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626145222297-1196511539.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;输出门&quot;&gt;（3）输出门&lt;/h3&gt;
&lt;p&gt;输出门决定从细胞状态要输出什么信息，这里也包含两部分：一个 sigmoid 输出门和一个 tanh 函数。sigmoid 决定输出的信号控制，tanh 决定输出什么内容。如下图所示，上一层的输出 h(t-1) concat 上本层的输入 xt，经过一个 sigmoid 网络（输出门）产生一个从 0 到 1 的数值 Ot，细胞状态 Ct 经过 tanh 网络做非线性变换，得到结果再与 sigmoid 的结果 Ot 相乘，最终决定有哪些信息可以输出，输出的结果 ht 会作为这个细胞的输出，也会作为传递个下一个细胞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626145256491-2142349187.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lstm-dssm-1&quot;&gt;4.2 LSTM-DSSM&lt;/h2&gt;
&lt;p&gt;LSTM-DSSM 其实用的是 LSTM 的一个变种——加入了&lt;strong&gt;peep hole&lt;/strong&gt;[6]的 LSTM。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626145411188-1989417089.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来有点复杂，我们换一个图，读者可以看的更清晰：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626145456387-2019106774.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里三条黑线就是所谓的 peephole，传统的 LSTM 中遗忘门、输入门和输出门只用了 h(t-1) 和 xt 来控制门缝的大小，peephole 的意思是说不但要考虑 h(t-1) 和 xt，也要考虑 Ct-1 和 Ct，其中遗忘门和输入门考虑了 Ct-1，而输出门考虑了 Ct。&lt;/strong&gt; 总体来说需要考虑的信息更丰富了。&lt;/p&gt;
&lt;p&gt;好了，来看一个 LSTM-DSSM 整体的网络结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201806/1192699-20180626145633105-438365884.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红色的部分可以清晰的看到残差传递的方向。&lt;/p&gt;

&lt;p&gt;介绍完了 DSSM 及其几个变种，还要给读者泼点冷水，DSSM 就一定适合所有的业务吗？&lt;/p&gt;
&lt;p&gt;这里列出 DSSM 的 2 个缺点以供参考：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;DSSM 是端到端的模型&lt;/strong&gt; ，虽然省去了人工特征转化、特征工程和特征组合，但&lt;strong&gt;端到端的模型有个问题就是效果不可控&lt;/strong&gt;。对于一些要保证较高的准确率的场景，用有监督人工标注的 Query 分类作为打底，再结合无监督的 Word2Vec、LDA 等进行语义特征的向量化，显然比较可控（至少 Query 分类的准确率可以达到 95% 以上）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;DSSM 是弱监督模型&lt;/strong&gt;，因为引擎的点击曝光日志里 Query 和 Title 的语义信息比较弱。举个例子，搜索引擎第一页的信息往往都是 Query 的包含匹配，笔者统计过，完全的语义匹配只有不到 2%。这就意味着几乎所有的标题里都包含用户 Query 里的关键词，而仅用点击和曝光就能作为正负样例的判断？显然不太靠谱，因为大部分的用户进行点击时越靠前的点击的概率越大，而引擎的排序又是由 pCTR、CVR、CPC 等多种因素决定的。从这种非常弱的信号里提取出语义的相似性或者差别，那就&lt;strong&gt;需要有海量的训练样本&lt;/strong&gt;。DSSM 论文中提到，实验的训练样本超过 1 亿。笔者和同事也亲测过，用传统 CTR 预估模型千万级的样本量来训练，模型无法收敛。可是这样海量的训练样本，恐怕只有搜索引擎才有吧？普通的搜索业务 Query 有上千万，可资源顶多只有几百万，像论文中说需要挑出点击和曝光置信度比较高且资源热度也比较高的作为训练样本，这样就过滤了 80% 的长尾 Query 和 Title 结果对，所以也只有搜索引擎才有这样的训练语料了吧。另一方面，超过 1 亿的训练样本作为输入，用深度学习模型做训练，需要大型的 GPU 集群，这个对于很多业务来说也是不具备的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[1]. Huang P S, He X, Gao J, et al. Learning deep structured semantic models for web search using clickthrough data[C]// ACM International Conference on Conference on Information &amp;amp; Knowledge Management. ACM, 2013:2333-2338.&lt;/p&gt;
&lt;p&gt;[2]. Shen, Yelong, et al. &quot;A latent semantic model with convolutional-pooling structure for information retrieval.&quot; Proceedings of the 23rd ACM International Conference on Conference on Information and Knowledge Management. ACM, 2014.&lt;/p&gt;
&lt;p&gt;[3]. Palangi, Hamid, et al. &quot;Semantic modelling with long-short-term memory for information retrieval.&quot; arXiv preprint arXiv:1412.6629 2014.&lt;/p&gt;
&lt;p&gt;[4]. Hochreiter, Sepp and Schmidhuber, J¨urgen. Long short-term memory. Neural Comput., 9(8):1735–1780, November 1997.&lt;/p&gt;
&lt;p&gt;[5]. Gers, Felix A., Schmidhuber, Jrgen, and Cummins, Fred. Learning to forget: Continual prediction with lstm. Neural Computation, 12:2451–2471, 1999.&lt;/p&gt;
&lt;p&gt;[6]. Gers, Felix A., Schraudolph, Nicol N., and Schmidhuber, J¨urgen. Learning precise timing with lstm recurrent networks. J. Mach. Learn. Res., 3:115–143, March 2003.&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jun 2018 07:06:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/9229190.html</dc:identifier>
</item>
<item>
<title>Spring的事件机制详解 - 醉眼识朦胧</title>
<link>http://www.cnblogs.com/fingerboy/p/9229164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fingerboy/p/9229164.html</guid>
<description>&lt;h2&gt;同步事件和异步事件&lt;/h2&gt;
&lt;p&gt;　　同步事件:在一个线程里,按顺序执行业务,做完一件事再去做下一件事.&lt;/p&gt;
&lt;p&gt;      异步事件:在一个线程里,做一个事的同事,可以另起一个新的线程执行另一件事,这样两件事可以同时执行.&lt;/p&gt;
&lt;p&gt;　　用一个例子来解释同步事件和异步事件的使用场景,有时候一段完整的代码逻辑,可能分为几部分,拿最常见的注册来说,假设完整流程是,1.点击注册-&amp;gt;2.检验信息并存库-&amp;gt;3.发送邮件通知-&amp;gt;4.返回给用户.代码这么写是正确,但不是最好的,缺点如下:&lt;/p&gt;
&lt;p&gt;         　1.逻辑复杂,业务耦合,我们把校验数据并存库和发送邮件写到一个大的业务方法里了,发邮件我们可以看做一个相对独立的业务方法&lt;/p&gt;
&lt;p&gt;　　　　2.效率低,假设2和3分别需要1秒的时候,那么用户在点击注册2秒后才能看到相应&lt;/p&gt;
&lt;p&gt;　　同步事件可以解决上面第一个问题,我们把发邮件的方法独立出来,放到事件里执行,这样注册的这个方法就可以只做2操作,完成之后发布一个事件去执行3,可以很好的解决业务耦合的问题.&lt;/p&gt;
&lt;p&gt;　  异步事件可以完美解决以上两个问题,注册方法执行2操作,执行之后发布一个异步事件,另起一个线程执行3操作,注册方法所在的线程可直接返回给用户,这样不仅实现了业务解耦还提高了效率,用户点击注册,1秒后就能看到响应.&lt;/p&gt;
&lt;h2&gt;Spring的事件机制&lt;/h2&gt;
&lt;p&gt;　　spring事件发送监听涉及3个部分&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;　　ApplicationEvent：表示事件本身，自定义事件需要继承该类,可以用来传递数据,比如上述操作,我们需要将用户的邮箱地址传给事件监听器.&lt;/h4&gt;
&lt;h4&gt;　　ApplicationEventPublisherAware：事件发送器,通过实现这个接口,来触发事件.&lt;/h4&gt;
&lt;h4&gt;　　ApplicationListener：事件监听器接口,事件的业务逻辑封装在监听器里面.&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　接下来使用spring的异步事件机制来模拟上面的注册流程.有配置文件和注解两种方式.&lt;/p&gt;
&lt;h2&gt;配置文件的方式:&lt;/h2&gt;
&lt;h3&gt;　　新建TestEvent:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestEvent &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ApplicationEvent {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TestParam source;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestEvent(TestParam source) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(source);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.source =&lt;span&gt; source;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestParam {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;新建TestListener:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestListener &lt;span&gt;implements&lt;/span&gt; ApplicationListener&amp;lt;TestEvent&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onApplicationEvent(TestEvent testEvent) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         TestParam param =&lt;span&gt; (TestParam) testEvent.getSource();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;.......开始.......&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;发送邮件:&quot;+&lt;span&gt;param.getEmail());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;.......结束.....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;新建EventPublisher:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestPublish &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplicationEventPublisherAware {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApplicationEventPublisher applicationEventPublisher;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        TestPublish.applicationEventPublisher &lt;/span&gt;=&lt;span&gt; applicationEventPublisher;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  publishEvent(ApplicationEvent communityArticleEvent) {
        applicationEventPublisher.publishEvent(communityArticleEvent);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;spring-context.xml中添加:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;applicationEventAsyncMulticaster&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.context.event.SimpleApplicationEventMulticaster&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;taskExecutor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;corePoolSize&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;keepAliveSeconds&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;3000&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maxPoolSize&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;50&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;queueCapacity&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意:如果加&amp;lt;propery name=&quot;taskExecutor&quot;,则使用异步方式执行,否则为同步方式&lt;/p&gt;
&lt;h2&gt;使用注解方式&lt;/h2&gt;
&lt;p&gt;　　使用@Async需要在配置文件添加一下支持,线程池也是需要配置一下的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 开启@AspectJ AOP代理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy &lt;/span&gt;&lt;span&gt;proxy-target-class&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 任务执行器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;task:executor &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;executor&quot;&lt;/span&gt;&lt;span&gt; pool-size&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;开启注解调度支持 @Async &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;task:annotation-driven &lt;/span&gt;&lt;span&gt;executor&lt;/span&gt;&lt;span&gt;=&quot;executor&quot;&lt;/span&gt;&lt;span&gt; proxy-target-class&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　TestListener中在方法中添加@Async&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestListener &lt;span&gt;implements&lt;/span&gt; ApplicationListener&amp;lt;TestEvent&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;strong&gt;&lt;span&gt;    @Async
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onApplicationEvent(TestEvent testEvent) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         TestParam param =&lt;span&gt; (TestParam) testEvent.getSource();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;.......开始.......&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;发送邮件:&quot;+&lt;span&gt;param.getEmail());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;.......结束.....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　Listener其实还可以做得更彻底一点,使用注解@EventListener可代替实现ApplicationListener,原理是通过扫描这个注解来创建监听器并自动添加到ApplicationContext中.&lt;/p&gt;
&lt;h3&gt;新建自定义EventHandler:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestEventHandler {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Async
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @EventListener
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleTestEvent(TestEvent testEvent) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         TestParam param =&lt;span&gt; (TestParam) testEvent.getSource();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;.......开始.......&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;发送邮件:&quot;+&lt;span&gt;param.getEmail());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;.......结束.....&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试及控制台的打印就不贴了,这里主要记录一下具体的实现方法.&lt;/p&gt;
&lt;h2&gt;总结:&lt;/h2&gt;
&lt;p&gt;　　使用spring事件机制能很好地帮助我们消除不同业务间的耦合关系,也可以提高执行效率,应该根据业务场景灵活选择.&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jun 2018 07:04:00 +0000</pubDate>
<dc:creator>醉眼识朦胧</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fingerboy/p/9229164.html</dc:identifier>
</item>
<item>
<title>没固定公网 IP 的公司内网实现动态域名解析（ 阿里云万网解析 ） - Dy1an</title>
<link>http://www.cnblogs.com/Dy1an/p/9229074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dy1an/p/9229074.html</guid>
<description>&lt;p&gt;&lt;span&gt;  &lt;strong&gt;情景说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;前段时间应公司需求，需要将内网的服务映射到公网。由于公司使用的是类似家庭宽带的线路，没有固定的公网 IP 地址，所以决定使用域名来完成。&lt;/p&gt;
&lt;p&gt;当时有几种方案：&lt;/p&gt;
&lt;p&gt;1、花生壳：但是目前需要乱七八糟的认证备案，舍弃！&lt;/p&gt;
&lt;p&gt;2、NAT123：花里胡哨的，感觉像垃圾软件，也舍弃！&lt;/p&gt;
&lt;p&gt;3、holer：GITHUB 上面的一个项目，但是我们只能安装 Client 端，Server 端在别人手里，不安全，舍弃！&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;还有其它的乱七八糟的很多，但是都觉得要么是 C/S 架构，麻烦。要么就是使用别人的，定制要么收费，要么不安全，也都放弃了，最后决定参考网上的 Python 调用阿里云 API 通过 Linux 定时任务来更新解析！&lt;/p&gt;


&lt;p&gt;&lt;span&gt;  &lt;strong&gt;网络拓扑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;简单的网络拓扑如下图： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979767/201806/979767-20180626134938299-2060755498.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;1、电信 ASDL 拨号，会有一个会变化的公网 IP 地址，我们的域名就是要解析到最新的该 IP 地址上面&lt;/p&gt;
&lt;p&gt;2、公司内网是一个路由器接交换机的方式，路由器比较 Low，H3C 的，简单的进行一个端口转发到指定的服务器 192.168.1.100&lt;/p&gt;
&lt;p&gt;3、192.168.1.100 上面安装 Nginx，做反向代理，同时也作为统一的管理入口，方便管理，同时也做定时更新 DNS 解析的任务&lt;/p&gt;


&lt;p&gt;&lt;span&gt;  &lt;strong&gt;准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;首先，我们需要去阿里云创建一个 Accesskey ，这个东西将作为我们登录阿里云更新解析的用户，具体创建方法可以参考百度，创建完成后记得保留好生成的 Key 和 Secret：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/979767/201806/979767-20180626140650670-555806177.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;：创建的 AccessKey 用户一定要记得授权 &lt;strong&gt;&lt;span&gt;DNS 管理&lt;/span&gt; &lt;/strong&gt;的权限，否则无法更新！&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其次，我们需要有一个已经备案完成的域名，如 &lt;span&gt;&lt;strong&gt;abc.com&lt;/strong&gt;&lt;/span&gt;！ &lt;/p&gt;
&lt;p&gt;最后，有一台内网的 Linux 机器，个人推荐 CentOS，几年运维下来，几乎用的都是这个，不为别的，就为了比较好管理。 &lt;/p&gt;


&lt;p&gt;&lt;span&gt;  &lt;strong&gt;服务配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;【1】CentOS 服务器安装 Python： 默认情况下，CentOS 是拥有 Python 的，一般都是 2.6 或者 2.7，但是不一定有 pip，我们需要安装 &lt;strong&gt;&lt;span&gt;pip&lt;/span&gt;&lt;/strong&gt;，这里采用的 &lt;strong&gt;&lt;span&gt;epel&lt;/span&gt;&lt;/strong&gt; 源：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; epel-&lt;span&gt;release
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; python-pip
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【2】安装依赖的阿里云 Python 包：前者是阿里云需要的包，后者是模拟请求需要的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip &lt;span&gt;install&lt;/span&gt; aliyun-python-sdk-&lt;span&gt;alidns
pip &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; requests
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【3】编辑更新脚本 &lt;span&gt;&lt;strong&gt;ddns_update.py&lt;/strong&gt;&lt;/span&gt;，内容如下： &lt;/p&gt;
&lt;p&gt;备注：脚本参考网上的老哥的分享，然后自己做了一些修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;这里解析有一个前提条件，就是你&lt;strong&gt;&lt;span&gt;需要修改的那条解析规则必须已经存在&lt;/span&gt;&lt;/strong&gt;，该脚本不能新增，只能修改旧的 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; aliyunsdkcore &lt;span&gt;import&lt;/span&gt;&lt;span&gt; client
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; aliyunsdkalidns.request.v20150109 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DescribeDomainsRequest,DescribeDomainRecordsRequest,UpdateDomainRecordRequest
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json,urllib,re

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#####################################################################################&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 个人配置区域&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;####################################################################################&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 创建的 AccessKey&lt;/span&gt;
ID=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Secret&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认&lt;/span&gt;
RegionId=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cn-hangzhou&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 你的域名&lt;/span&gt;
DomainName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 你想解析的二级域名，是一个列表，可以写多个&lt;/span&gt;
HostNameList = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认&lt;/span&gt;
Types = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
clt &lt;/span&gt;=&lt;span&gt; client.AcsClient(ID,Secret,RegionId)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#####################################################################################&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 动态获取当前公司对外的公网 IP&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; GetLocalIP():
    IPInfo &lt;/span&gt;= urllib.urlopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://ip.chinaz.com/getip.aspx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).read()
    IP &lt;/span&gt;= re.findall(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ip:'(.*?)',&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, IPInfo)[0]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IP

    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新域名 IP&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; EditDomainRecord(HostName, RecordId, Types, IP):
    UpdateDomainRecord &lt;/span&gt;=&lt;span&gt; UpdateDomainRecordRequest.UpdateDomainRecordRequest()
    UpdateDomainRecord.set_accept_format(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    UpdateDomainRecord.set_RecordId(RecordId)
    UpdateDomainRecord.set_RR(HostName)
    UpdateDomainRecord.set_Type(Types)
    UpdateDomainRecord.set_TTL(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    UpdateDomainRecord.set_Value(IP)
    UpdateDomainRecordJson &lt;/span&gt;=&lt;span&gt; json.loads(clt.do_action_with_exception(UpdateDomainRecord))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; UpdateDomainRecordJson

    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取域名信息&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; GetAllDomainRecords(DomainName, Types, IP):
    DomainRecords &lt;/span&gt;=&lt;span&gt; DescribeDomainRecordsRequest.DescribeDomainRecordsRequest()
    DomainRecords.set_accept_format(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    DomainRecords.set_DomainName(DomainName)
    DomainRecordsJson &lt;/span&gt;=&lt;span&gt; json.loads(clt.do_action_with_exception(DomainRecords))
    
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; DomainRecordsJson[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DomainRecords&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Record&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; HostName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; HostNameList:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; DomainRecordsJson[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DomainRecords&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Record&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
            RR &lt;/span&gt;= x[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            Type &lt;/span&gt;= x[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; RR == HostName &lt;span&gt;and&lt;/span&gt; Type ==&lt;span&gt; Types:
                RecordId &lt;/span&gt;= x[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RecordId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; RecordId
                EditDomainRecord(HostName, RecordId, Types, IP)

                
IP &lt;/span&gt;=&lt;span&gt; GetLocalIP()
GetAllDomainRecords(DomainName, Types, IP)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【4】添加定时任务： 每两小时更新一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 授执行权限&lt;/span&gt;
chmod 755 /scripts/&lt;span&gt;ddns_update.py

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加定时任务&lt;/span&gt;
echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;* */2 * * * /usr/bin/python /scripts/ddns_update.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /var/spool/cron/root
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 【5】配置完成，此时你可以手动执行检验该脚本是否能够正常的修改域名解析！至于后面的 Nginx 反向代理，网上的方法很多，这里就不一一缀诉！&lt;/p&gt;


&lt;p&gt;&lt;span&gt;  &lt;strong&gt;其它&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这里感谢提供这个脚本的大神，但是我写这个的时候已经离找到这个脚本有一段时间了，所以就无法具体到哪位，有些遗憾！&lt;/p&gt;

</description>
<pubDate>Tue, 26 Jun 2018 06:48:00 +0000</pubDate>
<dc:creator>Dy1an</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dy1an/p/9229074.html</dc:identifier>
</item>
<item>
<title>mixin配合class实现多继承的绝佳妙用 - 王海荣</title>
<link>http://www.cnblogs.com/wwwweb/p/9228973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwwweb/p/9228973.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/ronffy/mixin-class&quot;&gt;Github 源码地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是mixin&quot;&gt;什么是mixin&lt;/h2&gt;
&lt;p&gt;mixin一般翻译为“混入”、“混合”，&lt;br/&gt;早期一般解释为：把一个对象的方法和属性拷贝到另一个对象上；&lt;br/&gt;也可以简单理解为能够被继承的类，&lt;br/&gt;最终目的是实现代码的复用。&lt;/p&gt;
&lt;h2 id=&quot;从一个需求说起&quot;&gt;从一个需求说起&lt;/h2&gt;
&lt;p&gt;为了使你能够最快的清楚我在说什么，我们从一个需求说起：&lt;/p&gt;
&lt;p&gt;一个项目中有多个弹层需求；&lt;br/&gt;一些是公共方法，比如点击关闭按钮关闭弹层；&lt;br/&gt;一些弹层是可以拖动的，且有蒙层；&lt;br/&gt;一些弹层是可以缩放的；&lt;br/&gt;其他都是业务方法，无可复用性。&lt;/p&gt;
&lt;p&gt;你可以先在心里想下，如果是你，你会怎样完成这个需求？&lt;/p&gt;
&lt;h2 id=&quot;脑海中规划下&quot;&gt;脑海中规划下&lt;/h2&gt;
&lt;p&gt;我们为公共方法写个类：&lt;code&gt;BaseModal&lt;/code&gt;&lt;br/&gt;为可拖动的弹层写个类：&lt;code&gt;DragModal&lt;/code&gt;&lt;br/&gt;为可缩放的弹层写个类：&lt;code&gt;ScaleModal&lt;/code&gt;&lt;br/&gt;为自定义的业务需求写个类：&lt;code&gt;CustomModal&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;画个脑图的话，会是下面图片中的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/26/1643ab34a4df3e86?w=706&amp;amp;h=568&amp;amp;f=png&amp;amp;s=52800&quot; alt=&quot;不同类之间的关系图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;extends简单实现下&quot;&gt;extends简单实现下&lt;/h2&gt;
&lt;h3 id=&quot;看代码&quot;&gt;看代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 公共方法&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 可以拖动的弹层，我们写一个单独的类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DragModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  hasLayer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 可以缩放的弹层，我们写一个单独的类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ScaleModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'scale'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 业务方法&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; DragModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'custom-close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'do'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;CustomModal&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;d&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// custom-close&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// drag&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;do&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// do&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasLayer&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;抛出问题&quot;&gt;抛出问题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如何使&lt;code&gt;CustomModal&lt;/code&gt;能够同时继承&lt;code&gt;DragModal&lt;/code&gt;和&lt;code&gt;ScaleModal&lt;/code&gt;？&lt;/li&gt;
&lt;li&gt;某个相同方法希望不覆盖，而是都执行&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;试试早期的mixin方法实现多继承&quot;&gt;试试早期的mixin方法实现多继承&lt;/h2&gt;
&lt;h3 id=&quot;看代码-1&quot;&gt;看代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 可以拖动的弹层，我们写一个单独的类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DragModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  hasLayer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 可以缩放的弹层，我们写一个单独的类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ScaleModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'scale'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 获取原型对象的所有属性和方法&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;getPrototypes&lt;/span&gt;(ClassPrototype) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getOwnPropertyNames&lt;/span&gt;(ClassPrototype).&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;mix&lt;/span&gt;(...&lt;span class=&quot;at&quot;&gt;mixins&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(target)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;mixins &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isArray&lt;/span&gt;(mixins)) &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; target&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; cp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; C of mixins) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; mp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;C&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; m of &lt;span class=&quot;at&quot;&gt;getPrototypes&lt;/span&gt;(mp)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        cp[m] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; mp[m]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
@&lt;span class=&quot;at&quot;&gt;mix&lt;/span&gt;(DragModal&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; ScaleModal)
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; DragModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'custom-scale'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 
  &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'do'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;CustomModal&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 报错，因为dobase没在A或B的prototype上，而是在A.prototype.__proto__上&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// drag&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// scale  并非是我们想要的custom-scale&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasLayer&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// undefined&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;存在的问题&quot;&gt;存在的问题&lt;/h3&gt;
&lt;p&gt;以上&lt;code&gt;mix&lt;/code&gt;方式实现了多继承，但存在以下问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会修改&lt;code&gt;target&lt;/code&gt;类的原型对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt;类的相同方法名会被被继承类的相同方法名覆盖&lt;/li&gt;
&lt;li&gt;实例属性无法继承&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BaseModal&lt;/code&gt;类无法被继承&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;只继承不修改prototype的实现方式&quot;&gt;只继承不修改prototype的实现方式&lt;/h2&gt;
&lt;h3 id=&quot;看代码-2&quot;&gt;看代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; DragModalMixin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (extendsClass) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; extendsClass &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  hasLayer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;DragModalMixin&lt;/span&gt;(BaseModal) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'custom-drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'do'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;CustomModal&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// close&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// custom-drag&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasLayer&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;存在的问题-1&quot;&gt;存在的问题&lt;/h3&gt;
&lt;p&gt;如何让&lt;code&gt;CustomModal&lt;/code&gt;再继承&lt;code&gt;ScaleModal&lt;/code&gt;呢？&lt;br/&gt;其实很简单，在上面基础上，我们再写一个&lt;code&gt;ScaleModalMixinMixin&lt;/code&gt;类就可以了&lt;/p&gt;
&lt;h2 id=&quot;完美的多继承&quot;&gt;完美的多继承&lt;/h2&gt;
&lt;h3 id=&quot;看代码-3&quot;&gt;看代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; DragModalMixin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (extendsClass) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; extendsClass &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  hasLayer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; ScaleModalMixin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (extendsClass) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; extendsClass &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'scale'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ScaleModalMixin&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;DragModalMixin&lt;/span&gt;(BaseModal)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'custom-drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'do'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;CustomModal&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// close&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// custom-drag&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// scale&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasLayer&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;存在的问题-2&quot;&gt;存在的问题&lt;/h3&gt;
&lt;p&gt;这种方式不会修改父类的原型对象，但是如果存在跟父类同名的方法，只会执行父类的，而不回执行被继承的类的方法，那么如何使相同方法分别执行呢？&lt;/p&gt;
&lt;h2 id=&quot;super实现相同方法不覆盖&quot;&gt;super实现相同方法不覆盖&lt;/h2&gt;
&lt;h3 id=&quot;看代码-4&quot;&gt;看代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BaseModal &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; DragModalMixin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (extendsClass) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; extendsClass &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  hasLayer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;drag&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'drag'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; ScaleModalMixin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (extendsClass) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; extendsClass &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;scale&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'scale'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'scale-close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomModal &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ScaleModalMixin&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;DragModalMixin&lt;/span&gt;(BaseModal)) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'custom-close'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'do'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;CustomModal&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// custom-close   -&amp;gt;   scale-close   -&amp;gt;   close&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Mixin是一种思想，用来实现代码高度可复用性，又可以用来解决多继承的问题，是一种非常灵活的设计模式，如果你多多琢磨，相信你也会发现一些其他的妙用的，看好你哟！&lt;/p&gt;
</description>
<pubDate>Tue, 26 Jun 2018 06:33:00 +0000</pubDate>
<dc:creator>王海荣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwwweb/p/9228973.html</dc:identifier>
</item>
<item>
<title>服务治理-&gt; Spring Cloud Eureka - Java/Python</title>
<link>http://www.cnblogs.com/wenhongyu/p/9228940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenhongyu/p/9228940.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务治理-&amp;gt;搭建服务注册中心&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    服务治理可以说是微服务架构中最为核心和基础的模块， 它主要用来实现各个微服务 实例的自动化注册与发现。 为什么我们在微服务架构中那么需要服务治理模块呢？微服务 系统没有它会有什么不好的地方吗？&lt;/p&gt;
&lt;p&gt;    在最初开始构建微服务系统的时候可能服务并不多， 我们可以通过做一些静态配置来 完成服务的调用。 比如，有两个服务 A 和 B, 其中服务 A 需要调用服务 B 来完成一个业务 操作时， 为了实现服务 B 的高可用， 不论采用服务端负载均衡还是客户端负载均衡， 都需 要手工维护服务 B 的具体实例清单。 但是随着业务的发展， 系统功能越来越复杂， 相应的 微服务应用也不断增加， 我们的静态配置就会变得越来越难以维护。 并且面对不断发展的业务， 我们的集群规模、 服务的位置 、 服务的命名等都有可能发生变化， 如果还是通过手 工维护的方式， 那么极易发生错误或是命名冲突等问题。 同时， 对于这类静态内容的维护 也必将消耗大量的人力。&lt;/p&gt;
&lt;p&gt;    为了解决微服务架构中的服务实例维护问题， 产生了大量的服务治理框架和产品。 这 些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的自动化管理。&lt;/p&gt;
&lt;p&gt;    • 服务注册：在服务治理框架中， 通常都会构建一个注册中心， 每个服务单元向注册 中心登记自己提供的服务， 将主机与端口号、 版本号、 通信协议等一些附加信息告 知注册中心， 注册中心按服务名分类组织服务清单。 比如， 我们有两个提供服务A 的进程分别运行于 192.168.0.100:8000和192.168.0.101:8000位置上， 另外还有三个 提供服务B的进程分别运行千192.168.0.100:9000 、 192.168.0.101:9000、 192.168.0.102:9000位置上。 当这些进程均启动， 并向注册中心注册自己的服务之后， 注册中心就会维护类似下面的一个服务清单。 另外， 服务注册中心还需要以心跳的方式去监测清单中的服务是否可用， 若不可用 需要从服务清单中剔除， 达到排除故障服务的效果。&lt;/p&gt;
&lt;p&gt;   服务名                                                              位置 &lt;/p&gt;
&lt;p&gt;   服务A                                 192.168.0.100:8000、192.168.0.101:8000&lt;/p&gt;
&lt;p&gt;   服务B                         192.168.0.100:9000、192.168.0.101:9000、192.168.0.102:9000&lt;/p&gt;

&lt;p&gt;    • 服务发现：由于在服务治理框架下运作， 服务间的调用不再通过指定具体的实例地 址来实现， 而是通过向服务名发起请求调用实现。 所以， 服务调用方在调用服务提 供方接口的时候， 并不知道具体的服务实例位置。 因此， 调用方需要向服务注册中 心咨询服务， 并获取所有服务的实例清单， 以实现对具体服务实例的访问。 比如， 现有服务C希望调用服务A, 服务C就需要向注册中心发起咨询服务请求， 服务注 册中心就会将服务A的位置清单返回给服务C, 如按上例服务A的情况，C便获得 了服务A的两个可用位置 192.168.0.100:8000和192.168.0.101:8000。 当服务C要发起调用的时候， 便从该清单中以某种轮询策略取出一 个位置来进行服 务调用， 这就是后续我们将会介绍的客户端负载均衡。 这里我们只是列举了一种简 单的服务治理逻辑， 以方便理解服务治理框架的基本运行思路。 实际的框架为了性 能等因素， 不会采用每次都向服务注册中心获取服务的方式， 并且不同的应用场景 在缓存和服务剔除等机制上也会有一些不同的实现策略。&lt;/p&gt;
&lt;p&gt;   Spring Cloud Eureka, 使用Netflix Eureka来实现服务注册与发现， 它既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用Java编写，所以Eureka主要适用 于通过Java实现的分布式系统，或是与NM兼容语言构建的系统。但是， 由于Eureka服 务端的服务治理机制提供了完备的RESTfulAPL所以它也支持将非Java语言构建的微服 务应用纳入Eureka的服务治理体系中来。只是在使用其他语言平台的时候，需要自己来实 现Eureka的客户端程序。不过庆幸的是，在目前几个较为流行的开发平台上，都已经有了 一些针对Eureka 注册中心的客户端实现框架， 比如.NET平台的 Steeltoe、 Node.js 的 eureka-js-client等。&lt;/p&gt;
&lt;p&gt;    Eureka服务端，我们也称为服务注册中心。 它同其他服务注册中心一样，支持高可用 配置。它依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。 如 果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模 式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时， 集群中 的其他分片会把它们的状态再次同步回来。以在AWS 上的实践为例， Netflix推荐每个可 用的区域运行一个Eureka服务端，通过它来形成集群。不同可用区域的服务注册中心通过 异步模式互相复制各自的状态，这意味着在任意给定的时间点每个实例关于所有服务的状 态是有细微差别的。&lt;/p&gt;
&lt;p&gt;    Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式， 嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身 提供的服务并周期性地发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注 册的服务信息并把它们缓存到本地并周期性地刷新服务状态。&lt;/p&gt;
&lt;p&gt;    下面我们来构建一些简单示例，学习如何使用Eureka构建注册中心以及进行注册与发 现服务。&lt;/p&gt;
&lt;p&gt;搭建服务注册中心&lt;/p&gt;
&lt;p&gt;    首先，创建一个基础的Spring Boot工程，命名为eureka-server, 并在pom.xml 中引入必要的依赖内容， 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.10.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;          
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;           
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;           
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.4.4.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;            
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Brixton.SR7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;            
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;        
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过@EnableEurekaServer 注解启动一个服务注册中心提供给其他应用进行对话。 这一步非常简单， 只需在一个普通的 Spring Boot 应用中添加这个注解就能开启此功能， 比 如下面的例子：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img.mukewang.com/5b3075210001800105000337.jpg&quot; alt=&quot;https://img2.mukewang.com/5b3075210001800107820526.jpg&quot; width=&quot;830&quot; height=&quot;506&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    在默认设置下， 该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们 需要禁用它的客户端注册行为， 只需在 application.properties 中增加如下配置：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img.mukewang.com/5b308a540001042805000295.jpg&quot; alt=&quot;https://img.mukewang.com/5b308a540001042808990530.jpg&quot; width=&quot;644&quot; height=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;p&gt;• eureka.client.register-with-eureka: 由于该应用为注册中心，所以设置 为 false, 代表不向注册中心注册自己。&lt;/p&gt;
&lt;p&gt;• eureka.client.fetch-registry: 由于注册中心的职责就是维护服务实例， 它并不需要去检索服务， 所以也设置为 false。&lt;/p&gt;
&lt;p&gt;   在完成了上面的配置后，启动应用并访问 http://localhost: 8081/。可以看到Eureka 信息面板， 其中 Instances currently registered with Eureka 栏是空的， 说明该注册中心还没有注册任何服务。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img.mukewang.com/5b30c3410001fd4f05000259.jpg&quot; alt=&quot;https://img3.mukewang.com/5b30c3410001fd4f18750971.jpg&quot; width=&quot;770&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务治理-&amp;gt;注册服务提供者&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在完成了服务注册中心的搭建之后，接下来我们尝试将一个既有的 Spring Boot 应用加 入 Emeka 的服务治理体系中去。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img1.mukewang.com/5b30cc9b0001e63204150329.jpg&quot; alt=&quot;https://img2.mukewang.com/5b30cc9b0001e63204150329.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img2.mukewang.com/5b30ccdc0001e2eb05000493.jpg&quot; alt=&quot;https://img1.mukewang.com/5b30ccdc0001e2eb07730761.jpg&quot; width=&quot;675&quot; height=&quot;666&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img1.mukewang.com/5b30cd8900017d1105000295.jpg&quot; alt=&quot;https://img3.mukewang.com/5b30cd8900017d1108500500.jpg&quot; width=&quot;642&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img2.mukewang.com/5b30cde30001cb3f05000336.jpg&quot; alt=&quot;https://img4.mukewang.com/5b30cde30001cb3f07390496.jpg&quot; width=&quot;652&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;最后 ，我们需要在 application. yml 配置文件中， 通 过 spring. application.name属性来为 服 务命名， 比如命名 为 hello-service。 再通过 eureka.client. serviceUrl.defaultZone属性来指定服务注册中心的地址， 这里 我们指定为之前构建的服务注册中心地址， 完整配置如下所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img2.mukewang.com/5b30ce2300019e5005000286.jpg&quot; alt=&quot;https://img3.mukewang.com/5b30ce2300019e5005930339.jpg&quot; width=&quot;825&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问地址：&lt;a href=&quot;http://localhost:8081/&quot;&gt;http://localhost:8081/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img.mukewang.com/5b30cf2c00016f6b05000038.jpg&quot; alt=&quot;https://img3.mukewang.com/5b30cf2c00016f6b10950082.jpg&quot; width=&quot;1066&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://img2.mukewang.com/5b30ce8300013a6605000247.jpg&quot; alt=&quot;https://img2.mukewang.com/5b30ce8300013a6618290903.jpg&quot; width=&quot;913&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Jun 2018 06:28:00 +0000</pubDate>
<dc:creator>Java/Python</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenhongyu/p/9228940.html</dc:identifier>
</item>
<item>
<title>HTTP请求与服务器响应流程 - dobinspark</title>
<link>http://www.cnblogs.com/Dobin/p/9227955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dobin/p/9227955.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　1. HTTP 简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.1定义&lt;/p&gt;
&lt;p&gt;　　　　1.2 请求/响应报文格式&lt;/p&gt;
&lt;p&gt;　　　　1.3请求方式--GET/POST     状态码&lt;/p&gt;
&lt;p&gt;　　　　1.4 响应状态&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. HTTP请求，浏览器做了什么,&lt;/strong&gt; 服务端处理解析过程&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1：HTTP简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　1.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　HTTP（HyperText Transfer Protocol，超文本传输协议）最早就是计算机与计算机之间沟通的一种标准协议，这 种协议限制了通讯内容的格式以及各项内容的含义。&lt;/p&gt;
&lt;p&gt;　　随着时代的发展，技术的变迁，这种协议现在广泛的应用在各种领域，也不仅仅局限于计算机与计算机之间，手 机、电视等各种智能设备很多时候都在使用这种协议通讯，所以一般现在称 HTTP 为端与端之间的通讯协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1329093/201806/1329093-20180626134034868-391056346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Web 属于 B/S 架构的应用软件，在 B/S 架构中，浏览器与服务器沟通的协议就是 HTTP 协议，作为一个合格的 Web 开发者，了解 HTTP 协议中约定的内容是一门必修课。&lt;/p&gt;
&lt;p&gt;　　应用软件架构一般分为两类： B/S 架构：Browser（浏览器） ←→ Server（服务器），这种软件都是通过浏览器访问一个网站使用， 服务器提供数据存储等服务。 C/S 架构：Client（客户端） ←→ Server（服务器），这种软件通过安装一个软件到电脑，然后使用， 服务器提供数据存储等服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.2请求报文的格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;请求行    ---》请求方式 请求路径 HTTP协议版本  （一般GET请求主观上都是去‘拿东西’，所以使用需要看情况）&lt;/p&gt;
&lt;p&gt;　　请求头    ---》客户端想要告诉服务端的一些额外信息&lt;/p&gt;
&lt;p&gt;　　空行&lt;/p&gt;
&lt;p&gt;　　请求体   ---》客户端想要发送给服务端的数据正文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1329093/201806/1329093-20180626140429906-620907297.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;1.3请求的方式GET/POST    状态码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据HTTP标准，HTTP请求可以使用多种请求方法。&lt;/p&gt;
&lt;p&gt;　　HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。&lt;/p&gt;
&lt;p&gt;　　HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。&lt;/p&gt;
&lt;p&gt;具体的请查看官方文档：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.runoob.com/http/http-methods.html&quot; target=&quot;_blank&quot;&gt;http://www.runoob.com/http/http-methods.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://www.w3school.com.cn/tags/html_ref_httpmethods.asp&quot; target=&quot;_blank&quot;&gt;http://www.w3school.com.cn/tags/html_ref_httpmethods.asp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1329093/201806/1329093-20180626140754773-869507871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　　状态码：了解即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。&lt;/p&gt;
&lt;p&gt;　　1xx：指示信息 —— 表示请求已接收，继续处理。&lt;/p&gt;
&lt;p&gt;　　2xx：成功 —— 表示请求已被成功接收、理解、接受。&lt;/p&gt;
&lt;p&gt;　　3xx：重定向 —— 要完成请求必须进行更进一步的操作。&lt;/p&gt;
&lt;p&gt;　　4xx：客户端错误 —— 请求有语法错误或请求无法实现。&lt;/p&gt;
&lt;p&gt;　　5xx：服务器端错误 —— 服务器未能实现合法的请求。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　常见状态代码、状态描述的说明如下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　200 OK：客户端请求成功。&lt;/p&gt;
&lt;p&gt;　　400 Bad Request：客户端请求有语法错误，不能被服务器所理解。&lt;/p&gt;
&lt;p&gt;　　401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。&lt;/p&gt;
&lt;p&gt;　　403 Forbidden：服务器收到请求，但是拒绝提供服务。&lt;/p&gt;
&lt;p&gt;　　404 Not Found：请求资源不存在，举个例子：输入了错误的URL。&lt;/p&gt;
&lt;p&gt;　　 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;2. HTTP请求，浏览器做了什么,&lt;/strong&gt; 服务端处理解析过程&lt;/h2&gt;
&lt;p&gt;　　下面这张图我觉得比任何文字描述都清晰了，我这里就不再做详细介绍了，此图根据不同的操作系统，会有不同的概念，此为：Windows下的Apache+PHP环境。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1329093/201806/1329093-20180626094244912-1096955678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     结语：以上过程仅是个人理解，或许有错误的地方，也或者有还未理解到的层面，如果看到有错误或者有所指点的还希望不吝赐教指正！抱拳，感谢！O(∩_∩)O哈哈~附上个人博客：&lt;a href=&quot;https://dobinspark.com.cn/&quot; target=&quot;_blank&quot;&gt;https://dobinspark.com.cn/&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 26 Jun 2018 06:26:00 +0000</pubDate>
<dc:creator>dobinspark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dobin/p/9227955.html</dc:identifier>
</item>
</channel>
</rss>