<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深度学习正在吞噬软件 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7868803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7868803.html</guid>
<description>&lt;blockquote readability=&quot;2.3125&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;原文作者： &lt;a href=&quot;https://petewarden.com/author/petewarden/&quot; title=&quot;View all posts by Pete Warden&quot;&gt;Pete Warden&lt;/a&gt;&lt;br/&gt;原文地址：&lt;a href=&quot;https://petewarden.com/2017/11/13/deep-learning-is-eating-software/&quot;&gt;Deep Learning is Eating Software&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-9c235f5b91ffbe52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Photo by John Watson&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几个星期前，当我和Andrej Karpathy一起喝酒的时候，我们讨论了我们认为机器学习在未来几年内的发展方向。Andrej抛出了“软件2.0”这个词，我立刻就嫉妒了，因为它抓住了我每天在数百个项目中看到的过程。我一直保持沉默，直到得到他的博客，但现在我也想扩展我的想法。&lt;/p&gt;
&lt;p&gt;模式是现有的软件项目使用明确的编程逻辑进行数据处理，负责维护的团队发现他们可以用深度学习的解决方案取代它。 我只能指出我们已经公开的字母表中的例子，比如&lt;a href=&quot;https://www.wired.com/2016/02/ai-is-changing-the-technology-behind-google-searches/&quot;&gt;upgrading search ranking&lt;/a&gt;，&lt;a href=&quot;https://deepmind.com/blog/deepmind-ai-reduces-google-data-centre-cooling-bill-40/&quot;&gt;data center energy usage&lt;/a&gt;， &lt;a href=&quot;https://en.wikipedia.org/wiki/Google_Neural_Machine_Translation&quot;&gt;language translation&lt;/a&gt;以及&lt;a href=&quot;https://deepmind.com/blog/alphago-zero-learning-scratch/&quot;&gt;solving Go&lt;/a&gt;，但这些在内部并不罕见。 我所看到的是，几乎所有具有重大逻辑的数据处理系统都可以通过应用现代机器学习来显着改善。&lt;/p&gt;
&lt;p&gt;如果用这些术语来说，这听起来可能不那么戏剧化，但是这对我们如何构建软件是一个根本性的改变。 开发人员不必编写和维护错综复杂，层次分明的逻辑关系，而必须成为&lt;a href=&quot;https://petewarden.com/2014/06/06/how-i-teach-computers-to-think/&quot;&gt;教师&lt;/a&gt;，培训数据的管理者和结果分析师。 这与我在学校所教授的编程有很大的不同，但让我最兴奋的是，一旦工具发展起来，它应该比传统的编码更容易获得。&lt;/p&gt;
&lt;p&gt;这个过程的本质是提供大量的输入示例，以及对输出的期望。这并不需要与传统编程相同的技术技能，但它确实需要对问题领域有深入的了解。这意味着，软件的用户将能够在构建它的过程中扮演更直接的角色。从本质上讲，用户正在编写自己的用户故事，并将其输入到机器中以构建他们想要的内容。&lt;/p&gt;
&lt;p&gt;Andrej在他的文章中重点关注了音频和语音识别等领域，但实际上我认为这会对更多领域产生影响。 经典的“&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf&quot;&gt;机器学习：技术债务的高利息信用卡&lt;/a&gt;”标识了一个非常常见的模式，即机器学习系统嵌入到深层软件中。 我所看到的是，通过用深度学习模式替换整个堆栈，问题越来越得到解决！ 以类比为切入点，这就像将所有债务合并为一笔较低的单笔贷款。 单一模型比一组深度互联的模块更容易改进，维护变得更容易。 对于许多大型系统来说，没有人可以声称自己实际上在做什么，所以在调试或控制方面并没有真正的损失。&lt;/p&gt;
&lt;p&gt;我知道这听起来更像是对深度学习的宣传，如果我没有看到每天发生的过程，我也很难接受，但这是真实的。比尔·盖茨(Bill Gates)曾说过：“大多数人高估了自己一年所能做的事情，却低估了他们十年后能做的事情”，这就是我对传统软件的替代态度。随着知识在开发者社区中传播，将会有很长一段时间的增长，但在10年里，我预测大多数软件作业都不会涉及编程。正如Andrej所记忆的那样，“(深度学习)比你更好!”&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:22:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7868803.html</dc:identifier>
</item>
<item>
<title>SpringMVC处理ajax请求的跨域问题和注意事项 - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/7868785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/7868785.html</guid>
<description>&lt;p&gt; .首先要知道ajax请求的核心是JavaScrip对象和XmlHttpRequest，而浏览器请求的核心是浏览器&lt;/p&gt;
&lt;p&gt;ajax请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120222754696-96052272.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120222743821-2021215167.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景一：使用ajax获取session中的user（跨域）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230048305-1380764596.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;195&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230056868-941601761.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可知，ajax每次访问服务器时都没有携带cookie，所以服务器每次都会分配一个新的session对象，所以ajax默认请求是直接获取不了session中的数据的。因此，如果我们想要通过ajax获取当前浏览器的session，我们必须保证每次发送请求都要携带cookie以确保获取的事统一个session。&lt;/p&gt;
&lt;p&gt;解决方法：step1.服务器设置接收ajax发送的cookie&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HandlerInterceptorAdapter&lt;br/&gt;//跨域设置&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CrossInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HandlerInterceptorAdapter {
　　
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Allow-Origin&quot;,&quot;http://localhost:8080&quot;&lt;span&gt;);
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Allow-Methods&quot;,&quot;*&quot;&lt;span&gt;);
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Max-Age&quot;,&quot;100&quot;&lt;span&gt;);
        response.addHeader(&lt;/span&gt;&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许客户端发送cookies true表示接收，false不接受 默认为false？&lt;/span&gt;
        response.addHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.preHandle(request, response, handler);
    } 

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step2 。设置ajax请求携带cookie&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    $.ajax({
        url: url&lt;/span&gt;+'/checkout.action'&lt;span&gt;,
        type: &lt;/span&gt;'GET'&lt;span&gt;,
        dataType: &lt;/span&gt;''&lt;span&gt;,
        data: {verifyCode: VerificationCodeInput.value},
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加跨域&lt;/span&gt;
       async: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
        xhrFields: {  
            withCredentials: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
        },  
        crossDomain: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
            console.log(data);
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注： &lt;span&gt;xhrFields: { withCredentials: &lt;span&gt;true &lt;span&gt;}, crossDomain: &lt;span&gt;true&lt;span&gt;, 一定要加上！！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230940446-1221298777.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;215&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1055780/201711/1055780-20171120230948993-1668735608.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样就可以愉快的玩耍了！　　　　&lt;/p&gt;

&lt;p&gt;场景二：当用户需要校验session是否登陆（没有登陆跳转到登陆页面）&lt;/p&gt;
&lt;p&gt;基于场景一，已经解决了回话问题但是在使用SpringMVC中&lt;/p&gt;
&lt;p&gt;　　　　    request.getRequestDispatcher(xxxx.html&quot;).forward(request, response);&lt;br/&gt;    　　　　response.sendRedirect(&quot;http://www.baidu.com&quot;);&lt;/p&gt;
&lt;p&gt;　会报错。因为当服务器转发或者重定向时返回的是一个页面，因为只有浏览器才能解析显示页面，而ajax的对象却不能，所以会报错错。&lt;/p&gt;

&lt;p&gt;　解决办法：因为ajax请求对象不能解析显示页面，所以不能直接转发或重定向，这时我们需要绕过服务器，直接使用浏览器跳转页面，但是对于session过期（用户没有登陆）我们要给浏览器一个反馈，我们可以给浏览器一个大于等于600的错误码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   　　 String requestType = request.getHeader(&quot;X-Requested-With&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(requestType != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &quot;XMLHttpRequest&quot;&lt;span&gt;.equalsIgnoreCase(requestType.trim())) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是ajax请求就设置一个自定义响应头&lt;/span&gt;
            response.setHeader(&quot;sessionStatus&quot;, &quot;timeout&quot;&lt;span&gt;);&lt;br/&gt;　　　　　　　&lt;span&gt; &lt;span&gt;/&lt;span&gt;/设置错误码以及错误码提示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            response.sendError(&lt;/span&gt;666, &quot;session timeout&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 同时要对ajax设置全局options　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajaxSetup({
  type:&lt;/span&gt;'post'&lt;span&gt;,
  complete:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(xhr, ts){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;XMLHttpRequest, textStatus&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; sessionStatus = xhr.getResponseHeader('sessionstatus'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sessionStatus == 'timeout'&lt;span&gt;) {
          alert(&lt;/span&gt;'用户没有登陆，请登录！'&lt;span&gt;);
          window.top.location.href &lt;/span&gt;= 'Login.html'&lt;span&gt;;
      }
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样就可以通过浏览器进行页面跳转了！&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:17:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiangchn/p/7868785.html</dc:identifier>
</item>
<item>
<title>设计模式-原型模式(06) - 秋夜雨巷</title>
<link>http://www.cnblogs.com/aeolian/p/7853477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aeolian/p/7853477.html</guid>
<description>&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;　　原型（Prototype Pattern）是一个简单的设计模式。原型模式的英文原话是：Specify the kind of objects to create using a prototypical instance，and create new objects by copying this prototype.意思是：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。&lt;/p&gt;
&lt;p&gt;　　原型模式有三种角色：&lt;/p&gt;
&lt;p&gt;　　1.客户（Client）角色：该角色提出创建对象的请求。&lt;br/&gt;　　2.抽象原型（Prototype）：该角色是一个抽象角色，通常由一个java接口或抽象类实现，给出所有的具体原型类所需要的接口。&lt;br/&gt;　　3.具体原型（Concrete Prototype）角色：该角色是被复制的对象，必须实现抽象原型接口。&lt;/p&gt;
&lt;p&gt;java中内置了克隆机制。object类具有一个clone（）方法，能够实现对对象的克隆，是一个类支持克隆只需要两步：&lt;/p&gt;
&lt;p&gt;　　1.实现Cloneable接口。&lt;br/&gt;　　2.覆盖Object的clone（）方法，完成对象的克隆操作，通常只需要调用Object的clone()方法即可。为了使外部能够调用此类的clone（）方法，可以将访问修饰符改为public。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽象原型角色(Prototype)
 * 给出具体原型类复制所需要的接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Prototype {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;克隆方法&lt;/span&gt;
&lt;span&gt;    Prototype clone();
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 具体原型工厂类
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcretePrototype &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Prototype {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Prototype clone() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Prototype)&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; operation(Prototype example) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到example&lt;/span&gt;
        Prototype prototype =&lt;span&gt; example.clone();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;原型模式的优点&lt;/h2&gt;
&lt;p&gt;　　1.性能优良：原型模式是对内存中二进制流的拷贝，要比直接new一个对象性能好，特别是当一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。&lt;/p&gt;
&lt;p&gt;　　2.逃避构造函数的约束。这既是优点也是缺点，直接在内存中拷贝对象，构造函数是不会执行的，因此减少了约束，不过这一点需要在实际应用时进行权衡考虑。&lt;/p&gt;
&lt;h2&gt;原型模式的使用场景&lt;/h2&gt;
&lt;p&gt;　　1.资源优化场景，类初始化时需要消化非常多的资源，这个资源包括数据、硬件资源等。&lt;/p&gt;
&lt;p&gt;　　2.性能和安全要求的场景，如果通过new产生一个对象需要非常繁琐的数据准备和访问权限，则可以使用原型模式。&lt;/p&gt;
&lt;p&gt;　　3.一个对象多个修改者的场景，一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值，可以考虑使用原型模式拷贝多个对象供调用者使用。&lt;/p&gt;
&lt;p&gt;在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现。原型模式通过clone（）方法创建一个对象，然后由工厂方法提供给调用者。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 实现clone接口,实现了clone方法,是实现克隆的关键
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mail &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Cloneable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;收件人&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String receiver;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件标题&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String subject;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;称谓&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String appellation;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件内容&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String contxt;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾部&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String tail;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mail(String subject,String contxt) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subject =&lt;span&gt; subject;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.contxt =&lt;span&gt; contxt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;克隆方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Mail clone() {
        Mail mail &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            mail&lt;/span&gt;=(Mail) &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
            System.out.println(&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;.toString());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;super指的是被调用的那个对象&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mail;
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 调用
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendMailDemo {
    Map students &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedHashMap();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个原型mail&lt;/span&gt;
        Mail mail = &lt;span&gt;new&lt;/span&gt; Mail(&quot;邮件标题&quot;, &quot;邮件内容&quot;&lt;span&gt;);
        mail.setTail(&lt;/span&gt;&quot;2017-11-20&quot;&lt;span&gt;);
        SendMailDemo sendMailDemo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SendMailDemo();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有学生&lt;/span&gt;
        Map students=&lt;span&gt;sendMailDemo.getStudent();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object name : students.keySet()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;克隆邮件&lt;/span&gt;
            Mail cloneMail =&lt;span&gt; mail.clone();
            cloneMail.setAppellation(name.toString());
            cloneMail.setReceiver(students.get(name).toString());
            sendMailDemo.sendMail(cloneMail);
        }
        
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map getStudent(){
        students.put(&lt;/span&gt;&quot;studentone&quot;, &quot;1@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studenttwo&quot;, &quot;2@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentthree&quot;, &quot;3@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentfour&quot;, &quot;4@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentfive&quot;, &quot;5@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentsix&quot;, &quot;6@foxmail.com&quot;&lt;span&gt;);
        students.put(&lt;/span&gt;&quot;studentseven&quot;, &quot;7@foxmail.com&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; students;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMail(Mail mail){
        System.out.println(&lt;/span&gt;&quot;标题:&quot;+mail.getSubject()+&quot;\t收件人邮箱:&quot;+mail.getReceiver()+&quot;\t正文:&quot;+mail.getAppellation()+mail.getContxt()+&quot;\t...已发送&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AutKevin/JAVA/tree/master/DesignPatterns/PrototypePattern&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 15:14:00 +0000</pubDate>
<dc:creator>秋夜雨巷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aeolian/p/7853477.html</dc:identifier>
</item>
<item>
<title>使用AspectCore动态代理 - Lemon丶</title>
<link>http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近越来越多的同学关注到&lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot;&gt;AspectCore&lt;/a&gt;，并且提出不少中肯的建议，其中最多的提议是希望能够看到更多的关于AspectCore使用方式的文章和Demo。那么在这篇文章里，我们就来聊聊AspectCore核心之一的动态代理。&lt;/p&gt;
&lt;h3 id=&quot;动态代理&quot;&gt;动态代理&lt;/h3&gt;
&lt;p&gt;在.NET平台中，静态织入和动态代理是实现AOP的两种方式。其中静态织入在编译时通过在MSBiuld执行自定义的Build Task来拦截编译过程，在生成的程序集里插入自己的IL。而动态代理则是在运行时通过Emit技术生成动态程序集和动态代理类型从而对目标方法进行拦截。不管那种方式，都需要对MSIL有足够的理解，如果读者想要学习MSIL相关的技术，我在这里推荐&lt;a href=&quot;https://book.douban.com/subject/4037255/&quot;&gt;《NET探秘MSIL权威指南》&lt;/a&gt;一书。&lt;br/&gt;AspectCore使用了动态代理作为AOP的实现，而不使用理论上性能更优的静态织入实现，是由于个人觉得动态代理方式可以做到更好的IoC进行集成并且能够在切面中获取更多的运行时元数据信息，并且在经过不断优化后，AspectCore动态代理的性能已经不落后静态织入的实现方式。&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;如何使用&lt;/h3&gt;
&lt;p&gt;在之前的文章里，只是简单的介绍了AspectCore，导致了很多同学不知道如何在项目里使用AspectCore(&lt;code&gt;^~^,求轻拍~&lt;/code&gt;)。下面就来讲一下如何在IoC环境和非IoC环境里使用AspectCore的AOP。&lt;br/&gt;首先通过nuget获取AspectCore：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.Core&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore中动态代理api在&lt;code&gt;AspectCore.DynamicProxy&lt;/code&gt;命名空间中，所以我们需要先引入命名空间&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using AspectCore.DynamicProxy;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在非IoC环境中，只使用AOP的话，AspectCore提供了&lt;code&gt;ProxyGeneratorBuilder&lt;/code&gt;作为代理生成器创建的入口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ProxyGeneratorBuilder proxyGeneratorBuilder = new ProxyGeneratorBuilder();
IProxyGenerator proxyGenerator = proxyGeneratorBuilder.Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;IProxyGenerator&lt;/code&gt;提供了&lt;code&gt;CreateClassProxy&lt;/code&gt;方法创建class代理和&lt;code&gt;CreateInterfaceProxy&lt;/code&gt;方法创建interface代理,创建的代理类被定义在命名为&lt;code&gt;AspectCore.DynamicProxy.Generator&lt;/code&gt;的动态程序集中，并且代理类使用&lt;code&gt;AspectCore.DynamicGenerated&lt;/code&gt;命名空间。&lt;br/&gt;我们先来定义一个简单的拦截器，接着定义一个interface和它的简单实现，并创建interface的代理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        ProxyGeneratorBuilder proxyGeneratorBuilder = new ProxyGeneratorBuilder();
        IProxyGenerator proxyGenerator = proxyGeneratorBuilder.Build();
        SampleInterface sampleInterface = proxyGenerator.CreateInterfaceProxy&amp;lt;SampleInterface&amp;gt;();
        Console.WriteLine(sampleInterface);
        sampleInterface.Foo();
        Console.ReadKey();
    }
}

public class SampleInterceptor : AbstractInterceptorAttribute
{
    public override Task Invoke(AspectContext context, AspectDelegate next)
    {
        Console.WriteLine(&quot;call interceptor&quot;);
        return context.Invoke(next);
    }
}

public class SampleClass : SampleInterface
{
    public virtual void Foo() { }
}

[SampleInterceptor]
public interface SampleInterface
{
    void Foo();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleInterface1
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，IProxyGenerator提供了若干重载的扩展方法来创建已有类或接口实例的代理，可在&lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/core/src/AspectCore.Core/DynamicProxy/Extensions/ProxyGeneratorExtensions.cs&quot;&gt;ProxyGeneratorExtensions&lt;/a&gt;中找到并使用它们。&lt;/p&gt;
&lt;h3 id=&quot;在ioc中使用aspectcore.dynamicproxy&quot;&gt;在IoC中使用AspectCore.DynamicProxy&lt;/h3&gt;
&lt;p&gt;AspectCore在设计之初就考虑AOP和IoC的集成使用，并提供AOP抽象接口以兼容不同IoC，目前已实现和AspectCore.DynamicProxy集成的IoC框架有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AspectCore.Injector(AspectCore Framework的内置IoC)&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.DependencyInjection(Asp.Net Core的内置DI框架)&lt;/li&gt;
&lt;li&gt;Autofac&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们分别看一下在三个IoC中如何使用AspectCore.DynamicProxy。&lt;/p&gt;
&lt;h4 id=&quot;aspectcore.injector&quot;&gt;AspectCore.Injector&lt;/h4&gt;
&lt;p&gt;AspectCore.Injector中内置了对AspectCore.DynamicProxy的支持，所以我们可以直接使用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IServiceContainer serviceContainer = new ServiceContainer();
serviceContainer.AddType&amp;lt;SampleInterface, SampleClass&amp;gt;();
IServiceResolver serviceResolver = serviceContainer.Build();
SampleInterface sampleInterface = serviceResolver.Resolve&amp;lt;SampleInterface&amp;gt;();
Console.WriteLine(sampleInterface);
sampleInterface.Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleClass
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;microsoft.extensions.dependencyinjection&quot;&gt;Microsoft.Extensions.DependencyInjection&lt;/h4&gt;
&lt;p&gt;AspectCore提供&lt;code&gt;AspectCore.Extensions.DependencyInjection&lt;/code&gt;包集成Microsoft.Extensions.DependencyInjection和AspectCore.DynamicProxy。&lt;br/&gt;通过nuget获取：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.Extensions.DependencyInjection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore提供了针对IServiceCollection的扩展方法&lt;code&gt;AddDynamicProxy&lt;/code&gt;注册动态代理的接口和相关拦截器配置，并需要使用&lt;code&gt;BuildAspectCoreServiceProvider&lt;/code&gt;创建被DynamicProxy接管的ServiceProvider：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IServiceCollection services = new ServiceCollection();
services.AddTransient&amp;lt;SampleInterface, SampleClass&amp;gt;();

services.AddDynamicProxy();
IServiceProvider serviceProvider = services.BuildAspectCoreServiceProvider();

SampleInterface sampleInterface = serviceProvider.GetService&amp;lt;SampleInterface&amp;gt;();
Console.WriteLine(sampleInterface);
sampleInterface.Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleClass
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;autofac&quot;&gt;Autofac&lt;/h4&gt;
&lt;p&gt;AspectCore提供&lt;code&gt;AspectCore.Extensions.Autofac&lt;/code&gt;包集成Autofac和AspectCore.DynamicProxy。&lt;br/&gt;通过nuget获取：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package AspectCore.Extensions.Autofac&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore提供了针对ContainerBuilder的扩展方法&lt;code&gt;RegisterDynamicProxy&lt;/code&gt;注册动态代理的接口和相关拦截器配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ContainerBuilder builder = new ContainerBuilder();
builder.RegisterType&amp;lt;SampleClass&amp;gt;().As&amp;lt;SampleInterface&amp;gt;();

builder.RegisterDynamicProxy();

var container = builder.Build();
SampleInterface sampleInterface = container.Resolve&amp;lt;SampleInterface&amp;gt;();
Console.WriteLine(sampleInterface);
sampleInterface.Foo();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AspectCore.DynamicGenerated.SampleClass
call interceptor&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;有问题反馈&quot;&gt;有问题反馈&lt;/h3&gt;
&lt;p&gt;如果您有任何问题，请提交 &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/issues/new&quot;&gt;Issue&lt;/a&gt; 给我们。&lt;br/&gt;Github : &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework&lt;/a&gt;&lt;br/&gt;AspectCore QQ群: 306531723&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:13:00 +0000</pubDate>
<dc:creator>Lemon丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html</dc:identifier>
</item>
<item>
<title>从零一起学Spring Boot之LayIM项目长成记（五）websocket - 丶Pz</title>
<link>http://www.cnblogs.com/panzi/p/7828743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panzi/p/7828743.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　距离上一篇已经比较久的时间了，项目也是开了个头。并且，由于网上的关于Spring Boot的websocket讲解也比较多。于是我采用了另外的一个通讯框架 &lt;strong&gt;t-io&lt;/strong&gt; 来实现LayIM中的通讯功能。本篇会着重介绍我在研究与开发过程中踩过的坑和比较花费的时间的部分。&lt;/p&gt;
&lt;h2&gt;WebSocket&lt;/h2&gt;
&lt;p&gt;　　在研究 &lt;strong&gt;t-io&lt;/strong&gt; 的时候，我已经写过关于t-io框架的一些简单例子分析以及框架中关于 websocket 中的编解码代码分析等，有兴趣的同学可以先看一下。因为 在LayIM项目中我会是用到 Showcase Demo 中的设计思路。&lt;/p&gt;
&lt;p&gt;　　&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/panzi/p/7814062.html&quot;&gt;通讯框架 t-io 学习——给初学者的Demo：ShowCase设计分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/panzi/p/7823118.html&quot;&gt;通讯框架 t-io 学习——websocket 部分源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果你潜心想学到这些东西的话，本人还是建议静下心来看看。为什么不用Spring Boot 封装好的websocket呢？因为它封装的太完备，许多业务不能定制。而通过t-io框架自己开发websocket端，就比较灵活了。甚至可以打造专门为LayIM定制的websocket服务，在讲解我的开发之路之前，也向大家推荐更完备的解决方案 &lt;strong&gt;tio-im&lt;/strong&gt;，当然，我也是借鉴该源代码的设计思路。不过它的实现更加强大，由于我的水平有限，我只能照猫画虎，胡乱写了一通。不过也还是能用的。&lt;/p&gt;
&lt;p&gt;　　tio-im 地址：&lt;a href=&quot;https://gitee.com/xchao/tio-im&quot; target=&quot;_blank&quot;&gt;https://gitee.com/xchao/tio-im&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;项目实战&lt;/h2&gt;
&lt;p&gt;　　前几篇已经实现了LayIM主要界面的数据加载功能。接下来就是最核心的部分，通讯。实现思路很多，这里呢我使用了 基于 t-io 通讯框架的 websocket。在进入详细代码之前，我们先分析LayIM中用到的一些功能点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;登录功能  &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单聊功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;群聊功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他自定义消息提醒功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等等。。。。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;登录的目的是过滤非法请求，如果有一个非法用户请求websocket服务，直接返回403或者401即可。&lt;/p&gt;
&lt;p&gt;　　单聊，群聊这个就不用解释了&lt;/p&gt;
&lt;p&gt;　　其他自定义消息提醒，比如：时时加好友消息，广播消息，审核消息等。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;t-io&lt;/strong&gt; 中的对外发送消息接口在 &lt;strong&gt;Aio.java&lt;/strong&gt; 中实现。（下文中只列取部分接口，以及在LayIM项目中用到的）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定用户&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bindUser(ChannelContext channelContext, String userid)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给用户 &lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Boolean sendToUser(GroupContext groupContext, String userid, Packet packet)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送到群组&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendToGroup(GroupContext groupContext, String group, Packet packet) 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给所有人&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendToAll(GroupContext groupContext, Packet packet)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送到指定channel &lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Boolean send(ChannelContext channelContext, Packet packet) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　开工之前呢，我们还要开发消息的编解码类（框架中已经实现），消息监听事件的处理，由于对于LayIM我们有基于业务的定制开发，所以会改一部分源代码。那我这里呢就把框架中部分源码粘贴到项目中，然后进行代码修改。不过像比如：握手流程，升级Websocket连接，解析byte[] 这些功能我们就没必要自己去做了，想要学习的话，可以看着源代码自己去研究。好，我们进入代码部分。&lt;/p&gt;
&lt;h2&gt;代码剖析&lt;/h2&gt;
&lt;p&gt;　　首先实现  &lt;strong&gt;IWsMsgHandler&lt;/strong&gt;接口。这个接口定义在 &lt;span class=&quot;kn&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;strong&gt;org&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;tio&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;websocket&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;server&lt;/strong&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;span class=&quot;na&quot;&gt;&lt;strong&gt;handler&lt;/strong&gt;  包中，代码如下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWsMsgHandler {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * 对httpResponse参数进行补充并返回，如果返回null表示不想和对方建立连接，框架会断开连接，如果返回非null，框架会把这个对象发送给对方
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponse handshake(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object onBytes(WsRequest wsRequest, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, ChannelContext channelContext) throws Exception;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object onClose(WsRequest wsRequest, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, ChannelContext channelContext) throws Exception;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*

     * @return 可以是WsResponse、byte[]、ByteBuffer、String或null，如果是null，框架不会回消息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object onText(WsRequest wsRequest, String text, ChannelContext channelContext) throws Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一般我们会在公开的这些接口实现中做些事情，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object onText(WsRequest wsRequest, String s, ChannelContext channelContext) throws Exception {
        logger.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到text消息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)；
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息业务处理逻辑&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息发送成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不过既然这次我们可以自己写websocket内部的业务逻辑，所以，这些接口我们就不在处理主要业务逻辑。那么主要业务逻辑在哪里处理呢？ 我把他放在了 decode 方法之后。可能，大伙看到这里有些晕，下面我画一张图来从大局上介绍一个消息的发送处理流程。这里我以单聊发送消息举例。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120151819180-789901606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先是，客户端连接服务器。先走握手流程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　if&lt;/span&gt; (!&lt;span&gt;wsSessionContext.isHandshaked()) {
            HttpRequest request &lt;/span&gt;=&lt;span&gt; HttpRequestDecoder.decode(buffer, channelContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
　　　　　　　//升级到websokcet协议
            HttpResponse httpResponse &lt;/span&gt;=&lt;span&gt; Protocol.updateToWebSocket(request, channelContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (httpResponse == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AioDecodeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http协议升级到websocket协议失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            wsSessionContext.setHandshakeRequestPacket(request);
            wsSessionContext.setHandshakeResponsePacket(httpResponse);

            WsRequest wsRequestPacket &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WsRequest();
            wsRequestPacket.setHandShake(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wsRequestPacket;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
　　　　　　　WsSessionContext wsSessionContext =&lt;span&gt; (WsSessionContext) channelContext.getAttribute();
            HttpRequest request &lt;/span&gt;=&lt;span&gt; wsSessionContext.getHandshakeRequestPacket();
            HttpResponse httpResponse &lt;/span&gt;=&lt;span&gt; wsSessionContext.getHandshakeResponsePacket();&lt;br/&gt;　　　　　　　//这里通过handshake接口实现的返回值，判断是否同意握手
            HttpResponse r &lt;/span&gt;=&lt;span&gt; wsMsgHandler.handshake(request, httpResponse, channelContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                Aio.remove(channelContext, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;业务层不同意握手&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上文第二段代码中的 wsMsgHandler.handshake 方法，这里一般直接返回默认的 httpReponse即可，代表（框架层）握手成功。但是我们可以在接口中自定义一些业务逻辑，比如用户判断之类的逻辑，然后决定是否同意握手流程。&lt;/p&gt;
&lt;p&gt;　　这里有一个小细节需要注意，无论是握手还是业务登录请求，成功之后，都需要将用户绑定到当前的上下文（channelContext）中。调用 &lt;strong&gt;Aio.bindUser&lt;/strong&gt; 即可。&lt;/p&gt;
&lt;p&gt;　　下图为简版的聊天发送消息流程：客户端A 发送消息到客户端B。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120154200102-1151133974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　正如上文中所说，编解码我们不用过多的关心，那么我们需要关注的部分就是业务处理了。设计思路呢也很容易想到，首先，我们有不同的消息类型。这个消息类型由客户端决定。如果传入了错误的消息类型，就抛出异常或者返回未知消息处理即可。消息处理类结构设计如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120155419680-31103644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是不是很简单，一个通用业务处理入口，将消息转化为友好的类实体，然后在具体的消息处理器中处理业务逻辑即可。&lt;/p&gt;
&lt;p&gt;　　LayimAbsMsgProcessor 核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 这里采用showcase中的设计思路（反序列化消息之后，由具体的消息处理器处理）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WsResponse process(WsRequest layimPacket, ChannelContext channelContext) throws Exception {
        Class&lt;/span&gt;&amp;lt;T&amp;gt; clazz =&lt;span&gt; getBodyClass();
        T body &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (layimPacket.getBody() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取json格式的数据　&lt;/span&gt;
            String json =&lt;span&gt; ByteUtil.toText(layimPacket.getBody());
　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符串转化为具体类型的对象&lt;/span&gt;
            body =&lt;span&gt; Json.toBean(json, clazz);
        }
　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过具体处理类处理消息对象&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; process(layimPacket, body, channelContext);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;abstract&lt;/span&gt; WsResponse process(WsRequest layimPacket,T body,ChannelContext channelContext) throws  Exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ClientToClientMsgProcessor 核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WsResponse process(WsRequest layimPacket, ChatRequestBody body, ChannelContext channelContext) throws Exception {
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;requestBody 转化为接收端的消息类型&lt;/span&gt;
        ClientToClientMsgBody msgBody =&lt;span&gt; BodyConvert.getInstance().convertToMsgBody(body,channelContext);
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息包装，返回WsResponse&lt;/span&gt;
        WsResponse response =&lt;span&gt; BodyConvert.getInstance().convertToTextResponse(msgBody);
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到对方的channelContext&lt;/span&gt;
        ChannelContext toChannelContext =&lt;span&gt; Aio.getChannelContextByUserid(channelContext.getGroupContext(),body.getToId());
        &lt;/span&gt;&lt;span&gt;//发送给对方&lt;/span&gt;
&lt;span&gt;        Aio.send(toChannelContext,response);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对接spring boot&lt;/h2&gt;
&lt;p&gt;　　那么如何启动websocket服务呢，一般框架中都是绑定好的。这里呢，我们特殊处理一下，刚开始我是手动调用start方法，后来研究了一下spring boot starter。下面简单介绍一下starter的用法。&lt;/p&gt;
&lt;p&gt;　　首先建立一个配置类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;layim.websocket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LayimServerProperties {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LayimServerProperties(){
        port &lt;/span&gt;= &lt;span&gt;8081&lt;/span&gt;&lt;span&gt;;
        heartBeatTimeout &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ip &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getter  setter&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heartBeatTimeout;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ip;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二部，新建一个 AutoConfig类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableConfigurationProperties(LayimServerProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LayimWebsocketServerAutoConfig {

    @Autowired
    LayimServerProperties properties;

    @Bean
    LayimWebsocketStarter layimWebsocketStarter() throws Exception{
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化配置信息&lt;/span&gt;
        LayimServerConfig config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LayimServerConfig(properties.getPort());
        config.setBindIp(properties.getIp());
        config.setHeartBeatTimeout(properties.getHeartBeatTimeout());

        LayimWebsocketStarter layimWebsocketStarter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LayimWebsocketStarter(config);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务&lt;/span&gt;
&lt;span&gt;        layimWebsocketStarter.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; layimWebsocketStarter;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第三步，在resources文件夹下，新建META-INF文件夹，在新建一个spring.factories文件，文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
org.springframework.boot.autoconfigure.EnableAutoConfiguration= com.fyp.layim.im.server.LayimWebsocketServerAutoConfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　OK，到这里我们配置一下。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120223315368-270528247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后启动程序。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120223412602-931294591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　   启动成功！&lt;/p&gt;
&lt;h2&gt;项目演示&lt;/h2&gt;
&lt;p&gt;　　啰啰嗦嗦的讲了这么多，还是给大家看一下演示。&lt;/p&gt;
&lt;p&gt;　　用户 1，2 链接服务器。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120223926149-369053253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用户2给用户1发送消息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120224041993-2070878173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看上面的只是演示消息能够顺利发送，下面的日志打印图可以看出来服务器的处理流程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/841545/201711/841545-20171120230906555-431992049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　到此为止我们已经可以实现通讯了，但是这些还不够还有更多的业务去处理。不过没关系，通讯实现了，后边的就不难了。其实更多的是细节的把握，比如用户退群，用户下线，统计用户在线个数等。&lt;/p&gt;
&lt;p&gt;　　下期预告：从零一起学Spring Boot之LayIM项目长成记（五）用户登录验证和单聊群聊的实现&lt;/p&gt;
&lt;p&gt;　　GitHub：&lt;a href=&quot;https://github.com/fanpan26/SpringBootLayIM&quot; target=&quot;_blank&quot;&gt;https://github.com/fanpan26/SpringBootLayIM&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 15:10:00 +0000</pubDate>
<dc:creator>丶Pz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/panzi/p/7828743.html</dc:identifier>
</item>
<item>
<title>Django 入门案例开发（下）——创建项目应用及模型类 - FocusBI</title>
<link>http://www.cnblogs.com/focusBI/p/7868737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/focusBI/p/7868737.html</guid>
<description>&lt;p&gt;　　前面两章是在已经开发好的项目上用来描述环境和业务，这一章创建一个全新的项目来用作开发，你可以跟着我的步骤进行开发，如果有不理解的地方可以给我留言。&lt;/p&gt;
&lt;p&gt;　　今天的任务是创建好项目和用户（users）应用及让它能运行起来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步创建虚拟空间及项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120215327852-333322074.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120215338243-1645503695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120215120540-1610128676.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步创建应用users&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120215223446-796444601.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 第三步创建数据及在setting.py中配置数据库连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120215517149-1099105042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120215712383-811058416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：为users应用配置urls&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120230100243-725114664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第五步：创建用户模型类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120222405180-557632284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六步：生成迁移和执行迁移   在数据库中创建出表，在执行迁移前数据库中是没有表的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120224239493-172709557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120225237508-1365233956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120225318055-619455842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120230134477-1411414224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 第七步：创建页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120230453696-1517806368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第八步：写视图和配置urls&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120230514071-688251596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 第九步：启动程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1281894/201711/1281894-20171120230654368-1455028185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 15:08:00 +0000</pubDate>
<dc:creator>FocusBI</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/focusBI/p/7868737.html</dc:identifier>
</item>
<item>
<title>73、django之setting配置汇总 - 布吉岛丶</title>
<link>http://www.cnblogs.com/liluning/p/7868683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liluning/p/7868683.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面的随笔中我们经常会改setting配置也经常将一些配置混淆今天主要是将一些常见的配置做一个汇总。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;setting配置汇总&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、app路径&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.contenttypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.staticfiles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app1.apps.App1Config&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,   
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认已有 如果没有只要添加app名称即可 例如： 'app1'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新建的应用都要在这里添加&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、数据库配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果使用django的默认sqlite3数据库则不需要改&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
DATABASES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENGINE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.db.backends.sqlite3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: os.path.join(BASE_DIR, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db.sqlite3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果使用mysql数据库需要将上述数据库注掉修改如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
DATABASES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {         
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ENGINE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.db.backends.mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;你的数据库名称 数据库需要自己提前建好&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;USER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;你的数据库用户名&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PASSWORD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;你的数据库密码&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;你的数据库主机，留空默认为localhost&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;你的数据库端口&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;并且需要在应用的__init__.py文件添加&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
pymysql.install_as_MySQLdb()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;详情可以查看：&lt;a href=&quot;http://www.cnblogs.com/liluning/p/7729607.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/liluning/p/7729607.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、sql语句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
LOGGING =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;disable_existing_loggers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: False,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;handlers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;logging.StreamHandler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        },
    },
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loggers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.db.backends&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;handlers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;propagate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEBUG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        },
    }
}　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当你的操作与数据库相关时 会将我们的写的语句翻译成sql语句在服务端打印。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、静态文件目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
STATIC_URL = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/static/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用时目录&lt;/span&gt;
&lt;span&gt;
STATICFILES_DIRS&lt;/span&gt;=&lt;span&gt;[
    os.path.join(BASE_DIR,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;具体路径&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、如果数据库中的UserInfo(用户表)继承django内置AbstractUser&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）model需导入&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span&gt;import&lt;/span&gt; AbstractUser
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
AUTH_USER_MODEL = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;应用名.UserInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、中间件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自己写的中间件，例如在项目中的md文件夹下md.py文件中的M1与M2两个中间件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
MIDDLEWARE =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.security.SecurityMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.middleware.SessionMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.common.CommonMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.csrf.CsrfViewMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth.middleware.AuthenticationMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages.middleware.MessageMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.middleware.clickjacking.XFrameOptionsMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;md.md.M1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;md.md.M2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意自己写的中间件，配置要写在系统中的后面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;session存储的相关配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）数据库配置（默认）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d5019baa-e672-4d13-94db-3fb54293bd8b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d5019baa-e672-4d13-94db-3fb54293bd8b&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d5019baa-e672-4d13-94db-3fb54293bd8b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。
  
配置 settings.py
  
    SESSION_ENGINE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.backends.db&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引擎（默认）&lt;/span&gt;
&lt;span&gt;      
    SESSION_COOKIE_NAME ＝ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sessionid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）&lt;/span&gt;
    SESSION_COOKIE_PATH ＝ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的路径（默认）&lt;/span&gt;
    SESSION_COOKIE_DOMAIN = None                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的域名（默认）&lt;/span&gt;
    SESSION_COOKIE_SECURE = False                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Https传输cookie（默认）&lt;/span&gt;
    SESSION_COOKIE_HTTPONLY = True                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Session的cookie只支持http传输（默认）&lt;/span&gt;
    SESSION_COOKIE_AGE = 1209600                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie失效日期（2周）（默认）&lt;/span&gt;
    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否关闭浏览器使得Session过期（默认）&lt;/span&gt;
    SESSION_SAVE_EVERY_REQUEST = False                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否每次请求都保存Session，默认修改之后才保存（默认）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）缓存配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_aeec5132-db10-46c6-8f9d-d16d764bdcab&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aeec5132-db10-46c6-8f9d-d16d764bdcab&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aeec5132-db10-46c6-8f9d-d16d764bdcab&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 配置 settings.py
  
    SESSION_ENGINE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.backends.cache&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引擎&lt;/span&gt;
    SESSION_CACHE_ALIAS = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置&lt;/span&gt;
&lt;span&gt;  
  
    SESSION_COOKIE_NAME ＝ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sessionid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串&lt;/span&gt;
    SESSION_COOKIE_PATH ＝ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的路径&lt;/span&gt;
    SESSION_COOKIE_DOMAIN = None                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的域名&lt;/span&gt;
    SESSION_COOKIE_SECURE = False                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Https传输cookie&lt;/span&gt;
    SESSION_COOKIE_HTTPONLY = True                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Session的cookie只支持http传输&lt;/span&gt;
    SESSION_COOKIE_AGE = 1209600                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie失效日期（2周）&lt;/span&gt;
    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否关闭浏览器使得Session过期&lt;/span&gt;
    SESSION_SAVE_EVERY_REQUEST = False                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否每次请求都保存Session，默认修改之后才保存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3）默认配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_409c37cd-a653-41d0-9e1a-7735240983a4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_409c37cd-a653-41d0-9e1a-7735240983a4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_409c37cd-a653-41d0-9e1a-7735240983a4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;配置 settings.py
  
    SESSION_ENGINE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions.backends.file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 引擎&lt;/span&gt;
    SESSION_FILE_PATH = None                                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()        &lt;/span&gt;
    SESSION_COOKIE_NAME ＝ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sessionid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串&lt;/span&gt;
    SESSION_COOKIE_PATH ＝ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的路径&lt;/span&gt;
    SESSION_COOKIE_DOMAIN = None                                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie保存的域名&lt;/span&gt;
    SESSION_COOKIE_SECURE = False                               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Https传输cookie&lt;/span&gt;
    SESSION_COOKIE_HTTPONLY = True                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否Session的cookie只支持http传输&lt;/span&gt;
    SESSION_COOKIE_AGE = 1209600                                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Session的cookie失效日期（2周）&lt;/span&gt;
    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否关闭浏览器使得Session过期&lt;/span&gt;
    SESSION_SAVE_EVERY_REQUEST = False                          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否每次请求都保存Session，默认修改之后才保存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）也可以自定义配置 但是自定义的配置都要写到配置文件最后 代码中使用时可以导入配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.conf &lt;span&gt;import&lt;/span&gt; settings
&lt;/pre&gt;
&lt;pre&gt;
settings.配置名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）上面所有配置都是针对特定问题需要修改的 系统默认配置不做说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）上面配置只是前面django系列随笔所遇到的常用配置 后续所遇配置都会逐步在此随笔中持续添加跟新&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 Nov 2017 14:55:00 +0000</pubDate>
<dc:creator>布吉岛丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liluning/p/7868683.html</dc:identifier>
</item>
<item>
<title>使用dropwizard(3)-加入DI-dagger2 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/dropwizard-with-dagger2-example.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/dropwizard-with-dagger2-example.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.dropwizard.io/1.1.4/docs/_static/dropwizard-hat.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://www.darksword-armory.com/wp-content/uploads/2014/09/gothic-medieval-dagger-1816-1600x1067.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;习惯了Spring全家桶，对spring的容器爱不释手。使用dropwizard，看起来确实很轻，然而，真正使用的时候不得不面临一个问题。&lt;strong&gt;我们不可能一个resource就能把所有的业务逻辑囊括&lt;/strong&gt;！那么，必然就要有负责处理逻辑的代码，有要提取的公共的代码，要做面向接口开发等等。按照简单的用法，Java Bean就自己new，只要通过Jersey提供的web能力发出去就好。这样写下来，到处都需要new，难以测试等等。目前我最care的是，每个request过来都要new一堆重复的对象，垃圾回收频繁。写个单例不就解决了？是的，当然要想到单例，然后发现几乎所有的类都是设计成单例的。然后，一堆单例的代码写的死。这就是样板代码。于是，想到提取工具类，算了，不如用Dagger好了。&lt;/p&gt;

&lt;p&gt;Dagger是Java里开源的DI框架中最火的之一，主要用在Android领域，很多特性也多针对Android开发的。因为Android开发对省电，性能之类的要求比较高，因此抛弃了反射，直接在编译级别生成工厂。详细学习测试：&lt;a href=&quot;http://www.cnblogs.com/woshimrf/p/hello-dagger.html&quot;&gt;Dagger2之helloworld原理探究&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Ryan-Miao/l4dropwizard&quot; class=&quot;uri&quot;&gt;https://github.com/Ryan-Miao/l4dropwizard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;structure&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;.
├── pom.&lt;span class=&quot;fu&quot;&gt;xml&lt;/span&gt;
├── readme.&lt;span class=&quot;fu&quot;&gt;md&lt;/span&gt;
└── src
    └── main
        ├── java
        │   └── com
        │       └── test
        │           ├── HelloWorldApplication.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │           ├── bundles
        │           │   └── ConnectivityBundle.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │           ├── configuration
        │           │   ├── HelloWorldConfiguration.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │           │   └── modules
        │           │       ├── ConnectAndReadConfig.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │           │       └── GithubApiConfig.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │           └── domain
        │               ├── connect
        │               │   ├── FeignClientBuilder.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │   ├── GithubClient.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │   └── GithubConnector.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               ├── entiry
        │               │   ├── GithubUser.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │   └── Saying.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               ├── exception
        │               │   └── UpstreamException.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               ├── health
        │               │   └── TemplateHealthCheck.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               ├── ioc
        │               │   ├── component
        │               │   │   └── GithubComponent.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │   └── module
        │               │       ├── ConfigurationModule.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │       ├── ConnectorModule.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │       └── ServiceModule.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               ├── resource
        │               │   ├── GithubResource.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               │   └── HelloWorldResource.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │               └── service
        │                   ├── IGithubService.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        │                   └── impl
        │                       └── GithubService.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;
        └── resources
            └── config
                └── dev.&lt;span class=&quot;fu&quot;&gt;yml&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文基于之前的&lt;a href=&quot;http://www.cnblogs.com/woshimrf/tag/dropwizard/&quot;&gt;dropwizard入门&lt;/a&gt;演进.&lt;/p&gt;
&lt;h2 id=&quot;添加dagger依赖&quot;&gt;添加dagger依赖&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;properties&lt;/code&gt;结点下新增&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dagger.verion&amp;gt;2.12&amp;lt;/dagger.verion&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在dependencies下新增&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.google.dagger&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;dagger&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${dagger.verion}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;build.plugins&lt;/code&gt;下新增&lt;code&gt;plugin&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.6.1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;source&amp;gt;&lt;/span&gt;${java.version}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;target&amp;gt;&lt;/span&gt;${java.version}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;encoding&amp;gt;&lt;/span&gt;UTF-8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/encoding&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;annotationProcessorPaths&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;path&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.google.dagger&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;dagger-compiler&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${dagger.verion}&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/path&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/annotationProcessorPaths&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在IDEA设置中，找到&lt;code&gt;Build&amp;gt;Compiler&amp;gt;Annotation Processors&lt;/code&gt;, 选择&lt;code&gt;Enable annotation processing&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;创建一个component&quot;&gt;创建一个Component&lt;/h2&gt;
&lt;p&gt;下面创建Component，用来包容Resource类，对外提供Resource类。新建&lt;code&gt;com.test.domain.ioc.component.GithubComponent&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.domain.ioc.component;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.test.domain.ioc.module.ServiceModule;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.test.domain.resource.GithubResource;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Component;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.inject.Singleton;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by Ryan Miao on 10/26/17.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Singleton&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;(modules = {ServiceModule.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;})
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; GithubComponent {
     GithubResource &lt;span class=&quot;fu&quot;&gt;gitHubResource&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，这个&lt;code&gt;GithubResource&lt;/code&gt;需要注入一个service，于是声明一个&lt;code&gt;ServiceModule&lt;/code&gt;, 创建&lt;code&gt;com.test.domain.ioc.module.ServiceModule&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.domain.ioc.module;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.test.domain.service.IGithubService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.test.domain.service.impl.GithubService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Module;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Provides;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.inject.Singleton;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by Ryan Miao on 10/26/17.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Module&lt;/span&gt;(includes = ConnectorModule.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ServiceModule {

    &lt;span class=&quot;fu&quot;&gt;@Singleton&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; IGithubService &lt;span class=&quot;fu&quot;&gt;githubService&lt;/span&gt;(GithubService service) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; service;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ServiceModule&lt;/code&gt;用来提供service注入，service接着依赖connector层，新建&lt;code&gt;com.test.domain.ioc.module.ConnectorModule&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.domain.ioc.module;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.test.domain.connect.FeignClientBuilder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Module;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Provides;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.inject.Singleton;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by Ryan Miao on 10/26/17.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Module&lt;/span&gt;(includes = ConfigurationModule.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ConnectorModule {

    &lt;span class=&quot;fu&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Singleton&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; FeignClientBuilder &lt;span class=&quot;fu&quot;&gt;feignClientBuilder&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FeignClientBuilder&lt;/span&gt;();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;connecttor&lt;/code&gt;层中，需要调用GlobalConfiguration的配置项，所以，单独把配置提出来，引入。新增&lt;code&gt;com.test.domain.ioc.module.ConfigurationModule&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.test.domain.ioc.module;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.test.configuration.HelloWorldConfiguration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Module;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import dagger.Provides;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.inject.Singleton;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by Ryan Miao on 11/20/17.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ConfigurationModule {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; HelloWorldConfiguration configuration;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConfigurationModule&lt;/span&gt;(HelloWorldConfiguration configuration) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;configuration&lt;/span&gt; = configuration;
    }


    &lt;span class=&quot;fu&quot;&gt;@Provides&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Singleton&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HelloWorldConfiguration &lt;span class=&quot;fu&quot;&gt;helloWorldConfiguration&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; configuration;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是依赖的最底层，我们通过手动构造函数的方式注入configuration，这样可以在dropwizard启动时生成module，并且得到configuration。&lt;/p&gt;
&lt;h2 id=&quot;引入我们的component&quot;&gt;引入我们的Component&lt;/h2&gt;
&lt;p&gt;这时候，build一下，dagger就会自动生成我们的工厂。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在IDEA里的maven plugin里，右键，reimport。防止IDEA不认识dagger自动生成的类。dagger自动生成的类位于&lt;code&gt;target/generated-sources/annotations&lt;/code&gt;. 点击刷新按钮，刷新下maven依赖。&lt;/p&gt;
&lt;p&gt;然后，在&lt;code&gt;com.test.HelloWorldApplication&lt;/code&gt;中,新增&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;registerResources&lt;/span&gt;(HelloWorldConfiguration configuration, Environment environment) {
    GithubComponent component = DaggerGithubComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;()
            .&lt;span class=&quot;fu&quot;&gt;configurationModule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConfigurationModule&lt;/span&gt;(configuration))
            .&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();
    environment.&lt;span class=&quot;fu&quot;&gt;jersey&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(component.&lt;span class=&quot;fu&quot;&gt;gitHubResource&lt;/span&gt;());
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;DaggerGithubComponent&lt;/code&gt;要在maven install之后，dagger生成的。完整启动类如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HelloWorldApplication &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Application&amp;lt;HelloWorldConfiguration&amp;gt; {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HelloWorldApplication&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(args);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;hello-world&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;initialize&lt;/span&gt;(Bootstrap&amp;lt;HelloWorldConfiguration&amp;gt; bootstrap) {
        bootstrap.&lt;span class=&quot;fu&quot;&gt;addBundle&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConnectivityBundle&lt;/span&gt;());
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(HelloWorldConfiguration configuration, Environment environment) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; HelloWorldResource resource = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;HelloWorldResource&lt;/span&gt;(
                configuration.&lt;span class=&quot;fu&quot;&gt;getTemplate&lt;/span&gt;(),
                configuration.&lt;span class=&quot;fu&quot;&gt;getDefaultName&lt;/span&gt;()
        );
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; TemplateHealthCheck healthCheck =
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;TemplateHealthCheck&lt;/span&gt;(configuration.&lt;span class=&quot;fu&quot;&gt;getTemplate&lt;/span&gt;());
        environment.&lt;span class=&quot;fu&quot;&gt;healthChecks&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;template&quot;&lt;/span&gt;, healthCheck);
        environment.&lt;span class=&quot;fu&quot;&gt;jersey&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(resource);
        environment.&lt;span class=&quot;fu&quot;&gt;jersey&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(healthCheck);

        &lt;span class=&quot;fu&quot;&gt;registerResources&lt;/span&gt;(configuration, environment);

    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;registerResources&lt;/span&gt;(HelloWorldConfiguration configuration, Environment environment) {
        GithubComponent component = DaggerGithubComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;configurationModule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConfigurationModule&lt;/span&gt;(configuration))
                .&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();
        environment.&lt;span class=&quot;fu&quot;&gt;jersey&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(component.&lt;span class=&quot;fu&quot;&gt;gitHubResource&lt;/span&gt;());
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，我们的Resource也要改成Inject模式&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GithubResource {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; IGithubService service;

    &lt;span class=&quot;fu&quot;&gt;@Inject&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;GithubResource&lt;/span&gt;(IGithubService service) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;service&lt;/span&gt; = service;
    }

    &lt;span class=&quot;fu&quot;&gt;@GET&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Timed&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Path&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/users/{username}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; GithubUser &lt;span class=&quot;fu&quot;&gt;getUserProfile&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@PathParam&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String username) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; service.&lt;span class=&quot;fu&quot;&gt;getUserProfile&lt;/span&gt;(username);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动，运行。一切OK。以后就可以在需要注入的类的构造器上声明&lt;code&gt;@Inject&lt;/code&gt;, 或者在module里&lt;code&gt;@Provide&lt;/code&gt;，就可以实现构造解耦。测试不要太方便.&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 14:39:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/dropwizard-with-dagger2-example.html</dc:identifier>
</item>
<item>
<title>MXNet之ps-lite及parameter server原理 - Thaurun</title>
<link>http://www.cnblogs.com/heguanyou/p/7868596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heguanyou/p/7868596.html</guid>
<description>&lt;p&gt;ps-lite框架是DMLC组自行实现的parameter server通信框架，是DMLC其他项目的核心，例如其深度学习框架MXNET的分布式训练就依赖ps-lite的实现。&lt;/p&gt;
&lt;h2 id=&quot;parameter-server原理&quot;&gt;parameter server原理&lt;/h2&gt;
&lt;p&gt;在机器学习和深度学习领域，分布式的优化已经成了一种先决条件，因为单机已经解决不了目前快速增长的数据与参数带来的问题。现实中，训练数据的数量可能达到1TB到1PB之间，而训练过程中的参数可能会达到&lt;span class=&quot;math inline&quot;&gt;\(10^9\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(10^{12}\)&lt;/span&gt;。而往往这些模型的参数需要被所有的worker节点频繁的访问，这就会带来很多问题和挑战：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问这些巨量的参数，需要大量的网络带宽支持；&lt;/li&gt;
&lt;li&gt;很多机器学习算法都是连续型的，只有上一次迭代完成（各个worker都完成）之后，才能进行下一次迭代，这就导致了如果机器之间性能差距大（木桶理论），就会造成性能的极大损失；&lt;/li&gt;
&lt;li&gt;在分布式中，容错能力是非常重要的。很多情况下，算法都是部署到云环境中的（这种环境下，机器是不可靠的，并且job也是有可能被抢占的）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分布式系统中的同步与异步机制&quot;&gt;分布式系统中的同步与异步机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222248665-424098071.gif&quot; alt=&quot;synchronous&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图1 在同步的机制下，系统运行的时间是由最慢的worker节点与通信时间决定的&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222520555-494089097.gif&quot; alt=&quot;asynchronous&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图2 在异步的机制下，每个worker不能等待其它workers完成再运行下一次迭代。这样可以提高效率，但从迭代次数的角度来看，会减慢收敛的速度。&lt;/center&gt;
&lt;h3 id=&quot;parameter-server架构&quot;&gt;parameter server架构&lt;/h3&gt;
&lt;p&gt;在parameter server中，每个 server 实际上都只负责分到的部分参数（servers共同维持一个全局的共享参数），而每个 work 也只分到部分数据和处理任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222630040-842532264.png&quot; alt=&quot;ps_struct&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图3 parameter server的架构图，server 节点可以跟其他 server 节点通信，每个server负责自己分到的参数，server group 共同维持所有参数的更新。server manager node 负责维护一些元数据的一致性，比如各个节点的状态，参数的分配情况等；worker 节点之间没有通信，只跟自己对应的server进行通信。每个worker group有一个task scheduler，负责向worker分配任务，并且监控worker的运行情况。当有新的worker加入或者退出，task scheduler 负责重新分配任务。&lt;/center&gt;
&lt;p&gt;PS架构包括计算资源与机器学习算法两个部分。其中计算资源分为两个部分，参数服务器节点和工作节点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数服务器节点用来存储参数&lt;/li&gt;
&lt;li&gt;工作节点部分用来做算法的训练&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;机器学习算法也分成两个部分，即参数和训练：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数部分即模型本身，有一致性的要求，参数服务器也可以是一个集群，对于大型的算法，比如DNN，CNN，参数上亿的时候，自然需要一个集群来存储这么多的参数，因而，参数服务器也是需要调度的。&lt;/li&gt;
&lt;li&gt;训练部分自然是并行的，不然无法体现分布式机器学习的优势。因为参数服务器的存在，每个计算节点在拿到新的batch数据之后，都要从参数服务器上取下最新的参数，然后计算梯度，再将梯度更新回参数服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种设计有两种好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过将机器学习系统的共同之处模块化，算法实现代码更加简洁。&lt;/li&gt;
&lt;li&gt;作为一个系统级别共享平台优化方法，PS结构能够支持很多种算法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从而，PS架构有五个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高效的通信：异步通信不会拖慢计算&lt;/li&gt;
&lt;li&gt;弹性一致：将模型一致这个条件放宽松，允许在算法收敛速度和系统性能之间做平衡。&lt;/li&gt;
&lt;li&gt;扩展性强：增加节点无需重启网络&lt;/li&gt;
&lt;li&gt;错误容忍：机器错误恢复时间短，Vector Clock容许网络错误&lt;/li&gt;
&lt;li&gt;易用性： 全局共享的参数使用向量和矩阵表示，而这些又可以用高性能多线程库进行优化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;push-and-pull&quot;&gt;Push and Pull&lt;/h3&gt;
&lt;p&gt;在parameter server中，参数都是可以被表示成(key, value)的集合，比如一个最小化损失函数的问题，key就是feature ID，而value就是它的权值。对于稀疏参数，不存在的key，就可以认为是0。&lt;/p&gt;
&lt;p&gt;把参数表示成k-v， 形式更自然， 易于理，更易于编程解。workers跟servers之间通过push与pull来通信的。worker通过push将计算好的梯度发送到server，然后通过pull从server更新参数。为了提高计算性能和带宽效率，parameter server允许用户使用Range Push跟Range Pull 操作。&lt;/p&gt;
&lt;h3 id=&quot;tasksynchronous-and-asynchronous&quot;&gt;Task:Synchronous and Asynchronous&lt;/h3&gt;
&lt;p&gt;Task也分为同步和异步，区别如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222706758-1379643681.png&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图4 如果iter1需要在iter0 computation，push跟pull都完成后才能开始，那么就是Synchronous，反之就是Asynchronous。Asynchronous能够提高系统的效率（因为节省了很多等待的过程），但是，它可能会降低算法的收敛速率；&lt;/center&gt;
&lt;p&gt;所以，系统性能跟算法收敛速率之间是存在一个平衡，你需要同时考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算法对于参数非一致性的敏感度&lt;/li&gt;
&lt;li&gt;训练数据特征之间的关联度&lt;/li&gt;
&lt;li&gt;硬盘的存储容量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑到用户使用的时候会有不同的情况，parameter server 为用户提供了多种任务依赖方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222735336-2071530035.png&quot; alt=&quot;consistency&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图5 三种不同的依赖方式&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;Sequential：这里其实是 synchronous task，任务之间是有顺序的，只有上一个任务完成，才能开始下一个任务。&lt;/li&gt;
&lt;li&gt;Eventual： 跟sequential相反，所有任务之间没有顺序，各自独立完成自己的任务。&lt;/li&gt;
&lt;li&gt;Bounded Delay： 这是sequential 跟 eventual 之间的一个均衡，可以设置一个&lt;span class=&quot;math inline&quot;&gt;\(\tau\)&lt;/span&gt;作为最大的延时时间。也就是说，只有大于&lt;span class=&quot;math inline&quot;&gt;\(\tau\)&lt;/span&gt;之前的任务都被完成了，才能开始一个新的任务；极端的情况：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\tau=0\)&lt;/span&gt;，情况就是 Sequential；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\tau=\infty\)&lt;/span&gt;，情况就是 Eventual；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ps下的算法&quot;&gt;PS下的算法&lt;/h3&gt;
&lt;p&gt;算法1是没有经过优化的直接算法和它的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222820571-1265719957.png&quot; alt=&quot;Algorithm1&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图6 算法1&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222844274-72827043.png&quot; alt=&quot;Algorithm_1_1&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图7 算法1的流程&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222906524-389188620.png&quot; alt=&quot;Algorithm3&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图8 优化算法1后的算法3。&lt;/center&gt;
&lt;p&gt;算法3中的KKT Filter可以是用户自定义过滤：&lt;br/&gt;对于机器学习优化问题比如梯度下降来说，并不是每次计算的梯度对于最终优化都是有价值的，用户可以通过自定义的规则过滤一些不必要的传送，再进一步压缩带宽消耗：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发送很小的梯度值是低效的：&lt;br/&gt;因此可以自定义设置，只在梯度值较大的时候发送；&lt;/li&gt;
&lt;li&gt;更新接近最优情况的值是低效的：&lt;br/&gt;因此，只在非最优的情况下发送，可通过KKT来判断；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;ps-lite实现&quot;&gt;ps-lite实现&lt;/h2&gt;
&lt;p&gt;上面说了parameter server的原理，现在来看下这个是怎么实现的。ps-lite是DMLC实现parameter server的一个程序，也是MXNet的核心组件之一。&lt;/p&gt;
&lt;h3 id=&quot;ps-lite角色&quot;&gt;ps-lite角色&lt;/h3&gt;
&lt;p&gt;ps-lite包含三种角色：Worker、Server、Scheduler。具体关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222934305-1465696765.png&quot; alt=&quot;s_w_h&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9 三种角色的关系图&lt;/p&gt;
&lt;p&gt;Worker节点负责计算参数，并发参数push到Server，同时从Serverpull参数回来。&lt;br/&gt;Server节点负责管理Worker节点发送来的参数，并“合并”，之后供各个Worker使用。&lt;br/&gt;Scheduler节点负责管理Worker节点和Server节点的状态，worker与server之间的连接是通过Scheduler的。&lt;/p&gt;
&lt;h3 id=&quot;重要类&quot;&gt;重要类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201711/1191997-20171120222958430-670962158.png&quot; alt=&quot;class&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图10 重要类的关系图&lt;/center&gt;
&lt;ul readability=&quot;16&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Postoffice是全局管理类，单例模式创建。主要用来配置当前node的一些信息，例如当前node是哪种类型(server,worker,scheduler)，nodeid是啥，以及worker/server 的rank 到 node id的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Van是负责通信的类，是Postoffice的成员。Van中std::unordered_map senders_保存了node_id到连接的映射。Van只是定义了接口，具体实现是依赖ZMQ实现的ZMQVan，Van类负责建立起节点之间的互相连接（例如Worker与Scheduler之间的连接），并且开启本地的receiving thread用来监听收到的message。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Customer用来通信，跟踪request和response。每一个连接对应一个Customer实例，连接对方的id和Customer实例的id相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SimpleApp是一个基类；提供了发送接收int型的head和string型的body消息，以及注册消息处理函数。它有2个派生类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;KVServer是SimpleApp的派生类，用来保存key-values数据。里面的Process()被注册到Customer对象中，当Customer对象的receiving thread接受到消息时，就调用Process()对数据进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;KVWorker是SimpleApp的派生类，主要有Push()和Pull()，它们最后都会调用Send()函数，Send()对KVPairs进行切分，因为每个Server只保留一部分参数，因此切分后的SlicedKVpairs就会被发送给不同的Server。切分函数可以由用户自行重写，默认为DefaultSlicer，每个SlicedKVPairs被包装成Message对象，然后用van::send()发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;KVPairs封装了Key-Value结构，还包含了一个长度选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SArray是Shared array，像智能指针一样共享数据，接口类似vector。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Node封装了节点的信息，例如角色、ip、端口、是否是恢复节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Control封装了控制信息，例如命令类型、目的节点、barrier_group的id、签名。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Meta封装了元数据，发送者、接受者、时间戳、请求还是相应等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Message是要发送的信息，除了元数据外，还包括发送的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;运行脚本&quot;&gt;运行脚本&lt;/h3&gt;
&lt;p&gt;为了更好地看到ps-lite的运行原理，我们先来看下它在本地运行的脚本：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# set -x&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if [&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$#&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-lt&lt;/span&gt; 3&lt;span class=&quot;kw&quot;&gt; ]&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;usage: &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$0&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; num_servers num_workers bin [args..]&quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;exit&lt;/span&gt; -1&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_NUM_SERVER=$1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;shift&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_NUM_WORKER=$1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;shift&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;bin=$1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;shift&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;arg=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$@&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# start the scheduler&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_PS_ROOT_URI=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'127.0.0.1'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_PS_ROOT_PORT=&lt;/span&gt;8000
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_ROLE=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'scheduler'&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;${bin}&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;${arg}&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;amp;&lt;/span&gt;


&lt;span class=&quot;co&quot;&gt;# start servers&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_ROLE=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'server'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;((&lt;/span&gt;i=0; i&amp;lt;&lt;span class=&quot;ot&quot;&gt;${DMLC_NUM_SERVER}&lt;/span&gt;; ++i&lt;span class=&quot;kw&quot;&gt;))&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;HEAPPROFILE=&lt;/span&gt;./S&lt;span class=&quot;ot&quot;&gt;${i}&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;${bin}&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;${arg}&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;done&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# start workers&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;DMLC_ROLE=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'worker'&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;((&lt;/span&gt;i=0; i&amp;lt;&lt;span class=&quot;ot&quot;&gt;${DMLC_NUM_WORKER}&lt;/span&gt;; ++i&lt;span class=&quot;kw&quot;&gt;))&lt;/span&gt;; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;HEAPPROFILE=&lt;/span&gt;./W&lt;span class=&quot;ot&quot;&gt;${i}&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;${bin}&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;${arg}&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;amp;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;done&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;wait&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个脚本主要做了两件事，第一件是为不同的角色设置环境变量，第二件是在本地运行多个不同的角色。所以说ps-lite是要多个不同的进程（程序）共同合作完成工作的，ps-lite采取的是用环境变量来设置角色的配置。&lt;/p&gt;
&lt;h3 id=&quot;test_simple_app流程&quot;&gt;test_simple_app流程&lt;/h3&gt;
&lt;p&gt;test_simple_app.cc是一人很简单的app，其它复杂的流程原理这个程序差不多，所以我们就说说这个程序是怎么运行的。先来看下刚开始运行程序时，worker(W)\Server(S)\Scheduler(H)之间是怎么连接的，这里没有写Customer处理普通信息的流程。W\S\H代表上面脚本运行各个角色后在不同角色程序内的处理流程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;W\S\H：初始化SimpleApp --&amp;gt; New Customer（绑定Process函数） --&amp;gt; Customer起一个Receiving线程&lt;/li&gt;
&lt;li&gt;W\S\H：初始化static PostOffice，全局都用同一个PostOffice --&amp;gt; Create(Van)用来做通信的发/发 --&amp;gt; 从环境变量中读入配置 --&amp;gt; 确定不同的角色。&lt;/li&gt;
&lt;li&gt;W\S\H：Start() --&amp;gt; Van::Start(), my_node_/Scheduler的初始化&lt;/li&gt;
&lt;li&gt;W\S：绑定port并连接到同一个Scheduler&lt;/li&gt;
&lt;li&gt;W\S：发送信息到指定ID&lt;/li&gt;
&lt;li&gt;W\S\h：在van中起一个Reciving的线程&lt;/li&gt;
&lt;li&gt;H：收到信息并回发&lt;/li&gt;
&lt;li&gt;W\S: 收到信息&lt;/li&gt;
&lt;li&gt;W\S\H：Finalize()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Customer处理普通信息流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;H：app-&amp;gt;requst() --&amp;gt; 放这个请求入到tracker_中 --&amp;gt; send(msg) --&amp;gt; app-&amp;gt;wait()[等待收回发的信息]&lt;/li&gt;
&lt;li&gt;W/S：收到信息后放到recv_queue_中&lt;/li&gt;
&lt;li&gt;W/S：Customer的Reciving收到信息 --&amp;gt; call recv_handle_ --&amp;gt; process(recv)[处理信息] --&amp;gt; response_hadle_(recv) --&amp;gt; ReqHandle() --&amp;gt; response()[回发信息]&lt;/li&gt;
&lt;li&gt;H：收到回发的信息 --&amp;gt; 放入到recv_queue_中处理 --&amp;gt; 在Customer中的Reciving中处理&lt;/li&gt;
&lt;li&gt;H：当tracker_.first == tracker_.second时，释放app-&amp;gt;wait()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考引用：&lt;br/&gt;[1] &lt;a href=&quot;http://blog.csdn.net/stdcoutzyx/article/details/51241868&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/stdcoutzyx/article/details/51241868&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;http://blog.csdn.net/cyh_24/article/details/50545780&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/cyh_24/article/details/50545780&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;https://www.zybuluo.com/Dounm/note/529299&quot; class=&quot;uri&quot;&gt;https://www.zybuluo.com/Dounm/note/529299&lt;/a&gt;&lt;br/&gt;[4] &lt;a href=&quot;http://blog.csdn.net/KangRoger/article/details/73307685&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/KangRoger/article/details/73307685&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【防止爬虫转载而导致的格式问题——链接】：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/heguanyou/p/7868596.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/heguanyou/p/7868596.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 14:31:00 +0000</pubDate>
<dc:creator>Thaurun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heguanyou/p/7868596.html</dc:identifier>
</item>
<item>
<title>Spring JDBC 示例 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/spring_jdbc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/spring_jdbc.html</guid>
<description>&lt;p&gt;在使用普通的 JDBC 数据库时，就会很麻烦的写不必要的代码来处理异常，打开和关闭数据库连接等。但 Spring JDBC 框架负责所有的低层细节，从开始打开连接，准备和执行 SQL 语句，处理异常，处理事务，到最后关闭连接。&lt;/p&gt;
&lt;p&gt;所以当从数据库中获取数据时，你所做的是定义连接参数，指定要执行的 SQL 语句，每次迭代完成所需的工作。&lt;/p&gt;
&lt;p&gt;Spring JDBC 提供几种方法和数据库中相应的不同的类与接口。我将给出使用 &lt;strong&gt;JdbcTemplate&lt;/strong&gt; 类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。&lt;/p&gt;
&lt;h2 id=&quot;c5275f87e4d3a93e3d9712dba791cddd&quot;&gt;JdbcTemplate 类&lt;/h2&gt;
&lt;p&gt;JdbcTemplate 类执行 SQL 查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获 JDBC 异常并转换它们到 org.springframework.dao 包中定义的通用类、更多的信息、异常层次结构。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;JdbcTemplate&lt;/em&gt; 类的实例是&lt;em&gt;线程安全&lt;/em&gt;配置的。所以你可以配置 JdbcTemplate 的单个实例，然后将这个共享的引用安全地注入到多个 DAOs 中。&lt;/p&gt;
&lt;p&gt;使用 JdbcTemplate 类时常见的做法是在你的 Spring 配置文件中配置数据源，然后共享数据源 bean 依赖注入到 DAO 类中，并在数据源的设值函数中创建了 JdbcTemplate。&lt;/p&gt;
&lt;p&gt;想要理解带有 jdbc 模板类的 Spring JDBC 框架的相关概念，让我们编写一个简单的示例，来实现下述 Student 表的所有 CRUD 操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; Student(
   ID   &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
   NAME &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
   AGE  &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
   &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (ID)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在继续之前，让我们适当地使用 Eclipse IDE 并按照如下所示的步骤创建一个 Spring 应用程序：&lt;/p&gt;
&lt;table class=&quot;table table-bordered&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr&gt;&lt;th&gt;步骤&lt;/th&gt;
&lt;th&gt; &lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;创建一个名为 &lt;em&gt;SpringExample&lt;/em&gt; 的项目，并在创建的项目中的 &lt;strong&gt;src&lt;/strong&gt; 文件夹下创建包 &lt;em&gt;com.cnblogs&lt;/em&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;使用 &lt;em&gt;Add External JARs&lt;/em&gt; 选项添加必需的 Spring 库&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;在项目中添加 Spring JDBC 指定的最新的库 &lt;strong&gt;mysql-connector-java.jar&lt;/strong&gt;，&lt;strong&gt;org.springframework.jdbc.jar&lt;/strong&gt; 和 &lt;strong&gt;org.springframework.transaction.jar&lt;/strong&gt;。如果这些库不存在，你可以下载它们。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;创建 DAO 接口 &lt;em&gt;StudentDAO&lt;/em&gt; 并列出所有必需的方法。尽管这一步不是必需的而且你可以直接编写 &lt;em&gt;StudentJDBCTemplate&lt;/em&gt; 类，但是作为一个好的实践，我们最好还是做这一步。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;在 &lt;em&gt;com.cnblogs&lt;/em&gt; 包下创建其他的必需的 Java 类 &lt;em&gt;Student&lt;/em&gt;，&lt;em&gt;StudentMapper&lt;/em&gt;，&lt;em&gt;StudentJDBCTemplate&lt;/em&gt; 和 &lt;em&gt;MainApp&lt;/em&gt; 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;确保你已经在 TEST 数据库中创建了 &lt;strong&gt;Student&lt;/strong&gt; 表。并确保你的 MySQL 服务器运行正常，且你可以使用给出的用户名和密码读/写访问数据库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;在 &lt;strong&gt;src&lt;/strong&gt; 文件夹下创建 Beans 配置文件 &lt;em&gt;Beans.xml&lt;/em&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;最后一步是创建所有的 Java 文件和 Bean 配置文件的内容并按照如下所示的方法运行应用程序。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下是数据访问对象接口文件 &lt;strong&gt;StudentDAO.java&lt;/strong&gt; 的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.sql.DataSource;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; StudentDAO {
   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
    * This is the method to be used to initialize
    * database resources ie. connection.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDataSource(DataSource ds);
   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
    * This is the method to be used to create
    * a record in the Student table.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; create(String name, Integer age);
   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
    * This is the method to be used to list down
    * a record from the Student table corresponding
    * to a passed student id.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student getStudent(Integer id);
   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
    * This is the method to be used to list down
    * all the records from the Student table.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt; listStudents();
   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
    * This is the method to be used to delete
    * a record from the Student table corresponding
    * to a passed student id.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(Integer id);
   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
    * This is the method to be used to update
    * a record into the Student table.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Integer id, Integer age);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是 &lt;strong&gt;Student.java&lt;/strong&gt; 文件的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是 &lt;strong&gt;StudentMapper.java&lt;/strong&gt; 文件的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.RowMapper;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StudentMapper &lt;span&gt;implements&lt;/span&gt; RowMapper&amp;lt;Student&amp;gt;&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student mapRow(ResultSet rs, &lt;span&gt;int&lt;/span&gt; rowNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
      Student student &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
      student.setId(rs.getInt(&lt;/span&gt;&quot;id&quot;&lt;span&gt;));
      student.setName(rs.getString(&lt;/span&gt;&quot;name&quot;&lt;span&gt;));
      student.setAge(rs.getInt(&lt;/span&gt;&quot;age&quot;&lt;span&gt;));
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; student;
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是为定义的 DAO 接口 StudentDAO 的实现类文件 &lt;strong&gt;StudentJDBCTemplate.java&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.sql.DataSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StudentJDBCTemplate &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; StudentDAO {
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DataSource dataSource;
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplateObject; 
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDataSource(DataSource dataSource) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dataSource =&lt;span&gt; dataSource;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.jdbcTemplateObject = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdbcTemplate(dataSource);
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; create(String name, Integer age) {
      String SQL &lt;/span&gt;= &quot;insert into Student (name, age) values (?, ?)&quot;&lt;span&gt;;     
      jdbcTemplateObject.update( SQL, name, age);
      System.out.println(&lt;/span&gt;&quot;Created Record Name = &quot; + name + &quot; Age = &quot; +&lt;span&gt; age);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student getStudent(Integer id) {
      String SQL &lt;/span&gt;= &quot;select * from Student where id = ?&quot;&lt;span&gt;;
      Student student &lt;/span&gt;=&lt;span&gt; jdbcTemplateObject.queryForObject(SQL, 
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Object[]{id}, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StudentMapper());
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; student;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Student&amp;gt;&lt;span&gt; listStudents() {
      String SQL &lt;/span&gt;= &quot;select * from Student&quot;&lt;span&gt;;
      List &lt;/span&gt;&amp;lt;Student&amp;gt; students =&lt;span&gt; jdbcTemplateObject.query(SQL, 
                                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StudentMapper());
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; students;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(Integer id){
      String SQL &lt;/span&gt;= &quot;delete from Student where id = ?&quot;&lt;span&gt;;
      jdbcTemplateObject.update(SQL, id);
      System.out.println(&lt;/span&gt;&quot;Deleted Record with ID = &quot; +&lt;span&gt; id );
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Integer id, Integer age){
      String SQL &lt;/span&gt;= &quot;update Student set age = ? where id = ?&quot;&lt;span&gt;;
      jdbcTemplateObject.update(SQL, age, id);
      System.out.println(&lt;/span&gt;&quot;Updated Record with ID = &quot; +&lt;span&gt; id );
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是 &lt;strong&gt;MainApp.java&lt;/strong&gt; 文件的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cnblogs;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cnblogs.StudentJDBCTemplate;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainApp {
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
      ApplicationContext context &lt;/span&gt;= 
             &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;Beans.xml&quot;&lt;span&gt;);
      StudentJDBCTemplate studentJDBCTemplate &lt;/span&gt;=&lt;span&gt; 
      (StudentJDBCTemplate)context.getBean(&lt;/span&gt;&quot;studentJDBCTemplate&quot;&lt;span&gt;);    
      System.out.println(&lt;/span&gt;&quot;------Records Creation--------&quot;&lt;span&gt; );
      studentJDBCTemplate.create(&lt;/span&gt;&quot;Zara&quot;, 11&lt;span&gt;);
      studentJDBCTemplate.create(&lt;/span&gt;&quot;Nuha&quot;, 2&lt;span&gt;);
      studentJDBCTemplate.create(&lt;/span&gt;&quot;Ayan&quot;, 15&lt;span&gt;);
      System.out.println(&lt;/span&gt;&quot;------Listing Multiple Records--------&quot;&lt;span&gt; );
      List&lt;/span&gt;&amp;lt;Student&amp;gt; students =&lt;span&gt; studentJDBCTemplate.listStudents();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Student record : students) {
         System.out.print(&lt;/span&gt;&quot;ID : &quot; +&lt;span&gt; record.getId() );
         System.out.print(&lt;/span&gt;&quot;, Name : &quot; +&lt;span&gt; record.getName() );
         System.out.println(&lt;/span&gt;&quot;, Age : &quot; +&lt;span&gt; record.getAge());
      }
      System.out.println(&lt;/span&gt;&quot;----Updating Record with ID = 2 -----&quot;&lt;span&gt; );
      studentJDBCTemplate.update(&lt;/span&gt;2, 20&lt;span&gt;);
      System.out.println(&lt;/span&gt;&quot;----Listing Record with ID = 2 -----&quot;&lt;span&gt; );
      Student student &lt;/span&gt;= studentJDBCTemplate.getStudent(2&lt;span&gt;);
      System.out.print(&lt;/span&gt;&quot;ID : &quot; +&lt;span&gt; student.getId() );
      System.out.print(&lt;/span&gt;&quot;, Name : &quot; +&lt;span&gt; student.getName() );
      System.out.println(&lt;/span&gt;&quot;, Age : &quot; +&lt;span&gt; student.getAge());      
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下述是配置文件 &lt;strong&gt;Beans.xml&lt;/strong&gt; 的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; 
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Initialization for data source &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; 
      class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClassName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/TEST&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Definition for studentJDBCTemplate bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;studentJDBCTemplate&quot;&lt;/span&gt;&lt;span&gt; 
      class&lt;/span&gt;&lt;span&gt;=&quot;com.cnblogs.StudentJDBCTemplate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;  ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;    
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你完成创建源和 bean 配置文件后，运行应用程序。如果你的应用程序一切运行顺利的话，将会输出如下所示的消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
------Records Creation--------&lt;span&gt;
Created Record Name &lt;/span&gt;= Zara Age = 11&lt;span&gt;
Created Record Name &lt;/span&gt;= Nuha Age = 2&lt;span&gt;
Created Record Name &lt;/span&gt;= Ayan Age = 15
------Listing Multiple Records--------&lt;span&gt;
ID : &lt;/span&gt;1, Name : Zara, Age : 11&lt;span&gt;
ID : &lt;/span&gt;2, Name : Nuha, Age : 2&lt;span&gt;
ID : &lt;/span&gt;3, Name : Ayan, Age : 15
----Updating Record with ID = 2 -----&lt;span&gt;
Updated Record with ID &lt;/span&gt;= 2
----Listing Record with ID = 2 -----&lt;span&gt;
ID : &lt;/span&gt;2, Name : Nuha, Age : 20
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以尝试自己删除在我的例子中我没有用到的操作，但是现在你有一个基于 Spring JDBC 框架的工作应用程序，你可以根据你的项目需求来扩展这个框架，添加复杂的功能。还有其他方法来访问你使用 &lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt; 和 &lt;strong&gt;SimpleJdbcTemplate&lt;/strong&gt; 类的数据库，所以如果你有兴趣学习这些类的话，那么你可以查看 Spring 框架的参考手册。&lt;/p&gt;
</description>
<pubDate>Mon, 20 Nov 2017 13:49:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/spring_jdbc.html</dc:identifier>
</item>
</channel>
</rss>