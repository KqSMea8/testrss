<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>------- 软件调试——挫败 QQ.exe 的内核模式保护机制 ------- - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8419853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8419853.html</guid>
<description>
&lt;p&gt;————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQ 是一款热门的即时通信（IM）类工具，在安装时刻会向系统分区的 \..\windows\system32\drivers 路径下生成两个驱动程序文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQProtect.sys 与 QQFrmMgr.sys ，前者是 QQProtect.exe（QQ 安全防护进程，又称 Q 盾）的内核模式组件；后者是一种过滤型驱动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时还会向注册表位置 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\ 创建对应名称的键，其中有重要的两个&lt;span&gt;子键&lt;/span&gt;控制&lt;/span&gt;&lt;span&gt;这两个驱动的加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方&lt;/span&gt;&lt;span&gt;式：“type”与“start”——对于 QQProtect.sys ，其键值分别为 1 和 2，这意味着由 services.exe（服务控制&lt;/span&gt;&lt;span&gt;管理器）自动将 QQProtect.sys 载入内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空&lt;/span&gt;&lt;span&gt;间；&lt;/span&gt;&lt;span&gt;对于 QQFrmMgr.sys，其键值分别为 1 和 1，这意味着在内核初始化期间，由 ntoskrnl.exe 将 QQFrmMgr.sys 载入内核空间，就加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的顺序而言，QQFrmMgr.sys 早于 QQProtect.sys ，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205223240373-1483520590.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;尽管这两个驱动并非 Rootkit 或者恶意软件，但它们确实会 hook 系统服务调度表/Shadow、在 &lt;span&gt;System 进程&lt;/span&gt;中注入内核线程、注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;册一些通知回调。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以也算是更改了系统的一些关键数据结构来进行非正当活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文探讨如何使用内核调试器 WinDbg.exe 来检查诸如此类为保护 QQ 进程而采取的内核空间手段，然后把系统还原至“干净”状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试环境是两台真实的计算机（双机物理调试）——&lt;span&gt;运行 Windows 7 的 宿主机（调试机），以及运行 Windows 8.1 的目标机（被调试机，已安装了 QQ）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者通过以太网线连接进行调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，通过以太网线执行双机物理调试时，对调试机的网卡无特殊要求；但是被调试机的网卡必须被 &lt;/span&gt;&lt;span&gt;Debugging Tools for Windows 所支持（亦即 Kd.exe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与 WinDbg.exe），而且被调试机上的操作系统版本需要是 windows 8 或者更后面的版本；&lt;/span&gt;&lt;span&gt;调试机上的操作系统需要是 windows xp 或更后面的版本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用以太网调试的一大好处就是，通信介质获取方便——相较于老旧的串口线（RS-232）以及主板上基本被淘汰的 COM 模块而言，Cat5 标准以上的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络线随便在电脑城就能买到，而且主板上绝不可能没有网络接口卡使用的 RJ-45 端口。。。。想必以太网调试一定会成为日后的标准！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一方面，我也实施了&lt;span&gt;物理-虚拟机调试&lt;/span&gt;，虚拟机作为被调试机，其上运行 Windows 7，这样不但能够对比出，QQ 驱动针对不同内核版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（Windows 7 是内核版本 6.1 ；Windows 8.1 是内核版本 6.3）所表现出来的逻辑差异，还能够明确 QQ 驱动是否采取了“反虚拟机”&lt;/span&gt;&lt;span&gt;技术，并且揭示它在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真实机器上的行为！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因此下面的调试过程中，所有与真实机器上不同的结果我都会另行说明。&lt;/span&gt;&lt;span&gt;在开始之前，来过目一下我配置的双机物理调试参数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cd &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:\Windows Kits\10\Debuggers\x86&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; d: &amp;amp;&amp;amp; windbg.exe -n -v -logo d:\networking_physical_host-target_debugging.txt -y SRV*E:\windows8_1_retail_symbols*http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;msdl.microsoft.com/download/symbols -k net:port=60111,key=shayi.1983.gmail.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❶ &lt;/span&gt;&lt;span&gt;我将 Windows Kits 驱动开发工具包安装到了“d:\Windows Kits”目录下；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❷ 输出调试信息到指定的日志文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❸ 指定微软的符号服务器 URL，这样调试器就可以通过 HTTP GET 请求，按需从服务器下载并解析特定内核模块中的函数符号；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❹ 以及预先存储在本地的符号文件（可以从 MSDN 站点下载，整个 MSI 封装的符号包大小约为五、六百 MB）所在路径；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （&lt;span&gt;注意，宿主机上内核版本的不同导致需要分别下载对应的符号文件，并指定为调试参数&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❺ 指定通过以太网调试（net），宿主机上开启调试端口为 UDP 的 60111；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;❻ 最后的 key 可以任意指定，但其中的 4 个子域之间需要用点号分隔开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于目标机上的对应配置，请各位参见 MSDN 文档，这里就不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;——————————————————————————————————————————————————————————&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先在 Windows 8.1 目标机上通过 Process Explorer 浏览到 System 进程中的系统线程，其中有一个 QQ 内核线程是由&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQFrmMgr.sys &lt;/span&gt;&lt;span&gt;创建的，该线程的启动地址距离所属模块被载入基址的偏移量为 0x5e34 ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205223811154-517512944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们的目标是结束该线程的执行，通常的做法是用系统内置的 &lt;span&gt;APC（异步过程调用）&lt;/span&gt;机制来实现。APC 就是运行在特定线程上下文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;例程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从编程角度来讲，调用 KeInitializeApc() 初始化一个 &lt;span&gt;nt!_KAPC&lt;/span&gt; 结构，并将其关联到该 QQ 内核线程的 &lt;span&gt;nt!_KTHREAD&lt;/span&gt; 结构，&lt;/span&gt;&lt;span&gt;设定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该 APC 例程回调为 &lt;/span&gt;&lt;span&gt;&lt;span&gt;PspExitThread()&lt;/span&gt;；&lt;/span&gt;&lt;span&gt;然后利用 KeInsertQueueApc() 通过这个 nt!_KTHREAD 结构来排入该 QQ 内核线程的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APC 队列，如此一来，&lt;/span&gt;&lt;span&gt;当该 APC 被交付时，&lt;/span&gt;&lt;span&gt;就会在该 QQ 内核线程的执行上下文中调用 PspExitThread()，从而终止掉该 QQ 内&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在调试环境下，没有对应的内核 API 可用，所以我们必须手工构造 APC、指定回调函数、关联线程、以及排入队列，如下步骤所&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：查询 System 进程的 nt!_EPROCESS 结构地址；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：定位到其中的线程双向链表头部，然后开始遍历这个链表中的每一个 nt!_ETHREAD 结构，找出那些启动地址位于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQFrmMgr.sys &lt;/span&gt;&lt;span&gt;模块空间内的线程：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224028341-591872758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 相应的 WinDbg 命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; !list &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-t nt!_LIST_ENTRY.FLink -e -x \&quot;r @$t3=@$extret-@$t1; &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; r @$t4= @$t3+&lt;span&gt;@$t2;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; r @$t5=&lt;span&gt;poi(@$t4);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; .&lt;span&gt;if&lt;/span&gt;(@@((unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;gt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82000000&lt;/span&gt; &amp;amp;&amp;amp; (unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;lt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82017b00&lt;/span&gt;)){r @$t3;dt -b nt!&lt;span&gt;_ETHREAD Cid. @$t3; dds @$t4 l1;}; 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; \&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 8565e5c0+@$t0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224314466-232482037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224412404-2063064714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：手工构建一个 nt!_KAPC 结构，指定回调函数、关联线程、以及排入队列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3-1）：查询 QQFrmMgr.sys 模块内部的 section 信息，注意到其中的 .data section 后紧接 INIT section：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224455920-823370704.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上图可知，.data section 起始 RVA 为 11800，大小 3C80，结束 RVA 为 15480，这刚好是 INIT section 的起始 RVA。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INIT section 的属性中，&lt;span&gt;“&lt;span&gt;Discardable”与“Execute Read Write”完美匹配了手工构建 APC 需要的写属性，以及回调函数需要&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;执行属性，所以它是理想&lt;/span&gt;&lt;span&gt;的目标 section。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3-2）：从 INIT section 起始地址初始化 0x200 字节内存，此块区域用于 nt!_KAPC 结构和回调函数&lt;/span&gt;&lt;span&gt;（nt!_KAPC 的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;KernelRoutine&lt;/span&gt; 字段）。如下图所示，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在地址 &lt;span&gt;82015480&lt;/span&gt; 处构造的回调函数调用 PspExitThread() 来结束当前线程&lt;/span&gt;&lt;span&gt;的运行；然后在地址 &lt;span&gt;82015500&lt;/span&gt; 处构造一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nt!_KAPC 结构；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205224640623-1460077245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; r @$t0=&lt;span&gt;82015500&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; r @$t1=&lt;span&gt;8b9ccbc0; 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; r@$t2=&lt;span&gt;82015480&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Type=&lt;span&gt;18&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Size=sizeof(nt!&lt;span&gt;_KAPC);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Thread=&lt;span&gt;@$t1;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;KernelRoutine=&lt;span&gt;@$t2;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; ?? ((nt!_KAPC*)@$t0)-&amp;gt;Inserted=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; r @$t3=@@(&amp;amp;(((nt!_ETHREAD*)@$t1)-&amp;gt;Tcb.ApcState.ApcListHead[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; r @$t4=@@(&amp;amp;(((nt!_KAPC*)@$t0)-&amp;gt;&lt;span&gt;ApcListEntry));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; r @$t5=@@(((nt!_LIST_ENTRY*)@$t3)-&amp;gt;&lt;span&gt;Flink);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t4)-&amp;gt;Flink=&lt;span&gt;@$t5;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t4)-&amp;gt;Blink=&lt;span&gt;@$t3;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t5)-&amp;gt;Blink=&lt;span&gt;@$t4;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; ?? ((nt!_LIST_ENTRY*)@$t3)-&amp;gt;Flink=&lt;span&gt;@$t4;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; ?? ((nt!_ETHREAD*)@$t1)-&amp;gt;Tcb.ApcState.KernelApcPending=&lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;变量“t1”的值是前面查询到的 QQ 内核线程的 nt!_ETHREAD 结构；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量“t3”用来定位到 nt!_ETHREAD 结构中的第一个 APC 队列头部（&lt;span&gt;Tcb.ApcState.ApcListHead[0]&lt;/span&gt;）；这个队列头部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的“Flink”字段&lt;/span&gt;&lt;span&gt;（指向下一个 nt!_KAPC 结构）由变量“t5”存储；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量“t4”亦即我们构建的 nt!_KAPC 结构中的“&lt;span&gt;ApcListEntry&lt;/span&gt;”字段，它被用来初始化“t5”；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种初始化逻辑类似于下面的 C 代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  KTHREAD.ApcState.ApcListHead[&lt;span&gt;0&lt;/span&gt;]-&amp;gt;Flink = KAPC-&amp;gt;ApcListEntry;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;验证我们的操作是否正确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225222857-1751485209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;整个过程的形象图示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225324388-357548917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了理解 APC 交付的机制，我们在回调函数入口处设置一个断点，然后就能够通过栈回溯信息得知该回调是如何被调用的，按&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下“g”键&lt;/span&gt;&lt;span&gt;恢复目标机器的执&lt;/span&gt;&lt;span&gt;行，等待 APC 交付时触发断点：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225427248-1318213836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从上图可以看到，这种 APC 交付机制其实并不神秘—— 传递给 PspSystemThreadStartup() 的首个参数就是 QQFrmMgr.sys 创&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建的 &lt;/span&gt;&lt;span&gt;QQ 内核线程的启动地&lt;/span&gt;&lt;span&gt;址，表明它被调度运行了；经过一系列调用后，&lt;span&gt;KiSwapThread() 从它接收到的首个参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（0x8b9ccbc0，亦即 QQ 内核线程的 nt!_ETHREAD 结构地址）中，&lt;/span&gt;&lt;span&gt;&lt;span&gt;定位到其 APC 队列头部，然后调用链表中第一个 nt!_KAPC&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;结构的&lt;/span&gt;&lt;span&gt;“KernelRoutine”回调，从而触发我们先前设置的断点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按下“g”键继续运行，导致 PspExitThread() 把 QQ 内核线程终止掉然后返回，现在通过 Process Explorer 浏览目标机器上，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;System 进程中的系统线程&lt;/span&gt;&lt;span&gt;们，已经找不到 QQFrmMgr.sys+0x5e34 那个线程了，另一方面，也可以在调试机器上验证：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; r @$t0=@@(#FIELD_OFFSET(nt!&lt;span&gt;_EPROCESS, ThreadListHead));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; r @$t1= @@(#FIELD_OFFSET(nt!&lt;span&gt;_ETHREAD, ThreadListEntry));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; r @$t2=@@(#FIELD_OFFSET(nt!&lt;span&gt;_ETHREAD, StartAddress));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; !list &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-t nt!_LIST_ENTRY.FLink -e -x \&quot;r @$t3=@$extret-@$t1; &lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; r @$t4= @$t3+&lt;span&gt;@$t2; 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; r @$t5=&lt;span&gt;poi(@$t4);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; .&lt;span&gt;if&lt;/span&gt;(@@((unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;gt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82000000&lt;/span&gt; &amp;amp;&amp;amp; (unsigned &lt;span&gt;long&lt;/span&gt;)@$t5&amp;lt;(unsigned &lt;span&gt;long&lt;/span&gt;)&lt;span&gt;0x82017b00&lt;/span&gt;)){r @$t3;dt -b nt!_ETHREAD Cid. ExitStatus @$t3; dt -b nt!&lt;span&gt;_KTHREAD Header. @$t3; }; 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; \&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 8565e5c0+@$t0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1318637/201802/1318637-20180205225814763-1020555222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结：本篇讨论了如何利用内核提供的基础设施——APC——来挫败 QQ 过滤驱动向内核空间注入的可执行代码，并在基于 &lt;/span&gt;&lt;span&gt;Windows 8.1（NT 6.3 版内&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;核）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;的真实机器上成功实践，限于篇幅，后续博文将介绍如何检测并还原 QQ 驱动修改的其它内核数据结构，&lt;/span&gt;&lt;span&gt;以及清除它安装的钩子例程！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;——————————————————————————————————————————————————————————————————————————————————&lt;/p&gt;

</description>
<pubDate>Mon, 05 Feb 2018 15:20:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8419853.html</dc:identifier>
</item>
<item>
<title>redis通过pipeline提升吞吐量 - zale.tang</title>
<link>http://www.cnblogs.com/littleatp/p/8419796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/8419796.html</guid>
<description>&lt;h2 id=&quot;案例目标&quot;&gt;案例目标&lt;/h2&gt;
&lt;p&gt;简单介绍 redis pipeline 的机制，结合一段实例说明pipeline 在提升吞吐量方面发生的效用。&lt;/p&gt;
&lt;h2 id=&quot;案例背景&quot;&gt;案例背景&lt;/h2&gt;
&lt;p&gt;应用系统在数据推送或事件处理过程中，往往出现数据流经过多个网元；&lt;br/&gt;然而在某些服务中，数据操作对redis 是强依赖的，在最近的一次分析中发现：&lt;br/&gt;&lt;strong&gt;一次数据推送会对 redis 产生近30次读写操作！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据推送业务中的性能压测中，以数据上报 -&amp;gt; 下发应答为一次事务；&lt;br/&gt;而对于这样的读写模型，redis 的操作过于频繁，很快便导致系统延时过高，吞吐量低下，无法满足目标；&lt;/p&gt;
&lt;p&gt;优化过程 主要针对业务代码做的优化，其中redis 操作经过大量合并，最终降低到原来的1/5，而系统吞吐量也提升明显。&lt;br/&gt;其中，&lt;strong&gt;redis pipeline(管道机制)&lt;/strong&gt; 的应用是一个关键手段。&lt;/p&gt;
&lt;h2 id=&quot;pipeline的解释&quot;&gt;pipeline的解释&lt;/h2&gt;
&lt;p&gt;Pipeline指的是管道技术，指的是客户端允许将多个请求依次发给服务器，过程中而不需要等待请求的回复，在最后再一并读取结果即可。&lt;br/&gt;管道技术使用广泛，例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。&lt;br/&gt;Redis很早就支持管道（pipeline）技术。(因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作Redis)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通请求模型&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184814060-1691050944.png&quot;/&gt;&lt;br/&gt;[图-pipeline1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pipeline请求模型&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184821607-996015857.png&quot;/&gt;&lt;br/&gt;[图-pipeline2]&lt;/p&gt;
&lt;p&gt;从两个图的对比中可看出，普通的请求模型是同步的，每次请求对应一次IO操作等待；&lt;br/&gt;而Pipeline 化之后所有的请求合并为一次IO，除了时延可以降低之外，还能大幅度提升系统吞吐量。&lt;/p&gt;
&lt;h2 id=&quot;代码实例&quot;&gt;代码实例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br/&gt;本地开启50个线程，每个线程完成1000个key的写入，对比pipeline开启及不开启两种场景下的性能表现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关常量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   // 并发任务
    private static final int taskCount = 50;
    // pipeline大小
    private static final int batchSize = 10;
    // 每个任务处理命令数
    private static final int cmdCount = 1000;

    private static final boolean usePipeline = true;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化连接&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxActive(200);
        poolConfig.setMaxIdle(100);
        poolConfig.setMaxWait(2000);
        poolConfig.setTestOnBorrow(false);
        poolConfig.setTestOnReturn(false);

        jedisPool = new JedisPool(poolConfig, host, port);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;并发启动任务，统计执行时间&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {
        init();

        flushDB();

        long t1 = System.currentTimeMillis();
        ExecutorService executor = Executors.newCachedThreadPool();

        CountDownLatch latch = new CountDownLatch(taskCount);
        for (int i = 0; i &amp;lt; taskCount; i++) {
            executor.submit(new DemoTask(i, latch));
        }

        latch.await();
        executor.shutdownNow();

        long t2 = System.currentTimeMillis();

        System.out.println(&quot;execution finish time(s):&quot; + (t2 - t1) / 1000.0);

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DemoTask&lt;/strong&gt; 封装了执行key写入的细节，区分不同场景&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void run() {
            logger.info(&quot;Task[{}] start.&quot;, id);
            try {
                if (usePipeline) {
                    runWithPipeline();
                } else {
                    runWithNonPipeline();
                }
            } finally {
                latch.countDown();
            }

            logger.info(&quot;Task[{}] end.&quot;, id);
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不使用Pipeline的场景比较简单，循环执行set操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            for (int i = 0; i &amp;lt; cmdCount; i++) {
                Jedis jedis = get();
                try {
                    jedis.set(key(i), UUID.randomUUID().toString());
                } finally {
                    if (jedis != null) {
                        jedisPool.returnResource(jedis);
                    }
                }
                if (i % batchSize == 0) {
                    logger.info(&quot;Task[{}] process -- {}&quot;, id, i);
                }
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Pipeline，需要处理分段，如10个作为一批命令执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         for (int i = 0; i &amp;lt; cmdCount;) {
                Jedis jedis = get();

                try {
                    Pipeline pipeline = jedis.pipelined();
                    int j;
                    for (j = 0; j &amp;lt; batchSize; j++) {
                        if (i + j &amp;lt; cmdCount) {
                            pipeline.set(key(i + j), UUID.randomUUID().toString());
                        } else {
                            break;
                        }
                    }
                    pipeline.sync();
                    logger.info(&quot;Task[{}] pipeline -- {}&quot;, id, i + j);

                    i += j;

                } finally {
                    if (jedis != null) {
                        jedisPool.returnResource(jedis);
                    }
                }

            }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行结果&quot;&gt;运行结果&lt;/h3&gt;
&lt;p&gt;不使用Pipeline，整体执行26s；而使用Pipeline优化后的代码，执行时间仅需要3s！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NoPipeline-stat&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184840295-630333542.png&quot;/&gt;&lt;br/&gt;[图-nopipeline]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pipeline-stat&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/242916/201802/242916-20180205184856732-300352579.png&quot;/&gt;&lt;br/&gt;[图-pipeline]&lt;/p&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;pipeline机制可以优化吞吐量，但无法提供原子性/事务保障，而这个可以通过Redis-Multi等命令实现。&lt;br/&gt;&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;参考这里&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部分读写操作存在相关依赖，无法使用pipeline实现，可利用&lt;a href=&quot;https://redis.io/commands/exec&quot;&gt;Script机制&lt;/a&gt;，但需要在可维护性方面做好取舍。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;扩展阅读&quot;&gt;扩展阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://redis.io/topics/pipelining&quot;&gt;官方文档-Redis-Pipelining&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;官方文档-Redis-Transaction&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 15:03:00 +0000</pubDate>
<dc:creator>zale.tang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/8419796.html</dc:identifier>
</item>
<item>
<title>dubbo扩展http协议后FullGC - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8419637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8419637.html</guid>
<description>&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;dubbo内部定制的版本中，在处理大于10K的包的时候，会出现内存溢出的现象&lt;/p&gt;
&lt;p&gt;原因是我们在定制dubbo http协议的时候，使用了jboss包里面的HttpRequestDecoder的http decoder方法来解析http协议内容&lt;br/&gt;该方法在解析非http协议的大内容时，会出现内存溢出的情况&lt;/p&gt;
&lt;p&gt;某个服务因为这个问题，出现了full gc 的情况&lt;/p&gt;
&lt;h3 id=&quot;复现问题&quot;&gt;复现问题&lt;/h3&gt;
&lt;p&gt;根据描述复现该问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指定dubbo版本&lt;/li&gt;
&lt;li&gt;dubbo请求，非http请求&lt;/li&gt;
&lt;li&gt;消息体大于10K&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;jvm堆配置，jmap -heap pid&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 2147483648 (2048.0MB)
   NewSize                  = 44564480 (42.5MB)
   MaxNewSize               = 715653120 (682.5MB)
   OldSize                  = 89653248 (85.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造provider和consumer，然后在consumer的入参约100K，启动tomcat（JVM）的时候添加打印gc详细信息的参数，发起调用的时候观察gc情况&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;-XX:+PrintGCDetails -XX:+PrintGCDateStamps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次调用的时候并没有出现Full GC的情况，想着是不是并发有点小，毕竟线上还是有一定并发量的，所以consumer端启动线程来调用，启动线程个数1、10、100、1000，线程数是1000的时候provider侧出现了FullGC的情况&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;2018-01-19T21:01:23.758-0800: [GC (Allocation Failure) [PSYoungGen: 454144K-&amp;gt;696K(468992K)] 1394833K-&amp;gt;1383056K(1867264K), 0.1343399 secs] [Times: user=0.26 sys=0.01, real=0.14 secs] 
2018-01-19T21:01:23.892-0800: [Full GC (Ergonomics) [PSYoungGen: 696K-&amp;gt;0K(468992K)] [ParOldGen: 1382359K-&amp;gt;940805K(1398272K)] 1383056K-&amp;gt;940805K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.2305879 secs] [Times: user=0.54 sys=0.01, real=0.23 secs] 
2018-01-19T21:01:24.629-0800: [Full GC (Ergonomics) [PSYoungGen: 464621K-&amp;gt;0K(468992K)] [ParOldGen: 1382601K-&amp;gt;941472K(1398272K)] 1847223K-&amp;gt;941472K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.2063340 secs] [Times: user=0.59 sys=0.00, real=0.21 secs] 
2018-01-19T21:01:25.305-0800: [Full GC (Ergonomics) [PSYoungGen: 454693K-&amp;gt;0K(468992K)] [ParOldGen: 1383395K-&amp;gt;499265K(1398272K)] 1838088K-&amp;gt;499265K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.1478104 secs] [Times: user=0.34 sys=0.01, real=0.15 secs] 
2018-01-19T21:01:25.945-0800: [Full GC (Ergonomics) [PSYoungGen: 457504K-&amp;gt;0K(468992K)] [ParOldGen: 1383424K-&amp;gt;499950K(1398272K)] 1840928K-&amp;gt;499950K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.1390671 secs] [Times: user=0.36 sys=0.00, real=0.14 secs] 
2018-01-19T21:01:26.585-0800: [Full GC (Ergonomics) [PSYoungGen: 456673K-&amp;gt;0K(468992K)] [ParOldGen: 1384488K-&amp;gt;499639K(1398272K)] 1841162K-&amp;gt;499639K(1867264K), [Metaspace: 52098K-&amp;gt;52098K(1097728K)], 0.1344279 secs] [Times: user=0.32 sys=0.01, real=0.14 secs] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jstat -gc pid -t 1s&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
         1438.8 1024.0 5120.0  0.0    0.0   443392.0 430848.7 1398272.0   478878.3  53464.0 52117.3 6144.0 5945.4   1733   97.928  949   166.820  264.748
         1440.0 1024.0 5120.0  0.0    0.0   443392.0 435843.6 1398272.0  1321492.8  53464.0 52117.3 6144.0 5945.4   1733   97.928  950   166.962  264.889
         1441.0 1024.0 5120.0  0.0    0.0   443392.0 433460.4 1398272.0   900800.9  53464.0 52117.3 6144.0 5945.4   1733   97.928  952   167.226  265.153
         1441.9 1024.0 5120.0  0.0    0.0   443392.0   0.0    1398272.0   479419.0  53464.0 52117.3 6144.0 5945.4   1733   97.928  954   167.491  265.419
         1443.0 1024.0 5120.0  0.0    0.0   443392.0 438270.0 1398272.0  1324328.4  53464.0 52117.3 6144.0 5945.4   1733   97.928  955   167.632  265.560
         1444.0 1024.0 5120.0  0.0    0.0   443392.0 437239.3 1398272.0   902696.2  53464.0 52117.3 6144.0 5945.4   1733   97.928  957   167.902  265.830
         1445.0 1024.0 5120.0  0.0    0.0   443392.0 440249.7 1398272.0  1326030.9  53464.0 52117.3 6144.0 5945.4   1733   97.928  959   168.046  265.974
         1446.0 1024.0 5120.0  0.0    0.0   443392.0 434997.3 1398272.0   903830.7  53464.0 52117.3 6144.0 5945.4   1733   97.928  960   168.341  266.269
         1447.0 1024.0 5120.0  0.0    0.0   443392.0 423591.6 1398272.0   480931.8  53464.0 52117.3 6144.0 5945.4   1733   97.928  962   168.610  266.537&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题原因&quot;&gt;问题原因&lt;/h3&gt;
&lt;p&gt;发生了FullGC，先拿出现在的Heap Dump看看当前JVM的堆内存使用情况&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;jmap -dump:format=b,file=dump.bin pid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到dump文件，拿到MAT中分析下，在dominator_tree视图中找到占用内存较多的对象，这里是byte数组，接下来找到byte数组属于哪一个类，在byte数据上右键&quot;Path To GC Roots&quot; -&amp;gt; &quot;with all reference&quot;就是下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/846961/201802/846961-20180205221931873-1727163326.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到org.jboss.netty.handler.codec.frame.FrameDecoder#cumulation这个对象很大，这个类是HttpRequestDecoder的超类，接下来就是调试源码，查看为什么这个字段会这么大&lt;/p&gt;
&lt;p&gt;找到这个字段的所有引用的地方，查看哪里往byte数组（cumulation这个字段包含一个byte数组）中写，主要是下面两个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 这个方法只是把原来的cumulation和新增的input复合到一个对象中，CompositeChannelBuffer&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#appendToCumulation
&lt;span class=&quot;co&quot;&gt;// 这个方法会对cumulation重新赋值，并把input写入cumulation中，也就是这个时候byte数组会增大&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#updateCumulation&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;org.jboss.netty.handler.codec.replay.ReplayingDecoder#messageReceived方法中调用上面这两个方法，ReplayingDecoder是HttpRequestDecoder的超类，在接收到请求的时候会调用messageReceived方法，所以在接收到请求的时候就会向cumulation中写数据。&lt;/p&gt;
&lt;p&gt;那么现在问题基本清晰了，不断往byte数组中写数据导致byte数组不断增大，问题应该出在byte数组没有被清空上，所以现在的问题是&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么cumulation没有被清空？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查找所有cumulation被清空的方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;replay&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ReplayingDecoder&lt;/span&gt;#cleanup&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看谁调用了这个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 连接断开的时候调用这个方法&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#channelDisconnected
&lt;span class=&quot;co&quot;&gt;// 连接关闭的时候调用这个方法&lt;/span&gt;
org.&lt;span class=&quot;fu&quot;&gt;jboss&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;netty&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;codec&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;frame&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FrameDecoder&lt;/span&gt;#channelClosed&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以只有在连接断开或者关闭的时候才会清空cumulation，结论已经呼之欲出了，回到一开始出现的问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;dubbo请求，非http请求&lt;/li&gt;
&lt;li&gt;大量并发请求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在接收到dubbo请求的时候，虽然不是http协议，但是还是会执行HttpRequestDecoder这个handler，也就会往cumulation中写数据，但是dubbo协议使用的是长连接（netty维护的长连接），所以dubbo请求的内容都会被加入到cumulation中，直到连接关闭或者断开才会清空，如果并发量大的话就会导致有多个cumulation大对象，如果对空间不够的时候就会引起FullGC。&lt;/p&gt;
&lt;p&gt;而http协议一般都是短连接，或者有超时时间（服务端超时或者客户端超时），这样cumulation就会被及时清空，所以http协议不容易出现这种问题，而dubbo协议更容易出现的原因。&lt;/p&gt;
&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;既然是非http请求就不需要使用HttpRequestDecoder做进一步处理，所以新建一个类HttpRequestWrapDecoder继承自HttpRequestDecoder，重写messageReceived方法，在该方法里面判断是否是http请求，如果是http请求才会进一步处理，否则直接返回不处理，执行pipeline中下一个handler&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 14:20:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8419637.html</dc:identifier>
</item>
<item>
<title>响应式编程的实践 - 张逸</title>
<link>http://www.cnblogs.com/wayfarer/p/summary-of-reactive-programming.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wayfarer/p/summary-of-reactive-programming.html</guid>
<description>&lt;p&gt;响应式编程在前端开发以及Android开发中有颇多运用，然而它的非阻塞异步编程模型以及对消息流的处理模式也在后端得到越来越多的应用。除了Netflix的OSS中大量使用了响应式编程之外，最近阿里也提出Dubbo 3.0版本将全面拥抱响应式编程。&lt;/p&gt;
&lt;p&gt;我之前针对某些项目需求也给出了响应式编程的方案，较好地解决了并行编程与异步编程的问题。不过在深入了解响应式编程之后，我也给出了自己的一些实践总结。&lt;/p&gt;
&lt;h3 id=&quot;响应式编程并非银弹&quot;&gt;响应式编程并非银弹&lt;/h3&gt;
&lt;p&gt;响应式编程并非银弹。事实上在软件领域，Brooks提出的“没有银弹”一说或许将永远生效。当我们在选择使用响应式编程时，一定要明确它的适用场景，主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理由用户或其他系统发起的事件，如鼠标点击、键盘按键或者物联网设备等无时无刻都在发射信号的情况&lt;/li&gt;
&lt;li&gt;处理磁盘或网络等高延迟的IO数据，且保证这些IO操作是异步的&lt;/li&gt;
&lt;li&gt;业务的处理流程是流式的，且需要高响应的非阻塞操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，我们当然也可以利用一些响应式编程框架如Rx，简化并发编程与数据流操作的实现。诸如RxJava就提供非常完整的工厂方法，可以将非响应式编程的Iterable、Array以及与响应式编程有一定相关性的Future、Callable转换为Observable或Flowable。&lt;/p&gt;
&lt;h3 id=&quot;理解source的本质&quot;&gt;理解Source的本质&lt;/h3&gt;
&lt;p&gt;Akka Stream将流数据源定义为Source，RxJava则定义为Observable或Flowable。这些响应式编程框架都为Source提供了丰富的operator。其中除了组合流的操作之外，最基本的操作即为：filter、map、flatMap、reduce等。&lt;/p&gt;
&lt;p&gt;粗略看来，这些操作皆为函数式的编程接口，从FP的角度看，我们甚至可以将Source视为一个monad。而站在Java编程的角度看，我们则很容易将Source视为等同于集合的数据结构。更何况，响应式编程实则脱胎于Observer模式与Iterator模式，其中Iterator模式就是针对集合的操作，只不过Observable或Flowable是push模型，而Iterator模式则为pull模型罢了。&lt;/p&gt;
&lt;p&gt;然而这就是本质的区别，即&lt;strong&gt;Source是一个不断发射事件（data、error、complete）的源头，具有时间序列的特点&lt;/strong&gt;，而Iterable则是一个静态的数据结构，在对它进行操作时，该数据结构中存储的数据就已经存在了。&lt;/p&gt;
&lt;h3 id=&quot;合理设计source的粒度&quot;&gt;合理设计Source的粒度&lt;/h3&gt;
&lt;p&gt;在演示Observable或Flowable的API时，我们往往喜欢采用Fluent Interface的方式连续地调用它的operator，形成一个整体的流处理过程。这并非总是合理的。当一个Source被多个operator串联起来的时候，会使得这个Source更加&lt;strong&gt;难以被重用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，在加载网页时，默认发起对后端服务的调用并返回需要的用户信息，若建模为&lt;strong&gt;流A&lt;/strong&gt;，其转换如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;uri ----&amp;gt; user ----&amp;gt; | --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，有一个鼠标点击事件也会通过随机生成URL发起对后端服务的调用并返回需要的用户信息，倘若建模为&lt;strong&gt;流B&lt;/strong&gt;，其转换如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;click ----&amp;gt; uri ----&amp;gt; user ----&amp;gt; | --&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，这两个流在从uri到user的流处理上出现了重复。如果我们创建的流A与流B并不包含uri到user的转换，就可以通过merge等合并操作将A与B合并，然后再&lt;strong&gt;共同重用从uri到user的转换&lt;/strong&gt;。我们也无需担心创建细粒度流的成本，因为这些流的创建是lazy的，流虽然创建了，对流的操作却不会立即执行。&lt;/p&gt;
&lt;h3 id=&quot;分离操作的逻辑&quot;&gt;分离操作的逻辑&lt;/h3&gt;
&lt;p&gt;无论是哪个响应式框架，都为流（Source）提供了丰富的operator。这些operator多数都支持lambda表达式。在处理简单的业务逻辑时，这样的实现是没有问题的；然而一旦逻辑变得非常复杂，lambda表达式的表达能力就不够了。从编程实践看，lambda表达式本身就应该保持微小的粒度。这时，就应该将这些逻辑单独分离出来，放到单独的类与方法中。&lt;/p&gt;
&lt;p&gt;例如，我们根据device的配置信息去调用远程服务获取设备信息，然后提取信息获得业务需要的指标，对指标进行转换，最后将转换的数据写入到数据库中。结合函数的转换本质，我们可以将这些操作拆分为多个连续的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deviceConfig --&amp;gt; deviceInfo --&amp;gt; List&amp;lt;extractedInfo&amp;gt; --&amp;gt; transformedInfo --&amp;gt; write&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;倘若这些转换的逻辑非常复杂，就可以将这些逻辑分别封装到DeviceFetcher、DeviceExtractor、DeviceTransformer与DeviceWriter这四个类中，于是代码可以写为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Flowable.&lt;span class=&quot;fu&quot;&gt;fromIterable&lt;/span&gt;(deviceConfigs)
    .&lt;span class=&quot;fu&quot;&gt;parallel&lt;/span&gt;()
    .&lt;span class=&quot;fu&quot;&gt;runOn&lt;/span&gt;(Schedulers.&lt;span class=&quot;fu&quot;&gt;computation&lt;/span&gt;())
    .&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(DeviceFetcher::fetch)
    .&lt;span class=&quot;fu&quot;&gt;flatMap&lt;/span&gt;(DeviceExtractor::extract)
    .&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(DeviceTransformer::transform)
    .&lt;span class=&quot;fu&quot;&gt;sequential&lt;/span&gt;()
    .&lt;span class=&quot;fu&quot;&gt;blockingSubscribe&lt;/span&gt;(info -&amp;gt; DeviceWriter.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(info); err -&amp;gt; &lt;span class=&quot;fu&quot;&gt;log&lt;/span&gt;(err); () -&amp;gt; &lt;span class=&quot;fu&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;done.&quot;&lt;/span&gt;));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一实践提倡将流的操作与每个操作的业务分离开，既能够保证流操作的简单与纯粹，又能保证操作业务的重用与可扩展。&lt;/p&gt;
&lt;h3 id=&quot;api的设计&quot;&gt;API的设计&lt;/h3&gt;
&lt;p&gt;如果我们要设计符合响应式编程设计的API，则应该尽可能保证每个方法都是非阻塞的。要做到这一点，就应该保证每个方法返回的类型是Source或Publisher。例如针对要返回多个数据的流，可以返回&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;或者&lt;code&gt;Flowable&amp;lt;T&amp;gt;&lt;/code&gt;；如果确定只返回一个数据，则可以返回&lt;code&gt;Single&amp;lt;T&amp;gt;&lt;/code&gt;；倘若不确定，则返回&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;。倘若该API方法仅仅是一个命令，无需返回结果，又需要保证方法是非阻塞的，则可以考虑返回&lt;code&gt;Completable&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;从某种意义上说，返回&lt;code&gt;Future&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;CompletableFuture&amp;lt;T&amp;gt;&lt;/code&gt;或者&lt;code&gt;CompletableStage&amp;lt;T&amp;gt;&lt;/code&gt;也可以认为是响应式的。这三个类型由于是JDK自身提供的，因此更纯粹。唯一不便的是这些接口没有提供类似Observable那样丰富的operator，但好在Observable与Flowable都提供了&lt;code&gt;fromFuture()&lt;/code&gt;方法对其进行转换，因而这样的设计也是可取的。&lt;/p&gt;
&lt;h3 id=&quot;akka-stream的流拓扑图&quot;&gt;Akka Stream的流拓扑图&lt;/h3&gt;
&lt;p&gt;Akka Stream对流处理的抽象被建模为图。这一设计思想使得流的处理变得更加直观，流的处理变成了“搭积木”游戏。可惜Java的DSL能力实在太弱，如果对比Scala与Java，你会发现GraphDSL对Graph的构造在表现上简直是天壤之别。&lt;/p&gt;
&lt;p&gt;例如这是官方文档中Java版本对Graph的构造：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;RunnableGraph.&lt;span class=&quot;fu&quot;&gt;fromGraph&lt;/span&gt;(GraphDSL.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(builder -&amp;gt; {
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Outlet&amp;lt;Integer&amp;gt; A = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Source.&lt;span class=&quot;fu&quot;&gt;single&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanOutShape&amp;lt;Integer, Integer&amp;gt; B = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Broadcast.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanInShape&amp;lt;Integer, Integer&amp;gt; C = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; FlowShape&amp;lt;Integer, Integer&amp;gt; D = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Flow.&lt;span class=&quot;fu&quot;&gt;of&lt;/span&gt;(Integer.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(i -&amp;gt; i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanOutShape&amp;lt;Integer, Integer&amp;gt; E = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Balance.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; UniformFanInShape&amp;lt;Integer, Integer&amp;gt; F = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Inlet&amp;lt;Integer&amp;gt; G = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Sink.&amp;lt;Integer&amp;gt;&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;::println)).&lt;span class=&quot;fu&quot;&gt;in&lt;/span&gt;();

    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(F).&lt;span class=&quot;fu&quot;&gt;toFanIn&lt;/span&gt;(C); &lt;span class=&quot;co&quot;&gt;//feedback loop&lt;/span&gt;
    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(A).&lt;span class=&quot;fu&quot;&gt;viaFanOut&lt;/span&gt;(B).&lt;span class=&quot;fu&quot;&gt;viaFanIn&lt;/span&gt;(C).&lt;span class=&quot;fu&quot;&gt;toFanIn&lt;/span&gt;(F);
    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(B).&lt;span class=&quot;fu&quot;&gt;via&lt;/span&gt;(D).&lt;span class=&quot;fu&quot;&gt;viaFanOut&lt;/span&gt;(E).&lt;span class=&quot;fu&quot;&gt;toFanIn&lt;/span&gt;(F);
    builder.&lt;span class=&quot;fu&quot;&gt;from&lt;/span&gt;(E).&lt;span class=&quot;fu&quot;&gt;toInlet&lt;/span&gt;(G);

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ClosedShape.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;();
})).&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(mat);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下是官方文档中Scala版本对同一个Graph的构造：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;RunnableGraph.&lt;span class=&quot;fu&quot;&gt;fromGraph&lt;/span&gt;(GraphDSL.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;implicit&lt;/span&gt; builder =&amp;gt;
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; A: Outlet[Int]                  = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Source.&lt;span class=&quot;fu&quot;&gt;single&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; B: UniformFanOutShape[Int, Int] = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Broadcast[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; C: UniformFanInShape[Int, Int]  = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; D: FlowShape[Int, Int]          = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Flow[Int].&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;(_ + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; E: UniformFanOutShape[Int, Int] = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Balance[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; F: UniformFanInShape[Int, Int]  = builder.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(Merge[Int](&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))
  &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; G: Inlet[Any]
  
                C     &amp;lt;~      F
  A  ~&amp;gt;  B  ~&amp;gt;  C     ~&amp;gt;      F
         B  ~&amp;gt;  D  ~&amp;gt;  E  ~&amp;gt;  F
                       E  ~&amp;gt;  G
  ClosedShape
})&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也看到，倘若在GraphDSL中我们能够将构成Graph的“材料”对象事先创建好，而将build工作统一放在一起，可以在一定程度改进代码的表现力。&lt;/p&gt;
&lt;p&gt;我们可以将Akka Stream的Graph（完整的Graph，称为ClosedShape，是可以运行的，又称之为RunnableShape）看做是流处理的”模具“，至于那些由Inlet与Outlet端口组成的基础Shape，则是设计这些模具的”基础材料“。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模具&lt;/strong&gt;是静态的，&lt;strong&gt;基础材料&lt;/strong&gt;与&lt;strong&gt;组合材料&lt;/strong&gt;是可重用的单元，然后再组合可以重用的&lt;strong&gt;业务单元&lt;/strong&gt;（以函数、类或者接口形式进行封装），这个模具就具有了业务处理能力。如果这个拓扑图过于复杂，我们还可以利用基础Shape组合形成一个个更粗粒度Partial Shap。这些Partial Shape不是封闭的，可以理解为更粗粒度的Source、Sink和Flow，它使得模具的组装变得更加简单。**&lt;/p&gt;
&lt;p&gt;材料、业务单元、模具之间的关系可以形象地用下图来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/526/201802/526-20180205214304607-1386887920.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦流处理的模具打造完毕，打开数据流的”水龙头“，让数据源源不断地流入Graph中，流处理就可以”自动“运行。只要Source没有发出complete或error信号，它就将一直运行下去。Akka Stream之所以将Graph的运行器称之为materializer，大约也是源于这样的隐喻吧。&lt;/p&gt;
&lt;p&gt;使用Akka Stream进行响应式流处理，我建议参考这样的思维。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://iamzhangyi.github.io/2018/02/03/summary-of-reactive-programming/&quot; class=&quot;uri&quot;&gt;https://iamzhangyi.github.io/2018/02/03/summary-of-reactive-programming/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 13:41:00 +0000</pubDate>
<dc:creator>张逸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wayfarer/p/summary-of-reactive-programming.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 Fragment番外篇——TabLayout+ViewPager+Fragment - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/8419496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/8419496.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上一篇文章中我们使用底部导航+Fragment的方式实现了Android主流App中大都存在的设计。并命名其为“Fragment最佳实践”，作为想到单独使用Fragment的用户来说，这个说法并不夸大，它解决了许多用户在使用Fragment时产生的这样那样可见或不可见的问题。不过Fragment还有其他的使用方式，就是我们本章要介绍的。（本来是介绍ListView的，等着ListView的读者不好意思了，我会很快更新的。）&lt;/p&gt;
&lt;p&gt;注：为什么临时插入这一章，因为有读者在上一篇文章中评论了，我觉得大有道理，感谢&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/730v2UJ.png&quot;/&gt;&lt;br/&gt;这里我就不打码了，，哈哈哈哈&lt;/p&gt;

&lt;h2 id=&quot;tablayout的静态使用&quot;&gt;TabLayout的静态使用&lt;/h2&gt;
&lt;p&gt;TabLayout是Android 5.0之后Google提供的一系列Material Design设计规范中的一个控件。我们在布局文件中可以这样使用&lt;br/&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;android.support.design.widget.TabLayout
    android:id=&quot;@+id/tab_layout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_alignParentBottom=&quot;true&quot;
    app:tabIndicatorHeight=&quot;0dp&quot;
    app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;
    &amp;gt;
    
    &amp;lt;android.support.design.widget.TabItem
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Tab 1&quot;/&amp;gt;
    &amp;lt;android.support.design.widget.TabItem
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Tab 2&quot;/&amp;gt;
    &amp;lt;android.support.design.widget.TabItem
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Tab 3&quot;/&amp;gt;
&amp;lt;/android.support.design.widget.TabLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TabLayout间接继承于ViewGroup，其内可包含0到n个TabItem，这个TabItem就是我们经常使用的标签，其是个自定义View&lt;br/&gt;，这样我们就定义了一个包含3个标签页的TabLayout。其运行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/F3gISgz.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tablayout的动态使用&quot;&gt;TabLayout的动态使用&lt;/h2&gt;
&lt;p&gt;在布局文件中我们可以很方便定义顶部/底部 导航的布局。我们来看一下在代码中的使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TabActivity extends AppCompatActivity {
    @BindView(R.id.tab_layout)
    TabLayout mTabLayout;
    @BindView(R.id.view_pager)
    ViewPager mViewPager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_tab);
        ButterKnife.bind(this);

        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 1&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 2&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 3&quot;));

        //为TabLayout添加Tab选择事件监听
        mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
            @Override
            public void onTabSelected(TabLayout.Tab tab) {//当标签被选择时回调
                
            }

            @Override
            public void onTabUnselected(TabLayout.Tab tab) {//当标签从选择变为非选择时回调

            }

            @Override
            public void onTabReselected(TabLayout.Tab tab) {//当标签被重新选择时回调

            }
        });
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于运行结果我就不上图了，跟上面的运行结果是一样的。&lt;/p&gt;
&lt;h2 id=&quot;tablayout的更多属性&quot;&gt;TabLayout的更多属性&lt;/h2&gt;
&lt;p&gt;关于TabLayout的更多属性以及使用的说明请查看其官方文档。在这里我们只关心TabLayout+ViewPager的化学反应,这个组合也是我们平常在开发中使用最多的。在此之前我们先介绍ViewPager&lt;/p&gt;

&lt;p&gt;先看看官方对ViewPager的说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
Layout manager that allows the user to flip left and right
through pages of data.  You supply an implementation of a
{@link PagerAdapter} to generate the pages that the view shows.


ViewPager is most often used in conjunction with {@link android.app.Fragment}
There are standard adapters implemented for using fragments with the ViewPager,
which cover the most common use cases.  These are
{@link android.support.v4.app.FragmentPagerAdapter} and
{@link android.support.v4.app.FragmentStatePagerAdapter};*/

public class ViewPager extends ViewGroup {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面英文的大致意思是ViewPager是一个布局管理类，这个类呢允许用户左右翻转页面。你必须实现一个PagerAdapter来生成这些显示的页面。ViewPager经常和Fragment一起使用。而且呢Google非常贴心的提供了两个类FragmentPagerAdapter和FragmentStatePagerAdapter来应付那些一般场景。&lt;/p&gt;
&lt;p&gt;其实从ViewPager的说明中，我们基本上就能知道ViewPager是什么以及如何使用了。&lt;/p&gt;

&lt;p&gt;ViewPager继承于ViewGroup，官方指导中就说了，你要自己实现PagerAdapter来生成显示的页面，那么我们来看看这个PagerAdapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Base class providing the adapter to populate pages inside of
 * a {@link ViewPager}.  You will most likely want to use a more
 * specific implementation of this, such as
 * {@link android.support.v4.app.FragmentPagerAdapter} or
 * {@link android.support.v4.app.FragmentStatePagerAdapter}.
 *
 * &amp;lt;p&amp;gt;When you implement a PagerAdapter, you must override the following methods
 * at minimum:&amp;lt;/p&amp;gt;
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;{@link #instantiateItem(ViewGroup, int)}&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;{@link #destroyItem(ViewGroup, int, Object)}&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;{@link #getCount()}&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;{@link #isViewFromObject(View, Object)}&amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 * /
public abstract class PagerAdapter {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实我们在看一个不太了解的类的时候，通过源码上的关于这个类的说明就可以知道很多信息了。关于PagerAdapter的说明就是如此。&lt;br/&gt;先说了一下PagerAdapter的作用，是一个基类提供适配器给ViewPager中的页面，如果你想使用特定的实现类，那么你可以看两个类FragmentPagerAdapter和FragmentStatePagerAdapter，这两个类继承了PagerAdapter，并实现了其抽象方法。&lt;/p&gt;
&lt;p&gt;后面一段的意思是你如果想自定义你自己的PagerAdapter，那么你最少要实现这4个方法&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;instantiateItem(ViewGroup, int)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;destroyItem(ViewGroup, int, Object)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;getCount()&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;isViewFromObject(View, Object)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们以代码的形式，说明这4个方法的含义以及如何使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private class MyViewPagerAdapter extends PagerAdapter {

    /**
      * 获取View的总数
      *
      * @return View总数
      */
    @Override
    public int getCount() {
        return 0;
    }

    
    /**
     * 为给定的位置创建相应的View。创建View之后,需要在该方法中自行添加到container中。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @return 提交给ViewPager进行保存的实例对象
     */
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        return super.instantiateItem(container, position);
    }
    
    /**
     * 给定的位置移除相应的View。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @param object    在instantiateItem中提交给ViewPager进行保存的实例对象
     */
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        super.destroyItem(container, position, object);
    }
 
    
    /**
     * 确认View与实例对象是否相互对应。ViewPager内部用于获取View对应的ItemInfo。
     *
     * @param view   ViewPager显示的View内容
     * @param object 在instantiateItem中提交给ViewPager进行保存的实例对象
     * @return 是否相互对应
     */
    @Override
    public boolean isViewFromObject(View view, Object object) {
        return false;
    }
    

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这4个方法是必须的，，另外还有一些不是必须，但是可能会用到的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 当ViewPager的内容有所变化时,进行调用。
 *
 * @param container ViewPager本身
 */
@Override
public void startUpdate(ViewGroup container) {
    super.startUpdate(container);
}


/**
 * ViewPager调用该方法来通知PageAdapter当前ViewPager显示的主要项,提供给用户对主要项进行操作的方法。
 *
 * @param container ViewPager本身
 * @param position  给定的位置
 * @param object    在instantiateItem中提交给ViewPager进行保存的实例对象
 */
@Override
public void setPrimaryItem(ViewGroup container, int position, Object object) {
    super.setPrimaryItem(container, position, object);
}


/**
 * 较多的用于Design库中的TabLayout与ViewPager进行绑定时,提供显示的标题。
 *
 * @param position 给定的位置
 * @return 显示的标题
 */
@Override
public CharSequence getPageTitle(int position) {
    return super.getPageTitle(position);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面呢只是列举说明了一下PagerAdapter，看起来有些枯燥，都是些说明，那么我们来看一下实践，ViewPager通畅跟Fragment一起使用，即其所管理的页面通畅是Fragment，所以Google提供了两个适配器FragmentPagerAdapter和FragmentStatePagerAdapter，我们这节分析FragmentPagerAdapter。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /**
 *真是不看不知道，一看吓一跳。FragmentPagerAdapter也是个抽象类，
 *
 */
public abstract class FragmentPagerAdapter extends PagerAdapter {
    private static final String TAG = &quot;FragmentPagerAdapter&quot;;
    private static final boolean DEBUG = false;

    private final FragmentManager mFragmentManager;
    private FragmentTransaction mCurTransaction = null;
    private Fragment mCurrentPrimaryItem = null;

    public FragmentPagerAdapter(FragmentManager fm) {
        mFragmentManager = fm;
    }

    /**
     *抽象方法，看来这个函数要子类自己实现了
     *
     * @param position ViewPager中Item的位置
     * @return 位置相关联的Fragment
     */
    public abstract Fragment getItem(int position);

    @Override
    public void startUpdate(ViewGroup container) {
        if (container.getId() == View.NO_ID) {
            throw new IllegalStateException(&quot;ViewPager with adapter &quot; + this
                    + &quot; requires a view id&quot;);
        }
    }

    /**
     * 为给定的位置创建相应的fragment。创建fragment之后,需要在该方法中自行添加到container中。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @return 提交给ViewPager进行保存的实例对象,这里是Fragment
     */
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        
        final long itemId = getItemId(position);

       
        String name = makeFragmentName(container.getId(), itemId);
        Fragment fragment = mFragmentManager.findFragmentByTag(name);
        if (fragment != null) {
            if (DEBUG) Log.v(TAG, &quot;Attaching item #&quot; + itemId + &quot;: f=&quot; + fragment);
            mCurTransaction.attach(fragment);
        } else {
            fragment = getItem(position);
            if (DEBUG) Log.v(TAG, &quot;Adding item #&quot; + itemId + &quot;: f=&quot; + fragment);
            mCurTransaction.add(container.getId(), fragment,
                    makeFragmentName(container.getId(), itemId));
        }
        if (fragment != mCurrentPrimaryItem) {
            fragment.setMenuVisibility(false);
            fragment.setUserVisibleHint(false);
        }

        return fragment;
    }

    /**
     * 移除给定的位置相应的fragment。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @param object    在instantiateItem中提交给ViewPager进行保存的实例对象
     */
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object
                + &quot; v=&quot; + ((Fragment)object).getView());
        mCurTransaction.detach((Fragment)object);
    }

    @Override
    public void setPrimaryItem(ViewGroup container, int position, Object object) {
        Fragment fragment = (Fragment)object;
        if (fragment != mCurrentPrimaryItem) {
            if (mCurrentPrimaryItem != null) {
                mCurrentPrimaryItem.setMenuVisibility(false);
                mCurrentPrimaryItem.setUserVisibleHint(false);
            }
            if (fragment != null) {
                fragment.setMenuVisibility(true);
                fragment.setUserVisibleHint(true);
            }
            mCurrentPrimaryItem = fragment;
        }
    }

    @Override
    public void finishUpdate(ViewGroup container) {
        if (mCurTransaction != null) {
            mCurTransaction.commitNowAllowingStateLoss();
            mCurTransaction = null;
        }
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {
        return ((Fragment)object).getView() == view;
    }

    @Override
    public Parcelable saveState() {
        return null;
    }

    @Override
    public void restoreState(Parcelable state, ClassLoader loader) {
    }

    /**
     * @param position ViewPager中Item的位置
     * @return 唯一的ItemID
     */
    public long getItemId(int position) {
        return position;
    }

    private static String makeFragmentName(int viewId, long id) {
        return &quot;android:switcher:&quot; + viewId + &quot;:&quot; + id;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码比较少，总共也就100多行，逻辑也比较清晰明了，我们来着重分析instantiateItem和destroyItem&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 为给定的位置创建相应的fragment。创建fragment之后,需要在该方法中自行添加到container中。
     *
     * @param container ViewPager本身
     * @param position  给定的位置
     * @return 提交给ViewPager进行保存的实例对象,这里是Fragment
     */
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        //开启事务
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        //得到指定位置Item的ID
        final long itemId = getItemId(position);

       //根据id和ViewPager的ID生成item的name
        String name = makeFragmentName(container.getId(), itemId);

        //以name为Tag查找对应的Fragment
        Fragment fragment = mFragmentManager.findFragmentByTag(name);


        if (fragment != null) {//如果找到了
            if (DEBUG) Log.v(TAG, &quot;Attaching item #&quot; + itemId + &quot;: f=&quot; + fragment);
            //调用事务的attach
            mCurTransaction.attach(fragment);
        } else {//没找到
            //通过我们重写的getItem方法得到相应fragment
            fragment = getItem(position);
            if (DEBUG) Log.v(TAG, &quot;Adding item #&quot; + itemId + &quot;: f=&quot; + fragment);

            //调用事务的add方法，并设置Tag
            mCurTransaction.add(container.getId(), fragment,
                    makeFragmentName(container.getId(), itemId));
        }
        //如果frament不等于当前主要的Item

        if (fragment != mCurrentPrimaryItem) {
            //设置其Menu不可见
            fragment.setMenuVisibility(false);
            //设置其不可见
            fragment.setUserVisibleHint(false);
        }

        return fragment;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;instantiateItem方法主要功能是为ViewPager生成Item。&lt;br/&gt;那么destroyItem方法的主要功能是销毁ViwePager内的Item&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        if (mCurTransaction == null) {
            mCurTransaction = mFragmentManager.beginTransaction();
        }
        
        //调用事务的detach方法
        mCurTransaction.detach((Fragment)object);
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于FragmentStatePagerAdapter，读者可自行分析，代码也不长。需要注意的地方是，两者对于destroyItem的不同实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void destroyItem(ViewGroup container, int position, Object object) {
    Fragment fragment = (Fragment) object;

    if (mCurTransaction == null) {
        mCurTransaction = mFragmentManager.beginTransaction();
    }
    if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object
            + &quot; v=&quot; + ((Fragment)object).getView());
    while (mSavedState.size() &amp;lt;= position) {
        mSavedState.add(null);
    }
    mSavedState.set(position, fragment.isAdded()
            ? mFragmentManager.saveFragmentInstanceState(fragment) : null);
    mFragments.set(position, null);

    //调用事务的remove方法
    mCurTransaction.remove(fragment);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;ViewPager是个ViewGroup，与其他布局LinearLayout或者其他任意的ViewGroup并无本质的不同，它被Google建议与Fragment结伴使用，也是说ViewPager所包裹的是Fragment布局。ViewPager需要适配器PagerAdapter操作Fragment，这一点就像ListView需要适配器操作其内部的Item一样。&lt;/p&gt;
&lt;p&gt;适配器PagerAdapter是个抽象类，并且依照官方说明，我们必须至少实现其4个重要方法。4个方法可能太多，所以Google提供了FragmentPagerAdapter以及FragmentStatePagerAdapter，这两个也是抽象类，不过我们的自定义Adapter只需要实现其中的getItem(int position)方法即可。&lt;/p&gt;
&lt;p&gt;关于FragmentPagerAdapter以及FragmentStatePagerAdapter的不同，我这里再总结一下。&lt;strong&gt;FragmentPagerAdapter销毁item的时候最终调用FragmentTransaction的detach()方法，使用detach()会将view从viewtree中删除,和FragmentStatePagerAdapter中使用的remove()不同,此时fragment的状态依然保持着,在使用attach()时会再次调用onCreateView()来重绘视图,注意使用detach()后fragment.isAdded()方法将返回false。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;实例&lt;/h2&gt;
&lt;p&gt;更改后的TabActivity对应的布局文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;

    &amp;lt;!--ViewPager--&amp;gt;
    &amp;lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/view_pager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentTop=&quot;true&quot;
        &amp;gt;

    &amp;lt;/android.support.v4.view.ViewPager&amp;gt;
    &amp;lt;!--分割线--&amp;gt;
    &amp;lt;ImageView
        android:id=&quot;@+id/image_1&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;1dp&quot;
        android:background=&quot;#919292&quot;
        android:layout_above=&quot;@+id/tab_layout&quot;/&amp;gt;



    &amp;lt;!--TabLayout--&amp;gt;
    &amp;lt;android.support.design.widget.TabLayout
        android:id=&quot;@+id/tab_layout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        app:tabIndicatorHeight=&quot;0dp&quot;
        app:tabSelectedTextColor=&quot;@color/colorPrimary&quot;
        &amp;gt;
        
    &amp;lt;/android.support.design.widget.TabLayout&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改后的TabActivity&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TabActivity extends AppCompatActivity {
    @BindView(R.id.tab_layout)
    TabLayout mTabLayout;
    @BindView(R.id.view_pager)
    ViewPager mViewPager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_tab);
        ButterKnife.bind(this);

        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 1&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 2&quot;));
        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Tab 3&quot;));

        //自定义的Adapter继承自FragmentPagerAdapter
        final PagerAdapter adapter = new PagerAdapter
            (getSupportFragmentManager(), mTabLayout.getTabCount());

        //ViewPager设置Adapter
        mViewPager.setAdapter(adapter);

        //为ViewPager添加页面改变监听
        mViewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout));

        //为TabLayout添加Tab选择监听
       
        mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
            @Override
            public void onTabSelected(TabLayout.Tab tab) {
                mViewPager.setCurrentItem(tab.getPosition());
            }

            @Override
            public void onTabUnselected(TabLayout.Tab tab) {

            }

            @Override
            public void onTabReselected(TabLayout.Tab tab) {

            }
        });
        
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而我们自定义的MyPagerAdapter也非常简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyPagerAdapter extends FragmentPagerAdapter {
    //fragment的数量
    int nNumOfTabs;
    public MyPagerAdapter(FragmentManager fm, int nNumOfTabs)
    {
        super(fm);
        this.nNumOfTabs=nNumOfTabs;
    }

    /**
     * 重写getItem方法
     *
     * @param position 指定的位置
     * @return 特定的Fragment
     */
    @Override
    public Fragment getItem(int position) {
        switch(position)
        {
            case 0:
                GoodsFragment tab1=new GoodsFragment();
                return tab1;
            case 1:
                CategoryFragment tab2=new CategoryFragment();
                return tab2;
            case 2:
                TaskFragment tab3=new TaskFragment();
                return tab3;
        }
        return null;
    }

    /**
     * 重写getCount方法
     *
     * @return fragment的数量
     */
    @Override
    public int getCount() {
        return nNumOfTabs;
    }
}&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;ViewPager可通过setOffscreenPageLimit(int limit)函数设置ViewPager预加载的View数目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void setOffscreenPageLimit(int limit) {
    //DEFAULT_OFFSCREEN_PAGES=1

    if (limit &amp;lt; DEFAULT_OFFSCREEN_PAGES) {
        Log.w(TAG, &quot;Requested offscreen page limit &quot; + limit + &quot; too small; defaulting to &quot;
                + DEFAULT_OFFSCREEN_PAGES);
        limit = DEFAULT_OFFSCREEN_PAGES;
    }
    if (limit != mOffscreenPageLimit) {
        mOffscreenPageLimit = limit;
        populate();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到该函数的源码，当我们传入的limit&amp;lt;1时，limit还是被设置为1，当limit与成员变量mOffscreenPageLimit的值不同时（成员变量mOffscreenPageLimit的默认值为1），更新成员变量mOffscreenPageLimit的值，然后调用populate()函数。&lt;/p&gt;
&lt;p&gt;而这个populate()函数就是给我们的ViewPager准备缓存页面并显示当前页面用的。&lt;/p&gt;
&lt;p&gt;假如说我采用下面的方法调用setOffscreenPageLimit(2),此时ViewPager的简单示意图&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/SE1LTNf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：从上面的代码也可以看出ViewPager最少会预加载一个页面。在本例中，也是我们在显示TAB1的时候，ViewPager已经加载了TAB2，具体方式是通过instantiateItem方法，该方法内部调用了我们重写的getItem方法，TAB2所表示的Fragment的onCreateView等相关生命周期方法会被回调。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ViewPager的预加载机制其实在某些时候是个很让人不爽的问题，比如我们在Fragment做网络请求数据的时候，我们网络请求的代码通常会放在onCreateView中，我们只是打开第1个Fragment，但是由于ViewPager会加载第2个Fragment，可能也执行了第2个Fragment的网络请求代码。&lt;/p&gt;
&lt;p&gt;而避免上述问题的主要依靠&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void setUserVisibleHint(boolean isVisibleToUser)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;setUserVisibleHint(boolean isVisibleToUser)是Fragment中的一个回调函数。当前Fragment可见时，setUserVisibleHint()回调，其中isVisibleToUser=true。当前Fragment由可见到不可见或实例化时，setUserVisibleHint()回调，其中isVisibleToUser=false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setUserVisibleHint(boolean isVisibleToUser)调用时机&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在Fragment实例化，即在ViewPager中，由于ViewPager默认会预加载左右两个页面。此时预加载页面回调的生命周期流程：setUserVisibleHint() --&amp;gt;onAttach() --&amp;gt; onCreate()--&amp;gt;onCreateView()--&amp;gt; onActivityCreate() --&amp;gt; onStart() --&amp;gt; onResume()&lt;/p&gt;
&lt;p&gt;此时，setUserVisibleHint() 中的参数为false，因为不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在Fragment可见时，即ViewPager中滑动到当前页面时，因为已经预加载过了，之前生命周期已经走到onResume() ，所以现在只会回调：setUserVisibleHint()。&lt;/p&gt;
&lt;p&gt;此时，setUserVisibleHint() 中的参数为true，因为可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在Fragment由可见变为不可见，即ViewPager由当前页面滑动到另一个页面，因为还要保持当前页面的预加载过程，所以只会回调：setUserVisibleHint()。&lt;/p&gt;
&lt;p&gt;此时，setUserVisibleHint() 中的参数为false，因为不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;由TabLayout直接跳转到一个未预加载的页面，此时生命周期的回调过程：setUserVisibleHint() --&amp;gt;setUserVisibleHint() --&amp;gt;onAttach() --&amp;gt; onCreate()--&amp;gt;onCreateView()--&amp;gt; onActivityCreate() --&amp;gt; onStart()&lt;br/&gt;--&amp;gt; onResume()&lt;/p&gt;
&lt;p&gt;此时回调了两次setUserVisibleHint() ，一次代表初始化时，传入参数是false，一次代表可见时，传入参数是true。这种情况比较特殊。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;总结：无论何时，setUserVisibleHint()都是先于其他生命周期的调用，并且初始化时调用，可见时调用，由可见转换成不可见时调用，一共三次时机。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在使用ViewPager+Fragment显示数据的时候，我们通常会把网络请求的操作放在onCreateView-&amp;gt;onResume之间的生命周期内。这可能带来的问题我们上面已经探讨了。那么怎么解决这个问题呢？&lt;/p&gt;

&lt;p&gt;我们在本篇博客中比较详细的探讨了TabLayout+ViewPager+Fragment的使用，我们在许多主流App中都能看到这种顶部、底部导航的效果，并且在此基础上我们探讨了TabLayout+ViewPager+Fragment网络数据加载问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们希望Fragment可见时加载网络数据，不可见时不进行或者取消网络请求。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class BaseFragment extends Fragment {
    protected View rootView;

    private Unbinder mUnbinder;
    //当前Fragment是否处于可见状态标志，防止因ViewPager的缓存机制而导致回调函数的触发
    private boolean isFragmentVisible;
    //是否是第一次开启网络加载
    public boolean isFirst;

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        if (rootView == null)
            rootView = inflater.inflate(getLayoutResource(), container, false);
        mUnbinder = ButterKnife.bind(this, rootView);
        initView();
        //可见，但是并没有加载过
        if (isFragmentVisible &amp;amp;&amp;amp; !isFirst) {
            onFragmentVisibleChange(true);
        }
        return rootView;
    }

    //获取布局文件
    protected abstract int getLayoutResource();


    //初始化view
    protected abstract void initView();


    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
        if (isVisibleToUser) {
            isFragmentVisible = true;
        }
        if (rootView == null) {
            return;
        }
        //可见，并且没有加载过
        if (!isFirst&amp;amp;&amp;amp;isFragmentVisible) {
            onFragmentVisibleChange(true);
            return;
        }
        //由可见——&amp;gt;不可见 已经加载过
        if (isFragmentVisible) {
            onFragmentVisibleChange(false);
            isFragmentVisible = false;
        }
    }


    @Override
    public void onDestroyView() {
        super.onDestroyView();
        mUnbinder.unbind();
    }

    /**
     * 当前fragment可见状态发生变化时会回调该方法
     * 
     * 如果当前fragment是第一次加载，等待onCreateView后才会回调该方法，其它情况回调时机跟 {@link #setUserVisibleHint(boolean)}一致
     * 在该回调方法中你可以做一些加载数据操作，甚至是控件的操作.
     *
     * @param isVisible true  不可见 -&amp;gt; 可见
     *                  false 可见  -&amp;gt; 不可见
     */
    protected void onFragmentVisibleChange(boolean isVisible) {

    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们设计抽象基类BaseFragment，所有的公共行为我们都可以在这个基类中定义，那么我们的Fragment是否可见就是其中的一种行为，所以我们上面重写了Fragment的setUserVisibleHint方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class GoodsFragment extends BaseFragment {
    
    @Override
    protected void onFragmentVisibleChange(boolean isVisible) {
        if(isVisible){
            //可见，并且是第一次加载
            lazyLoad();
        }else{
            //取消加载
        }
    }

    private void lazyLoad() {
        if (!isFirst) {
            isFirst = true;
        }
    }


    @Override
    protected int getLayoutResource() {
        return R.layout.fragment_goods;
    }

    @Override
    protected void initView() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们设计GoodsFragment继承BaseFragment并重写其onFragmentVisibleChange以控制自身的网络请求。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本篇为读者介绍了另外一种导航页切换的实现，我们使用TabLayout+ViewPager+Fragment的方式，其中读者需要重点理解以下几点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ViewPager是个ViewGroup，它所关机的布局就是通常是我们的Fragment布局。&lt;/li&gt;
&lt;li&gt;ViewPager的预加载机制、可能带来的问题及如何解决。&lt;/li&gt;
&lt;li&gt;理解PagerAdapter，以及如何实现它&lt;/li&gt;
&lt;li&gt;理解Google提供了两个特定场景的PagerAdapter实现类FragmentPagerAdapter以及FragmentStatePagerAdapter,以及他们的主要区别&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;p&gt;下篇打算往Fragment中加点东西，ListView&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 13:29:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/8419496.html</dc:identifier>
</item>
<item>
<title>模型的元数据Meta  -- Django从入门到精通系列教程 - 刘江liujiangblog.com</title>
<link>http://www.cnblogs.com/feixuelove1009/p/8419493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/8419493.html</guid>
<description>&lt;h3 id=&quot;该系列教程系个人原创并完整发布在个人官网刘江的博客和教程&quot;&gt;该系列教程系个人原创，并完整发布在个人官网&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;刘江的博客和教程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;所有转载本文者需在顶部显著位置注明原作者及www.liujiangblog.com官网地址&quot;&gt;所有转载本文者，需在顶部显著位置注明原作者及www.liujiangblog.com官网地址。&lt;/h3&gt;
&lt;h3 id=&quot;python及django学习qq群453131687&quot;&gt;Python及Django学习QQ群：453131687&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。所有的这些都是非必须的，甚至元数据本身对模型也是非必须的。但是，我要说但是，有些元数据选项能给予你极大的帮助，在实际使用中具有重要的作用，是实际应用的‘必须’。&lt;/p&gt;
&lt;p&gt;想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的&lt;code&gt;Meta&lt;/code&gt;，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Ox(models.Model):
    horn_length &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.IntegerField()

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:         &lt;span class=&quot;co&quot;&gt;# 注意，是模型的子类，要缩进！&lt;/span&gt;
        ordering &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;horn_length&quot;&lt;/span&gt;]
        verbose_name_plural &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;oxen&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名，下面我们会详细介绍有哪些可用的元数据选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强调：每个模型都可以有自己的元数据类，每个元数据类也只对自己所在模型起作用。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;abstract&quot;&gt;abstract&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;abstract=True&lt;/code&gt;，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;app_label&quot;&gt;app_label&lt;/h3&gt;
&lt;p&gt;如果定义了模型的app没有在&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中注册，则必须通过此元选项声明它属于哪个app，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app_label = 'myapp'&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;base_manager_name&quot;&gt;base_manager_name&lt;/h3&gt;
&lt;p&gt;自定义模型的&lt;code&gt;_base_manager&lt;/code&gt;管理器的名字。模型管理器是Django为模型提供的API所在。Django1.10新增。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;db_table&quot;&gt;db_table&lt;/h3&gt;
&lt;p&gt;指定在数据库中，当前模型生成的数据表的表名。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db_table = 'my_freinds'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;友情建议：使用MySQL数据库时，&lt;code&gt;db_table&lt;/code&gt;用小写英文。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;db_tablespace&quot;&gt;db_tablespace&lt;/h3&gt;
&lt;p&gt;自定义数据库表空间的名字。默认值是工程的&lt;code&gt;DEFAULT_TABLESPACE&lt;/code&gt;设置。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;default_manager_name&quot;&gt;default_manager_name&lt;/h3&gt;
&lt;p&gt;自定义模型的&lt;code&gt;_default_manager&lt;/code&gt;管理器的名字。Django1.10新增。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;default_related_name&quot;&gt;default_related_name&lt;/h3&gt;
&lt;p&gt;默认情况下，从一个模型反向关联设置有关系字段的源模型，我们使用&lt;code&gt;&amp;lt;model_name&amp;gt;_set&lt;/code&gt;，也就是源模型的名字+下划线+&lt;code&gt;set&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个元数据选项可以让你自定义反向关系名，同时也影响反向查询关系名！看下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Foo(models.Model):
    &lt;span class=&quot;cf&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Bar(models.Model):
    foo &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Foo)

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:
        default_related_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'bars'&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;# 关键在这里&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的使用差别如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; bar = Bar.objects.get(pk=1)
&amp;gt;&amp;gt;&amp;gt; # 不能再使用&quot;bar&quot;作为反向查询的关键字了。
&amp;gt;&amp;gt;&amp;gt; Foo.objects.get(bar=bar)
&amp;gt;&amp;gt;&amp;gt; # 而要使用你自己定义的&quot;bars&quot;了。
&amp;gt;&amp;gt;&amp;gt; Foo.objects.get(bars=bar)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;get_latest_by&quot;&gt;get_latest_by&lt;/h3&gt;
&lt;p&gt;Django管理器给我们提供有latest()和earliest()方法，分别表示获取最近一个和最前一个数据对象。但是，如何来判断最近一个和最前面一个呢？也就是根据什么来排序呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get_latest_by&lt;/code&gt;元数据选项帮你解决这个问题，它可以指定一个类似 &lt;code&gt;DateField&lt;/code&gt;、&lt;code&gt;DateTimeField&lt;/code&gt;或者&lt;code&gt;IntegerField&lt;/code&gt;这种可以排序的字段，作为latest()和earliest()方法的排序依据，从而得出最近一个或最前面一个对象。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get_latest_by = &quot;order_date&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;managed&quot;&gt;managed&lt;/h3&gt;
&lt;p&gt;该元数据默认值为True，表示Django将按照既定的规则，管理数据库表的生命周期。&lt;/p&gt;
&lt;p&gt;如果设置为False，将不会针对当前模型创建和删除数据库表。在某些场景下，这可能有用，但更多时候，你可以忘记该选项。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;order_with_respect_to&quot;&gt;order_with_respect_to&lt;/h3&gt;
&lt;p&gt;这个选项不好理解。其用途是根据指定的字段进行排序，通常用于关系字段。看下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.db &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; models

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Question(models.Model):
    text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.TextField()
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Answer(models.Model):
    question &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; models.ForeignKey(Question, on_delete&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;models.CASCADE)
    &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Meta:
        order_with_respect_to &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'question'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面在Answer模型中设置了&lt;code&gt;order_with_respect_to = 'question'&lt;/code&gt;，这样的话，Django会自动提供两个API，&lt;code&gt;get_RELATED_order()&lt;/code&gt;和&lt;code&gt;set_RELATED_order()&lt;/code&gt;，其中的&lt;code&gt;RELATED&lt;/code&gt;用小写的模型名代替。假设现在有一个Question对象，它关联着多个Answer对象，下面的操作返回包含关联的Anser对象的主键的列表[1,2,3]：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; question = Question.objects.get(id=1)
&amp;gt;&amp;gt;&amp;gt; question.get_answer_order()
[1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过&lt;code&gt;set_RELATED_order()&lt;/code&gt;方法，指定上面这个列表的顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; question.set_answer_order([3, 1, 2])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，关联的对象也获得了两个方法&lt;code&gt;get_next_in_order()&lt;/code&gt;和&lt;code&gt;get_previous_in_order()&lt;/code&gt;，用于通过特定的顺序访问对象，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; answer = Answer.objects.get(id=2)
&amp;gt;&amp;gt;&amp;gt; answer.get_next_in_order()
&amp;lt;Answer: 3&amp;gt;
&amp;gt;&amp;gt;&amp;gt; answer.get_previous_in_order()
&amp;lt;Answer: 1&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个元数据的作用......还没用过，囧。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;ordering&quot;&gt;ordering&lt;/h3&gt;
&lt;p&gt;最常用的元数据之一了！&lt;/p&gt;
&lt;p&gt;用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ordering = ['pub_date']             # 表示按'pub_date'字段进行升序排列
ordering = ['-pub_date']            # 表示按'pub_date'字段进行降序排列
ordering = ['-pub_date', 'author']  # 表示先按'pub_date'字段进行降序排列，再按`author`字段进行升序排列。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;permissions&quot;&gt;permissions&lt;/h3&gt;
&lt;p&gt;该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是&lt;code&gt;(权限代码, 直观的权限名称)&lt;/code&gt;的格式。比如下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;permissions = ((&quot;can_deliver_pizzas&quot;, &quot;可以送披萨&quot;),)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;default_permissions&quot;&gt;default_permissions&lt;/h3&gt;
&lt;p&gt;Django默认给所有的模型设置('add', 'change', 'delete')的权限，也就是增删改。你可以自定义这个选项，比如设置为一个空列表，表示你不需要默认的权限，但是这一操作必须在执行migrate命令之前。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;proxy&quot;&gt;proxy&lt;/h3&gt;
&lt;p&gt;如果设置了&lt;code&gt;proxy = True&lt;/code&gt;，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;required_db_features&quot;&gt;required_db_features&lt;/h3&gt;
&lt;p&gt;声明模型依赖的数据库功能。比如['gis_enabled']，表示模型的建立依赖GIS功能。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;required_db_vendor&quot;&gt;required_db_vendor&lt;/h3&gt;
&lt;p&gt;声明模型支持的数据库。Django默认支持&lt;code&gt;sqlite, postgresql, mysql, oracle&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;select_on_save&quot;&gt;select_on_save&lt;/h3&gt;
&lt;p&gt;决定是否使用1.6版本之前的&lt;code&gt;django.db.models.Model.save()&lt;/code&gt;算法保存对象。默认值为False。这个选项我们通常不用关心。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;indexes&quot;&gt;indexes&lt;/h3&gt;
&lt;p&gt;Django1.11新增的选项。&lt;/p&gt;
&lt;p&gt;接收一个应用在当前模型上的索引列表，如下例所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class Customer(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)

    class Meta:
        indexes = [
            models.Index(fields=['last_name', 'first_name']),
            models.Index(fields=['first_name'], name='first_name_idx'),
        ]&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;unique_together&quot;&gt;unique_together&lt;/h3&gt;
&lt;p&gt;这个元数据是非常重要的一个！它等同于数据库的联合约束！&lt;/p&gt;
&lt;p&gt;举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要和我说主键唯一，这里讨论的不是这个问题）&lt;/p&gt;
&lt;p&gt;我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;unique_together&lt;/code&gt;，也就是联合唯一！&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unique_together = (('name', 'birth_day', 'address'),)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这一元数据经常被用在admin后台，并且强制应用于数据库层面。&lt;/p&gt;
&lt;p&gt;unique_together接收一个二维的元组((xx,xx,xx,...),(),(),()...)，每一个元素都是一个元组，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unique_together = ('name', 'birth_day', 'address')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;联合唯一无法作用于普通的多对多字段。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;index_together&quot;&gt;index_together&lt;/h3&gt;
&lt;p&gt;即将废弃，使用&lt;code&gt;index&lt;/code&gt;元数据代替。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;verbose_name&quot;&gt;verbose_name&lt;/h3&gt;
&lt;p&gt;最常用的元数据之一！用于设置模型对象的直观、人类可读的名称。可以用中文。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;verbose_name = &quot;story&quot;
verbose_name = &quot;披萨&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不指定它，那么Django会使用小写的模型名作为默认值。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;verbose_name_plural&quot;&gt;verbose_name_plural&lt;/h3&gt;
&lt;p&gt;英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和&lt;code&gt;verbose_name&lt;/code&gt;一致也可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;verbose_name_plural = &quot;stories&quot;
verbose_name_plural = &quot;披萨&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不指定该选项，那么默认的复数名字是&lt;code&gt;verbose_name&lt;/code&gt;加上‘s’&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;label&quot;&gt;label&lt;/h3&gt;
&lt;p&gt;前面介绍的元数据都是可修改和设置的，但还有两个只读的元数据，label就是其中之一。&lt;/p&gt;
&lt;p&gt;label等同于&lt;code&gt;app_label.object_name&lt;/code&gt;。例如&lt;code&gt;polls.Question&lt;/code&gt;，polls是应用名，Question是模型名。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;label_lower&quot;&gt;label_lower&lt;/h3&gt;
&lt;p&gt;同上，不过是小写的模型名。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 13:28:00 +0000</pubDate>
<dc:creator>刘江liujiangblog.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/8419493.html</dc:identifier>
</item>
<item>
<title>聊聊构造函数 - -宇泽-</title>
<link>http://www.cnblogs.com/-yu-ze-/p/8419364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-yu-ze-/p/8419364.html</guid>
<description>&lt;h2&gt;JavaScript对象的创建方式&lt;/h2&gt;
&lt;p&gt;在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便的书写方式，例如：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_384965&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o1 = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;p:”I’m in Object literal”,&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alertP:function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这样，就用对象字面量创建了一个对象o1，它具有一个成员变量p以及一个成员方法alertP。这种写法不需要定义构造函数，因此不在本文的讨论范围之内。这种写法的缺点是，每创建一个新的对象都需要写出完整的定义语句，不便于创建大量相同类型的对象，不利于使用继承等高级特性。&lt;/p&gt;
&lt;p&gt;new表达式是配合构造函数使用的，例如new String(“a string”)，调用内置的String函数构造了一个字符串对象。下面我们用构造函数的方式来重新创建一个实现同样功能的对象，首先是定义构造函数，然后是调用new表达式：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_805455&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function CO(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = “I’m in constructed object”;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o2 = newCO();&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;那么，在使用new操作符来调用一个构造函数的时候，发生了什么呢？其实很简单，就发生了四件事：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_281817&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var obj  ={};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;obj.__proto__ = CO.prototype;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CO.call(obj);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;obj;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;第一行，创建一个空对象obj。&lt;/p&gt;
&lt;p&gt;第二行，将这个空对象的__proto__成员指向了构造函数对象的prototype成员对象，这是最关键的一步，具体细节将在下文描述。&lt;/p&gt;
&lt;p&gt;第三行，将构造函数的作用域赋给新对象，因此CA函数中的this指向新对象obj，然后再调用CO函数。于是我们就给obj对象赋值了一个成员变量p，这个成员变量的值是” I’min constructed object”。&lt;/p&gt;
&lt;p&gt;第四行，返回新对象obj。当构造函数里包含返回语句时情况比较特殊，这种情况会在下文中说到。&lt;/p&gt;

&lt;h2&gt;正确定义JavaScript构造函数&lt;/h2&gt;
&lt;p&gt;不同于其它的主流编程语言，JavaScript的构造函数并不是作为类的一个特定方法存在的；当任意一个普通函数用于创建&lt;strong&gt;一类&lt;/strong&gt;对象时，它就被称作构造函数，或构造器。一个函数要作为一个真正意义上的构造函数，需要满足下列条件：&lt;/p&gt;
&lt;p&gt;1、 在函数内部对新对象（this）的属性进行设置，通常是添加属性和方法。&lt;/p&gt;
&lt;p&gt;2、 构造函数可以包含返回语句（不推荐），但返回值必须是this，或者其它非对象类型的值。&lt;/p&gt;
&lt;p&gt;上文定义的构造函数CO就是一个标准的、简单的构造函数。下面例子定义的函数C1返回了一个对象，我们可以使用new表达式来调用它，该表达式可以正确返回一个对象：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_894414&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function C1(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;var o = {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;p:”I’m p in C1”&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;o;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var o1 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C1();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;alert(o1.p);&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;但这种方式并不是值得推荐的方式，因为对象o1的原型是函数C1内部定义的对象o的原型，也就是Object.prototype。这种方式相当于执行了正常new表达式的前三步，而在第四步的时候返回了C1函数的返回值。该方式同样不便于创建大量相同类型的对象，不利于使用继承等高级特性，并且容易造成混乱，应该摒弃。&lt;/p&gt;
&lt;p&gt;一个构造函数在某些情况下完全可以作为普通的功能函数来使用，这是JavaScript灵活性的一个体现。下例定义的C2就是一个“多用途”函数：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_894269&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function C2(a, b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var c2 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C2(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;c2.alertP();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;alert(C2(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;));&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;该函数既可以用作构造函数来构造一个对象，也可以作为普通的函数来使用。用作普通函数时，它接收两个参数，并返回两者的相加的结果。为了代码的可读性和可维护性，建议作为构造函数的函数不要掺杂除构造作用以外的代码；同样的，一般的功能函数也不要用作构造对象。&lt;/p&gt;

&lt;h2&gt;为什么要使用构造函数&lt;/h2&gt;
&lt;p&gt;根据上文的定义，在表面上看来，构造函数似乎只是对一个新创建的对象进行初始化，增加一些成员变量和方法；然而构造函数的作用远不止这些。为了说明使用构造函数的意义，我们先来回顾一下前文提到的例子。执行var o2 = new CO();创建对象的时候，发生了四件事情：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_550422&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var obj  ={};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;obj.__proto__ = CO.prototype;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CO.call(obj);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;obj;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;我们说最重要的是第二步，将新生成的对象的__prop__属性赋值为构造函数的prototype属性，使得通过构造函数创建的所有对象可以共享相同的原型。这意味着同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的对象。关于原型（prototype）和继承的细节，笔者会再另一篇文章中深入说明。&lt;/p&gt;
&lt;p&gt;在JavaScript标准中，并没有__prop__这个属性，不过它现在已经是一些主流的JavaScript执行环境默认的一个标准属性，用于指向构造函数的原型。该属性是默认不可见的，而且在各执行环境中实现的细节不尽相同，例如IE浏览器中不存在该属性。我们只要知道JavaScript对象内部存在指向构造函数原型的指针就可以了，这个指针是在调用new表达式的时候自动赋值的，并且我们不应该去修改它。&lt;/p&gt;
&lt;p&gt;在构造对象的四个步骤中，我们可以看到，除第二步以外，别的步骤我们无须借助new表达式去实现，因此new表达式不仅仅是对这四个步骤的简化，也是要实现继承的必经之路。&lt;/p&gt;

&lt;h2&gt;容易混淆的地方&lt;/h2&gt;
&lt;p&gt;关于JavaScript的构造函数，有一个容易混淆的地方，那就是原型的constructor属性。在JavaScript中，每一个函数都有默认的原型对象属性prototype，该对象默认包含了两个成员属性：constructor和__proto__。关于原型的细节就不在本文赘述了，我们现在关心的是这个constructor属性。&lt;/p&gt;
&lt;p&gt;按照面向对象的习惯性思维，我们说构造函数相当于“类”的定义，从而可能会认为constructor属性就是该类实际意义上的构造函数，在new表达式创建一个对象的时候，会直接调用constructor来初始化对象，那就大错特错了。new表达式执行的实际过程已经在上文中介绍过了（四个步骤），其中用于初始化对象的是第三步，调用的初始化函数正是“类函数”本身，而不是constructor。如果没有考虑过这个问题，这一点可能不太好理解，那就让我们举个例子来说明一下吧：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_535261&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function C3(a, b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p = a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.alertP = function(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;alert(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function fake(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.p =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;100&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;C3.prototype.constructor = fake;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var c3 =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;C3(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;c3.alertP();&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;上述代码手动改变了C3原型中的constructor函数，然而却没有对c3对象的创建产生实质的影响，可见在new表达式中，起初始化对象作用的只能是构造函数本身。那么constructor属性的作用是什么呢？一般来说，我们可以使用constructor属性来测试对象的类型：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_341493&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var myArray = [&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(myArray.constructor == Array);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这招对于简单的对象是管用的，涉及到继承或者跨窗口等复杂情况时，可能就没那么灵光了：&lt;/p&gt;

&lt;div&gt;
&lt;div id=&quot;highlighter_473660&quot; class=&quot;syntaxhighlighter java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function f() {&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.foo =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;function s() {&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.bar =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;s.prototype =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;f();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt; &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;var son =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;s();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(son.constructor == s);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;(son.constructor == f);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这样的结果可能跟你的预期不相一致，所以使用constructor属性的时候一定要小心，或者干脆不要用它。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 12:40:00 +0000</pubDate>
<dc:creator>-宇泽-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-yu-ze-/p/8419364.html</dc:identifier>
</item>
<item>
<title>八大排序算法Java实现 - morethink</title>
<link>http://www.cnblogs.com/morethink/p/8419151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morethink/p/8419151.html</guid>
<description>&lt;p&gt;本文对常见的排序算法进行了总结。&lt;/p&gt;
&lt;p&gt;常见排序算法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#直接插入排序&quot;&gt;直接插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#希尔排序&quot;&gt;希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#简单选择排序&quot;&gt;简单选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#堆排序&quot;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#冒泡排序&quot;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#快速排序&quot;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#归并排序&quot;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/morethink/p/8419151.html#基数排序&quot;&gt;基数排序&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/3d3cc5f92a9b88b9def40b8aeab71af2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;稳定与非稳定&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是 &lt;strong&gt;稳定&lt;/strong&gt; 的。反之，则是 &lt;strong&gt;非稳定&lt;/strong&gt; 的。&lt;/p&gt;

&lt;h2 id=&quot;基本思想&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了要给插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。&lt;/p&gt;
&lt;h2 id=&quot;算法描述&quot;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从第一个元素开始，该元素可以认为已经被排序&lt;/li&gt;
&lt;li&gt;取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li&gt;
&lt;li&gt;如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li&gt;
&lt;li&gt;将新元素插入到该位置后&lt;/li&gt;
&lt;li&gt;重复步骤2~5&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;动态效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;br/&gt;如果 &lt;em&gt;比较操作&lt;/em&gt; 的代价比 &lt;em&gt;交换操作&lt;/em&gt; 大的话，可以采用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95&quot;&gt;二分查找法&lt;/a&gt;来减少 &lt;em&gt;比较操作&lt;/em&gt; 的数目。该算法可以认为是 &lt;strong&gt;插入排序&lt;/strong&gt; 的一个变种，称为&lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;二分查找插入排序&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 通过交换进行插入排序&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i++) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; j &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j--) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[j] &amp;lt; a[j - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = a[j];
                a[j] = a[j - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;];
                a[j - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = temp;
            }
        }
    }
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 通过将较大的元素都向右移动而不总是交换两个元素，这样访问数组的次数就能减半&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort2&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i++) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; num = a[i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;];
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt;= i; j++) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (num &amp;lt; a[j]) {
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; m = i; m &amp;gt;= j; m--) {
                    a[m + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = a[m];
                }
                a[j] = num;
                &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;直接插入排序复杂度如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;比较与总结&quot;&gt;比较与总结&lt;/h2&gt;
&lt;p&gt;插入排序所需的时间取决于输入元素的初始顺序。例如，对一个很大且其中的元素已经有序(或接近有序)的数组进行排序将会比随机顺序的数组或是逆序数组进行排序要快得多。&lt;/p&gt;

&lt;p&gt;希尔排序，也称 &lt;strong&gt;递减增量排序算法&lt;/strong&gt;，是插入排序的一种更高效的改进版本。希尔排序是 &lt;strong&gt;非稳定排序算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;希尔排序是基于插入排序的以下两点性质而提出改进方法的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率&lt;/li&gt;
&lt;li&gt;但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。&lt;/p&gt;
&lt;h2 id=&quot;基本思想-1&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。&lt;/p&gt;
&lt;p&gt;可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是&lt;strong&gt;初次取数组长度的一半&lt;/strong&gt;为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97&quot;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;算法描述-1&quot;&gt;算法描述&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;选择一个增量序列 t1，t2，……，tk，其中 ti &amp;gt; tj, tk = 1；&lt;/li&gt;
&lt;li&gt;按增量序列个数 k，对序列进行 k 趟排序；&lt;/li&gt;
&lt;li&gt;每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/4697893fd8a952d01956e192640c1c3c.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现-1&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;下面参考《算法》中给出的步长选择策略，《算法》中给出的解释是&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;下面代码中递增序列的计算和使用都很简单，和复杂递增序列的性能接近。当可以证明复杂的序列在最坏情况下的性能要好于我们所使用的递增序列。更加优秀的递增序列有待我们去发现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; length = a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; h = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (h &amp;lt; length / &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) h = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; * h + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (; h &amp;gt;= &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; h /= &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - h; i += h) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = i + h; j &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j -= h) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[j] &amp;lt; a[j - h]) {
                    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = a[j];
                    a[j] = a[j - h];
                    a[j - h] = temp;
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-1&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;以下是希尔排序复杂度:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;O(nlog2 n)&lt;/td&gt;
&lt;td&gt;O(nlog2 n)&lt;/td&gt;
&lt;td&gt;O(nlog2 n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;总结与思考&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。&lt;/p&gt;

&lt;h2 id=&quot;基本思想-2&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p&gt;
&lt;p&gt;选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n个元素的表进行排序总共进行至多 n-1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。&lt;/p&gt;
&lt;h2 id=&quot;算法描述-2&quot;&gt;算法描述&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;从未排序序列中，找到关键字最小的元素&lt;/li&gt;
&lt;li&gt;如果最小元素不是未排序序列的第一个元素，将其和未排序序列第一个元素互换&lt;/li&gt;
&lt;li&gt;重复1、2步，直到排序结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;动图效果如下所示：&lt;br/&gt;&lt;img src=&quot;https://images.morethink.cn/28749720-90304278-7503-11e7-9bc8-e3b56539d8bf.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; min = i;
        &lt;span class=&quot;co&quot;&gt;//选出之后待排序中值最小的位置&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; j &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; j++) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[j] &amp;lt; a[min]) {
                min = j;
            }
        }
        &lt;span class=&quot;co&quot;&gt;//最小值不等于当前值时进行交换&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (min != i) {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = a[i];
            a[i] = a[min];
            a[min] = temp;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-2&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;以下是选择排序复杂度:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;总结与思考-1&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;堆的定义如下：&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个元素的序列{k1,k2,..,kn}&lt;br/&gt;当且仅当满足下关系时，称之为堆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/a59e9c9d21c72944dac53b59b745a5cc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：&lt;strong&gt;完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。&lt;/strong&gt; 由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。&lt;/p&gt;
&lt;h2 id=&quot;基本思想-3&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。&lt;/p&gt;
&lt;h2 id=&quot;算法描述-3&quot;&gt;算法描述&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先将初始序列&lt;span class=&quot;math inline&quot;&gt;\(K[1..n]\)&lt;/span&gt;建成一个大顶堆, 那么此时第一个元素&lt;span class=&quot;math inline&quot;&gt;\(K_1\)&lt;/span&gt;最大, 此堆为初始的无序区.&lt;/li&gt;
&lt;li&gt;再将关键字最大的记录&lt;span class=&quot;math inline&quot;&gt;\(K_1\)&lt;/span&gt; (即堆顶, 第一个元素)和无序区的最后一个记录 &lt;span class=&quot;math inline&quot;&gt;\(K_n\)&lt;/span&gt; 交换, 由此得到新的无序区&lt;span class=&quot;math inline&quot;&gt;\(K[1..n-1]\)&lt;/span&gt;和有序区&lt;span class=&quot;math inline&quot;&gt;\(K[n]\)&lt;/span&gt;, 且满足&lt;span class=&quot;math inline&quot;&gt;\(K[1..n-1].keys \leqslant K[n].key\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;交换&lt;span class=&quot;math inline&quot;&gt;\(K_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(K_n\)&lt;/span&gt; 后, 堆顶可能违反堆性质, 因此需将&lt;span class=&quot;math inline&quot;&gt;\(K[1..n-1]\)&lt;/span&gt;调整为堆. 然后重复步骤2, 直到无序区只有一个元素时停止。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;动图效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/heap_sort_gif.gif&quot; alt=&quot;堆排序过程&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现-3&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。&lt;/p&gt;
&lt;p&gt;总结起来就是定义了以下几种操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点&lt;/li&gt;
&lt;li&gt;创建最大堆（Build_Max_Heap）：将堆所有数据重新排序&lt;/li&gt;
&lt;li&gt;堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于堆节点的访问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父节点i的左子节点在位置：&lt;code&gt;(2*i+1)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;父节点i的右子节点在位置：&lt;code&gt;(2*i+2)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;子节点i的父节点在位置：&lt;code&gt;floor((i-1)/2)&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i--) {
        &lt;span class=&quot;fu&quot;&gt;max_heapify&lt;/span&gt;(a, i);

        &lt;span class=&quot;co&quot;&gt;//堆顶元素(第一个元素)与Kn交换&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = a[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];
        a[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = a[i];
        a[i] = temp;
    }
}

&lt;span class=&quot;co&quot;&gt;/***&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *  将数组堆化&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *  i = 第一个非叶子节点。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param n&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;max_heapify&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; child;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i--) {
        &lt;span class=&quot;co&quot;&gt;//左子节点位置&lt;/span&gt;
        child = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; * i + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;//右子节点存在且大于左子节点，child变成右子节点&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (child != n &amp;amp;&amp;amp; a[child] &amp;lt; a[child + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]) {
            child++;
        }
        &lt;span class=&quot;co&quot;&gt;//交换父节点与左右子节点中的最大值&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[i] &amp;lt; a[child]) {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = a[i];
            a[i] = a[child];
            a[child] = temp;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-3&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);&lt;/li&gt;
&lt;li&gt;调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);&lt;/li&gt;
&lt;li&gt;堆排序的过程由n次第2步完成, 时间复杂度为O(nlgn).&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n \log_{2}n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n \log_{2}n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(O(n \log_{2}n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;总结与思考-2&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列&lt;/strong&gt;。 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本思想-4&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/p&gt;
&lt;h2 id=&quot;算法描述-4&quot;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;冒泡排序算法的运作如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/bubble.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现-4&quot;&gt;代码实现&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
    &lt;span class=&quot;co&quot;&gt;//外层循环控制比较的次数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i++) {
      &lt;span class=&quot;co&quot;&gt;//内层循环控制到达位置&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - i - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; j++) {
            &lt;span class=&quot;co&quot;&gt;//前面的元素比后面大就交换&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[j] &amp;gt; a[j + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; temp = a[j];
                a[j] = a[j + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;];
                a[j + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = temp;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-4&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;以下是冒泡排序算法复杂度:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).&lt;/p&gt;
&lt;h2 id=&quot;总结与思考-3&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。&lt;/p&gt;

&lt;p&gt;快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。&lt;/p&gt;
&lt;h2 id=&quot;基本思想-5&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;快速排序的基本思想：&lt;strong&gt;挖坑填数+分治法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。&lt;/p&gt;
&lt;p&gt;快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。&lt;/p&gt;
&lt;p&gt;快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好。&lt;/p&gt;
&lt;h2 id=&quot;算法描述-5&quot;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从数列中挑出一个元素，称为&quot;基准&quot;（pivot）。&lt;/li&gt;
&lt;li&gt;重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。&lt;/li&gt;
&lt;li&gt;递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/quick-sort.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现-5&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;用伪代码描述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;i = L; j = R;&lt;/code&gt; 将基准数挖出形成第一个坑&lt;code&gt;a[i]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j--&lt;/code&gt;，由后向前找比它小的数，找到后挖出此数填前一个坑&lt;code&gt;a[i]&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i++&lt;/code&gt;，由前向后找比它大的数，找到后也挖出此数填到前一个坑&lt;code&gt;a[j]&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;再重复执行2，3二步，直到&lt;code&gt;i==j&lt;/code&gt;，将基准数填入&lt;code&gt;a[i]&lt;/code&gt;中&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; low, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; high) {
    &lt;span class=&quot;co&quot;&gt;//已经排完&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (low &amp;gt;= high) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; left = low;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; right = high;

    &lt;span class=&quot;co&quot;&gt;//保存基准值&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pivot = a[left];
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (left &amp;lt; right) {
        &lt;span class=&quot;co&quot;&gt;//从后向前找到比基准小的元素&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (left &amp;lt; right &amp;amp;&amp;amp; a[right] &amp;gt;= pivot)
            right--;
        a[left] = a[right];
        &lt;span class=&quot;co&quot;&gt;//从前往后找到比基准大的元素&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (left &amp;lt; right &amp;amp;&amp;amp; a[left] &amp;lt;= pivot)
            left++;
        a[right] = a[left];
    }
    &lt;span class=&quot;co&quot;&gt;// 放置基准值，准备分治递归快排&lt;/span&gt;
    a[left] = pivot;
    &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(a, low, left - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(a, left + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, high);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是递归版的快速排序：通过把基准插入到合适的位置来实现分治，并递归地对分治后的两个划分继续快排。那么非递归版的快排如何实现呢？&lt;/p&gt;
&lt;p&gt;因为 &lt;strong&gt;递归的本质是栈&lt;/strong&gt; ，所以我们非递归实现的过程中，可以借助栈来保存中间变量就可以实现非递归了。在这里中间变量也就是通过Pritation函数划分区间之后分成左右两部分的首尾指针，只需要保存这两部分的首尾指针即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sortByStack&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
    Stack&amp;lt;Integer&amp;gt; stack = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Stack&amp;lt;Integer&amp;gt;();

    &lt;span class=&quot;co&quot;&gt;//初始状态的左右指针入栈&lt;/span&gt;
    stack.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
    stack.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!stack.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span class=&quot;co&quot;&gt;//出栈进行划分&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; high = stack.&lt;span class=&quot;fu&quot;&gt;pop&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; low = stack.&lt;span class=&quot;fu&quot;&gt;pop&lt;/span&gt;();

        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pivotIndex = &lt;span class=&quot;fu&quot;&gt;partition&lt;/span&gt;(a, low, high);

        &lt;span class=&quot;co&quot;&gt;//保存中间变量&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pivotIndex &amp;gt; low) {
            stack.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(low);
            stack.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(pivotIndex - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pivotIndex &amp;lt; high &amp;amp;&amp;amp; pivotIndex &amp;gt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            stack.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(pivotIndex + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
            stack.&lt;span class=&quot;fu&quot;&gt;push&lt;/span&gt;(high);
        }
    }
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;partition&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; low, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; high) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (low &amp;gt;= high) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; left = low;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; right = high;
    &lt;span class=&quot;co&quot;&gt;//保存基准的值&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pivot = a[left];
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (left &amp;lt; right) {
        &lt;span class=&quot;co&quot;&gt;//从后向前找到比基准小的元素，插入到基准位置中&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (left &amp;lt; right &amp;amp;&amp;amp; a[right] &amp;gt;= pivot) {
            right--;
        }
        a[left] = a[right];
        &lt;span class=&quot;co&quot;&gt;//从前往后找到比基准大的元素&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (left &amp;lt; right &amp;amp;&amp;amp; a[left] &amp;lt;= pivot) {
            left++;
        }
        a[right] = a[left];
    }
    &lt;span class=&quot;co&quot;&gt;//放置基准值，准备分治递归快排&lt;/span&gt;
    a[left] = pivot;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; left;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;算法改进&quot;&gt;算法改进&lt;/h2&gt;
&lt;h3 id=&quot;切换到插入排序&quot;&gt;切换到插入排序&lt;/h3&gt;
&lt;p&gt;和大多数递归排序算法一样，改进快速排序性能的一个简单方法基于以下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于小数组，快速排序比插入排序慢&lt;/li&gt;
&lt;li&gt;因为递归，快速排序的sort()方法在小数组中叶会调用自己&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，在排序小数组时应该切换到插入排序。&lt;/p&gt;
&lt;h3 id=&quot;三者取中法&quot;&gt;三者取中法&lt;/h3&gt;
&lt;p&gt;快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。&lt;/p&gt;
&lt;h3 id=&quot;三向快速排序&quot;&gt;三向快速排序&lt;/h3&gt;
&lt;p&gt;实际应用中经常会出现含有大量重复元素的数组。例如，一个元素全部重复的子数组就不需要继续排序了，但我们的算法还会继续将它切分为更小的数组。在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，经当前实现的线性对数级的性能提高到线性级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法描述&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在lt之前的(lo~lt-1)都小于中间值&lt;/li&gt;
&lt;li&gt;在gt之前的(gt+1~hi)都大于中间值&lt;/li&gt;
&lt;li&gt;在lt~i-1的都等于中间值&lt;/li&gt;
&lt;li&gt;在i~gt的都还不确定（最终i会大于gt，即不确定的将不复存在）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/9f4bd508a48664b472e5644e48c2be4b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sortThreeWay&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lo, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hi) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (lo &amp;gt;= hi) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; v = a[lo], lt = lo, i = lo + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, gt = hi;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (i &amp;lt;= gt) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[i] &amp;lt; v) {
            &lt;span class=&quot;fu&quot;&gt;swap&lt;/span&gt;(a, i++, lt++);
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (a[i] &amp;gt; v) {
            &lt;span class=&quot;fu&quot;&gt;swap&lt;/span&gt;(a, i, gt--);
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            i++;
        }
    }
    &lt;span class=&quot;fu&quot;&gt;sortThreeWay&lt;/span&gt;(a, lo, lt - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;fu&quot;&gt;sortThreeWay&lt;/span&gt;(a, gt + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, hi);
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;swap&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; t = a[i];
    a[i] = a[j];
    a[j] = t;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-5&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;以下是快速排序算法复杂度:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)（原地分区递归版）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。&lt;/p&gt;
&lt;h2 id=&quot;基本思想-6&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/merge.gif&quot; alt=&quot;这个图很有概括性，来自维基&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法描述-6&quot;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;归并排序可通过两种方式实现&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自上而下的递归&lt;/li&gt;
&lt;li&gt;自下而上的迭代&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;递归法&lt;/strong&gt;（假设序列共有n个元素）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；&lt;/li&gt;
&lt;li&gt;将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；&lt;/li&gt;
&lt;li&gt;重复步骤2，直到所有元素排序完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/merging-sort.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/li&gt;
&lt;li&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/li&gt;
&lt;li&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/li&gt;
&lt;li&gt;重复步骤3直到某一指针到达序列尾&lt;/li&gt;
&lt;li&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;代码实现-6&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;归并排序其实要做两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分解：将序列每次折半拆分&lt;/li&gt;
&lt;li&gt;合并：将划分后的序列段两两排序合并&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，归并排序实际上就是两个操作，拆分+合并&lt;/p&gt;
&lt;p&gt;下面是递归的方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Merge {

    &lt;span class=&quot;co&quot;&gt;//归并所需的辅助数组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] aux;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a) {
        &lt;span class=&quot;co&quot;&gt;//一次性分配空间&lt;/span&gt;
        aux = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;];
        &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(a, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; low, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; high) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (low &amp;gt;= high) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        }
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mid = (low + high) / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;//将左半边排序&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(a, low, mid);
        &lt;span class=&quot;co&quot;&gt;//将右半边排序&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(a, mid + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, high);
        &lt;span class=&quot;fu&quot;&gt;merge&lt;/span&gt;(a, low, mid, high);
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 该方法先将所有元素复制到aux[]中，然后在归并会a[]中。方法咋归并时(第二个for循环)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 进行了4个条件判断：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * - 左半边用尽(取右半边的元素)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * - 右半边用尽(取左半边的元素)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * - 右半边的当前元素小于左半边的当前元素(取右半边的元素)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * - 右半边的当前元素大于等于左半边的当前元素(取左半边的元素)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param low&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param mid&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param high&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;merge&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] a, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; low, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mid, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; high) {
        &lt;span class=&quot;co&quot;&gt;//将a[low..mid]和a[mid+1..high]归并&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = low, j = mid + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = low; k &amp;lt;= high; k++) {
            aux[k] = a[k];
        }

        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = low; k &amp;lt;= high; k++) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (i &amp;gt; mid) {
                a[k] = aux[j++];
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (j &amp;gt; high) {
                a[k] = aux[i++];
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (aux[j] &amp;lt; aux[i]) {
                a[k] = aux[j++];
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                a[k] = aux[i++];
            }
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-6&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;以下是归并排序算法复杂度:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。&lt;/p&gt;
&lt;h2 id=&quot;总结与思考-4&quot;&gt;总结与思考&lt;/h2&gt;
&lt;p&gt;归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，它的主要缺点则是他所需的额外空间和N成正比。&lt;/p&gt;

&lt;p&gt;基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。&lt;/p&gt;
&lt;p&gt;基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。&lt;/p&gt;
&lt;h2 id=&quot;基本思想-7&quot;&gt;基本思想&lt;/h2&gt;
&lt;p&gt;它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。&lt;/p&gt;
&lt;p&gt;基数排序按照优先从高位或低位来排序有两种实现方案：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;MSD（Most significant digital） 从最左侧高位开始进行排序&lt;/strong&gt;。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。&lt;em&gt;MSD方式适用于位数多的序列&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;LSD （Least significant digital）从最右侧低位开始进行排序&lt;/strong&gt;。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。&lt;em&gt;LSD方式适用于位数少的序列&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/radix-sort_sample.gif&quot; alt=&quot;基数排序LSD动图演示&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法描述-7&quot;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;我们以LSD为例，从最低位开始，具体算法描述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;取得数组中的最大数，并取得位数；&lt;/li&gt;
&lt;li&gt;arr为原始数组，从最低位开始取每个位组成radix数组；&lt;/li&gt;
&lt;li&gt;对radix进行计数排序（利用计数排序适用于小范围数的特点）；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;代码实现-7&quot;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;分配&lt;/strong&gt;：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;收集&lt;/strong&gt;：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] arr) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;lt;= &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;//取得数组中的最大数，并取得位数&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; max = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; i++) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (max &amp;lt; arr[i]) {
            max = arr[i];
        }
    }
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; maxDigit = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (max / &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        maxDigit++;
        max = max / &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;//申请一个桶空间&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[][] buckets = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;][arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;];
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; base = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;//从低位到高位，对每一位遍历，将所有元素分配到桶中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; maxDigit; i++) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] bktLen = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];        &lt;span class=&quot;co&quot;&gt;//存储各个桶中存储元素的数量&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;//分配：将所有元素分配到桶中&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; arr.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; j++) {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; whichBucket = (arr[j] % base) / (base / &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;);
            buckets[whichBucket][bktLen[whichBucket]] = arr[j];
            bktLen[whichBucket]++;
        }

        &lt;span class=&quot;co&quot;&gt;//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; b &amp;lt; buckets.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; b++) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; p = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; p &amp;lt; bktLen[b]; p++) {
                arr[k++] = buckets[b][p];
            }
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Sorting: &quot;&lt;/span&gt; + Arrays.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(arr));
        base *= &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;复杂度分析-7&quot;&gt;复杂度分析&lt;/h2&gt;
&lt;p&gt;以下是基数排序算法复杂度，其中k为最大数的位数：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;O(d*(n+r))&lt;/td&gt;
&lt;td&gt;O(d*(n+r))&lt;/td&gt;
&lt;td&gt;O(d*(n+r))&lt;/td&gt;
&lt;td&gt;O(n+r)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中，&lt;strong&gt;d 为位数，r 为基数，n 为原数组个数&lt;/strong&gt;。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 &lt;code&gt;O(d*(n + r))&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结和思考&quot;&gt;总结和思考&lt;/h2&gt;
&lt;p&gt;基数排序更适合用于对时间, 字符串等这些 &lt;strong&gt;整体权值未知的数据&lt;/strong&gt; 进行排序。&lt;/p&gt;
&lt;p&gt;基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基数排序 vs 计数排序 vs 桶排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基数排序：根据键值的每位数字来分配桶&lt;/li&gt;
&lt;li&gt;计数排序：每个桶只存储单一键值&lt;/li&gt;
&lt;li&gt;桶排序：每个桶存储一定范围的数值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各种排序性能对比如下:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;冒泡排序&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;选择排序&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;直接插入排序&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;折半插入排序&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;希尔排序&lt;/td&gt;
&lt;td&gt;O(n^1.3)&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;归并排序&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;快速排序&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;堆排序&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(nlog₂n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;不稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;计数排序&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(k)&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;桶排序&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(n²)&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;(不)稳定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;基数排序&lt;/td&gt;
&lt;td&gt;O(d(n+k))&lt;/td&gt;
&lt;td&gt;O(d(n+k))&lt;/td&gt;
&lt;td&gt;O(d(n+kd))&lt;/td&gt;
&lt;td&gt;O(n+kd)&lt;/td&gt;
&lt;td&gt;稳定&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从时间复杂度来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;平方阶O(n²)排序：&lt;strong&gt;各类简单排序：直接插入、直接选择和冒泡排序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;线性对数阶O(nlog₂n)排序：&lt;strong&gt;快速排序、堆排序和归并排序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;O(n1+§))排序，§是介于0和1之间的常数：&lt;strong&gt;希尔排序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;线性阶O(n)排序：&lt;strong&gt;基数排序，此外还有桶、箱排序&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;论是否有序的影响：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；&lt;/li&gt;
&lt;li&gt;而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；&lt;/li&gt;
&lt;li&gt;原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/sort-comparison.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码放在 &lt;a href=&quot;https://github.com/morethink/algorithm/tree/master/src/algorithm/sort&quot; class=&quot;uri&quot;&gt;https://github.com/morethink/algorithm/tree/master/src/algorithm/sort&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《算法》第四版&lt;/li&gt;
&lt;li&gt;维基百科&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://itimetraveler.github.io/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/#%E4%B8%83%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merging-Sort%EF%BC%89&quot;&gt;八大排序算法总结与java实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010413296#articleHeader33&quot;&gt;前端面试必备——十大经典排序算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/8c915179fd02&quot;&gt;必须知道的八大种排序算法【java实现】&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 05 Feb 2018 11:41:00 +0000</pubDate>
<dc:creator>morethink</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morethink/p/8419151.html</dc:identifier>
</item>
<item>
<title>用Lua定制Redis命令 - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/8416162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/8416162.html</guid>
<description>&lt;p&gt;Redis作为一个非常成功的数据库，提供了非常丰富的数据类型和命令，使用这些，我们可以轻易而高效地完成很多缓存操作，可是总有一些比较特殊的问题或需求需要解决，这时候可能就需要我们自己定制自己的 Redis 数据结构和命令。&lt;/p&gt;
&lt;p&gt;文章欢迎转载，请尊重作者劳动成果，带上原文链接：http://www.cnblogs.com/zhenbianshu/p/8416162.html&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;&lt;q&gt;线程安全&lt;/q&gt;问题&lt;/h2&gt;
&lt;p&gt;我们都知道 Redis 是单线程的，可是它怎么会有 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&quot;&gt;线程安全&lt;/a&gt; 问题呢？&lt;/p&gt;
&lt;p&gt;我们正常理解的线程安全问题是指&lt;code&gt;单进程多线程&lt;/code&gt;模型内部多个线程&lt;code&gt;操作进程内共享内存&lt;/code&gt;导致的数据资源充突。而 Redis 的线程安全问题的产生，并不是来自于 Redis 服务器内部。&lt;/p&gt;
&lt;p&gt;Redis 作为数据服务器，就相当于多个客户端的共享内存，多个客户端就相当于同一进程下的多个线程，如果多个客户端之间没有良好的数据同步策略，就会产生类似线程安全的问题。&lt;/p&gt;
&lt;p&gt;典型场景是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis 内存储了一个用户的状态： &lt;code&gt;user5277=idle&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;客户端连接 A 读取了用户状态，获取到用户的空闲状态 &lt;code&gt;status = get(&quot;user5277&quot;)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;客户端连接 B 也同样读取了用户状态；&lt;/li&gt;
&lt;li&gt;客户端连接 A 给用户安排了一个任务，并将 Redis 内用户状态置为忙碌 &lt;code&gt;set(&quot;user5277&quot;, &quot;busy&quot;)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;客户端连接 B 同样设置用户为忙碌状态。&lt;/li&gt;
&lt;li&gt;可是此时用户却被同时分配了两个任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;导致这个问题的原因就是虽然 Redis 是单线程的，能保证命令的序列化，但由于其执行效率很高，多个客户端的命令之间不做好请求同步，同样会造成命令的顺序错乱。&lt;/p&gt;
&lt;p&gt;当然这个问题也很好解决，给用户状态加锁就行了，使同一时间内只能有一个客户端操作用户状态。不过加锁我们就需要考虑锁粒度、死锁等问题了，无疑添加了程序的复杂性，不利于维护。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;效率问题&lt;/h2&gt;
&lt;p&gt;Redis 作为一个极其高效的内存数据服务器，其命令执行速度极快，之前看过阿里云 Redis 的一个压测结果，执行效率可以达到 10W写QPS， 60W读QPS，那么，它的效率问题又来自何处呢？&lt;/p&gt;
&lt;p&gt;答案是网络，做 Web 的都知道，效率优化要从网络做起，服务端又是优化代码，又是优化数据库，不如网络连接的一次优化，而网络优化最有效的就是减少请求数。我们要知道执行一次内存访问的耗时约是 &lt;code&gt;100ns&lt;/code&gt;，而不同机房之间来回一次约需要 &lt;code&gt;500000ns&lt;/code&gt;，其中的差距可想而知。&lt;/p&gt;
&lt;p&gt;Redis在单机内效率超高，但工业化部署总不会把服务器和 Redis 放在同一台机器上，如果触碰到效率瓶颈的话，那就是网络。&lt;/p&gt;
&lt;p&gt;典型场景就是我们从 Redis 里读出一条数据，再使用这条数据做键，读取另外一条数据。这样来来回回，便有两次网络往返。&lt;/p&gt;
&lt;p&gt;导致这种问题的原因就是 Redis 的普通命令没有服务端计算的能力，无法在服务器进行复合命令操作，虽然有 Redis 也提供了 &lt;code&gt;pipeline&lt;/code&gt; 的特性，但它需要多个命令的请求和响应之间没有依赖关系。想简化多个相互依赖的命令就只能将数据拉回客户端，由客户端处理后再请求 Redis。&lt;/p&gt;
&lt;p&gt;综上，我们要更高效更方便的使用 Redis 就需要自己“定制”一些命令了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;万幸 Redis 内嵌了 Lua 执行环境，支持 Lua 脚本的执行，通过执行 Lua 脚本，我们可以把多个命令复合为一个 Lua 脚本，通过 Lua 脚本来实现上文中提到的 Redis 命令的次序性和 Redis 服务端计算。&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;Lua&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Lua&quot;&gt;Lua&lt;/a&gt; 是一个简洁、轻量、可扩展的脚本语言，它的特性有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;轻量：源码包只有核心库，编译后体积很小。&lt;/li&gt;
&lt;li&gt;高效：由 ANSI C 写的，启动快、运行快。&lt;/li&gt;
&lt;li&gt;内嵌：可内嵌到各种编程语言或系统中运行，提升静态语言的灵活性。如 OpenResty 就是将 Lua 嵌入到 nginx 中执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而且完全不需要担心语法问题，Lua 的语法很简单，分分钟使用不成问题。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;执行步骤&lt;/h2&gt;
&lt;p&gt;Redis 在 2.6 版本后，启动时会创建 Lua 环境、载入 Lua 库、定义 Redis 全局表格、存储 &lt;code&gt;redis.pcall&lt;/code&gt; 等 Redis 命令，以准备 Lua 脚本的执行。&lt;/p&gt;
&lt;p&gt;一个典型的 Lua 脚本执行步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查脚本是否执行过，没执行过使用脚本的 sha1 校验和生成一个 Lua 函数；&lt;/li&gt;
&lt;li&gt;为函数绑定超时、错误处理勾子；&lt;/li&gt;
&lt;li&gt;创建一个伪客户端，通过这个伪客户端执行 Lua 中的 Redis 命令；&lt;/li&gt;
&lt;li&gt;处理伪客户端的返回值，最终返回给客户端；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;交互时序如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201802/819496-20180205092021279-1844481758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然 Lua 脚本使用的是伪客户端，但 Redis 处理它会跟普通客户端一样，也会将执行的 Redis 命令进行 rdb aof 主从复制等操作。&lt;/p&gt;
&lt;h2 id=&quot;toc_8&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;Lua 脚本的使用可以通过 Redis 的 &lt;code&gt;EVAL&lt;/code&gt; 和 &lt;code&gt;EVALSHA&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EVAL&lt;/code&gt; 适用于单次执行 Lua 脚本，执行脚本前会由脚本内容生成 sha1 校验和，在函数表内查询函数是否已定义，如未定义执行成功后 Redis 会在全局表里缓存这个脚本的校验和为函数名，后续再次执行此命令就不会再创建新的函数了。&lt;/p&gt;
&lt;p&gt;而要使用 &lt;code&gt;EVALSHA&lt;/code&gt; 命令，就得先使用 &lt;code&gt;SCRIPT LOAD&lt;/code&gt; 命令先将函数加载到 Redis，Redis 会返回此函数的 sha1 校验和， 后续就可以直接使用这个校验和来执行命令了。&lt;/p&gt;
&lt;p&gt;以下是使用上述命令的例子：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;127.0.0.1:6379&amp;gt; EVAL &quot;return 'hello'&quot; 0 0
&quot;hello&quot;

127.0.0.1:6379&amp;gt; SCRIPT LOAD &quot;return redis.pcall('GET', ARGV[1])&quot;
&quot;20b602dcc1bb4ba8fca6b74ab364c05c58161a0a&quot;

127.0.0.1:6379&amp;gt; EVALSHA 20b602dcc1bb4ba8fca6b74ab364c05c58161a0a 0 test
&quot;zbs&quot;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EVAL 命令的原型是 &lt;code&gt;EVAL script numkeys key [key ...] arg [arg ...]&lt;/code&gt;，在 Lua 函数内部可以使用 &lt;code&gt;KEYS[N]&lt;/code&gt; 和 &lt;code&gt;ARGV[N]&lt;/code&gt; 引用键和参数，需要注意 KEYS 和 ARGV 的参数序号都是从 &lt;code&gt;1&lt;/code&gt; 开始的。&lt;/p&gt;
&lt;p&gt;还需要注意在 Lua 脚本中，Redis 返回为空时，结果是 &lt;code&gt;false&lt;/code&gt;，而 &lt;code&gt;不是 nil&lt;/code&gt;；&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;下面写几个 Lua 脚本的实例，用来介绍语法的，仅供参考。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis 里 hashSet A 的 字段 B 的值是 C，取出 Redis 里键为 C 的值。&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;// 使用: EVAL script 2 A B

local tmpKey = redis.call('HGET', KEYS[1], KEYS[2]); 
return redis.call('GET', tmpKey); &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;一次 lpop 出多个值，直到值为 n，或 list 为空（pipeline 也可轻易实现）；&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;// 使用: EVAL script 2 list count

local list = {};
local item = false;
local num = tonumber(KEYS[2]);
while (num &amp;gt; 0)
do
    item = redis.call('LPOP', KEYS[1]);
    if item == false then
        break;
    end;
    table.insert(list, item);
    num = num - 1;
end;
return list;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;获取 zset 内 score 最多的 n 个元素 对应 hashset 中的详细信息；&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;line-numbers&quot;&gt;
&lt;code class=&quot;language-none&quot;&gt;local elements = redis.call('ZRANK', KEYS[1], 0, KEY[2]);
local detail = {};

for index,ele in elements do
    local info = redis.call('HGETALL', ele);
    table.insert(detail, info);
end;

return detail;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本使用语法就是如此，更多应用就看各个具体场景了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;实现之外，还要一些东西要思考：&lt;/p&gt;
&lt;h2 id=&quot;toc_11&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;首先来总结一下 Redis 中 Lua 的使用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以使用 Lua 脚本实现原子性操作，避免不同客户端访问 Redis 服务器造成的数据冲突。&lt;/li&gt;
&lt;li&gt;在前后多次请求的结果有依赖时，可以使用 Lua 脚本把多个请求整合为一个请求。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_12&quot;&gt;注意点&lt;/h2&gt;
&lt;p&gt;使用 Lua 脚本，我们还需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要保证安全性，在 Lua 脚本中不要使用全局变量，以免污染 Lua 环境，虽然使用全局变量全报错，Lua 脚本停止执行，但还是在定义变量时添加 &lt;code&gt;local&lt;/code&gt; 关键字。&lt;/li&gt;
&lt;li&gt;要注意 Lua 脚本的时间复杂度，Redis 的单线程同样会阻塞在 Lua 脚本的执行中。&lt;/li&gt;
&lt;li&gt;使用 Lua 脚本实现原子操作时，要注意如果 Lua 脚本报错，之前的命令同样无法回滚。&lt;/li&gt;
&lt;li&gt;一次发出多个 Redis 请求，但请求前后无依赖时，使用 &lt;code&gt;pipeline&lt;/code&gt;，比 Lua 脚本方便。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;最近工作有了较大的变动，从业务到技术栈都跟原来完全不同了，所有代码和业务都脱离了自己掌控的感觉真的很不爽，工作中全是“开局一个搜索引擎，语法全靠查”，每天还要熬到很晚熟悉新的东西，有点小累，果然换工作就是找罪受啊。不过走出舒适区后的充实感也在提醒自己正在不停进步，倒也挺有成就感的。&lt;/p&gt;
&lt;p&gt;刚接触新的东西没什么沉淀，又不想写一些《带你三天精通 Java》这种水文，工作之余的时间都被拿去补充工作需要的技术栈了，也没时间研究些自己觉得有意思的东西，写文章需要素材啊，为了不自砸招牌，最近可能会少更。。&lt;/p&gt;
&lt;p&gt;关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 &lt;strong&gt;&lt;code&gt;推荐&lt;/code&gt;&lt;/strong&gt; 支持一下我，博客一直在更新，欢迎 &lt;strong&gt;&lt;code&gt;关注&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://redisbook.readthedocs.io/en/latest/feature/scripting.html&quot;&gt;Redis 设计与实现 » Lua 脚本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.jikexueyuan.com/project/redis/Lua.html&quot;&gt;Redis 与 Lua 脚本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9e7b5c5c9b7b&quot;&gt;Redis的Lua脚本编程的实现和应用&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Feb 2018 11:27:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/8416162.html</dc:identifier>
</item>
<item>
<title>使用CefSharp开发一个12306“安心刷票弹窗通知”工具 - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/8418821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/8418821.html</guid>
<description>&lt;p&gt;最近两年没有在春节回家过年了，主要是票太难买，虽然之前写了一个&lt;a href=&quot;http://www.cnblogs.com/bluedoctor/p/3513689.html&quot; target=&quot;_blank&quot;&gt;12306“无声购票弹窗”工具&lt;/a&gt;，解决了抢票问题，但是全家老小一起回去还是很累，干脆就在北京过年了。这两天突然有一个朋友问我你之前的抢票工具还能用不，我让他试试，他说可以，于是我觉得这样一个小工具居然还有人继续使用啊，既然有人用我就继续把他做好点，让大家过年抢票更“安心”！&lt;/p&gt;
&lt;p&gt;之前的抢票工具是基于IEBrowser控件做的，不用说大家都知道这个控件在不同的Windows系统上表现各异，因为它主要依赖于IE内核，坑爹的是它有时候还没有直接使用IE效果好，所以使用我这个抢票工具总有不顺收的地方，比如一些显示问题，提交订单后无法直接支付问题等。看到朋友介绍说CefSharp控件不错，于是决定试试，没想到出了网上介绍的坑，还有些其它的坑没有人写过，这里写出来给大家做一个参考。&lt;/p&gt;

&lt;p&gt;最新版的CefSharp要求.NET应用程序至少支持 .NET 4.6.2以上，而我这次要整合的工具程序还是 .NET 4.0的，照做相关资料去下载了一个之前的版本，结果在JS无法调用VB.NET写的方法，而它去可以在X64模式下调用C#写的方法。没法只好升级到CefSharp 57.0.0 ，才解决了这个问题。&lt;/p&gt;
&lt;p&gt;JS调用VB.NET的代码如下：&lt;/p&gt;
&lt;p&gt;VB.NET代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Public&lt;/span&gt; &lt;span&gt;Class&lt;/span&gt;&lt;span&gt; TicketNotify
    &lt;/span&gt;&lt;span&gt;Dim&lt;/span&gt; owerForm &lt;span&gt;As&lt;/span&gt;&lt;span&gt; Form

    &lt;/span&gt;&lt;span&gt;Public&lt;/span&gt; &lt;span&gt;Sub&lt;/span&gt; &lt;span&gt;New&lt;/span&gt;(&lt;span&gt;ByVal&lt;/span&gt; owner &lt;span&gt;As&lt;/span&gt;&lt;span&gt; Form)
        &lt;/span&gt;&lt;span&gt;Me&lt;/span&gt;.owerForm =&lt;span&gt; owner
    &lt;/span&gt;&lt;span&gt;End Sub&lt;/span&gt;
   
    &lt;span&gt;Public&lt;/span&gt; &lt;span&gt;Sub&lt;/span&gt;&lt;span&gt; MyNotify()
        &lt;/span&gt;&lt;span&gt;Dim&lt;/span&gt; target &lt;span&gt;As&lt;/span&gt; frm12306Ticket = &lt;span&gt;Me&lt;/span&gt;&lt;span&gt;.owerForm
        target.FoundTickt &lt;/span&gt;= &lt;span&gt;True&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt; target.Notify()&lt;/span&gt;
    &lt;span&gt;End Sub&lt;/span&gt;
   
&lt;span&gt;End Class&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将这个.NET类注册到Cef浏览器里面去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;Dim&lt;/span&gt; &lt;span&gt;WithEvents&lt;/span&gt; WebBrowser1 &lt;span&gt;As&lt;/span&gt;&lt;span&gt; CefSharp.WinForms.ChromiumWebBrowser
 &lt;/span&gt;&lt;span&gt;Me&lt;/span&gt;.WebBrowser1 = &lt;span&gt;New&lt;/span&gt; CefSharp.WinForms.ChromiumWebBrowser(&lt;span&gt;Me&lt;/span&gt;&lt;span&gt;.ticketUrl)
 &lt;/span&gt;&lt;span&gt;Me&lt;/span&gt;.WebBrowser1.RegisterJsObject(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsObj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;New&lt;/span&gt; TicketNotify(&lt;span&gt;Me&lt;/span&gt;), &lt;span&gt;Nothing&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，将一段调用这个.NET方法的JS函数注入到Cef浏览器内：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;Private&lt;/span&gt; &lt;span&gt;Sub&lt;/span&gt; WebBrowser1_FrameLoadEnd(sender &lt;span&gt;As&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;, e &lt;span&gt;As&lt;/span&gt; FrameLoadEndEventArgs) &lt;span&gt;Handles&lt;/span&gt;&lt;span&gt; WebBrowser1.FrameLoadEnd
        &lt;/span&gt;&lt;span&gt;Dim&lt;/span&gt; js &lt;span&gt;As&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; =
&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
       var divAlert&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkHaveTicket() {
            var div &lt;/span&gt;= document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;autosubmitcheckticketinfo');&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (div) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (div.style.display == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;block' || div.style.display == '') {&lt;/span&gt;
                    //txtName.value = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;有票了!!!';&lt;/span&gt;
&lt;span&gt;                    jsObj.myNotify();
                }
             }
        }

&lt;/span&gt;&amp;lt;/&lt;span&gt;string&lt;/span&gt;&amp;gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;下面两行代码效果一样&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Me.WebBrowser1.GetMainFrame().ExecuteJavaScriptAsync(js)&lt;/span&gt;
        &lt;span&gt;Me&lt;/span&gt;&lt;span&gt;.WebBrowser1.ExecuteScriptAsync(js)
 &lt;/span&gt;&lt;span&gt;End Sub&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，浏览器执行  jsObj.myNotify(); 这个方法就可以调用我们的.NET对象的方法 MyNotify() 了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
PS:注意上面有一个代码 &amp;lt;string&amp;gt;...&amp;lt;/string&amp;gt; ，这个是VB.NET独特的XML语句块，&lt;span&gt;XML是VB.NET的一种数据类型&lt;/span&gt;，就像你自定义的类型一样，这里用来表示一个字符串，所以用它来表示多行字符串是最合适的了。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于CefSharp版本问题，这个JS代码必须写到 浏览器控件的 FrameLoadEnd 事件中，但是之前查询到文章里面都说可以在 IsBrowserInitializedChanged 事件里面，现在是找不到的，但不报错，例如下面实际的代码说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;Private&lt;/span&gt; &lt;span&gt;Sub&lt;/span&gt; WebBrowser1_IsBrowserInitializedChanged(sender &lt;span&gt;As&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;, e &lt;span&gt;As&lt;/span&gt; IsBrowserInitializedChangedEventArgs) &lt;span&gt;Handles&lt;/span&gt;&lt;span&gt; WebBrowser1.IsBrowserInitializedChanged
        &lt;/span&gt;&lt;span&gt;If&lt;/span&gt; e.IsBrowserInitialized &lt;span&gt;Then&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;不可以在这里注册JS代码，新版CefSharp 找不到&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;不可以在这里开启定时器，否则定时器的事件会在当前线程，也就是UI线程之外运行，相关UI访问代码会发生“线程间操作无效”的异常&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Me.Timer1.Start()&lt;/span&gt;
        &lt;span&gt;End&lt;/span&gt; &lt;span&gt;If&lt;/span&gt;
    &lt;span&gt;End Sub&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我在公司的Windows 10系统下CefSharp运行正常，但是回家在Windows 8.1系统上，发现Cef浏览器总是不能填充满窗口，只有一半大小，但是滚动条位置却能鼓动，滚动的时候会看到闪屏，同时页面上控件的点击位置也是错位的，需要点击下才能回复页面大小，但很快又变小了。差了下资料，说可以通过程序集设置文件进行设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ede97ae6-dd7c-4f2f-9efd-2b904d7fc8f8')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ede97ae6-dd7c-4f2f-9efd-2b904d7fc8f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ede97ae6-dd7c-4f2f-9efd-2b904d7fc8f8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ede97ae6-dd7c-4f2f-9efd-2b904d7fc8f8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ede97ae6-dd7c-4f2f-9efd-2b904d7fc8f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;asmv1:assembly &lt;/span&gt;&lt;span&gt;manifestVersion&lt;/span&gt;&lt;span&gt;=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;urn:schemas-microsoft-com:asm.v1&quot;&lt;/span&gt;&lt;span&gt; xmlns:asmv1&lt;/span&gt;&lt;span&gt;=&quot;urn:schemas-microsoft-com:asm.v1&quot;&lt;/span&gt;&lt;span&gt; xmlns:asmv2&lt;/span&gt;&lt;span&gt;=&quot;urn:schemas-microsoft-com:asm.v2&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;assemblyIdentity &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.0.0.0&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;MyApplication.app&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;trustInfo &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;urn:schemas-microsoft-com:asm.v2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;security&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;requestedPrivileges &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;urn:schemas-microsoft-com:asm.v3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; UAC 清单选项
            如果希望更改 Windows 用户帐户控制级别，请用以下节点之一替换 
            requestedExecutionLevel 节点。

        &amp;lt;requestedExecutionLevel  level=&quot;asInvoker&quot; uiAccess=&quot;false&quot; /&amp;gt;
        &amp;lt;requestedExecutionLevel  level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot; /&amp;gt;
        &amp;lt;requestedExecutionLevel  level=&quot;highestAvailable&quot; uiAccess=&quot;false&quot; /&amp;gt;

            如果您希望利用文件和注册表虚拟化提供
            向后兼容性，请删除 requestedExecutionLevel 节点。
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;requestedExecutionLevel &lt;/span&gt;&lt;span&gt;level&lt;/span&gt;&lt;span&gt;=&quot;asInvoker&quot;&lt;/span&gt;&lt;span&gt; uiAccess&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;requestedPrivileges&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;security&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;trustInfo&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;compatibility &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;urn:schemas-microsoft-com:compatibility.v1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 此应用程序设计使用的所有 Windows 版本的列表。
      Windows 将会自动选择最兼容的环境。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果应用程序设计为使用 Windows Vista，请取消注释以下 supportedOS 节点&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedOS &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;{e2011457-1546-43c5-a5fe-008deee3d3f0}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;supportedOS&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果应用程序设计使用 Windows 7，请取消注释以下 supportedOS 节点&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedOS &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;{35138b9a-5d96-4fbd-8e2d-a2440225f93a}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果应用程序设计为使用 Windows 8，请取消注释以下 supportedOS 节点&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedOS &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;supportedOS&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果应用程序设计为使用 Windows 8.1，请取消对以下 supportedOS 节点的注释&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;supportedOS &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;{1f676c76-80e1-4239-95bb-83d0f6d0da78}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;compatibility&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&amp;gt;
    &amp;lt;windowsSettings&amp;gt;
      &amp;lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&amp;gt;true&amp;lt;/dpiAware&amp;gt;
    &amp;lt;/windowsSettings&amp;gt;
  &amp;lt;/application&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;asmv1:assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;app.manifest&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;结果无效，后来看到可能没有禁用GPU有关，于是做下设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;Dim&lt;/span&gt; setting &lt;span&gt;As&lt;/span&gt; CefSettings = &lt;span&gt;New&lt;/span&gt;&lt;span&gt; CefSettings()
        &lt;/span&gt;&lt;span&gt;With&lt;/span&gt;&lt;span&gt; setting
            .Locale &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            .AcceptLanguageList &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            .MultiThreadedMessageLoop &lt;/span&gt;= &lt;span&gt;True&lt;/span&gt;
        &lt;span&gt;End&lt;/span&gt; &lt;span&gt;With&lt;/span&gt;
        &lt;span&gt;Dim&lt;/span&gt; osVersion =&lt;span&gt; Environment.OSVersion
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//Disable GPU for Windows 7  ,8,8.1 &lt;/span&gt;
        &lt;span&gt;If&lt;/span&gt; osVersion.Version.Major = &lt;span&gt;6&lt;/span&gt; &lt;span&gt;Then&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;// Disable GPU in WPF and Offscreen examples until #1634 has been resolved&lt;/span&gt;
            setting.CefCommandLineArgs.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;disable-gpu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;End&lt;/span&gt; &lt;span&gt;If&lt;/span&gt;&lt;span&gt;

        CefSharp.Cef.Initialize(setting)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过这样的设置后，终于显示正常了。&lt;/p&gt;

&lt;p&gt;小工具是通过定时器不断监控页面有没有出现特定的标记来表示有票的，就是上面注入的JS代码中的 checkHaveTicket 函数。之前是在 CefSharp控件的 IsBrowserInitializedChanged 事件中处理的，结果发现运行时偶发错误，而且是Win 10报错但是Win 8.1报错：&lt;/p&gt;
&lt;p&gt;相关UI访问代码会发生“线程间操作无效”的异常&lt;/p&gt;
&lt;p&gt;推测是CefSharp控件的这些事件可能不一定运行在UI线程，在非UI线程启动定时器那么定时器的“定时事件”也不在UI线程了，所以报错。&lt;/p&gt;

&lt;p&gt;本次更新增加了“声音通知”功能，发现有票后会不断播放音乐提示，以方便你不在电脑跟前也能知道。&lt;/p&gt;
&lt;p&gt;当然如果你在电脑跟前并且不想被刷票问题打扰，这就是本工具最大的优势了，第一时间弹窗通知，不用时时刻刻去看。&lt;/p&gt;
&lt;p&gt;最后关于安全问题，既然开源了，就不会有什么偷窥您隐私问题的可能性了，可以放心使用！&lt;/p&gt;

&lt;p&gt;其它问题就没有了，处理方式跟之前的弹窗工具一样，代码我已经签入到了SOD的Github代码库中，地址如下：&lt;a href=&quot;https://github.com/znlgis/sod&quot; target=&quot;_blank&quot;&gt;https://github.com/znlgis/sod&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面附带一个运行测试效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201802/114517-20180205181104748-505508428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是打开12306自动刷票功能的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201802/114517-20180205181206966-121458759.jpg&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;468&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果有问题，或者想获取编译好的程序包，请加QQ群：18215717 ,加群请注明暗号：博客园看到12306刷票工具 &lt;/p&gt;
&lt;p&gt;稍后我会放到CSDN下载频道，请大家注意本篇博客文章的更新。&lt;/p&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;p&gt;刷票弹窗通知工具现在集成到了 &quot;PDF.NET集成开发工具&quot;里面，所以这意味着你既可以用它来做一个轻量级的&lt;span&gt;多种数据库的查询客户端&lt;/span&gt;，也可以做一个&lt;span&gt;简单的谷歌浏览器&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;虽然SOD框架是基于&lt;span&gt;LGPL协议&lt;/span&gt;发布的开源软件，但是集成开发工具属于&lt;span&gt;GPL开源协议&lt;/span&gt;，这意味着如果你可以自由的&lt;span&gt;免费的使用本软件&lt;/span&gt;，您不可以使用这个工具的源码用作商业用途，但是SOD框架的其它部分源码不在此限制范围。&lt;/p&gt;
&lt;p&gt;详细问题请看PDF.NET框架官网  &lt;a href=&quot;%20http://www.pwmis.com/sqlmap&quot; target=&quot;_blank&quot;&gt;http://www.pwmis.com/sqlmap&lt;/a&gt; ,如果有问题请和我们联系。&lt;/p&gt;

</description>
<pubDate>Mon, 05 Feb 2018 10:23:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluedoctor/p/8418821.html</dc:identifier>
</item>
</channel>
</rss>