<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ray-AABB交叉检测算法 - DHUtoBUAA</title>
<link>http://www.cnblogs.com/DHUtoBUAA/p/8329048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DHUtoBUAA/p/8329048.html</guid>
<description>&lt;p&gt;  最近在解决三维问题时，需要判断线段是否与立方体交叉，这个问题可以引申为：射线是否穿过立方体AABB。&lt;br/&gt;  在3D游戏开发中碰撞检测普遍采用的算法是轴对齐矩形边界框(Axially Aligned Bounding Box, AABB)包装盒方法,其基本思想是用一个立方体或者球体完全包裹住3D物体对象，然后根据包装盒的距离、位置等相关信息来计算是否发生碰撞。&lt;/p&gt;

&lt;p&gt;  本文接下来主要讨论射线与AABB的关系，主要对box2d碰撞检测使用的slab的碰撞检测算法(Slabs method)进行介绍，然后使用python语言实现slab碰撞检测方法，该方法可以用于3D物体拾取等应用场景。&lt;br/&gt;  Slab英文翻译是“平板”，本文是指两个平行平面/直线之间的空间。在2D空间中slab可以理解为平行于坐标轴的两条直线间的区域，3D空间中为平行于xy平面（或者yz面，xz面）的两个平面之间的区域。由此，我们可以把3D空间中的AABB盒子看做是由AABB的3组平行面形成的3个方向的slab的交集。&lt;br/&gt;  另外，引入候选面的概念：在3D空间中，我们先确定正对着射线的三个面，也就是说，我们可以通过某种方式将AABB相对于射线Ray的背面给忽略掉，从而确定三个候选的面。这三个候选的面，就是有可能和射线Ray发生交叉的最近的面。&lt;/p&gt;
&lt;p&gt;  根据这个定义，我们可以得到以下三个结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;性质一：如果一个点在AABB中，那么这个点必定同时在这3个slab中。&lt;/li&gt;
&lt;li&gt;性质二：如果一条射线和AABB相交，那么这条射线和3个slab的相交部分必定有重合部分。&lt;/li&gt;
&lt;li&gt;性质三：当射线与这三个候选面中的一个发生交叉之后，射线Ray的原点到这个面的距离要比到其他几个面的距离要长。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;  性质一和性质二比较容易理解，如果射线和3个slab的相交线段没有重合，那么这些线段就不可能同时存在于3个slab中，也就不可能在AABB盒子中。&lt;br/&gt;  为了方便理解性质三，使用2D图形来讲解：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-22/14739430.jpg&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;图片名称&quot; align=&quot;center/&quot;/&gt;&lt;/div&gt;
&lt;p&gt;  在上图中，我们的射线在右下角，向左上角发射，射线经过一个A点，其中候选面是y1面和x2面。&lt;br/&gt;  根据上述性质，可以看到A点同时在2D空间中的2个slab中；此外，根据性质二，因为射线与平面相交，那么这条射线与slab的相交部分必有重合部分，因为A点在射线上，且在平面中，那么可以得到max(t1,t2)&amp;lt;=tA&amp;lt;=min(t3,t4);根据性质三：当交叉后，可以看出t2&amp;gt;t1。&lt;br/&gt;  同理，我们可以把上述的验证过程推广到三维中。在三维空间中，假设射线到3个候选面的距离分别是t1、t2、t3，到候选面对应的面的距离分别为t4、t5、t6，那么根据性质二，射线与AABB碰撞的条件是max(t1,t2,t3)&amp;lt;=min(t4,t5,t6);如果发生交叉，那么根据性质三，射线到最近的交叉面的距离是是max(t1,t2,t3)。&lt;/p&gt;
&lt;p&gt;  在上述性质基础上，确定射线与AABB是否交叉需要三步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何确定候选面：只要将平面方程带入射线Ray的方程，求出这两个平面的t值，然后t值较小的那个自然先与射线交叉，那么就表示它是一个候选面。射线可以用参数方程表示为R(t) = P0 + t·d, (其中P0为射线起点，d为射线的方向向量)&lt;/li&gt;
&lt;li&gt;如何确定候选面的方程。平面由隐式定义方程X·n=D， (其中X为平面上的点，n为平面法向量，D为原点到平面的距离)给出。由于AABB的slab平面都分别和两个坐标轴平行，它的面的法线总是有两个分量是0，而另外一个分量总是为1，所以我们一致使用某个轴分量为1的法线。如果上面的方程表示的是AABB盒的左面的面，那么公式中的n表示的就是(1,0,0)，但上面的公式表示的是AABB盒的右边的面的时候，n表示的值依然是(1,0,0)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如何对交叉点是否在AABB盒上进行判断。根据性质二判断，即射线与AABB碰撞的条件是max(t1,t2,t3)&amp;lt;=min(t4,t5,t6)。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;
&lt;p&gt;  求取t值的公式推导如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-22/97654879.jpg&quot; width=&quot;350&quot; height=&quot;500&quot; alt=&quot;图片名称&quot; align=&quot;center/&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;最后，附上我的Python代码片段，代码实时更新于&lt;a href=&quot;https://github.com/wylloong/TinyPrograms/blob/master/SimulationProject/Ray-AABB%E4%BA%A4%E5%8F%89%E6%A3%80%E6%B5%8B.md&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Ray-AABB方法 相交返回True，否则返回False&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# TDPoint = collections.namedtuple(&quot;TDPoint&quot;, [&quot;x&quot;, &quot;y&quot;,&quot;z&quot;])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# AABB有最大和最小点组成，数据结构为｛max=TDPoint,min=TDPoint｝&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Ray由原点和方向组成，其中方向矢量为1，数据结构为｛TDPoint，TDPoint｝&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; intersectWithAABB(AABB,Ray):
    tmin&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    tmax&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;# &amp;lt;editor-fold desc=&quot;平行于x轴&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(math.fabs(Ray[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].x)&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.000001&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].x&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;AABB.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;.x) &lt;span class=&quot;op&quot;&gt;or&lt;/span&gt; (Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].x&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;AABB.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;.x):
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        ood&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].x
        t1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(AABB.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;.x&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].x)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;ood
        t2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(AABB.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;.x&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].x)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;ood
        &lt;span class=&quot;co&quot;&gt;# t1做候选平面，t2做远平面&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (t1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;t2):
            temp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t1
            t1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t2
            t2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;temp
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;tmin:
            tmin&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t1
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t2&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;tmax:
            tmax&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t2
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; tmin&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;tmax:
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# &amp;lt;/editor-fold&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;# &amp;lt;editor-fold desc=&quot;平行于y轴&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(math.fabs(Ray[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].y)&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.000001&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].y&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;AABB.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;.y) &lt;span class=&quot;op&quot;&gt;or&lt;/span&gt; (Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].y&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;AABB.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;.y):
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        ood&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].y
        t1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(AABB.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;.y&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].y)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;ood
        t2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(AABB.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;.y&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].y)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;ood
        &lt;span class=&quot;co&quot;&gt;# t1做候选平面，t2做远平面&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (t1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;t2):
            temp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t1
            t1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t2
            t2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;temp
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;tmin:
            tmin&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t1
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t2&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;tmax:
            tmax&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t2
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; tmin&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;tmax:
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# &amp;lt;/editor-fold&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;# &amp;lt;editor-fold desc=&quot;平行于z轴&quot;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(math.fabs(Ray[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].z)&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.000001&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].z&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;AABB.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;.z) &lt;span class=&quot;op&quot;&gt;or&lt;/span&gt; (Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].z&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;AABB.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;.z):
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        ood&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].z
        t1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(AABB.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;.z&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].z)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;ood
        t2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(AABB.&lt;span class=&quot;bu&quot;&gt;max&lt;/span&gt;.z&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;Ray[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].z)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;ood
        &lt;span class=&quot;co&quot;&gt;# t1做候选平面，t2做远平面&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (t1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;t2):
            temp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t1
            t1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t2
            t2&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;temp
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t1&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;tmin:
            tmin&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t1
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t2&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;tmax:
            tmax&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;t2
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; tmin&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;tmax:
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# &amp;lt;/editor-fold&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;from &lt;a href=&quot;http://blog.csdn.net/i_dovelemon/article/details/38342739&quot;&gt;3D空间中射线与轴向包围盒AABB的交叉检测算法&lt;/a&gt;&lt;br/&gt;from &lt;a href=&quot;http://blog.csdn.net/ring0hx/article/details/7677418&quot;&gt;Box2D 射线和AABB的碰撞检测&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Jan 2018 06:59:00 +0000</pubDate>
<dc:creator>DHUtoBUAA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DHUtoBUAA/p/8329048.html</dc:identifier>
</item>
<item>
<title>net+Oracle开发过程中遇到的小问题 - 歌神的卖</title>
<link>http://www.cnblogs.com/kaoleba/p/8328928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaoleba/p/8328928.html</guid>
<description>&lt;p&gt;最新的项目开始使用Oracle后，5个月之间遇到一些在SqlServer中没有遇到的问题，这里记录并贴上一些常用的解决办法。&lt;/p&gt;
&lt;h2 id=&quot;oracle相关&quot;&gt;Oracle相关&lt;/h2&gt;
&lt;h3 id=&quot;一数据库不同版本还原&quot;&gt;一、数据库不同版本还原&lt;/h3&gt;
&lt;p&gt;刚开始我们一直使用Oracle12C进行开发，到上线服务器时说12C与可能不太稳定，有些问题不好定位就转用11g，这里牵扯到12C导出的DMP文件导入到11G上的问题，导出导入语句：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;fu&quot;&gt;exp&lt;/span&gt; 账号/密码@STO_DataBase file=D:\STO_DataBase.dmp full=y
imp 账号/密码@STO_DataBase file=D:\DataBackUp\STO_DataBase.dmp full=y&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入报异常版本不一样，无法导入，这里用一款小工具可以解决问题&lt;a href=&quot;http://download.csdn.net/download/kaoleba126com/10217188&quot;&gt;下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/375940/201801/375940-20180122085557803-1850168115.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二数据库创建&quot;&gt;二、数据库创建&lt;/h3&gt;
&lt;p&gt;数据库文件大小受DB_BLOCK_SIZE决定，默认是8K对应的数据库文件是32G，所以创建数据库时数据库的大小不要设置最大值最好设置成无限大，可以多设置几个数据库文件，以免数据库大小不够用引起数据库异常。创建语句：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;//创建表空间
&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLESPACE&lt;/span&gt; STO_Data  
&lt;span class=&quot;kw&quot;&gt;LOGGING&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;DATAFILE&lt;/span&gt; 
&lt;span class=&quot;st&quot;&gt;'D:\DataBase\DbFile\STO_DATA.DBF'&lt;/span&gt;,
&lt;span class=&quot;st&quot;&gt;'D:\DataBase\DbFile\STO_DATA1.DBF'&lt;/span&gt;,  
&lt;span class=&quot;st&quot;&gt;'D:\DataBase\DbFile\STO_DATA2.DBF'&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;SIZE&lt;/span&gt; 512M   
&lt;span class=&quot;kw&quot;&gt;AUTOEXTEND&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt;   
&lt;span class=&quot;kw&quot;&gt;NEXT&lt;/span&gt; 512M &lt;span class=&quot;kw&quot;&gt;MAXSIZE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;unlimited&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;EXTENT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;MANAGEMENT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;LOCAL&lt;/span&gt;;
//创建临时表空间
&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TEMPORARY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLESPACE&lt;/span&gt; STO_Temp  
&lt;span class=&quot;kw&quot;&gt;TEMPFILE&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'D:\DataBase\DbFile\STO_Temp.DBF'&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;SIZE&lt;/span&gt; 512M  
&lt;span class=&quot;kw&quot;&gt;AUTOEXTEND&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;ON&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;NEXT&lt;/span&gt; 512M &lt;span class=&quot;kw&quot;&gt;MAXSIZE&lt;/span&gt; unlimite
&lt;span class=&quot;kw&quot;&gt;EXTENT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;MANAGEMENT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;LOCAL&lt;/span&gt;;  
//创建用户
&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;USER&lt;/span&gt; 用户名 &lt;span class=&quot;kw&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;BY&lt;/span&gt; 用户名密码
&lt;span class=&quot;kw&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLESPACE&lt;/span&gt; STO_Data  
&lt;span class=&quot;kw&quot;&gt;TEMPORARY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;TABLESPACE&lt;/span&gt; STO_Temp  
//用户赋权限  
&lt;span class=&quot;kw&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;connect&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;resource&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;dba&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; 用户名 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;三常见问题&quot;&gt;三、常见问题&lt;/h3&gt;
&lt;h4 id=&quot;存储过程参数&quot;&gt;（1）存储过程参数&lt;/h4&gt;
&lt;p&gt;存储过程的参数命名最好可以按照规则来否则会有问题，例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;procedure&lt;/span&gt; Proc_Test(IN_CompanyName       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;varchar2&lt;/span&gt;, 
                                      OUT_Table        &lt;span class=&quot;kw&quot;&gt;out&lt;/span&gt; sys_refcursor) &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;open&lt;/span&gt; OUT_Table &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; Waybill_Pickup t &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; t.companyname=IN_CompanyName;
  
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt; Proc_Test;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果参数使用的和数据库中的表字段一样会引起失效，例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;procedure&lt;/span&gt; Proc_Test(CompanyName       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;varchar2&lt;/span&gt;, 
                                      OUT_Table        &lt;span class=&quot;kw&quot;&gt;out&lt;/span&gt; sys_refcursor) &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;open&lt;/span&gt; OUT_Table &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; Waybill_Pickup t &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; t.companyname=CompanyName;
  
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt; Proc_Test;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;定期释放temp文件空间&quot;&gt;（2）定期释放Temp文件空间&lt;/h4&gt;
&lt;p&gt;长时间使用会使Temp文件越来越大，而引起某些操作异常。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;tablespace&lt;/span&gt; STO_TEMP &lt;span class=&quot;kw&quot;&gt;shrink&lt;/span&gt; space;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;索引失效&quot;&gt;（3）索引失效&lt;/h4&gt;
&lt;p&gt;Oracle批量插入如果是用Oracle.DataAccess.Client.OracleBulkCopy 类，数据在插入过程中会引起索引失效，如果是业务表就会引起业务查询非常缓慢。但是插入效率很高，如果数据库使用读写分离，或者接口采用读写分离的两个表可以通过此方法进行插入，如果遇到索引失效可用以下语句查看和修复。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;//查看失效索引
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; user_indexes &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; Status=&lt;span class=&quot;st&quot;&gt;'UNUSABLE'&lt;/span&gt;
//重建失效索引
&lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;FOR&lt;/span&gt; cur &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; INDEX_NAME &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; user_indexes &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; Status=&lt;span class=&quot;st&quot;&gt;'UNUSABLE'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;loop&lt;/span&gt;  
     &lt;span class=&quot;kw&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;immediate&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;'alter index '&lt;/span&gt;|| cur.INDEX_NAME||&lt;span class=&quot;st&quot;&gt;' rebuild'&lt;/span&gt; ;
  &lt;span class=&quot;kw&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;LOOP&lt;/span&gt;;  
&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;遇到问题如何排查&quot;&gt;（4）遇到问题如何排查&lt;/h4&gt;
&lt;p&gt;当Oracle遇到内部问题出现异常和挂机后的排查步骤（Oracle服务器）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查找日志D:\app\Administrator\diag\rdbms\sto_database\stodatabase\alert&lt;/li&gt;
&lt;li&gt;查询跟踪文件D:\app\Administrator\diag\rdbms\sto_database\stodatabase\trace&lt;/li&gt;
&lt;li&gt;然后定位问题解决问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7ddfc9750102wjej.html&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当时遇到的问题是：数据库直接Down掉了，连接时报没有监听程序。重启服务器后过一会数据库就挂掉了&lt;br/&gt;检查Oracle日志：&lt;br/&gt;D:\app\Administrator\diag\rdbms\sto_database\stodatabase\alert&lt;br/&gt;查看Log文件，在日志文件中找到错误信息提示：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/375940/201801/375940-20180122101252537-1625210665.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查跟踪文件&lt;br/&gt;D:\app\Administrator\diag\rdbms\sto_database\stodatabase\trace&lt;br/&gt;在跟踪文件中查看错误信息引起的原因：&lt;br/&gt;根据错误查找出引起错误的SQL语句，最后定位到是单条语句超过65535个参数引起，由于.net中使用了DbDataAdapter进行保存数据，他类似于拼接的Sql语句，更改批次提交数解决问题。&lt;/p&gt;
&lt;h2 id=&quot;net相关&quot;&gt;.net相关&lt;/h2&gt;
&lt;h3 id=&quot;一处理传参和long-raw类型&quot;&gt;一、处理传参和LONG RAW类型&lt;/h3&gt;
&lt;p&gt;DbCommand处理Oracle数据库默认参数绑定是按次序且不能查询LONG RAW类型，处理SqlServer数据库不用处理，&lt;br/&gt;所以在初始化DbCommand时需要加入如下代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;(cmd &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; Oracle.DataAccess.Client.OracleCommand).BindByName=true;
(cmd &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; Oracle.DataAccess.Client.OracleCommand).InitialLONGFetchSize = -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;二批量插入&quot;&gt;二、批量插入&lt;/h3&gt;
&lt;h4 id=&quot;oraclebulkcopy&quot;&gt;（1）OracleBulkCopy&lt;/h4&gt;
&lt;p&gt;OracleBulkCopy在Oracle.DataAccess.DLL中，速率很快，但不进行主键和唯一键检查，经常会将唯一索引弄坏，并且在插入过程中普通索引也会失效。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 批量插入数据库
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;datatable&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public string OracleBulkInsert(DataTable datatable)
{
    OracleBulkCopy bulkCopy = new OracleBulkCopy(_connStr, OracleBulkCopyOptions.UseInternalTransaction);
    try
    {
        bulkCopy.DestinationTableName = datatable.TableName;
        bulkCopy.BulkCopyTimeout = 600000;
        bulkCopy.BatchSize = 50000;
        if (datatable != null &amp;amp;&amp;amp; datatable.Rows.Count != 0)
            bulkCopy.WriteToServer(datatable);
        return &quot;&quot;;
    }
    catch (Exception ex)
    {
        throw ex;
    }
    finally
    {
        if (bulkCopy != null)
            bulkCopy.Close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DataTable在插入时应注意字段类型和顺序，可以用以下代码获得表结构&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 根据表名获取Table结构
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;tableName&quot;&amp;gt;表名&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public  DataTable InitStructureByTable(string tableName)
{
    DataTable dtColums = helper.GetDataSet(&quot;select column_name,data_type from user_tab_columns where table_name='&quot; + tableName.ToUpper() + &quot;' order by column_id&quot;, null).Tables[0];
    DataTable dtNew = new DataTable();
    dtNew.TableName = tableName;
    //匹配列数
    for (int j = 0; j &amp;lt; dtColums.Rows.Count; j++)
    {
        switch (dtColums.Rows[j][1].ToString().ToUpper())
        {
            case &quot;DATE&quot;:
                dtNew.Columns.Add(new DataColumn(dtColums.Rows[j][0].ToString(), typeof(DateTime)));
                break;
            case &quot;NUMBER&quot;:
                dtNew.Columns.Add(new DataColumn(dtColums.Rows[j][0].ToString(), typeof(double)));
                break;
            default:
                dtNew.Columns.Add(new DataColumn(dtColums.Rows[j][0].ToString(), typeof(string)));
                break;
        }              
    }
    return dtNew;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dbdataadapter批量插入&quot;&gt;（2）DbDataAdapter批量插入&lt;/h4&gt;
&lt;p&gt;这种插入方式要比OracleBulkCopy要慢，相当于拼接了带参数的插入语句插入，注意UpdateBatchSize数值不要过大，否则可能由于单句Sql语句参数超过65535引起数据库崩溃。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 批量插入数据库
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;datatable&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public  string BulkInsertCopy(DataTable datatable)
{
    DbDataAdapter adapter = _factory.CreateDataAdapter();        
    DbCommand cmd = _factory.CreateCommand();
    DbCommandBuilder cb = _factory.CreateCommandBuilder();      
    try
    {
        adapter.UpdateBatchSize = 200;
        using (DbConnection conn = _factory.CreateConnection())
        {
            conn.ConnectionString = ConnectionString;                
            conn.Open();
            cmd.Connection = conn;
            //cmd.Transaction = conn.BeginTransaction();          
            cb.DataAdapter = adapter;                 
            adapter.SelectCommand = cmd;
            adapter.SelectCommand.CommandText = &quot;select * from &quot; + datatable.TableName;
            adapter.FillSchema(datatable, SchemaType.Source);
            adapter.Update(datatable);
            //cmd.Transaction.Commit();           
        }
        return &quot;&quot;;
    }
    catch (Exception ex)
    {
        //cmd.Transaction.Rollback();
        return ex.Message;
    }
    finally
    {
        cmd.Dispose();
        cb.Dispose();
        adapter.Dispose();
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 22 Jan 2018 06:38:00 +0000</pubDate>
<dc:creator>歌神的卖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaoleba/p/8328928.html</dc:identifier>
</item>
<item>
<title>Redis进阶实践之四Redis的基本数据类型 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8328669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8328669.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    今天正式开始了Redis的学习，如果要想学好Redis，必须先学好Redis的数据类型。Redis为什么会比以前的Memchaed等内存缓存软件使用的更频繁，适用范围更广呢？就是因为Redis使用起来更方便，之所以方便，是因为Redis支持的数据类型比以前的Memchaed缓存支持数据类型的更多了。Redis有五种基本数据类型，String(字符串)，Hash(哈希),List(链表),Set(集合),ZSet(有序集合)，在这五种基本的数据类型中，String类型是最基础的。为什么说String类型是最基础的，就拿List为例来说，它是以列表的形式组织字符串数据，Set类型是以集合类型来组织字符串数据的。今天就让我们比较全面的来认识一下redis的基本数据类型吧。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、NoSQL的介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，意为反Sql运动，提倡运用非关系型的数据存储，随着Web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经力不从心，暴露了很多难以克服的问题，而非关系型数据库则由于其本身的特点得到了迅速发展。&lt;/p&gt;&lt;p&gt;    NoSQL是以key-value形式存储，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如：遵循Sql标准，ACID属性、表结构特性等等。分关系型数据库的特点如下：非关系型的、分布式的、开源的、水平可以扩展的。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;NoSQL数据库的四大分类&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    1、键值(Key-Value)存储数据库：该类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。例如：Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB.&lt;/p&gt;&lt;p&gt;    2、列存储数据库：该库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。如：Cassandra, HBase, Riak.&lt;/p&gt;&lt;p&gt;   3、文档型数据库：该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值，而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, MongoDb. 国内（SequoiaDB，已经开源）。&lt;/p&gt;&lt;p&gt;   4、图形(Graph)数据库：图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;NoSQL使用场景：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;    1、对数据高并发的读写，可以使用NoSQL类型数据库。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;    2、对海量数据的高效率的存储和访问，可以使用NoSQL类型数据库。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;    3、对数据的高可扩展性和高可用性要求比较高的也可以使用NoSQL类型数据库。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、Redis的介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      redis是一个key-value存储系统。它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。为了可靠性，redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;/p&gt;&lt;p&gt;    redis的优点如下：&lt;/p&gt;&lt;p&gt;    (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)&lt;/p&gt;&lt;p&gt;    (2) 支持丰富数据类型，支持string，list，set，sorted set，hash&lt;/p&gt;&lt;p&gt;    (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行&lt;/p&gt;&lt;p&gt;    (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除&lt;/p&gt;&lt;p&gt;    有了这些优点，才会有这么多的人使用它。&lt;br/&gt;   &lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、Redis的数据类型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      redis的数据类型是学好redis的基础，所以要想很好的掌握redis，必须把它的数据类型掌握好，并且熟练记忆各个类型的基本操作。这里面针对每种数据类型的操作不是全部都涉及到，只是会涉及到一些常用的命令，如果大家想观看全部的命令，可以去官网上查看，地址如下：https://redis.io/commands。还有一点需要说明一下，有些例子，可能几个命令都是相关联的，比如说第一个命令执行了增加操作，我在介绍第二个命令的时候有时候会使用第一个命令的结果。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;   1、String字符串类型使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         1.1、redis一共分为五种基本数据类型：String（字符串）,Hash（哈希）、List（链表），Set（集合），ZSet（有序集合）&lt;/p&gt;&lt;p&gt;         1.2、String类型是包含很多种类型的特殊类型，并且是二进制安全的。比如：序列化的对象可以以String类型进行存储，也可以把一张图片的二进制数据以String类型进行存储，当然也可以存储简单的字符串数据，也可以以String类型存储数字。字符串最大的容量是512M，也就是2的32次方-1。&lt;/p&gt;&lt;p&gt;         1.3、常用命令如下：&lt;/p&gt;&lt;p&gt;            1.3.1】、语法：set key value [EX seconds] [PX milliseconds] [NX|XX]   设置成功OK,如果针对同一个key设置，会覆盖原来的值。&lt;/p&gt;&lt;p&gt;               1】、192.168.127.128:6379&amp;gt;set name HuangFeiHong 可以针对同一个key重复设置值&lt;br/&gt;                       OK&lt;/p&gt;&lt;p&gt;               2】、EX:（expired过期时间，单位秒）,设置成功返回OK。查看过期时间ttl key,组合命令：setex&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; age &lt;span&gt;18&lt;/span&gt; ex &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;ttl age  返回0过期，-&lt;span&gt;2已经删除该标志
           (integer)&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;            3】、PX:（过期时间，单位毫秒），设置成功返回OK，查看过期时间pttl&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; sex nan px &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
          OK

          &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;pttl sex 返回0为过期，-&lt;span&gt;2已经删除标志
          (integer)&lt;/span&gt;&lt;span&gt;1125&lt;/span&gt;

          &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;pttl sex
          (integer)&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;            4】、NX(not exists)：如果指定的Key不存在，就设置该值,组合命令：sexnx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; name FangShiYu nx
         (nil)

          &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; name1 FangShiYu nx
         OK

         设置失败，因为为name 的key 已经存在了，设置成功返回OK，设置失败返回nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;            5】、XX:如果key存在就设置该值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; address hebeisheng xx(该值不存在)
         (nil)

         &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; address hebeisheng xx(该值存在在)
         OK

         设置失败，因为key不存在，返回nil，存在才可以设置，成功返回OK。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.2】、语法：get key，获取指定key的值，有值返回值，无值返回nil。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HuangFeiHong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.3】、语法：del key [key...]：删除多个key的值，删除成功返回删除的个数，删除失败返回0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;del name
       （integer）&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.4】、语法：keys Pattern：查看有什么key&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
             &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
             &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.5】、语法：dbsize： 可以查看key的数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;dbsize
             (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.6】、语法：setrange key offset value：从第几位开始替换成我们想要得值，第几位就是offset的值。替换字符串，最后返回整个字符串的长度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; email &lt;span&gt;1234567890&lt;/span&gt;&lt;span&gt;@com
             OK

             &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;setrange email &lt;span&gt;10&lt;/span&gt;&lt;span&gt; #
             (integer)&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.7】、语法：mset key value [key value ...]，设置成功返回OK，重复设置会覆盖&lt;br/&gt;     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;mset name zhangsan sex nan address hebei
              OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        1.3.8】、语法：mget key [key ...],有值得返回值，无值的返回nil&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
              &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;mget name sex address
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZhangSan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               (nil)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        1.3.9】、语法：msetnx key value [key value ...]设置成功会返回成功的个数，失败返回0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;msetnx school daxue postnum &lt;span&gt;1234567&lt;/span&gt;&lt;span&gt;
              (integer) &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; 或者 （integer） &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.10】、语法：getset key value：支持并发，是原子操作的，先返回该key的原始值，然后用新值替换原来的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
              &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

              &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;getset name lisi
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

              &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.11】、语法：incr key，该key的值必须是数值类型字符串表示，该函数对key的值加一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
             OK

             &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

             &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;incr age
             (integer)&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.12】、语法：decr key,该key的值必须是数值型字符串表示，该函数对key的值减一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
            OK

            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;decr age
            (integer)&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.13】、语法：incrby key increment，该key的值必须是数值型字符串表示，该函数对key的值增加指定的数值（正数情况）或者减少指定数值（负数情况）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
            OK

            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;incrby age &lt;span&gt;3&lt;/span&gt;(增加3)-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;（减少3）
            (integer)&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.14】、语法：decrby key decrement，该key的值必须是数值型字符串表示，该函数对key的值增加指定的数值（负数情况）或者减少指定数值（正数情况）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
            OK

            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;decrby age &lt;span&gt;3&lt;/span&gt;(减少3)-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;（增加3）
            (integer)&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.15】、语法：incrbyfloat key increment，该key的值必须是数值型字符串表示，如果想要给key的值增加或者减少有小数的情况，可以使用该命令，正小数（增加），负小数（减少）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
            OK

            &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;decrby age &lt;span&gt;3.5&lt;/span&gt;(减少3)-&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;（增加3）
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;21.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.16】、语法：append key value，向指定的key追加内容，不会覆盖原始的内容。返回追加后字符串的总长度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;append name zhangsan（该key不存在会有set的效果，如果存在就追加）
           （integer）&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.17】、语法：strlen key，获取指定key值的长度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;strlen name
            (integer)&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       1.3.18】、语法：type key，返回当前key的值的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;type age
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        以上就是Redis的String类型的基本操作，但是这里没有包含所有的命令，只是一些经常用到的命令，string类型是redis基本数据类型中最基本，最重要的类型，其他的类型都是基于此的，所以该命令大家要熟练使用。&lt;/p&gt;&lt;p&gt; &lt;br/&gt;&lt;strong&gt;   2、Hash哈希类型的使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       2.1、redis一共分为五种基本数据类型：String（字符串）,Hash（哈希）、List（链表），Set（集合），ZSet（有序集合）&lt;/p&gt;&lt;p&gt;      2.2、Hash类型是String类型的field和value的映射表，或者说是一个string 集合，它特别适合存储对象，相比较而言，将一个对象类型存储在Hash类型里比存储在string类型占用的内存空间更少，并方便对象的存取。Hash类型的field字段必须是字符串类型，不能是其他数据类型，换句话说Hash类型不能嵌套其他数据类型。一个Hash类型可以包含的key（其实是field）是2的32次方减去1个，也就是说40多亿个key（这里的key也是指field）都可以被支持，所以说Hash可以存储很大的数据量。&lt;/p&gt;&lt;p&gt;      2.3、常用命令如下：&lt;/p&gt;&lt;p&gt;        2.3.1】、语法：hset key field value，向键值为key的里面增加field和value的映射数据。增加成功返回1，如果重复增加，会覆盖，但是返回值是0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hset key1 name zhangsan
               (integer)

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;hset key1 age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;hset key1 age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
               (integer)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;       
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.2】、语法：hget key field，根据指定的key和field获取其对应的值。如果有值就返回其值，如果没有返回值为nil。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hget key1 name
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hget key1 address (没有该field值)
               （nil）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.3】、语法：hmset key field value [field value ...]，可以一次设置多个值。设置成功返回OK。如果重复设置会覆盖原来的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;hmset key name zhangsan sex nan age &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
               OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.4】、语法：hmget key field [field ...]，可以一次性获取指定key的多个field的值，有值的field会返回其值，没有值的返回nil。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hmget key name sex age address(地址属性没定义，会返回nil)
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
               (nil)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        2.3.5】、语法：hsetnx key field value，如果指定key的field的值不存在，则增加该值。增加成功返回1，增加失败返回0.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hsetnx key name li
               (integer)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hsetnx key name1 li(该key的field的值不存在，则增加成功)
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.6】、语法：hincrby key field increment，该value的值必须是数字类型的字符串，否则有错。让指定key的指定field的值增加（正值）或者减少（负值）多少。(ERR hash value is not an integer)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;hincrby key age &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
               (integer)&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;hincrby key age -&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
               (integer)&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.7】、语法：hincrbyfloat key field increment,该value的值必须是数字类型的字符串，否则有错。让指定key的指定field的值增加（正值）或者减少（负值）多少小数。(ERR hash value is not an integer)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;hincrbyfloat key age &lt;span&gt;0.54&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20.54&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.8】、语法：hexists key field，判断指定key的field字段是否有值，有值返回1，无值返回0.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hexists key age
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hexists key age1
               (integer)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        2.3.9】、语法：hlen key，判断指定key下有几个field。有值返回就是几个，没有纸就返回0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hlen key
               (integer)&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hlen key1
               (integer)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       2.3.10】、语法：hdel key field，删除指定key的field键值对，删除成功返回1，删除失败返回0.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hdel key name1
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hdel key name1
               (integer)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       2.3.11】、语法：hkeys key，列出指定key的field字段值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hkeys key
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       2.3.12】、语法：hvals key，列出指定key的field的所对应的值，也就是value。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hvals key
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20.54&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       2.3.13】、语法：hgetall key，列出指定key的field和value的映射值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;hgetall key
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20.54&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;   3、List列表类型的使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     3.1、redis一共分为五种基本数据类型：String（字符串）,Hash（哈希）、List（链表），Set（集合），ZSet（有序集合）&lt;/p&gt;&lt;p&gt;     3.2、List类型是一个链表结构的集合，并且是有序的集合，其值是可以重复的，其主要功能操作有push，pop、获取元素等。更详细的说，List类型是一个双端链表结构，我们可以通过相关操作在集合的头部和尾部增加或者删除元素。List类型设计的非常巧妙，既可以做【栈-先进后出】使用，也可以做【队列-先进先出】使用，能满足绝大多数的需求。List类型有点类似数组的概念，所以具有下标，可以针对指定下标进行操作，比如替换。&lt;/p&gt;&lt;p&gt;     3.3、常用命令如下：&lt;/p&gt;&lt;p&gt;        3.3.1】、语法：lpush key value [value ...] 向指定列表key从左面增加元素。增加成功，返回当前列表元素的个数。这个显示的方式是堆栈的形式，先进后出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;lpush list1 hello
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;lpush list1 world
               (integer)&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;lpush list1 world（可以重复增加）
               (integer)&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.2】、语法：rpush key value [value ...]向指定的列表key从右面增加元素。增加成功，返回当前列表元素的个数。这个显示的方式是队列的形式，先进先出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
              &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rpush list2 hello
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rpush list2 world
               (integer)&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;rpush list2 !!!&lt;span&gt;
               (integer)&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;

               先进先出的显示方式：
               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list1 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.3】、语法：linsert key BEFORE|AFTER pivot value，向指定列表key在指定元素【前|后】插入元素，成功返回列表当前元素的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;linsert list2 before world my
               (integer)&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list2 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.4】、语法：lrange key start stop，将制定列表key的元素按指定范围显示出来。 因为list是双端列表，如果计数是从左到右开始，那就是从0开始，依次是1,2,3等，如果计数是从右到左开始，那就是从-1开始，依次为-2，-3等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list1 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 这个意思就是从左边第一位到右面最后一位，全部显示
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.5】、语法：lset key index（列表下标） value，将指定下标的元素替换掉，替换成功返回OK,可以重复操作，会替换以前的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lset list2 &lt;span&gt;3&lt;/span&gt; !!，将hello my world !!!&lt;span&gt;里面的三个！替换成2个！
               OK

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list2 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;             &lt;br/&gt;        3.3.6】、语法：lrem key count value，删除和指定元素想相等的元素并返回删除的个数，删除正确返回个数，删除错误返回0。count，删除个数，如果count是正数，从列表表头开始搜索，如果count是负数，从列表表尾开始搜索，删除的个数就是count的绝对值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               当前值：
               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list2 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrem list2 &lt;span&gt;1&lt;/span&gt;&lt;span&gt; my
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list2 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrem list2 &lt;span&gt;1&lt;/span&gt;&lt;span&gt; my（已经没有my这个值了）
               (integer)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.7】、语法：ltrim，保留指定key的索引值范围内的数据，其他数据删除，开始从0开始。修剪成功返回OK,可以重复执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               当前值：
               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list2 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;ltrim list2 &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list2 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.8】、语法：lpop key，从list的头部删除元素，并返回删除元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rpush list3 a b c d e f
               (integer)&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;lpop list3
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;        3.3.9】、语法：rpop key，从list的尾部删除元素，并返回删除元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rpop list3
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       3.3.10】、语法：rpoplpush，第一步从指定list列表的尾部删除元素，第二步，从指定list列表头部加入元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rpoplpush list3 list4
               &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lrange list4 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       3.3.11】、语法：lindex key index，返回指定list列表中index为止的元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;lindex list2 &lt;span&gt;0&lt;/span&gt;
               &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       3.3.12】、语法：llen key，返回指定key列表的元素的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;llen list2
               (integer)&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;      这里，我要说明一下，这里面的所有代码，上下是有关系的，这个大家要知道一下，否则不知道为什么会有这样的结果。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;   4、Set集合类型的使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     4.1、redis一共分为五种基本数据类型：String（字符串）,Hash（哈希）、List（链表），Set（集合），ZSet（有序集合）&lt;/p&gt;&lt;p&gt;     4.2、set集合是string类型的无需集合，集合里面的元素不能重复，或者说必须是唯一的。set内部是通过Hashtable来实现的，并且这个Hashtable的value是没有值的，既然是集合，因此，我们可以对集合实施交集（Inter--InterStore）、并集（Union--UnionStore）和差集（Diff--DiffStore）的操作。操作复杂度都是：O(1)&lt;/p&gt;&lt;p&gt;     4.3、常用命令如下：&lt;/p&gt;&lt;p&gt;       4.3.1】、语法：sadd key member [member ...]：可以向名称为key的set集合中添加元素，一次可以添加多个，也可以添加一个，以空格为分隔符，并且增加的元素不能有重复。成功返回添加的元素的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sadd set1 aaa bbb ccc ddd eee
               (integer)&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sadd set1 eee
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.2】、语法：smembers key：我们可以通过该方法查看名称为key集合的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;smembers set1
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;4&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;5&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;6&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.3】、语法：srem key member [member ...]：删除set集合元素，可以删除一个，也可以删除多个。成功删除返回删除个数，失败返回0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;srem set1 aaa bbb ccc ddd eee fff
               (integer)&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.4】、语法：spop key [count]：随机返回删除的key，可以返回【count】个，返回的元素会被删除。&lt;br/&gt;               &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：aaa bbb ccc ddd eee fff
               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;spop set1 &lt;span&gt;3&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.5】、语法：sinter key [key ...]：取两个或者多个集合的交集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sinter set1 set2
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.6】、语法：sinterstore destination key [key ...]方法：取两个或者多个集合的交集并存到指定集合里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sinterstore setinter set1 set2
               （integer）&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;smembers setinter
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;               
               &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.7】、语法：sunion key [key ...]：取两个或者多个集合的并集。如果有重复元素，会去掉重复元素然后在显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sunion set1 set2
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;4&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;5&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.8】、语法：sunionstore destination key [key ...]：取两个或者多个集合的并集并存储到指定集合里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sunionstore setunion set1 set2
               （integer）&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;


               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;smembers setunion
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;4&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;5&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.9】、语法：sdiff key [key ...]：取两个或者多个集合不同的元素，第一个参数集合为参考对象，由于参考对象不同，结果可能也不同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sdiff set1 set2
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.10】、语法：sdiffstore destination key [key ...]：取两个或者多个集合不同的元素，并把结果存储到指定集合里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sdiffstore setdiff set1 set2
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;smembers setdiff
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.11】、语法：smove source destination member：把一个元素member从一个set集合移动到另一个set集合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd
               set2 bbb ccc ddd eee

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;smove set1 set2 aaa
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;smembers set2
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;4&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;5&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;移动过来的&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.12】、语法：scard key：查看集合里元素的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;scard set1
               (integer)&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.13】、语法：sismember key member：判断某个元素是否在指定的集合里面，存在返回1，不存在返回0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;sismember set1 aaa
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       4.3.14】、语法：srandmember key [count]：随机返回一个或者几个元素，不会删除元素，默认返回一个元素。每次执行都会返回不同的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 aaa bbb ccc ddd

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;srandmember set1 &lt;span&gt;3&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;   5、ZSet有序集合类型的使用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     5.1、redis一共分为五种基本数据类型：String（字符串）,Hash（哈希）、List（链表），Set（集合），ZSet（有序集合）&lt;/p&gt;&lt;p&gt;     5.2、ZSet数据类型，是有序的集合类型，集合里面的元素必须保证唯一，不会出现重复的元素。无论以什么方式访问有序集合都很快，因为它内部是通过哈希表和跳跃表来实现的。默认排序是由小到大。&lt;/p&gt;&lt;p&gt;     5.3、常用命令如下：&lt;/p&gt;&lt;p&gt;       5.3.1】、语法：zadd key [NX|XX] [CH] [INCR] score member [score member ...]：向有序集合中添加一个h或者多个元素，该元素如果存在，则更新顺序。如果在重复插入的时候，会根据顺序属性更新。&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
               &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zadd set1 &lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc
               （integer）&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;

               如果想要修改某元素的分数，例如把aaa的分数改成10，可以如下：

               zadd set1 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt; aaa

               当前返回值为0，但是分数已经成功修改。默认返回值是增加到有序集合里面元素的个数。

              nx参数：如果该元素不存在则增加该元素

              xx参数：如果该元素存在则修改该元素

              ch参数:可以让方法返回值是更改分数的元素的个数

              incr参数:可以对指定元素的分数进行增加或者减少指定数值，正数增加，负数减少

              zadd set1 [nx&lt;/span&gt;|xx|ch|incr] &lt;span&gt;10&lt;/span&gt; aaa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.2】、语法：zrange key start stop [WITHSCORES]：查看有序集合的元素，分数可以是选项，可以显示，也可以不显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zrange set1 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; [withscores]
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;4&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;5&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;6&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.3】、语法：zrevrange key start stop [WITHSCORES]方法：按分数从大到小的排序集合元素，默认是小到大排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zrevrange set1 &lt;span&gt;0&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt; [withscores]
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;4&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;5&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;6&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.4】、语法：zrem key member [member ...]：删除名称为key的zset中的元素member，可以删除一个，也可以删除多个。成功返回删除个数，失败返回0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;zrem set1 aaa bbb
               (integer)&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.5】、语法：zincrby key increment member：以指定值去自动递增或者递减少指定元素的分数，用法和之前的incryby类似&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zincrby set1 &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ccc
               “&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.6】、语法：zrangebyscore key min max [WITHSCORES]：查找分数在指定区间范围的元素，返回找到的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zrangebyscore set1 &lt;span&gt;7&lt;/span&gt;（分数最小值） &lt;span&gt;10&lt;/span&gt;&lt;span&gt;（分数最大值） withscores
               &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
               &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.7】、语法：zremrangebyrank key start stop：根据索引值删除指定的元素，返回删除的个数，没有数据返回0.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zremrangebyrank set1 &lt;span&gt;0&lt;/span&gt;(索引值) &lt;span&gt;1&lt;/span&gt;&lt;span&gt;(索引值)
               (integer)&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.8】、语法：zremrangebyscore key min max：根据指定的分数删除元素，返回删除的个数，没有数据返回0.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zremrangebysocre set1 &lt;span&gt;5&lt;/span&gt;(分数最小值) &lt;span&gt;6&lt;/span&gt;&lt;span&gt;（分数最大值）
               (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.9】、语法：zrank key member：（从小到大）返回排序索引从小到大排序的某有序集合里面某元素的索引，无值返回nil，索引从0开始计数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;zrank set1 aaa
               （integer）&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.9】、语法：zrevrank key member：返回排序索引从大到小排序的索引值，也就是说最大的分数的索引是0（降序排序之后再找索引）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;zrevrank set1 ccc
               （integer）&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.10】、语法：zcard key：返回集合里所有元素的个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;zcard set1
               (integer)&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;       5.3.11】、语法：zcount key min max：返回集合中score在给定区间中的数量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;               原始值：
               set1 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt; aaa &lt;span&gt;5&lt;/span&gt; bbb &lt;span&gt;10&lt;/span&gt;&lt;span&gt; ccc

               &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;zcount set1 &lt;span&gt;7&lt;/span&gt;(分数最小值) &lt;span&gt;10&lt;/span&gt;&lt;span&gt;（分数最大值）
               (integer)&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      redis的数据类型今天就写到这里了，学了更多的东西在更新吧。每一步走的都挺艰难的，革命还没成功，我辈还需努力啊。现在对redis的认识和以前不一样了，整体轮廓有了。下一步要掌握集群的高可用性和可扩展方面的知识点了，继续上路吧。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Jan 2018 05:54:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8328669.html</dc:identifier>
</item>
<item>
<title>一步一步从原理跟我学邮件收取及发送 3.telnet命令行发一封信 - clq</title>
<link>http://www.cnblogs.com/-clq/p/8328568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-clq/p/8328568.html</guid>
<description>[unable to retrieve full-text content]首先要感谢博客园管理员的及时回复,本系列的第二篇文章得以恢复到首页,这是对作者的莫大鼓励.说实在的本来我真的挺受打击的.好在管理员说只是排版上有些问题,要用代码块修饰下相关的信息.说来惭愧因为常年编码已经习惯了用纯文本和空白行等处理文章,确实谈不上对文章排版,后面我会多学习应用排版功能. 经过前面两</description>
<pubDate>Mon, 22 Jan 2018 05:28:00 +0000</pubDate>
<dc:creator>clq</dc:creator>
<dc:identifier>http://www.cnblogs.com/-clq/p/8328568.html</dc:identifier>
</item>
<item>
<title>C#中的多线程超时处理实践 - 阿子</title>
<link>http://www.cnblogs.com/yayazi/p/8328468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yayazi/p/8328468.html</guid>
<description>[unable to retrieve full-text content]最近我正在处理C＃中关于timeout行为的一些bug。解决方案非常有意思，所以我在这里分享给广大博友们。 我要处理的是下面这些情况： - 我们做了一个应用程序，程序中有这么一个模块，它的功能向用户显示一个消息对话框，15秒后再自动关闭该对话框。但是，如果用户手动关闭对话框，则在timeout时...</description>
<pubDate>Mon, 22 Jan 2018 04:53:00 +0000</pubDate>
<dc:creator>阿子</dc:creator>
<dc:identifier>http://www.cnblogs.com/yayazi/p/8328468.html</dc:identifier>
</item>
<item>
<title>镜像队列 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/8328472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/8328472.html</guid>
<description>&lt;p&gt;&lt;span&gt;默认情况下，RabbitMQ集群中的队列都是位于单个结点上的。这一点和exchanges、bindings是不同的，因为这些是位于所有结点之上的。可以在多个结点之间将队列镜像化。每一个被镜像化的队列由一个master和一个或多个镜像组成，当master挂掉以后，最老的镜像将会成为新的master。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发布到队列上的消息会被复制到所有镜像上。消费者都连接到master上。在master上被确认的消息会从镜像中删除。队列镜像提供了可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;all participating nodes each do all the work（每个结点都要做所有的工作，也就是说，每个操作所有结点都要做一遍）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种解决方案需要一个RabbitMQ集群。不推荐在WAN（广域网）上建立集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在分布式系统中有很多名词用来标识第一和第二副本。通常，典型的做法是用“master”表示队列的主副本，用“mirror”表示第二副本。然而，你会发现也有用“slave”来表示第二副本的。这是因为RabbitMQ CLI工具的历史原因造成的。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;docHeading&quot;&gt;How Mirroring is Configured&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;镜像参数用策略来配置。一个策略通过正则表达式按名称匹配一个或多个队列。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;docHeading&quot;&gt;Queue Arguments that Control Mirroring&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;策略可以在任何时候改变。创建一个非镜像的队列，然后在随后的某个时间点将它镜像化，这是有效的（反之亦然）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个非镜像队列和一个镜像队列是不同的，前者没有额外的镜像基础设施，并且可能提供更高的输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了让队列变成镜像，你需要创建一个策略来匹配它们，并且设置策略key值ha-mode和（可选的）ha-params&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面表格列出了这些选项的具体含义：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;ha-mode&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;ha-params&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;Result&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;all&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;集群中所有结点都被做成镜像&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;span&gt;exactly&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;count&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;集群中队列实例的数量。count值为1意味着只有master，没有mirrors，这种情况下如果master不可用，那么队列将不可用。count值为2意味着有一个master和一个mirror，此时，如果master不可用，则mirror会自动成为master。NumberOfQueueMirrors = NumberOfNodes - 1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;nodes&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;em&gt;node names&lt;/em&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;根据指定结点的名称来镜像&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;h2&gt;&lt;span&gt;To How Many Nodes to Mirror?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;镜像到所有队列是最保守的情况，大多数情况下你不必这么做。对于超过3结点的集群来说推荐镜像到结点的法定人数。比如：在3个结点的集群中选2个结点，在5个结点的集群中选3个结点。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;queue-master-location&quot;&gt;Queue Master Location&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所有队列的操作都会首先经过master，然后再复制到mirrors。保证消息的先进先出非常有必要。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;docHeading&quot;&gt;Mirrored Queue Implementation and Semantics&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;每个镜像队列都有一个master和一个或多个mirrors，它们都分布在不同的节点上。mirrors应用发生在master上的操作，并且以和master上相同的顺序应用这些操作，因此维护它们之间有相同的状态。除了发布以为的其它操作都到master，master广播这个操作的影响给mirrors。因此，客户端从一个镜像队列那里消费实际上是从master那里消费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果master失败的话，运行得最久的那个mirror会成为master，因为运行得最久的那个最有可能和master是完全同步的。如果没有mirror和master是同步的，那么那些只存在于master的消息将会丢失。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于镜像队列，我的理解是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、首先，镜像队列是建立在集群基础之上的。它产生的背景是，队列位于单个结点上的，万一某个结点不可用，则整个集群变得不可用。镜像队列的出现就是要保证即使某个结点失败了，不影响，依然可以提供服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、通过策略决定集群中的哪些结点被镜像化，也就是说，并不是集群中的所有结点都会被做成镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、客户端向被镜像化的队列中发布消息以后，消息会被复制到其它镜像上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、每个镜像队列由一个master和多个slave组成。slave失败了不要紧。master失败了会自动有slave成为新的master。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、一般选取集群中结点个数的法定人数个结点做一个镜像队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、我觉得，镜像队列是凌驾于被做成镜像的那些队列之上的&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;参考 http://www.rabbitmq.com/ha.html&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 22 Jan 2018 04:51:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/8328472.html</dc:identifier>
</item>
<item>
<title>Mysql隔离级别，锁与MVCC - jieqing</title>
<link>http://www.cnblogs.com/jieqing/p/8328074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jieqing/p/8328074.html</guid>
<description>&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;：事务，ACID，隔离级别，MVCC，共享锁，排它锁&lt;/p&gt;
&lt;p&gt;阅读本文前请先阅读http://hedengcheng.com/?p=771 &lt;a href=&quot;http://www.hollischuang.com/archives/943&quot; class=&quot;uri&quot;&gt;http://www.hollischuang.com/archives/943&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文意在弄清楚这些概念间的关系及其作用。弄清Mysql在开启事务的情况下，每条sql执行时的加锁操作和MVCC版本控制。为使讨论简单，本文忽略了GAP锁（间隙锁、范围锁）。&lt;/p&gt;
&lt;p&gt;我们经常所高并发，高可用。就是从&lt;code&gt;质&lt;/code&gt;和&lt;code&gt;量&lt;/code&gt;来评估，任何事物都可以从这两个角度来分析。在Mysql数据库中，事务就是用来保证&lt;code&gt;质&lt;/code&gt;的，MVCC就是用来保证&lt;code&gt;量&lt;/code&gt;的。&lt;/p&gt;

&lt;p&gt;我们使用事务来保证每一条SQL语句的结果执行符合我们的预期。我们说事务必须具备ACID特性。ACID中的三者：原子性、一致性和持久性其实描述的都差不多，保证SQL执行结果的可靠性。而隔离性就比较复杂了，隔离性描述的是在并发场景下数据库的表现，但并发量并不是固定的，而不同的业务可能有不同的需求，为了使数据库能适应不同的并发场景，所以伟大的人们又定义了四种隔离级别：Read Uncommited，Read Committed (RC)，Repeatable Read (RR)，Serializable。随着数据库隔离级别的提高，数据的并发能力也有所下降。&lt;/p&gt;

&lt;p&gt;标准隔离级别下数据库会怎么表现可参考http://www.hollischuang.com/archives/943，我们这里只讨论&lt;code&gt;共享锁&lt;/code&gt;和&lt;code&gt;排它锁&lt;/code&gt;这两概念，读加共享锁，写加排它锁：&lt;/p&gt;
&lt;p&gt;在RC隔离级别下，修改数据会加排它锁，事务结束释放，其他事务不许读，解决&lt;code&gt;脏读&lt;/code&gt;问题。&lt;strong&gt;（共享锁当场释放）&lt;/strong&gt;&lt;br/&gt;在RR隔离级别下，读数据加共享锁，事务结束释放，其他事务不许修改，解决&lt;code&gt;不可重复读&lt;/code&gt;。&lt;strong&gt;（共享锁事务结束释放）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上都把操作串行化了。而Mysql对其进行了优化，一个事务读时其他事务不能写，一个事务写时其他事务不能读？我不这么干照样能解决脏读和不可重复读问题。MVCC出现了。（这也使得问题变得越来越复杂，而不一样的地方也开始出现在RR隔离级别下，碰巧Mysql的默认隔离级别就是RR）&lt;/p&gt;

&lt;p&gt;MVCC即&lt;code&gt;多版本并发控制&lt;/code&gt;，使用了双版本号来解决数据的隔离问题。（“create”一个版本号，“delete”一个版本号，修改操作拆分为“delete”和“create”）每个事务在开始对每张表增删改查操作时都会生成一个版本号，每个事务只能查到“create”小于本版本号和“delete”大于本版本号的数据。这样，增删查操作就完全可以并发进行了，只有修改操作是一定要排队的。这样，就算没有共享锁也解决了不可重复读问题，因为其他事务修改后，数据的版本号比我大，我不会读到。&lt;/p&gt;

&lt;p&gt;引入MVCC之后，看似很美好。然而大家有没有想过两个事务先后对一条数据做更新操作，然后两个事务再读取那条数据，分别读到什么？哈哈，这根本是不可能出现的，因为修改操作是串行的，另一个事务必须先commit本事务才能修改。好，换个问题，两个事务先后对一条数据做+1操作，另一个事务提交后，本事务再+1，再读取那条数据，本事务是读取到+1还是+2的结果？如果读取到+2，那不是破坏了隔离性，读到了其他事务提交的数据么？&lt;/p&gt;
&lt;p&gt;然而事实确实是这样，其他事务已经提交，本事务也已修改过那条数据了，之后当然要读到+2才行。虽然本来是0，本事务明明只加了1，可读取后却变成2了，有点不适应。确实，在标准的RR隔离级别下，因为操作都是串行的，本事务读取一行数据后，其他事务就不能修改这条数据了，这条数据永远只有本事务在操作，所以严格满足隔离性。但是Mysql的RR增强了读与写的并发，只有当两个事务同时修改一条数据需要串行，其他所有操作都可以并行。所以造成了这种结果，好像出现了&lt;code&gt;不可重复读&lt;/code&gt;。但是这种不可重复读实际上是符合我们的直观感受的，在本事务对数据修改后，当然要读取到最新的数据。&lt;/p&gt;
&lt;p&gt;要对其过程进行分析的话：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据create版本号为0&lt;/li&gt;
&lt;li&gt;事务1版本号为1，读取数据value=0&lt;/li&gt;
&lt;li&gt;事务2版本号为2，修改数据value+1=1，原数据delete版本号为2，新数据create版本号更新为2，commit&lt;/li&gt;
&lt;li&gt;事务1修改数据value+1=2，（由于修改是当前读，永远读取版本号最大的数据，所以读取到value为1）修改后delete版本号为1，新数据create版本号为1&lt;/li&gt;
&lt;li&gt;本事务读取数据value=2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;深入分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实上面的描述也是有漏洞的，如果有第三个事务版本号为3呢？因为版本号为3，是不是可以直接读取事务1、2未提交的数据？实际上在MVCC中，每个事务还有一个最低可见版本low_limit_id（事务号 &amp;gt;= low_limit_id的记录，对于当前事务都是不可见的），把当前正在执行还没commit的事务给过滤掉了。例如事务3，虽然版本号为3，但是low_limit_id=1，所以事务1和事务2的修改对3都是不可见的。&lt;/p&gt;

&lt;p&gt;为了解决隔离性问题，都没有使用完全copy数据这种笨方法。传统数据库使用共享锁和排它锁使读写操作串行；Mysql使用MVCC和排它锁，读写可并行。Mysql在RR隔离级别以下，和传统方式表现一致，在RR隔离级别，和传统方式有差异，体现在本事务更新某条数据后，能读取到其他事务对该条数据已提交的修改。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Jan 2018 03:24:00 +0000</pubDate>
<dc:creator>jieqing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jieqing/p/8328074.html</dc:identifier>
</item>
<item>
<title>我们编写 React 组件的最佳实践 - 夜色镇歌</title>
<link>http://www.cnblogs.com/wenpengfei/p/8327862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenpengfei/p/8327862.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://blog.catwen.cn/images/best-practices-for-writing-react-components/1.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚接触 &lt;code&gt;React&lt;/code&gt; 的时候，在一个又一个的教程上面看到很多种编写组件的方法，尽管那时候 &lt;code&gt;React&lt;/code&gt; 框架已经相当成熟，但是并没有一个固定的规则去规范我们去写代码。&lt;/p&gt;
&lt;p&gt;在过去的一年里，我们在不断的完善我们的做法，直到满意为止。&lt;/p&gt;
&lt;p&gt;本文会列出我们自己在使用的最佳实践，不管你是刚入门的新手还是很有经验的开发者，我们都希望本文对你有所帮助。&lt;/p&gt;
&lt;p&gt;开始之前，先列几条：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们使用ES6/ES7&lt;/li&gt;
&lt;li&gt;如果你无法区分页面组件和容器组件，推荐阅读 &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.kuvqndiqq&quot;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果有更好的意见或建议，请在评论区告诉我，谢谢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于 Class 的组件是有状态的，不管它包不包含函数，我们都会尽量少用。但是它也有它的用处。&lt;/p&gt;
&lt;p&gt;现在来一行一行的编写我们的组件：&lt;/p&gt;
&lt;h2 id=&quot;导入-css&quot;&gt;导入 CSS&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExpandableForm &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./ExpandableForm'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/ProfileContainer.css'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我喜欢 &lt;code&gt;CSS in Javascript&lt;/code&gt;，但是这个概念还比较新，现在也并没有成熟的解决方案，所以我们在每个组件里面去引用 CSS&lt;/p&gt;
&lt;h2 id=&quot;初始化-state&quot;&gt;初始化 State&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExpandableForm &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./ExpandableForm'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/ProfileContainer.css'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然你也可以选择在构造函数里面去初始化，但是我们觉得这种方式更加清晰。&lt;/p&gt;
&lt;p&gt;当然也会保证 Class 是默认导出的。&lt;/p&gt;
&lt;h2 id=&quot;proptypes-和-defaultprops&quot;&gt;propTypes 和 defaultProps&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; string&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; object &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExpandableForm &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./ExpandableForm'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/ProfileContainer.css'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
 
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; propTypes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
 
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Your Name'&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;propTypes 和 defaultProps 是静态属性，尽可能的把它们写在组件的最上方，以便其他开发者阅读。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;React 15.3.0&lt;/code&gt; 或更高的版本，使用 &lt;a href=&quot;https://github.com/facebook/prop-types&quot;&gt;prop-types&lt;/a&gt; 代替 &lt;code&gt;React.PropTypes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所有的组件都必须声明 propTypes&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; string&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; object &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExpandableForm &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./ExpandableForm'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/ProfileContainer.css'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
 
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; propTypes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
 
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Your Name'&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  handleSubmit &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;save&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  handleNameChange &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;changeName&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  handleExpand &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用基于 Class 的组件时，当你传递函数给子组件的时候，要确保他们有正确的 &lt;code&gt;this&lt;/code&gt;，通常用这种形式实现 &lt;code&gt;this.handleSubmit.bind(this)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是如果你使用箭头函数，就不需要 &lt;code&gt;bind(this)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;为-setstate-传递函数&quot;&gt;为 setState 传递函数&lt;/h2&gt;
&lt;p&gt;上面的例子中我们是这么做的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有个 setState 的小知识 —— 它是异步的，为了保证性能，&lt;code&gt;React&lt;/code&gt; 会分批修改 state，所以 state 不会在调用 setState 之后立即改变&lt;/p&gt;
&lt;p&gt;这意味着你不能依赖当前的状态，因为你不知道当前的状态是什么状态&lt;/p&gt;
&lt;p&gt;这里有个解决方案 —— 传递函数给 setState，&lt;code&gt;React&lt;/code&gt; 会把上一个状态 &lt;code&gt;prevState&lt;/code&gt; 传递给你&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(prevState &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;prevState&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;解构-props&quot;&gt;解构 Props&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; string&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; object &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExpandableForm &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./ExpandableForm'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/ProfileContainer.css'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
 
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; propTypes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
 
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Your Name'&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
handleSubmit &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;save&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  handleNameChange &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;changeName&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  handleExpand &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(prevState &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;prevState&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      model&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      title
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; ( 
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ExpandableForm 
        onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 
        expanded&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 
        onExpand&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;op&quot;&gt;&amp;gt;{&lt;/span&gt;title&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;          &amp;lt;input&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            type=&quot;text&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            value={model.name}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            onChange={this.handleNameChange}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            placeholder=&quot;Your Name&quot;/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      &amp;lt;/ExpandableForm&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    )
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像上面的例子一样，每个 prop 都独占一行&lt;/p&gt;
&lt;h2 id=&quot;装饰器decorators&quot;&gt;装饰器(Decorators)&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;@observer
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你使用了类似 &lt;a href=&quot;https://github.com/mobxjs/mobx&quot;&gt;mobx&lt;/a&gt; 的库，你可以这样去装饰你的 Class 组件&lt;/p&gt;
&lt;p&gt;修改函数式组件使用 &lt;a href=&quot;http://javascript.info/tutorial/decorators&quot;&gt;decorators&lt;/a&gt; 很灵活并且可读&lt;/p&gt;
&lt;p&gt;如果你不想使用装饰器，可以这么做：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// Component code&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;observer&lt;/span&gt;(ProfileContainer)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;闭包&quot;&gt;闭包&lt;/h2&gt;
&lt;p&gt;避免像下面注释的地方一样传递新的闭包给子组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;input
      type&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;
      value&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// onChange={(e) =&amp;gt; { model.name = e.target.value }}&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// ^ Not this. Use the below:&lt;/span&gt;
      onChange&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleChange&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      placeholder&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Your Name&quot;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式的好处是每次render，不会重新创建一个函数，没有额外的性能损失。&lt;/p&gt;
&lt;p&gt;这里是完整的组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; string&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; object &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Separate local imports from dependencies&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; ExpandableForm &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./ExpandableForm'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/ProfileContainer.css'&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Use decorators if needed&lt;/span&gt;
@observer
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProfileContainer &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Component &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// Initialize state here (ES7) or in a constructor method (ES6)&lt;/span&gt;
 
  &lt;span class=&quot;co&quot;&gt;// Declare propTypes as static properties as early as possible&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; propTypes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; string
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;co&quot;&gt;// Default props below propTypes&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; defaultProps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Your Name'&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;co&quot;&gt;// Use fat arrow functions for methods to preserve context (this will thus be the component instance)&lt;/span&gt;
  handleSubmit &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;save&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  handleNameChange &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;model&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;target&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  handleExpand &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setState&lt;/span&gt;(prevState &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;prevState&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  
  &lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Destructure props for readability&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      model&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      title
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;props&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; ( 
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;ExpandableForm 
        onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 
        expanded&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;state&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; 
        onExpand&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;handleExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// Newline props if there are more than two&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;span class=&quot;op&quot;&gt;&amp;gt;{&lt;/span&gt;title&lt;span class=&quot;op&quot;&gt;}&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;          &amp;lt;input&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            type=&quot;text&quot;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            value={model.name}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            // onChange={&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt; =&amp;gt; { model.name = e.target.value }}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            // Avoid creating new closures in the render method- use methods like below&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            onChange={this.handleNameChange}&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;            placeholder=&quot;Your Name&quot;/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;      &amp;lt;/ExpandableForm&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
    )
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这些组件没有状态和函数，他们很纯，非常容易阅读，尽量多的使用他们。&lt;/p&gt;
&lt;h2 id=&quot;proptypes&quot;&gt;propTypes&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; func&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; bool &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/Form.css'&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ExpandableForm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;propTypes&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; bool
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Component declaration&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们把 propTypes 写在最前面，他会被组件立即可见，这要归功于JavaScript的 &lt;code&gt;函数提升&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;解构-props-和-defaultprops&quot;&gt;解构 Props 和 defaultProps&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; func&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; bool &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/Form.css'&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ExpandableForm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;propTypes&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; bool&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ExpandableForm&lt;/span&gt;(props) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; formStyle &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;expanded&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'auto'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; : &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;form style&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;formStyle&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;props&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;Expand&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &amp;lt;/form&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的组件是一个函数，我们获取他的 props 就是在获取函数的参数值，我们可以直接用 &lt;code&gt;ES6&lt;/code&gt; 的解构：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; func&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; bool &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/Form.css'&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ExpandableForm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;propTypes&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; bool&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ExpandableForm&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; onExpand&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expanded &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; children&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; onSubmit &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; formStyle &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; expanded &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'auto'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; : &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;form style&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;formStyle&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;onSubmit&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;onExpand&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;Expand&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &amp;lt;/form&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以使用默认参数值去设置 &lt;code&gt;defaultProps&lt;/code&gt;，就像上面的 &lt;code&gt;expanded = false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;避免使用下面的 ES6 语法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; ExpandableForm &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; onExpand&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expanded&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; children &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来很先（逼）进（格），但这个函数是匿名的。&lt;/p&gt;
&lt;p&gt;如果你的Babel设置正确，这个匿名函数不会成为一个问题 —— 但是如果不是的话，任何错误都会显示在 &lt;code&gt;&amp;lt;&amp;lt; anonymous &amp;gt;&amp;gt;&lt;/code&gt; 中，这对于调试来说是非常糟糕的。&lt;/p&gt;
&lt;h2 id=&quot;wrapping&quot;&gt;Wrapping&lt;/h2&gt;
&lt;p&gt;函数式组件中不能使用 &lt;code&gt;decorators&lt;/code&gt;，你只需把它作为参数传递给过去&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; func&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; bool &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/Form.css'&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ExpandableForm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;propTypes&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; bool&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ExpandableForm&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; onExpand&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expanded &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; children&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; onSubmit &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; formStyle &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; expanded &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'auto'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; : &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;form style&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;formStyle&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;onSubmit&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;onExpand&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;Expand&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &amp;lt;/form&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;observer&lt;/span&gt;(ExpandableForm)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是完整的组件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; observer &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'mobx-react'&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; func&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; bool &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'prop-types'&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// Separate local imports from dependencies&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./styles/Form.css'&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Declare propTypes here, before the component (taking advantage of JS function hoisting)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// You want these to be as visible as possible&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ExpandableForm&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;propTypes&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;expanded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; bool&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;onExpand&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;func&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isRequired&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Destructure props like so, and use default arguments as a way of setting defaultProps&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;ExpandableForm&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; onExpand&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expanded &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; children&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; onSubmit &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; formStyle &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; expanded &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'auto'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; : &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; (
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;form style&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;formStyle&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; onSubmit&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;onSubmit&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;children&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;button onClick&lt;span class=&quot;op&quot;&gt;={&lt;/span&gt;onExpand&lt;span class=&quot;op&quot;&gt;}&amp;gt;&lt;/span&gt;Expand&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/button&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;    &amp;lt;/form&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
  )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// Wrap the component instead of decorating it&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;observer&lt;/span&gt;(ExpandableForm)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;jsx-中的条件判断&quot;&gt;JSX 中的条件判断&lt;/h2&gt;
&lt;p&gt;你可能会有很复杂的条件判断语句，但是你要避免下面的写法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.catwen.cn/images/best-practices-for-writing-react-components/2.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嵌套的三元表达式不是一个好的方法，太难阅读了&lt;/p&gt;
&lt;p&gt;有一些库可以解决这个问题(&lt;a href=&quot;https://github.com/AlexGilleran/jsx-control-statements&quot;&gt;jsx-control-statements&lt;/a&gt;)，但是我们没有引入其他的库，我们是这么解决的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.catwen.cn/images/best-practices-for-writing-react-components/3.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用了 &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript&quot;&gt;立即执行函数&lt;/a&gt; 把条件语句写在里面，虽然这样可能会导致性能下降，但是在大多数情况下，它带来的负面影响还是小于糟糕的可读性。&lt;/p&gt;
&lt;p&gt;当然如果组件分的足够细，你可能不会用到这么复杂的条件判断。&lt;/p&gt;
&lt;p&gt;此外，如果你只在一个表达式里面去渲染组件，避免这么做：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  isTrue
   &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;True&lt;span class=&quot;op&quot;&gt;!&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;   : &amp;lt;none/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以使用短路语法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  isTrue &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;True&lt;span class=&quot;op&quot;&gt;!&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这篇文章对你有帮助吗？请在评论区给出你的意见和建议，感谢阅读！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://engineering.musefind.com/our-best-practices-for-writing-react-components-dec3eb5c3fc8&quot;&gt;原文链接&lt;/a&gt;，翻译并首发于&lt;a href=&quot;https://blog.catwen.cn&quot;&gt;我的个人博客&lt;/a&gt;，推荐下我前阵子写的一个 React 脚手架 &lt;a href=&quot;https://github.com/wenpengfei/parcel-typescript-react-boilerplate&quot;&gt;parcel-typescript-react-boilerplate&lt;/a&gt;，请给出意见和建议，相互学习。无耻的求个星，谢谢~~！&lt;/p&gt;
</description>
<pubDate>Mon, 22 Jan 2018 02:51:00 +0000</pubDate>
<dc:creator>夜色镇歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenpengfei/p/8327862.html</dc:identifier>
</item>
<item>
<title>[翻译].NET Shell Extensions - Shell Context Menus---.net 外壳扩展之右键菜单 - 可达鸭要进化</title>
<link>http://www.cnblogs.com/Aries-rong/p/8320531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Aries-rong/p/8320531.html</guid>
<description>&lt;p&gt;本文原作者为&lt;strong&gt;&lt;a id=&quot;ctl00_AboutAuthorRptr_ctl00_AboutAuthor_memberProfileLink&quot; class=&quot;author&quot; href=&quot;https://www.codeproject.com/Members/DaveKerr&quot;&gt;Dave Kerr&lt;/a&gt;&lt;/strong&gt;，原文链接为&lt;a href=&quot;http://www.codeproject.com/Articles/512956/NET-Shell-Extensions-Shell-Context-Menus&quot;&gt;.NET Shell Extensions - Shell Context Menus &lt;/a&gt;，我是在为了完成最新需求的时候查询资料的时候发现的，因为太久没有看外文资料了，所以为了锻炼一下翻译的，文中有一句未能翻译出来。&lt;/p&gt;




&lt;p&gt;一直到.NET 4.0为止，我们都还是不能通过.NET代码完全实现外壳扩展的功能。但是随着framework的不断提高，现在我们已经可以实现这个功能了。在本文中，我将带领你通过C#类文件快速实现右键菜单扩展功能。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120133646162-781214674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图中是已经实现的功能，“Count Lines”是我自定义的一个右键选项，文章将仔细解释如何实现该功能）&lt;/p&gt;




&lt;p&gt;本文只是“.NET外壳扩展”的一部分，本系列还包括:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/512956/NET-Shell-Extensions-Shell-Context-Menus&quot;&gt;.NET Shell Extensions - Shell Context Menus &lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/522665/NET-Shell-Extensions-Shell-Icon-Handlers&quot;&gt;.NET Shell Extensions - Shell Icon Handlers &lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;Shell Info Tip Handlers&quot; href=&quot;http://www.codeproject.com/Articles/527058/NET-Shell-Extensions-Shell-Info-Tip-Handlers&quot;&gt;.NET Shell Extensions - Shell Info Tip Handlers&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/529515/NET-Shell-Extensions-Shell-Drop-Handlers&quot;&gt;.NET Shell Extensions - Shell Drop Handlers  &lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;Shell Preview Handlers&quot; href=&quot;http://www.codeproject.com/Articles/533948/NET-Shell-Extensions-Shell-Preview-Handlers&quot;&gt;.NET Shell Extensions - Shell Preview Handlers&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/545781/NET-Shell-Extensions-Shell-Icon-Overlay-Handlers&quot;&gt;.NET Shell Extensions - Shell Icon Overlay Handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;.NET Shell Extensions - Shell Thumbnail Handlers&quot; href=&quot;http://www.codeproject.com/Articles/563114/NET-Shell-Extensions-Shell-Thumbnail-Handlers&quot;&gt;.NET Shell Extensions - Shell Thumbnail Handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/573392/NET-Shell-Extensions-Shell-Property-Sheets&quot;&gt;.NET Shell Extensions - Shell Property Sheets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeproject.com/Articles/653780/NET-Shell-Extensions-Deploying-SharpShell-Servers&quot;&gt;.NET Shell Extensions - Deploying SharpShell Servers&lt;/a&gt;    &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Shell Context Menus是在系统中注册，允许扩展shell对象的Context菜单的COM服务器。这里说的对象可以明确到具体的文件类型，例如“.txt”文件，驱动，文件或者其他的文件类型。这时的Context菜单可以通过Windows管理器快速访问到更多的信息。&lt;/p&gt;


&lt;p&gt;实现外壳扩展功能有很多工作需要完成：我们需要实现具体的COM接口，需要提供服务，并通过各种方式更新注册表。现在我们可以调用我已经写好的一个叫做“SharpShell”库来完成这些复杂的功能，这样我们的任务就变成了只需要创建一个包含已完成延展功能类的轻量级的类库了。&lt;/p&gt;


&lt;p&gt;下面所示代码创建了一个shell扩展，允许你通过右键并选择“Count Lines”来计算出任何文本文件中的行数。另外在文章后半部分我将详细讲解如何创建下面所示的库。我先将代码显示出来的意图是为了强调在调用SharpShell库的情况下如何直截了当的完成库的书写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; The CountLinesExtensions is an example shell context menu extension,
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; implemented with SharpShell. It adds the command 'Count Lines' to text
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; files.
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
[ComVisible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
[COMServerAssociation(AssociationType.ClassOfExtension, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountLinesExtension : SharpContextMenu
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Determines whether this instance can a shell
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; context show menu, given the specified selected file list.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;c&amp;gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&amp;lt;/c&amp;gt;&lt;/span&gt;&lt;span&gt; if this instance should show a shell context
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; menu for the specified file list; otherwise, &lt;/span&gt;&lt;span&gt;&amp;lt;c&amp;gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&amp;lt;/c&amp;gt;&lt;/span&gt;&lt;span&gt;.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanShowMenu()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  We always show the menu.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Creates the context menu. This can be a single menu item or a tree of them.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; The context menu for the shell context menu.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ContextMenuStrip CreateMenu()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Create the menu strip.&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; menu = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextMenuStrip();
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Create a 'count lines' item.&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; itemCountLines = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ToolStripMenuItem
        {
            Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Count Lines...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Image &lt;/span&gt;=&lt;span&gt; Properties.Resources.CountLines
        };
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  When we click, we'll count the lines.&lt;/span&gt;
        itemCountLines.Click += (sender, args) =&amp;gt;&lt;span&gt; CountLines();
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Add the item to the context menu.&lt;/span&gt;
&lt;span&gt;        menu.Items.Add(itemCountLines);
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Return the menu.&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; menu;
    }
 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Counts the lines in the selected files.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CountLines()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Builder for the output.&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Go through each file.&lt;/span&gt;
        &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; filePath &lt;span&gt;in&lt;/span&gt;&lt;span&gt; SelectedItemPaths)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Count the lines.&lt;/span&gt;
            builder.AppendLine(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} - {1} Lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
              Path.GetFileName(filePath), File.ReadAllLines(filePath).Length));
        }
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Show the ouput.&lt;/span&gt;
&lt;span&gt;        MessageBox.Show(builder.ToString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码可以说简单清晰了，现在就让我们开始仔细研究具体的实现过程吧。&lt;/p&gt;


&lt;p&gt;首先，我们需要开始一个新的C#类库项目。&lt;/p&gt;
&lt;p&gt;提示：你也可以除了C#，还可以使用VB，在本文中虽然所有的代码都是C#，但是方法原理均同理可得。&lt;/p&gt;
&lt;p&gt;在本例中，我们的项目名称是” CountLinesExtension”.&lt;/p&gt;
&lt;p&gt;现在我们需要添加一下的引用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;System.Windows.Forms&lt;/li&gt;
&lt;li&gt;System.Drawing&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之所以需要&lt;code&gt;System.Windows.Forms&lt;/code&gt;，是因为我们需要通过WinForms ContextMenuStrip来定义context菜单。而需要调用System.Drawing的原因在于我们想要用到Icons。&lt;/p&gt;
&lt;p&gt;将'&lt;em&gt;Class1.cs&lt;/em&gt;'重命名为'&lt;em&gt;CountLinesExtension.cs&lt;/em&gt;'.那么目前我们项目的就变成了这样了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120133751584-793899959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;现在我们需要添加对SharpShell的引用。你可以通过以下这些不同的方法：&lt;/p&gt;
&lt;h2&gt;添加引用：&lt;/h2&gt;
&lt;p&gt;在文章最开始的地方下载'SharpShell Library'压缩文件，然后直接对&lt;em&gt;SharpShell.dll&lt;/em&gt;文件添加引用即可。&lt;/p&gt;
&lt;p&gt;提示：文章开始的下载文件是在此文写的时候的文件，如果你想要获得最新的版本，请通过Nuget或者从&lt;a title=&quot;SharpShell on CodePlex&quot; href=&quot;http://sharpshell.codeplex.com/&quot; target=&quot;_blank&quot;&gt;sharpshell.codeplex.com&lt;/a&gt;获取。&lt;/p&gt;
&lt;h2&gt;Nuget&lt;/h2&gt;
&lt;p&gt;如果你电脑有Nuget，那么就只需要简单检索SharpShell并安装即可，或者直接访问：&lt;a href=&quot;https://www.nuget.org/packages/SharpShell&quot;&gt;https://www.nuget.org/packages/SharpShell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120133826896-1421821781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;CodePlex &lt;/h2&gt;
&lt;p&gt;从&lt;strong&gt;CodePlex&lt;/strong&gt; 的里面专门的SharpShell主页&lt;a title=&quot;SharpShell on CodePlex&quot; href=&quot;https://www.codeproject.com/Articles/512956/sharpshell.codeplex.com&quot; target=&quot;_blank&quot;&gt;sharpshell.codeplex.com&lt;/a&gt;中你直接可以得到最新的版本。Nuget上虽然也有最新的可靠的版本，但是CodePlex可以还有可用的已写好的betas，而且那上面的文章里面的版本基本都是可用的。&lt;/p&gt;


&lt;p&gt;现在开始就开始真正的研究了，注意了哦。我们的&lt;code&gt;CountLinesExtension&lt;/code&gt;继承于&lt;code&gt;SharpContextMenu&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; The Count Lines Context Menu Extension
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountLinesExtension : SharpContextMenu
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们既然继承于&lt;code&gt;SharpContextMenu&lt;/code&gt;这个父类，那我们就要来实现这个抽象类。右键选择&lt;code&gt;SharpContextMenu&lt;/code&gt;，然后选择'Implement Abstract Class'：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120133903209-207126304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个操作将会自动生成&lt;code&gt;SharpContextMenu&lt;/code&gt;的两个函数-&lt;code&gt;CanShowMenu&lt;/code&gt; 和 &lt;code&gt;CreateMenu&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; The Count Lines Context Menu Extension
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountLinesExtension : SharpContextMenu
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanShowMenu()
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
    }
 
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ContextMenuStrip CreateMenu()
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过实现这两个函数没我们可以实现我们所需的所有功能。两个函数功能具体介绍：&lt;/p&gt;
&lt;h2&gt;CanShowMenu   &lt;span&gt;&lt;sub&gt;（好像有点不对）&lt;/sub&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这个函数来决定当前的文件是否是我们需要用来显示扩展菜单的文件。被选中的文件类型是&lt;code&gt;SelectedItemPaths&lt;/code&gt;的属性。我们可以通过检查来判断当前的文件类型是不是符合要求的文件类型。如果需要显示菜单就返回true，否则就返回false。&lt;/p&gt;
&lt;h2&gt;CreateMenu&lt;/h2&gt;
&lt;p&gt;这个函数实现主要的功能。我们需要返回WinForms的&lt;code&gt;ContextMenuStrip&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是具体的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanShowMenu()
&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  We will always show the menu.&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt; &lt;span&gt;}&lt;/span&gt; 
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ContextMenuStrip CreateMenu()
&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Create the menu strip.&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; menu = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextMenuStrip();
&lt;/span&gt; 
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Create a 'count lines' item.&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; itemCountLines = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ToolStripMenuItem
&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;         Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Count Lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
 &lt;span&gt;    };&lt;/span&gt; 
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  When we click, we'll call the 'CountLines' function.&lt;/span&gt;
     itemCountLines.Click += (sender, args) =&amp;gt;&lt;span&gt; CountLines();&lt;/span&gt;  
 
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Add the item to the context menu.&lt;/span&gt;
 &lt;span&gt;    menu.Items.Add(itemCountLines);&lt;/span&gt; &lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Return the menu.&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; menu;
&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;   
 
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CountLines()
&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Builder for the output.&lt;/span&gt;
     &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder(); 
&lt;/span&gt; 
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Go through each file.&lt;/span&gt;
     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; filePath &lt;span&gt;in&lt;/span&gt;&lt;span&gt; SelectedItemPaths)
&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Count the lines.&lt;/span&gt;
         builder.AppendLine(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} - {1} Lines&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,Path.GetFileName(filePath),File.ReadAllLines(filePath).Length));
&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt; 
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Show the ouput.&lt;/span&gt;
 &lt;span&gt;    MessageBox.Show(builder.ToString());
&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于&lt;code&gt;CanShowMenu&lt;/code&gt;，我们常常直接返回true（很快我们就会明白为什么我们不需要验证我们的文本文件了）。对于&lt;code&gt;CreateMenu&lt;/code&gt;，我们建立了一个显示菜单，里面只有一个选项，也就是'Count Lines'，并实现读出行数的功能。&lt;/p&gt;
&lt;p&gt;CountLines这个功能的实现是通过&lt;code&gt;SelectedItemPaths&lt;/code&gt;和读取每个文件的函数，然后总结好了显示在弹窗里。&lt;/p&gt;


&lt;p&gt;现在所剩的事情不多了。首先我们需要添加&lt;code&gt;COMVisible&lt;/code&gt;的引用到我们的类里面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ComVisible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CountLinesExtension : SharpContextMenu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么呢？因为我们的类虽然看起来不像，但是他本质上也是一个COM Server.如果你了解一些基类，那么你可以看我们刚刚实现的COM接口，例如&lt;code&gt;IShellExtInit&lt;/code&gt;, &lt;code&gt;IContextMenu&lt;/code&gt;, 和 &lt;code&gt;ISharpShellServer&lt;/code&gt;。我们不用了解这里到底做了什么，凡是为了保证系统能够创建我们的扩展，她就必须有这个属性。&lt;/p&gt;
&lt;p&gt;接下来，我们需要给程序集一个强名称。这里有很多方法实现这个要求，但是总体来说，这是最好的方法。现在我们单机程序右键，然后选择“属性”。再选择“签名”。选中“为程序集签名”，再选择“选择强名称秘钥文件”里面的“新建”，并输入新建的密钥文件名称。你可以自行选择是否需要使用密码保护密钥文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120134007318-2054214432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一步，我们需要关联我们的扩展到具体的文件类型了。这个的实现可以通过对&lt;code&gt;COMServerAssociation&lt;/code&gt;（来源于SharpShell）的引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 [ComVisible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt; [COMServerAssociation(AssociationType.ClassOfExtension, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CountLinesExtension : SharpContextMenu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们做了什么呢？我们告诉了SharpShell，注册服务器时，我们想要关联任何与“.txt”相关的类。这就意味着我们不止是仅限于以.TXT结尾的文件，而是任何同类的文件。更权威的说法是，大多是与txt文件共享同样图标的东西。&lt;/p&gt;
&lt;p&gt;你可以用&lt;code&gt;COMServerAssociation&lt;/code&gt;的属性来实现更多的功能，例如你还可以与文件夹，驱动，位置的文件来实现特定的扩展，等等。另外，关于&lt;a title=&quot;COM Server Associations Documentation&quot; href=&quot;http://sharpshell.codeplex.com/wikipage?title=COM%20Server%20Associations&amp;amp;referringTitle=Documentation&quot; target=&quot;_blank&quot;&gt;COM Server Associations&lt;/a&gt;的详细的文献资料在&lt;a title=&quot;SharpShell&quot; href=&quot;http://sharpshell.codeplex.com/&quot; target=&quot;_blank&quot;&gt;SharpShell CodePlex&lt;/a&gt;上面。&lt;/p&gt;
&lt;p&gt;好了，但目前为止就搞定了！我们已经创建一个可以在作为COM server 在系统中添加自定义菜单的CountLinesExtension程序集项目了。关于注册COM Server和调试部署的任务，我们我们将在下一节，仔细讨论。&lt;/p&gt;


&lt;p&gt;这个Shell扩展功能将被加载到电脑资源管理器时，由于加载.NET COM Server时各种迂回的方式，所以可以说让调试器进入进程并但不执行托管代码几乎可以说是不可能实现的事情。当然，这里还是有一个方法可以快速实现调试。Sharp Shell有一些工具，让实现COM Server变得简单了，其中一个叫做：Server Manager。我们可以用这个工作实现调试。&lt;/p&gt;
&lt;p&gt;打开Server Manager工具，然后点击File，选择Load Server，再加载已生成的文件（DLL文件）。你也可以直接拖动文件到主界面中。然后被选中的文件的详细信息就会在旁边显示了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120134033099-330009674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个Server Manager非常好用，它可以告诉你服务是否已经安装了和其他各种信息。&lt;/p&gt;
&lt;p&gt;如果你要加载SharpContextMenu服务，那就选中'Tools'，然后你选中再选中'Test Context Menu'。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120134059099-890388504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你用到了'Test Context Menu'的时候，你会得到一份测试窗口。只是Windows资源管理器应用程序的基本实现。你可以通过右键单击来测试。&lt;/p&gt;
&lt;p&gt;提示：不管你的COMServerAssocations已经生成了，测试的窗口都会不断的重新创建。&lt;/p&gt;
&lt;p&gt;将调试器附加到servermanager过程将允许你调试你的上下文菜单和测试它的功能，而无需在Windows登记服务器。下面是运行Count Line上下文扩展菜单时测试shell的样子&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/924627/201801/924627-20180120134126428-232647069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里又很多方法实现安装和注册Shell扩展。在接下来的这一节里我将仔细介绍这些。&lt;/p&gt;
&lt;h2&gt;regasm&lt;/h2&gt;
&lt;p&gt;你可以通过regasm这个工具来实现安装和祖册shell扩展。当使用regasm的时候shell会被装进注册表中（COM服务器的类ID将放在COM服务器类部分，并与实际服务器文件的路径相关联），也会创建关联。&lt;/p&gt;
&lt;h2&gt;Server Manager&lt;/h2&gt;
&lt;p&gt;在开发过程中，服务器管理工具是我首选的安装/卸载和注册/注销的方法，因为它可以让安装和注册作为单独的步骤处理。它也将让你指定你是安装/卸载在32位还是64位模式中。&lt;/p&gt;
&lt;h2&gt;手动注册表操作&lt;/h2&gt;
&lt;p&gt;Generally a bad approach, but if you absolutely have to then the MSDN documentation for Shell Extensions describes the changes that must be made to the registry to manually register a COM server, or a Managed COM Server（这句不会翻译）。这个文献资料被放在了下一节。&lt;/p&gt;




&lt;p&gt;会逐渐通过SharpShell和.NET的使用来时间实现更多的shell扩展功能，形成一个完整的系列。目前那我正在实现图标处理程序（正在编写文档），关于属性表处理程序问题已经实现了（还有些bug正在解决）。&lt;/p&gt;

</description>
<pubDate>Mon, 22 Jan 2018 01:55:00 +0000</pubDate>
<dc:creator>可达鸭要进化</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Aries-rong/p/8320531.html</dc:identifier>
</item>
<item>
<title>HashMap 源码详细分析(JDK1.8) - code4funn</title>
<link>http://www.cnblogs.com/nullllun/p/8327664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullllun/p/8327664.html</guid>
<description>&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;本篇文章我们来聊聊大家日常开发中常用的一个集合类 - &lt;code&gt;HashMap&lt;/code&gt;。HashMap 最早出现在 JDK 1.2中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。&lt;/p&gt;
&lt;p&gt;在本篇文章中，我将会对 HashMap 中常用方法、重要属性及相关方法进行分析。需要说明的是，HashMap 源码中可分析的点很多，本文很难一一覆盖，请见谅。&lt;/p&gt;
&lt;h2 id=&quot;二原理&quot;&gt;二、原理&lt;/h2&gt;
&lt;p&gt;上一节说到 HashMap 底层是基于散列算法实现，散列算法分为散列再探测和拉链式。HashMap 则使用了拉链式的散列算法，并在 JDK 1.8 中引入了红黑树优化过长的链表。数据结构示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161231547335.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于拉链式的散列算法，其数据结构是由数组和链表（或树形结构）组成。在进行增删查等操作时，首先要定位到元素的所在桶的位置，之后再从链表中定位该元素。比如我们要查询上图结构中是否包含元素&lt;code&gt;35&lt;/code&gt;，步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定位元素&lt;code&gt;35&lt;/code&gt;所处桶的位置，&lt;code&gt;index = 35 % 16 = 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;3&lt;/code&gt;号桶所指向的链表中继续查找，发现35在链表中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面就是 HashMap 底层数据结构的原理，HashMap 基本操作就是对拉链式散列算法基本操作的一层包装。不同的地方在于 JDK 1.8 中引入了红黑树，底层数据结构由&lt;code&gt;数组+链表&lt;/code&gt;变为了&lt;code&gt;数组+链表+红黑树&lt;/code&gt;，不过本质并未变。好了，原理部分先讲到这，接下来说说源码实现。&lt;/p&gt;
&lt;h2 id=&quot;三源码分析&quot;&gt;三、源码分析&lt;/h2&gt;
&lt;p&gt;本篇文章所分析的源码版本为 JDK 1.8。与 JDK 1.7 相比，JDK 1.8 对 HashMap 进行了一些优化。比如引入红黑树解决过长链表效率低的问题。重写 resize 方法，移除了 alternative hashing 相关方法，避免重新计算键的 hash 等。不过本篇文章并不打算对这些优化进行分析，本文仅会分析 HashMap 常用的方法及一些重要属性和相关方法。如果大家对红黑树感兴趣，可以阅读我的另一篇文章 - &lt;a href=&quot;http://www.coolblog.xyz/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/&quot;&gt;红黑树详细分析&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;构造方法&quot;&gt;3.1 构造方法&lt;/h3&gt;
&lt;h4 id=&quot;构造方法分析&quot;&gt;3.1.1 构造方法分析&lt;/h4&gt;
&lt;p&gt;HashMap 的构造方法不多，只有四个。HashMap 构造方法做的事情比较简单，一般都是初始化一些重要变量，比如 loadFactor 和 threshold。而底层的数据结构则是延迟到插入键值对时再进行初始化。HashMap 相关构造方法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** 构造方法 1 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap() {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;loadFactor&lt;/span&gt; = DEFAULT_LOAD_FACTOR; &lt;span class=&quot;co&quot;&gt;// all other fields defaulted&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;/** 构造方法 2 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);
}

&lt;span class=&quot;co&quot;&gt;/** 构造方法 3 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity, &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; loadFactor) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal initial capacity: &quot;&lt;/span&gt; +
                                           initialCapacity);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loadFactor &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || Float.&lt;span class=&quot;fu&quot;&gt;isNaN&lt;/span&gt;(loadFactor))
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal load factor: &quot;&lt;/span&gt; +
                                           loadFactor);
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;loadFactor&lt;/span&gt; = loadFactor;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;threshold&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;tableSizeFor&lt;/span&gt;(initialCapacity);
}

&lt;span class=&quot;co&quot;&gt;/** 构造方法 4 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; HashMap(Map&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; K, ? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; V&amp;gt; m) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;loadFactor&lt;/span&gt; = DEFAULT_LOAD_FACTOR;
    &lt;span class=&quot;fu&quot;&gt;putMapEntries&lt;/span&gt;(m, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面4个构造方法中，大家平时用的最多的应该是第一个了。第一个构造方法很简单，仅将 loadFactor 变量设为默认值。构造方法2调用了构造方法3，而构造方法3仍然只是设置了一些变量。构造方法4则是将另一个 Map 中的映射拷贝一份到自己的存储结构中来，这个方法不是很常用。&lt;/p&gt;
&lt;p&gt;上面就是对构造方法简单的介绍，构造方法本身并没什么太多东西，所以就不说了。接下来说说构造方法所初始化的几个的变量。&lt;/p&gt;
&lt;h4 id=&quot;初始容量负载因子阈值&quot;&gt;3.1.2 初始容量、负载因子、阈值&lt;/h4&gt;
&lt;p&gt;我们在一般情况下，都会使用无参构造方法创建 HashMap。但当我们对时间和空间复杂度有要求的时候，使用默认值有时可能达不到我们的要求，这个时候我们就需要手动调参。在 HashMap 构造方法中，可供我们调整的参数有两个，一个是初始容量 initialCapacity，另一个负载因子 loadFactor。通过这两个设定这两个参数，可以进一步影响阈值大小。但初始阈值 threshold 仅由 initialCapacity 经过移位操作计算得出。他们的作用分别如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;initialCapacity&lt;/td&gt;
&lt;td&gt;HashMap 初始容量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;loadFactor&lt;/td&gt;
&lt;td&gt;负载因子&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;threshold&lt;/td&gt;
&lt;td&gt;当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** The default initial capacity - MUST be a power of two. */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;/** The load factor used when none specified in constructor. */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = &lt;span class=&quot;fl&quot;&gt;0.&lt;/span&gt;75f;

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; loadFactor;

&lt;span class=&quot;co&quot;&gt;/** The next size value at which to resize (capacity * load factor). */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; threshold;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果大家去看源码，会发现 HashMap 中没有定义 initialCapacity 这个变量。这个也并不难理解，从参数名上可看出，这个变量表示一个初始容量，只是构造方法中用一次，没必要定义一个变量保存。但如果大家仔细看上面 HashMap 的构造方法，会发现存储键值对的数据结构并不是在构造方法里初始化的。这就有个疑问了，既然叫初始容量，但最终并没有用与初始化数据结构，那传这个参数还有什么用呢？这个问题我先不解释，给大家留个悬念，后面会说明。&lt;/p&gt;
&lt;p&gt;默认情况下，HashMap 初始容量是16，负载因子为 0.75。这里并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明），即&lt;code&gt;threshold = capacity * loadFactor&lt;/code&gt;。但当你仔细看构造方法3时，会发现阈值并不是由上面公式计算而来，而是通过一个方法算出来的。这是不是可以说明 threshold 变量的注释有误呢？还是仅这里进行了特殊处理，其他地方遵循计算公式呢？关于这个疑问，这里也先不说明，后面在分析扩容方法时，再来解释这个问题。接下来，我们来看看初始化 threshold 的方法长什么样的的，源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Returns a power of two size for the given target capacity.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tableSizeFor&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cap) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n = cap - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;
    n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;;
    n |= n &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (n &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) ? &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码长的有点不太好看，反正我第一次看的时候不明白它想干啥。不过后来在纸上画画，知道了它的用途。总结起来就一句话：找到大于或等于 cap 的最小2的幂。至于为啥要这样，后面再解释。我们先来看看 tableSizeFor 方法的图解：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15159249414047.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面是 tableSizeFor 方法的计算过程图，这里&lt;code&gt;cap = 536,870,913 = 2&amp;lt;sup&amp;gt;29&amp;lt;/sup&amp;gt; + 1&lt;/code&gt;，多次计算后，算出&lt;code&gt;n + 1 = 1,073,741,824 = 2&amp;lt;sup&amp;gt;30&amp;lt;/sup&amp;gt;&lt;/code&gt;。通过图解应该可以比较容易理解这个方法的用途，这里就不多说了。&lt;/p&gt;
&lt;p&gt;说完了初始阈值的计算过程，再来说说负载因子（loadFactor）。对于 HashMap 来说，负载因子是一个很重要的参数，该参数反应了 HashMap 桶数组的使用情况（假设键值对节点均匀分布在桶数组中）。通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现。当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键的键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。一般情况下，我们用默认值就可以了。&lt;/p&gt;
&lt;h3 id=&quot;查找&quot;&gt;3.2 查找&lt;/h3&gt;
&lt;p&gt;HashMap 的查找操作比较简单，查找步骤与原理篇介绍一致，即先定位键值对所在的桶的位置，然后再对链表或红黑树进行查找。通过这两步即可完成查找，该操作相关代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (e = &lt;span class=&quot;fu&quot;&gt;getNode&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key)) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;getNode&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, Object key) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n; K k;
    &lt;span class=&quot;co&quot;&gt;// 1. 定位键值对所在桶的位置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
        (first = tab[(n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp; &lt;span class=&quot;co&quot;&gt;// always check first node&lt;/span&gt;
            ((k = first.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; first;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = first.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 2. 如果 first 是 TreeNode 类型，则调用黑红树查找方法&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;)first).&lt;span class=&quot;fu&quot;&gt;getTreeNode&lt;/span&gt;(hash, key);
                
            &lt;span class=&quot;co&quot;&gt;// 2. 对链表进行查找&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
                    ((k = e.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; e;
            } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查找的核心逻辑是封装在 getNode 方法中的，getNode 方法源码我已经写了一些注释，应该不难看懂。我们先来看看查找过程的第一步 - 确定桶位置，其实现代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// index = (n - 1) &amp;amp; hash&lt;/span&gt;
first = tab[(n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里通过&lt;code&gt;(n - 1)&amp;amp; hash&lt;/code&gt;即可算出桶的在桶数组中的位置，可能有的朋友不太明白这里为什么这么做，这里简单解释一下。HashMap 中桶数组的大小 length 总是2的幂，此时，&lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt; 等价于对 length 取余。但取余的计算效率没有位运算高，所以&lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt;也是一个小的优化。举个例子说明一下吧，假设 hash = 185，n = 16。计算过程示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15159947838577.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的计算并不复杂，这里就不多说了。&lt;/p&gt;
&lt;p&gt;在上面源码中，除了查找相关逻辑，还有一个计算 hash 的方法。这个方法源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 计算键的 hash 值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(Object key) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; h;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (key == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; : (h = key.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看这个方法的逻辑好像是通过位运算重新计算 hash，那么这里为什么要这样做呢？为什么不直接用键的 hashCode 方法产生的 hash 呢？大家先可以思考一下，我把答案写在下面。&lt;/p&gt;
&lt;p&gt;这样做有两个好处，我来简单解释一下。我们再看一下上面求余的计算图，图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低4位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高4位数据与低4位数据进行异或运算，即 &lt;code&gt;hash ^ (hash &amp;gt;&amp;gt;&amp;gt; 4)&lt;/code&gt;。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160192933678.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要左移16位。&lt;/p&gt;
&lt;p&gt;上面所说的是重新计算 hash 的一个好处，除此之外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。&lt;/p&gt;
&lt;h3 id=&quot;遍历&quot;&gt;3.3 遍历&lt;/h3&gt;
&lt;p&gt;和查找查找一样，遍历操作也是大家使用频率比较高的一个操作。对于 遍历 HashMap，我们一般都会用下面的方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(Object key : map.&lt;span class=&quot;fu&quot;&gt;keySet&lt;/span&gt;()) {
    &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(HashMap.&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt; entry : map.&lt;span class=&quot;fu&quot;&gt;entrySet&lt;/span&gt;()) {
    &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码片段中可以看出，大家一般都是对 HashMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 keySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Set keys = map.&lt;span class=&quot;fu&quot;&gt;keySet&lt;/span&gt;();
Iterator ite = keys.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (ite.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
    Object key = ite.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家在遍历 HashMap 的过程中会发现，多次对 HashMap 进行遍历时，遍历结果顺序都是一致的。但这个顺序和插入的顺序一般都是不一致的。产生上述行为的原因是怎样的呢？大家想一下原因。我先把遍历相关的代码贴出来，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Set&amp;lt;K&amp;gt; &lt;span class=&quot;fu&quot;&gt;keySet&lt;/span&gt;() {
    Set&amp;lt;K&amp;gt; ks = keySet;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ks == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        ks = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;KeySet&lt;/span&gt;();
        keySet = ks;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ks;
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 键集合&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; KeySet &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractSet&amp;lt;K&amp;gt; {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;()                 { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; size; }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;()               { HashMap.&lt;span class=&quot;fu&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;(); }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Iterator&amp;lt;K&amp;gt; &lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;()     { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;KeyIterator&lt;/span&gt;(); }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(Object o) { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;containsKey&lt;/span&gt;(o); }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(Object key) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;// 省略部分代码&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 键迭代器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; KeyIterator &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; HashIterator 
    &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Iterator&amp;lt;K&amp;gt; {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; K &lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nextNode&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;; }
}

&lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HashIterator {
    Node&amp;lt;K,V&amp;gt; next;        &lt;span class=&quot;co&quot;&gt;// next entry to return&lt;/span&gt;
    Node&amp;lt;K,V&amp;gt; current;     &lt;span class=&quot;co&quot;&gt;// current entry&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expectedModCount;  &lt;span class=&quot;co&quot;&gt;// for fast-fail&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index;             &lt;span class=&quot;co&quot;&gt;// current slot&lt;/span&gt;

    &lt;span class=&quot;fu&quot;&gt;HashIterator&lt;/span&gt;() {
        expectedModCount = modCount;
        Node&amp;lt;K,V&amp;gt;[] t = table;
        current = next = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; size &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) { &lt;span class=&quot;co&quot;&gt;// advance to first entry &lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 寻找第一个包含链表节点引用的桶&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {} &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (index &amp;lt; t.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;amp;&amp;amp; (next = t[index++]) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; next != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }

    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;nextNode&lt;/span&gt;() {
        Node&amp;lt;K,V&amp;gt;[] t;
        Node&amp;lt;K,V&amp;gt; e = next;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NoSuchElementException();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((next = (current = e).&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (t = table) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// 寻找下一个包含链表节点引用的桶&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {} &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (index &amp;lt; t.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;amp;&amp;amp; (next = t[index++]) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; e;
    }
    &lt;span class=&quot;co&quot;&gt;//省略部分代码&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的源码，遍历所有的键时，首先要获取键集合&lt;code&gt;KeySet&lt;/code&gt;对象，然后再通过 KeySet 的迭代器&lt;code&gt;KeyIterator&lt;/code&gt;进行遍历。KeyIterator 类继承自&lt;code&gt;HashIterator&lt;/code&gt;类，核心逻辑也封装在 HashIterator 类中。HashIterator 的逻辑并不复杂，在初始化时，HashIterator 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。举个例子，假设我们遍历下图的结构：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160157281390.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HashIterator 在初始化时，会先遍历桶数组，找到包含链表节点引用的桶，对应图中就是3号桶。随后由 nextNode 方法遍历该桶所指向的链表。遍历完3号桶后，nextNode 方法继续寻找下一个不为空的桶，对应图中的7号桶。之后流程和上面类似，直至遍历完最后一个桶。以上就是 HashIterator 的核心逻辑的流程，对应下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160167712865.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;遍历上图的最终结果是 &lt;code&gt;19 -&amp;gt; 3 -&amp;gt; 35 -&amp;gt; 7 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 59&lt;/code&gt;，为了验证正确性，简单写点测试代码跑一下看看。测试代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 应在 JDK 1.8 下测试，其他环境下不保证结果和上面一致&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HashMapTest {

    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testTraversal&lt;/span&gt;() {
        HashMap&amp;lt;Integer, String&amp;gt; map = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; HashMap(&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;43&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;59&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
        map.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;35&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);

        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;遍历结果：&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Integer key : map.&lt;span class=&quot;fu&quot;&gt;keySet&lt;/span&gt;()) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(key + &lt;span class=&quot;st&quot;&gt;&quot; -&amp;gt; &quot;&lt;/span&gt;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遍历结果如下：&lt;br/&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160172288975.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在本小节的最后，抛两个问题给大家。在 JDK 1.8 版本中，为了避免过长的链表对 HashMap 性能的影响，特地引入了红黑树优化性能。但在上面的源码中并没有发现红黑树遍历的相关逻辑，这是为什么呢？对于被转换成红黑树的链表该如何遍历呢？大家可以先想想，然后可以去源码或本文后续章节中找答案。&lt;/p&gt;
&lt;h3 id=&quot;插入&quot;&gt;3.4 插入&lt;/h3&gt;
&lt;h4 id=&quot;插入逻辑分析&quot;&gt;3.4.1 插入逻辑分析&lt;/h4&gt;
&lt;p&gt;通过前两节的分析，大家对 HashMap 低层的数据结构应该了然于心了。即使我不说，大家也应该能知道 HashMap 的插入流程是什么样的了。首先肯定是先定位要插入的键值对属于哪个桶，定位到桶后，再判断桶是否为空。如果为空，则将键值对存入即可。如果不为空，则需将键值对接在链表最后一个位置，或者更新键值对。这就是 HashMap 的插入流程，是不是觉得很简单。当然，大家先别高兴。这只是一个简化版的插入流程，真正的插入流程要复杂不少。首先 HashMap 是变长集合，所以需要考虑扩容的问题。其次，在 JDK 1.8 中，HashMap 引入了红黑树优化过长链表，这里还要考虑多长的链表需要进行优化，优化过程又是怎样的问题。引入这里两个问题后，大家会发现原本简单的操作，现在略显复杂了。在本节中，我将先分析插入操作的源码，扩容、树化（链表转为红黑树，下同）以及其他和树结构相关的操作，随后将在独立的两小结中进行分析。接下来，先来看一下插入操作的源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(K key, V value) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;putVal&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key, value, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
}

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;putVal&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, K key, V value, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; onlyIfAbsent,
               &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, i;
    &lt;span class=&quot;co&quot;&gt;// 初始化桶数组 table，table 被延迟到插入新数据时再进行初始化&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
        n = (tab = &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 如果桶中不包含键值对节点引用，则将新键值对节点的引用存入桶中即可&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((p = tab[i = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
        tab[i] = &lt;span class=&quot;fu&quot;&gt;newNode&lt;/span&gt;(hash, key, value, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        Node&amp;lt;K,V&amp;gt; e; K k;
        &lt;span class=&quot;co&quot;&gt;// 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
            ((k = p.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
            e = p;
            
        &lt;span class=&quot;co&quot;&gt;// 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)  
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).&lt;span class=&quot;fu&quot;&gt;putTreeVal&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, tab, hash, key, value);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 对链表进行遍历，并统计链表长度&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; binCount = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; ; ++binCount) {
                &lt;span class=&quot;co&quot;&gt;// 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;newNode&lt;/span&gt;(hash, key, value, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
                    &lt;span class=&quot;co&quot;&gt;// 如果链表长度大于或等于树化阈值，则进行树化操作&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// -1 for 1st&lt;/span&gt;
                        &lt;span class=&quot;fu&quot;&gt;treeifyBin&lt;/span&gt;(tab, hash);
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                }
                
                &lt;span class=&quot;co&quot;&gt;// 条件为 true，表示当前链表包含要插入的键值对，终止遍历&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
                    ((k = e.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                p = e;
            }
        }
        
        &lt;span class=&quot;co&quot;&gt;// 判断要插入的键值对是否存在 HashMap 中&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) { &lt;span class=&quot;co&quot;&gt;// existing mapping for key&lt;/span&gt;
            V oldValue = e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
            &lt;span class=&quot;fu&quot;&gt;afterNodeAccess&lt;/span&gt;(e);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldValue;
        }
    }
    ++modCount;
    &lt;span class=&quot;co&quot;&gt;// 键值对数量超过阈值时，则进行扩容&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (++size &amp;gt; threshold)
        &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;();
    &lt;span class=&quot;fu&quot;&gt;afterNodeInsertion&lt;/span&gt;(evict);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入操作的入口方法是 &lt;code&gt;put(K,V)&lt;/code&gt;，但核心逻辑在&lt;code&gt;V putVal(int, K, V, boolean, boolean)&lt;/code&gt; 方法中。putVal 方法主要做了这么几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当桶数组 table 为空时，通过扩容的方式初始化 table&lt;/li&gt;
&lt;li&gt;查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值&lt;/li&gt;
&lt;li&gt;如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树&lt;/li&gt;
&lt;li&gt;判断键值对数量是否大于阈值，大于的话则进行扩容操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是 HashMap 插入的逻辑，并不是很复杂，这里就不多说了。接下来来分析一下扩容机制。&lt;/p&gt;
&lt;h4 id=&quot;扩容机制&quot;&gt;3.4.2 扩容机制&lt;/h4&gt;
&lt;p&gt;在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。建小了不够用，建大了用不完，造成浪费。如果我们能实现一种变长的数组，并按需分配空间就好了。好在，我们不用自己实现变长数组，Java 集合框架已经实现了变长的数据结构。比如 ArrayList 和 HashMap。对于这类基于数组的变长数据结构，扩容是一个非常重要的操作。下面就来聊聊 HashMap 的扩容机制。&lt;/p&gt;
&lt;p&gt;在详细分析之前，先来说一下扩容相关的背景知识：&lt;/p&gt;
&lt;p&gt;在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。&lt;/p&gt;
&lt;p&gt;HashMap 的扩容机制与其他变长集合的套路不太一样，HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。以上就是 HashMap 的扩容大致过程，接下来我们来看看具体的实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;() {
    Node&amp;lt;K,V&amp;gt;[] oldTab = table;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; : oldTab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldThr = threshold;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCap, newThr = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 如果 table 不为空，表明已经初始化过了&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 当 table 容量超过容量最大值，则不再扩容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldTab;
        } 
        &lt;span class=&quot;co&quot;&gt;// 按旧容量和阈值的2倍计算新容量和阈值的大小&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                 oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// double threshold&lt;/span&gt;
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldThr &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// initial capacity was placed in threshold&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 初始化时，将 threshold 的值赋值给 newCap，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt; 
        newCap = oldThr;
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {               &lt;span class=&quot;co&quot;&gt;// zero initial threshold signifies using defaults&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 调用无参构造方法时，桶数组容量为默认容量，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 阈值为默认容量与默认负载因子乘积&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    
    &lt;span class=&quot;co&quot;&gt;// newThr 为 0 时，按阈值计算公式进行计算&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newThr == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt; ft = (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)newCap * loadFactor;
        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span class=&quot;dt&quot;&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
                  (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;)ft : Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;);
    }
    threshold = newThr;
    &lt;span class=&quot;co&quot;&gt;// 创建新的桶数组，桶数组的初始化也是在这里完成的&lt;/span&gt;
    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node[newCap];
    table = newTab;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldTab != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; oldCap; ++j) {
            Node&amp;lt;K,V&amp;gt; e;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                oldTab[j] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    newTab[e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; &amp;amp; (newCap - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)] = e;
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                    &lt;span class=&quot;co&quot;&gt;// 重新映射时，需要对红黑树进行拆分&lt;/span&gt;
                    ((TreeNode&amp;lt;K,V&amp;gt;)e).&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, newTab, j, oldCap);
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;co&quot;&gt;// preserve order&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; loHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, loTail = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                    Node&amp;lt;K,V&amp;gt; hiHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, hiTail = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                    Node&amp;lt;K,V&amp;gt; next;
                    &lt;span class=&quot;co&quot;&gt;// 遍历链表，并将链表节点按原顺序进行分组&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                        next = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
                        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; &amp;amp; oldCap) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loTail == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                                loHead = e;
                            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                                loTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = e;
                            loTail = e;
                        }
                        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hiTail == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                                hiHead = e;
                            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                                hiTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = e;
                            hiTail = e;
                        }
                    } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = next) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
                    &lt;span class=&quot;co&quot;&gt;// 将分组后的链表映射到新桶中&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loTail != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        loTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                        newTab[j] = loHead;
                    }
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hiTail != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        hiTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; newTab;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的源码有点长，希望大家耐心看懂它的逻辑。上面的源码总共做了3件事，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算新桶数组的容量 newCap 和新阈值 newThr&lt;/li&gt;
&lt;li&gt;根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的&lt;/li&gt;
&lt;li&gt;将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面列的三点中，创建新的桶数组就一行代码，不用说了。接下来，来说说第一点和第三点，先说说 newCap 和 newThr 计算过程。该计算过程对应 resize 源码的第一和第二个条件分支，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 第一个条件分支&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( oldCap &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    &lt;span class=&quot;co&quot;&gt;// 嵌套条件分支&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {...}
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                 oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY) {...}
} 
&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldThr &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {...}
&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {...}

&lt;span class=&quot;co&quot;&gt;// 第二个条件分支&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newThr == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {...}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这两个条件分支对不同情况进行判断，进而算出不同的容量值和阈值。它们所覆盖的情况如下：&lt;/p&gt;
&lt;p&gt;分支一：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;oldCap &amp;gt; 0&lt;/td&gt;
&lt;td&gt;桶数组 table 已经被初始化&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;oldThr &amp;gt; 0&lt;/td&gt;
&lt;td&gt;threshold &amp;gt; 0，且桶数组未被初始化&lt;/td&gt;
&lt;td&gt;调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;oldCap == 0 &amp;amp;&amp;amp; oldThr == 0&lt;/td&gt;
&lt;td&gt;桶数组未被初始化，且 threshold 为 0&lt;/td&gt;
&lt;td&gt;调用 HashMap() 构造方法会产生这种情况。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里把&lt;code&gt;oldThr &amp;gt; 0&lt;/code&gt;情况单独拿出来说一下。在这种情况下，会将 oldThr 赋值给 newCap，等价于&lt;code&gt;newCap = threshold = tableSizeFor(initialCapacity)&lt;/code&gt;。我们在初始化时传入的 initialCapacity 参数经过 threshold 中转最终赋值给了 newCap。这也就解答了前面提的一个疑问：initialCapacity 参数没有被保存下来，那么它怎么参与桶数组的初始化过程的呢？&lt;/p&gt;
&lt;p&gt;嵌套分支：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;oldCap &amp;gt;= 2&lt;sup&gt;30&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;桶数组容量大于或等于最大桶容量 2&lt;sup&gt;30&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;这种情况下不再扩容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;newCap &amp;lt; 2&lt;sup&gt;30&lt;/sup&gt; &amp;amp;&amp;amp; oldCap &amp;gt; 16&lt;/td&gt;
&lt;td&gt;新桶数组容量小于最大值，且旧桶数组容量大于 16&lt;/td&gt;
&lt;td&gt;该种情况下新阈值 newThr = oldThr &amp;lt;&amp;lt; 1，移位可能会导致溢出&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里简单说明一下移位导致的溢出情况，当 loadFactor小数位为 0，整数位可被2整除且大于等于8时，在某次计算中就可能会导致 newThr 溢出归零。见下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160915272993.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分支二：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;newThr == 0&lt;/td&gt;
&lt;td&gt;第一个条件分支未计算 newThr 或嵌套分支在计算过程中导致 newThr 溢出归零&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;说完 newCap 和 newThr 的计算过程，接下来再来分析一下键值对节点重新映射的过程。&lt;/p&gt;
&lt;p&gt;在 JDK 1.8 中，重新映射节点需要考虑节点类型。对于树形节点，需先拆分红黑树再映射。对于链表类型节点，则需先对链表进行分组，然后再映射。需要的注意的是，分组后，组内节点相对位置保持不变。关于红黑树拆分的逻辑将会放在下一小节说明，先来看看链表是怎样进行分组映射的。&lt;/p&gt;
&lt;p&gt;我们都知道往底层数据结构中插入节点时，一般都是先通过模运算计算桶位置，接着把节点放入桶中即可。事实上，我们可以把重新映射看做插入操作。在 JDK 1.7 中，也确实是这样做的。但在 JDK 1.8 中，则对这个过程进行了一定的优化，逻辑上要稍微复杂一些。在详细分析前，我们先来回顾一下 hash 求余的过程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160962033713.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图中，桶数组大小 n = 16，hash1 与 hash2 不相等。但因为只有后4位参与求余，所以结果相等。当桶数组扩容后，n 由16变成了32，对上面的 hash 值重新进行映射：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15160965715169.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;扩容后，参与模运算的位数由4位变为了5位。由于两个 hash 第5位的值是不一样，所以两个 hash 算出的结果也不一样。上面的计算过程并不难理解，继续往下分析。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15162009417224.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设我们上图的桶数组进行扩容，扩容后容量 n = 16，重新映射过程如下:&lt;/p&gt;
&lt;p&gt;依次遍历链表，并计算节点 &lt;code&gt;hash &amp;amp; oldCap&lt;/code&gt; 的值。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15162009755513.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果值为0，将 loHead 和 loTail 指向这个节点。如果后面还有节点 hash &amp;amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点。如果值为1的话，则让 hiHead 和 hiTail 指向该节点。完成遍历后，可能会得到两条链表，此时就完成了链表分组：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161040950151.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后再将这两条链接存放到相应的桶中，完成扩容。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15162010230589.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上图可以发现，重新映射后，两条链表中的节点顺序并未发生变化，还是保持了扩容前的顺序。以上就是 JDK 1.8 中 HashMap 扩容的代码讲解。另外再补充一下，JDK 1.8 版本下 HashMap 扩容效率要高于之前版本。如果大家看过 JDK 1.7 的源码会发现，JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在计算 hash 过程中引入随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率。&lt;/p&gt;
&lt;p&gt;本小节的内容讲就先讲到这，接下来，来讲讲链表与红黑树相互转换的过程。&lt;/p&gt;
&lt;h4 id=&quot;链表树化红黑树链化与拆分&quot;&gt;3.4.3 链表树化、红黑树链化与拆分&lt;/h4&gt;
&lt;p&gt;JDK 1.8 对 HashMap 实现进行了改进。最大的改进莫过于在引入了红黑树处理频繁的碰撞，代码复杂度也随之上升。比如，以前只需实现一套针对链表操作的方法即可。而引入红黑树后，需要另外实现红黑树相关的操作。红黑树是一种自平衡的二叉查找树，本身就比较复杂。本篇文章中并不打算对红黑树展开介绍，本文仅会介绍链表树化需要注意的地方。至于红黑树详细的介绍，如果大家有兴趣，可以参考我的另一篇文章 - &lt;a href=&quot;http://www.coolblog.xyz/2018/01/11/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/&quot;&gt;红黑树详细分析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在展开说明之前，先把树化的相关代码贴出来，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; TREEIFY_THRESHOLD = &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 当桶数组容量小于该值时，优先进行扩容，而不是树化&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MIN_TREEIFY_CAPACITY = &lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;;

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; LinkedHashMap.&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; {
    TreeNode&amp;lt;K,V&amp;gt; parent;  &lt;span class=&quot;co&quot;&gt;// red-black tree links&lt;/span&gt;
    TreeNode&amp;lt;K,V&amp;gt; left;
    TreeNode&amp;lt;K,V&amp;gt; right;
    TreeNode&amp;lt;K,V&amp;gt; prev;    &lt;span class=&quot;co&quot;&gt;// needed to unlink next upon deletion&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; red;
    TreeNode(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(hash, key, val, next);
    }
}

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 将普通节点链表转换成树形节点链表&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;treeifyBin&lt;/span&gt;(Node&amp;lt;K,V&amp;gt;[] tab, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, index; Node&amp;lt;K,V&amp;gt; e;
    &lt;span class=&quot;co&quot;&gt;// 桶数组容量小于 MIN_TREEIFY_CAPACITY，优先进行扩容而不是树化&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tab == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) &amp;lt; MIN_TREEIFY_CAPACITY)
        &lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = tab[index = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// hd 为头节点（head），tl 为尾节点（tail）&lt;/span&gt;
        TreeNode&amp;lt;K,V&amp;gt; hd = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, tl = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 将普通节点替换成树形节点&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; p = &lt;span class=&quot;fu&quot;&gt;replacementTreeNode&lt;/span&gt;(e, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tl == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                hd = p;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                p.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = tl;
                tl.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = p;
            }
            tl = p;
        } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// 将普通链表转成由树形节点链表&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab[index] = hd) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;co&quot;&gt;// 将树形链表转换成红黑树&lt;/span&gt;
            hd.&lt;span class=&quot;fu&quot;&gt;treeify&lt;/span&gt;(tab);
    }
}

TreeNode&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;replacementTreeNode&lt;/span&gt;(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt; next) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TreeNode&amp;lt;&amp;gt;(p.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;, p.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;, p.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;, next);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在扩容过程中，树化要满足两个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;链表长度大于等于 TREEIFY_THRESHOLD&lt;/li&gt;
&lt;li&gt;桶数组容量大于等于 MIN_TREEIFY_CAPACITY&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一个条件比较好理解，这里就不说了。这里来说说加入第二个条件的原因，个人觉得原因如下：&lt;/p&gt;
&lt;p&gt;当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。同时，桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事。&lt;/p&gt;
&lt;p&gt;回到上面的源码中，我们继续看一下 treeifyBin 方法。该方法主要的作用是将普通链表转成为由 TreeNode 型节点组成的链表，并在最后调用 treeify 是将该链表转为红黑树。TreeNode 继承自 Node 类，所以 TreeNode 仍然包含 next 引用，原链表的节点顺序最终通过 next 引用被保存下来。我们假设树化前，链表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15162026592538.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HashMap 在设计之初，并没有考虑到以后会引入红黑树进行优化。所以并没有像 TreeMap 那样，要求键类实现 comparable 接口或提供相应的比较器。但由于树化过程需要比较两个键对象的大小，在键类没有实现 comparable 接口的情况下，怎么比较键与键之间的大小了就成了一个棘手的问题。为了解决这个问题，HashMap 是做了三步处理，确保可以比较出两个键的大小，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较&lt;/li&gt;
&lt;li&gt;检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较&lt;/li&gt;
&lt;li&gt;如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder（大家自己看源码吧）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;tie break 是网球术语，可以理解为加时赛的意思，起这个名字还是挺有意思的。&lt;/p&gt;
&lt;p&gt;通过上面三次比较，最终就可以比较出孰大孰小。比较出大小后就可以构造红黑树了，最终构造出的红黑树如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161226696106.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;橙色的箭头表示 TreeNode 的 next 引用。由于空间有限，prev 引用未画出。可以看出，链表转成红黑树后，原链表的顺序仍然会被引用仍被保留了（红黑树的根节点会被移动到链表的第一位），我们仍然可以按遍历链表的方式去遍历上面的红黑树。这样的结构为后面红黑树的切分以及红黑树转成链表做好了铺垫，我们继续往下分析。&lt;/p&gt;
&lt;h5 id=&quot;红黑树拆分&quot;&gt;红黑树拆分&lt;/h5&gt;
&lt;p&gt;扩容后，普通节点需要重新映射，红黑树节点也不例外。按照一般的思路，我们可以先把红黑树转成链表，之后再重新映射链表即可。这种处理方式是大家比较容易想到的，但这样做会损失一定的效率。不同于上面的处理方式，HashMap 实现的思路则是上好佳（上好佳请把广告费打给我）。如上节所说，在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序。这样再对红黑树进行重新映射时，完全可以按照映射链表的方式进行。这样就避免了将红黑树转成链表后再进行映射，无形中提高了效率。&lt;/p&gt;
&lt;p&gt;以上就是红黑树拆分的逻辑，下面看一下具体实现吧：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 红黑树转链表阈值&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; UNTREEIFY_THRESHOLD = &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;;

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; bit) {
    TreeNode&amp;lt;K,V&amp;gt; b = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// Relink into lo and hi lists, preserving order&lt;/span&gt;
    TreeNode&amp;lt;K,V&amp;gt; loHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, loTail = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    TreeNode&amp;lt;K,V&amp;gt; hiHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, hiTail = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lc = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, hc = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;/* &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 下面的循环是对红黑树节点进行分组，与上面类似&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; e = b, next; e != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; e = next) {
        next = (TreeNode&amp;lt;K,V&amp;gt;)e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; &amp;amp; bit) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = loTail) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                loHead = e;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                loTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = e;
            loTail = e;
            ++lc;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = hiTail) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                hiHead = e;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                hiTail.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = e;
            hiTail = e;
            ++hc;
        }
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loHead != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (lc &amp;lt;= UNTREEIFY_THRESHOLD)
            tab[index] = loHead.&lt;span class=&quot;fu&quot;&gt;untreeify&lt;/span&gt;(map);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            tab[index] = loHead;
            &lt;span class=&quot;co&quot;&gt;/* &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             * hiHead == null 时，表明扩容后，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             * 所有节点仍在原位置，树结构不变，无需重新树化&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;             */&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hiHead != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) 
                loHead.&lt;span class=&quot;fu&quot;&gt;treeify&lt;/span&gt;(tab);
        }
    }
    &lt;span class=&quot;co&quot;&gt;// 与上面类似&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hiHead != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hc &amp;lt;= UNTREEIFY_THRESHOLD)
            tab[index + bit] = hiHead.&lt;span class=&quot;fu&quot;&gt;untreeify&lt;/span&gt;(map);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            tab[index + bit] = hiHead;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loHead != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                hiHead.&lt;span class=&quot;fu&quot;&gt;treeify&lt;/span&gt;(tab);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从源码上可以看得出，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于 UNTREEIFY_THRESHOLD，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化。举个例子说明一下，假设扩容后，重新映射上图的红黑树，映射结果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.coolblog.xyz/&quot;&gt;&lt;img src=&quot;https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15161648473103.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;红黑树链化&quot;&gt;红黑树链化&lt;/h5&gt;
&lt;p&gt;前面说过，红黑树中仍然保留了原链表节点顺序。有了这个前提，再将红黑树转成链表就简单多了，仅需将 TreeNode 链表转成 Node 类型的链表即可。相关代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;untreeify&lt;/span&gt;(HashMap&amp;lt;K,V&amp;gt; map) {
    Node&amp;lt;K,V&amp;gt; hd = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, tl = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 遍历 TreeNode 链表，并用 Node 替换&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; q = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;; q != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; q = q.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 替换节点类型&lt;/span&gt;
        Node&amp;lt;K,V&amp;gt; p = map.&lt;span class=&quot;fu&quot;&gt;replacementNode&lt;/span&gt;(q, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (tl == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            hd = p;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            tl.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = p;
        tl = p;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; hd;
}

Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;replacementNode&lt;/span&gt;(Node&amp;lt;K,V&amp;gt; p, Node&amp;lt;K,V&amp;gt; next) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(p.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;, p.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;, p.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;, next);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码并不复杂，不难理解，这里就不多说了。到此扩容相关内容就说完了，不知道大家理解没。&lt;/p&gt;
&lt;h3 id=&quot;删除&quot;&gt;3.5 删除&lt;/h3&gt;
&lt;p&gt;如果大家坚持看完了前面的内容，到本节就可以轻松一下。当然，前提是不去看红黑树的删除操作。不过红黑树并非本文讲解重点，本节中也不会介绍红黑树相关内容，所以大家不用担心。&lt;/p&gt;
&lt;p&gt;HashMap 的删除操作并不复杂，仅需三个步骤即可完成。第一步是定位桶位置，第二步遍历链表并找到键值相等的节点，第三步删除节点。相关源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;30&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(Object key) {
    Node&amp;lt;K,V&amp;gt; e;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (e = &lt;span class=&quot;fu&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt;(key), key, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ?
        &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : e.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
}

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;fu&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hash, Object key, Object value,
                           &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; matchValue, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; movable) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, index;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((tab = table) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
        &lt;span class=&quot;co&quot;&gt;// 1. 定位桶位置&lt;/span&gt;
        (p = tab[index = (n - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &amp;amp; hash]) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        Node&amp;lt;K,V&amp;gt; node = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, e; K k; V v;
        &lt;span class=&quot;co&quot;&gt;// 如果键的值与链表第一个节点相等，则将 node 指向该节点&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
            ((k = p.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key || (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k))))
            node = p;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((e = p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {  
            &lt;span class=&quot;co&quot;&gt;// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                node = ((TreeNode&amp;lt;K,V&amp;gt;)p).&lt;span class=&quot;fu&quot;&gt;getTreeNode&lt;/span&gt;(hash, key);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 2. 遍历链表，找到待删除节点&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e.&lt;span class=&quot;fu&quot;&gt;hash&lt;/span&gt; == hash &amp;amp;&amp;amp;
                        ((k = e.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == key ||
                         (key != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(k)))) {
                        node = e;
                        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
                    }
                    p = e;
                } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((e = e.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            }
        }
        
        &lt;span class=&quot;co&quot;&gt;// 3. 删除节点，并修复链表或红黑树&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!matchValue || (v = node.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;) == value ||
                             (value != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; value.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(v)))) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; TreeNode)
                ((TreeNode&amp;lt;K,V&amp;gt;)node).&lt;span class=&quot;fu&quot;&gt;removeTreeNode&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, tab, movable);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node == p)
                tab[index] = node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
            ++modCount;
            --size;
            &lt;span class=&quot;fu&quot;&gt;afterNodeRemoval&lt;/span&gt;(node);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; node;
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除操作本身并不复杂，有了前面的基础，理解起来也就不难了，这里就不多说了。&lt;/p&gt;
&lt;h3 id=&quot;其他细节&quot;&gt;3.6 其他细节&lt;/h3&gt;
&lt;p&gt;前面的内容分析了 HashMap 的常用操作及相关的源码，本节内容再补充一点其他方面的东西。&lt;/p&gt;
&lt;h4 id=&quot;被-transient-所修饰-table-变量&quot;&gt;被 transient 所修饰 table 变量&lt;/h4&gt;
&lt;p&gt;如果大家细心阅读 HashMap 的源码，会发现桶数组 table 被申明为 transient。transient 表示易变的意思，在 Java 中，被该关键字修饰的变量不会被默认的序列化机制序列化。我们再回到源码中，考虑一个问题：桶数组 table 是 HashMap 底层重要的数据结构，不序列化的话，别人还怎么还原呢？&lt;/p&gt;
&lt;p&gt;这里简单说明一下吧，HashMap 并没有使用默认的序列化机制，而是通过实现&lt;code&gt;readObject/writeObject&lt;/code&gt;两个方法自定义了序列化的内容。这样做是有原因的，试问一句，HashMap 中存储的内容是什么？不用说，大家也知道是&lt;code&gt;键值对&lt;/code&gt;。所以只要我们把键值对序列化了，我们就可以根据键值对数据重建 HashMap。有的朋友可能会想，序列化 table 不是可以一步到位，后面直接还原不就行了吗？这样一想，倒也是合理。但序列化 talbe 存在着两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间&lt;/li&gt;
&lt;li&gt;同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上两个问题中，第一个问题比较好理解，第二个问题解释一下。HashMap 的&lt;code&gt;get/put/remove&lt;/code&gt;等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。&lt;/p&gt;
&lt;p&gt;综上所述，大家应该能明白 HashMap 不序列化 table 的原因了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;3.7 总结&lt;/h3&gt;
&lt;p&gt;本章对 HashMap 常见操作相关代码进行了详细分析，并在最后补充了一些其他细节。在本章中，插入操作一节的内容说的最多，主要是因为插入操作涉及的点特别多，一环扣一环。包含但不限于“table 初始化、扩容、树化”等，总体来说，插入操作分析起来难度还是很大的。好在，最后分析完了。&lt;/p&gt;
&lt;p&gt;本章篇幅虽比较大，但仍未把 HashMap 所有的点都分析到。比如，红黑树的增删查等操作。当然，我个人看来，以上的分析已经够了。毕竟大家是类库的使用者而不是设计者，没必要去弄懂每个细节。所以如果某些细节实在看不懂的话就跳过吧，对我们开发来说，知道 HashMap 大致原理即可。&lt;/p&gt;
&lt;p&gt;好了，本章到此结束。&lt;/p&gt;
&lt;h2 id=&quot;四写在最后&quot;&gt;四、写在最后&lt;/h2&gt;
&lt;p&gt;写到这里终于可以松一口气了，这篇文章前前后后花了我一周多的时间。在我写这篇文章之前，对 HashMap 认识仅限于原理层面，并未深入了解。一开始，我觉得关于 HashMap 没什么好写的，毕竟大家对 HashMap 多少都有一定的了解。但等我深入阅读 HashMap 源码后，发现之前的认知是错的。不是没什么可写的，而是可写的点太多了，不知道怎么写了。JDK 1.8 版本的 HashMap 实现上比之前版本要复杂的多，想弄懂众多的细节难度还是不小的。仅自己弄懂还不够，还要写出来，难度就更大了，本篇文章基本上是在边读源码边写的状态下完成的。由于时间和能力有限，加之文章篇幅比较大，很难保证不出错分析过程及配图不出错。如果有错误，希望大家指出来，我会及时修改，这里先谢谢大家。&lt;/p&gt;
&lt;p&gt;好了，本文就到这里了，谢谢大家的阅读！&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;blockquote readability=&quot;5.28125&quot;&gt;
&lt;p&gt;本文在知识共享许可协议 4.0 下发布，转载请注明出处&lt;br/&gt;作者：code4fun&lt;br/&gt;为了获得更好的分类阅读体验，&lt;br/&gt;请移步至本人的个人博客：&lt;a href=&quot;http://www.coolblog.xyz/&quot; class=&quot;uri&quot;&gt;http://www.coolblog.xyz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;&lt;img src=&quot;http://blog-pictures.oss-cn-shanghai.aliyuncs.com/cc.png&quot; alt=&quot;cc&quot;/&gt;&lt;/a&gt;&lt;br/&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot;&gt;知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Jan 2018 01:51:00 +0000</pubDate>
<dc:creator>code4funn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullllun/p/8327664.html</dc:identifier>
</item>
</channel>
</rss>