<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM GC-----垃圾回收算法 - 王若伊_恩赐解脱</title>
<link>http://www.cnblogs.com/jilodream/p/9038853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jilodream/p/9038853.html</guid>
<description>&lt;p&gt;&lt;span&gt;说到Java，一定绕不开GC，尽管不是Java首创的，但Java一定是使用GC的代表。GC就是垃圾回收，更直接点说就是内存回收。是对内存进行整理，从而使内存的使用尽可能大的被复用。 一直想好好写一篇关于GC的文章，可是却发现要写的东西太大了，不是一篇博客能简单的介绍完的。所以打算拆分成若干篇博客，一点点的总结下来。 本篇主要介绍的是GC中的常用算法。这些算法被广泛的应用于各个内存管理语言的虚拟机中，或者是各大常用的操作系统中。 说到GC，也就是垃圾回收，那么需要做的事有两件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第一件是查找到哪些内存中的对象是已经废弃掉的。&lt;br/&gt;第二件事是如何清理掉这些已经废弃掉的数据。&lt;br/&gt;本文先来说说后者，如何清除掉这些内存中的废弃数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1、标记清除算法Mark-Sweep&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这种算法是最简单最直接的算法，也是其它算法的一些最初思路。标记清除算法其实就是对内存中的对象依次的进行判断，如果对象需要回收那么就打一个标记，如果对象仍然需要使用，那么就保留下来。这样经过一次迭代之后，所有的对象都会被筛选判(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )断一次。紧接着会对内存中已经标记的对&lt;br/&gt;象依次进行清除。 这个算法比较简单粗暴，实现起来比较简单。&lt;br/&gt;但是会留下两个比较麻烦的问题：&lt;br/&gt; (1)标记和清除需要两遍循环内存中的对象，标记本身也是一个比较麻烦的工作，因此这种算法的效率不是特别的高。&lt;br/&gt; (2)对于分配的内存来说，往往是连续的比较好，因为这样有利于分配大数据的对象。倘若当前内存中都是小段的内存碎片，会知道需要分配大段内存时，没有可以放置的位置，而触发内存回收。也就是空间不足而导致频繁GC和性能下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704073/201805/704073-20180515002311953-306197864.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、复制算法Copying&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在使用数据库的过程中，曾经遇到这样一个问题，表中的数据量相对来说比较大，大概30万行，需要使用多个苛刻的条件删除其中的大部分数据（因此无法使用索引），而只保留其中的较少数据。常规的delete语法使用起来是超时的。于是我查看维护人员的sql，发现一个很有意思的逻辑。首先查出数据库表中需要保留的数据，放到一张临时表中。然后彻底删除掉原有的数据表。然后把这张临时创建表的表名，改为当初的表名。这是一种典型的空间换取时间的方法。而复制算法就是这样一个思路。 复制算法中，会将内存划分为两块相等大小的内存区域A/B，然后生成的数据会存放在A区，当A区剩余空间不足以存放下一个新创建的对象时，系统就会将A区中的有效对象全部复制到B区中，而且是连续存放的。然后直接清空A区中的所有对象。 由于编程语言中的对象，大部分在创建后很快就(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )会被回收掉，所以我们需要复制的对象其实并不多。 Java中的实现是这样的： Java中将Eden和Survivor区同时作为复制算法的使用区域。Survivor又分为From区和To区。这块内容可以参考我的另外一篇博客，博客中有详细的介绍：http://www.cnblogs.com/jilodream/p/6147791.html。每次GC的时候都会将Eden和Survivor的From区中的有效对象进行标记，一同复制到Survivor的To区。然后彻底清除原来的Eden区和From区的内存对象。与此同时To区就是下一次回收的From区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704073/201805/704073-20180514234714875-977222237.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复制算法的缺点： 算法使用了空间换取时间的思路，因此需要一块空白的区域作为内存对象要粘贴的区域。这无疑会造成一种浪费。尤其是内存较小时。 算法每次清除无效对象时，都要进行一次复制粘贴的对象转移，因此对使用场景是有限制的。只有在有效对象占据总回收内存是非常小的时候，这种算法的性价比才会达到最高。否则大量的复制动作所浪费的时间可能要远远大于空间换取时间得到的收益。因此这种算法在Jvm中，也只被用来作为初级的对象回收。因为这时的有效对象比例最低，算法的性价比是最高的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、 标记整理算法 Mark-Compact&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复制算法需要一块额外的内存空间，用于存放幸存的内存对象。这无疑造成了内存的浪费。我们还可以在原有的标记清除算法的基础上，提出了优化方案。也就是标记到的可用对象整体向一侧移动，然后直接清除掉可用对象边界意外的内存。(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )这样既解决了内存碎片的问题。又不需要原有的空间换时间的硬件浪费。由于老年代中的幸存对象较多，而且对象内存占用较大。这就使得一旦出现内存回收，需要被回收的对象并不多，碎片也就相对的比较少。所以不需要太多的复制和移动步骤。因此这种方法常常被应用到老年代中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;标记整理算法的缺点： 标记整理算法由于需要不断的移动对象到另外一侧，而这种不断的移动其实是非常不适合杂而多的小内存对象的。每次的移动和计算都是非常复杂的过程。因此在使用场景上，就注定限制了标记整理算法的使用不太适合频繁创建和回收对象的内存中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704073/201805/704073-20180514234740532-462297462.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、分代收集算法  Generational Collection&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种算法就是将内存以代的形式划分，然后针对情况分别使用性价比最高的算法进行处理。在Java中，一般将堆分为老年代和新生代。新创建的对象往往被放置在新生代中。而经过不断的回收，逐渐存活下来的对象被安置到了老年代中。越新的对象越可能被回收，越老的对象反而会存活的越久。因此针对这两种场景，新生代和老年代也会分别采用前文所述的两种算法进行清理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps：话说现在写篇博客越来越难了，今天以为画个图就可以发布了，结果画图画了一个小时。哎&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 May 2018 16:14:00 +0000</pubDate>
<dc:creator>王若伊_恩赐解脱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jilodream/p/9038853.html</dc:identifier>
</item>
<item>
<title>C++  模板基础 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/9031722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/9031722.html</guid>
<description>&lt;p&gt;&lt;span&gt;我们学习使用C++，肯定都要了解模板这个概念。就我自己的理解，模板其实就是为复用而生，&lt;span&gt;模板就是实现代码复用&lt;span&gt;机制的一&lt;span&gt;种工具，它可以实现类型参数化，即&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;把类型定义为参数；进而实现了真正的代码可重用性。模版&lt;span&gt;可以分为&lt;span&gt;两类：一&lt;span&gt;个是函数模版，另外一个是类模版。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个最简单的例子，当在编写好了一个进行int型交换的swap函数，而此后若又要进行double型交换，那就得重新写一个，如果又要交换string类型....这里就尴尬了。&lt;span&gt;使用模板的目的就是要让程序的实现与类型无关，比如这里将&lt;span&gt;swap弄成&lt;span&gt;模板函数，即可以实现&lt;span&gt;int&lt;span&gt; 型，又可&lt;span&gt;以实现&lt;span&gt;double型的交换&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;而针对函数模板，其格式是:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;&lt;span&gt;&lt;span&gt;template &amp;lt;&lt;span&gt;class &lt;span&gt;形参名1&lt;span&gt;, &lt;span&gt;class &lt;span&gt;形参名2, class &lt;span&gt;形参名n&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  返回类型 函数名(&lt;span&gt;参数列表)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　&lt;span&gt;{...&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;&lt;span&gt;&lt;span&gt; 如交换函数：&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
template&amp;lt;class T&amp;gt; 
void swap(T&amp;amp; a, T&amp;amp; b)
{....}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;值得注意的是&lt;/span&gt;：&lt;span&gt;&lt;span&gt;&lt;span&gt;模板进程形参的定义既可以使用class，也可以使用typename，含义是相同的&lt;/span&gt;&lt;span&gt;；再一个就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不&lt;span&gt;能&lt;span&gt;在main函数中声明或定义一个模板。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;实现机理&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;
&lt;hr/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模板&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，从字面意思上大致就能知道它只是一个模子，用的时候，还需我们进行一番修饰，也就是说写好的函数模板还不是直接使用的，只有在实例化的时候，编译器才会推演出我们要用的代码，推演的依据就正是我们传入的参数了。（&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这里，你可以去验证一下，比如先不调用函数，此时&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;将模板代码中的一句分号去掉，编译器并不会报错）。实质上，说的通俗一点，实例化的时候，如int a =1,b=2; swap(a, b)就是编译器编译时直接用int将T替换，以此实例化一份代码出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模板显示实例化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;
&lt;hr/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;前面我们值得使用函数模板时，编译器会针对参数的类型推演出相应的代码。如果我们在调用一个模板函数的时候，在&lt;span&gt;函数名后面加上&amp;lt;类型&amp;gt;&lt;/span&gt;，这时候系统不需要从形参这里推&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;断类型了。它&lt;span&gt;直接使用尖括号里面的类型就ok了。&lt;span&gt;返回类型形式是：&lt;span&gt;函数名&lt;/span&gt;&amp;lt;&lt;span&gt;类型&amp;gt;&lt;span&gt;(&lt;span&gt;参数列表&lt;span&gt;)&lt;span&gt;，接下来我们来验证一下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
 template&amp;lt;class T&amp;gt;
 void Swap(T&amp;amp; a, T&amp;amp;b)
 {
     T tmp = a;
     a = b;
     b = tmp;
 }
 void Test( )
 {
     int a =1, b=2;
     Swap&amp;lt;int&amp;gt;(a, b);  //显示实例化
     cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180514181608096-298667184.png&quot; alt=&quot;&quot; width=&quot;642&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;值得注意是此时模板中形参只有一种，所以调用swap函数不要传入两种类型不同的实参，这是不合法的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;相对来讲，模板函数算比较简单的，下面来看看模板类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模板类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;hr/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;它和模板函数类似，其格式如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
template&amp;lt;class 形参名1, class 形参名2, ...class 形参名n&amp;gt;  
class 类名
{ ... };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对于类模板，实例化时，模板形参的类型必须在类名后的尖括号中明确指定。举个例子，如&lt;span&gt;A&amp;lt;10&amp;gt; m&lt;/span&gt;， 这样是绝对不行的，&lt;span&gt;类模板中是不存在实参类型的推断；也不能直接A a这样定义，道理很明显，这样编译器没法推演。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;然后&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;在类模板外部定义成员函数的方法为&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
 template&amp;lt;模板形参列表&amp;gt;
函数返回类型 类名&amp;lt;模板形参名&amp;gt;::函数名(参数列表){函数体}，
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;比如有两个模板形参&lt;span&gt;T1，&lt;span&gt;T2的类&lt;span&gt;A中含有一个&lt;span&gt;void f()函数，则定义该函数的语法为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;template&amp;lt;class T1,class T2&amp;gt; void A&amp;lt;T1,T2&amp;gt;::f(){}。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;：当在类外面定义类的成员时&lt;span&gt;template后面的模板形参应与要定义的类的模板形参一致。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;strong&gt;&lt;span&gt;来个实例，实现一个简易带头双向链表：&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
 /*************************************************************************
   &amp;gt; File Name: List.cc
   &amp;gt; Author: tp
   &amp;gt; Mail: 
   &amp;gt; Created Time: Sat 05 May 2018 08:39:46 PM CST
  ************************************************************************/
 
 #include &amp;lt;iostream&amp;gt;
 #include &amp;lt;string&amp;gt;
 #include &amp;lt;cassert&amp;gt;
 using namespace std;
 
 template&amp;lt;class T&amp;gt;
 struct ListNode
 { 
     T _val;
     ListNode* _prev;
     ListNode* _next;
     ListNode(const T&amp;amp; x)
         :_val(x), _prev( NULL),_next( NULL)
     { }
 };
 
 template&amp;lt;class T&amp;gt;
 class List
 { 
     typedef ListNode&amp;lt;T&amp;gt; Node;
 public:
     List()  
     :_head(new Node(T()))  
     { 
         _head-&amp;gt;_prev = _head;
         _head-&amp;gt;_next = _head;
     }
     void PushBack(const T&amp;amp; x)
     { 
         Insert(_head, x);
     }
     void PopBack() 
     { 
         Erase( _head-&amp;gt;_prev);
     }
     void PushFront(const T&amp;amp; x)
     { 
         Insert(_head-&amp;gt;_next, x);
     }
     void PopFront() 
     { 
         Erase(_head-&amp;gt;_next);
     }
     void Insert(Node* pos, const T&amp;amp; x) 
     { 
         assert( pos);
         Node* prev = pos-&amp;gt;_prev;
         //prev newnode  pos
         Node* newnode = new Node(x);
         prev-&amp;gt;_next = newnode;
         newnode-&amp;gt;_prev = prev;
 
         newnode-&amp;gt;_next = pos;
         pos-&amp;gt;_prev = newnode;
     } 
     void Erase(Node* pos)
     { 
         assert( pos &amp;amp;&amp;amp; pos != _head);
         //能删头结点？
         Node* prev = pos-&amp;gt;_prev;
         Node* next = pos-&amp;gt;_next;
         delete pos;
         prev-&amp;gt;_next = next;
         next-&amp;gt;_prev = prev;
     }
     bool Empty() 
     { 
         return _head == _head-&amp;gt;_next;
     }
     Node* Find(const T&amp;amp; x)  
     { 
         Node* cur = _head-&amp;gt;_next;
         while( cur != _head)
         { 
             if( cur-&amp;gt;_val == x)
                 return cur;
             cur = cur-&amp;gt;_next;
         }
         return NULL;
     }
     //以O( 1)的时间复杂度, 多开4字节进行计数,不能让头结点存计数，因为类型不确定
     //这里普通做法
     size_t Size() 
     { 
         size_t count = 0;
         Node* cur = _head-&amp;gt;_next;   
         while( cur != _head)
         { 
             ++count;
             cur = cur-&amp;gt;_next;
         }
         return count;
     }
 
     void Clear( )
     { 
         Node* cur = _head-&amp;gt;_next;
         while(cur != _head)
         { 
             Node* next = cur-&amp;gt;_next;
             delete cur;
             cur = next;
         }
     }
     ~List( )
     { 
         Clear();
         _head = NULL;
     }
     void Print();
 protected:
     Node* _head;
 };
 template&amp;lt;class T&amp;gt;
 void List&amp;lt;T&amp;gt;::Print()
 { 
     Node* cur = _head-&amp;gt;_next;
     while( cur != _head)
     { 
         cout&amp;lt;&amp;lt;cur-&amp;gt;_val&amp;lt;&amp;lt;&quot; &quot;;
         cur = cur-&amp;gt;_next;
     }
     cout&amp;lt;&amp;lt;endl;
 }
 int main( )
 { 
     List&amp;lt;int&amp;gt; l;
     l.PushBack(1);
     l.PushBack(2);
     l.PushBack(3);
     l.PushBack(4);
     l.PopBack( );
     l.Print();
     cout&amp;lt;&amp;lt;l.Size( )&amp;lt;&amp;lt;endl;
 
     List&amp;lt;string&amp;gt; l1;
     l1.PushBack( &quot; 11&quot;);
     l1.PushBack( &quot; 1i32&quot;);
     l1.PushBack( &quot; 1112019jhja&quot;);
     l1.PushBack( &quot; 11&quot;);
     l1.Print( );
     return 0;
 }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;div readability=&quot;64&quot;&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;模板中的形参&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;·类型形参&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 接下我们来看模板的形参，&lt;span&gt;&lt;span&gt;类型形参由关见字class或typename后接说明符构成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;           template&amp;lt;class T&amp;gt; void func(T a){}&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其中&lt;span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&lt;span&gt;就是一个类型形参，表示一种类型&lt;/span&gt;，类型形参的名字由用户自已确定。&lt;span&gt;&lt;span&gt;模板形参表示的是一个未知的类型&lt;span&gt;。模板类&lt;span&gt;型形参可作为类型说明符，可用在模板中的任何地&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方；它与内置类型说明符或类类型说明符的使用方式完全相同&lt;span&gt;，即可以用于指定返回类型，变量声明等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是注意&lt;span&gt;&lt;span&gt;不能为同一个模板类型形参指定两种不同的类型&lt;/span&gt;，比如&lt;span&gt;&lt;strong&gt;&lt;span&gt;template&amp;lt;class T&amp;gt; void func(T&amp;amp; a, T&amp;amp; b){}&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;语句调用&lt;strong&gt;func&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;(2, 2.1&lt;/strong&gt;)&lt;span&gt;将出错，因为该语句给同一模板形&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;参&lt;span&gt;T&lt;span&gt;指定了两种类型，第一个实参&lt;span&gt;2&lt;span&gt;把模板形参T指定为&lt;span&gt;int&lt;span&gt;，而&lt;span&gt;第二个实参2.1&lt;span&gt;把模板形参指定为&lt;span&gt;double&lt;span&gt;，两种类型的形参不一致，会出错。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当然在模板类中，这样也会有不合适，但是在这里是一个警告。&lt;span&gt;但是记住，无论是模板函数还是模板类都不要这样用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·非类型模板形参&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;94&quot;&gt;
&lt;p&gt;&lt;span&gt;非类型模板形参：&lt;span&gt;&lt;span&gt;模板的非类型形参也就是内置类型形参&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如:&lt;span&gt;template&amp;lt;class T, int a&amp;gt; class A{};&lt;/span&gt;其中&lt;span&gt;&lt;strong&gt;int a&lt;/strong&gt; 就是非类型的模板形式参。&lt;/span&gt;&lt;span&gt;非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板的内部是常量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
 #include &amp;lt;iostream&amp;gt;
 using namespace std;
 
 template&amp;lt;class T, int b&amp;gt;
 class A
 {
 public:
         A()
             :a(b){}
         void show( )
         {cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;}
 protected:
     T a;
 };
 int main(void)
 {
     const int i = 10;
     A&amp;lt;int, i&amp;gt; a;
     a.show();
     return 0;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1. &lt;span&gt;&lt;span&gt;调用非类型模板形参的&lt;span&gt;&lt;strong&gt;实参&lt;/strong&gt;&lt;/span&gt;必须是一个常量表达式，即它必须能在编译时计算出结果。&lt;span&gt;&lt;span&gt;sizeof表达式的结果是一个常量表达式，&lt;span&gt;&lt;span&gt;&lt;span&gt;全局变量的地址或引用，全局对象的地址或引用const类型变量也是常量表达式 ，它们&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可以用作非类型模板形参的实参。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. &lt;span&gt;&lt;span&gt;&lt;span&gt;非类型&lt;span&gt;&lt;span&gt;模板的&lt;span&gt;形参&lt;/span&gt;只能是整型，指针和引用，像double，String, String **这样的类型是不允许的。&lt;span&gt;但是&lt;span&gt;double &amp;amp;，double *，对象的引用或指针则是可以的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. &lt;span&gt;任何局部对象，局部变量，局部对象的地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能用作非类型模&lt;/span&gt;板形参的实参。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、当模板的形参是整型时调用该模板时的实参必须是整型的，且在编译期间是常量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：&lt;span&gt;template &amp;lt;class T, int a&amp;gt; class A{};&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有&lt;span&gt;int b，这时A&amp;lt;int, b&amp;gt; m;将出错，因为&lt;span&gt;b不是常量，如果&lt;span&gt;const int b，这时A&amp;lt;int, b&amp;gt; m;就是正确的，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;因为这时&lt;span&gt;b是常量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.&lt;span&gt; &lt;span&gt;非类型模板形参的形参和实参间所允许的转换:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180514183546349-1223129570.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;·模板形参&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 类模板的类型形参默认值形式为：&lt;span&gt;template&amp;lt;class T1, class T2=int&amp;gt; class A{...}，这样来为&lt;span&gt;&lt;span&gt;模板&lt;/span&gt;&lt;/span&gt;中的第二个形参&lt;span&gt;T2提供&lt;span&gt;int型的默认值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2&lt;span&gt;&lt;span&gt;、模板形参&lt;span&gt;&lt;span&gt;可以为&lt;span&gt;类模板&lt;/span&gt;的类型形参提供默认值，但不能为&lt;span&gt;函数模板&lt;/span&gt;的类型形参提供默认值。函数模板和类模板都可以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;为模板的非类型形参提供默认值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;strong&gt;类模板类型形参&lt;span&gt;添加&lt;/span&gt;默认值的规则和函数默认参数规则一样&lt;/strong&gt;。如果有多个类型形参，参数从右向左连续的缺省，因为要符合的参数从右向左的入栈规则。比如&lt;span&gt;template&amp;lt;class T1=int, class T2&amp;gt;class A{};就是错误的，因为&lt;span&gt;T1给出了默认&lt;/span&gt;&lt;/span&gt;值，而&lt;span&gt;T2没有设定。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、在类模板的&lt;span&gt;外部定义类中的成员时&lt;/span&gt;&lt;span&gt;template 后的&lt;strong&gt;形参表应省略默认的形参类型&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 比如&lt;span&gt;template&amp;lt;class  T1, class T2=int&amp;gt; class A{public: void func();}; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 定义方法为&lt;span&gt;template&amp;lt;class T1,&lt;span&gt;class T2&lt;/span&gt;&amp;gt; void A&amp;lt;T1,T2&amp;gt;::func(){}，将int省略掉。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大致了解了上面模板的一些用法，我们可以来实现一个东西——&lt;span&gt;&lt;strong&gt;适配器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
//紧接上面List的头文件
..................
 
template &amp;lt;class T, template&amp;lt;class&amp;gt;class Container&amp;gt;
 class Vector
 {
 public:
     void Push( const T&amp;amp; x)
     {   
         _con.PushBack(x);
     }
     void Pop()
     {   
         _con.PopBack();
     }
     size_t Size()
     {   
         return _con.Size();
     }
     bool Empty( )
     {
         return _con.Empty( );
     }
     void Print( )
     {
         _con.Print( );
     }
 private:
     Container&amp;lt;T&amp;gt;  _con;
 };
 void test( )
 {
     Vector&amp;lt;string, List&amp;gt; v;
     v.Push(&quot;hello&quot;);
     v.Print( );
     cout&amp;lt;&amp;lt;v.Empty();
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这里用到了上面实现的双向链表，以此简陋地来模拟STL里面的vector（其实这里用链表版本并不合适，STL里面用到是顺序表）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后来看看模板参数里的这个&lt;strong&gt;template&amp;lt;class&amp;gt; class Container ，&lt;/strong&gt;第一次看的话，&lt;span&gt;可能&lt;/span&gt;你我多少会&lt;span&gt;&lt;span&gt;有些小慌，毕竟出来个这么长的怪物。细细来看 其实就好理解了，template&amp;lt;class&amp;gt;指明了这是模板参数且是模板类类型，后面取了名字叫Container。所以这就相当于&lt;/span&gt;&lt;/span&gt;声明Container是一个&lt;span&gt;模板类类型的类模板参数。&lt;span&gt;这算是一种固定搭配，念着有些拗口，记住就好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后就是下面的  &lt;span&gt;Container&amp;lt;T&amp;gt; _con; 它&lt;/span&gt;意思就是创建一个Container的对象，而我们也知道这个对象也是模板类对象，&lt;strong&gt;所以把&amp;lt;T&amp;gt;给它传进去&lt;/strong&gt;。然后我们现在来说一下这个代码有什么用？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这里的Vector类相当于一个适配器。&lt;span&gt;适配器&lt;span&gt;&lt;span&gt;有一种“让&lt;span&gt;一种事物的行为类似于另外一种事物行为”的机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，它对容器进行包装，使其表现出另外一种行为。&lt;span&gt;针对不同类型的数据，&lt;/span&gt;&lt;/span&gt;在存、删数据时，我们不用再去实现不同版本的线性表；我们直接去用List类里面的函数，具体就是直接定义一个List的对象，然后直接拿走进行使用，最后让Vector管理不同类型数据，进而完成适配；再比如STL里面一个管理Int数据的栈，它的实现是stack&amp;lt;int, vector&amp;lt;int&amp;gt; &amp;gt;的，其内部其实是&lt;span&gt;&lt;span&gt;&lt;span&gt;使用顺序容器vector&amp;lt;int&amp;gt;来存储数据&lt;/span&gt;&lt;span&gt;（相当于是vector&amp;lt;int&amp;gt;表现出了栈的行为）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这些都是灵活的复用的体现。&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;最后，模板不支持分离编译&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;还是用上面的交换函数举例，不过这时我们将.h  和.cpp文件分开。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
***************Swap.h************
#include &amp;lt;iostream&amp;gt;
 using namespace std;

template&amp;lt;class T&amp;gt;
void Swap(T&amp;amp; a, T&amp;amp; b);


***************Swap.cpp************
 #include &quot;Swap.h&quot;

 template&amp;lt;class T&amp;gt;
 void Swap(T&amp;amp; a, T&amp;amp;b)
 {
     T tmp = a;
     a = b;
     b = tmp;
 }

***************main.cpp************
#include &quot;Swap.h&quot;

 int main(void)
 {
     int a =1, b=2;
     Swap&amp;lt;int&amp;gt;(a, b);
     cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;
     return 0;
 }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180514233845498-654214303.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;207&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在分离式编译的环境下，编译器&lt;span&gt;编译&lt;/span&gt;某一个&lt;span lang=&quot;en-us&quot;&gt;.cpp文件时并不知道另一个&lt;span lang=&quot;en-us&quot;&gt;.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于&lt;span&gt;连接器&lt;/span&gt;）。这种模式在没有模板的情况下运行良好（main函数里面调用swap函数时，.h文件告诉编译器，让&lt;span&gt;连接器&lt;/span&gt;去其它的.obj文件找地址），但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化代码出来（这里swap.cpp里面未调用swap函数,便无法推演出代码出来，自然就无法call到swap函数地址了），当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的&lt;span lang=&quot;en-us&quot;&gt;.cpp文件中没有用到模板的实例时，编译器懒得去实例化了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;那么&lt;span&gt;解决这种问题的办法就是&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在模板头文件 xxx.h 里面显示实例化，针对模板类，就在模板类的定义后面添加 template class List&amp;lt;int&amp;gt;; 一般不推荐这种方法，一方面老编译器可能不支持，另一方面实例化依赖调用者。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将声明和定义放到一个文件 &quot;xxx.hpp&quot; 里面，（这样编译时头文件展开，实例化代码便很轻松了）。通常我们会使用这种方法，但这种方法也有缺陷，因为实际开发中，.h文件是别人看的，而开发者并不希望别人细致了解内部的具体实现。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;





</description>
<pubDate>Mon, 14 May 2018 16:08:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/9031722.html</dc:identifier>
</item>
<item>
<title>Python并发编程之线程中的信息隔离（五） - 站在两个世界的边缘</title>
<link>http://www.cnblogs.com/wongbingming/p/9038815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wongbingming/p/9038815.html</guid>
<description>&lt;p&gt;大家好，&lt;code&gt;并发编程&lt;/code&gt; 进入第三篇。&lt;/p&gt;
&lt;p&gt;上班第一天，大家应该比较忙吧。小明也是呢，所以今天的内容也很少。只要几分钟就能学完。&lt;/p&gt;
&lt;p&gt;昨天我们说，线程与线程之间要通过消息通信来控制程序的执行。&lt;/p&gt;
&lt;p&gt;讲完了消息通信，今天就来探讨下线程里的&lt;code&gt;信息隔离&lt;/code&gt;是如何做到的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;大家注意&lt;/strong&gt;：&lt;br/&gt;&lt;code&gt;信息隔离&lt;/code&gt;，这并不是官方命名的名词，也不是网上广为流传的名词。是我为了方便理解而自创的，大家知道就好咯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;本文目录&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;初步认识信息隔离&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;信息隔离的意义何在&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt; 初步认识信息隔离&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;什么是&lt;code&gt;信息隔离&lt;/code&gt;？&lt;br/&gt;比如说，咱有两个线程，线程A里的变量，和线程B里的变量值不能共享。这就是&lt;code&gt;信息隔离&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你可能要说，那变量名取不一样不就好啦？&lt;/p&gt;
&lt;p&gt;是的，如果所有的线程都不是由一个class实例化出来的同一个对象，确实是可以。这个问题我们暂且挂着，后面我再说明。&lt;/p&gt;
&lt;p&gt;那么，如何实现&lt;code&gt;信息隔离&lt;/code&gt;呢？&lt;br/&gt;在Python中，其提供了&lt;code&gt;threading.local&lt;/code&gt;这个类，可以很方便的控制变量的隔离，即使是同一个变量，在不同的线程中，其值也是不能共享的。&lt;/p&gt;
&lt;p&gt;用代码来看下&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;20&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; threading &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; local, Thread, currentThread&lt;p&gt;&lt;br/&gt;local_data = local()&lt;br/&gt;local_data.name = &lt;span class=&quot;hljs-string&quot;&gt;'local_data'&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Thread)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;赋值前-子线程：&quot;&lt;/span&gt;, currentThread(),local_data.__dict__)&lt;br/&gt;local_data.name = self.getName()&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;赋值后-子线程：&quot;&lt;/span&gt;,currentThread(), local_data.__dict__)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__'&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;开始前-主线程：&quot;&lt;/span&gt;,local_data.__dict__)&lt;/p&gt;&lt;p&gt;t1 = MyThread()&lt;br/&gt;t1.start()&lt;br/&gt;t1.join()&lt;/p&gt;&lt;p&gt;t2 = MyThread()&lt;br/&gt;t2.start()&lt;br/&gt;t2.join()&lt;/p&gt;&lt;p&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;结束后-主线程：&quot;&lt;/span&gt;,local_data.__dict__)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看看输出结果&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;12&quot;&gt;开始前-主线程： {&lt;span class=&quot;hljs-string&quot;&gt;'name'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'local_data'&lt;/span&gt;}&lt;p&gt;赋值前-子线程： &amp;lt;MyThread(Thread&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, started &lt;span class=&quot;hljs-number&quot;&gt;4832&lt;/span&gt;)&amp;gt; {}&lt;br/&gt;赋值后-子线程： &amp;lt;MyThread(Thread&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, started &lt;span class=&quot;hljs-number&quot;&gt;4832&lt;/span&gt;)&amp;gt; {&lt;span class=&quot;hljs-string&quot;&gt;'name'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'Thread-1'&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;赋值前-子线程： &amp;lt;MyThread(Thread&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;, started &lt;span class=&quot;hljs-number&quot;&gt;5616&lt;/span&gt;)&amp;gt; {}&lt;br/&gt;赋值后-子线程： &amp;lt;MyThread(Thread&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;, started &lt;span class=&quot;hljs-number&quot;&gt;5616&lt;/span&gt;)&amp;gt; {&lt;span class=&quot;hljs-string&quot;&gt;'name'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'Thread-2'&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;结束后-主线程： {&lt;span class=&quot;hljs-string&quot;&gt;'name'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'local_data'&lt;/span&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出来看，我们可以知道，&lt;code&gt;local&lt;/code&gt;实际是一个&lt;code&gt;字典型&lt;/code&gt;的对象，其内部可以以&lt;code&gt;key-value&lt;/code&gt;的形式存入你要做信息隔离的变量。local实例可以是&lt;code&gt;全局唯一&lt;/code&gt;的，只有一个。因为你在给local存入或访问变量时，它会根据当前的线程的不同从不同的&lt;code&gt;存储空间&lt;/code&gt;存入或获取。&lt;/p&gt;
&lt;p&gt;基于此，我们可以得出以下三点结论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;主线程中的变量，不会因为其是全局变量，而被子线程获取到；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主线程也不能获取到子线程中的变量；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子线程与子线程之间的变量也不能互相访问。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;所以如果想在当前线程保存一个全局值，并且各自线程（包括主线程）互不干扰，使用local类吧。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt; 信息隔离的意义何在&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;细心的你，一定已经发现了，上面那个例子，即使我们不用&lt;code&gt;threading.local&lt;/code&gt;来做信息隔离，两个线程&lt;code&gt;self.getName()&lt;/code&gt;本身就是隔离的，没有任何关系的。因为这两个线程是由一个class实例出的两个不同的实例对象。自然是可以不用做隔离，因为其本身就是隔离的。&lt;/p&gt;
&lt;p&gt;但是，现实开发中。不可排除有多个线程，是由一个class实例出的同一个实例对象而实现的。&lt;/p&gt;
&lt;p&gt;譬如，现在新手特别喜欢的爬虫项目。通常都是先给爬虫一个主页，然后获取主页下的所有链接，对这个链接再进行遍历，一直往下，直到把所有的链接都爬完，获取到我们所需的内容。&lt;/p&gt;
&lt;p&gt;由于单线程的爬取效率实在是太低了，我们考虑使用多线程来工作。先使用&lt;code&gt;socket&lt;/code&gt;和&lt;code&gt;www.sina.con.cn&lt;/code&gt;建立一个TCP连接。然后在这个连接的基础上，对主页上的每个链接（我们这里只举&lt;code&gt;news.sina.com.cn&lt;/code&gt;和&lt;code&gt;blog.sina.com.cn&lt;/code&gt;这两个子链接做例子）创建一个线程，这样效率就高多了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;友情提醒&lt;/strong&gt;：&lt;br/&gt;以下代码，若要理解，可能需要你了解下socket的网络编程相关内容。我在前几天的文章中有发布一篇相关的文章，没有基础的同学可以先去看看那篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre readability=&quot;19.5&quot;&gt;
&lt;code class=&quot;python language-python hljs&quot; readability=&quot;33&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; threading&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; partial&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; socket &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; socket, AF_INET, SOCK_STREAM&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LazyConnection&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, address, family=AF_INET, type=SOCK_STREAM)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;self.address = address&lt;br/&gt;self.family = AF_INET&lt;br/&gt;self.type = SOCK_STREAM&lt;br/&gt;self.local = threading.local()&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__enter__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; hasattr(self.local, &lt;span class=&quot;hljs-string&quot;&gt;'sock'&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;raise&lt;/span&gt; RuntimeError(&lt;span class=&quot;hljs-string&quot;&gt;'Already connected'&lt;/span&gt;)&lt;br/&gt;self.local.sock = socket(self.family, self.type)&lt;br/&gt;self.local.sock.connect(self.address)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.local.sock&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__exit__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, exc_ty, exc_val, tb)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;self.local.sock.close()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; self.local.sock&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;spider&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(conn, website)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; conn &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; s:&lt;br/&gt;header = &lt;span class=&quot;hljs-string&quot;&gt;'GET / HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n'&lt;/span&gt;.format(website)&lt;br/&gt;s.send(header.encode(&lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;))&lt;br/&gt;resp = &lt;span class=&quot;hljs-string&quot;&gt;b''&lt;/span&gt;.join(iter(partial(s.recv, &lt;span class=&quot;hljs-number&quot;&gt;100000&lt;/span&gt;), &lt;span class=&quot;hljs-string&quot;&gt;b''&lt;/span&gt;))&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'Got {} bytes'&lt;/span&gt;.format(len(resp)))&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__'&lt;/span&gt;:&lt;br/&gt;conn = LazyConnection((&lt;span class=&quot;hljs-string&quot;&gt;'www.sina.com.cn'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;))&lt;/p&gt;&lt;p&gt;&lt;br/&gt;t1 = threading.Thread(target=spider, args=(conn,&lt;span class=&quot;hljs-string&quot;&gt;&quot;news.sina.com.cn&quot;&lt;/span&gt;))&lt;br/&gt;t2 = threading.Thread(target=spider, args=(conn,&lt;span class=&quot;hljs-string&quot;&gt;&quot;blog.sina.com.cn&quot;&lt;/span&gt;))&lt;br/&gt;t1.start()&lt;br/&gt;t2.start()&lt;br/&gt;t1.join()&lt;br/&gt;t2.join()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;python language-python hljs&quot;&gt;Got &lt;span class=&quot;hljs-number&quot;&gt;765&lt;/span&gt; bytes&lt;br/&gt;Got &lt;span class=&quot;hljs-number&quot;&gt;513469&lt;/span&gt; bytes&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是在这种场景下，要做到线程之间的状态信息的隔离，就肯定要借助&lt;code&gt;threading.local&lt;/code&gt;，所以&lt;code&gt;threading.local&lt;/code&gt;的存在是有存在的意义的。其他还有很多场景是必须借助&lt;code&gt;threading.local&lt;/code&gt;才能实现的，而这些就要靠你们在真正的业务开发中去发现咯。&lt;/p&gt;
&lt;p&gt;好了，今天就讲这些内容。&lt;/p&gt;
&lt;hr/&gt;&lt;img src=&quot;https://i.loli.net/2018/04/30/5ae6ce87421aa.jpg&quot; alt=&quot;关注公众号，获取最新文章&quot; title=&quot;关注公众号，获取最新文章&quot;/&gt;关注公众号，获取最新文章</description>
<pubDate>Mon, 14 May 2018 16:00:00 +0000</pubDate>
<dc:creator>站在两个世界的边缘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wongbingming/p/9038815.html</dc:identifier>
</item>
<item>
<title>在C++98基础上学习C++11新特性 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/9038814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/9038814.html</guid>
<description>&lt;p&gt;自己一直用的是&lt;strong&gt;&lt;em&gt;C++98&lt;/em&gt;&lt;/strong&gt;规范来编程，对于&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;只闻其名却没用过其特性。近期因为工作的需要，需要掌握&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;的一些特性，所以查阅了一些&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;资料。因为自己有&lt;strong&gt;&lt;em&gt;C++98&lt;/em&gt;&lt;/strong&gt;的基础，所以从&lt;strong&gt;&lt;em&gt;C++98&lt;/em&gt;&lt;/strong&gt;过渡到&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;并不算特别吃力，读了一些书籍后，算是对&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;有了个比较基础的理解，感觉程序员还是要经常保持新语言新特性的更新，现在 &lt;strong&gt;&lt;em&gt;C++&lt;/em&gt;&lt;/strong&gt; 标准都出到&lt;strong&gt;&lt;em&gt;C++17&lt;/em&gt;&lt;/strong&gt;了！这篇文章就是对&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;一些常用新特性的一些总结，以&lt;strong&gt;&lt;em&gt;C++98&lt;/em&gt;&lt;/strong&gt;和 &lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;在语法上的差异来突出&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;新特性的非凡优势。&lt;/p&gt;
&lt;h2 id=&quot;一新语法&quot;&gt;一、新语法&lt;/h2&gt;
&lt;h3 id=&quot;自动类型推导auto&quot;&gt;1.自动类型推导auto&lt;/h3&gt;
&lt;p&gt;auto的自动推导，用于从初始化表达式中推断出变量的数据类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
//C++98
int a = 10;
string s = &quot;abc&quot;;
float b = 10.0;
vector&amp;lt;int&amp;gt; c;
vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; d;
map&amp;lt;int, string&amp;gt; m;
m[1] = &quot;aaa&quot;;
map&amp;lt;int, string&amp;gt;::iterator it = m.begin();


//C++11
auto a1 = 10;  //a1为int
auto s1 = &quot;abc&quot;;  //s1为string
auto b1 = b;  
auto c1 = c;
auto d1 = d;
auto e1 = 'a';
int* x = &amp;amp;a1;
auto d1 = x;
auto m1 = m.begin();
auto x=1,y=2; //ok
auto i=1.j=3.14; //compile error

double a2 = 3.144;
const auto a3 = a2;  //const double
auto a4 = a2;  //double
volatile int c2 = 3;
auto c3 = c2; //int&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;萃取类型decltype&quot;&gt;2.萃取类型decltype&lt;/h3&gt;
&lt;p&gt;decltype可以通过一个变量或表达式得到类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int add(int a)
{
    return ++a;
}

void fun(int a)
{
    cout &amp;lt;&amp;lt; &quot;call function: [int]\n&quot; &amp;lt;&amp;lt; endl;
}

void fun(int *a)
{
    cout &amp;lt;&amp;lt; &quot;call function: [int*]\n&quot; &amp;lt;&amp;lt; endl;
}

int main()
{
    //C++11
    int aa = 10;
    decltype(aa) bb = 11;
    string ss = &quot;hello intel&quot;;
    decltype(ss) ss1 = &quot;hello&quot;;
    const vector&amp;lt;int&amp;gt; vec(1);
    decltype(vec[0]) cc = 1;
    decltype(0) dd = vec[0];  //dd是int类型
    decltype(add(1)) ee;  //int
    int a[5];
    decltype(a) ff; //int[5]
    //decltype(fun) gg;  无法通过编译，是个重载函数
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nullptr&quot;&gt;3.nullptr&lt;/h3&gt;
&lt;p&gt;空指针标识符nullptr是一个表示空指针的标识，他不是一个整数，这是与我们常用的NULL宏的区别。NULL只是一个定义为常整数0的宏，而nullptr是C++11的一个关键字，一个內建的标识符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

void fun(int a)
{
    cout &amp;lt;&amp;lt; &quot;call function: [int]\n&quot; &amp;lt;&amp;lt; endl;
}

void fun(int *a)
{
    cout &amp;lt;&amp;lt; &quot;call function: [int*]\n&quot; &amp;lt;&amp;lt; endl;
}

int main()
{
    //C++11
    fun(NULL);   //call function: [int]
    fun(nullptr);  //call function: [int*]

    int* p = NULL;
    fun(p);  //call function: [int*]

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;区间迭代range-for&quot;&gt;4.区间迭代range for&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;C++98&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;C++11&lt;/em&gt;&lt;/strong&gt;在使用语法上的差异如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;


int main()
{
    //C++98
    vector&amp;lt;int&amp;gt; vec(8, 1);
    cout &amp;lt;&amp;lt; &quot;C++98 range for:&quot; &amp;lt;&amp;lt; endl;
    for (vector&amp;lt;int&amp;gt;::iterator it = vec.begin(); it != vec.end(); it++)
    {
        cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; endl;
    }

    //C++11
    cout &amp;lt;&amp;lt; &quot;C++11 range for:&quot; &amp;lt;&amp;lt; endl;
    for (auto d : vec)
    {
        cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得指出的是，是否能够使用基于范围的for循环，必须依赖一些条件。首先，就是for循环迭代的范围是可确定的。对于类来说，如果该类有begin和end函数，那么for_each之间就是for循环迭代的范围。对于数组而言，就是数组的第一个和最后一个元素间的范围。其次，基于范围的for循环还要求迭代的对象实现+ + 和==等操作符。对于STL中的容器，如string、array、map等使用起来是不会有问题的。下面是C++11操作vector和数组的实践：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
    vector&amp;lt;int&amp;gt; vec(8, 1);

    //C++11
    cout &amp;lt;&amp;lt; &quot;C++11 value range for:&quot; &amp;lt;&amp;lt; endl;
    /*d非引用，修改d不会影响vector里的值*/
    for (auto d : vec)   //d中存储的是vec中的值
    {
        d = 2;
    }

    for (auto d : vec)   
    {
        cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl;
    }

    cout &amp;lt;&amp;lt; &quot;C++11 reference range for:&quot; &amp;lt;&amp;lt; endl;
    /*当迭代变量d为引用时，vector里的值可以被修改*/
    for (auto &amp;amp;d : vec)  
    {
        d = 2;
    }

    for (auto d : vec)   
    {
        cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl;
    }

    //数组for_each
    char arr[] = {'a','b','c','d'};
    for (auto &amp;amp;d : arr)
    {
        d -= 32;
    }
    for (auto d : arr)
    {
        cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl;
    }

    //遍历二维数组，注意迭代变量row必须为引用。如果你想用 range for 的方法，来遍历更高维的数组 （dim &amp;gt; 2），那么你只需要：除了最内层循环之外，其他所有外层循环都加入 '&amp;amp;' 即可。
    int array2[5][5] = {0};
    for (auto &amp;amp;row : array2)
        for (auto col : row)
            cout &amp;lt;&amp;lt; col &amp;lt;&amp;lt; endl;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;返回类型后置语法&quot;&gt;5.返回类型后置语法&lt;/h3&gt;
&lt;p&gt;先看下面这个例子，编译器在推导decltype(t1+t2)时表达式中t1和t2都未声明，所以编译失败。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

template&amp;lt;class T1, class T2&amp;gt;
decltype(t1 + t2) sum(T1 t1, T2 t2)
{
    return t1 + t2;
}

int main()
{
    auto total = sum(1, 2);
    cout &amp;lt;&amp;lt; total &amp;lt;&amp;lt; endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以C++11引入新语法，即把函数的返回值移至参数声明之后，复合符号-&amp;gt;decltype(t1+t2)被称为追踪返回类型。而原本的函数返回值由auto占据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

template&amp;lt;class T1, class T2&amp;gt;
auto sum(T1 t1, T2 t2) -&amp;gt;decltype(t1+t2)
{
    return t1 + t2;
}

int main()
{
    auto total = sum(1, 2);
    cout &amp;lt;&amp;lt; total &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;final和override&quot;&gt;6.final和override&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;struct B
{
    virtual void f1(int) const;
    virtual void f2();
    void f3();
};

struct D1 : public B
{
    void f1(int) const override;  //ok
    void f2(int) override;   //error，B中没有形如f2(int)的函数
    void f3() override;  //error，f3不是虚函数
    void f4() override;  //error，B中无f4函数
};

struct D2 : public B
{
    void f1(int) const final;  //不许后续的其他类覆盖
};

struct D3 :public D2
{
    void f2();
    void f1(int) const; //error，final函数不可覆盖
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;final还可以用于防止继承的发生&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class NoDerived final
{

};

class Bad :NoDerived   //NoDerived不可做基类
{

};

class Base
{

};

class Last final :Base
{

};

class Bad2 :Last   //Last不可做基类
{

};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;default和delete&quot;&gt;7.=default和=delete&lt;/h3&gt;
&lt;p&gt;对于 C++ 的类，如果程序员没有为其定义特殊成员函数，那么在需要用到某个特殊成员函数的时候，编译器会隐式的自动生成一个默认的特殊成员函数，比如拷贝构造函数，或者拷贝赋值操作符。&lt;/p&gt;
&lt;p&gt;C++11允许我们使用=default来要求编译器生成一个默认构造函数，也允许我们使用=delete来告诉编译器不要为我们生成某个默认函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class B
{
    B() = default; //显示声明使用默认构造函数
    B(const B&amp;amp;) = delete; //禁止使用类对象之间的拷贝
    ~B() = default;  //显示声明使用默认析构函数
    B&amp;amp; operator=(const B&amp;amp;) = delete;  //禁止使用类对象之间的赋值
    B(int a);  
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;lambda表达式&quot;&gt;8.lambda表达式&lt;/h3&gt;
&lt;p&gt;简单来说，Lambda函数也就是一个函数（匿名函数），它的语法定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[capture](parameters) mutable -&amp;gt;return-type{statement}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;[=,&amp;amp;a,&amp;amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;&lt;/li&gt;
&lt;li&gt;[&amp;amp;,a,this]表示以值传递的方式捕捉变量a和类的this指针，引用传递方式捕捉其它所有变量。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
    auto f = []() {cout &amp;lt;&amp;lt; &quot;hello world!&quot; &amp;lt;&amp;lt; endl; };
    f();  //hello world!

    int a = 123;
    auto f1 = [a] { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; };
    f1();  //123

    auto f2 = [&amp;amp;a] {cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; };
    a = 789;
    f2();  //789

    //隐式捕获:让编译器根据函数体中的代码来推断需要捕获哪些变量
    auto f3 = [=] {cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; };
    f3();  //789

    auto f4 = [&amp;amp;] {cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; };
    a = 990;
    f4();  //990

    auto f5 = [](int a, int b)-&amp;gt;int {return a + b; };
    printf(&quot;%d\n&quot;, f5(1, 2));  //3

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式在C++下的应用，排序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

void print(char arr[], int len)
{
    for (int i = 0; i &amp;lt; len; i++)
    {
        printf(&quot;%d &quot;, arr[i]);
    }
    printf(&quot;\n&quot;);
}

bool cmp(char a, char b)
{
    if (a &amp;gt; b)
        return true;
    else
        return false;
}

int main()
{
    //c++98
    char arr1[] = { 2,5,2,1,5,89,36,22,89 };
    int len = sizeof(arr1) / sizeof(char);
    sort(arr1, arr1 + len, cmp);
    print(arr1, len);

    //c++11
    char arr2[] = { 2,5,2,1,5,89,36,22,89 };
    int len2 = sizeof(arr2) / sizeof(char);
    sort(arr2, arr2 + len2, [](char a, char b)-&amp;gt;bool {return a &amp;gt; b; });
    print(arr2, len2);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stdmove&quot;&gt;9.std::move&lt;/h3&gt;
&lt;p&gt;std::move是为性能而生，通过std::move，可以避免不必要的拷贝操作。std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;utility&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
int main()
{
    std::string str = &quot;Hello&quot;;
    std::vector&amp;lt;std::string&amp;gt; v;
    //调用常规的拷贝构造函数，新建字符数组，拷贝数据
    v.push_back(str);
    std::cout &amp;lt;&amp;lt; &quot;After copy, str is \&quot;&quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &quot;\&quot;\n&quot;; //After move, str is &quot;Hello&quot;
    //调用移动构造函数，掏空str，掏空后，最好不要使用str
    v.push_back(std::move(str));
    std::cout &amp;lt;&amp;lt; &quot;After move, str is \&quot;&quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &quot;\&quot;\n&quot;;   //After move, str is &quot;&quot;
    std::cout &amp;lt;&amp;lt; &quot;The contents of the vector are \&quot;&quot; &amp;lt;&amp;lt; v[0]
        &amp;lt;&amp;lt; &quot;\&quot;, \&quot;&quot; &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; &quot;\&quot;\n&quot;;   //The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二stl新内容&quot;&gt;二、STL新内容&lt;/h2&gt;
&lt;h3 id=&quot;stdarray&quot;&gt;1.std::array&lt;/h3&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用 std::array保存在栈内存中，相比堆内存中的 std::vector，我们就能够灵活的访问这里面的元素，从而获得更高的性能；同时正式由于其堆内存存储的特性，有些时候我们还需要自己负责释放这些资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用std::array能够让代码变得更加现代，且封装了一些操作函数，同时还能够友好的使用标准库中的容器算法等等，比如 std::sort。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 很简单，只需指定其类型和大小即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;array&amp;gt;

void foo(int* p)
{

}

int main()
{
    std::array&amp;lt;int, 4&amp;gt; arr = {4,3,1,2};

    foo(&amp;amp;arr[0]);  //OK
    foo(arr.data());  //OK
    //foo(arr);  //wrong
    std::sort(arr.begin(), arr.end());  //排序

    return 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stdforward_list&quot;&gt;2.std::forward_list&lt;/h3&gt;
&lt;p&gt;std::forward_list 使用单向链表进行实现，提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;forward_list&amp;gt;

int main()
{
    std::forward_list&amp;lt;int&amp;gt; list1 = { 1, 2, 3, 4 };

    //从前面向foo1容器中添加数据，注意不支持push_back
    list1.pop_front();  //删除链表第一个元素
    list1.remove(3);   //删除链表值为3的节点
    list1.push_front(2);
    list1.push_front(1);
    list1.push_front(14);
    list1.push_front(17);

    list1.sort();

    for (auto &amp;amp;n : list1)
    {
        if (n == 17)
            n = 19;
    }

    for (const auto &amp;amp;n : list1)
    {
        std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;  //1 2 2 4 14 19
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stdunordered_map和stdunordered_set&quot;&gt;3.std::unordered_map和std::unordered_set&lt;/h3&gt;
&lt;p&gt;无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。&lt;/p&gt;
&lt;p&gt;C++11 引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。&lt;/p&gt;
&lt;p&gt;下面给出unordered_map和unordered_set的使用方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;unordered_set&amp;gt;

void foo(int* p)
{

}

int main()
{
    //unordered_map usage
    std::unordered_map&amp;lt;std::string, int&amp;gt; um = { {&quot;2&quot;,2},{&quot;1&quot;,1},{&quot;3&quot;,3} };

    //遍历
    for (const auto &amp;amp;n : um)
    {
        std::cout &amp;lt;&amp;lt; &quot;key:&quot; &amp;lt;&amp;lt; n.first &amp;lt;&amp;lt; &quot;  value:&quot; &amp;lt;&amp;lt; n.second &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &quot;value:&quot; &amp;lt;&amp;lt; um[&quot;1&quot;] &amp;lt;&amp;lt; std::endl;


    //unordered_set usage
    std::unordered_set&amp;lt;int&amp;gt; us = { 2,3,4,1};

    //遍历
    for (const auto &amp;amp;n : us)
    {
        std::cout &amp;lt;&amp;lt; &quot;value:&quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
    }

    std::cout &amp;lt;&amp;lt; &quot;value:&quot; &amp;lt;&amp;lt; us.count(9) &amp;lt;&amp;lt; std::endl; //判断一个数是否在集合内，1存在0不存在
    std::cout &amp;lt;&amp;lt; &quot;value:&quot; &amp;lt;&amp;lt; *us.find(1) &amp;lt;&amp;lt; std::endl;  //查找一个特定的数是否在集合内，找到就返回该数的迭代器位置

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三智能指针&quot;&gt;三、智能指针&lt;/h2&gt;
&lt;h3 id=&quot;stdshared_ptr&quot;&gt;1. std::shared_ptr&lt;/h3&gt;
&lt;p&gt;shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;iostream&amp;gt;

int main()
{
    //auto ptr = std::make_shared&amp;lt;int&amp;gt;(10);
    std::shared_ptr&amp;lt;int&amp;gt; ptr(new int(10));
    std::shared_ptr&amp;lt;int&amp;gt; ptrC(ptr);

    auto ptr2 = ptr;

    {
        auto ptr3 = ptr2;
        std::cout &amp;lt;&amp;lt; &quot;pointer1.use_count() = &quot; &amp;lt;&amp;lt; ptr.use_count() &amp;lt;&amp;lt; std::endl;  //4
        std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; ptr2.use_count() &amp;lt;&amp;lt; std::endl;  //4
    }

    std::cout &amp;lt;&amp;lt; &quot;pointer1.use_count() = &quot; &amp;lt;&amp;lt; ptr.use_count() &amp;lt;&amp;lt; std::endl;  //3
    std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; ptr2.use_count() &amp;lt;&amp;lt; std::endl;  //3

    int *p = ptr.get(); //获取原始指针

    std::cout &amp;lt;&amp;lt; &quot;pointer1.use_count() = &quot; &amp;lt;&amp;lt; ptr.use_count() &amp;lt;&amp;lt; std::endl;  //3
    std::cout &amp;lt;&amp;lt; &quot;pointer2.use_count() = &quot; &amp;lt;&amp;lt; ptr2.use_count() &amp;lt;&amp;lt; std::endl;  //3

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;stdunique_ptr&quot;&gt;3 2. std::unique_ptr&lt;/h2&gt;
&lt;p&gt;std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;iostream&amp;gt;

int main()
{
    std::unique_ptr&amp;lt;int&amp;gt; ptr(new int(10));
    //auto ptr2 = ptr; //非法

    //虽说unique_ptr是不可复制的，但我们可以使用std::move将其独占权转移到其他的unique_ptr
    auto ptr2(std::move(ptr));
    std::cout &amp;lt;&amp;lt; *ptr2 &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;stdweak_ptr&quot;&gt;3. std::weak_ptr&lt;/h3&gt;
&lt;p&gt;先观察下面的代码，如果我们在类father中使用的是shared_ptr&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;father !
son !&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上问题就是shared_ptr的环形引用问题。为了避免shared_ptr的环形引用问题，需要引入一个弱引用weak_ptr， weak_ptr是为了配合shared_ptr而引入的一种智能指针，弱引用不会引起引用计数增加,它更像是shared_ptr的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载operator*和-&amp;gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;
using namespace std;

class father;
class son;

class father {
public:
    father() {
        cout &amp;lt;&amp;lt; &quot;father !&quot; &amp;lt;&amp;lt; endl;
    }
    ~father() {
        cout &amp;lt;&amp;lt; &quot;~~~~~father !&quot; &amp;lt;&amp;lt; endl;
    }
    void setSon(shared_ptr&amp;lt;son&amp;gt; s) {
        son = s;
    }
private:
    //shared_ptr&amp;lt;son&amp;gt; son;
    weak_ptr&amp;lt;son&amp;gt; son; // 用weak_ptr来替换
};


class son {
public:
    son() {
        cout &amp;lt;&amp;lt; &quot;son !&quot; &amp;lt;&amp;lt; endl;
    }
    ~son() {
        cout &amp;lt;&amp;lt; &quot;~~~~~~son !&quot; &amp;lt;&amp;lt; endl;
    }
    void setFather(shared_ptr&amp;lt;father&amp;gt; f) {
        father = f;
    }
private:
    shared_ptr&amp;lt;father&amp;gt; father;
};

void test() {
    shared_ptr&amp;lt;father&amp;gt; f(new father());
    shared_ptr&amp;lt;son&amp;gt; s(new son());
    f-&amp;gt;setSon(s);
    s-&amp;gt;setFather(f);
}

int main()
{
    test();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;father !
son !
~~~~~~son !
~~~~~father !&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 14 May 2018 15:59:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/9038814.html</dc:identifier>
</item>
<item>
<title>前端leader找我谈心：我是如何从刚毕业的前端菜鸟一步步成长为前端架构师的？ - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/9038725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/9038725.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;谈谈学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我做前端已经有五年的时间了，从大学刚毕业的时候，我是一个完全什么都不懂的小白。虽然我大学里学的是软件工程专业，但是因为在大学里荒废学业，每天只知道打游戏，基本上到大学毕业之前我是什么都不会的，而且大学里是没有教前端相关的东西的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我是在大学毕业之前，两三个月，自学了一点点前端的皮毛，也就是会写一点点的html和css。那个时候找工作也不容易，终于有一个公司收留了我，虽然说工资什么的我们暂时按下不提。但是至少他们要我，我就非常地开心了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从那个时候开始，因为有了项目要做，所以我逼迫自己，每天去学习新的内容。那个时候我从jQuery开始做，因为公司的项目比较特殊，就是单页应用，总共加起来大概就五六个页面，但是要一次性全部加载完，后续的所有数据都是根据接口去获取。那个时候没有框架，没有React，ngular也刚刚出来，还并不流行。所以那个时候我们就用jQuery。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后我就想办法去做，第一版做的非常的烂，就一个js文件我写了3000多行代码。所以在那个时候我逼迫自己想办法去解决各种问题。我就针对自己当时的认知，比如说js文件太大了，应该怎么办？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后我去网上搜，我发现了sea.js这个东西。我学习了它异步加载JavaScript的方法，后来才把它引用到项目里。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我发现代码量多了，很难去维护这个逻辑，还有页面的切换。于是我就去网上搜资料学习，发现有backbone.js这个东西，它可以帮我解决这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在后来这段时间里，我积累了非常多的东西，也是我进步最快的一个时期。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我再去接触到这些Vue、React这些框架的时候，我先去学习了一遍它们主要是解决了什么问题，它们主要的功能有哪些。然后我再尝试用到项目里面去。那个时候，我刚开始学的是Angular，当时也没有了解到有构建工具这个概念。那时候最多只知道有Grunt，帮你去压缩一下js。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当时，我还没有模块化的概念。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后来又做了一些项目，发现了很多的问题，我再去想办法去解决。这个时候才会知道有Webpack这些模块化组织代码的工具。我就是在这种环境下一步一步成长起来的。我所有学的内容，对于前端的了解，基本上都是基于我想要去解决一个问题，然后再去网上搜相关的内容，然后去想办法把这个问题解决掉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以对于我来说，学习这个东西，你要知道你要解决什么问题。然后你学的这个东西，它解决了什么问题。它适不适合用在你遇到的这些问题上，以及你在学习这个内容之前，你必须要对它的整体有一个了解。不然的话，你就是瞎用。你用的方法可能根本就不是这个框架要解决的问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如Vue，大家对于vue整体有一个概念之后，再去用到一个项目里面去。而项目一开始我们做的时候并不要求做的特别的复杂。只要你基础扎实，你肯定有办法去解决这些在项目里碰到的问题。而在解决问题的过程当中，才是你掌握了你学习到的东西，巩固了你学习到的这些内容的地方。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以这就是我要谈的学习。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;谈谈前端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在的前端跟五年前的前端是天壤之别。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五年前的前端，框架之流刚刚兴起，也就是Angular带的头，那个时候刚出来没多久。那个时候流行什么呢？就是写页面模板。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们写好html、css，以及这个页面上简单的动画效果，比如说点击一下有什么事件之类的。然后这个东西写好之后干嘛呢？丢给后端人员他们用后端模板，比如说最多的用Java，Java有jsp模板语言，接着把数据填进去，就OK了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个时候我们一个网站有很多页面怎么办呢？比如说我们写了很多的html页面，写好之后交给后端人员，然后他们整合在模板，再把数据动态插进去。这样的话，每个http的请求发送到后端那边，后端根据这个http请求，返回不同的模板，并且把数据渲染进去，最终返回给用户。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是以前的前端。那么现在的前端呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们把渲染模板的操作从后端挪到了前端来做。因为把模板渲染这部分拿到前端来做，所以很多业务逻辑的判断、渲染、数据获取等都要在前端来做。这个时候就大大加深了前端的业务逻辑。它包含的内容就比以前上升了好几个量级。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在这种情况下，我们需要一个框架去整理代码。而这个时候就会出现各种帮助我们前端开发者去处理这些内容的东西，比如说我们有了前端路由的概念，我们有了store状态管理的概念。以前MVC的时候，还有过其他的处理数据的方式，反正各种各样的工具帮我们去处理这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;伴随着前端业务代码越来越复杂，我们用以前的方式去写JavaScript代码，效率非常的低。因为我们写的JavaScript代码很多都受浏览器兼容的限制，或者是它的低版本的很多功能不支持，导致我们写起来非常的蛋疼。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;彼时前端界不缺人才，他们发明了各种各样的工具，比如用babel让我们能提前享受到最新的JavaScript语法带来的很多很好用的功能。当我们有了React这类框架之后，希望前端的应用以js作为入口，而不是以html作为入口。我们html里显示的内容都是从js里面渲染出来的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;由于整个应用基本上以js作为入口，我们就需要用js来处理css、图片等其他静态资源。这个时候我们发现，js本身不是用来处理这些东西的，而我们又迫切需要一些工具来处理这个问题，因此又出现了webpack。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以前端的发展速度在整个编程界来说，是相对特别快的。主要的原因就是因为以前的前端它的标准实在是太低了。现在补充的很多js 的标准、前端的一些标准都是以前发展缓慢，落下来的。所以说，现在只能说是慢慢地变成了一个正常的状态，而不是说已经超前非常多了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前端现在要入门的童鞋，对你们来说，其实不算是一个特别好的时机。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果你之前是有基础的，那么还可以。如果你之前一点基础都没有，你会发现前端进来之后，你要学的东西特别的多，各种各样的东西。在这种鱼龙混杂的时候，你必须要保持一颗好奇心，保持一个吸收新知识的能力。你要经常去看一些文章，或者是GitHub，或者是一些厉害的程序员的博客。他们有发现新的东西，好玩的东西，都会分享出来。然后你要立马去学习，因为它有可能就是将来的主流。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以现在去学习前端，你要时刻保持一种学习的心态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;谈谈面试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在的前端状态有点混乱，发展节奏有点快，你仅仅是想把vue学好是不可能的。你要学vue就必须要学webpack。当然你可以直接用vue-cli去生成一个项目。但是对于好奇的你，肯定会想，vue-cli里面到底做了哪些东西。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后当你以后出去面试的时候，你跟面试官说，你做过vue的项目。然后面试官肯定会问你一些webpack相关的一些东西。这个时候你又说不出个所以然来。他会问你，那你的项目是怎么生成的，你会说用vue-cli脚手架生成的。他会问你，那你有没有看过vue-cli里面生成的一些代码，然后这个时候你又说没有。那么他对你的期望值就会变得非常的低。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然有的面试官还会不厌其烦地问你，为什么我们用webpack生成的文件名后面要带上一串哈希码？这个问题至少我问过很多初中级的童鞋，他们都是不知道的，不太清楚，或者只是清楚一些有概念叫做缓存。但是至于这个文件名后面加一堆哈希码，到底是做什么事情，他们不太清楚。浏览器如何去缓存，他们也不太清楚。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以webpack是一个逃不开的话题。然后还有vue-router、vuex这些已经算是vue项目开发的三驾马车。因此当你想学好vue的时候，意味着你还要学好webpack、vue-router、vuex。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，服务端渲染也是值得讨论的话题。这些东西要去全部学习好，对于基础比较差的童鞋来讲，确实有点难，他一下子接收的东西实在太多了。一旦涉及到webpack，而webpack又是跑在node端的，所以你还要学习用node.js如何去写脚本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，如果对于追求上进的你来说，还想学习下SSR服务端渲染，首先你要去学习用node.js如何去写一个server，然后还有服务端的接口实现，虽然这是一个纯后端的实现内容。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当你以为这就结束了的话，你就错了。如果你面试的是BATJ等互联网大厂，面试官可能还会问你http相关的内容。比如说，面试官会问你，像http的get、post、put、delete这些request methods它们又有什么用，有什么区别？从语义上来讲，http的code又有什么用。当这些问题抛向你的时候，如果你平时没有注意积累这方面的技术知识，此时的你是否依然会处于一个懵圈的状态？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这些东西，对于一个纯做前端，纯做页面的童鞋来说的话，你确实不用特别的了解。但是你一旦升级为一个工程师，你要去跟后端交流一些接口，你要去思考统筹整个项目的时候，你必须要了解。不然的话，你会踩非常多的坑，犯非常多的错误。导致你的整个项目到后期维护的时候，有很多的内容到后期是没办法去升级的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;讲了这么多关于学习、前端、面试等话题，终归学习是要讲效率的，如果你学了非常多的时间，发现自己还是不怎么会，你就会特别没有成就感。当时就不会想继续学下去了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后，向内认知，向外行走。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;谨以此文与君共勉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上内容参考自某大型互联网公司前端架构师的心路历程，在此表示感谢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最新的文章都会第一时间更新在我的公众号&amp;lt;&lt;strong&gt;闰土大叔&lt;/strong&gt;&amp;gt;里面，欢迎关注。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180514232310270-544612060.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 May 2018 15:29:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/9038725.html</dc:identifier>
</item>
<item>
<title>spring cloud 入门系列七：基于Git存储的分布式配置中心--Spring Cloud Config - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/9036053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/9036053.html</guid>
<description>&lt;p&gt;我们前面接触到的spring cloud组件都是基于Netflix的组件进行实现的，这次我们来看下spring cloud 团队自己创建的一个全新项目：Spring Cloud Config.&lt;br/&gt;它用来为分布式系统中的基础设施和微服务提供集中化的外部配置支持，分为服务端和客户端两个部分。&lt;/p&gt;
&lt;p&gt;其中服务端也称为分布式配置中心，他是独立的微服务应用，用来连接配置仓库并为客户端提供获取接口(这些接口返回配置信息、加密、解密信息等)；&lt;/p&gt;
&lt;p&gt;客户端是微服务架构中的各个微服务应用或基础设施，它们通过制定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。&lt;br/&gt;由于配置中心默认采用Git来存储配置信息，因此我们会用到Git相关的内容，如果没有用过Git或者忘记怎么用了，可以参考下廖雪峰老师的&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;。&lt;br/&gt;另外，我自己用的Git远程仓库是码云。&lt;br/&gt;====================华丽的分割线===================&lt;br/&gt;接下来看下代码怎么实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、准备远程Git仓库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Gitee上新建一个项目https://gitee.com/sam-uncle/spring-cloud-learning&lt;/li&gt;
&lt;li&gt;在项目下新建子目录spring-cloud-config-file，然后新建三个文件
&lt;ol&gt;&lt;li&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514163008919-621335425.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;内容分别是&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-dev-1.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-test-1.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-1.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;新建一个分支config-lable-test，新分支里面新建三个同名的文件，不过内容分别是from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-dev-2.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-test-2.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-2.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、构建配置中心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;先给出最终代码结构：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514151827679-330662155.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　搭建过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建maven工程config-server&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;修改POM文件
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sam&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;config-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.1.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用dependencyManagement进行版本管理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Camden.SR6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引入config server依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-config-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;创建启动类
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @EnableConfigServer
 * 
 * 开启Spring Cloud Config 的服务端功能
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
@EnableConfigServer
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServerApp {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConfigServerApp.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;配置application.properties文件，指定远程仓库信息
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
server.port=7001&lt;span&gt;
spring.application.name&lt;/span&gt;=config-&lt;span&gt;server

#配置Git仓库的地址
spring.cloud.config.server.git.uri&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/sam-uncle/spring-cloud-learning/&lt;/span&gt;
&lt;span&gt;#配置仓库路径下的相对搜索位置，可以配置多个
spring.cloud.config.server.git.search&lt;/span&gt;-paths=spring-cloud-config-&lt;span&gt;file
#这里配置你的Git仓库的用户名
spring.cloud.config.server.git.username&lt;/span&gt;=&lt;span&gt;&lt;em&gt;用户名&lt;/em&gt;
#这里配置你的Git仓库的密码
spring.cloud.config.server.git.password&lt;/span&gt;=&lt;em&gt;密码&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;启动并验证&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　访问配置信息的URL与配置文件的映射关系如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;/{application}/{profile} [/{label}]&lt;/li&gt;
&lt;li&gt;/{application}-{profile}.yml&lt;/li&gt;
&lt;li&gt;/{label}/{application}-{profile}.yml&lt;/li&gt;
&lt;li&gt;/{application}-{profile}.properties&lt;/li&gt;
&lt;li&gt;/{label}/{appliction}-{profile}.properties&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认是master。&lt;/p&gt;
&lt;p&gt;　　　　通过浏览器访问http://localhost:7001/sam/dev/config-label-test,结果如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514204453611-2012505138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;三、实现客户端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　  &lt;/span&gt;&lt;/strong&gt;最终代码结构：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514230359517-257063183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　搭建过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建maven工程config-client&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;修改POM文件
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sam&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;config-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.1.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用dependencyManagement进行版本管理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Camden.SR6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引入config依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;创建启动类
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigClientApp {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConfigClientApp.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;配置bootstrap.properties文件，指定config-server位置
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
server.port=7002&lt;span&gt;
#{application}
spring.application.name&lt;/span&gt;=&lt;span&gt;sam
#{profile}
spring.cloud.config.profile&lt;/span&gt;=&lt;span&gt;dev
#{label}
spring.cloud.config.label&lt;/span&gt;=&lt;span&gt;master

#config server uri
spring.cloud.config.uri&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:7001/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;创建controller
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RefreshScope
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController {

    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过@Value 来讲配置文件中的值写入到代码中
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Value(&lt;/span&gt;&quot;${from}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String from;

    @RequestMapping(&lt;/span&gt;&quot;/from&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String from() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; from;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;启动并测试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514225453678-933035224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、工作原理&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Spring Cloud Config配置中心的工作原理如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端启动时，根据bootstrap.properties中配置的应用名{application}、环境名{profile}、分支名{label}，向Config Server请求获取配置信息。&lt;/li&gt;
&lt;li&gt;Config Server根据自己维护的Git仓库信息和客户传递过来的配置定位信息去查找配置信息。&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;通过git clone命令将找到的配置信息下载到本地（Config Server的文件系统中）。在通过页面访问或启动客户端的时候，我们在服务端能看到如下下载的log：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;14&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;58.055&lt;/span&gt;  INFO &lt;span&gt;3084&lt;/span&gt; --- [nio-&lt;span&gt;7001&lt;/span&gt;-exec-&lt;span&gt;1&lt;/span&gt;] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: file:/C:/Users/sam/AppData/Local/Temp/config-repo-&lt;span&gt;8627749771720918793&lt;/span&gt;/spring-cloud-config-file/sam-&lt;span&gt;dev.properties
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;14&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;58.055&lt;/span&gt;  INFO &lt;span&gt;3084&lt;/span&gt; --- [nio-&lt;span&gt;7001&lt;/span&gt;-exec-&lt;span&gt;1&lt;/span&gt;] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: file:/C:/Users/sam/AppData/Local/Temp/config-repo-&lt;span&gt;8627749771720918793&lt;/span&gt;/spring-cloud-config-file/sam.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Config Server创建Spring 的ApplicationContext实例，并从Git本地仓库中加载配置文件，最后将这些配置内容读取出来返回给客户端。&lt;/li&gt;
&lt;li&gt;客户端在获取外部配置信息后加载到客户端的applicationContext实例。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 14 May 2018 15:00:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/9036053.html</dc:identifier>
</item>
<item>
<title>设计模式之模板方法(Template Method) - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9033517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9033517.html</guid>
<description>&lt;p&gt;　　在整理模板方法之前，先来说点废话吧。除了记录学习总结，也来记录一下生活吧。&lt;/p&gt;
&lt;p&gt;　　我们公司的老板在北京，老板也会因为项目来公司，不过不是天天来。公司有个同事，只要老板不在就天天迟到，而且一天比一天晚，经常来了公司没多久，午饭的外卖就送到公司了。前几天，外卖竟然比他还来的早（外卖11点半送到的），公司一个不怎么说废话的同事说了一句“兵马未动，粮草先行”。其他同事都觉得他说的很是到位。&lt;/p&gt;

&lt;p&gt;模板方法模式的定义&lt;/p&gt;
&lt;p&gt;　　定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;　　我的理解是，在一个较为通用的流程中或步骤中，只有具体的某个步骤可能是不相同的。比如，实现一个“我下面给你吃……”，首先把水倒入锅里，第二步下面，最后把面从锅里捞出来。这个流程是固定的，但是可能第二部在南方和北方就不一样了，比如北方人吃刀削面，所以下的是刀削面，南方人吃的是热干面，所以第二步下的是热干面。也就是具体的面不一样了，而整个的流程算法是相同的。&lt;/p&gt;

&lt;p&gt;代码示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TemplateMethod {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;南方人下面给你吃&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         NanFang nf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NanFang();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        nf.zhuMian();;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         
&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;++++++++++++++++++++++++&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;北方人下面给你吃&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         BeiFang bf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeiFang();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        bf.zhuMian();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mian {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zhuMian() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;把水倒入锅里&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        xiaMian();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;把面从锅里捞出来&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         System.out.println(&quot;面给你吃&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xiaMian();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NanFang &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Mian {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xiaMian() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;热干面&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BeiFang &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Mian {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xiaMian() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         System.out.println(&quot;刀削面&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　编译运行如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201805/892439-20180514224246560-603107637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;　　总结来自于《大话设计模式》一书中第十章“考题抄错会做也白搭——模板方法模式”。&lt;/p&gt;
&lt;p&gt;1、既然用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复；&lt;/p&gt;
&lt;p&gt;2、当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理；&lt;/p&gt;
&lt;p&gt;3、模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势；&lt;/p&gt;
&lt;p&gt;4、当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。&lt;/p&gt;


</description>
<pubDate>Mon, 14 May 2018 14:55:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9033517.html</dc:identifier>
</item>
<item>
<title>模拟业务最小测试用例02 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9038472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9038472.html</guid>
<description>&lt;p&gt;Oracle数据库对很多开发人员而言，基本就只是一个存储数据的仓库，只不过这个仓库功能非常强大，额外提供了很多好用的功能，需要的时候会用就好，不会纠结于某个细节。而对很多DBA而言，正好相反，喜欢沉溺于某些细节上，对某些小知识点对应的原理理解的非常透彻，但却往往很少会站在开发层面认识Oracle。&lt;br/&gt;本文旨在构造一份相对较全面的测试数据，对开发常用的对象都模拟创建一份测试用例，DBA就可以直接拿去做一些基本测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle 11.2.0.4&lt;/p&gt;

&lt;p&gt;初始化测试数据的脚本主要包含了如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.表空间创建&lt;/li&gt;
&lt;li&gt;2.用户创建及赋权&lt;/li&gt;
&lt;li&gt;3.表创建&lt;/li&gt;
&lt;li&gt;4.索引创建&lt;/li&gt;
&lt;li&gt;5.视图、同义词、序列、dblink&lt;/li&gt;
&lt;li&gt;6.存储过程、函数、包、定时任务、触发器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;脚本：&lt;/strong&gt;initData.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
#name：initData.sh
#function：to initial data for test.
#usage: oracle用户登录，执行 sh initData.sh &amp;gt; /tmp/initData.log

#logon database
sqlplus -S / as sysdba &amp;lt;&amp;lt;EOF


prompt ============================
prompt ==  summary         
prompt ============================
prompt
prompt 1.表空间创建 
prompt 2.用户创建及赋权
prompt 3.表创建
prompt 4.索引创建
prompt 5.视图、同义词、序列、dblink
prompt 6.存储过程、函数、包、定时任务、触发器
prompt

prompt ============================
prompt == 1.表空间创建 
prompt ============================
prompt Tablespace：DBS_D_JINGYU
prompt Tablespace：DBS_I_JINGYU
prompt TEMPORARY Tablespace：TEMP_JINGYU
prompt 
-- 数据表空间
create tablespace dbs_d_jingyu datafile size 30M autoextend on maxsize 500M;
-- 临时表空间
create temporary tablespace temp_jingyu tempfile size 30M autoextend on maxsize 500M;
-- 索引表空间(可选)
create tablespace dbs_i_jingyu datafile size 30M autoextend on maxsize 500M;


prompt ============================
prompt == 2.用户创建及赋权
prompt ============================
prompt User：jingyu 权限：connect, resource
prompt User：ludan  权限：connect, resource, dba
prompt
-- 假设创建用户 jingyu 密码 jingyu，默认临时表空间 temp_jingyu， 默认数据表空间 dbs_d_jingyu。
CREATE USER jingyu IDENTIFIED BY jingyu
  TEMPORARY TABLESPACE temp_jingyu
  DEFAULT TABLESPACE dbs_d_jingyu
  QUOTA UNLIMITED ON dbs_d_jingyu;

-- 假设创建用户 ludan 密码 ludan，默认临时表空间temp_jingyu， 默认数据表空间 dbs_d_jingyu。
CREATE USER ludan IDENTIFIED BY ludan
  TEMPORARY TABLESPACE temp_jingyu
  DEFAULT TABLESPACE dbs_d_jingyu
  QUOTA UNLIMITED ON dbs_d_jingyu;

-- 赋权
grant resource, connect to jingyu;
grant resource, connect, dba to ludan;


prompt ============================
prompt == 3.表创建
prompt ============================
prompt 

prompt 3.1 普通堆表
prompt ============================
prompt
--3.1 普通堆表
--prepare 
conn /as sysdba
alter user scott identified by tiger account unlock;
conn scott/tiger
grant select on emp to jingyu;
grant select on dept to jingyu;

-- 业务用户登录
conn jingyu/jingyu
-- 删除 emp
--drop table emp cascade constraints purge;
--drop table dept cascade constraints purge;
-- 创建emp
create table emp tablespace dbs_d_jingyu as select * from scott.emp;
create table dept tablespace dbs_d_jingyu as select * from scott.dept;
-- 查询T1,T2表数据量
select count(1) from emp;
select count(1) from dept;
-- 创建后面JOB用到的表
create table t_times(col1 date);
create table t_sum(col1 date, col2 number);
create table t_times_old as select * from t_times where 1=2;

-- 业务用户登录
conn ludan/ludan
-- 创建 t_obj
create table t_obj as select * from dba_objects;
-- 查询 数据量
select count(1) from t_obj;

prompt 3.2 分区表
prompt ============================
prompt
--3.2 分区表
conn ludan/ludan
create table t_obj_part
partition by range(CREATED)
(
  partition P2015 values less than (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu,
  partition P2016 values less than (TO_DATE(' 2017-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu,
  partition P2017 values less than (TO_DATE(' 2018-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu,
  partition P2018 values less than (TO_DATE(' 2019-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu
) as select * from t_obj;

select count(1) from t_obj_part partition(P2018);

prompt 3.3 全局临时表
prompt ============================
prompt
--3.3 全局临时表
conn ludan/ludan
create global temporary table t_tmp_session on commit preserve rows as select * from dba_objects where 1 = 2;
create global temporary table t_tmp_transaction on commit delete rows as select * from dba_objects where 1 = 2;

prompt 3.4 索引组织表
prompt ============================
prompt
--3.4 索引组织表
conn jingyu/jingyu
--select dbms_metadata.get_ddl('TABLE',upper('emp'),'JINGYU') from dual;

CREATE TABLE emp_iot
   (    &quot;EMPNO&quot; NUMBER(4,0),
        &quot;ENAME&quot; VARCHAR2(10),
        &quot;JOB&quot; VARCHAR2(9),
        &quot;MGR&quot; NUMBER(4,0),
        &quot;HIREDATE&quot; DATE,
        &quot;SAL&quot; NUMBER(7,2),
        &quot;COMM&quot; NUMBER(7,2),
        &quot;DEPTNO&quot; NUMBER(2,0),
        primary key(empno)
   )organization index;

insert into emp_iot select * from emp;
commit;

--select * from jingyu.emp where empno = 7788;
--select * from jingyu.emp_iot where empno = 7788;

--select * from jingyu.emp where ename = 'SCOTT';
--select * from jingyu.emp_iot where ename = 'SCOTT';

prompt 3.5 簇表
prompt ============================
prompt
--3.5 簇表
conn jingyu/jingyu

create cluster shc
(cust_id number,
order_dt timestamp SORT)
hashkeys 10000
hash is cust_id
size 8192;

create table cust_orders(
cust_id number,
order_dt timestamp SORT,
order_number number,
username varchar2(30),
ship_addr number,
bill_addr number,
invoice_num number
)
cluster shc(cust_id, order_dt);

--select * from dba_objects where object_name = 'SHC';

prompt 3.6 外部表
prompt ============================
prompt
--3.6 外部表
conn /as sysdba
!mkdir -p /home/oracle/external_table
create or replace directory external_table as '/home/oracle/external_table';
grant read,write on directory external_table to jingyu;

conn jingyu/jingyu
create table ext_emp (ename,job,sal,dname)
organization external
(type oracle_datapump default directory external_table location('ext_emp'))
as select ename,job,sal,dname from emp join dept on emp.deptno=dept.deptno;


prompt ============================
prompt == 4.索引创建
prompt ============================
prompt 主键、外键、唯一索引、普通索引、位图索引、函数索引
prompt

prompt 4.1 普通B-Tree索引
prompt ============================
prompt
--4.1 普通B-Tree索引
--ludan.idx_t_obj_name
conn ludan/ludan
create index idx_t_obj_name on t_obj(object_name) tablespace dbs_i_jingyu;
--jingyu.empno
conn jingyu/jingyu
create index idx_emp_1 on emp(empno, ename) tablespace dbs_i_jingyu;
create index idx_emp_2 on emp(mgr) tablespace dbs_i_jingyu;

prompt 4.2 唯一索引
prompt ============================
prompt
--4.2 唯一索引
conn ludan/ludan
create unique index ux_t_obj_id on t_obj(object_id) tablespace dbs_i_jingyu;

prompt 4.3 位图索引
prompt ============================
prompt
--4.3 位图索引
conn jingyu/jingyu
create bitmap index bx_emp_job on emp(job) tablespace dbs_i_jingyu;

prompt 4.4 函数索引
prompt ============================
prompt
--4.4 函数索引
conn jingyu/jingyu
create index fx_emp_hiredate on emp(to_char(hiredate,'yyyy-mm-dd')) tablespace dbs_i_jingyu;
--select * from jingyu.emp where to_char(hiredate,'yyyy-mm-dd') = '1981-11-17';

prompt 4.5 主键、外键
prompt ============================
prompt
--4.5 主键、外键
conn jingyu/jingyu
alter table emp add constraint pk_emp_empno primary key(empno);
alter table dept add constraint pk_dept_deptno primary key(deptno);
alter table emp add constraint fk_emp_references_dept foreign key(deptno) references dept(deptno);


prompt ============================
prompt == 5.视图、同义词、序列、dblink
prompt ============================
prompt 视图、同义词、序列、dblink
prompt

prompt 5.1 视图
prompt ============================
prompt
--5.1 视图
conn /as sysdba
grant create view to jingyu;

conn jingyu/jingyu
create view emp_high_sal as select * from emp where sal &amp;gt; 3000;

prompt 5.2 同义词
prompt ============================
prompt
--5.2 同义词
conn ludan/ludan
create synonym s_emp for jingyu.emp;
create synonym s_dept for jingyu.dept;

--public synonym
create public synonym pubic_emp for jingyu.emp;
create public synonym pubic_dept for jingyu.dept;

prompt 5.3 序列
prompt ============================
prompt
--5.3 序列
conn jingyu/jingyu

--drop sequence seq_1;
create sequence seq_1 start with 1 increment by 1;

--drop table t_test_seq purge;
create table t_test_seq(id number, name varchar2(20));
insert into t_test_seq values(seq_1.nextval, 'jingyu');
insert into t_test_seq values(seq_1.nextval, 'jingyu');
insert into t_test_seq values(seq_1.nextval, 'jingyu');
commit;

prompt 5.4 dblink
prompt ============================
prompt
--5.4 dblink
--tnsnames.ora
--JYZHAO =
--  (DESCRIPTION =
--    (ADDRESS = (PROTOCOL = TCP)(HOST = jyrac-scan)(PORT = 1521))
--    (CONNECT_DATA =
--      (SERVER = DEDICATED)
--      (SERVICE_NAME = jyzhao)
--    )
--  )

--connect user
conn ludan/ludan
--private dblink
create database link to_jyzhao_jy connect to jingyu identified by jingyu using 'JYZHAO';
--public dblink
create public database link to_jyzhao_ld connect to ludan identified by ludan using 'JYZHAO';

prompt ============================
prompt == 6.存储过程、函数、包、定时任务、触发器
prompt ============================
prompt 存储过程、函数、包、定时任务
prompt

prompt 6.1 存储过程：
prompt ============================
prompt
--6.1 存储过程：
--功能：可以输入雇员名，新工资，可以修改雇员的工资。
conn jingyu/jingyu
create or replace procedure p_update_sal(v_ename varchar2,v_newsal number) is
    begin
        update emp set sal=v_newsal where ename=v_ename;
        commit;
    end;
/

prompt 6.2 函数：
prompt ============================
prompt
--6.2 函数：
--功能：输入雇员的姓名，返回该雇员的年薪。
conn jingyu/jingyu
create function f_yearSal(empName varchar2) return number is
    yearSal number(7,2);
    begin
        select sal * 12 + nvl(comm,0) * 12 into yearSal from emp where ename=empName;
        return yearSal;
    end;
/

--SQL&amp;gt; 调用函数
--var income number;
--call f_yearSal('SCOTT') into:income;
--set serveroutput on
--exec dbms_output.put_line(:income);

prompt 6.3 包：
prompt ============================
prompt
--6.3 包
--package
create package pkg_emp is
    procedure p_update_sal(v_ename varchar2,v_newsal number);
    function f_yearSal(empName varchar2) return number;
end;
/

--package body
create or replace package body pkg_emp is
    procedure p_update_sal(v_ename varchar2,v_newsal number) is
        begin
            update emp set sal=v_newsal where ename=v_ename;
            commit;
        end;
    function f_yearSal(empName varchar2) return number is
        yearSal number(7,2);
        begin
            select sal * 12 + nvl(comm,0) * 12 into yearSal from emp where ename=empName;
            return yearSal;
        end;
    end;
/


--调用包中的过程：
--call pkg_emp.p_update_sal('SMITH',133);
--调用包中的函数：
--var abc number
--call pkg_emp.f_yearSal('SMITH') into:abc;

prompt 6.4 JOB：
prompt ============================
prompt
--6.4 JOB
--select OWNER, JOB_NAME, JOB_STYLE, JOB_TYPE, STATE from DBA_SCHEDULER_JOBS;
--select JOB_NAME, JOB_STYLE, JOB_TYPE, STATE from USER_SCHEDULER_JOBS;
conn ludan/ludan

--作业功能：每秒向T_TIMES表插入当前系统时间，运行1w次后终止。
BEGIN
sys.dbms_scheduler.create_job( 
job_name =&amp;gt; '&quot;JINGYU&quot;.&quot;J_INSERT&quot;',
job_type =&amp;gt; 'PLSQL_BLOCK',
job_action =&amp;gt; 'begin
  -- Insert PL/SQL code here
  insert into t_times values(sysdate);
  commit;
end;',
repeat_interval =&amp;gt; 'FREQ=SECONDLY',
start_date =&amp;gt; to_timestamp_tz('2015-12-09 05:05:00 Asia/Shanghai', 'YYYY-MM-DD HH24:MI:SS TZR'),
job_class =&amp;gt; '&quot;DEFAULT_JOB_CLASS&quot;',
comments =&amp;gt; 'Insert the current date into the T_TIMES table.',
auto_drop =&amp;gt; FALSE,
enabled =&amp;gt; FALSE);
sys.dbms_scheduler.set_attribute( name =&amp;gt; '&quot;JINGYU&quot;.&quot;J_INSERT&quot;', attribute =&amp;gt; 'max_runs', value =&amp;gt; 10000); 
END;
/

--ENABLE(启动作业)
exec dbms_scheduler.enable('&quot;JINGYU&quot;.&quot;J_INSERT&quot;');
--DISABLE(禁用作业)
--exec dbms_scheduler.disable('&quot;JINGYU&quot;.&quot;J_INSERT&quot;');
--DROP_JOB（删除作业）
--exec dbms_scheduler.drop_job('&quot;J_INSERT&quot;');



prompt 6.5 触发器：
prompt ============================
prompt
--6.5 Trigger
conn jingyu/jingyu
--功能：只要有更新emp表的操作，就会记录sal字段的变化。
--drop table aud_salary_history;
create table aud_salary_history(
empno NUMBER(4),
old_sal NUMBER(7,2),
new_sal NUMBER(7,2),
change_time varchar2(50)
);

create or replace trigger tri_sal after update
on emp
    for each row
begin
    insert into aud_salary_history VALUES
  (:OLD.empno, :OLD.sal, :NEW.sal, TO_CHAR(SYSDATE, 'yyyy-mm-dd hh24:mi:ss'));
end;
/

--update emp set sal = 1000 where empno=7369;
--select * from aud_salary_history;
--rollback;

prompt ============================
prompt ===initData Completed!!!====
prompt ============================

EOF&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;清空测试数据的脚本主要包含如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.删除用户&lt;/li&gt;
&lt;li&gt;2.删除表空间&lt;/li&gt;
&lt;li&gt;3.删除public对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;脚本：&lt;/strong&gt;delData.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
#name：delData.sh
#function：to delete data for test.
#usage: oracle用户登录，执行 sh delData.sh &amp;gt; /tmp/delData.log

#logon database
sqlplus -S / as sysdba &amp;lt;&amp;lt;EOF

prompt ============================
prompt == 1.Drop User
prompt ============================
prompt 
--drop user 
--select s.username, s.sid, s.serial#, p.spid from v$session s, v$process p where s.paddr = p.addr and s.username = 'JINGYU';
select s.username, s.sid, s.serial#, p.spid from v\$session s, v\$process p where s.paddr = p.addr and s.username is not null;
drop user ludan cascade;
drop user jingyu cascade;

prompt ============================
prompt == 2.Drop Tablespace
prompt ============================
prompt 
--drop tablespace
drop tablespace dbs_d_jingyu including contents and datafiles;
drop tablespace dbs_i_jingyu including contents and datafiles;
drop tablespace temp_jingyu including contents and datafiles;

prompt ============================
prompt == 3.Drop Public Objects
prompt ============================
prompt 
--public dblink
select dbms_metadata.get_ddl('DB_LINK',DB_LINK,'PUBLIC') FROM DBA_DB_LINKS where owner='PUBLIC';
drop public database link TO_JYZHAO_LD;
select dbms_metadata.get_ddl('DB_LINK',DB_LINK,'PUBLIC') FROM DBA_DB_LINKS where owner='PUBLIC';

--public synonym
SELECT DBMS_METADATA.GET_DDL('SYNONYM',a.SYNONYM_NAME,a.owner) FROM DBA_SYNONYMS a where a.owner ='PUBLIC' and table_owner in ('JINGYU','LUDAN');
drop public synonym PUBIC_DEPT;
drop public synonym PUBIC_EMP;
SELECT DBMS_METADATA.GET_DDL('SYNONYM',a.SYNONYM_NAME,a.owner) FROM DBA_SYNONYMS a where a.owner ='PUBLIC' and table_owner in ('JINGYU','LUDAN');

--external tables
select * from dba_external_tables;
--外部表会随用户被删除而删除,但外部表真实的文件还在，需要删除掉（rm命令危险，故注释掉手工执行）：
--!rm -rf /home/oracle/external_table

prompt ============================
prompt ===delData Completed!!!====
prompt ============================

EOF&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 14 May 2018 14:53:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9038472.html</dc:identifier>
</item>
<item>
<title>基于ASP.NET MVC 微信网页登录授权(scope为snsapi_base) 流程  上 获取OPENID - SuiTao</title>
<link>http://www.cnblogs.com/suitao/p/9038547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suitao/p/9038547.html</guid>
<description>&lt;p&gt;流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/933224/201805/933224-20180514214718940-503038980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们需要判断是否存在OPENID  首先我们得先定义一个全局的OPENID 类似于普通账号密码登录系统的 当前登录用户ID  因为我是MVC 框架  我这里定义一个控制器基类 BaseController 然后将OPENID定义在BaseController中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseController : Controller
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; openid
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后定义一个HomeController   写一个 测试登录功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : BaseController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Home&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Login()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(openid)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openid不存在  跳转授权&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处忽略10万行授权相关代码&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处忽略3000行获取用户信息相关&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上为一个大概 忽略大部分无关紧要代码后的微信授权登录功能代码     当然很多人要的都不是这些  接下来 是一些更详细的代码  大概分为2个大模块&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取OPENID &lt;/li&gt;
&lt;li&gt;获取用户信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我将这2个模块写成2个方法定义在WXHelper类中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WXHelper {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetOpenID() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User_UserInfo GetUserInfo() {
            User_UserInfo model_UserInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User_UserInfo();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; model_UserInfo;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后之前的Login Action 可以改成这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Login()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(openid)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openid不存在  跳转授权&lt;/span&gt;
&lt;span&gt;            {
                openid &lt;/span&gt;=&lt;span&gt; WXHelper.GetOpenID();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LoginUserInfo 是我当前登录用户信息  你们自行找方式存 Session 或者全局变量之类的&lt;/span&gt;
            LoginUserInfo =&lt;span&gt; WXHelper.GetUserInfo();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们开始实现第一个方法    GetOpenID  &lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140842&quot;&gt;官方API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里具体请求我就不 多说了   主意 几个地方  这里我是采用的 方式为 scope=snsapi_base  &lt;/p&gt;
&lt;p&gt;因为这里回调地址 无法写本地地址进行调试 所以我采用 手动记录code  并在有效期内手动在本地写入code 继续往下调试&lt;/p&gt;
&lt;p&gt;不情愿的贴上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取code 方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetWeChat_Code()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; urlhead = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; rediretUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https%3a%2f%2fxxxx.com%2fHome%2fLoadCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strUrl = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{urlhead}open.weixin.qq.com/connect/oauth2/authorize?appid={appid}&amp;amp;redirect_uri={rediretUrl}&amp;amp;response_type=code&amp;amp;scope=snsapi_base&amp;amp;state=qwe12e12e#wechat_redirect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处省略n行get请求方法&lt;/span&gt;
        }    
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;细心的朋友可能会发现上面的redireUrl 地址指向的是Home 控制器下面 LoadCode 这个 方法  SO&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;#region&lt;/span&gt; 微信授权回调
        &lt;span&gt;public&lt;/span&gt; ActionResult LoadCode(&lt;span&gt;string&lt;/span&gt; code, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; state)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为MVC 的参数映射 所以我只需要把 code  和state  写成方法参数即可 这里我就可以获取到code方法了 然后我们直接通过code 获取OPENID &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;#region&lt;/span&gt; 获取OpenID

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetOpenId(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; code)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; urlhead = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strUrl = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{urlhead}api.weixin.qq.com/sns/oauth2/access_token?appid={appid}&amp;amp;secret={secret}&amp;amp;code={code}&amp;amp;grant_type=authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Access_openid token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Access_openid();
            HttpWebRequest req &lt;/span&gt;= (HttpWebRequest)HttpWebRequest.Create(strUrl);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用GET形式请求指定的地址 &lt;/span&gt;
            req.Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (WebResponse wr =&lt;span&gt; req.GetResponse())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HttpWebResponse myResponse = (HttpWebResponse)req.GetResponse();  &lt;/span&gt;
                StreamReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(wr.GetResponseStream(), Encoding.UTF8);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content =&lt;span&gt; reader.ReadToEnd();
                reader.Close();
                reader.Dispose();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里对Access_token 赋值  &lt;/span&gt;
                token = JsonConvert.DeserializeObject&amp;lt;Access_openid&amp;gt;&lt;span&gt;(content);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token.openid;
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果有人对这个Access_openid 对象感到懵逼的话  这里说一下 这个对象就是下图中 红框 获取到的JSON数据 的对象 这里我们是  snsapi_base  所以只需要 openid 切 整个授权过程到次结束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/933224/201805/933224-20180514221448285-298646113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 May 2018 14:36:00 +0000</pubDate>
<dc:creator>SuiTao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suitao/p/9038547.html</dc:identifier>
</item>
<item>
<title>flask模板 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/9038533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/9038533.html</guid>
<description>&lt;p&gt;做为python web开发领域的一员，flask跟Django在很多地方用法以都是相似的，比如flask的模板&lt;/p&gt;
&lt;p&gt;模板就是服务器端的页面，在模板中可以使用服务端的语法进行输出控制&lt;/p&gt;
&lt;h2 id=&quot;模板的工作原理&quot;&gt;1.模板的工作原理&lt;/h2&gt;
&lt;p&gt;在视图函数中，通过&lt;code&gt;render_template&lt;/code&gt;方法返回一个页面，然后通过Jinja2语法来进行渲染&lt;/p&gt;
&lt;p&gt;简单来说，就是把服务器端的html页面解释成用户看到的页面，而视图函数是通过上下文对象来进行变量的传递&lt;/p&gt;
&lt;p&gt;在项目开发中，视图函数经常会把一些服务器处理完成的变量传递给前端页面进行渲染，&lt;/p&gt;
&lt;p&gt;比如在下面的例子中，由&lt;code&gt;render_template&lt;/code&gt;返回html页面时，携带一些变量数据给Jinja2语法进行渲染&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Flask, render_template

app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Flask(&lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt;)
app.debug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; hello_world():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello World!'&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'杰克'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message)

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    app.run(debug&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端页面detail.html内容为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动项目，浏览器打开&lt;code&gt;http://127.0.0.1:5000/detail&lt;/code&gt;页面，前端页面渲染后效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223019668-153588341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么此时，如果后台返回给前端的变量为一段html代码，返回给前端经过Jinja2语法渲染后，效果会是怎么样的呢？？&lt;/p&gt;
&lt;h2 id=&quot;jinja2语法安全机制&quot;&gt;2.Jinja2语法安全机制&lt;/h2&gt;
&lt;p&gt;修改message变量，然后由render_template返回&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'&amp;lt;h2&amp;gt;杰克&amp;lt;/h2&amp;gt;'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端页面不变，刷新浏览器，效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223029235-1752825641.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，返回的变量中包含html代码，但是Jinja2语法并没有对这一小段代码进行渲染，而是直接显示了出来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;实际上这是为了安全，因为如果后台返回的html代码中包含恶意的js代码，如果直接就渲染了，会造成站点被攻击。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那如果我就是想渲染后台返回给前端的HTML代码，那应该怎么办呢&lt;/p&gt;
&lt;p&gt;在flask中，如果确认后台返回给前端进行渲染的变量中包含的HTML代码是安全的，则可以使用一些方法来对这段HTML代码也进行渲染&lt;/p&gt;
&lt;h3 id=&quot;方法一autoescape-关闭安全机制&quot;&gt;方法一：autoescape 关闭安全机制&lt;/h3&gt;
&lt;p&gt;这种方法与Django的模板语法相同&lt;/p&gt;
&lt;p&gt;后台代码不变，修改前端detail.html代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
{% autoescape false %}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endautoescape %}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，再次刷新页面，查看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223039083-2049570692.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法二调用jinja2的safe过滤器&quot;&gt;方法二，调用Jinja2的safe过滤器&lt;/h3&gt;
&lt;p&gt;如果觉得第一种方法有点麻烦，可以使用第二种方法&lt;/p&gt;
&lt;p&gt;后台代码不变，同样修改detail.html页面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text | safe }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，再次刷新页面，效果跟第一种方法一样&lt;/p&gt;
&lt;p&gt;在flask中，Jinja2语法提供了很多过滤器，可以在下面的地址进行查找&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://jinja.pocoo.org/docs/dev/templates/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义过滤器&quot;&gt;3.自定义过滤器&lt;/h2&gt;
&lt;p&gt;在写文章或博客的时候，很多时候都会用到Markdown语法&lt;/p&gt;
&lt;p&gt;在flask的Jinja2语法中，并没有标准的Markdown语法过滤器，此时可以使用扩展来自定义Markdown语法过滤器&lt;/p&gt;
&lt;p&gt;修改flask项目文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Flask, render_template

app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Flask(&lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt;)
app.debug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; hello_world():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello World!'&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'&amp;lt;h2&amp;gt;杰克&amp;lt;/h2&amp;gt;'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message,markdown&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'## Markdown编辑器&amp;lt;br&amp;gt;`注释`'&lt;/span&gt;)

&lt;span class=&quot;at&quot;&gt;@app.template_filter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'md'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; markdown_html(txt):
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; markdown &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; markdown
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; markdown(txt)

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    app.run(debug&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改detail.html前端页面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text | safe }}
    {{ markdown | md | safe }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新浏览器，查看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223049570-154627894.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际开发中，&lt;code&gt;后台向模板中传递的不只有变量和filter，还可能会向前端传递一个方法&lt;/code&gt;，此时可以使用flask的上下文来实现&lt;/p&gt;
&lt;p&gt;修改flask项目文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#-*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Flask, render_template

app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Flask(&lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt;)
app.debug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; hello_world():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello World!'&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; read_md(filename):
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;reduce&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(filename,encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; md_file:
        content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;reduce&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x,y:x &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; y, md_file.readlines())
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; content

&lt;span class=&quot;at&quot;&gt;@app.context_processor&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; methods():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;dict&lt;/span&gt;(read_md&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;read_md)

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'&amp;lt;h2&amp;gt;杰克&amp;lt;/h2&amp;gt;'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message,markdown&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'## Markdown'&lt;/span&gt;)

&lt;span class=&quot;at&quot;&gt;@app.template_filter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'md'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; markdown_html(txt):
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; markdown &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; markdown
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; markdown(txt)

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    app.run(debug&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想在Jinja2语法中调用后台定义的某个函数时，比如在这个例子中，前端页面中调用后台定义的read_md方法来处理某个Markdown格式的文件时，可以使用&lt;code&gt;context_processor上下文处理器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在项目中应用了context_processor时，&lt;code&gt;flask会把context_processor装饰的方法注册到Jinja2模板语法中&lt;/code&gt;来，这样就可以在Jinja2语法中调用后台的方法了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用context_processor装饰的后台方法可以在前端所有的Jinja2语法中调用&lt;br/&gt;修改前端页面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text | safe }}
    {{ markdown | md | safe }}
    {{ read_md('editor.md') |md| safe}}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新浏览器，查看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223104986-147615258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用过滤器和context_processor配置一起使用时，可以很灵活的进行页面的渲染&lt;/p&gt;
</description>
<pubDate>Mon, 14 May 2018 14:32:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/9038533.html</dc:identifier>
</item>
</channel>
</rss>