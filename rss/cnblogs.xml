<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[js高手之路]html5 canvas动画教程 - 边界判断与小球粒子模拟喷泉,散弹效果 - ghostwu</title>
<link>http://www.cnblogs.com/ghostwu/p/7645789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghostwu/p/7645789.html</guid>
<description>&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;本文后面的代码，如果加载了ball.js，那么请使用这篇文章&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/ghostwu/p/7638492.html&quot;&gt;[js高手之路] html5 canvas动画教程 - 匀速运动&lt;/a&gt;的ball.js代码.&lt;/p&gt;
&lt;p&gt;本文，我们要做点有意思的效果，首先，来一个简单的边界判断，所谓边界判断：就是把物体的运动限定在一个范围内.我们先来一个简单的实例，&lt;span&gt;在canvas上生成一个小球，小球的初始位置是在canvas的正中间，然后通过键盘的上下左右来移动小球的位置，如果小球碰到canvas的左边，那么不能再向左运动，其他方向同理&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;要实现这个效果，只需要一个边界判断，即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkBorder() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ( ball.x &amp;lt; ball.radius ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰到左边界&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         ball.x =&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( ball.y &amp;lt; ball.radius ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰到上边界&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         ball.y =&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( ball.x &amp;gt; width - ball.radius ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰到右边界&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         ball.x = width -&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( ball.y &amp;gt; height -&lt;span&gt; ball.radius ){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         ball.y = height -&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;左边界：只要判断小球的圆心x 如果小于小球的半径，那肯定是碰到了左边界，我们就让小球的中心x等于小球的半径。&lt;/p&gt;
&lt;p&gt;右边界：只要判断小球的圆心x 如果大于canvas的宽度减去小球的半径，那肯定是碰到了右边界，我们就让小球的中心x等于canvas的宽度减去小球的半径&lt;/p&gt;
&lt;p&gt;其他上下边界跟左右是同理。&lt;/p&gt;
&lt;p&gt;完整的实例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;meta charset='utf-8' /&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        #canvas {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            border: 1px dashed #aaa;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;script src=&quot;./ball.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oCanvas = document.querySelector(&quot;#canvas&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 oGc = oCanvas.getContext('2d'&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 width = oCanvas.width, height =&lt;span&gt; oCanvas.height,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 ball = &lt;span&gt;new&lt;/span&gt; Ball(width / 2, height / 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                ball.fill( oGc );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             addEventListener(&quot;keydown&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 oGc.clearRect(0, 0&lt;span&gt;, width, height);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; oEvent = ev ||&lt;span&gt; event;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (oEvent.keyCode) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 37&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         ball.x -= 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 39&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         ball.x += 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 38&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         ball.y -= 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 40&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         ball.y += 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkBorder() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ( ball.x &amp;lt; ball.radius ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰到左边界&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                     ball.x =&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( ball.y &amp;lt; ball.radius ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰到上边界&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                     ball.y =&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( ball.x &amp;gt; width - ball.radius ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰到右边界&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                     ball.x = width -&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( ball.y &amp;gt; height -&lt;span&gt; ball.radius ){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     ball.y = height -&lt;span&gt; ball.radius;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;55&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;58&lt;/span&gt;     &amp;lt;canvas id=&quot;canvas&quot; width=&quot;1200&quot; height=&quot;600&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;span&gt;59&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;边界穿透：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果小球向左运动，且完全超出左边界，我们就让他从右边出来，如果小球向右运动，且完全超出右边界，我们就让他从左边出来。上下方向同理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;meta charset='utf-8' /&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        #canvas {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            border: 1px dashed #aaa;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;script src=&quot;./ball.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oCanvas = document.querySelector(&quot;#canvas&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 oGc = oCanvas.getContext('2d'&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 width = oCanvas.width, height =&lt;span&gt; oCanvas.height,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 ball = &lt;span&gt;new&lt;/span&gt; Ball(width / 2, height / 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             addEventListener(&quot;keydown&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 oGc.clearRect(0, 0&lt;span&gt;, width, height);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; oEvent = ev ||&lt;span&gt; event;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (oEvent.keyCode) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 37&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         ball.x -= 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 39&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         ball.x += 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 38&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         ball.y -= 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;case&lt;/span&gt; 40&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         ball.y += 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                        checkBorder();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkBorder() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (ball.x &amp;lt; -ball.radius) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完全超出左边界&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                     ball.x = width + ball.radius; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让球从右边出来&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ball.y &amp;lt; -ball.radius) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完全超出上边界&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                     ball.y = height + ball.radius;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让球从下面出来&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ball.x &amp;gt; width + ball.radius) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完全超出右边界&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                     ball.x = -ball.radius;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让球从左边出来&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ball.y &amp;gt; height + ball.radius) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完全超出下边界&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;                     ball.y = -ball.radius; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让球从上边出来&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;55&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;58&lt;/span&gt;     &amp;lt;canvas id=&quot;canvas&quot; width=&quot;1200&quot; height=&quot;600&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;span&gt;59&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;散弹效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过canvas的中心点，不停的向四周发射小球，形成散弹的效果. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我不知道你们有没有这样的误区：不停的向四周发射小球，那是不是要不停的创造小球呢？如果你这样想，程序就算写出来了，肯定会卡死.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实我们可以只创建，一定数量的小球，比如( 50, 60. ...100 )，然后当这些小球，完全超出的边界的时候，再把这些小球的圆心( x, y )设定到最开始的位置，再次随机x和y方向的速度，就可以达到目的了， 说白了就是，那个完全超出边界的小球，我们让他重新回到最初的地方，只是改变了他的颜色和速度，给人感觉就是那个发射小球的地方源源不断的在发射小球&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171010150853012-922511050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的散弹效果：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;meta charset='utf-8' /&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        #canvas {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            border: 1px dashed #aaa;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;script src=&quot;./ball.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oCanvas = document.querySelector(&quot;#canvas&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 oGc = oCanvas.getContext('2d'&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 width = oCanvas.width, height =&lt;span&gt; oCanvas.height,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 balls = [], n = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getRandColor() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; '#' + ( &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( color ){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; ( color += '0123456789abcdef' [Math.floor( Math.random() * 16 )] ) &amp;amp;&amp;amp; ( color.length == 6 ) ?&lt;span&gt; color : arguments.callee( color );
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 } )( ''&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; n; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ball = &lt;span&gt;new&lt;/span&gt; Ball( width / 2, height / 2, 20&lt;span&gt;, getRandColor() );
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 ball.vx = ( Math.random() * 2 - 1 ) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 ball.vy = ( Math.random() * 2 - 1 ) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                balls.push( ball );
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; move(){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 oGc.clearRect( 0, 0&lt;span&gt;, width, height );
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 balls.forEach( &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( ball ){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ( ball.x &amp;lt; -&lt;span&gt;ball.radius
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         || ball.x &amp;gt; width +&lt;span&gt; ball.radius
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         || ball.y &amp;lt; -&lt;span&gt;ball.radius
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         || ball.y &amp;gt; height +&lt;span&gt; ball.radius ) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             ball.x = width / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                             ball.y = height / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             ball.vx = ( Math.random() * 2 - 1 ) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                             ball.vy = ( Math.random() * 2 - 1 ) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     ball.x +=&lt;span&gt; ball.vx;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     ball.y +=&lt;span&gt; ball.vy;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    ball.fill( oGc );
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                } );
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                requestAnimationFrame( move );
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            })();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;46&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;47&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;48&lt;/span&gt;     &amp;lt;canvas id=&quot;canvas&quot; width=&quot;1200&quot; height=&quot;600&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;span&gt;49&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们可以在之前的基础上，加上重力的影响，实现喷泉的效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171010153654215-782628878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这张图，看着是不是更像喷泉？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171010155719965-1104970084.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;meta charset='utf-8' /&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        #canvas {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            border: 1px dashed #aaa;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;script src=&quot;./ball.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oCanvas = document.querySelector(&quot;#canvas&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 oGc = oCanvas.getContext('2d'&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 width = oCanvas.width, height =&lt;span&gt; oCanvas.height,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 balls = [], n = 50, gravity = 0.2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getRandColor() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; '#' + (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (color) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; (color += '0123456789abcdef'[Math.floor(Math.random() * 16)]) &amp;amp;&amp;amp; (color.length == 6) ?&lt;span&gt; color : arguments.callee(color);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 })(''&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; n; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ball = &lt;span&gt;new&lt;/span&gt; Ball(width / 2, height / 2, 20&lt;span&gt;, getRandColor());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 ball.vx = (Math.random() * 2 - 1) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 ball.vy = (Math.random() * 2 - 1) * 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                balls.push(ball);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; move() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 oGc.clearRect(0, 0&lt;span&gt;, width, height);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 balls.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ball) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (ball.x &amp;lt; -&lt;span&gt;ball.radius
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         || ball.x &amp;gt; width +&lt;span&gt; ball.radius
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         || ball.y &amp;lt; -&lt;span&gt;ball.radius
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         || ball.y &amp;gt; height +&lt;span&gt; ball.radius) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         ball.x = width / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         ball.y = height / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         ball.vx = (Math.random() * 2 - 1) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         ball.vy = (Math.random() * 2 - 1) * 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     ball.x +=&lt;span&gt; ball.vx;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     ball.y +=&lt;span&gt; ball.vy;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     ball.vy +=&lt;span&gt; gravity;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                    ball.fill(oGc);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                requestAnimationFrame(move);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            })();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;47&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;50&lt;/span&gt;     &amp;lt;canvas id=&quot;canvas&quot; width=&quot;1200&quot; height=&quot;600&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;span&gt;51&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以通过控制小球的vx, vy，就是x方向和y方向的速度，来限制小球朝某一个方向发射，下面的例子，我们只让小球朝着x轴的右边发射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;meta charset='utf-8' /&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        #canvas {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            border: 1px dashed #aaa;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;script src=&quot;./ball.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;10&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oCanvas = document.querySelector(&quot;#canvas&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 oGc = oCanvas.getContext('2d'&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 width = oCanvas.width, height =&lt;span&gt; oCanvas.height,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 balls = [], n = 50&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getRandColor() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; '#' + ( &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( color ){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; ( color += '0123456789abcdef' [Math.floor( Math.random() * 16 )] ) &amp;amp;&amp;amp; ( color.length == 6 ) ?&lt;span&gt; color : arguments.callee( color );
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 } )( ''&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; n; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ball = &lt;span&gt;new&lt;/span&gt; Ball( width / 2, height / 2, 20&lt;span&gt;, getRandColor() );
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 ball.vx = Math.abs( ( Math.random() * 2 - 1 ) * 5&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 ball.vy = ( Math.random() * 2 - 1 ) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                balls.push( ball );
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; move(){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 oGc.clearRect( 0, 0&lt;span&gt;, width, height );
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 balls.forEach( &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( ball ){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ( ball.x &amp;lt; -&lt;span&gt;ball.radius
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         || ball.x &amp;gt; width +&lt;span&gt; ball.radius
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         || ball.y &amp;lt; -&lt;span&gt;ball.radius
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         || ball.y &amp;gt; height +&lt;span&gt; ball.radius ) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             ball.x = width / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                             ball.y = height / 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             ball.vx = Math.abs( ( Math.random() * 2 - 1 ) * 5&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                             ball.vy = ( Math.random() * 2 - 1 ) * 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     ball.x +=&lt;span&gt; ball.vx;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     ball.y +=&lt;span&gt; ball.vy;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    ball.fill( oGc );
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                } );
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                requestAnimationFrame( move );
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            })();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;46&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;47&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;48&lt;/span&gt;     &amp;lt;canvas id=&quot;canvas&quot; width=&quot;1200&quot; height=&quot;600&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;span&gt;49&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171010153710012-694515484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 07:38:00 +0000</pubDate>
<dc:creator>ghostwu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ghostwu/p/7645789.html</dc:identifier>
</item>
<item>
<title>JavaWeb（六）之MVC与三层架构设计 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7645581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7645581.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这段时间要学习hadoop，但是也希望把自己的web知识复习起来。所以花自己休息的时间把这些web的知识好好的巩固一下！没有什么可以阻挡我前进的脚步。&lt;/p&gt;
&lt;p&gt;　　首先我们先了解一下：　　&lt;/p&gt;
&lt;p&gt;　　　　C/S：客户端 / 服务器 （胖客户端）&lt;br/&gt;　　　　B/S：浏览器 / 服务器 （瘦客户端）&lt;br/&gt;　　　　JavaBean:就是一个普通类（实体bean），包含三样标准：一个无参构造、私有属性、公共的getter和setter方法。&lt;/p&gt;

&lt;p&gt;　　其实在前面中javaweb知识中我们主要讲了两大类：一是servlet，二是jsp。&lt;br/&gt;　　Servlet就是&lt;span&gt;为了解决静态页面的问题，能够实现动态的页面&lt;/span&gt;，使维护，开发更加的方便，但是也有缺点，&lt;span&gt;在Servlet嵌入HTML代码实在是太麻烦了&lt;/span&gt;，每次都要out.println();输出。&lt;br/&gt;　　所以就有了Jsp，&lt;span&gt;J&lt;/span&gt;&lt;span&gt;SP中的内容就是html，为的就是方便写html，写页面，本质上JSP也是一个servlet&lt;/span&gt;，所以在它中也会&lt;span&gt;不可避免的要写一些java代码，也就是脚本，为了不让其那么混乱，就增加了标签，EL表达式来尽量代替脚本&lt;/span&gt;。&lt;br/&gt;　　但是在写一些项目时，还是会很麻烦，原因是&lt;span&gt;业务逻辑代码，与数据库交互的代码，HTML代码这些类别，风格，作用完全不同的都混杂在了一起，造成的结果是代码的维护性，可读性以及扩张性都非常差&lt;/span&gt;，比如要改一个需求，&lt;br/&gt;　　那么必须要把全部代码都看完，理解到，不然你可能会因为修改了一处代码，导致别的地方多处错误，这种设计模式也叫做 模式一(Model 1)。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010134748777-2092979906.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.1、概述&lt;/h2&gt;
&lt;p&gt;　　为了改进上面所说的缺点，也就是&lt;span&gt;将业务逻辑代码放一起，显示页面的HTML代码放一起，与数据库交互的代码放一起&lt;/span&gt;，这样&lt;span&gt;开发思路更加清晰，维护起来也更加方便，这种就叫做MVC模&lt;/span&gt;式。&lt;/p&gt;
&lt;p&gt;　　M：Model 模型，代表着&lt;span&gt;业务逻辑代码与数据库代码&lt;/span&gt;，V：View 对&lt;span&gt;数据的展示代码&lt;/span&gt;，比如JSP页面，就是专门用来展示数据，美化页面的 。&lt;/p&gt;
&lt;p&gt;　　C:Controller　控制，&lt;span&gt;Servlet来充当这一角色，连接着View和Model，从View中获得指令，在从model中通过业务逻辑代码获取需要的数据，然后在通过Servlet去交给View层去显示&lt;/span&gt;。也就是MVC三层结构的意义！&lt;/p&gt;
&lt;p&gt;　　用图分析就是：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010135105543-296757037.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;388&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们打开浏览器，输入网址，就是到服务器中请求页面(JSP也可能是别的)，然后&lt;span&gt;显示到浏览器&lt;/span&gt;上，然后通过&lt;span&gt;点击JSP页面上的内容，提交请求，到服务器中，也就到了Control(Servlet)这一块&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　Servlet通过分析请求，知道用户需要什么，需要数据，那么就通过Model，从数据库拿到数据，在将数据显示在JSP中，在将JSP发送回浏览器，显示在用户看，&lt;/p&gt;
&lt;p&gt;　　所以我们经常说，JSP就是View层，给用户看的，Servlet作为控制流程，而编写操作数据库代码，业务逻辑代码就属于Model。这就是MVC的应用。&lt;/p&gt;
&lt;h2&gt;2.2、分析　&lt;/h2&gt;
&lt;p&gt;　　JSP + Servlet + JavaBean&lt;br/&gt;　　MVC:开发模式&lt;br/&gt;　　M: Model模型 JavaBean|四种作用域&lt;br/&gt;　　V：view视图 JSP&lt;br/&gt;　　C:Controller控制器 Servlet&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010143913777-1069751792.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;252&quot;/&gt;　&lt;/p&gt;

&lt;p&gt;　　表示层(web层)、业务逻辑层(service层)、数据访问层(dao层)，用一张图来描述这其中的关系：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010143322215-36469527.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为现在只学习Servlet，Jsp，所以在&lt;span&gt;表示层中就放的是Servlet和Jsp了&lt;/span&gt;，如果学了3大框架，Struts、Hibernate、Spring、会发现Struts是处理表示层的一个框架，而Hibernate是在dao层的一个框架，spring就是service层了。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010143442652-443316387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分层思想：&lt;span&gt;强内聚、弱耦合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　实际项目中的&lt;span&gt;包命名结构，其也是按照三层架构思想来进行编写代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171010144508418-586276199.png&quot; alt=&quot;&quot; width=&quot;654&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：（xxx:代表公司名称、yyy：代表项目名称）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　com.xxx.yyy.dao　　　　　　dao层接口
　　　　　　com.xxx.yyy.dao.impl　　　　dao层实现
　　　　　　com.xxx.yyy.service　　　　service层接口
　　　　　　com.xxx.yyy.service.impl　　service层实现　　　　　　
　　　　　　com.xxx.yyy.web　　　　　　web层
　　　　　　com.xxx.yyy.util　　　　　　工具包
　　　　　　com.xxx.yyy.domain　　　　javabean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、总结&lt;/p&gt;
&lt;p&gt;经典三层架构和MVC的关系：&lt;/p&gt;
&lt;p&gt;　　他们是两个毫无相关的东西，&lt;span&gt;经典三层架构是一种分层思想，将开发模式分为了这三&lt;/span&gt;&lt;span&gt;层&lt;/span&gt;，每个人根据自己的专长，开发不同的模块，比如，前端工程师，那么就专研表示层即可，想办法如何让页面变的更好看，&lt;/p&gt;
&lt;p&gt;　　如何吸引别人，而有些专门做数据库工作的人，就可以只关注操作数据库的活，如何让查询更加快速有效，而不必关注数据该如何显示这种问题。这就是分层带来的巨大好处。&lt;/p&gt;
&lt;p&gt;　　而MVC是&lt;span&gt;一种设计模式，目的是让HTML代码和业务逻辑代码分开，让代码看起来更加清晰，便于开发&lt;/span&gt;。　　&lt;/p&gt;
&lt;p&gt; 　　如果说他们有关系的话：只能说他们有共同的点，分层，解耦。&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 06:49:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7645581.html</dc:identifier>
</item>
<item>
<title>21.Linux-写USB键盘驱动(详解) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/7645527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/7645527.html</guid>
<description>&lt;td id=&quot;main&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;post&quot;&gt;
&lt;div class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/lifexy/p/7645527.html&quot;&gt;21.Linux-写USB键盘驱动(详解)&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;postText&quot; readability=&quot;100.43660773376&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;342.08111941004&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;本节目的:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　根据上节写的&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7641602.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;USB鼠标驱动&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;,来依葫芦画瓢写出&lt;strong&gt;键盘驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.首先我们通过上节的代码中修改,来打印下键盘驱动的数据到底是怎样的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来回忆下,我们之前写的鼠标驱动的id_table是这样:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142516824-1387856641.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;216&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们要修改id_table,使这个驱动为键盘的驱动,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142547980-931139209.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后修改中断函数,通过printk()打印数据:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先按下按键A为例,打印出0x04,如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142552074-1634725233.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们再同时按下按键A和S,打印出0x04,0X16, 如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142556059-1145817763.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然这些普通按键都是从buf[2]开始的,那第一个数组到底又存什么值？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们按完所有键盘按键,发现只有8个按键会打印在buf[0]里,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142601684-982284384.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以buf[0]是用来保存键盘的特定功能的键,而buf[1]可能是个保留键,没有用到的,&lt;/span&gt;&lt;span&gt;buf[2]~buf[7]是普通按键,比如ABCD,1234,F1,F2等等,能支持最多6个按键同时按下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.那么每个按键的数据又是怎么定义的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1比如我们按下按键A,为什么打印0X04?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们找到输入子系统(input.h)中按键A定义的值,它对应的却是30,看来不是直接调用的,如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142610449-514611546.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们再来参考内核自带的USB键盘驱动 (/drivers/hid/usbhid/usbkbd.c)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现它的中断函数中有个键盘描述码表(其中0表示保留的意思):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142627137-77628081.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;发现该数组的0X04就是0X30,看来要写个键盘驱动,还需要上面的数组才行.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么问题又来了,如果我们按下左alt键,buf[0]中会出现0x04,如果也代入到键盘描述码表中,显然就会当作键盘按键A来使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2.2&lt;/span&gt;我们来分析内核的键盘中断函数是如何处理的：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现有这么一句:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt;)

       input_report_key(kbd&lt;/span&gt;-&amp;gt;dev, usb_kbd_keycode[i+ &lt;span&gt;224&lt;/span&gt;], (kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] &amp;gt;&amp;gt; i) &amp;amp; &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;其中kbd-&amp;gt;new表示的就是键盘数据数组,它将buf[0]的每一位通通以usb_kbd_keycode[i+ 224]的形式上传到按键事件中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然我们的buf[0]的0X04就是上传的usb_kbd_keycode[4+ 224]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3我们来看看usb_kbd_keycode[226]里的数据对应的到底是不是左ALT键&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到usb_kbd_keycode[226]=56:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142642121-1162789310.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后再进入input.h,找到56的定义,刚好就是KEY_LEFTALT(左边的alt键)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010142647137-1997097355.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.接下来再来仔细分析下内核自带的USB键盘驱动usbkbd.c里的中断函数:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; usb_kbd_irq(&lt;span&gt;struct&lt;/span&gt; urb *&lt;span&gt;urb)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; usb_kbd *kbd = urb-&amp;gt;&lt;span&gt;context;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
       &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (urb-&amp;gt;status) {                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有urb-&amp;gt;status==0时,说明数据传输成功&lt;/span&gt;
       &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:                  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; success &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
              &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -ECONNRESET:     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; unlink &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;case&lt;/span&gt; -&lt;span&gt;ENOENT:
       &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -&lt;span&gt;ESHUTDOWN:
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; -EPIPE:  should clear the halt &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;default&lt;/span&gt;:          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; error &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
              &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; resubmit;
       }

       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++)                           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传crtl、shift、atl、windows 等按键&lt;/span&gt;&lt;span&gt;
              input_report_key(kbd&lt;/span&gt;-&amp;gt;dev, usb_kbd_keycode[i + &lt;span&gt;224&lt;/span&gt;], (kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;] &amp;gt;&amp;gt; i) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++) {                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传普通按键&lt;/span&gt;
              &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;通过上个状态的按键数据kbd-&amp;gt;old[i]的非0值,来查找当前状态的按键数据,若没有找到,说明已经松开了该按键 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (kbd-&amp;gt;old[i] &amp;gt; &lt;span&gt;3&lt;/span&gt; &amp;amp;&amp;amp; memscan(kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;, kbd-&amp;gt;old[i], &lt;span&gt;6&lt;/span&gt;) == kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt; + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (usb_kbd_keycode[kbd-&amp;gt;old[i]])              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次判断键盘描述码表的值是否非0&lt;/span&gt;&lt;span&gt;
                input_report_key(kbd&lt;/span&gt;-&amp;gt;dev, usb_kbd_keycode[kbd-&amp;gt;old[i]], &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传松开事件&lt;/span&gt;
               &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown key (scancode %#x) released.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, kbd-&amp;gt;&lt;span&gt;old[i]);
              }

　　　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;通过当前状态的按键数据kbd-&amp;gt;new[i]的非0值,来查找上个状态的按键数据,若没有找到,说明已经按下了该按键 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;[i] &amp;gt; &lt;span&gt;3&lt;/span&gt; &amp;amp;&amp;amp; memscan(kbd-&amp;gt;old + &lt;span&gt;2&lt;/span&gt;, kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;[i], &lt;span&gt;6&lt;/span&gt;) == kbd-&amp;gt;old + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;) {
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (usb_kbd_keycode[kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;[i]]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次判断键盘描述码表的值是否非0&lt;/span&gt;&lt;span&gt;
                input_report_key(kbd&lt;/span&gt;-&amp;gt;dev, usb_kbd_keycode[kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;[i]], &lt;span&gt;1&lt;/span&gt;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传按下事件&lt;/span&gt;
             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown key (scancode %#x) pressed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;[i]);
              }
       }

       input_sync(kbd&lt;/span&gt;-&amp;gt;&lt;span&gt;dev); 
       memcpy(kbd&lt;/span&gt;-&amp;gt;old, kbd-&amp;gt;&lt;span&gt;new&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新上个状态值&lt;/span&gt;&lt;span&gt; 
resubmit:
       i &lt;/span&gt;=&lt;span&gt; usb_submit_urb (urb, GFP_ATOMIC);
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i)
         err (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;can't resubmit intr, %s-%s/input0, status %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         kbd&lt;/span&gt;-&amp;gt;usbdev-&amp;gt;bus-&amp;gt;&lt;span&gt;bus_name,
         kbd&lt;/span&gt;-&amp;gt;usbdev-&amp;gt;&lt;span&gt;devpath, i);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1上面获取普通按键时,为什么不直接判断非0,要判断按键数据&amp;gt; 3?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前我们就分析了,当按键数据=0X01、0X02时,代表的是特定功能的键(crtl、shift),是属于buf[0]的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中memscan()是用来匹配上次按键和当前按键的数据,它这么做的原因是怕上个buf[]和当前buf[]的数据错位,这里就不做详细分析了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一切迎刃而解,我们只需要将自己的代码也通过这个码表添加所有按键按键事件,然后再在键盘中断函数中根据数据来上传事件即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.本节键盘代码如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;337&quot;&gt;
&lt;pre&gt;
#include &amp;lt;linux/kernel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/slab.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/module.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/init.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/usb/input.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/hid.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; input_dev *myusb_kbd_dev;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;input_dev&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *myusb_kbd_buf;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟地址缓存区&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; dma_addr_t myusb_kbd_phyc;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DMA缓存区;&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; __le16 myusb_kbd_size;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据包长度&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; urb  *myusb_kbd_urb;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;urb&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; usb_kbd_keycode[&lt;span&gt;252&lt;/span&gt;] =&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;48&lt;/span&gt;, &lt;span&gt;46&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;33&lt;/span&gt;, &lt;span&gt;34&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;, &lt;span&gt;23&lt;/span&gt;, &lt;span&gt;36&lt;/span&gt;, &lt;span&gt;37&lt;/span&gt;, &lt;span&gt;38&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;50&lt;/span&gt;, &lt;span&gt;49&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;31&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;, &lt;span&gt;47&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;, &lt;span&gt;44&lt;/span&gt;,  &lt;span&gt;2&lt;/span&gt;,  &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,  &lt;span&gt;5&lt;/span&gt;,  &lt;span&gt;6&lt;/span&gt;,  &lt;span&gt;7&lt;/span&gt;,  &lt;span&gt;8&lt;/span&gt;,  &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;,  &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;57&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;26&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;27&lt;/span&gt;, &lt;span&gt;43&lt;/span&gt;, &lt;span&gt;43&lt;/span&gt;, &lt;span&gt;39&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;41&lt;/span&gt;, &lt;span&gt;51&lt;/span&gt;, &lt;span&gt;52&lt;/span&gt;, &lt;span&gt;53&lt;/span&gt;, &lt;span&gt;58&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;61&lt;/span&gt;, &lt;span&gt;62&lt;/span&gt;, &lt;span&gt;63&lt;/span&gt;, &lt;span&gt;64&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;65&lt;/span&gt;, &lt;span&gt;66&lt;/span&gt;, &lt;span&gt;67&lt;/span&gt;, &lt;span&gt;68&lt;/span&gt;, &lt;span&gt;87&lt;/span&gt;, &lt;span&gt;88&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;, &lt;span&gt;70&lt;/span&gt;,&lt;span&gt;119&lt;/span&gt;,&lt;span&gt;110&lt;/span&gt;,&lt;span&gt;102&lt;/span&gt;,&lt;span&gt;104&lt;/span&gt;,&lt;span&gt;111&lt;/span&gt;,&lt;span&gt;107&lt;/span&gt;,&lt;span&gt;109&lt;/span&gt;,&lt;span&gt;106&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;105&lt;/span&gt;,&lt;span&gt;108&lt;/span&gt;,&lt;span&gt;103&lt;/span&gt;, &lt;span&gt;69&lt;/span&gt;, &lt;span&gt;98&lt;/span&gt;, &lt;span&gt;55&lt;/span&gt;, &lt;span&gt;74&lt;/span&gt;, &lt;span&gt;78&lt;/span&gt;, &lt;span&gt;96&lt;/span&gt;, &lt;span&gt;79&lt;/span&gt;, &lt;span&gt;80&lt;/span&gt;, &lt;span&gt;81&lt;/span&gt;, &lt;span&gt;75&lt;/span&gt;, &lt;span&gt;76&lt;/span&gt;, &lt;span&gt;77&lt;/span&gt;, &lt;span&gt;71&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;72&lt;/span&gt;, &lt;span&gt;73&lt;/span&gt;, &lt;span&gt;82&lt;/span&gt;, &lt;span&gt;83&lt;/span&gt;, &lt;span&gt;86&lt;/span&gt;,&lt;span&gt;127&lt;/span&gt;,&lt;span&gt;116&lt;/span&gt;,&lt;span&gt;117&lt;/span&gt;,&lt;span&gt;183&lt;/span&gt;,&lt;span&gt;184&lt;/span&gt;,&lt;span&gt;185&lt;/span&gt;,&lt;span&gt;186&lt;/span&gt;,&lt;span&gt;187&lt;/span&gt;,&lt;span&gt;188&lt;/span&gt;,&lt;span&gt;189&lt;/span&gt;,&lt;span&gt;190&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;191&lt;/span&gt;,&lt;span&gt;192&lt;/span&gt;,&lt;span&gt;193&lt;/span&gt;,&lt;span&gt;194&lt;/span&gt;,&lt;span&gt;134&lt;/span&gt;,&lt;span&gt;138&lt;/span&gt;,&lt;span&gt;130&lt;/span&gt;,&lt;span&gt;132&lt;/span&gt;,&lt;span&gt;128&lt;/span&gt;,&lt;span&gt;129&lt;/span&gt;,&lt;span&gt;131&lt;/span&gt;,&lt;span&gt;137&lt;/span&gt;,&lt;span&gt;133&lt;/span&gt;,&lt;span&gt;135&lt;/span&gt;,&lt;span&gt;136&lt;/span&gt;,&lt;span&gt;113&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;115&lt;/span&gt;,&lt;span&gt;114&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;121&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;89&lt;/span&gt;, &lt;span&gt;93&lt;/span&gt;,&lt;span&gt;124&lt;/span&gt;, &lt;span&gt;92&lt;/span&gt;, &lt;span&gt;94&lt;/span&gt;, &lt;span&gt;95&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;122&lt;/span&gt;,&lt;span&gt;123&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;, &lt;span&gt;91&lt;/span&gt;, &lt;span&gt;85&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;,  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;29&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;, &lt;span&gt;56&lt;/span&gt;,&lt;span&gt;125&lt;/span&gt;, &lt;span&gt;97&lt;/span&gt;, &lt;span&gt;54&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;126&lt;/span&gt;,&lt;span&gt;164&lt;/span&gt;,&lt;span&gt;166&lt;/span&gt;,&lt;span&gt;165&lt;/span&gt;,&lt;span&gt;163&lt;/span&gt;,&lt;span&gt;161&lt;/span&gt;,&lt;span&gt;115&lt;/span&gt;,&lt;span&gt;114&lt;/span&gt;,&lt;span&gt;113&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;150&lt;/span&gt;,&lt;span&gt;158&lt;/span&gt;,&lt;span&gt;159&lt;/span&gt;,&lt;span&gt;128&lt;/span&gt;,&lt;span&gt;136&lt;/span&gt;,&lt;span&gt;177&lt;/span&gt;,&lt;span&gt;178&lt;/span&gt;,&lt;span&gt;176&lt;/span&gt;,&lt;span&gt;142&lt;/span&gt;,&lt;span&gt;152&lt;/span&gt;,&lt;span&gt;173&lt;/span&gt;,&lt;span&gt;140&lt;/span&gt;&lt;span&gt;
};       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;键盘码表共有252个数据&lt;/span&gt;

 
&lt;span&gt;void&lt;/span&gt; my_memcpy(unsigned &lt;span&gt;char&lt;/span&gt; *dest,unsigned &lt;span&gt;char&lt;/span&gt; *src,&lt;span&gt;int&lt;/span&gt; len)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制缓存&lt;/span&gt;&lt;span&gt;
{
       &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(len--&lt;span&gt;)
        {
            &lt;/span&gt;*dest++= *src++&lt;span&gt;;
        }
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; myusb_kbd_irq(&lt;span&gt;struct&lt;/span&gt; urb *urb)               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;键盘中断函数&lt;/span&gt;&lt;span&gt;
{
   &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; buf1[&lt;span&gt;8&lt;/span&gt;]={&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;上传crtl、shift、atl、windows 等按键&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
     &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(((myusb_kbd_buf[&lt;span&gt;0&lt;/span&gt;]&amp;gt;&amp;gt;i)&amp;amp;&lt;span&gt;1&lt;/span&gt;)!=((buf1[&lt;span&gt;0&lt;/span&gt;]&amp;gt;&amp;gt;i)&amp;amp;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
     {    
             input_report_key(myusb_kbd_dev, usb_kbd_keycode[i &lt;/span&gt;+ &lt;span&gt;224&lt;/span&gt;], (myusb_kbd_buf[&lt;span&gt;0&lt;/span&gt;]&amp;gt;&amp;gt; i) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
             input_sync(myusb_kbd_dev);             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传同步事件&lt;/span&gt;&lt;span&gt;
      }


     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;上传普通按键&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;&lt;span&gt;8&lt;/span&gt;;i++&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(myusb_kbd_buf[i]!=&lt;span&gt;buf1[i])
    {
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(myusb_kbd_buf[i] )      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下事件&lt;/span&gt;&lt;span&gt;
    input_report_key(myusb_kbd_dev,usb_kbd_keycode[myusb_kbd_buf[i]], &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);   
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt;(buf1[i])                                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;松开事件&lt;/span&gt;
&lt;span&gt;    input_report_key(myusb_kbd_dev,usb_kbd_keycode[buf1[i]], &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    input_sync(myusb_kbd_dev);             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传同步事件&lt;/span&gt;
&lt;span&gt;    }

  my_memcpy(buf1, myusb_kbd_buf, &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新数据&lt;/span&gt;&lt;span&gt;    
  usb_submit_urb(myusb_kbd_urb, GFP_KERNEL);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myusb_kbd_probe(&lt;span&gt;struct&lt;/span&gt; usb_interface *intf, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; usb_device_id *&lt;span&gt;id)
{
       &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;  i;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; usb_device *dev = interface_to_usbdev(intf);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; usb_endpoint_descriptor *&lt;span&gt;endpoint;                            
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; usb_host_interface *&lt;span&gt;interface&lt;/span&gt;;                                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前接口&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt; pipe;                                                                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端点管道&lt;/span&gt;
       &lt;span&gt;interface&lt;/span&gt;=intf-&amp;gt;&lt;span&gt;cur_altsetting;                                                                   
       endpoint &lt;/span&gt;= &amp;amp;&lt;span&gt;interface&lt;/span&gt;-&amp;gt;endpoint[&lt;span&gt;0&lt;/span&gt;].desc;                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前接口下的端点描述符&lt;/span&gt;&lt;span&gt;
       printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VID=%x,PID=%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,dev-&amp;gt;descriptor.idVendor,dev-&amp;gt;&lt;span&gt;descriptor.idProduct);   

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   1)分配一个input_dev结构体  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       myusb_kbd_dev&lt;/span&gt;=&lt;span&gt;input_allocate_device();

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   2)设置input_dev支持 按键事件&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       set_bit(EV_KEY, myusb_kbd_dev&lt;/span&gt;-&amp;gt;&lt;span&gt;evbit);
       set_bit(EV_REP, myusb_kbd_dev&lt;/span&gt;-&amp;gt;evbit);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持重复按功能&lt;/span&gt;

       &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;252&lt;/span&gt;; i++&lt;span&gt;)
       set_bit(usb_kbd_keycode[i], myusb_kbd_dev&lt;/span&gt;-&amp;gt;keybit);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加所有键&lt;/span&gt;&lt;span&gt;
       clear_bit(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, myusb_kbd_dev-&amp;gt;&lt;span&gt;keybit);

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   3)注册input_dev结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       input_register_device(myusb_kbd_dev);

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;   4)设置USB键盘数据传输 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.1)通过usb_rcvintpipe()创建一个端点管道&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       pipe&lt;/span&gt;=usb_rcvintpipe(dev,endpoint-&amp;gt;&lt;span&gt;bEndpointAddress); 

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.2)通过usb_buffer_alloc()申请USB缓冲区&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      myusb_kbd_size&lt;/span&gt;=endpoint-&amp;gt;&lt;span&gt;wMaxPacketSize;
      myusb_kbd_buf&lt;/span&gt;=usb_buffer_alloc(dev,myusb_kbd_size,GFP_ATOMIC,&amp;amp;&lt;span&gt;myusb_kbd_phyc);

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.3)通过usb_alloc_urb()和usb_fill_int_urb()申请并初始化urb结构体 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       myusb_kbd_urb&lt;/span&gt;=usb_alloc_urb(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,GFP_KERNEL);
       usb_fill_int_urb (myusb_kbd_urb,              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;urb结构体&lt;/span&gt;&lt;span&gt;
                                 dev,                                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;usb设备&lt;/span&gt;&lt;span&gt;
                                 pipe,                                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端点管道&lt;/span&gt;&lt;span&gt;
                                 myusb_kbd_buf,               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存区地址&lt;/span&gt;&lt;span&gt;
                                 myusb_kbd_size,              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据长度&lt;/span&gt;&lt;span&gt;
                                 myusb_kbd_irq,               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断函数&lt;/span&gt;
                                 &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                                 endpoint&lt;/span&gt;-&amp;gt;bInterval);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断间隔时间&lt;/span&gt;
 
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.4) 因为我们2440支持DMA,所以要告诉urb结构体,使用DMA缓冲区地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        myusb_kbd_urb&lt;/span&gt;-&amp;gt;transfer_dma   =myusb_kbd_phyc;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置DMA地址&lt;/span&gt;&lt;span&gt;
        myusb_kbd_urb&lt;/span&gt;-&amp;gt;transfer_flags   =URB_NO_TRANSFER_DMA_MAP;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置使用DMA地址&lt;/span&gt;

  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-&amp;gt;4.5)使用usb_submit_urb()提交urb&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        usb_submit_urb(myusb_kbd_urb, GFP_KERNEL);   
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; myusb_kbd_disconnect(&lt;span&gt;struct&lt;/span&gt; usb_interface *&lt;span&gt;intf)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; usb_device *dev = interface_to_usbdev(intf);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备&lt;/span&gt;&lt;span&gt;
    usb_kill_urb(myusb_kbd_urb);
    usb_free_urb(myusb_kbd_urb);
    usb_buffer_free(dev, myusb_kbd_size, myusb_kbd_buf,myusb_kbd_phyc);
    input_unregister_device(myusb_kbd_dev);               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注销内核中的input_dev&lt;/span&gt;&lt;span&gt;
    input_free_device(myusb_kbd_dev);                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放input_dev&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; usb_device_id myusb_kbd_id_table [] =&lt;span&gt; {
       { USB_INTERFACE_INFO(
              USB_INTERFACE_CLASS_HID,                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口类:hid类&lt;/span&gt;&lt;span&gt;
              USB_INTERFACE_SUBCLASS_BOOT,             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类:启动设备类&lt;/span&gt;&lt;span&gt;
              USB_INTERFACE_PROTOCOL_KEYBOARD) }, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;USB协议:键盘协议&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; usb_driver myusb_kbd_drv =&lt;span&gt; {
       .name            &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myusb_kbd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
       .probe           &lt;/span&gt;=&lt;span&gt; myusb_kbd_probe,                        
       .disconnect     &lt;/span&gt;=&lt;span&gt; myusb_kbd_disconnect,
       .id_table  &lt;/span&gt;=&lt;span&gt; myusb_kbd_id_table,
};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;入口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myusb_kbd_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{ 
       usb_register(&lt;/span&gt;&amp;amp;&lt;span&gt;myusb_kbd_drv);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;出口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; myusb_kbd_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
       usb_deregister(&lt;/span&gt;&amp;amp;&lt;span&gt;myusb_kbd_drv);
}

module_init(myusb_kbd_init);
module_exit(myusb_kbd_exit);
MODULE_LICENSE(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;strong&gt;测试运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1 &lt;/strong&gt;&lt;strong&gt;重新设置编译内核&lt;/strong&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;strong&gt;去掉默认的&lt;/strong&gt;&lt;strong&gt;hid_USB&lt;/strong&gt;&lt;strong&gt;驱动&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;make menuconfig ,进入menu菜单重新设置内核参数:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;进入-&amp;gt; Device Drivers -&amp;gt; HID Devices &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&amp;lt;&amp;gt; USB Human Interface Device (full HID) support　　　　 //hid:人机交互的USB驱动,比如鼠标,键盘等&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;然后make uImage 编译内核&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;将新的键盘驱动模块放入nfs文件系统目录中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2&lt;/strong&gt;&lt;strong&gt;然后烧写内核&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;装载触摸屏驱动模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;如下图,当我们插上USB鼠标时,可以看到该VID和PID,和电脑上的键盘的参数一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010143216230-364861668.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;91&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3&lt;/strong&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;cat  tty1&lt;/strong&gt;&lt;strong&gt;进程测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010143228074-344309620.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.4 &lt;/strong&gt;&lt;strong&gt;使用&lt;/strong&gt;exec 0&amp;lt;/dev/tty1&lt;strong&gt;测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(exec命令详解入口地址: &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7553228.html&quot;&gt;http://www.cnblogs.com/lifexy/p/7553228.html&lt;/a&gt;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图,就能通过板子上的键盘来操作了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171010143241980-1521587749.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img id=&quot;uploading_image_14018&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;



&lt;/td&gt;
</description>
<pubDate>Tue, 10 Oct 2017 06:41:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/7645527.html</dc:identifier>
</item>
<item>
<title>JavaScript继承与聚合 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7644809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7644809.html</guid>
<description>&lt;p&gt;&lt;span&gt;一，继承&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种方式：类与被继承类直接耦合度高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，首先，准备一个可以被继承的类（父类），例如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个人员类&lt;/span&gt;
    function Person(name) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在Person里面的域是由Person里面的&lt;/span&gt;
&lt;span&gt;  来this来控制的
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2，然后，有个需要继承父类的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 function Teacher(name,books) {&lt;span&gt;
           Person.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于java中的super函数 在new Teacher时将Person的name初始化&lt;/span&gt;
           &lt;span&gt;this&lt;/span&gt;.books=&lt;span&gt;books;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 说明一下:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)call方法可以将一个函数的对象上下文从初始化变成由this来决定                     一个类去控制另一个类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)Teacher类去控制 Person类 用Teacher域里面的 this来控制Person域里面的 this&lt;br/&gt;(3)调用 Perosn的构造函数，因为Perosn没有用 new 所以是个空对象（模板）     显示调用call方法，可以初始化 Person&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3，最后，实现继承&lt;/p&gt;
&lt;p&gt;（步骤1）先继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 Teacher.prototype=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
    Teacher.prototype.constructor&lt;/span&gt;=Teacher;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保继承后任然是Teacher自己的构造函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （步骤2）为子类扩展一些方法，用于访问从父类继承的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Teacher.prototype.getBook=&lt;span&gt;function () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name+&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.books;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（步骤3）使用已经继承好的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; jim=&lt;span&gt;new&lt;/span&gt; Teacher(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jim&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    alert(jim.getBook())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：此种方法是直接在子类中显示调用父类，耦合度高，复用性差。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二种方式，使用封装，完成程序中所用继承操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，首先，准备一个可以被继承的类（父类），例如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个人员类&lt;/span&gt;
    function Person(name) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在Person里面的域由Person里面的来this来控制的&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2,创建extend函数为了程序中所有的继承操作（最重要的地方）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;创建extend函数为了程序中所有的继承操作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;subClass:子类  superClass：超类（2）&lt;/span&gt;
&lt;span&gt;    function extend(subClass,superClass) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1，使子类原型属性等于父类的原型属性

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个中间空对象，目的是为了转换主父关系&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; F =&lt;span&gt; function () {};
        F.prototype &lt;/span&gt;=&lt;span&gt; superClass.prototype;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2， 让子类继承F&lt;/span&gt;
        subClass.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
        subClass.prototype.constructor &lt;/span&gt;=&lt;span&gt; subClass;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3，为子类增加属性 superClass ==》原型链的引用&lt;/span&gt;
        subClass.superClass =&lt;span&gt; superClass.prototype;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4，增加一个保险，就算你的原型类是超类（Object）那么也要把你的构造函数级别降下来&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (superClass.prototype.constructor ==&lt;span&gt; Object.prototype.constructor) {
            superClass.prototype.constructor &lt;/span&gt;=&lt;span&gt; superClass;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，有一个需要继承其他类的子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; function Author(name,books) {
            Author.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,name);//没有直接写父类，降低了耦合度
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person.call(this,name)   直接写Person代表其构造函数&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.books=&lt;span&gt;books;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getBooks=&lt;span&gt;function () {
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name+&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.books ;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4，最后，实现继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承&lt;/span&gt;
        extend(Author,Person);//（子类，父类）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5，使用已经继承好的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; peter=&lt;span&gt;new&lt;/span&gt; Author(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Peter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        alert(peter.getBooks());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式二图解为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171010113505418-480468601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里可能会有一个疑问就是为啥要使用中间类？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里假如没有中间类的话，我们在实例化子类时就需要为父类传递一些相应的参数，这样的话，该句代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 Author.superClass.constructor.call(&lt;span&gt;this&lt;/span&gt;,name);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就不能放在子类（Author）中，而是需要放入到extend中，这样的话代码的通用性就很低，故此需要使用中间类。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二，聚合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用聚合的原因，&lt;/span&gt;有&lt;span&gt;的时候不需要严格的继承，我们真正需要的是一个类（或几个类）中的一些函数。故此我们可以使用聚合 也就是使用 &lt;/span&gt;掺元类&lt;/p&gt;
&lt;p&gt; 对于聚合有两种情况&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是聚合到 &lt;/span&gt;&lt;span&gt;var a={}空类或者不是用function声明的类中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1，首先，需要一个合适的可以被聚合的类（给体），此时需要在&lt;span&gt;本类的内部&lt;/span&gt;进行扩展属性，方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; JSON={&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写到类的内部&lt;/span&gt;
&lt;span&gt;        toJsonString:function () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; output=&lt;span&gt;[];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this代表那个调用，就指向那个一个对象&lt;/span&gt;
                output.push(key+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[key]);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，制作一个聚合函数（最重要）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;聚合函数
     receivingClass：接受聚合内容的类
     givingClass：被聚合的目标类
    * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    function mixin(receivingClass,givingClass){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(methodName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; givingClass){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!receivingClass.__proto__[methodName]){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前原型中是否含有即将要被聚合的方法，若没有则聚合进来&lt;/span&gt;
                receivingClass.__proto__[methodName]=&lt;span&gt;givingClass[methodName];//直接获得类中的方法，因为方法是直接写在方法内部的。
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，接受聚合的类（受体）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; get={name:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,age:&lt;span&gt;20&lt;/span&gt;};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4，实现将JSON类的方法聚合到类get中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mixin(get,JSON);//(受体，给体)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5，使用get类中聚合的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 document.write(get.toJsonString().join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种是聚合用function声明的类中  var a=function(){}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，首先，需要一个合适的可以被聚合的类（给体），此时需要在&lt;span&gt;本类的原型对象&lt;/span&gt;上进行扩展属性，方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; JSON=&lt;span&gt;{};
 JSON.prototype&lt;/span&gt;={&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写到类的原型对象上&lt;/span&gt;
&lt;span&gt; toJsonString:function () {
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; output=&lt;span&gt;[];
 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this代表那个调用，就指向那个一个对象&lt;/span&gt;
 output.push(key+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[key]);
 }
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
 }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2，制作一个聚合函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
（&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）制作聚合函数(receivingClass中聚合givingClass中的属性，或者方法)
 function mixin(receivingClass,givingClass) {
 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(methodName &lt;span&gt;in&lt;/span&gt;&lt;span&gt; givingClass.prototype){
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!receivingClass.prototype[methodName]){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前原型中是否含有即将要被聚合的方法，若没有则聚合进来&lt;/span&gt;
 receivingClass.prototype[methodName]=&lt;span&gt;givingClass.prototype[methodName];
 }
 }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，接受 聚合的类（受体）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; o=&lt;span&gt;function () {
 &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;聚合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt;19&lt;/span&gt;&lt;span&gt;;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4，实现JSON类到o类的聚合（将JSON类中的方法聚合到o类中）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mixin(o,JSON);//（受体，给体）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5,使用o类中聚合而来的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; useO=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; o();
 document.write(useO.toJsonString().join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种图解理解为：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171010143503512-1191235271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 该方式属于类o上一层的聚合。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 06:35:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7644809.html</dc:identifier>
</item>
<item>
<title>PowerBI开发 第七篇：数据集和数据刷新 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4516815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4516815.html</guid>
<description>&lt;p&gt;PowerBI报表是基于数据分析的引擎，数据真正的来源（Data Source）是数据库，文件等数据存储媒介，PowerBI支持的数据源类型多种多样。PowerBI Service（云端）有时不直接访问Data Source，而是直接从PowerBI Service创建的数据集（Dataset）中获取数据，数据集中存储的内容主要分为三部分：Data Source的数据（Data）、连接数据源的凭证（Credentials）、以及数据源的架构（Table Schema）等元数据（metadata）。PowerBI Service分析数据时，直接访问Dataset获取数据，执行聚合计算，以响应用户的查询请求。使用Dataset的好处是：PowerBI只需要维护统一的Data Store，不需要从众多不同的DataSource中读取数据，所需要的数据都能从单一的数据结构（Dataset）中读取。&lt;/p&gt;
&lt;p&gt;PowerBI Service为每个发布的Report自动创建一个Dataset，每一个Dataset的大小的上限是1GB。在导入（Import）连接模式下，PowerBI把多个Data Source的数据导入到Dataset中，也就是说，Dataset存储的是多个数据源（Data Source）的快照。是否把数据源导入到Dataset，是由数据连接（Data Connection Model）决定的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，数据连接模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当使用“&lt;strong&gt;Get Data&lt;/strong&gt;”连接到Data Source时，PowerBI 自动创建Dataset，把数据从多个Data Source加载到一个Dataset中，Dataset还包含连接Data Source的凭证（Credentials），以及数据的架构等元数据。PowerBI Service直接从Dataset中引用数据，而不是直接从Data Source中。PowerBI支持的连接模式有两种，分别是：Import，Live/DirectQuery。导入（Import）模式把Data Source的数据导入到PowerBI Service的Dataset中，而直接查询（DirectQuery）模式建立Data Source 和Dataset之间的直接连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/628084/201709/628084-20170923120536743-309529904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，&lt;/strong&gt;导入（Import）模式&lt;/p&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;对于导入（Import）模式，云端的Dataset中存储的数据来源于内网（On-Premises）数据的副本，一旦加载数据源，查询定义的所有数据都会被加载到Dataset中。PowerBI从高度优化的Dataset中查询数据，查询性能高，能够快速响应用户的交互式查询。由于导入模式是把数据源快照复制到Dataset中，因此，底层数据源的改动不会实时更新到Dataset，这使得Dataset存储的数据是过时的，用户需要手动刷新或设置调度刷新，否则，Dataset的数据不会更新。数据的刷新是全量更新，而非增量。&lt;/p&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;导入模式的限制是：Dataset的最大Size是1GB。&lt;/p&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;&lt;strong&gt;2，直接查询（DirectQuery）模式&lt;/strong&gt;&lt;/p&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;对于DirectQuery模式，PowerBI直接访问底层的数据源，因此数据始终是最新的。一旦加载数据，PowerBI Service不会向Dataset中加载任何数据（Data），这意味着，Dataset不存储任何数据（Data），但是，Dataset仍然会存储连接Data Source的凭证，以及数据源的元数据，用于访问底层数据源。在执行查询请求时，PowerBI Service直接把查询请求发送到原始的Data Source中去获取所需的数据。直接查询采用主动获取数据的方式，这意味着，底层数据的任何更新，不会立即反应到现有的报表展示中，用户需要刷新（Refresh）数据，但是，新的查询请求，都会使用最新的数据。&lt;/p&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;直接查询模式需要使用本地数据网管（On-Premises Data Gateway），PowerBI Service能够从云端向本地数据源（on-premises data sources）发送查询请求。当产生数据交互行为时，查询直接发送到数据库，Excel，Azure SQL DB/DW等，由于PowerBI和Data Source之间是直接连接，因此，不需要调度数据PowerBI Service的数据集（Dataset）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;&lt;strong&gt;Live/DirectQuery – This means there is a live connection between Power BI and the data source.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DirectQuery连接模式的好处是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;能够访问更大Size的Dataset：由于不需要把数据加载到Dataset中，DirectQuery模式能够从海量的数据源中加载数据；&lt;/li&gt;
&lt;li&gt;直接访问数据源：在DirectQuery模式下，PowerBI使用的是最新的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二，数据刷新（Data Refresh）&lt;/strong&gt;&lt;/p&gt;
&lt;p data-bi-id=&quot;31-id-P&quot; data-bi-name=&quot;4-31-layer-P&quot;&gt;PowerBI Service从Dataset中获取数据，用于数据分析和展示，用户可以通过&quot;SCHEDULE REFRESH&quot;和&quot;REFRESH NOW&quot;刷新Dataset的数据，把Dataset的数据更新到最新。用户刷新Dataset之前，必须配置内网数据网关（On-Premises Data Gateway），详细信息，请参考我的博文《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ljhdo/p/5125235.html&quot;&gt;PowerBI开发 第六章：数据网管&lt;/a&gt;》。PowerBI Service对数据Dataset的刷新是完整数据刷新，而不是增量数据刷新。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p data-bi-id=&quot;35-id-P&quot; data-bi-name=&quot;4-35-layer-P&quot;&gt;When you refresh data, you are updating the data in the dataset that is stored in Power BI from your data source. This refresh is a full refresh and not incremental.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用Import连接模式时，所有的数据都会从Data Source导入到PowerBI Service的缓存中，PowerBI的可视化控件都是从缓存中查询数据。一旦PowerBI文件发布到PowerBI Service中，PowerBI 将会创建一个Dataset，用于存储被导入的数据。设置调度，定时刷新Dataset，使得PowerBI呈现最新的分析数据，对于做出正确的决策是非常重要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三，连接模式的性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐使用导入（Import）连接模式&lt;/strong&gt;，这是因为PowerBI 使用内存的列式数据库 &lt;strong&gt;VertiPaq&lt;/strong&gt;，用于对已发布的数据集（Dataset）进行数据压缩和快速处理，能够使PowerBI报表执行脱机访问，面向列的处理，高度优化对1:N关系的处理性能。导入模式非常适合聚合查询，特别是，当存在大量的关系时，PowerBI能够快速执行聚合运算。导入模式的缺点是Dataset的Size最大是1GB，需要调度刷新才能访问最新的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接查询（DirectQuery）模式，建立PowerBI和Data Source之间的直接连接，访问的数据始终是最新的，并且数据源的大小是无限制的&lt;/strong&gt;。在直接查询模式下，PowerBI直接发送查询到Datasource中，以获取所需要的数据。当Data Source是关系型数据库时，PowerBI直接发送SQL查询语句到数据库中。直接查询模式的最大缺点是性能问题。&lt;/p&gt;
&lt;p&gt;在直接查询模式下，所有的直接查询请求都直接发送到源数据库中，后端数据源响应查询请求的速度决定了直接查询的性能。虽然PowerBI尽可能的优化生成的SQL命令，但是，通过监控发现，PowerBI最终生成的SQL命令是非常低效的，特别是在查询海量的数据源时，后端（Back-end）数据源需要执行很长时间，才能返回结果。等待的时间超过30s，用户体检就很不理想了。当导入模式不能满足业务需求时，再考虑直接查询模式。&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://powerbi.microsoft.com/en-us/documentation/powerbi-refresh-data/&quot; target=&quot;_blank&quot;&gt;Data refresh in Power BI&lt;/a&gt;&lt;/p&gt;
&lt;p data-bi-id=&quot;1-id-H1&quot; data-bi-name=&quot;4-1-layer-H1&quot;&gt;&lt;a href=&quot;https://powerbi.microsoft.com/en-us/documentation/powerbi-desktop-use-directquery/&quot; target=&quot;_blank&quot;&gt;Use DirectQuery in Power BI Desktop&lt;/a&gt;&lt;/p&gt;
&lt;p data-bi-id=&quot;1-id-H1&quot; data-bi-name=&quot;4-1-layer-H1&quot;&gt;&lt;a href=&quot;https://powerbi.microsoft.com/en-us/documentation/powerbi-desktop-directquery-about/&quot; target=&quot;_blank&quot;&gt;Power BI and DirectQuery&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 06:32:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4516815.html</dc:identifier>
</item>
<item>
<title>JavaScript 版数据结构与算法（一）栈 - lewis617</title>
<link>http://www.cnblogs.com/lewis617/p/7645394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lewis617/p/7645394.html</guid>
<description>&lt;p&gt;今天，我们要讲的是数据结构与算法中的栈。&lt;/p&gt;
&lt;h2 id=&quot;栈的简介&quot;&gt;栈的简介&lt;/h2&gt;
&lt;p&gt;栈是什么？栈是一个后进先出（LIFO）的数据结构。栈有啥作用？栈可以模拟算法或生活中的一些后进先出的场景，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;十进制转二进制，你需要将余数倒序输出。&lt;/li&gt;
&lt;li&gt;二叉树的先中后序非递归遍历都用到了栈。&lt;/li&gt;
&lt;li&gt;在生活中，栈可以模拟煤炉与蜂窝煤等场景。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/83900b4ely1fcqywbcbrjj20hz08dq2s&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用-javascript-写一个栈类&quot;&gt;用 JavaScript 写一个栈类&lt;/h2&gt;
&lt;p&gt;对于 JavaScript 工程师来说，没必要在开发中实现一个栈。因为 JavaScript 的内置对象 Array 已经实现了栈的相关方法。不过，好的程序员不能光用别人设计好的方法，而不理解为啥这么设计，所以我们还是自己设计一个栈玩玩吧！&lt;/p&gt;
&lt;p&gt;我们使用构造器函数来模拟类，不了解构造器函数的同学可以看&lt;a href=&quot;https://lewis617.github.io/2017/02/15/construcor-function-create-class/&quot;&gt;《在 JavaScript 中使用构造器函数模拟类》&lt;/a&gt;这篇博客。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Stack&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  ...
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Stack&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;私有变量&quot;&gt;私有变量&lt;/h3&gt;
&lt;p&gt;栈类的私有变量是个数组 &lt;code&gt;items&lt;/code&gt;，用于记录栈的元素。栈类实例化生成的对象不能直接操作 &lt;code&gt;items&lt;/code&gt;，因为 &lt;code&gt;items&lt;/code&gt; 在函数外面是不可见的，你只能通过一些类方法沿着作用域链来间接操作 &lt;code&gt;items&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Stack&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 私有变量 items，用于记录数组，对象不能直接操作&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; items &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;实现-push-pop和-tostring-方法&quot;&gt;实现 push 、pop和 toString 方法&lt;/h3&gt;
&lt;p&gt;实现 &lt;code&gt;push&lt;/code&gt; 、&lt;code&gt;pop&lt;/code&gt; 和 &lt;code&gt;toString&lt;/code&gt; 方法，跑通如下测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 实例化一个 stack 对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; stack &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Stack&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 期望 stack 转化成的字符串为'5,8'&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBe&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'5,8'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 期望 stack 删除并返回的是8&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pop&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBe&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 期望 stack 转化成的字符串为'5'&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBe&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'5'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6.2775800711744&quot;&gt;
&lt;p&gt;单元测试有时候就是可以作为需求文档来用的，在测试驱动开发（TDD），往往都是先写测试，再写代码。本教程用了 Jest 来进行单元测试，如果你不了解 Jest 和单元测试，可以先看&lt;a href=&quot;https://lewis617.github.io/2017/02/15/start-jest/&quot;&gt;《Jest 单元测试入门》&lt;/a&gt;这篇博客。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt; 、&lt;code&gt;pop&lt;/code&gt; 和 &lt;code&gt;toString&lt;/code&gt; 方法 与 Array 自带的 &lt;code&gt;push&lt;/code&gt; 、&lt;code&gt;pop&lt;/code&gt; 和 &lt;code&gt;toString&lt;/code&gt; 方法一样，所以实现代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Stack&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 私有变量 items，用于记录数组，对象不能直接操作&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; items &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;co&quot;&gt;// 类方法 push，在数组末尾添加项，对象可以直接调用&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (element) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;items&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(element)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  
  &lt;span class=&quot;co&quot;&gt;// 删除并返回数组末尾的项&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;items&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pop&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  
  &lt;span class=&quot;co&quot;&gt;// 将数组转为字符串并返回&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;items&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toString&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;实现-peek-isemptyclearsize-方法&quot;&gt;实现 peek 、isEmpty、clear、size 方法&lt;/h3&gt;
&lt;p&gt;实现 &lt;code&gt;peek&lt;/code&gt; 、&lt;code&gt;isEmpty&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;、&lt;code&gt;size&lt;/code&gt; 方法，跑通如下测试：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 实例化一个 stack 对象&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; stack &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Stack&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 期望 stack 最后一项是8&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;peek&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBe&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 期望 stack 的长度为2&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBe&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 期望 stack 不为空&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isEmpty&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBeFalsy&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clear&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 期望 stack 长度为0&lt;/span&gt;
&lt;span class=&quot;at&quot;&gt;expect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stack&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt;()).&lt;span class=&quot;at&quot;&gt;toBe&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述方法比较简单，直接上代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Stack&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 私有变量 items，用于记录数组，对象不能直接操作&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; items &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  
  &lt;span class=&quot;co&quot;&gt;// 查看数组最后一项&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;peek&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; items[&lt;span class=&quot;va&quot;&gt;items&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 判断数组是否为空&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isEmpty&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;items&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 清空数组&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clear&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    items &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 返回数组长度&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;items&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，栈的编写就完成了。&lt;/p&gt;
&lt;h2 id=&quot;教程示例代码及目录&quot;&gt;教程示例代码及目录&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;a href=&quot;https://github.com/lewis617/javascript-datastructures-algorithms&quot; class=&quot;uri&quot;&gt;https://github.com/lewis617/javascript-datastructures-algorithms&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目录：&lt;a href=&quot;http://www.liuyiqi.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/&quot; class=&quot;uri&quot;&gt;http://www.liuyiqi.cn/tags/数据结构与算法/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 06:22:00 +0000</pubDate>
<dc:creator>lewis617</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lewis617/p/7645394.html</dc:identifier>
</item>
<item>
<title>mvc的filter - 成天</title>
<link>http://www.cnblogs.com/chengtian/p/7645022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengtian/p/7645022.html</guid>
<description>&lt;p&gt;&lt;span&gt;如果想要记录ajax的请求和输出信息、内部发生异常记录日志、需要登录认证、需要权限判断；那mvc的各种filter可以帮助你实现你想要的。&lt;/span&gt;&lt;span&gt;Mvc框架支持5种不同类型的过滤器；我会按照执行顺序进行简单的demo,再简单的代码分享，万一对一个人有益，也是值的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449569/201710/449569-20171010124257230-683038392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.通过实现IAuthenticationFilter来进行登录认证，如果认证通过继续后续的权限授权等操作；如果认证没有通过跳转登录页面；代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcAuthenticationFilter : FilterAttribute, IAuthenticationFilter
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否需要认证 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsNeedAuthentication { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对请求进行身份验证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filterContext&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthentication(AuthenticationContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = filterContext.ActionDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), &lt;span&gt;true&lt;/span&gt;) || filterContext.ActionDescriptor.ControllerDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsNeedAuthentication)
            {
                IPrincipal user;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.IsAuthenticated(filterContext, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; user))
                {
                    filterContext.Principal &lt;/span&gt;=&lt;span&gt; user;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.UnauthenticatedRequest(filterContext);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsAuthenticated(AuthenticationContext filterContext, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; IPrincipal user)
        {
            user &lt;/span&gt;=&lt;span&gt; filterContext.HttpContext.User;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cc = filterContext.Controller.ControllerContext.Controller &lt;span&gt;as&lt;/span&gt;&lt;span&gt; BaseController;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cc != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; cc.CurrentAdminInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                IIdentity identity &lt;/span&gt;=&lt;span&gt; user.Identity;
                user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GenericPrincipal(identity, &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;noroot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里根据实际情况获取用户的角色&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UnauthenticatedRequest(AuthenticationContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; returnUrl =&lt;span&gt; filterContext.HttpContext.Request.Url.AbsolutePath;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; redirectUrl = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?ReturnUrl={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, returnUrl);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; loginUrl = FormsAuthentication.LoginUrl +&lt;span&gt; redirectUrl;
            filterContext.HttpContext.Response.Redirect(loginUrl, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthenticationChallenge(AuthenticationChallengeContext filterContext) { }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.每个管理后台都少不了权限判断的需求；你可以使用[Authorize(Roles = &quot;r1,r2&quot;)] 默认实现进行硬编码，对于用户的权限和角色经常变动的话，或者你需要灵活的处理就需要自定义Authorize，咱们先看下Authorize源代码实现你就会明白&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449569/201710/449569-20171010124418324-604784063.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;他的实现原理，先判断是否有匿名访问标签，然后利用AuthorizeCore 授权检查，如果未授权利用HandleUnauthorizedRequest 放回401，跳转到登录页面；很明显授权不通过跳转登录页面不是太合适；另一种实现方式 自定义Authorize 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] Roles { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; AuthorizeCore(HttpContextBase httpContext)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由原来指定的roles 替换成动态读取的。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跟登录用户的roles进行比较。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (httpContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;httpContext.User.Identity.IsAuthenticated)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Roles == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Roles.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Roles.Any(&lt;span&gt;new&lt;/span&gt; Func&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;(httpContext.User.IsInRole)))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            httpContext.Response.StatusCode &lt;/span&gt;= &lt;span&gt;403&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HandleUnauthorizedRequest(AuthorizationContext filterContext)
        {
            filterContext.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpUnauthorizedResult();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationContext filterContext)
        {

            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = filterContext.ActionDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), &lt;span&gt;true&lt;/span&gt;) || filterContext.ActionDescriptor.ControllerDescriptor.IsDefined(&lt;span&gt;typeof&lt;/span&gt;(AllowAnonymousAttribute), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; controllerName =&lt;span&gt; filterContext.ActionDescriptor.ControllerDescriptor.ControllerName;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; actionName =&lt;span&gt; filterContext.ActionDescriptor.ActionName;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; roles = &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, GetRoles(actionName, controllerName));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(roles))
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Roles = roles.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }, StringSplitOptions.RemoveEmptyEntries);
            }

            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnAuthorization(filterContext);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filterContext.HttpContext.Response.StatusCode == &lt;span&gt;403&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转未授权页面&lt;/span&gt;
                filterContext.Result = &lt;span&gt;new&lt;/span&gt; RedirectResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Other/Noright&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.动作过滤器记录一些ajax的输入输出数据，方便排查问题；代码有注释也比较简单直接贴代码了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.HttpContext.Request.IsAjaxRequest())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext =&lt;span&gt; filterContext.HttpContext;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入参数&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; req = &lt;span&gt;new&lt;/span&gt; JavaScriptSerializer().Serialize(HttpContext.Current.Request.Form.AllKeys.ToDictionary(k =&amp;gt; k, k =&amp;gt;&lt;span&gt; HttpContext.Current.Request.Form[k]));
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; code =&lt;span&gt; httpContext.Request.GetHashCode();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = filterContext.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = filterContext.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postUrl = controllerName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; actionName;
                LogHelper.WriteDebug(
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RequestUrl:{0};HashCode:{1}&amp;lt;/br&amp;gt;RequestParam{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                   postUrl, code,
                    req));
            }
        }

   
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuted(ActionExecutedContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.HttpContext.Request.IsAjaxRequest())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出参数&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; jsonR = filterContext.Result &lt;span&gt;as&lt;/span&gt;&lt;span&gt; JsonResult;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JavaScriptSerializer().Serialize(jsonR);
                LogHelper.WriteDebug(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OnActionExecuted---返回值:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res));
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.最后是发生异常的处理，mvc默认实现HandleErrorAttribute，但是也不够灵活，查看源代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449569/201710/449569-20171010124624777-1101636234.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt; 我们定义之后的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnException(ExceptionContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; errCode = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; errMsg = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义错误&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (filterContext.Exception &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ClException)
            {
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                errMsg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未知错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                LogHelper.WriteError(filterContext.Exception.Message);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是ajax请求&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filterContext.HttpContext.Request.IsAjaxRequest())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExceptionResponse
                {
                    ErrMsg &lt;/span&gt;=&lt;span&gt; errMsg,
                };
                filterContext.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonResult()
                {
                    Data &lt;/span&gt;=&lt;span&gt; result
                };
            }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;500服务器内部错误&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                filterContext.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ViewResult() { ViewName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Views/Other/Seerro.cshtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            }

            filterContext.ExceptionHandled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻止golbal里的错误执行&lt;/span&gt;
&lt;span&gt;            filterContext.HttpContext.Response.Clear();
            filterContext.HttpContext.Response.StatusCode &lt;/span&gt;= &lt;span&gt;500&lt;/span&gt;&lt;span&gt;;
            filterContext.HttpContext.Response.TrySkipIisCustomErrors &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁用 IIS 自定义错误&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 看下弹出的错误效果&lt;img src=&quot;http://images2017.cnblogs.com/blog/449569/201710/449569-20171010125811793-1550515311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 04:49:00 +0000</pubDate>
<dc:creator>成天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengtian/p/7645022.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（5）——开发前准备工作（了解编码前需要知道的一些常识） - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/7488816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/7488816.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　中午吃饭时间到了，小白赶紧向老菜坐的位置走过去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;小白：&lt;/strong&gt;&lt;/span&gt;老大，中午请你吃饭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;老菜：&lt;/span&gt;&lt;/strong&gt;哈哈...又遇到问题了吧，这次得狠狠宰你一顿才行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;小&lt;/strong&gt;白&lt;/span&gt;：&lt;/span&gt;行行行，只要您赏脸，米饭任吃，嘻嘻，我们边走边聊。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;小&lt;strong&gt;白&lt;/strong&gt;：&lt;/span&gt;&lt;/strong&gt;老大，我照您上次讲的办法都做完了，一步步执行，方向和条理清晰了很多，现在马上要进入编码了，所以想让您再指点一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;老菜：&lt;/span&gt;&lt;/strong&gt;嗯嗯，做的还不错嘛，孺子可教也。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编码相关的一些内容也是老生常谈的东西，它就好像起一座高楼大厦，如果没有设计图纸，没有将基础打好，那么可想而知建造出来的质量怎么样了。主要有下面几点要注意的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1.编码规范&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于这个，python做的挺不错的，有统一的规范PEP8指导，只要按要求去做就可以了，当然要重点注意的有两点，一是命名一定要按有意义的可读性强的英文单词来使命名；二是代码注释上，尽量表达清楚到位，尽量多点注释，不然一段时间后你重新维护旧系统时，你就知道痛苦了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;2.代码要适度封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　简单来说，你要将相同或类似功能的代码放到统一的文件当中，给其他需要调用相同功能的地方调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如说我们经常要用到MD5进行加密，不可能每次要用到时，都要导入hashlib包，然后创建实例对象，再根据当前加密对象是bytes还是字符串，然后做相应处理，这样重复代码就会很多。万一那个地方要进行修改时，就得修改所有使用MD5加密的代码，而如果处理过程中有所遗忘，就会产生问题了。所以我们将md5、base64编码与解码、aes加密与解密等内容统一放到encrypt_helper.py这个加密操作包中，那么我们要使用时就非常方便了。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; md5(text):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;md5加密函数&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    md5 &lt;/span&gt;=&lt;span&gt; hashlib.md5()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; isinstance(text, bytes):
        text &lt;/span&gt;= str(text).encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    md5.update(text)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; md5.hexdigest()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　为什么说适度封装呢？因为过度封装的话，会令代码的可读性下降，使代码变的难于理解，所以适度就好。当然对于你这种初学者来说，可能一开始很难理解，这不用担心，你就按你自己的经验正常实现功能需求就行了，等你完成这个项目后就会发现好多代码可以重用，需要封装重构了，到时再进行处理既容易理解，能力也会提升很快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3.程序文件分类摆放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果你的项目文件随便摆放，当程序文件越来越多时，就会非常混乱，要找某些功能函数时，就会很困难，所以在开发前要做好规划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如common文件夹放各种工具函数包；config放各种配置文件；api放各种接口文件等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4.面向对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　理解什么是面向对象，清楚面向对象的几大原则，并能应用到编码当中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;5.做好开发文档管理工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　开发时尽量编写与维护好各种开发文档，比如原型、数据字典、业务流程图、接口文档等，如果是团队合作项目，还要维护好甘特图、开发进度管理表和各种约束、分析、会议记要等文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然小项目不用那么复杂，不维护一般来说也没太大的问题，如果可能的话还是维护好接口文档会比较好，不然二次开发或与别人合作开发时，就呵呵了...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般接口文档都会用wiki来记录，网上有很多开源免费的wiki，安装使用都很方便，比如：&lt;a href=&quot;https://www.showdoc.cc/&quot; target=&quot;_blank&quot;&gt;ShowDoc&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;6.代码版本控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　虽然是小项目，最好也用用SVN或Git等版本控制比较好。没有版本控制的项目，有时写着写着，想回滚以前版本时，或代码出现问题要回滚时，我只能呵呵了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;7.开发时间的评估与控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　小项目在时间管理上也不要太大意了，有时一不留神就到了交付时间，如果还没开发出来就惨了，怎么评估和控制好项目开发时间也是很有讲究的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在开始一个项目时，一般都会对项目进行分解，细分到每个页面和接口，甚至更细的都有，然后分配这些开发任务到个人，有了这些详细的任务，要评估具体的开发周期就好办多了。在评估的时候，因为关乎到个人的开发时间控制，都会去思考每个页面与接口要处理的内容是什么，会遇到哪些技术难题，要怎么处理；又或者是这些页面或接口涉及的业务流程是什么，是否清晰，流转是否存在问题等等。这等于在开发前就已经在大脑里面将代码写过一便了，所以预估的时间大都八九不离十。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而项目控制又涉及到项目管理，这里就不再扩展了，如果一个个往细说就没完没了了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　唔唔，到吃饭的地方了，我看看哪家比较贵又吃不饱的，得好好挑一下才行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;strong&gt;小&lt;/strong&gt;白&lt;/span&gt;：&lt;span&gt;老大，大哥，注意口下留情啊！！！您知道小弟囊中羞涩，放过我的钱包吧！！！等收了项目款后再请你大吃一餐，不然剩下的日子我得天天吃泡面了，嗯，我看这家不错，我经常来，就去这家吧......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;老菜：&lt;/strong&gt;&lt;/span&gt;@.@&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：AllEmpty&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;出处：http://www.cnblogs.com/EmptyFS/&lt;br/&gt;有兴趣的朋友可以加加&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;python开发QQ群&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;：669058475，大家一起探讨。大家有问题的话可以在群里发问，当然我平时工作也非常繁忙不一定会及时回复。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文为&lt;/strong&gt;AllEmpty&lt;/span&gt;原创，欢迎转载，但未经同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;

</description>
<pubDate>Tue, 10 Oct 2017 04:07:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/7488816.html</dc:identifier>
</item>
<item>
<title>微前端 - 将微服务理念延伸到前端开发中 - 大转转FE</title>
<link>http://www.cnblogs.com/zhuanzhuanfe/p/7644846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuanzhuanfe/p/7644846.html</guid>
<description>&lt;p&gt;翻译自 &lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//micro-frontends.org/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;micro-frontends.org/&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文描述了采用不同 JavaScript 技术框架的多个团队中协同构建一个现代化前端 Web 应用所需要的技术、策略和方法。&lt;/p&gt;
&lt;h2&gt;什么是微前端？&lt;/h2&gt;
&lt;p&gt;微前端这个术语最初来自 2016 年的 ThoughtWorks 技术雷达[ &lt;em&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.thoughtworks.com/radar/techniques/micro-frontends&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;span class=&quot;visible&quot;&gt;thoughtworks.com/radar/&lt;span class=&quot;invisible&quot;&gt;techniques/micro-frontends&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/em&gt; ]，它将微服务的概念扩展到了前端领域。目前的趋势是构建一个功能丰富且强大的前端应用，即单页面应用(SPA)，其本身一般都是建立在一个微服务架构之上。前端层通常由一个单独的团队开发，随着时间的推移，会变得越来越庞大而难以维护。这就是传说中的前端巨无霸(Frontend Monolith) [ &lt;em&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpU1gXA0rfwc&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;span class=&quot;visible&quot;&gt;youtube.com/watch?&lt;span class=&quot;invisible&quot;&gt;v=pU1gXA0rfwc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/em&gt; ]。&lt;/p&gt;
&lt;p&gt;微前端背后的理念是将一个网站或者 Web App 当成特性的组合体，每个特性都由一个独立的团队负责。每个团队都有擅长的特定业务领域或是它关心的任务。这里，一个团队是跨职能的，它可以端到端，从数据库到用户界面完整的开发它所负责的功能。&lt;/p&gt;
&lt;p&gt;然而，这个概念并不新鲜，过去它叫针对垂直系统的前端一体化或独立系统。不过微前端显然是一个更加友好并且不那么笨重的术语。&lt;/p&gt;
&lt;p&gt;一体化的前端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010113915574-561859948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;垂直化组织方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010113931168-354016756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;什么是现代化前端应用&lt;/h2&gt;
&lt;p&gt;在介绍中我使用了措辞“构建一个现代化前端应用”，让我们先给出一些这个术语有关的设定。&lt;/p&gt;
&lt;p&gt;从一个更广泛的角度来看，Aral Balkan 曾写过一个相关的博客，他把这个概念叫做文档-应用连续统一体。他提出了一个滑动比例尺的概念，在比例尺的最左边是一个网站，由静态文档构成，通过链接相互连接；最右边是一个纯行为驱动的，几乎没内容的应用程序，比如在线图片编辑器。&lt;/p&gt;
&lt;p&gt;如果你把你的项目定位在这个范围的左侧，那在 Web 服务器级别的集成会比较合适。在这个模型中，服务器会收集页面中各个组件的内容并将其 HTML 字符串连接起来返回给用户。内容更新则采用从服务端重新加载的方式或者通过 ajax 进行部分替换。Gustaf Nilsson Kotte 针对这个主题写过一篇综合性的文章。&lt;/p&gt;
&lt;p&gt;当用户界面需要提供及时反馈时，即使采用不可靠连接，一个纯粹的服务端渲染网站也不够用。为了实现 Optimistic UI 或 Skeleton Screens 这样的技术你需要在设备本身对 UI 进行更新。Google 提出的 PWA 巧妙的描述了这种兼顾各方的做法（渐进增强），同时提供 App 一样的性能体验。这种类型的应用在上面的比例尺中位于文档-应用连续统一体中间的某个地方。在这里纯粹的服务端方案已经不再够用，我们必须将主要逻辑放到浏览器中，这正是本文会重点描述的。&lt;/p&gt;
&lt;h2&gt;微前端背后的核心理念&lt;/h2&gt;
&lt;p&gt;技术无关&lt;/p&gt;
&lt;p&gt;每一个团队在选择和升级他们的技术栈时应该能够做到不需要和其他团队进行对接。Custom Elements 是一个隐藏实现细节的非常好的方法，同时能够对外提供一个统一接口。&lt;/p&gt;
&lt;p&gt;隔离团队代码&lt;/p&gt;
&lt;p&gt;即使所有的团队都使用同样的框架，也不要共享一个运行时。构建独立的应用，不要依赖于共享状态或全局变量。&lt;/p&gt;
&lt;p&gt;建立各团队的前缀&lt;/p&gt;
&lt;p&gt;当隔离已经不可能时要商定一个命名规范。对 CSS、Events、Local Storage 和 Cookie 建立命名空间来避免碰撞并声明所有权。&lt;/p&gt;
&lt;p&gt;本地浏览器特性优先于自定义 API&lt;/p&gt;
&lt;p&gt;采用浏览器事件进行数据沟通而不是构建一个全局的发布者-订阅者系统。如果你确实需要构建一个跨团队的 API，那就确保它越简单越好。&lt;/p&gt;
&lt;p&gt;构建自适应网站&lt;/p&gt;
&lt;p&gt;即使 JavaScript 执行失败或是根本没有执行，你的特性也应该是能够使用的。采用通用渲染或渐进式增强来提高可感知的性能。&lt;/p&gt;

&lt;h2&gt;DOM 就是 API&lt;/h2&gt;
&lt;p&gt;自定义元素 Custom Elements 面向 Web 组件规范中互操作方面，在浏览器中是一个适用于功能集成的基本元素。每个团队采用自己选择的 Web 技术构建他们的组件，并将它们封装到一个 自定义元素 中(比如 &amp;lt;order-minicart&amp;gt;&amp;lt;/order-minicart&amp;gt; )。这个特定元素的 DOM 声明(标签名、属性和事件)对于其他团队来说体现为一个协定或者叫公共 API。这样做的好处是其他人可以使用这个组件及其功能而不需要知道实现细节，他们只需要能够和 DOM 交互即可。&lt;/p&gt;
&lt;p&gt;但仅仅自定义元素是不能满足解决方案的所有需求的。为了处理渐进增强、通用渲染或路由我们还需要软件的其他部分。&lt;/p&gt;
&lt;p&gt;本文分为两部分。首先我们会介绍页面组合(Page Composition) —— 如何使用不同团队提供的组件组合成一个页面。然后我们会给出一些示例展示客户端页面转化(Page Transition)的实现。&lt;/p&gt;
&lt;h2&gt;页面组合&lt;/h2&gt;
&lt;p&gt;除了采用不同框架编写的客户端或服务端代码集成，还有很多副主题需要讨论：隔离 js的机制、规避 CSS 冲突、按需加载资源、不同团队共享公共资源、处理数据获取和思考提供给用户的加载状态。我们将会依次讨论这些主题。&lt;/p&gt;
&lt;h2&gt;基本原型&lt;/h2&gt;
&lt;p&gt;如下的拖拉机模型商店的产品页面将会作为后续示例的基础。&lt;/p&gt;
&lt;p&gt;这个页面主要功能是通过一个变量选择器在三个不同拖拉机模型之间进行选择转换，变量改变时产品图片、名称、价格和推荐都会更新。还有一个购买按钮，点击后会将选中的模型添加到购物车中，同时顶部的迷你购物车也会相应更新。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010114001168-1980981562.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;RichText-gifPlaceholder&quot;&gt;
&lt;div class=&quot;GifPlayer&quot; data-reactroot=&quot;&quot; data-za-module=&quot;GifItem&quot;&gt;&lt;img class=&quot;column-gif&quot; src=&quot;https://pic4.zhimg.com/v2-a75c83b15cb5c646316fbd89f72b4927_b.jpg&quot; alt=&quot;&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-a75c83b15cb5c646316fbd89f72b4927_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;所有的 HTML 页面都通过纯 JavaScript和 ES6 模板字符串在客户端生成，没有任何依赖。代码使用一个简单的状态/标记分离方式，一旦有变化整个 HTML 页面都会重新渲染 —— 没有炫酷的 DOM 对比功能，也暂时没有通用渲染。当然也没有团队分离 —— 所有代码都在一个 js/css 文件中。&lt;/p&gt;
&lt;h2&gt;客户端集成&lt;/h2&gt;
&lt;p&gt;在如下示例中，这个页面被分隔成不同的组件和片段，分别被三个不同的团队负责。交易组(蓝色)负责所有跟付账流程有关的事情 —— 也就是购买按钮和迷你购物车。推荐组(绿色)负责页面中的产品推荐部分。页面本身则由产品组(红色)负责。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010114028168-886851210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;产品组决定哪个功能点被采用以及该功能在页面布局的位置。页面包含的信息可以由产品组自身提供，比如产品名称、图片和可采用的参数，但还可以包括其他团队提供的片段(自定义元素)。&lt;/p&gt;
&lt;h2&gt;如何创建一个自定义元素&lt;/h2&gt;
&lt;p&gt;让我们把购买按钮作为一个示例。产品组简单的将 &amp;lt;blue-buysku=&quot;t_porsche&quot;&amp;gt;&amp;lt;/blue-buy&amp;gt; 加入到页面中期望的位置就可以使用这个按钮了。要让这个按钮起作用，交易组还需要在页面中注册元素 blue-buy。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class BlueBuy extends HTMLElement {
  constructor() {
    super();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.innerHTML = ` &amp;lt; button type = &quot;button&quot; &amp;gt;&lt;span&gt; buy
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 66&lt;span&gt;,
    &lt;/span&gt;00€ &amp;lt; /button&amp;gt;`;
&lt;span&gt;}
   disconnectedCallback() { ... }
}
window.customElements.define(&lt;/span&gt;'blue-buy', BlueBuy); 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;现在每当浏览器遇到一个新的 blue-buy 标签时，都会调用这个构造器。其中， this 是这个自定义元素 DOM 根节点的引用。所有标准 DOM 元素的属性和方法都可以使用，比如 innerHTML 或 getAttribute()。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010114505715-256240627.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;RichText-gifPlaceholder&quot;&gt;
&lt;div class=&quot;GifPlayer&quot; data-reactroot=&quot;&quot; data-za-module=&quot;GifItem&quot;&gt;&lt;img class=&quot;column-gif&quot; src=&quot;https://pic3.zhimg.com/v2-29486a05e240a5ebc383b2ce8b4b104a_b.jpg&quot; alt=&quot;&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-29486a05e240a5ebc383b2ce8b4b104a_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;根据标准文档的定义，当命名自定义元素时唯一的需求是名称中必须包含一个破折号 - 以确保和未来新的 HTML 标签进行兼容。在后面的示例中则使用了 [team_color]-[feature] 命名规范。团队命名空间预防了碰撞，这种方法让一个功能点的权责变得更分明：只要看看 DOM 就知道了。&lt;/p&gt;
&lt;h2&gt;父子元素通信 / DOM 修改&lt;/h2&gt;
&lt;p&gt;当用户在变量选择器中选择了另外一个拖拉机时，购买按钮必须相应的进行更新。要达到这种效果，产品组只需要从 DOM 中移除相应元素，并插入一个新的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
container.innerHTML;
// =&amp;gt; &amp;lt;blue-buy sku=&quot;t_porsche&quot;&amp;gt;...&amp;lt;/blue-buy&amp;gt;
container.innerHTML = '&amp;lt;blue-buy sku=&quot;t_fendt&quot;&amp;gt;&amp;lt;/blue-buy&amp;gt;';
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;老元素的 disconnectedCallback 方法会被同步调用进行一些清理资源的操作比如移除事件监听器。然后新创建的 t_fendt 元素的 constructor 会被调用。&lt;/p&gt;
&lt;p&gt;另外一个性能更好的选择是仅仅更新现有元素的 sku 属性。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
document.querySelector('blue-buy').setAttribute('sku', 't_fendt');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果产品组使用了以 DOM 对比为特色的模板引擎，比如 React，那它的算法就会自动完成上述功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010114531262-108215348.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;RichText-gifPlaceholder&quot;&gt;
&lt;div class=&quot;GifPlayer&quot; data-reactroot=&quot;&quot; data-za-module=&quot;GifItem&quot;&gt;&lt;img class=&quot;column-gif&quot; src=&quot;https://pic3.zhimg.com/v2-829d87921199ed719c9149be56badd76_b.jpg&quot; alt=&quot;&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-829d87921199ed719c9149be56badd76_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;要支持这种效果，自定义元素可以实现 attributeChangedCallback 并指定一个 observedAttributes 列表来触发这个回调。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const prices = {
  t_porsche: '66,00 €',
  t_fendt: '54,00 €',
  t_eicher: '58,00 €',
};

class BlueBuy extends HTMLElement {
  static get observedAttributes() {
    return ['sku'];
  }
  constructor() {
    super();
    this.render();
  }
  render() {
    const sku = this.getAttribute('sku');
    const price = prices[sku];
    this.innerHTML = ` &amp;lt; button type = &quot;button&quot; &amp;gt; buy
    for $ {
      price
    } &amp;lt; /button&amp;gt;`;
}
   attributeChangedCallback(attr, oldValue, newValue) {
this.render();
}
   disconnectedCallback() {...}
}
window.customElements.define('blue-buy', BlueBuy);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;为避免重复，引入一个 render() 方法并在 constructor 和 attributeChangedCallback 中调用。这个方法收集需要的数据，并填充新标签的 innerHTML 属性。当决定在自定义元素中采用一个更加成熟的模板引擎或框架时，这里便是初始化代码所呆的地方。&lt;/p&gt;
&lt;h2&gt;浏览器支持&lt;/h2&gt;
&lt;p&gt;上例采用了 Custom Element 规范 V1 版，目前已经在 Chrome, Safari 和 Opera 中得到支持。但是通过 document-register-element 这个轻量级且经过大量测试的 polyfill 可以让该特性在所有浏览器中运行。在底层，它使用了广泛支持的 Mutation Observer API，所以并没有在背后使用 DOM 树监听这种侵入式的 hack 方法。&lt;/p&gt;
&lt;h2&gt;框架兼容性&lt;/h2&gt;
&lt;p&gt;因为自定义元素 Custom Element 是一个 Web 标准，所有的主流 JavaScript 框架都支持，比如 Angular、React、Preact、Vue 或 Hyperapp。但深入到细节时，就会发现有些框架依然存在实现上的问题。可以访问 Custom Elements Everywhere 这个兼容性测试套件，Rob Dodson 把没有解决的问题都高亮显示了。&lt;/p&gt;
&lt;h2&gt;子父元素或兄弟元素通信 / DOM 事件&lt;/h2&gt;
&lt;p&gt;然而，对于所有的交互来说从上至下传递属性是不够的。在我们的示例中，当用户对购买按钮执行一次点击事件时，迷你购物车应该刷新。&lt;/p&gt;
&lt;p&gt;上面这两个片段都由交易组(蓝色)维护的，所以为了达到迷你购物车和按钮通信的效果他们可以构建一种内建的 JavaScript API 进行通信。但这样就需要组件实例之间相互了解，同时也违背了隔离的原则。&lt;/p&gt;
&lt;p&gt;一种更加干净的方法是采用发布者订阅者机制：一个组件可以发布信息，其他组件则订阅指定的主题(topic)。幸运的是浏览器内建了这个特性，这也正是 click、 select、 mouseover 等浏览器事件的工作机制。除了这些本地事件，还有一种可能性是通过 newCustomEvent(...) 来创建更加高级别的事件。事件总是绑定到它们创建或者分配的 DOM 节点上，大部分本地事件也支持冒泡的特性，这让监听 DOM 中特定子树节点的所有事件成为可能。如果你想要监听页面上的所有事件，将事件监听器附加到 window 元素上就 OK 了。如下是本示例中 blue:basket:changed 事件创建的大概样子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
class BlueBuy extends HTMLElement { [...] connectedCallback() { [...] this.render();
    this.firstChild.addEventListener('click', this.addToCart);
  }
  addToCart() {
    // maybe talk to an api
    this.dispatchEvent(new CustomEvent('blue:basket:changed', {
      bubbles: true,
    }));
  }
  render() {
    this.innerHTML = ` &amp;lt; button type = &quot;button&quot; &amp;gt; buy &amp;lt; /button&amp;gt;`;
}
 disconnectedCallback() {
this.firstChild.removeEventListener('click', this.addToCart);
}
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;现在迷你购物车可以在 window 对象上订阅这个事件了，在需要刷新数据时它就会得到通知。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
class BlueBasket extends HTMLElement {
  connectedCallback() { [...] window.addEventListener('blue:basket:changed', this.refresh);
  }
  refresh() {
    // fetch new data and render it
  }
  disconnectedCallback() {
    window.removeEventListener('blue:basket:changed', this.refresh);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;采用这种方法实现时，迷你购物车片段增加了一个不在它范围之内(window)的 DOM 元素监听器。对于大部分应用来说，这个做法没有什么问题，但是如果你不太满意这种做法，还可以让页面自身(产品组)去监听这个事件，并通过调用 DOM 元素的 refresh() 方法来通知迷你购物车。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// page.js
const $ = document.getElementsByTagName;

$('blue-buy')[0].addEventListener('blue:basket:changed', function() {
 $('blue-basket')[0].refresh();
});
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;命令式调用 DOM 方法其实相当罕见，但比如在 video 元素 API 中就有这种做法。如果可能的话，还是应该推荐这种命令式的方法(属性更改)。&lt;/p&gt;
&lt;h2&gt;服务端渲染 / 通用渲染&lt;/h2&gt;
&lt;p&gt;在浏览器中采用自定义元素 Custom Elements 来集成组件是个绝好的做法。但实际在构建一个 Web 中可访问的站点时，很可能是初次加载性能才是关键点，在所有的 JS 框架全部加载并执行之前用户只会看到白屏。另外，还有一个值得思考的是如果 JavaScript 执行失败或者被阻塞时网站会发生什么。Jeremy Keith 在他的 ebook/播客 Resilient Web Design 中解释了这个问题的重要性。所以能够在服务端渲染核心内容才是关键。不幸的是 Web 组件规范根本没有讨论服务端渲染。JavaScript 没有，Custom Elements 也没有:(&lt;/p&gt;
&lt;h2&gt;自定义元素 + 服务端包含(Includes) = ❤️&lt;/h2&gt;
&lt;p&gt;为了引入服务端渲染，前面的示例进行了重构。每个团队都有他们自己的 express 服务器，自定义元素的 render() 方法也都通过 url 来进行访问。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
$ curl http://127.0.0.1:3000/blue-buy?sku=t_porsche
&amp;lt;button type=&quot;button&quot;&amp;gt;buy for 66,00 €&amp;lt;/button&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;自定义元素的标签名被用作路径名，属性名成为了查询参数。这样为每个组件用服务端渲染内容的方法就有了。再配合上 &amp;lt;blue-buy&amp;gt; 自定义元素，一种非常接近于通用 Web 组件的东西就出来了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;blue-buy sku=&quot;t_porsche&quot;&amp;gt;
&amp;lt;!--#include virtual=&quot;/blue-buy?sku=t_porsche&quot; --&amp;gt;
&amp;lt;/blue-buy&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;#include 注释是服务端包含 Server Side Includes 的一部分，这个功能在大部分 Web 服务器中都支持。没错，这个就是很早以前我们在网站中嵌入当前日期所采用的同样技术。也有几个其他可选技术比如 ESI、nodesi、compoxure 和 tailor，但是对于我们的项目 SSI 已经被证明是一个简单同时也相当稳定的解决方案。&lt;/p&gt;
&lt;p&gt;在 Web 服务器将完整的页面发送到浏览器之前 #include 注释被替换为 /blue-buy?sku=t_porsche 的返回值。在 Nginx 中配置如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
upstream team_blue {
  server team_blue: 3001;
}
upstream team_green {
  server team_green: 3002;
}
upstream team_red {
  server team_red: 3003;
}

server {
  listen 3000;
  ssi on;

  location / blue {
    proxy_pass http: //team_blue;
  }
  location / green {
    proxy_pass http: //team_green;
  }
  location / red {
    proxy_pass http: //team_red;
  }
  location / {
    proxy_pass http: //team_red;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;指令 ssi:on; 用来开启 SSI 功能， upstream 和 location 块用来确保每个团队的 url 都会被正确分配到对应的服务，比如以 /blue 开头的 url 会被路由到相应的应用服务( team_blue:3001)。另外， / 路由被映射到负责首页和产品页的产品组(红色)。&lt;/p&gt;
&lt;p&gt;下面的动画演示了在一个 JavaScript 被禁用的浏览器中拖拉机商店使用情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171010114559590-710348509.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;RichText-gifPlaceholder&quot;&gt;
&lt;div class=&quot;GifPlayer&quot; data-reactroot=&quot;&quot; data-za-module=&quot;GifItem&quot;&gt;&lt;img class=&quot;column-gif&quot; src=&quot;https://pic3.zhimg.com/v2-78a0d87e0383b00b3b5bf49f404e5dc2_b.jpg&quot; alt=&quot;&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-78a0d87e0383b00b3b5bf49f404e5dc2_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;变量选择按钮现在是一个真实的链接了，每一次点击都会让整个页面重新加载。右边的终端展示了一个请求如何被路由到产品组的流程，产品组则控制整个产品页，里面的标记则由推荐组和交易组的内容片段来提供。&lt;/p&gt;
&lt;p&gt;当打开启用 JavaScript 的开关后，在服务端日志消息中只有第一条请求才会显示。所有后续的拖拉机变化逻辑都在客户端处理了，就和前面第一个示例一样。在后面的示例中，产品数据将会从 JavaScript 代码中被抽离出来，并在需要的时候通过一个 REST API 进行加载。&lt;/p&gt;
&lt;p&gt;你可以在本机运行这个代码。只需要安装 Docker Compose[ &lt;em&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//docs.docker.com/compose/install/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;docs.docker.com/compose&lt;span class=&quot;invisible&quot;&gt;/install/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/em&gt; ]。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
git clone https://github.com/neuland/micro-frontends.git
cd micro-frontends/2-composition-universal
docker-compose up --build
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Docker 会在 3000 端口启动 Nginx，并为每个团队构建 node.js 镜像。当你在浏览器中打开 &lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=http%3A//127.0.0.1%3A3000/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;span class=&quot;visible&quot;&gt;127.0.0.1:3000/&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 时应该会看到一个红色的拖拉机。通过 docker-compose 给出的组合日志可以很轻松的看到网络中发生了什么。不好的是目前还不能控制输出信息的颜色，所以你不得不接受一个事实，那就是蓝色的交易组可能被高亮成绿色 :)&lt;/p&gt;
&lt;p&gt;src 中的文件会被映射到独立的容器中，当你进行代码更改后 node 应用会重启。修改 nginx.conf 需要重启 docker-compose 才能生效。然后你就尽情瞎搞并提供反馈吧。&lt;/p&gt;
&lt;h2&gt;数据获取 &amp;amp; 加载状态&lt;/h2&gt;
&lt;p&gt;待续...&lt;/p&gt;
&lt;p&gt;关注 Github Repo[ &lt;em&gt;&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/neuland/micro-frontends&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;github.com/neuland/micr&lt;span class=&quot;invisible&quot;&gt;o-frontends&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/em&gt; ] 来获取通知&lt;/p&gt;
&lt;h2&gt;参考资源&lt;/h2&gt;
</description>
<pubDate>Tue, 10 Oct 2017 03:48:00 +0000</pubDate>
<dc:creator>大转转FE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuanzhuanfe/p/7644846.html</dc:identifier>
</item>
<item>
<title>Java中的类型擦除与桥方法 - Beginner_YH</title>
<link>http://www.cnblogs.com/xz816111/p/7643323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xz816111/p/7643323.html</guid>
<description>&lt;h2 id=&quot;类型擦除&quot;&gt;类型擦除&lt;/h2&gt;
&lt;p&gt;Java在语法中虽然存在泛型的概念，但是在虚拟机中却没有泛型的概念，虚拟机中所有的类型都是普通类。无论何时定义一个泛型类型，编译后类型会被都被自动转换成一个相应的原始类型。&lt;/p&gt;
&lt;p&gt;比如这个类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Parent&amp;lt;T&amp;gt;
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(T value)
    {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is Parent Class, value is &quot;&lt;/span&gt; + value);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在编译后就变成了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Parent
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(Object value)
    {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is Parent Class, value is &quot;&lt;/span&gt; + value);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对类型变量进行替换的规则有两条：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若为无限定的类型，如&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;，被替换为&lt;code&gt;Object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若为限定类型，如&lt;code&gt;&amp;lt;T extends Comparable &amp;amp; Serializable&amp;gt;&lt;/code&gt;，则用第一个限定的类型变量来替换，在这里被替换为&lt;code&gt;Comparable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;桥方法&quot;&gt;桥方法&lt;/h2&gt;
&lt;p&gt;类型擦除后，就产生了一个奇怪的现象。&lt;/p&gt;
&lt;p&gt;假设有一个超类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Parent&amp;lt;T&amp;gt;
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(T value)
    {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is Parent Class, value is &quot;&lt;/span&gt; + value);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及一个子类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Child &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Parent&amp;lt;String&amp;gt;
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(String value)
    {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is Child class, value is &quot;&lt;/span&gt; + value);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后有以下测试代码，企图实现多态：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MainApp
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args)
    {
        Child child = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Child&lt;/span&gt;();
        Parent&amp;lt;String&amp;gt; parent = child;

        parent.&lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is a string&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行的时候，会对&lt;code&gt;Child&lt;/code&gt;类的方法表进行搜索，先分析一下&lt;code&gt;Child&lt;/code&gt;类的方法表里有哪些东西：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;. &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(Object value) : 从类型被擦除后的超类中继承过来
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;. &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(String value) : 自己新增的方法，和超类毫无联系
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;. 一些从Object类继承来的方法，这里忽略&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按理来说，这段测试代码应该不能通过编译，因为要实现多态的话，所调用的方法必须在子类中重写，但是在这里&lt;code&gt;Child&lt;/code&gt;类并没有重写&lt;code&gt;Parent&lt;/code&gt;类中的&lt;code&gt;sayHello(Object value)&lt;/code&gt;方法，只是单纯的继承而已，并且新加了一个参数不同的同名方法。&lt;/p&gt;
&lt;p&gt;但是结果是可以正常运行。&lt;/p&gt;
&lt;p&gt;原因是编译器在&lt;code&gt;Child&lt;/code&gt;类中自动生成了一个&lt;strong&gt;桥方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(Object value)
{
    &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;((String) value);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，这个桥方法实际上就是对超类中&lt;code&gt;sayHello(Obejct)&lt;/code&gt;的重写。这样做的原因是，当程序员在子类中写下以下这段代码的时候，本意是对超类中的同名方法进行重写，但因为超类发生了类型擦除，所以实际上并没有重写成功，因此加入了桥方法的机制来避免类型擦除与多态发生冲突。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Child &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Parent&amp;lt;String&amp;gt;
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sayHello&lt;/span&gt;(String value)
    {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This is Child class, value is &quot;&lt;/span&gt; + value);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;桥方法并不需要自己手动生成，一切都是编译器自动完成的。&lt;/p&gt;
&lt;h2 id=&quot;桥方法与geter&quot;&gt;桥方法与Geter&lt;/h2&gt;
&lt;p&gt;同样的，如果超类中有&lt;code&gt;getter&lt;/code&gt;的话，在使用多态的时候也可能发生冲突。假设有超类被类型擦除后存在这样一个方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Obejct &lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在子类中，程序员想要重写这个方法，因此新增了一个这样的方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;String &lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是正如前面所述，重写并没有起作用，甚至还应该报错，因为在子类中，根据 &lt;strong&gt;函数签名=方法名+参数&lt;/strong&gt; 的原则，从超类继承的方法与新增的方法冲突了。&lt;/p&gt;
&lt;p&gt;但实际上这样的代码是可以工作的，原因在于，JVM是用&lt;strong&gt;返回值+方法名+参数&lt;/strong&gt;的方式来计算函数签名的，所以编译器就可以借助这一原则来生成一个桥方法。不过这种计算函数签名的方法仅仅存在于虚拟机中。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Oct 2017 03:47:00 +0000</pubDate>
<dc:creator>Beginner_YH</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xz816111/p/7643323.html</dc:identifier>
</item>
</channel>
</rss>