<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用Identity Server 4建立Authorization Server (4) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7795121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7795121.html</guid>
<description>&lt;p&gt;预备知识: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7746496.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7746496.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7780559.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7780559.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7788636.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7788636.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/7793241.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/7793241.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇讲了使用OpenId Connect进行Authentication.&lt;/p&gt;
&lt;p&gt;下面讲&lt;/p&gt;

&lt;p&gt;目前我们解决方案里面有三个项目 Authorization Server, Web api和Mvc Client. 在现实世界中, 他们可能都在不同的地方.&lt;/p&gt;
&lt;p&gt;现在让我们从MvcClient使用从Authorization Server获取的token来访问web api. 并且确保这个token不过期.&lt;/p&gt;
&lt;p&gt;现在我们的mvcClient使用的是implicit flow, 也就是说, token 被发送到client. 这种情况下 token的生命可能很短, 但是我们可以重定向到authorization server 重新获取新的token.&lt;/p&gt;
&lt;p&gt;例如, 在SPA(Single Page Application)中, implicit flow基本上就是除了resource owner password flow 以外唯一合适的flow, 但是我们的网站可能会在client没使用网站的时候访问api, 为了这样做, 不但要保证token不过期, 我们还需要使用别的flow. 我们要介绍一下authorization code flow. 它和implicit flow 很像, 不同的是, 在重定向回到网站的时候获取的不是access token, 而是从authorization server获取了一个code, 使用它网站可以交换一个secret, 使用这个secret可以获取access token和refresh tokens.&lt;/p&gt;
&lt;p&gt;Hybrid Flow, 是两种的混合, 首先identity token通过浏览器传过来了, 然后客户端可以在进行任何工作之前对其验证, 如果验证成功, 客户端就会再打开一个通道向Authorization Server请求获取access token.&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MVC Code Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.&lt;span&gt;HybridAndClientCredentials&lt;/span&gt;,
                    &lt;span&gt;ClientSecrets &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=
                    {
                        new Secret(&quot;secret&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.Sha256())
                    },&lt;/span&gt;
                    RedirectUris &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5002/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    PostLogoutRedirectUris &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5002/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    AllowedScopes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        IdentityServerConstants.StandardScopes.&lt;span&gt;Email&lt;/span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socialnetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    &lt;span&gt;AllowOfflineAccess &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= true&lt;/span&gt;&lt;span&gt;&lt;span&gt;,&lt;/span&gt;
                    AllowAccessTokensViaBrowser &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先肯定要修改一下ClientId.&lt;/p&gt;
&lt;p&gt;GrantType要改成Hybrid或者HybrdAndClientCredentials, 如果只使用Code Flow的话不行, 因为我们的网站使用Authorization Server来进行Authentication, 我们想获取Access token以便被授权来访问api. 所以这里用HybridFlow.&lt;/p&gt;
&lt;p&gt;还需要添加一个新的Email scope, 因为我想改变api来允许我基于email来创建用户的数据, 因为authorization server 和 web api是分开的, 所以用户的数据库也是分开的. Api使用用户名(email)来查询数据库中的数据.&lt;/p&gt;
&lt;p&gt;AllowOfflineAccess. 我们还需要获取Refresh Token, 这就要求我们的网站必须可以&quot;离线&quot;工作, 这里离线是指用户和网站之间断开了, 并不是指网站离线了.&lt;/p&gt;
&lt;p&gt;这就是说网站可以使用token来和api进行交互, 而不需要用户登陆到网站上. &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();

            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
            services.AddAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            })
            .AddCookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
            {
                options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                options.ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;span&gt;options.ClientSecret &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &quot;secret&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
                options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token &lt;span&gt;code&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;span&gt;options.Scope.Add(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;socialnetwork&quot;);
                options.Scope.Add(&quot;offline_access&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                options.SaveTokens &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;span&gt;options.GetClaimsFromUserInfoEndpoint &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= true&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先改ClientId和Authorization server一致. 这样用户访问的时候和implicit差不多, 只不过重定向回来的时候, 获取了一个code, 使用这个code可以换取secret然后获取access token.&lt;/p&gt;
&lt;p&gt;所以需要在网站(MvcClient)上指定Client Secret. 这个不要泄露出去.&lt;/p&gt;
&lt;p&gt;还需要改变reponse type, 不需要再获取access token了, 而是code, 这意味着使用的是Authorization Code flow.&lt;/p&gt;
&lt;p&gt;还需要指定请求访问的scopes: 包括 socialnetwork api和离线访问&lt;/p&gt;
&lt;p&gt;最后还可以告诉它从UserInfo节点获取用户的Claims.&lt;/p&gt;

&lt;p&gt;点击About, 重定向到Authorization Server:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106203711169-1535526784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时在Authorization Server的控制台可以看见如下信息:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106203733200-266796215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到请求访问的scope, response_type. 还告诉我们respose mode是from_post, 这就是说, 在这登陆后重定向回到网站是使用的form post方式.&lt;/p&gt;
&lt;p&gt;然后登陆:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106204015059-1765695997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看到请求访问的范围, 包括个人信息和Application Access.&lt;/p&gt;
&lt;p&gt;点击Yes, Allow:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106204134263-1205616414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重定向回到了网站. 这里看起来好像和以前一样. 但是如果看一下Authorization Server的控制台:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106204255513-1269956998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就会看到一个request. 中间件发起了一个请求使用Authorization Code和ClientId和secret来换取了Access token.&lt;/p&gt;
&lt;p&gt;当Authorization验证上述信息后, 它就会创建一个token.&lt;/p&gt;

&lt;p&gt;修改MvcClient的About.cshtml:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using Microsoft.AspNetCore.Authentication
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id_token&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@await ViewContext.HttpContext.GetTokenAsync(&quot;id_token&quot;)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;access_token&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;strong&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@await ViewContext.HttpContext.GetTokenAsync(&quot;access_token&quot;)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;div&amp;gt;
    &amp;lt;strong&amp;gt;refresh_token&amp;lt;/strong&amp;gt;
    &amp;lt;span&amp;gt;@await ViewContext.HttpContext.GetTokenAsync(&quot;refresh_token&quot;)&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @foreach (var claim in User.Claims)
    {
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@claim.Type&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@claim.Value&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新页面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106204750544-341544679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到了refresh token.&lt;/p&gt;
&lt;p&gt;这些token包含了什么时候过期的信息.&lt;/p&gt;
&lt;p&gt;如果access token过期了, 就无法访问api了. 所以需要确保access token不过期. 这就需要使用refresh token了.&lt;/p&gt;
&lt;p&gt;复制一下refresh token, 然后使用postman:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106205139513-39687568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用这个refresh token可以获取到新的access token和refresh_token, 当这个access_token过期的时候, 可以使用refresh_token再获取一个access_token和refresh_token......&lt;/p&gt;
&lt;p&gt;而如果使用同一个refresh token两次, 就会得到下面的结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106205347856-564600382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看看Authorization Server的控制台, 显示是一个invalid refresh token:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171106205444606-2110926939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以说, refresh token是一次性的.&lt;/p&gt;

&lt;p&gt;web api 要求request请求提供access token, 以证明请求的用户是已经授权的. 现在我们准备从Access token里面提取一些自定义的Claims, 例如Email.&lt;/p&gt;
&lt;p&gt;看看Authorization Server的Client配置:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107131838575-1561344546.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Client的AllowedScopes已经包括了Email. 但是还没有配置Authorization Server允许这个Scope. 所以需要修改GetIdentityResources()(我自己的代码可能改名成IdentityResources()了):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;IdentityResource&amp;gt;&lt;span&gt; IdentityResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.OpenId(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile(),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; IdentityResources.Email()&lt;/span&gt;
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要为TestUser添加一个自定义的Claims;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;TestUser&amp;gt;&lt;span&gt; Users()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestUser
                {
                    SubjectId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mail@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Password &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;span&gt;Claims &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new [] { new Claim(&quot;email&quot;, &quot;mail@qq.com&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;) }&lt;/span&gt;
                }
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后需要对MvcClient进行设置, Startup的ConfigureServices:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();

            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
            services.AddAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            })
            .AddCookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
            {
                options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                options.ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.ClientSecret &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id_token code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socialnetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;offline_access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;span&gt;options.Scope.Add(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;email&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                options.SaveTokens &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.GetClaimsFromUserInfoEndpoint &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加email scope. 所以MvcClient就会也请求这个scope.&lt;/p&gt;
&lt;p&gt;运行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107132600153-2028205233.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时在同意(consent)页面就会出现email address一栏.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107132659028-659738764.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同意之后, 可以看到email已经获取到了.&lt;/p&gt;

&lt;p&gt;首先在web api项目建立一个IdentityController:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebApi.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IdentityController: Controller
    {
        [&lt;span&gt;Authorize&lt;/span&gt;]
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Get()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; username = User.Claims.First(x =&amp;gt; x.Type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(username);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return new JsonResult(from c in User.Claims select new { c.Type, c.Value});&lt;/span&gt;
&lt;span&gt;        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们想要通过自定义的claim: email的值.&lt;/p&gt;
&lt;p&gt;然后回到mvcClient的HomeController, 添加一个方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; GetIdentity()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
            {
                client.DefaultRequestHeaders.Authorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AuthenticationHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, token);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001/api/identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                // &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; JArray.Parse(content).ToString();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(new { value = content });
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里首先通过HttpContext获得access token, 然后在请求的Authorization Header加上Bearer Token.&lt;/p&gt;
&lt;p&gt;让我们运行一下, 并在MvcClient和Web Api里面都设好断点,&lt;/p&gt;
&lt;p&gt;登录后在浏览器输入 http://localhost:5002/Home/GetIdentity 以执行GetIdenttiy方法, 然后进入Web Api看看断点调试情况:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107134728825-1822262194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我们已经授权了, 所以可以看到User的一些claims, 而其中没有email这个claim. 再运行就报错了.&lt;/p&gt;
&lt;p&gt;这是怎么回事? 我们回到About页面, 复制一下access_token, 去jwt.io分析一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107135138747-2085642282.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实没有email的值, 所以提取不出来.&lt;/p&gt;
&lt;p&gt;所以我们需要把email添加到access token的数据里面, 这就需要告诉Authorization Server的Api Resource里面要包括User的Scope, 因为这是Identity Scope, 我们想要把它添加到access token里:&lt;/p&gt;
&lt;p&gt;修改Authorization Server的InMemoryConfiguration的ApiResources():&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; ApiResources()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socialnetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;社交网络&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;span&gt;{
                    UserClaims &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new [] { &quot;email&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt; }
                }&lt;/span&gt;
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这对这个Api Resouce设置它的属性UserClaims, 里面写上email.&lt;/p&gt;
&lt;p&gt;然后再运行一下程序, 这里需要重新登陆, 首先分析一下token:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107135830747-451552352.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有email了. &lt;/p&gt;
&lt;p&gt;然后执行GetIdentity(), 在web api断点调试, 可以看到UserClaims已经包含了email:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107140350434-1705894253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;上面这些如果您不会的话, 需要整理总结一下.&lt;/h2&gt;
&lt;p&gt;用户使用Authorization Server去登录网站(MvcClient), 也就是说用户从网站跳转到第三方的系统完成了身份的验证, 然后被授权可以访问web api了(这里讲的是用户通过mvcClient访问api). 当访问web api的时候, 首先和authorization server沟通确认access token的正确性, 然后就可以成功的访问api了.&lt;/p&gt;

&lt;p&gt;根据配置不同, token的有效期可能差别很大, 如果token过期了, 那么发送请求之后就会返回401 UnAuthorized.&lt;/p&gt;
&lt;p&gt;当然如果token过期了, 你可以让用户重定向到Authorization Server重新登陆,再回来操作, 不过这样太不友好, 太繁琐了.&lt;/p&gt;
&lt;p&gt;既然我们有refresh token了, 那不如向authorization server请求一个新的access token和refresh token. 然后再把这些更新到cookie里面. 所以下次再调用api的时候使用的是新的token.&lt;/p&gt;
&lt;p&gt;在MvcClient的HomeController添加RefreshTokens()方法:&lt;/p&gt;
&lt;p&gt;首先需要安装IdentityModel, 它是OpenIdConnect, OAuth2.0的客户端库:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107142017809-1221236771.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task RefreshTokensAsync()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authorizationServerInfo = &lt;span&gt;await&lt;/span&gt; DiscoveryClient.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt; TokenClient(authorizationServerInfo.TokenEndpoint, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; refreshToken = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refresh_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; client.RequestRefreshTokenAsync(refreshToken);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; identityToken = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expiresAt = DateTime.UtcNow +&lt;span&gt; TimeSpan.FromSeconds(response.ExpiresIn);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokens = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationToken
                {
                    Name &lt;/span&gt;=&lt;span&gt; OpenIdConnectParameterNames.IdToken,
                    Value &lt;/span&gt;=&lt;span&gt; identityToken
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationToken
                {
                    Name &lt;/span&gt;=&lt;span&gt; OpenIdConnectParameterNames.AccessToken,
                    Value &lt;/span&gt;=&lt;span&gt; response.AccessToken
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationToken
                {
                    Name &lt;/span&gt;=&lt;span&gt; OpenIdConnectParameterNames.RefreshToken,
                    Value &lt;/span&gt;=&lt;span&gt; response.RefreshToken
                },
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationToken
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expires_at&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Value &lt;/span&gt;= expiresAt.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, CultureInfo.InvariantCulture)
                }
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authenticationInfo = &lt;span&gt;await&lt;/span&gt; HttpContext.AuthenticateAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            authenticationInfo.Properties.StoreTokens(tokens);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; HttpContext.SignInAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, authenticationInfo.Principal, authenticationInfo.Properties);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先使用一个叫做discovery client的东西来获取Authorization Server的信息. Authorization Server里面有一个discovery节点(endpoint), 可以通过这个地址查看: /.well-known/openid-configuration. 从这里可以获得很多信息, 例如: authorization节点, token节点, 发布者, key, scopes等等.&lt;/p&gt;
&lt;p&gt;然后使用TokenClient, 参数有token节点, clientId和secret. 然后可以使用这个client和refreshtoken来请求新的access token等. &lt;/p&gt;
&lt;p&gt;找到refresh token后, 使用client获取新的tokens, 返回结果是tokenresponse. 你可以设断点查看一下token reponse里面都有什么东西, 这里就不弄了, 里面包括identitytoken, accesstoken, refreshtoken等等.&lt;/p&gt;
&lt;p&gt;然后需要找到原来的identity token, 因为它相当于是cookie中存储的主键...&lt;/p&gt;
&lt;p&gt;然后设置一下过期时间.&lt;/p&gt;
&lt;p&gt;然后将老的identity token和新获取到的其它tokens以及过期时间, 组成一个集合.&lt;/p&gt;
&lt;p&gt;然后使用这些tokens来重新登陆用户. 不过首先要获取当前用户的authentication信息, 使用HttpContext.AuthenticateAsync(&quot;Cookies&quot;), 参数是AuthenticationScheme. 然后修改属性, 存储新的tokens.&lt;/p&gt;
&lt;p&gt;最后就是重登录, 把当前用户信息的Principal和Properties传进去. 这就会更新客户端的Cookies, 用户也就保持登陆并且刷新了tokens.&lt;/p&gt;
&lt;p&gt;先简单调用一下这个方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; GetIdentity()
        {
            &lt;/span&gt;&lt;span&gt;await RefreshTokensAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
            {
                client.DefaultRequestHeaders.Authorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AuthenticationHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, token);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001/api/identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var json = JArray.Parse(content).ToString();&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { value =&lt;span&gt; content });
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正式生产环境中可不要这么做, 正式环境中应该在401之后, 调用这个方法, 如果再失败, 再返回错误.&lt;/p&gt;
&lt;p&gt;运行一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107150038731-1296232033.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现获取的access token是空的, 一定是哪出现了问题, 看一下 authorization server的控制台:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107150113856-1690270723.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说refresh token不正确(应该是内存数据和cookie数据不匹配). 那就重新登陆.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107150426481-30676148.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看断点, 有token了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107150444981-1595380740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且和About页面显示的不一样, 说明刷新token了.&lt;/p&gt;
&lt;p&gt;也可以看一下authorization server的控制台:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201711/986268-20171107150549622-106468132.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明成功请求了token.&lt;/p&gt;
&lt;p&gt;今天先到这里.&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 07:09:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7795121.html</dc:identifier>
</item>
<item>
<title>WPF TextBox按字节长度限制输入 - 衆尋</title>
<link>http://www.cnblogs.com/ZXdeveloper/p/7798943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZXdeveloper/p/7798943.html</guid>
<description>&lt;p&gt;前两天做一个项目的时候，由于页面没有限制TextBox的输入长度，所以，后台直接报错了，超出数据库最大的长度。&lt;/p&gt;
&lt;p&gt;数据库的长度是按照字节来计算的，而且不同的编码格式，汉字占用的字节长度又不相同，比如，我们用的是UTF8，一个汉字是3个字节，而默认的Default，一个汉字是2个字节。&lt;/p&gt;
&lt;p&gt;TextBox有个MaxLength属性，但是这个属性是不太合乎要求的，因为这个长度，是限制了输入的长度，比如设置20，则无论是数字、字母、汉字最大的长度都是20个，但是，对于数据库来说，长度却不相同了，&lt;/p&gt;
&lt;p&gt;所以，不能使用这个属性。&lt;/p&gt;
&lt;p&gt;为了，统一解决下这个问题，所以给TextBox写了附加属性。&lt;/p&gt;

&lt;p&gt;一、想要的效果&lt;/p&gt;
&lt;p&gt;用了附加属性，想达到一个什么效果呢，就是像设置MaxLength一样，一旦到了数据库的字节长度，就不再能输入了。&lt;/p&gt;
&lt;p&gt;因此，最开始想找一个限制输入的属性，可惜我学的太浅薄，没有找到相关的属性，因此，最后在同事的提醒下，可以记录上一次的内容，然后，如果超长，就用上一次的内容进行赋值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171107143154388-1579194997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171107144746059-1689367193.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、附加属性&lt;/p&gt;
&lt;p&gt;既然要用附加属性，并且方便使用，那肯定要给开发者暴露出来至少两个：MaxByteLength用来设置最大的字节数，EncodeModel用来设置编码格式&lt;/p&gt;
&lt;p&gt;EncodeModel是用Menu类型来做的，方便使用时直接敲内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171107143557794-2104039427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本来上面是直接想用Encoding来做的，奈何它是抽象类，只好，写个方法进行了一部转化，并且把Encoding类型的属性进行private。&lt;/p&gt;

&lt;p&gt;大致上也就是这么一个思路，下面上代码，给需要的人使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaxByteAttachedProperty:DependencyObject
    {
       &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; preText = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Encode
        {
            Default,
            ASCII,
            UTF8,
            UTF32,
            UTF7,
            BigEndianUnicode,
            Unicode
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetMaxByteLength(DependencyObject obj)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)obj.GetValue(MaxByteLengthProperty);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetMaxByteLength(DependencyObject obj, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
        {
            obj.SetValue(MaxByteLengthProperty, value);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Using a DependencyProperty as the backing store for MaxByteLength.  This enables animation, styling, binding, etc...&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty MaxByteLengthProperty =&lt;span&gt;
            DependencyProperty.RegisterAttached(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaxByteLength&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(MaxByteAttachedProperty), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyMetadata(OnTextBoxPropertyChanged));

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnTextBoxPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            TextBox tb &lt;/span&gt;= d &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TextBox;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tb==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            tb.TextChanged &lt;/span&gt;+=&lt;span&gt; Tb_TextChanged;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Tb_TextChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, TextChangedEventArgs e)
        {
            TextBox tb &lt;/span&gt;= sender &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TextBox;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IsOutMaxByteLength(tb.Text,tb))
            {
                tb.Text &lt;/span&gt;=&lt;span&gt; preText;
                tb.Select(tb.Text.Length, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Encode GetEncodeModel(DependencyObject obj)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (Encode)obj.GetValue(EncodeModelProperty);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetEncodeModel(DependencyObject obj, Encode value)
        {
            obj.SetValue(EncodeModelProperty, value);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Using a DependencyProperty as the backing store for EncodeM.  This enables animation, styling, binding, etc...&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty EncodeModelProperty =&lt;span&gt;
            DependencyProperty.RegisterAttached(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EncodeModel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(Encode), &lt;span&gt;typeof&lt;/span&gt;(MaxByteAttachedProperty), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyMetadata(Encode.UTF8, OnEncodeModelChanged));
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnEncodeModelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            SetEM(d,GetEncodeModel(d));
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Encoding GetEncodingModel(DependencyObject obj)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (Encoding)obj.GetValue(EncodingModelProperty);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetEncodingModel(DependencyObject obj, Encoding value)
        {
            obj.SetValue(EncodingModelProperty, value);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Using a DependencyProperty as the backing store for EncodingModel.  This enables animation, styling, binding, etc...&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty EncodingModelProperty =&lt;span&gt;
            DependencyProperty.RegisterAttached(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EncodingModel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(Encoding), &lt;span&gt;typeof&lt;/span&gt;(MaxByteAttachedProperty), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyMetadata(Encoding.UTF8));

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetEM(DependencyObject obj,Encode e)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.Default:
                    SetEncodingModel(obj, Encoding.Default);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.ASCII:
                    SetEncodingModel(obj, Encoding.ASCII);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.UTF8:
                    SetEncodingModel(obj, Encoding.UTF8);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.UTF32:
                    SetEncodingModel(obj, Encoding.UTF32);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.UTF7:
                    SetEncodingModel(obj, Encoding.UTF7);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.BigEndianUnicode:
                    SetEncodingModel(obj, Encoding.BigEndianUnicode);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Encode.Unicode:
                    SetEncodingModel(obj, Encoding.Unicode);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsOutMaxByteLength(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; txt, DependencyObject obj)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; txtLength = GetEncodingModel(obj).GetBytes(txt).Length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本长度&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (GetMaxByteLength(obj) &amp;gt;=&lt;span&gt; txtLength)
            {
                preText &lt;/span&gt;=&lt;span&gt; txt;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 使用方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171107144043669-1693388203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MaxByteLength是必须设置的没有进行默认，EncodeModel可以不设置但是由于是我们自己用，所以默认是UTF8，可以自行修改代码，按照你们公司的编码格式，这样也就不用赋值了。&lt;/p&gt;

</description>
<pubDate>Tue, 07 Nov 2017 06:45:00 +0000</pubDate>
<dc:creator>衆尋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZXdeveloper/p/7798943.html</dc:identifier>
</item>
<item>
<title>【Kafka源码】SocketServer启动过程 - 端木轩</title>
<link>http://www.cnblogs.com/f-zhao/p/7798796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-zhao/p/7798796.html</guid>
<description>&lt;p&gt;SocketServer主要用于接收外部的网络请求，并把请求添加到请求队列中。&lt;/p&gt;

&lt;p&gt;在KafkaServer.scala中的start方法中，有这样的入口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;socketServer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SocketServer&lt;/span&gt;(config, metrics, kafkaMetricsTime)
socketServer.&lt;span class=&quot;fu&quot;&gt;startup&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这块就是启动了一个SocketServer，我们具体看一下。&lt;/p&gt;

&lt;p&gt;我们看下SocketServer里面包含的参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; endpoints = config.&lt;span class=&quot;fu&quot;&gt;listeners&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; numProcessorThreads = config.&lt;span class=&quot;fu&quot;&gt;numNetworkThreads&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; maxQueuedRequests = config.&lt;span class=&quot;fu&quot;&gt;queuedMaxRequests&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; totalProcessorThreads = numProcessorThreads * endpoints.&lt;span class=&quot;fu&quot;&gt;siz&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; maxConnectionsPerIp = config.&lt;span class=&quot;fu&quot;&gt;maxConnectionsPerIp&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; maxConnectionsPerIpOverrides config.&lt;span class=&quot;fu&quot;&gt;maxConnectionsPerIpOverride&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;logIdent&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;&quot;[Socket Server on Broker &quot;&lt;/span&gt; + config.&lt;span class=&quot;fu&quot;&gt;brokerId&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&quot;], &quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; requestChannel = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RequestChannel&lt;/span&gt;(totalProcessorThreadsmaxQueuedRequests)
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; processors = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Array[Processor](totalProcessorThreads)

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt;[network] &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; acceptors = mutable.&lt;span class=&quot;fu&quot;&gt;Map&lt;/span&gt;[EndPoint, Acceptor]()
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; connectionQuotas: ConnectionQuotas = _&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面涉及几个配置内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;listeners：默认是PLAINTEXT://:port,前面部分是协议,可配置为PLAINTEXT,SSL,SASL_PLAINTEXT,SASL_SSL&lt;/li&gt;
&lt;li&gt;num.network.threads：处理网络请求的线程个数配置,默认是3&lt;/li&gt;
&lt;li&gt;queued.max.requests：请求队列的最大个数,默认500&lt;/li&gt;
&lt;li&gt;max.connections.per.ip：单机IP的最大连接个数的配置,默认不限制&lt;/li&gt;
&lt;li&gt;max.connections.per.ip.overrides：针对某个特别的IP的连接个数限制的重新设置值.多个IP配置间使用逗号分开,如:host1:500,host2:600&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;启动的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Start the socket server&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;startup&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;synchronized&lt;/span&gt; {

    &lt;span class=&quot;co&quot;&gt;//每个ip的连接数限制&lt;/span&gt;
    connectionQuotas = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConnectionQuotas&lt;/span&gt;(maxConnectionsPerIp, maxConnectionsPerIpOverrides)

    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; sendBufferSize = config.&lt;span class=&quot;fu&quot;&gt;socketSendBufferBytes&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; recvBufferSize = config.&lt;span class=&quot;fu&quot;&gt;socketReceiveBufferBytes&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; brokerId = config.&lt;span class=&quot;fu&quot;&gt;brokerId&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;//这里根据每一个endpoint(也就是配置的listener的协议与端口),生成处理的网络线程Processor与Acceptor实例.并启动endpoint对应的Acceptor实例.在生成Acceptor的实例时,会同时启动此实例中对应的线程处理实例数组Processor.&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; processorBeginIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    endpoints.&lt;span class=&quot;fu&quot;&gt;values&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt; { endpoint =&amp;gt;
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; protocol = endpoint.&lt;span class=&quot;fu&quot;&gt;protocolType&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; processorEndIndex = processorBeginIndex + numProcessorThreads

        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (i &amp;lt;- processorBeginIndex until processorEndIndex)
          &lt;span class=&quot;fu&quot;&gt;processors&lt;/span&gt;(i) = &lt;span class=&quot;fu&quot;&gt;newProcessor&lt;/span&gt;(i, connectionQuotas, protocol)

        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; acceptor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Acceptor&lt;/span&gt;(endpoint, sendBufferSize, recvBufferSize, brokerId,
          processors.&lt;span class=&quot;fu&quot;&gt;slice&lt;/span&gt;(processorBeginIndex, processorEndIndex), connectionQuotas)
        acceptors.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(endpoint, acceptor)
        Utils.&lt;span class=&quot;fu&quot;&gt;newThread&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;kafka-socket-acceptor-%s-%d&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(protocol.toString, endpoint.port), acceptor, false).start()
        acceptor.&lt;span class=&quot;fu&quot;&gt;awaitStartup&lt;/span&gt;()

        processorBeginIndex = processorEndIndex
      }
    }

    &lt;span class=&quot;fu&quot;&gt;newGauge&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;NetworkProcessorAvgIdlePercent&quot;&lt;/span&gt;,
      &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Gauge[Double] {
        &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; value = allMetricNames.&lt;span class=&quot;fu&quot;&gt;map&lt;/span&gt;( metricName =&amp;gt;
          metrics.&lt;span class=&quot;fu&quot;&gt;metrics&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(metricName).&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;()).&lt;span class=&quot;fu&quot;&gt;sum&lt;/span&gt; / totalProcessorThreads
      }
    )

    &lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Started &quot;&lt;/span&gt; + acceptors.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&quot; acceptor threads&quot;&lt;/span&gt;)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这块涉及到几个配置项，主要用于生成socket中的SO_SNDBUF和SO_RCVBUF。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;socket.send.buffer.bytes：默认值100kb,这个用于SOCKET发送数据的缓冲区大小&lt;/li&gt;
&lt;li&gt;socket.receive.buffer.bytes：默认值100kb,这个用于SOCKET的接收数据的缓冲区大小&lt;/li&gt;
&lt;li&gt;broker.id&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;newprocessor&quot;&gt;3.1 newProcessor&lt;/h2&gt;
&lt;p&gt;我们先看下这个简单的赋值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt;[network] &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;newProcessor&lt;/span&gt;(id: Int, connectionQuotas: ConnectionQuotas, protocol: SecurityProtocol): Processor = {
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Processor&lt;/span&gt;(id,
      time,
      config.&lt;span class=&quot;fu&quot;&gt;socketRequestMaxBytes&lt;/span&gt;,
      requestChannel,
      connectionQuotas,
      config.&lt;span class=&quot;fu&quot;&gt;connectionsMaxIdleMs&lt;/span&gt;,
      protocol,
      config.&lt;span class=&quot;fu&quot;&gt;values&lt;/span&gt;,
      metrics
    )
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是Processor的实例生成，主要涉及几个配置项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;socket.request.max.bytes：设置每次请求的数据大小.默认值,100MB&lt;/li&gt;
&lt;li&gt;connections.max.idle.ms：默认为10分钟,用于设置每个连接最大的空闲回收时间&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;acceptor&quot;&gt;3.2 Acceptor&lt;/h2&gt;
&lt;p&gt;每个endPoint对应一个Acceptor，也就是每个listener对应一个Acceptor。Acceptor主要用于接收网络请求，将请求分发到processor处理。我们来看下Acceptor的run方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
    &lt;span class=&quot;co&quot;&gt;//将channel注册到selector上&lt;/span&gt;
    serverChannel.&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(nioSelector, SelectionKey.&lt;span class=&quot;fu&quot;&gt;OP_ACCEPT&lt;/span&gt;)
    &lt;span class=&quot;fu&quot;&gt;startupComplete&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; currentProcessor = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (isRunning) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
          &lt;span class=&quot;co&quot;&gt;//这里进行堵塞接收,最多等500ms,如果ready返回的值是0表示还没有准备好,否则表示准备就绪.表示有通道已经被注册&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; ready = nioSelector.&lt;span class=&quot;fu&quot;&gt;select&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;)
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ready &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;//这里得到已经准备好的网络通道的key的集合&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; keys = nioSelector.&lt;span class=&quot;fu&quot;&gt;selectedKeys&lt;/span&gt;()
            &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; iter = keys.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;()
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (iter.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt; &amp;amp;&amp;amp; isRunning) {
              &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; key = iter.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;
                iter.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;()
                &lt;span class=&quot;co&quot;&gt;//如果selectkey已经注册到accept事件,通过accept函数与对应的线程Processor进行处理.这里表示这个socket的通道包含有一个client端的连接请求.&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (key.&lt;span class=&quot;fu&quot;&gt;isAcceptable&lt;/span&gt;)
                  &lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(key, &lt;span class=&quot;fu&quot;&gt;processors&lt;/span&gt;(currentProcessor))
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                  &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;Unrecognized key state for acceptor thread.&quot;&lt;/span&gt;)

                &lt;span class=&quot;co&quot;&gt;// round robin to the next processor thread&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//每次接收一个socket请求后,用于处理的线程进行轮询到一个线程中处理.&lt;/span&gt;
                currentProcessor = (currentProcessor + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) % processors.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;
              } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e: Throwable =&amp;gt; &lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Error while accepting connection&quot;&lt;/span&gt;, e)
              }
            }
          }
        }
        &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
          &lt;span class=&quot;co&quot;&gt;// We catch all the throwables to prevent the acceptor thread from exiting on exceptions due&lt;/span&gt;
          &lt;span class=&quot;co&quot;&gt;// to a select operation on a specific channel or a bad request. We don't want the&lt;/span&gt;
          &lt;span class=&quot;co&quot;&gt;// the broker to stop responding to requests from other clients in these scenarios.&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e: ControlThrowable =&amp;gt; &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e: Throwable =&amp;gt; &lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Error occurred&quot;&lt;/span&gt;, e)
        }
      }
    } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
      &lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Closing server socket and selector.&quot;&lt;/span&gt;)
      &lt;span class=&quot;fu&quot;&gt;swallowError&lt;/span&gt;(serverChannel.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;())
      &lt;span class=&quot;fu&quot;&gt;swallowError&lt;/span&gt;(nioSelector.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;())
      &lt;span class=&quot;fu&quot;&gt;shutdownComplete&lt;/span&gt;()
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们看下accept方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;  &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * Accept a new connection&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   */&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(key: SelectionKey, processor: Processor) {
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; serverSocketChannel = key.&lt;span class=&quot;fu&quot;&gt;channel&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;asInstanceOf&lt;/span&gt;[ServerSocketChannel]
    &lt;span class=&quot;co&quot;&gt;//得到请求的socket通道&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; socketChannel = serverSocketChannel.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;co&quot;&gt;//这里检查当前的IP的连接数是否已经达到了最大的连接数,如果是,直接throw too many connect.&lt;/span&gt;
      connectionQuotas.&lt;span class=&quot;fu&quot;&gt;inc&lt;/span&gt;(socketChannel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInetAddress&lt;/span&gt;)
      socketChannel.&lt;span class=&quot;fu&quot;&gt;configureBlocking&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)
      socketChannel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setTcpNoDelay&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)
      socketChannel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setKeepAlive&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)
      socketChannel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setSendBufferSize&lt;/span&gt;(sendBufferSize)

      &lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Accepted connection from %s on %s and assigned it to processor %d, sendBufferSize [actual|requested]: [%d|%d] recvBufferSize [actual|requested]: [%d|%d]&quot;&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(socketChannel.socket.getRemoteSocketAddress, socketChannel.socket.getLocalSocketAddress, processor.id,
                  socketChannel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getSendBufferSize&lt;/span&gt;, sendBufferSize,
                  socketChannel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getReceiveBufferSize&lt;/span&gt;, recvBufferSize))

      &lt;span class=&quot;co&quot;&gt;//对应的processor处理socket通道&lt;/span&gt;
      processor.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(socketChannel)
    } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e: TooManyConnectionsException =&amp;gt;
        &lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Rejected connection from %s, address already has the configured maximum of %d connections.&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(e.ip, e.count))
        &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(socketChannel)
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;processor&quot;&gt;3.3 Processor&lt;/h2&gt;
&lt;p&gt;上面accept方法中，调用到了processor的accept方法，我们看下这个accept方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;  &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * Queue up a new connection for reading&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   */&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(socketChannel: SocketChannel) {
    newConnections.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(socketChannel)
    &lt;span class=&quot;fu&quot;&gt;wakeup&lt;/span&gt;()
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是向队列中新增了一个socket通道，等待processor线程处理。下面我们看下processor是怎么处理的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
    &lt;span class=&quot;fu&quot;&gt;startupComplete&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (isRunning) {
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// setup any new connections that have been queued up&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;configureNewConnections&lt;/span&gt;()
        &lt;span class=&quot;co&quot;&gt;// register any new responses for writing&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;processNewResponses&lt;/span&gt;()
        &lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;()
        &lt;span class=&quot;fu&quot;&gt;processCompletedReceives&lt;/span&gt;()
        &lt;span class=&quot;fu&quot;&gt;processCompletedSends&lt;/span&gt;()
        &lt;span class=&quot;fu&quot;&gt;processDisconnected&lt;/span&gt;()
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// We catch all the throwables here to prevent the processor thread from exiting. We do this because&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// letting a processor exit might cause a bigger impact on the broker. Usually the exceptions thrown would&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// be either associated with a specific socket channel or a bad request. We just ignore the bad socket channel&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// or request. This behavior might need to be reviewed if we see an exception that need the entire broker to stop.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e: ControlThrowable =&amp;gt; &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e: Throwable =&amp;gt;
          &lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Processor got uncaught exception.&quot;&lt;/span&gt;, e)
      }
    }

    &lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Closing selector - processor &quot;&lt;/span&gt; + id)
    &lt;span class=&quot;fu&quot;&gt;swallowError&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;closeAll&lt;/span&gt;())
    &lt;span class=&quot;fu&quot;&gt;shutdownComplete&lt;/span&gt;()
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这块其实是个门面模式，里面调用的内容比较多，我们一一看一下。&lt;/p&gt;
&lt;h3 id=&quot;configurenewconnections&quot;&gt;3.3.1 configureNewConnections&lt;/h3&gt;
&lt;p&gt;这块是从队列中取一个连接，并注册到selector上。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;  &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   * Register any new connections that have been queued up&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;   */&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;configureNewConnections&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!newConnections.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;) {
      &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; channel = newConnections.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;()
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(s&lt;span class=&quot;st&quot;&gt;&quot;Processor $id listening to new connection from ${channel.socket.getRemoteSocketAddress}&quot;&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; localHost = channel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getLocalAddress&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getHostAddress&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; localPort = channel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getLocalPort&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; remoteHost = channel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInetAddress&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getHostAddress&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; remotePort = channel.&lt;span class=&quot;fu&quot;&gt;socket&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getPort&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; connectionId = &lt;span class=&quot;fu&quot;&gt;ConnectionId&lt;/span&gt;(localHost, localPort, remoteHost, remotePort).&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;
        selector.&lt;span class=&quot;fu&quot;&gt;register&lt;/span&gt;(connectionId, channel)
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;// We explicitly catch all non fatal exceptions and close the socket to avoid a socket leak. The other&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// throwables will be caught in processor and logged as uncaught exceptions.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;NonFatal&lt;/span&gt;(e) =&amp;gt;
          &lt;span class=&quot;co&quot;&gt;// need to close the channel here to avoid a socket leak.&lt;/span&gt;
          &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(channel)
          &lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(s&lt;span class=&quot;st&quot;&gt;&quot;Processor $id closed connection from ${channel.getRemoteAddress}&quot;&lt;/span&gt;, e)
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;processnewresponses&quot;&gt;3.3.2 processNewResponses&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;processNewResponses&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; curr = requestChannel.&lt;span class=&quot;fu&quot;&gt;receiveResponse&lt;/span&gt;(id)
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (curr != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        curr.&lt;span class=&quot;fu&quot;&gt;responseAction&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;match&lt;/span&gt; {
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; RequestChannel.&lt;span class=&quot;fu&quot;&gt;NoOpAction&lt;/span&gt; =&amp;gt;
            &lt;span class=&quot;co&quot;&gt;// There is no response to send to the client, we need to read more pipelined requests&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// that are sitting in the server's socket buffer&lt;/span&gt;
            curr.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateRequestMetrics&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;trace&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Socket server received empty response to send, registering for read: &quot;&lt;/span&gt; + curr)
            selector.&lt;span class=&quot;fu&quot;&gt;unmute&lt;/span&gt;(curr.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;connectionId&lt;/span&gt;)
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; RequestChannel.&lt;span class=&quot;fu&quot;&gt;SendAction&lt;/span&gt; =&amp;gt;
            &lt;span class=&quot;fu&quot;&gt;sendResponse&lt;/span&gt;(curr)
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; RequestChannel.&lt;span class=&quot;fu&quot;&gt;CloseConnectionAction&lt;/span&gt; =&amp;gt;
            curr.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateRequestMetrics&lt;/span&gt;
            &lt;span class=&quot;fu&quot;&gt;trace&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Closing socket connection actively according to the response code.&quot;&lt;/span&gt;)
            &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(selector, curr.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;connectionId&lt;/span&gt;)
        }
      } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
        curr = requestChannel.&lt;span class=&quot;fu&quot;&gt;receiveResponse&lt;/span&gt;(id)
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;poll&quot;&gt;3.3.3 poll&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; selector.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e @ (_: IllegalStateException | _: IOException) =&amp;gt;
        &lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(s&lt;span class=&quot;st&quot;&gt;&quot;Closing processor $id due to illegal state or IO exception&quot;&lt;/span&gt;)
        &lt;span class=&quot;fu&quot;&gt;swallow&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;closeAll&lt;/span&gt;())
        &lt;span class=&quot;fu&quot;&gt;shutdownComplete&lt;/span&gt;()
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; timeout) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (timeout &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;timeout should be &amp;gt;= 0&quot;&lt;/span&gt;);

        &lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;();

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;hasStagedReceives&lt;/span&gt;() || !immediatelyConnectedKeys.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;())
            timeout = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;/* check ready keys */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startSelect = time.&lt;span class=&quot;fu&quot;&gt;nanoseconds&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; readyKeys = &lt;span class=&quot;fu&quot;&gt;select&lt;/span&gt;(timeout);
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endSelect = time.&lt;span class=&quot;fu&quot;&gt;nanoseconds&lt;/span&gt;();
        currentTimeNanos = endSelect;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sensors&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;selectTime&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;record&lt;/span&gt;(endSelect - startSelect, time.&lt;span class=&quot;fu&quot;&gt;milliseconds&lt;/span&gt;());

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (readyKeys &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || !immediatelyConnectedKeys.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
            &lt;span class=&quot;fu&quot;&gt;pollSelectionKeys&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;nioSelector&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;selectedKeys&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;fu&quot;&gt;pollSelectionKeys&lt;/span&gt;(immediatelyConnectedKeys, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        }

        &lt;span class=&quot;fu&quot;&gt;addToCompletedReceives&lt;/span&gt;();

        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; endIo = time.&lt;span class=&quot;fu&quot;&gt;nanoseconds&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sensors&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ioTime&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;record&lt;/span&gt;(endIo - endSelect, time.&lt;span class=&quot;fu&quot;&gt;milliseconds&lt;/span&gt;());
        &lt;span class=&quot;fu&quot;&gt;maybeCloseOldestConnection&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这块主要看一下pollSelectionKeys方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;pollSelectionKeys&lt;/span&gt;(Iterable&amp;lt;SelectionKey&amp;gt; selectionKeys, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isImmediatelyConnected) {
        Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (iterator.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
            SelectionKey key = iterator.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            iterator.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;();
            KafkaChannel channel = &lt;span class=&quot;fu&quot;&gt;channel&lt;/span&gt;(key);

            &lt;span class=&quot;co&quot;&gt;// register all per-connection metrics at once&lt;/span&gt;
            sensors.&lt;span class=&quot;fu&quot;&gt;maybeRegisterConnectionMetrics&lt;/span&gt;(channel.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;());
            lruConnections.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(channel.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;(), currentTimeNanos);

            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

                &lt;span class=&quot;co&quot;&gt;/* complete any connections that have finished their handshake (either normally or immediately) */&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isImmediatelyConnected || key.&lt;span class=&quot;fu&quot;&gt;isConnectable&lt;/span&gt;()) {
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (channel.&lt;span class=&quot;fu&quot;&gt;finishConnect&lt;/span&gt;()) {
                        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;connected&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(channel.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;());
                        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sensors&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;connectionCreated&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;record&lt;/span&gt;();
                    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
                }

                &lt;span class=&quot;co&quot;&gt;/* if channel is not ready finish prepare */&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (channel.&lt;span class=&quot;fu&quot;&gt;isConnected&lt;/span&gt;() &amp;amp;&amp;amp; !channel.&lt;span class=&quot;fu&quot;&gt;ready&lt;/span&gt;())
                    channel.&lt;span class=&quot;fu&quot;&gt;prepare&lt;/span&gt;();

                &lt;span class=&quot;co&quot;&gt;/* if channel is ready read from any connections that have readable data */&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (channel.&lt;span class=&quot;fu&quot;&gt;ready&lt;/span&gt;() &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;isReadable&lt;/span&gt;() &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;hasStagedReceive&lt;/span&gt;(channel)) {
                    NetworkReceive networkReceive;
                    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((networkReceive = channel.&lt;span class=&quot;fu&quot;&gt;read&lt;/span&gt;()) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                        &lt;span class=&quot;fu&quot;&gt;addToStagedReceives&lt;/span&gt;(channel, networkReceive);
                }

                &lt;span class=&quot;co&quot;&gt;/* if channel is ready write to any sockets that have space in their buffer and for which we have data */&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (channel.&lt;span class=&quot;fu&quot;&gt;ready&lt;/span&gt;() &amp;amp;&amp;amp; key.&lt;span class=&quot;fu&quot;&gt;isWritable&lt;/span&gt;()) {
                    Send send = channel.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;();
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (send != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;completedSends&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(send);
                        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;sensors&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;recordBytesSent&lt;/span&gt;(channel.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;(), send.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());
                    }
                }

                &lt;span class=&quot;co&quot;&gt;/* cancel any defunct sockets */&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!key.&lt;span class=&quot;fu&quot;&gt;isValid&lt;/span&gt;()) {
                    &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(channel);
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;disconnected&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(channel.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;());
                }

            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                String desc = channel.&lt;span class=&quot;fu&quot;&gt;socketDescription&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (e &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; IOException)
                    log.&lt;span class=&quot;fu&quot;&gt;debug&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Connection with {} disconnected&quot;&lt;/span&gt;, desc, e);
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                    log.&lt;span class=&quot;fu&quot;&gt;warn&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Unexpected error from {}; closing connection&quot;&lt;/span&gt;, desc, e);
                &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(channel);
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;disconnected&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(channel.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt;());
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里开始处理socket通道中的请求,根据如下几个流程进行处理:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果请求中包含有一个isConnectable操作,把这个连接缓存起来.&lt;/li&gt;
&lt;li&gt;如果请求中包含有isReadable操作.表示这个client的管道中包含有数据,需要读取,接收数据.&lt;/li&gt;
&lt;li&gt;如果包含有isWriteable的操作,表示需要向client端进行写操作.&lt;/li&gt;
&lt;li&gt;最后检查是否有connect被关闭的请求或connect连接空闲过期&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;processcompletedreceives&quot;&gt;3.3.4 processCompletedReceives&lt;/h3&gt;
&lt;p&gt;得到对应的请求的Request的实例,并把这个Request通过SocketServer中的RequestChannel的sendRequest的函数,把请求添加到请求的队列中.等待KafkaApis来进行处理.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;processCompletedReceives&lt;/span&gt;() {
    selector.&lt;span class=&quot;fu&quot;&gt;completedReceives&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;asScala&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt; { receive =&amp;gt;
      &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; channel = selector.&lt;span class=&quot;fu&quot;&gt;channel&lt;/span&gt;(receive.&lt;span class=&quot;fu&quot;&gt;source&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; session = RequestChannel.&lt;span class=&quot;fu&quot;&gt;Session&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;KafkaPrincipal&lt;/span&gt;(KafkaPrincipal.&lt;span class=&quot;fu&quot;&gt;USER_TYPE&lt;/span&gt;, channel.&lt;span class=&quot;fu&quot;&gt;principal&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;),
          channel.&lt;span class=&quot;fu&quot;&gt;socketAddress&lt;/span&gt;)
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; req = RequestChannel.&lt;span class=&quot;fu&quot;&gt;Request&lt;/span&gt;(processor = id, connectionId = receive.&lt;span class=&quot;fu&quot;&gt;source&lt;/span&gt;, session = session, buffer = receive.&lt;span class=&quot;fu&quot;&gt;payload&lt;/span&gt;, startTimeMs = time.&lt;span class=&quot;fu&quot;&gt;milliseconds&lt;/span&gt;, securityProtocol = protocol)
        &lt;span class=&quot;co&quot;&gt;//这是重点！！！可以看下KafkaApis对消息的处理，后续会分析到&lt;/span&gt;
        requestChannel.&lt;span class=&quot;fu&quot;&gt;sendRequest&lt;/span&gt;(req)
        selector.&lt;span class=&quot;fu&quot;&gt;mute&lt;/span&gt;(receive.&lt;span class=&quot;fu&quot;&gt;source&lt;/span&gt;)
      } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; e @ (_: InvalidRequestException | _: SchemaException) =&amp;gt;
          &lt;span class=&quot;co&quot;&gt;// note that even though we got an exception, we can assume that receive.source is valid. Issues with constructing a valid receive object were handled earlier&lt;/span&gt;
          &lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(s&lt;span class=&quot;st&quot;&gt;&quot;Closing socket for ${receive.source} because of error&quot;&lt;/span&gt;, e)
          &lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;(selector, receive.&lt;span class=&quot;fu&quot;&gt;source&lt;/span&gt;)
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;processcompletedsends&quot;&gt;3.3.5 processCompletedSends&lt;/h3&gt;
&lt;p&gt;这里的send完成表示有向client端进行响应的写操作处理完成&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;processCompletedSends&lt;/span&gt;() {
    selector.&lt;span class=&quot;fu&quot;&gt;completedSends&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;asScala&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt; { send =&amp;gt;
      &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; resp = inflightResponses.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(send.&lt;span class=&quot;fu&quot;&gt;destination&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getOrElse&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(s&lt;span class=&quot;st&quot;&gt;&quot;Send for ${send.destination} completed, but not in `inflightResponses`&quot;&lt;/span&gt;)
      }
      resp.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateRequestMetrics&lt;/span&gt;()
      selector.&lt;span class=&quot;fu&quot;&gt;unmute&lt;/span&gt;(send.&lt;span class=&quot;fu&quot;&gt;destination&lt;/span&gt;)
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;processdisconnected&quot;&gt;3.3.6 processDisconnected&lt;/h3&gt;
&lt;p&gt;如果socket server中包含有已经关闭的连接,减少这个quotas中对此ip的连接数的值.&lt;br/&gt;这个情况包含connect处理超时或者说有connect的消息处理错误被发起了close的请求后的处理成功的消息.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;processDisconnected&lt;/span&gt;() {
    selector.&lt;span class=&quot;fu&quot;&gt;disconnected&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;asScala&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt; { connectionId =&amp;gt;
      &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; remoteHost = ConnectionId.&lt;span class=&quot;fu&quot;&gt;fromString&lt;/span&gt;(connectionId).&lt;span class=&quot;fu&quot;&gt;getOrElse&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(s&lt;span class=&quot;st&quot;&gt;&quot;connectionId has unexpected format: $connectionId&quot;&lt;/span&gt;)
      }.&lt;span class=&quot;fu&quot;&gt;remoteHost&lt;/span&gt;
      inflightResponses.&lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(connectionId).&lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt;(_.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;updateRequestMetrics&lt;/span&gt;())
      &lt;span class=&quot;co&quot;&gt;// the channel has been closed by the selector but the quotas still need to be updated&lt;/span&gt;
      connectionQuotas.&lt;span class=&quot;fu&quot;&gt;dec&lt;/span&gt;(InetAddress.&lt;span class=&quot;fu&quot;&gt;getByName&lt;/span&gt;(remoteHost))
    }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 07 Nov 2017 06:14:00 +0000</pubDate>
<dc:creator>端木轩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-zhao/p/7798796.html</dc:identifier>
</item>
<item>
<title>关于Spring在多线程下的个人疑问 - 156庄威龙</title>
<link>http://www.cnblogs.com/lger/p/7798620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lger/p/7798620.html</guid>
<description>&lt;p&gt; 　　在Web开发中，不可避免的是需要遇到并发操作的，并发操作就有可能会引发我们的多线程安全问题。比如说，我们多线程下访问同一个变量并且有一个线程做出修改那么就会使得我们另外的线程在不知情的情况下被修改自己的数据。&lt;/p&gt;
&lt;p&gt; 　　如果说当我们其中一个线程访问了成员变量Object后并且设置为null，那么其他线程访问就会出现空指针异常了。我接触线程安全问题的时候是在数据库的连接操作。刚刚学习Web开发，使用了JDBC操作，而且对于servlet还是很懵懂。在开发的时候我竟然将Connection设置为成员变量，然后有同学点醒了我，说这样会引发线程安全问题。所以，在学习Spring的时候，我也会问自己是否线程安全的问题。&lt;/p&gt;
&lt;h3 id=&quot;多线程下单例有成员变量&quot;&gt;&lt;strong&gt;1. 多线程下单例有成员变量&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;测试&quot;&gt;&lt;strong&gt;1.1. 测试&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;首先这里有一个类&lt;code&gt;User&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class User {

    private int age;
    
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    
    public long thisTime() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().toString()+&quot;age:&quot;+age);
        age++;
        return System.currentTimeMillis();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;User&lt;/code&gt;中有一个方法&lt;code&gt;thisTime&lt;/code&gt; 这个方法访问了age并作出了+1操作的修改。&lt;br/&gt;然后我们还有一个类&lt;code&gt;MulThread&lt;/code&gt;是用于访问&lt;code&gt;User&lt;/code&gt;的方法&lt;code&gt;thisTime&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MulThread extends Thread {

    @Resource(name = &quot;user&quot;)
    private User user;
    
    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 50; i++) {
            System.out.println(Thread.currentThread().toString()+user.thisTime());
        }
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们可以开启线程用于测试模拟线程下，方法&lt;code&gt;thisTime&lt;/code&gt;的访问情况，这里我们的具体实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
public class TestMulThread {

    @Resource
    private MulThread th1;
    @Resource
    private MulThread th2;
    
    @Test
    public void test01() {
        
    System.out.println(&quot;&quot;+th1+th1.getUser()+&quot;\n&quot;+th2+th2.getUser());
        
        th1.start();
        th2.start();
        
        //等待线程结束
        try {
            Thread.sleep(20000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们接下来在Spring配置Bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean name=&quot;user&quot; class=&quot;cn.gcc.domain.User&quot; scope=&quot;singleton&quot;&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;18&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean class=&quot;cn.gcc.test.MulThread&quot; scope=&quot;prototype&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果&quot;&gt;&lt;strong&gt;1.2. 结果&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;Thread[Thread-2,5,main]cn.gcc.domain.User@cad498c
Thread[Thread-3,5,main]cn.gcc.domain.User@cad498c
Thread[Thread-2,5,main]age:18
Thread[Thread-3,5,main]age:18
Thread[Thread-2,5,main]1510027754876
Thread[Thread-3,5,main]1510027754876
Thread[Thread-3,5,main]age:20
Thread[Thread-2,5,main]age:20
.......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到上面的运行结果我们可以看到19直接被跳过了，因为age++被同时执行了两次。因此，&lt;strong&gt;结论&lt;/strong&gt;就是如果是单例模式下如果方法访问了同一个成员变量那么就会引起线程不安全的问题。&lt;/p&gt;
&lt;h4 id=&quot;修改&quot;&gt;&lt;strong&gt;1.3. 修改&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;我们现在如果想用单例但是又要线程安全的话该怎么办？修改如下：&lt;br/&gt;我们可以加锁&lt;code&gt;synchronized&lt;/code&gt;我们只需要修改&lt;code&gt;User&lt;/code&gt;的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized long thisTime() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().toString()+&quot;age:&quot;+age);
        age++;
        return System.currentTimeMillis();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Thread[Thread-2,5,main]cn.gcc.domain.User@cad498c
Thread[Thread-3,5,main]cn.gcc.domain.User@cad498c
Thread[Thread-3,5,main]age:18
Thread[Thread-3,5,main]1510028011839
Thread[Thread-2,5,main]age:19
Thread[Thread-2,5,main]1510028011939
Thread[Thread-3,5,main]age:20
....&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的运行结果就不会有执行两次age++的情况了，因为我们对&lt;code&gt;User&lt;/code&gt;对象加锁操作，多个线程对同一个对象不能同时访问。&lt;/p&gt;
&lt;p&gt;当然除了上面的方法也可以修改我们的Spring配置信息，&lt;code&gt;&amp;lt;bean name=&quot;user&quot; class=&quot;cn.gcc.domain.User&quot; scope=&quot;prototype&quot;&amp;gt;&lt;/code&gt;&lt;br/&gt;设置成多例就不会有这种问题了&lt;/p&gt;
&lt;h3 id=&quot;多线程下springmvc的controller&quot;&gt;&lt;strong&gt;2. 多线程下SpringMVC的Controller&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们在使用SpringMVC的时候默认Controller是单例的，因此，如果在设计Bean的时候是有成员变量的请参考上面所讲的 。&lt;/p&gt;
&lt;p&gt;还有一种就是我们方法中的参数引用的是Bean，那么这个引用是不是在多线程下是同一地址呢？&lt;br/&gt;现在我们写一个controller&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller
public class RegisterController {

    @RequestMapping(value = &quot;/reg.action&quot;, method = RequestMethod.GET)
    public String reg(){
        return &quot;reg.jsp&quot;;
    }

    @RequestMapping(value = &quot;/reg.action&quot;, method = RequestMethod.POST)
    public String reg2(User user){
        System.out.println(user);
        return &quot;reg.jsp&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个controller中在填入表单之后的提交过程中，form表单的各个元素SpringMVC都会帮我们封装，现在我们使用post请求去访问&lt;code&gt;/reg.action&lt;/code&gt;然后看看结果是怎么样的&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171107130822654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGdlcl9Qcm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;当我们使用了POST请求之后返回了reg.jsp的页面，控制台打印的信息是&lt;code&gt;cn.gcc.domain.User@49cd75c3&lt;/code&gt;&lt;br/&gt;我们再次访问后的打印信息是&lt;code&gt;cn.gcc.domain.User@555b1f19&lt;/code&gt;，因此，&lt;strong&gt;结论&lt;/strong&gt;就是SpringMVC帮我们封装后的方法引用中是不会出现线程问题的&lt;/p&gt;
&lt;p&gt;这里SpringMVC的封装的机制我猜测是根据setter方法来封装的，而且每次封装都会通过反射机制重新新建一个对象并且注入表单的值&lt;/p&gt;
&lt;p&gt;下面是一些关于线程安全的链接&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/xiao__gui/article/details/8188833&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/xiao__gui/article/details/8188833&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/doit8791/p/4093808.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/doit8791/p/4093808.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/29587112&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/29587112&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/a236209186/article/details/61460211&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/a236209186/article/details/61460211&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 07 Nov 2017 05:42:00 +0000</pubDate>
<dc:creator>156庄威龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lger/p/7798620.html</dc:identifier>
</item>
<item>
<title>生产者消费者模型的正确姿势 - nullzx</title>
<link>http://www.cnblogs.com/nullzx/p/7798504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullzx/p/7798504.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简介&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者、消费者模型是多线程编程的常见问题，最简单的一个生产者、一个消费者线程模型大多数人都能够写出来，但是一旦条件发生变化，我们就很容易掉进多线程的bug中。这篇文章主要讲解了生产者和消费者的数量，商品缓存位置数量，商品数量等多个条件的不同组合下，写出正确的生产者消费者模型的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎探讨，如有错误敬请指正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如需转载，请注明出处&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/nullzx/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/nullzx/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr align=&quot;center&quot; size=&quot;3&quot; width=&quot;100%&quot;/&gt;&lt;p&gt;&lt;span&gt;定义商品类&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

/*定义商品*/
public class Goods {
        public final String name;
        public final int price;
        public final int id;
        
        public Goods(String name, int price, int id){
                this.name = name; /*类型*/
                this.price = price; /*价格*/
                this.id = id; /*商品序列号*/
        }
        
        @Override
        public String toString(){
                return &quot;name: &quot; + name + &quot;,   price:&quot;+ price + &quot;,   id: &quot; + id; 
        }
}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;基本要求：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）生产者不能重复生产一个商品，也就是说不能有两个id相同的商品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）生产者不能覆盖一个商品（当前商品还未被消费，就被下一个新商品覆盖）。也就是说消费商品时，商品的id属性可以不连续，但不能出现缺号的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）消费者不能重复消费一个商品&lt;/span&gt;&lt;/p&gt;


&lt;h4&gt;&lt;span&gt;1. 生产者线程无线生产，消费者线程无限消费的模式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1.1使用线程对象，一个生产者线程，一个消费者线程，一个商品存储位置&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

import java.util.Random;

/*使用线程对象，一个缓存位置，一个生产者，一个消费者，无限生产商品消费商品*/
public class ProducterComsumerDemo1 {
        
        /*定义一个商品缓存位置*/
        private volatile Goods goods;
        
        /*定义一个对象作为锁,不使用goods作为锁是因为生产者每次会产生一个新的对象*/
        private Object obj = new Object();
        
        
        /*isFull == true 生产者线程休息,消费者线程消费 
         *isFull == false 消费者线程休息，生产者线程生产*/
        private volatile boolean isFull = false;
        
        /*商品的id编号,生产者制造的每个商品的id都不一样,每生产一个id自增1*/
        private int id = 1;
        
        /*随机产生一个sleep时间*/
        private Random rnd = new Random();
        
        /*=================定义消费者线程==================*/
        public class ComsumeThread implements Runnable{
                @Override
                public void run(){
                        
                        try{
                                while(true){
                                        
                                        /*获取obj对象的锁, id 和 isFull 的操作都在同步代码块中*/
                                        synchronized(obj){
                                                
                                                if(!isFull){
                                                        /*wait方法使当前线程阻塞，并释放锁*/
                                                        obj.wait();
                                                }
                                                        
                                                /*随机延时一段时间*/
                                                Thread.sleep(rnd.nextInt(250));
                                                
                                                /*模拟消费商品*/
                                                System.out.println(goods);
                                                
                                                /*随机延时一段时间*/
                                                Thread.sleep(rnd.nextInt(250));
                                                
                                                isFull = false;
                                                
                                                /*唤醒阻塞obj上的生产者线程*/
                                                obj.notify();
                                                
                                        }
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                }
                        }catch (InterruptedException e){
                                /*什么都不做*/
                        }
                }
        }
        
/*=================定义生产者线程==================*/
        public class ProductThread implements Runnable{
                @Override
                public void run(){
                        
                        try {
                                while(true){
                                        
                                        synchronized(obj){
                                                
                                                if(isFull){
                                                        obj.wait();
                                                }
                                                        
                                                Thread.sleep(rnd.nextInt(500));
                                                
                                                /*如果id为偶数,生产价格为2的产品A
                                                 *如果id为奇数,生产价格为1的产品B*/
                                                if(id % 2 == 0){
                                                        goods = new Goods(&quot;A&quot;, 2, id);
                                                }else{
                                                        goods = new Goods(&quot;B&quot;, 1, id);
                                                }
                                                
                                                Thread.sleep(rnd.nextInt(250));
                                                
                                                id++;
                                                isFull = true;
                                                
                                                /*唤醒阻塞的消费者线程*/
                                                obj.notify();
                                        }
                                }
                        } catch (InterruptedException e) {
                                /*什么都不做*/
                        }
                        
                }
        }
        
        public static void main(String[] args) throws InterruptedException{
                
                ProducterComsumerDemo1 pcd = new ProducterComsumerDemo1();
                
                Runnable c = pcd.new ComsumeThread();
                Runnable p = pcd.new ProductThread();
                
                new Thread(p).start();
                new Thread(c).start();
        }
}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
name: B,   price:1,   id: 1
name: A,   price:2,   id: 2
name: B,   price:1,   id: 3
name: A,   price:2,   id: 4
name: B,   price:1,   id: 5
name: A,   price:2,   id: 6
name: B,   price:1,   id: 7
name: A,   price:2,   id: 8
name: B,   price:1,   id: 9
name: A,   price:2,   id: 10
name: B,   price:1,   id: 11
name: A,   price:2,   id: 12
name: B,   price:1,   id: 13
……
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;从结果看出，商品类型交替生产，每个商品的id都不相同，且不会漏过任何一个id，生产者没有重复生产，消费者没有重复消费，结果完全正确。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;1.2. 使用线程对象，多个生产者线程，多个消费者线程，1个缓存位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2.1一个经典的bug&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于多生产者，多消费者这个问题，看起来我们似乎不用修改代码，只需在main方法中多添加几个线程就好。假设我们需要三个消费者，一个生产者，那么我们只需要在main方法中再添加两个消费者线程。&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
   public static void main(String[] args) throws InterruptedException{
                
                ProducterComsumerDemo1 pcd = new ProducterComsumerDemo1();
                
                Runnable c = pcd.new ComsumeThread();
                Runnable p = pcd.new ProductThread();
                
                new Thread(c).start();

                new Thread(p).start();

                new Thread(c).start();
                new Thread(c).start();

        }

&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
name: B,   price:1,   id: 1
name: A,   price:2,   id: 2
name: A,   price:2,   id: 2
name: B,   price:1,   id: 3
name: B,   price:1,   id: 3
name: A,   price:2,   id: 4
name: A,   price:2,   id: 4
name: B,   price:1,   id: 5
name: B,   price:1,   id: 5
name: A,   price:2,   id: 6
……
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;从结果中，我们发现消费者重复消费了商品，所以这样做显然是错误的。这里我们定义多个消费者，一个生产者，所以遇到了重复消费的问题，如果定义成一个消费者，多个生产者就会遇到id覆盖的问题。如果我们定义多个消费者，多个生产者，那么即会遇到重复消费，也会遇到id覆盖的问题。&lt;strong&gt;注意，上面的代码使用的notifyAll唤醒方法，如果使用notify方法唤醒bug仍然可能发生&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我们来分析一下原因。当生产者生产好了商品，会唤醒因没有商品而阻塞消费者线程，假设唤醒的消费者线程超过两个，这两个线程会竞争获取锁，获取到锁的线程就会从obj.wait()方法中返回，然后消费商品，并把isFull置为false，然后释放锁。当被唤醒的另一个线程竞争获取到锁了以后也会从obj.wait()方法中返回。会再次消费同一个商品。显然，每一个被唤醒的线程应该再次检查isFull这个条件。&lt;strong&gt;所以无论是消费者，还是生产者，isFull的判断必须改成while循环&lt;/strong&gt;，这样才能得到正确的结果而不受生产者的线程数和消费者的线程数的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于只有一个生产者线程，一个消费者线程，用if判断是没有问题的，但是仍然强烈建议改成while语句进行判断。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.2.2&lt;/strong&gt;&lt;strong&gt;正确的姿势&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

import java.util.Random;

/*使用线程对象，一个缓存位置，一个生产者，一个消费者，无限生产商品,消费商品*/

public class ProducterComsumerDemo1 {
        
        /*定义一个商品缓存位置*/
        private volatile Goods goods;
        
        /*定义一个对象作为锁,不使用goods作为锁是因为生产者每次会产生一个新的对象*/
        private Object obj = new Object();
        
        
        /*isFull == true 生产者线程休息,消费者线程消费 
         *isFull == false 消费者线程消费，生产者线程生产*/
        private volatile boolean isFull = false;
        
        /*商品的id编号,生产者制造的每个商品的id都不一样,每生产一个id自增1*/
        private int id = 1;
        
        /*随机产生一个sleep时间*/
        private Random rnd = new Random();
        
        /*=================定义消费者线程==================*/
        public class ComsumeThread implements Runnable{
                @Override
                public void run(){
                        
                        try{
                                while(true){
                                        
                                        /*获取obj对象的锁, id 和 isFull 的操作都在同步代码块中*/
                                        synchronized(obj){
                                                
                                                while(!isFull){
                                                        /*wait方法使当前线程阻塞，并释放锁*/
                                                        obj.wait();
                                                }
                                                        
                                                /*随机延时一段时间*/
                                                Thread.sleep(rnd.nextInt(250));
                                                
                                                /*模拟消费商品*/
                                                System.out.println(goods);
                                                
                                                /*随机延时一段时间*/
                                                Thread.sleep(rnd.nextInt(250));
                                                
                                                isFull = false;
                                                
                                                /*唤醒阻塞obj上的生产者线程*/
                                                obj.notifyAll();
                                                
                                        }
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                }
                        }catch (InterruptedException e){
                                /*我就是任性，这里什么都不做*/
                        }
                }
        }
        
        /*=================定义生产者线程==================*/
        public class ProductThread implements Runnable{
                @Override
                public void run(){
                        
                        try {
                                while(true){
                                        
                                        synchronized(obj){
                                                
                                                while(isFull){
                                                        obj.wait();
                                                }
                                                        
                                                Thread.sleep(rnd.nextInt(500));
                                                
                                                /*如果id为偶数,生产价格为2的产品A
                                                     如果id为奇数,生产价格为1的产品B*/
                                                if(id % 2 == 0){
                                                        goods = new Goods(&quot;A&quot;, 2, id);
                                                }else{
                                                        goods = new Goods(&quot;B&quot;, 1, id);
                                                }
                                                
                                                Thread.sleep(rnd.nextInt(250));
                                                
                                                id++;
                                                isFull = true;
                                                
                                                /*唤醒阻塞的消费者线程*/
                                                obj.notifyAll();
                                        }
                                }
                        } catch (InterruptedException e) {
                                /*我就是任性，这里什么都不做*/
                        }
                        
                }
        }
        
        public static void main(String[] args) throws InterruptedException{
                
                ProducterComsumerDemo1 pcd = new ProducterComsumerDemo1();
                
                Runnable c = pcd.new ComsumeThread();
                Runnable p = pcd.new ProductThread();
                
                new Thread(c).start();

                new Thread(p).start();

                new Thread(c).start();
                new Thread(c).start();
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;1.3 使用线程对象,多个缓存位置(有界),多生产者，多消费者&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）当缓存位置满时，我们应该阻塞生产者线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）当缓存位置空时，我们应该阻塞消费者线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的代码我没有用java对象内置的锁，而是用了ReentrantLock对象。是因为普通对象的锁只有一个阻塞队列，如果使用notify方式，无法保证唤醒的就是特定类型的线程（消费者线程或生产者线程），而notifyAll方法会唤醒所有的线程，当剩余的缓存商品的数量小于生产者线程数量或已缓存商品的数量小于消费者线程时效率就比较低。所以这里我们通过ReentrantLock对象构造两个阻塞队列提高效率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3.1 普通方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

import java.util.LinkedList;
import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*使用线程对象,多个缓存位置(有界),多生产者,多消费者,无限循环模式*/

public class ProducterComsumerDemo2 {
        
        /*最大缓存商品数*/
        private final int MAX_SLOT = 2;
        
        /*定义缓存商品的容器*/
        private LinkedList&amp;lt;Goods&amp;gt; queue = new LinkedList&amp;lt;Goods&amp;gt;();
        
        /*定义线程锁和锁对应的阻塞队列*/
        private Lock lock = new ReentrantLock();
        private Condition full = lock.newCondition();
        private Condition empty = lock.newCondition();
        
        /*商品的id编号,生产者制造的每个商品的id都不一样,每生产一个id自增1*/
        private int id = 1;
        
        /*随机产生一个sleep时间*/
        private Random rnd = new Random();
        

        /*=================定义消费者线程==================*/
        public class ComsumeThread implements Runnable{
                @Override
                public void run(){

                        while(true){
                                
                                /*加锁,queue的出列操作都在同步代码块中*/
                                lock.lock();
                                try {
                                        while(queue.isEmpty()){
                                                System.out.println(&quot;queue is empty&quot;);
                                                empty.await();                  
                                        }
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        /*模拟消费商品*/
                                        Goods goods = queue.remove();
                                        System.out.println(goods);
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        /*唤醒阻塞的生产者线程*/
                                        full.signal();
                                        
                                } catch (InterruptedException e) {
                                        /*什么都不做*/
                                }finally{
                                        lock.unlock();
                                }
                                
                                /*释放锁后随机延时一段时间*/
                                try {
                                        Thread.sleep(rnd.nextInt(200));
                                } catch (InterruptedException e) {
                                        /*什么都不做*/
                                }
                        }
                }
        }
        
        /*=================定义生产者线程==================*/
        public class ProductThread implements Runnable{
                
                @Override
                public void run(){
                                
                        while(true){
                                /*加锁,queue的入列操作，id操作都在同步代码块中*/
                                lock.lock();
                                try{
                                        
                                        while(queue.size() == MAX_SLOT){
                                                System.out.println(&quot;queue is full&quot;);
                                                full.await();
                                        }
                                        
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        Goods goods = null;
                                        /*根据序号产生不同的商品*/
                                        switch(id%3){
                                                case 0 : goods = new Goods(&quot;A&quot;, 1, id);
                                                                 break;
                                                
                                                case 1 : goods = new Goods(&quot;B&quot;, 2, id);
                                                                 break;
                                                                 
                                                case 2 : goods = new Goods(&quot;C&quot;, 3, id);
                                                                 break;
                                        }
                                        
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        queue.add(goods);
                                        id++;

                                        /*唤醒阻塞的消费者线程*/
                                        empty.signal();
                                        
                                }catch(InterruptedException e){
                                        /*什么都不做*/
                                }finally{
                                        lock.unlock();
                                }
                                
                                /*释放锁后随机延时一段时间*/
                                try {
                                        Thread.sleep(rnd.nextInt(100));
                                } catch (InterruptedException e) {
                                        /*什么都不做*/
                                }
                        }
                }
        }
        
        /*=================main==================*/
        public static void main(String[] args) throws InterruptedException{
                
                ProducterComsumerDemo2 pcd = new ProducterComsumerDemo2();
                
                Runnable c = pcd.new ComsumeThread();
                Runnable p = pcd.new ProductThread();
                
                /*两个生产者线程，两个消费者线程*/
                new Thread(p).start();
                new Thread(p).start();
                
                new Thread(c).start();
                new Thread(c).start();
                
        }
}
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;运行结果&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
queue is empty
queue is empty
name: B,   price:2,   id: 1
name: C,   price:3,   id: 2
name: A,   price:1,   id: 3
queue is full
name: B,   price:2,   id: 4
name: C,   price:3,   id: 5
queue is full
name: A,   price:1,   id: 6
name: B,   price:2,   id: 7
name: C,   price:3,   id: 8
name: A,   price:1,   id: 9
name: B,   price:2,   id: 10
name: C,   price:3,   id: 11
name: A,   price:1,   id: 12
name: B,   price:2,   id: 13
name: C,   price:3,   id: 14
……
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3.2 更优雅的实现方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面使用线程池（ThreadPool）和阻塞队列（LinkedBlockingQueue）原子类（AtomicInteger）以更加优雅的方式实现上述功能。&lt;strong&gt;LinkedBlockingQueue阻塞队列仅在take和put方法上锁，所以id必须定义为原子类。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

/*使用线程对象,多个缓存位置(有界),多生产者,多消费者,无限循环模式*/

public class ProducterComsumerDemo4 {
        
        /*最大缓存商品数*/
        private final int MAX_SLOT = 3;
        
        /*定义缓存商品的容器*/
        private LinkedBlockingQueue&amp;lt;Goods&amp;gt; queue = new LinkedBlockingQueue&amp;lt;Goods&amp;gt;(MAX_SLOT);
        
        /*商品的id编号,生产者制造的每个商品的id都不一样,每生产一个id自增1*/
        private AtomicInteger id = new AtomicInteger(1);
        
        /*随机产生一个sleep时间*/
        private Random rnd = new Random();
        
        /*=================定义消费者线程==================*/
        public class ComsumeThread implements Runnable{
                @Override
                public void run(){

                        while(true){
                                
                                try {
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        /*模拟消费商品*/
                                        Goods goods = queue.take();
                                        System.out.println(goods);
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                } catch (InterruptedException e) {
                                        /*什么都不做*/
                                }
                        }
                }
        }
        
        /*=================定义生产者线程==================*/
        public class ProductThread implements Runnable{
                @Override
                public void run(){
                                
                        while(true){
                                
                                try{
                                        
                                        int x = id.getAndIncrement();
                                        Goods goods = null;
                                        
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        /*根据序号产生不同的商品*/
                                        switch(x%3){
                                                case 0 : goods = new Goods(&quot;A&quot;, 1, x);
                                                                 break;
                                                
                                                case 1 : goods = new Goods(&quot;B&quot;, 2, x);
                                                                 break;
                                                                 
                                                case 2 : goods = new Goods(&quot;C&quot;, 3, x);
                                                                 break;
                                        }
                                        
                                        Thread.sleep(rnd.nextInt(200));
                                        
                                        queue.put(goods);

                                        Thread.sleep(rnd.nextInt(100));
                                        
                                }catch(InterruptedException e){
                                        /*什么都不做*/
                                }
                        }
                }
        }
        
        /*=================main==================*/
        public static void main(String[] args) throws InterruptedException{
                
                ProducterComsumerDemo4 pcd = new ProducterComsumerDemo4();
                
                Runnable c = pcd.new ComsumeThread();
                Runnable p = pcd.new ProductThread();
                
                /*定义线程池*/
                ExecutorService es = Executors.newCachedThreadPool();
                
                /*三个生产者线程，两个消费者线程*/
                es.execute(p);
                es.execute(p);
                es.execute(p);
                
                es.execute(c);
                es.execute(c);
                
                es.shutdown();
        }
}

&lt;/pre&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;2. 有限商品个数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这个问题显然比上面的问题要复杂不少，原因在于要保证缓存区的商品要全部消费掉，没有重复消费商品，没有覆盖商品，同时还要保证所有线程能够正常结束，防止存在一直阻塞的线程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;2.1 使用线程对象,多个缓存位置(有界),多生产者，多消费者&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路 定义一下三个变量&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
/*需要生产的总商品数*/
        private final int TOTAL_NUM = 30;
        
        /*已产生的数量*/
        private volatile int productNum = 0;
        
        /*已消耗的商品数*/
        private volatile int comsumedNum = 0;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;每生产一个商品 productNum 自增1，直到TOTAL_NUM为止，如果不满足条件 productNum &amp;lt; TOTAL_NUM 则结束进程，自增操作必须在full.await()方法调用之前，防止生产者线程无法唤醒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，每消费一个商品 comsumedNum 自增1，直到TOTAL_NUM为止，如果不满足条件 comsumedNum &amp;lt; TOTAL_NUM 则结束进程，自增操作必须在empty.await()方法调用之前，防止消费者线程无法唤醒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;comsumedNum和&lt;span&gt;productNum相当于计划经济时代的粮票一样，有了它能够保证生产者线程在唤醒后一定需要生产一个商品，消费者线程在唤醒以后一定能够消费一个商品&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

import java.util.LinkedList;
import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/*使用线程对象,多个缓存位置(有界),多生产者，多消费者, 有限商品个数*/

public class ProducterComsumerDemo3 {
        
        /*需要生产的总商品数*/
        private final int TOTAL_NUM = 30;
        
        /*已产生的数量*/
        private volatile int productNum = 0;
        
        /*已消耗的商品数*/
        private volatile int comsumedNum = 0;
        
        /*最大缓存商品数*/
        private final int MAX_SLOT = 2;
        
        /*定义线程公用的锁和条件*/
        private Lock lock = new ReentrantLock();
        private Condition full = lock.newCondition();
        private Condition empty = lock.newCondition();
        
        
        /*定义缓存商品的容器*/
        private LinkedList&amp;lt;Goods&amp;gt; queue = new LinkedList&amp;lt;Goods&amp;gt;();
        
        /*商品的id编号,生产者制造的每个商品的id都不一样,每生产一个id自增1*/
        private int id = 1;
        
        /*随机产生一个sleep时间*/
        private Random rnd = new Random();
        
        
        /*=================定义消费者线程==================*/
        public class ComsumeThread implements Runnable{
                @Override
                public void run(){
                                
                        while(true){
                                /*加锁, id、comsumedNum 操作都在同步代码块中*/
                                lock.lock();
                                try {
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                        if(comsumedNum &amp;lt; TOTAL_NUM){
                                                comsumedNum++;
                                        }else{
                                                /*这里会自动执行finally的语句，释放锁*/
                                                break;
                                        }
                                        
                                        while(queue.isEmpty()){
                                                System.out.println(&quot;queue is empty&quot;);
                                                empty.await();
                                        }
                                                
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                        /*模拟消费商品*/
                                        Goods goods = queue.remove();
                                        System.out.println(goods);
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                        /*唤醒阻塞的生产者线程*/
                                        full.signal();
                                        
                                } catch (InterruptedException e) {

                                }finally{
                                        lock.unlock();
                                }
                                
                                /*释放锁后，随机延时一段时间*/
                                try {
                                        Thread.sleep(rnd.nextInt(250));
                                } catch (InterruptedException e) {

                                }
                        }
                        
                        System.out.println(
                                        &quot;customer &quot; 
                                        + Thread.currentThread().getName()
                                        + &quot; is over&quot;);
                }
        }
        
        
        /*=================定义生产者线程==================*/
        public class ProductThread implements Runnable{
                
                @Override
                public void run(){
                        
                        while(true){
                                
                                lock.lock();
                                try{
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                        if(productNum &amp;lt; TOTAL_NUM){
                                                productNum++;
                                        }else{
                                                /*这里会自动执行finally的语句，释放锁*/
                                                break;
                                        }
                                        
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                        while(queue.size() == MAX_SLOT){
                                                System.out.println(&quot;queue is full&quot;);
                                                full.await();
                                        }
                                                
                                        Thread.sleep(rnd.nextInt(250));
                                        
                                        Goods goods = null;
                                        /*根据序号产生不同的商品*/
                                        switch(id%3){
                                                case 0 : goods = new Goods(&quot;A&quot;, 1, id);
                                                                 break;
                                                
                                                case 1 : goods = new Goods(&quot;B&quot;, 2, id);
                                                                 break;
                                                                 
                                                case 2 : goods = new Goods(&quot;C&quot;, 3, id);
                                                                 break;
                                        }
                                        
                                        queue.add(goods);
                                        id++;
                                        
                                        /*唤醒阻塞的消费者线程*/
                                        empty.signal();
                                        
                                }catch(InterruptedException e){

                                }finally{
                                        lock.unlock();
                                }
                                
                                /*释放锁后，随机延时一段时间*/
                                try {
                                        Thread.sleep(rnd.nextInt(250));
                                } catch (InterruptedException e) {
                                        /*什么都不做*/
                                }
                        }
                        
                        System.out.println(
                                        &quot;producter &quot; 
                                        + Thread.currentThread().getName()
                                        + &quot; is over&quot;);
                }
        }
        
        /*=================main==================*/
        public static void main(String[] args) throws InterruptedException{
                
                ProducterComsumerDemo3 pcd = new ProducterComsumerDemo3();
                
                ComsumeThread c = pcd.new ComsumeThread();
                ProductThread p = pcd.new ProductThread();
                
                new Thread(p).start();
                new Thread(p).start();
                new Thread(p).start();
                
                new Thread(c).start();
                new Thread(c).start();
                new Thread(c).start();
                
                System.out.println(&quot;main Thread is over&quot;);
        }
}
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;2.2利用线程池，原子类，阻塞队列，以更优雅的方式实现&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;LinkedBlockingQueue阻塞队列仅在take和put方法上锁，&lt;strong&gt;所以productNum和comsumedNum必须定义为原子类。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: java; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
package demo;

import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

/*使用线程池,多个缓存位置(有界),多生产者，多消费者, 有限商品个数*/
public class LinkedBlockingQueueDemo {
        
        /*需要生产的总商品数*/
        private final int TOTAL_NUM = 20;
        
        /*已产生商品的数量*/
        volatile AtomicInteger productNum = new AtomicInteger(0);
        
        /*已消耗的商品数*/
        volatile AtomicInteger comsumedNum = new AtomicInteger(0);
        
        /*最大缓存商品数*/
        private final int MAX_SLOT = 5;
        
        /*同步阻塞队列，队列容量为MAX_SLOT*/
        private LinkedBlockingQueue&amp;lt;Goods&amp;gt; lbq = new LinkedBlockingQueue&amp;lt;Goods&amp;gt;(MAX_SLOT);
        
        /*随机数*/
        private Random rnd = new Random();
        
        /*pn表示产品的编号，产品编号从1开始*/
        private volatile AtomicInteger pn = new AtomicInteger(1);
        
        
        /*=================定义消费者线程==================*/
        public class CustomerThread implements Runnable{
                
                @Override
                public void run(){
                        
                        while(comsumedNum.getAndIncrement() &amp;lt; TOTAL_NUM){
                                
                                try{
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(500));
                                        
                                        /*从队列中取出商品，队列空时发生阻塞*/
                                        Goods goods = lbq.take();
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(500));
                                        
                                        /*模拟消耗商品*/
                                        System.out.println(goods);
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(500));
                                        
                                }catch(InterruptedException e){

                                }       
                        }
                        
                        System.out.println(
                                        &quot;customer &quot; 
                                        + Thread.currentThread().getName()
                                        + &quot; is over&quot;);
                }
        }
        
        /*=================定义生产者线程==================*/
        public class ProducerThread implements Runnable{
                
                @Override
                public void run(){
                        
                        while(productNum.getAndIncrement() &amp;lt; TOTAL_NUM){
                                try {
                                        int x = pn.getAndIncrement();
                                        
                                        Goods goods = null;
                                        /*根据序号产生不同的商品*/
                                        switch(x%3){
                                                case 0 : goods = new Goods(&quot;A&quot;, 1, x);
                                                                 break;
                                                
                                                case 1 : goods = new Goods(&quot;B&quot;, 2, x);
                                                                 break;
                                                                 
                                                case 2 : goods = new Goods(&quot;C&quot;, 3, x);
                                                                 break;
                                        }
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(500));

                                        /*产生的新产品入列,队列满时发生阻塞*/
                                        lbq.put(goods);
                                        
                                        /*随机延时一段时间*/
                                        Thread.sleep(rnd.nextInt(500));
                                
                                } catch (InterruptedException e1) {
                                        /*什么都不做*/
                                }
                        }
                        
                        System.out.println(
                                        &quot;producter &quot; 
                                        + Thread.currentThread().getName()
                                        + &quot; is over &quot;);
                }
        }
        
        /*=================main==================*/
        public static void main(String[] args){
                
                LinkedBlockingQueueDemo lbqd = new LinkedBlockingQueueDemo();
                
                Runnable c = lbqd.new CustomerThread();
                Runnable p = lbqd.new ProducerThread();
                
                ExecutorService es = Executors.newCachedThreadPool();

                es.execute(c);
                es.execute(c);
                es.execute(c);
                
                es.execute(p);
                es.execute(p);
                es.execute(p);
                
                es.shutdown();
                System.out.println(&quot;main Thread is over&quot;);
        }
}
&lt;/pre&gt;</description>
<pubDate>Tue, 07 Nov 2017 04:51:00 +0000</pubDate>
<dc:creator>nullzx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullzx/p/7798504.html</dc:identifier>
</item>
<item>
<title>模拟制作网易云音乐(AudioContext) - _糊一笑</title>
<link>http://www.cnblogs.com/rynxiao/p/7798419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rynxiao/p/7798419.html</guid>
<description>&lt;p&gt;记得好早前在慕课网上看到一款&lt;a href=&quot;http://www.imooc.com/learn/299&quot;&gt;可视化音乐播放器&lt;/a&gt;，当前是觉得很是神奇，还能这么玩。由于当时刚刚转行不久，好多东西看得稀里糊涂不明白，于是趁着现在有时间又重新梳理了一遍，然后参照官网的API模拟做了一款网易播放器。没有什么创新的点，只是想到了就想做一下而已。&lt;/p&gt;
&lt;p&gt;效果可以看这里：&lt;a href=&quot;http://music.poemghost.com/&quot; class=&quot;uri&quot;&gt;http://music.poemghost.com/&lt;/a&gt;，如果看不了，说明博主的服务器已经不在工作啦。&lt;strong&gt;（建议使用电脑浏览器打开，同时切换到手机模式来打开，因为在手机上测试时有问题，而且有很大性能损耗，经常会导致浏览器奔溃）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码在这里：&lt;a href=&quot;https://github.com/Rynxiao/wangyi_music&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;效果图一览：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/681618/201711/681618-20171107120811466-2120192710.gif&quot; alt=&quot;xiaoguo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看着自己洋洋洒洒写了快1000多行的&lt;code&gt;js&lt;/code&gt;，我现在心里也是一万屁草泥马飘过。当然其中还有很多代码没有经过提炼，很多变量可以公用，用对象化的方式来说写这个会更有条理，这个博主以后有时间再梳理一遍。下面来讲讲主要的实现过程。&lt;/p&gt;
&lt;h2 id=&quot;一整体思路&quot;&gt;一、整体思路&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;API&lt;/code&gt;可以到&lt;a href=&quot;https://webaudio.github.io/web-audio-api/#dom-audiobuffersourcenode&quot; class=&quot;uri&quot;&gt;https://webaudio.github.io/web-audio-api/#dom-audiobuffersourcenode&lt;/a&gt;上面去看，只是一个草案，并没有纳入标准，所以有些地方还是有问题，在下面我会说到我遇到了什么问题。但是这个草案上的东西其实可以做出很多其他的效果。比如多音频源来达到混音效果、音频振荡器效果等等...&lt;/p&gt;
&lt;p&gt;整体的思路图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/681618/201711/681618-20171107120911856-722744871.png&quot; alt=&quot;silu&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大致上来说就是通过&lt;code&gt;window&lt;/code&gt;上的&lt;code&gt;AudioContext&lt;/code&gt;方法来创建一个音频对象，然后连接上数据，分析器和音量控制。最后通过&lt;code&gt;BufferSourceNode&lt;/code&gt;的&lt;code&gt;start&lt;/code&gt;方法来启动音频。&lt;/p&gt;
&lt;h2 id=&quot;二具体分析&quot;&gt;二、具体分析&lt;/h2&gt;
&lt;h3 id=&quot;路由&quot;&gt;2.1 路由&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;routes/index.js&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;router&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(req&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; next) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readdir&lt;/span&gt;(media&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; names) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; first &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; names[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;// 如果第一个文件不是mp3文件，说明是MAC系统&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;indexOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'mp3'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            first &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; names[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            names &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;names&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;slice&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; song &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;' - '&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].&lt;span class=&quot;at&quot;&gt;replace&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'.mp3'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; singer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;' - '&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (err) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;render&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'index'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
                &lt;span class=&quot;dt&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'网易云音乐'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
                &lt;span class=&quot;dt&quot;&gt;music&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; names&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
                &lt;span class=&quot;dt&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; listPosts&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;song&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; song&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;singer&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; singer&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; listPosts[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] 
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里&lt;code&gt;mac&lt;/code&gt;平台和&lt;code&gt;windows&lt;/code&gt;不同，&lt;code&gt;mac&lt;/code&gt;文件夹会有一个&lt;code&gt;.DS_Store&lt;/code&gt;文件，因此作了一点小处理。&lt;/p&gt;
&lt;p&gt;另外由于用的海外服务器，所以请求&lt;code&gt;mp3&lt;/code&gt;资源的时候会有很长时间，因此我把音频资源放在了七牛云，而不是从本地获取，但是数据还是在本地拿，因为并没有用到数据库。&lt;/p&gt;
&lt;h3 id=&quot;主页面&quot;&gt;2.2 主页面&lt;/h3&gt;
&lt;p&gt;页面运用了手淘的&lt;code&gt;flexible&lt;/code&gt;，因此在最开始切换到手机模式的时候，可能需要刷新一下浏览器才能显示正常。样式采用的是预处理&lt;code&gt;sass&lt;/code&gt;，感兴趣的可以去看一下&lt;a href=&quot;https://github.com/Rynxiao/wangyi_music&quot;&gt;代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建音频&quot;&gt;2.3 创建音频&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 创建音频&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;AudioBuffer&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; buffer AudioBuffer对象&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; void&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;createAudio&lt;/span&gt;(buffer) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果音频是关闭状态，则重新新建一个全局音频上下文&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'closed'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        ac &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;AudioContext&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;webkitAudioContext&lt;/span&gt;)()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    audioBuffer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; buffer&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onstatechange&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; onStateChange&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 创建BufferSrouceNode&lt;/span&gt;
    bufferSource &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createBufferSource&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; buffer&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 创建音量节点&lt;/span&gt;
    gainNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createGain&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;gainNode&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;gain&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; gainValue&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 创建分析节点&lt;/span&gt;
    analyser &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createAnalyser&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fftSize&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fftSize&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onended&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; onPlayEnded&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;// 嵌套连接&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(analyser)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(gainNode)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;gainNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;destination&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合上面的图，这里创建音频的代码就比较好理解了。&lt;/p&gt;
&lt;h3 id=&quot;播放&quot;&gt;2.4 播放&lt;/h3&gt;
&lt;p&gt;播放其实是一个非常简单的&lt;code&gt;API&lt;/code&gt;，直接调用&lt;code&gt;BufferSourceNode&lt;/code&gt;的&lt;code&gt;start&lt;/code&gt;方法即可，&lt;code&gt;start&lt;/code&gt;方法有两个我们会用到的参数，第一个是开始时间，第二个是时间位移，决定了我们从什么时候开始，这将在跳播的时候会用到。&lt;/p&gt;
&lt;p&gt;另外有一个注意的点是，不能再同一个&lt;code&gt;BufferSourceNode&lt;/code&gt;上调用两次&lt;code&gt;start&lt;/code&gt;方法，否则会报错。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;bufferSource &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;获取频谱图数据&quot;&gt;2.5 获取频谱图数据&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 获取音频解析数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; void&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;getByteFrequencyData&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Uint8Array&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;frequencyBinCount&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getByteFrequencyData&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;renderCanvas&lt;/span&gt;(arr)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    renderInter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;requestAnimationFrame&lt;/span&gt;(getByteFrequencyData)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过不断触发这个函数，将最新的数据填充到一个8位的无符号数组中，进而开始渲染数据。此时的音频范围默认设置为256。&lt;/p&gt;
&lt;h3 id=&quot;音量调节&quot;&gt;2.6 音量调节&lt;/h3&gt;
&lt;p&gt;音量调节也有现成的&lt;code&gt;API&lt;/code&gt;，这点也没什么可讲的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// gain 的值默认为1&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 因此这里如果想做继续音量放大的可以大于1&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 但是太大可能会出现破音效果，大家感兴趣可以试试&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;gainNode&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;gain&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;~&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;暂停与恢复播放&quot;&gt;2.7 暂停与恢复播放&lt;/h3&gt;
&lt;p&gt;我在&lt;code&gt;AudioBufferSourceNode&lt;/code&gt;上找了好久，本来以为有&lt;code&gt;start/stop&lt;/code&gt;方法，那么就会有类似于&lt;code&gt;puase&lt;/code&gt;方法之类的，但是遗憾的是，确实没有。最开始我也不知道怎么做播放和暂停，但是好在天无绝人之路，意外发现在全局的&lt;code&gt;AudioContext&lt;/code&gt;上有两个方法&lt;code&gt;resume/suspend&lt;/code&gt;，这也是实现播放和暂停的两个方法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 恢复播放&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; null&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;resumeAudio&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    playState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;PLAY_STATE&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 放下磁头&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;downPin&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 在当前AudioContext被挂起的状态下，才能使用resume进行重新激活&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resume&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 重新恢复可视化&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;resumeRenderCanvas&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 重启定时器&lt;/span&gt;
    startInter &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;clearInterval&lt;/span&gt;(startInter)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    startInter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setInterval&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;renderTime&lt;/span&gt;(start&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;executeTime&lt;/span&gt;(startSecond))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;updateProgress&lt;/span&gt;(startSecond&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; totalTime)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        startSecond&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 暂停播放&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; null&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;suspendAudio&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    playState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;PLAY_STATE&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;SUSPENDED&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 停止可视化&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;stopRenderCanvas&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 收起磁头&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;upPin&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    startInter &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;clearInterval&lt;/span&gt;(startInter)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 挂起当前播放&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;suspend&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;跳动播放&quot;&gt;2.8 跳动播放&lt;/h3&gt;
&lt;p&gt;跳动播放需要用到开始时间，这里我默认设置为0，接下来就是时间位移了。通过跳动播放进度条的游标，我们不难计算出我们应该播放的时间。&lt;/p&gt;
&lt;p&gt;这里有一个问题，我之前也说到过，就是在同一个&lt;code&gt;AudioBufferSourceNode&lt;/code&gt;上不能同时&lt;code&gt;start&lt;/code&gt;两次，那么也就是说，我如果这里再直接调用&lt;code&gt;start(0, offsetTime)&lt;/code&gt;将会报错，是的，这里我也卡了好久，最后再一个论坛(是哪个我倒是忘记了)上给了一个建议，不能同时在一个&lt;code&gt;AudioBufferSourceNode&lt;/code&gt;上&lt;code&gt;start&lt;/code&gt;两次，那就在不同的&lt;code&gt;AudioBufferSourceNode&lt;/code&gt;上&lt;code&gt;start&lt;/code&gt;，也就意味着我可以新建一个节点，然后依然用之前&lt;code&gt;ajax&lt;/code&gt;请求到的数据来创建一个新的音频数据。实验是可以行的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 跳动播放&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; time 跳跃时间秒数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; void&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;skipAudio&lt;/span&gt;(time) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 先释放之前的AudioBufferSourceNode对象&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 然后再重新连接&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 因为不允许在一个Node上start两次&lt;/span&gt;
    analyser &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;disconnect&lt;/span&gt;(gainNode)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    gainNode &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;gainNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;disconnect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;destination&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    bufferSource &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createBufferSource&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; audioBuffer&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 创建音频节点&lt;/span&gt;
    gainNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createGain&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;gainNode&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;gain&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; gainValue&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 创建分析节点&lt;/span&gt;
    analyser &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createAnalyser&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fftSize&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fftSize&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(analyser)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;analyser&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(gainNode)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;gainNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;connect&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;destination&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onended&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; onPlayEnded&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;bufferSource&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;start&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; time)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    playState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;PLAY_STATE&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;RUNNING&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;changeSuspendBtn&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 开始分析&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;getByteFrequencyData&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 填充当前播放的时间&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;renderTime&lt;/span&gt;(start&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;executeTime&lt;/span&gt;(time))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    startSecond &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 放下磁头&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;downPin&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 重新开始计时&lt;/span&gt;
    startInter &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;clearInterval&lt;/span&gt;(startInter)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    startSecond&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
    startInter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;setInterval&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;renderTime&lt;/span&gt;(start&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;executeTime&lt;/span&gt;(startSecond))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;updateProgress&lt;/span&gt;(startSecond&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; totalTime)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        startSecond&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;列表循环&quot;&gt;2.9 列表循环&lt;/h3&gt;
&lt;p&gt;列表循环用到了&lt;code&gt;bufferSource&lt;/code&gt;上的一个回调方法&lt;code&gt;onended&lt;/code&gt;，在播放完成之后就自动执行下一曲。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 播放完成后的回调&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; null&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;onPlayEnded&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; acState &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ac&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 在进行上一曲和下一曲或者跳跃播放的时候&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 如果调用stop方法，会进入当前回调，因此要作区分&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 上一曲和下一曲的时候，由于是新的资源，因此采用关闭当前的AduioContext, load的时候重新生成&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 这样acState的状态就是suspended，这样就不会出现播放错位&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 而在跳跃播放的时候，由于是同一个资源，因此加上skip标志就可以判断出来&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 发现如果是循环播放，onPlayEnded方法不会被执行，因此采用加载相同索引的方式&lt;/span&gt;

    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (acState &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'running'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;skip) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; index &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;getNextPlayIndex&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;loadMusic&lt;/span&gt;(playItems[index]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个坑就是当我点击了上一曲和下一曲的时候，发现也会执行这个回调，因此点击下一曲的时候，实际上播放的是下两曲的歌曲。因此这里做了区分，当点击上一曲和下一曲的时候，会给&lt;code&gt;skip&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;，这样就不会执行这个方法中默认的行为。&lt;/p&gt;
&lt;h2 id=&quot;三手机端会有的问题&quot;&gt;三、手机端会有的问题&lt;/h2&gt;
&lt;p&gt;之前说过，建议不要在手机端运行，因为会有一些问题，主要表现在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AudioContext&lt;/code&gt;需要兼容，我在&lt;code&gt;Chrome&lt;/code&gt;和&lt;code&gt;Safari&lt;/code&gt;测试的时候一直得不到音频数据，之后才发现需要兼容写法，不然页面播放不了。兼容写法为：&lt;code&gt;webkitAudioContext&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最开始加载音频的时候，&lt;code&gt;AudioContext&lt;/code&gt;默认的状态是&lt;code&gt;suspended&lt;/code&gt;，这也是我最开始最纳闷的事，当我点击播放按钮的时候没有声音，而点击跳播的时候会播放声音，后来调试发现走到了&lt;code&gt;resumeAudio&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;性能还是有一定的问题，在手机上播放的时候，经常会出现卡死的现象。渲染柱状条的时候感到有明显的卡顿。、&lt;/li&gt;
&lt;li&gt;由于手机浏览器上页面高度还包括地址栏、导航条高度，因此，唱片可能会超出范围&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;我就是发现了一个好玩的东西，然后发了兴致好好玩了一下，之前照着别人的代码敲了一遍代码，后来发现什么都忘了，不如自己动手来得牢靠。有些东西一时看不懂，不要死磕，那是因为水平不够，不过记住就好，慢慢学习，然后再来攻克它，以此共勉。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Nov 2017 04:13:00 +0000</pubDate>
<dc:creator>_糊一笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rynxiao/p/7798419.html</dc:identifier>
</item>
<item>
<title>【Win 10 应用开发】UI Composition 札记（三）：与 XAML 集成 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/7798041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/7798041.html</guid>
<description>&lt;p&gt;除了 DirectX 游戏开发，我们一般很少单独使用 UI Composition ，因此，与 XAML 互动并集成是必然结果。这样能够把两者的优势混合使用，让UI布局能够更灵活。&lt;/p&gt;
&lt;p&gt;说到与 XAML 的集成，则我们必须先认识一位伙计，他非常重要，位于 Windows.UI.Xaml.Hosting 命名空间下，名叫 ElementCompositionPreview ，有了它，我们才可以在 XAML 元素与 Composition UI 元素之间游走。来看看它都公开了哪些成员。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElementCompositionPreview : IElementCompositionPreview
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetImplicitShowAnimation(UIElement element, ICompositionAnimationBase animation);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetImplicitHideAnimation(UIElement element, ICompositionAnimationBase animation);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetIsTranslationEnabled(UIElement element, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; value);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; CompositionPropertySet GetPointerPositionPropertySet(UIElement targetElement);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Visual GetElementVisual(UIElement element);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Visual GetElementChildVisual(UIElement element);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetElementChildVisual(UIElement element, Visual visual);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; CompositionPropertySet GetScrollViewerManipulationPropertySet(ScrollViewer scrollViewer);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类公开的方法都是静态的，无需实例调用。我们不要急于弄懂每个方法的作用，这样会把自己带入死胡同。此处，我们先重点掌握以下几个方法的用法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、GetElementVisual：要使 XAML 元素与 Composition API 交互，这个方法特别要紧，通过调用它，我们可以得到 XAML 元素中的 Composition UI 树的表示元素，并且能获取到关联的 Compositor 对象，有了关联的 Compositor实例，我们才能创建各种 UI 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、SetElementChildVisual：当我们使用 Composition API 创建完自定义的 UI 元素后，要调用这个方法把它插入到 XAML 对象的可视化树中。注意，UI 元素总是被插入到可视化树的最后一个位置，因此，我们自己组装的元素总是会挡住原来的 XAML 元素的。这个你得注意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、GetElementChildVisual：只有你调用过 SetElementChildVisual 方法把自定义 Visual 元素加入过可视化树，才能调用这个方法，这个方法就是返回你上一次插入的元素。如果你没有插入过自定义的可视化元素，则该方法会返回 null。注意，不要把这个方法跟 GetElementVisual 方法混淆，两者不同。GetElementVisual 方法是获得与目标 XAML 对象关联的可视化对象，而 GetElementChildVisual 方法是获取你上一次插入到可视化树的自定义元素。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下面给大伙看一个例子。&lt;/p&gt;
&lt;p&gt;在页面上，我放了一个 Border 对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{ThemeResource ApplicationPageBackgroundThemeBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;bd&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Black&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便把它的背景设置为黑色，方便后面看电影。&lt;/p&gt;

&lt;p&gt;切换到代码文件，现在我们自定义组装一下UI，然后插入到 Border 元素的子树中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainPage()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.InitializeComponent();
            &lt;em&gt;&lt;strong&gt;CompositMyVisual();
&lt;/strong&gt;&lt;/em&gt;        }


        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CompositMyVisual()
        {
            Visual visualForbd &lt;/span&gt;=&lt;span&gt;&lt;em&gt;&lt;strong&gt; ElementCompositionPreview.GetElementVisual(bd)&lt;/strong&gt;&lt;/em&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组建UI&lt;/span&gt;
            Compositor compos =&lt;span&gt; visualForbd.Compositor;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根元素&lt;/span&gt;
            ContainerVisual rootvs =&lt;span&gt; compos.CreateContainerVisual();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个可视化元素&lt;/span&gt;
            SpriteVisual v1 =&lt;span&gt; compos.CreateSpriteVisual();
            v1.Brush &lt;/span&gt;=&lt;span&gt; compos.CreateColorBrush(Colors.Green);
            v1.Size &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Vector2(450f, 300f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;大小&lt;/span&gt;
            v1.Offset = &lt;span&gt;new&lt;/span&gt; Vector3(30f, 20f, -1f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;位移&lt;/span&gt;
&lt;em&gt;&lt;strong&gt;&lt;span&gt;            rootvs.Children.InsertAtTop(v1);
            &lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个可视化元素&lt;/span&gt;
            SpriteVisual v2 =&lt;span&gt; compos.CreateSpriteVisual();
            v2.Brush &lt;/span&gt;=&lt;span&gt; compos.CreateColorBrush(Colors.SkyBlue);
            v2.Size &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vector2(400f, 400f);
            v2.Offset &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vector3(180f, 125f, 0f);
            &lt;em&gt;&lt;strong&gt;rootvs.Children.InsertAtTop(v2);

            &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这一句很重要&lt;/span&gt;
&lt;span&gt;&lt;em&gt;&lt;strong&gt;            ElementCompositionPreview.SetElementChildVisual(bd, rootvs);&lt;/strong&gt;&lt;/em&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得，在组装完UI元素后，要调用 ElementCompositionPreview.SetElementChildVisual方法，把自定义的元素插入到可视化树中。&lt;/p&gt;
&lt;p&gt;在前面的博文中，老周介绍过，ContainerVisual 是个容器元素，它公开一个 Children 集合，我们可以向其中添加子元素，这里头有四个方法我们可以调用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、InsertAtTop ：子元素会始终位于其他元素的顶部，所以这个元素会遮挡住其他元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、InsertAtBottom：所添加的子元素始终在显示层的底部，它会被其他元素遮挡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、InsertAbove：把当前子元素放到某个元素之上。比如我们可以明确指定让当前元素位于 A 元素之上，这使得当前元素可能遮挡住 A 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、InsertBelow：把当前元素放到某个元素的下方。如果当前元素放在 A 元素下面，那么，该元素可能被 A 元素遮挡。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们看看这个例子的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201711/367389-20171107110139950-565003752.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在上面的代码中，第一个元素是绿色画刷填充的，第二个是天蓝色的，而我们在插入元素树时，都把它们放到所有元素的顶部。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    rootvs.Children.InsertAtTop(v1);
    rootvs.Children.InsertAtTop(v2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;都位于顶部，那么后加上去的元素就会挡住前面的元素，所以我们看到，天蓝色的那块区域挡住了绿色区域的一部分。&lt;/p&gt;

&lt;p&gt;使用这种交互，我们还可以很轻松地对 XAML 元素进行三维旋转。&lt;/p&gt;
&lt;p&gt;这个例子的界面分为两部分。左边咱们放三个滑块，分别调节 XAML 对象在 X、Y、Z 轴上的旋转角度，范围在 -90 到 90 之间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Slider &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sldX&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;X 轴&quot;&lt;/span&gt;&lt;span&gt; Maximum&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; Minimum&lt;/span&gt;&lt;span&gt;=&quot;-90&quot;&lt;/span&gt;&lt;span&gt; SmallChange&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; StepFrequency&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; ValueChanged&lt;/span&gt;&lt;span&gt;=&quot;OnSliderValChanged&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Slider &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sldY&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;Y 轴&quot;&lt;/span&gt;&lt;span&gt; Maximum&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; Minimum&lt;/span&gt;&lt;span&gt;=&quot;-90&quot;&lt;/span&gt;&lt;span&gt; SmallChange&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; StepFrequency&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; ValueChanged&lt;/span&gt;&lt;span&gt;=&quot;OnSliderValChanged&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Slider &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sldZ&quot;&lt;/span&gt;&lt;span&gt; Header&lt;/span&gt;&lt;span&gt;=&quot;Z 轴&quot;&lt;/span&gt;&lt;span&gt; Maximum&lt;/span&gt;&lt;span&gt;=&quot;90&quot;&lt;/span&gt;&lt;span&gt; Minimum&lt;/span&gt;&lt;span&gt;=&quot;-90&quot;&lt;/span&gt;&lt;span&gt; SmallChange&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; StepFrequency&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; ValueChanged&lt;/span&gt;&lt;span&gt;=&quot;OnSliderValChanged&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;界面的右边是一个矩形。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Rectangle &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; Fill&lt;/span&gt;&lt;span&gt;=&quot;Brown&quot;&lt;/span&gt;&lt;span&gt; Name&lt;/span&gt;&lt;span&gt;=&quot;rect&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们就是要让这个矩形进行三维旋转。&lt;/p&gt;
&lt;p&gt;定义一个方法，从以上三个 Slider 控件中获得实时的值，然后改变矩形的三维方向（在三个轴上的旋转角度）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetUI()
        {
            Visual v &lt;/span&gt;=&lt;span&gt; ElementCompositionPreview.GetElementVisual(rect);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置方向&lt;/span&gt;
            &lt;span&gt;float&lt;/span&gt; x = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)sldX.Value;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; y = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)sldY.Value;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; z = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)sldZ.Value;
            Quaternion q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Quaternion(x, y, z, 1f);
            v.Orientation &lt;/span&gt;=&lt;span&gt; q;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个 Quaternion 实例包含四个值，前三个就是三个坐标轴上旋转的值，那个 W 不管它，始终给它分配 1 就行了。&lt;/p&gt;

&lt;p&gt;来，看看效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/367389/201711/367389-20171107115617950-1003402274.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个示例的源代码可以 &lt;a href=&quot;https://files.cnblogs.com/files/tcjiaan/UIRotinXamlsample.zip&quot; target=&quot;_blank&quot;&gt;点击这里下载&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;好，本篇咱们就聊到这里，下一篇老周再介绍一下如何用 Win 2D 组件在 XAML 元素上画点东东，可以实现 WPF 中自定义 Renderer 的效果。&lt;/p&gt;

</description>
<pubDate>Tue, 07 Nov 2017 04:02:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/7798041.html</dc:identifier>
</item>
<item>
<title>初窥图像识别与k-means算法 - 不著人间风雨门</title>
<link>http://www.cnblogs.com/zhouxiaosong/p/7707479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouxiaosong/p/7707479.html</guid>
<description>
&lt;p&gt;　　前段时间做了一个车型识别的小项目，思路是利用k-means算法以及词袋模型来做的。&lt;/p&gt;
&lt;p&gt;　　近年来图像识别的方法非常非常多，这边只记录一下我那个项目的思路，核心思想是k-means算法和词汇树。&lt;/p&gt;
&lt;p&gt;　　很遗憾没有做详尽的开发前的思路文档，只能按照记忆进行大致总结。&lt;/p&gt;
&lt;p&gt;　　项目分为三大模块：特征点抽取、训练词汇树、识别(利用训练好的词汇树)。&lt;/p&gt;


&lt;p&gt;　　首先是特征点的抽取。我是用的OpenCV的框架来做的特征点抽取。这里提到两种特征点：&lt;span&gt;SURF&lt;/span&gt;和&lt;span&gt;SIFT。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　关于这两种特征点提取算法，这里做简要介绍（其实我真的不太care，主要是看哪个的特性适合我的项目。单纯为了实现这个东西的话我觉得没必要太深究这个，当然如果你要把这个东西做透了，那肯定得好好研究，毕竟源码来看还是有很多可以优化的东西）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　SIFT特征是图像的局部特征，对平移、旋转、尺度缩放、亮度变化、遮挡和噪声等具有良好的不变性，对视觉变化、仿射变换也保持一定程度的稳定性。SIFT算法时间复杂度的瓶颈在于描述子的建立和匹配 ，如何优化对特征点的描述方法是提升SIFT效率的关键。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　SURF算法的优点是速度远快于SIFT且稳定性好;在时间上，SURF运行速度大约为SIFT的3倍；在质量上，SURF的鲁棒性很好，特征点识别率较SIFT高，在视角、光照、尺度变化等情形下，大体上都优于SIFT。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里要提到的一点就是SURF是64维的特征描述子，而SIFT是128维的特征描述子，简单点数说就是SIFT是X=(x1,x2,x3,...,x128)。而SURF是Y=(y1,y2,y3,...,y64)。从做k-means聚类的角度上来说我果断选择了SURF算法来提取（不过因为用的是OpenCV框架，所以几句代码的事。再提一句，OpenCV框架不止C有，Java也有，喜欢Java不喜欢C/C++的朋友可以尝试，我就是用的java代码）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　简单点说一幅图就是由N多个SURF特征点构成的，有点像像素点。每一个SURF特征点是一个64维的向量Y=(y1,y2,y3,...,y64)，就像像素一样，一张图不也是由很多很多个像素点组成的吗，每一个像素点是一个三维向量(x,y,z)，其中x,y,z都在0到255之间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;首先是SURF特征点的抽取&lt;/span&gt;，我们采用OpenCV框架来抽取每一张图的SURF特征点（当时大约10000张图），将所有图中抽出的SURF特征点都放在一起，形成一个特征点“池塘”，有大概几十亿个特征点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;第二步是词汇树的训练&lt;/span&gt;。我们把这个词汇树定义为一个深层次的二叉树，那么这个二叉树如何生成呢，这里首先要提到k-means聚类算法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　k-means聚类算法是一类无监督机器学习的算法。至于什么是机器学习，什么是有监督学习和无监督学习，这里简单介绍，具体可以查百度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　机器学习是一类算法的总称，通俗点来讲就是想让机器通过学习来拥有智慧（拥有决策能力），这和大多数的基本算法其实没啥区别，这里还要提到一点就是基于时代的背景，当下机器学习大势是在统计学习上的，至于什么是统计学习，什么是符号学习，这个是机器学习的一个发展史相关的东西，可以百度。也就是说我们根据现有的一些数据，通过一些手段来分析，能够得到一个决策的方法，来了一个新的数据我就知道该干什么（这跟我们人类的思维过程是一样的，我们也是小的时候学到了很多东西，后来遇到一件新的事情之后呢我们就能根据以往的经验来做出决策）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　有监督学习和无监督学习是机器学习中的两个大类，有监督学习是说我给定的一大堆数据，是人为标注好哪些数据属于哪一类的。而无监督学习是指我事先不加以人工干预，单纯凭借这一大批数据来进行一个分类或者说预测。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　k-means算法的大致步骤，这里我用二维坐标系中的点的聚类来形象地表示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;10&quot;&gt;　　1）从N个点随机选取K个K作为质心。对于我们的二维坐标系来说，就是随便找K个点（实际上还有一些初始的找质心的算法，比如说你如果三个点紧挨在一起，最终收敛的可能很慢，可能效果不好，这也是机器学习算法的一个普遍特征，他每次运行出来的结果是不一样的，你的初始状态的设定等等会很大程度上影响算法的运行时长、结果等等）&lt;a href=&quot;https://baike.baidu.com/item/%E8%B4%A8%E5%BF%83&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;div class=&quot;para&quot; readability=&quot;11&quot;&gt;　　2）对剩余的每个点测量其到每个质心的距离，并把它归到最近的质心的类。对于我们二维坐标系来说，就是计算欧氏距离即&lt;img src=&quot;http://images2017.cnblogs.com/blog/909212/201711/909212-20171107110829278-1481537772.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　（不好意思自己弄得公示有点丑），(x0,y0)即质心。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;para&quot; readability=&quot;11&quot;&gt;　　3）重新计算已经得到的各个类的质心，即当前已形成了几类，但是我最开始的质心是瞎找的，所以要再次迭代，重新找质心就是计算这个类当中的所有的点的x的平均值，y的平均值，最终得到的新的(x1,y1)就是一个新的质心。&lt;a href=&quot;https://baike.baidu.com/item/%E8%B4%A8%E5%BF%83&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;　　4）迭代2～3步直至新的质心与原质心相等或小于指定阈值，算法结束。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　从网上贴张图来表示k-means聚类的过程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/909212/201711/909212-20171107105648247-1502076921.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这是一种比较形象的聚类。可以看到图中三类点被聚到了3类中。&lt;/p&gt;
&lt;p&gt;　　那么对于我们项目中的SURF特征点的聚类，实际上和上面提到的二维点聚类是一样的，只不过我们现在是一个64维的坐标系，每一个点是一个64维向量X=(x1,x2,x3,...,x64)&lt;/p&gt;
&lt;p&gt;　　而计算距离就是变成了&lt;img src=&quot;http://images2017.cnblogs.com/blog/909212/201711/909212-20171107111749606-1095972170.png&quot; alt=&quot;&quot;/&gt;。而质心的坐标就是(x10,x20,x30,...,x640)。&lt;/p&gt;
&lt;p&gt;　　接下来就是建立二叉树的过程了，首先我们有一个根结点。我们对于那么多的特征点利用k-means算法分成两类。那么根结点的左右子树分别是我们分好类的A类和B类。紧接着，对于左右子树，我们分别对A类再分成A1，A2两类作为左子树的左右子树；对B类在分成B1，B2两类作为右子树的左右子树，一直迭代，直到迭代到我们需要的层数。我当时定了32层，于是在叶子节点处就有2^31个叶子节点，即有2^31类。然后对每一个叶子节点给一个符号。现在词汇树就建立完成了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;接下来就是图像识别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　现在我的词汇树已经训练完成，那么我要对我数据库里面的10000张图片做一个调整，毕竟图片是没啥东西可以抽取的，我们要转换成别的形式。于是我们数据库里的每一张图，现在我们来走一遍这个二叉树，就能将一张图片转化为一段文本。具体过程：遍历每一个SURF特征点，然后比较和A1，A2类哪个接近（用欧氏距离），假设离A1近，然后再到A1子树里，比较和A1的左子树，A1的右子树哪个近……就这样一直比较到最终的叶子节点，然后就把这个SURF特征点转化为一个符号（也就是一个文字）。接着我么把所有的数据库中的图片全部转化为文字。&lt;/p&gt;
&lt;p&gt;　　然后我们再进一步转化，可以把一张图转化成一个多维向量！这个利用到文本挖掘里面的一点知识，大家可以自行百度，简单说就是由好多好多文本（每一段文本由不同的符号组成，相当于普通文本，每一段文本由不同的词组成嘛），然后选出一系列具有代表性的词（我们不需要选，因为我们只有2^31个词！那么就能转化成2^31维的向量）。&lt;/p&gt;
&lt;p&gt;　　紧接着我们拍到了一张新的汽车的图片，我们利用相似的过程将一个新的汽车的图片转化成一个2^31维向量，然后根据已有的数据来匹配，最接近哪些车型？这个过程其实有很多办法，这里不详细展开了，最简单的一种办法就是像刚刚一样计算欧氏距离。&lt;/p&gt;

&lt;p&gt;　　那么整个识别过程到这里就介绍完了，当中其实还有很多坑，比如说拍的汽车图片，周围是有很多背景的，在提取SURF特征点过程中，如何防止这些无用的背景的干扰，还有可否拍摄视频来识别？等等有很多问题需要解决，也有很多方法，就不在本文中描述了。&lt;/p&gt;

</description>
<pubDate>Tue, 07 Nov 2017 03:47:00 +0000</pubDate>
<dc:creator>不著人间风雨门</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouxiaosong/p/7707479.html</dc:identifier>
</item>
<item>
<title>nova创建虚拟机源码分析系列之六 api入口create方法 - 金色旭光</title>
<link>http://www.cnblogs.com/goldsunshine/p/7717694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goldsunshine/p/7717694.html</guid>
<description>&lt;p&gt;openstack 版本：Newton&lt;/p&gt;
&lt;p&gt;注：博文图片采用了很多大牛博客图片，仅作为总结学习，非商用。&lt;br/&gt;该图全面的说明了nova创建虚机的过程，从逻辑的角度清晰的描述了前端请求创建虚拟机之后发生的一系列反应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201710/1060878-20171023165216754-1891183799.gif&quot; alt=&quot;&quot; width=&quot;1054&quot; height=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图是以逻辑的关系说明虚机创建的流程，并没有涉及到真正的代码，下面这张图则是从代码的角度来看虚机的创建过程。两张逻辑图相辅相成，能够快速对nova创建虚机流程有一个认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107121138669-1848547864.png&quot; alt=&quot;&quot; width=&quot;2448&quot; height=&quot;1848&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上一篇博文已经将nova创建虚机的流程分析到restful调用具体的函数。如下图所示，本篇将从该函数开始分析，展开nova服务的代码文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107101138044-458841829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图的create函数是nova api的入口函数，所有nova api的调用都是从该函数开始的。&lt;/p&gt;
&lt;p&gt;从该函数开始到nova调用底层驱动创建虚拟机，要经过的调用流程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt; nova.api.openstack.compute.servers.py::Controller：create
-&amp;gt;nova.compute.api.py::API:create
-&amp;gt;nova.compute.api.py::API:_create_instance
-&amp;gt;nova.comductor.ComputeTaskAPI.py::build_instances
-&amp;gt;nova.conductor.rpcapi.py::ComputeTaskAPI:build_instances
-&amp;gt;nova.conductor.manager.py::ComputeTaskAPI.py:build_instances
-&amp;gt;nova.compute.rpcapi.ComputeManager.py::build_and_run_instance
-&amp;gt;nova.compute.manager.py::ComputeManager:_do_build_and_run_instance
-&amp;gt;nova.compute.manager.py::ComputeManager:_build_and_run_instance
-&amp;gt;driver&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;&lt;strong&gt;&lt;span&gt;nova.api.openstack.compute.servers.py:: Controller:create&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;  指该create函数的所在路径是nova文件夹下的/nova/api/openstack/compute/servers.py中的create方法&lt;/p&gt;
&lt;p&gt;同理：&lt;span&gt;&lt;strong&gt;&lt;span&gt;nova.compute.api.py::API:create&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 指该create方法在/nova/compute/api.py中的create方法。&lt;/p&gt;
&lt;p&gt;所以这个调用的顺序就是如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107104808138-1442562366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么接下来就详细分析create()函数方法。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107104850622-131662174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要搞明白create函数做了什么，就要弄清楚函数传入的参数是什么。create传入了三个参数，分别是self，req，body。&lt;/p&gt;
&lt;p&gt;其中self是类方法的标识，如果java类中函数的 &quot;this&quot; 字段。那么req、body分别是什么呢？使用python中print打印到文件的方法，输出了req与body的内容。&lt;/p&gt;
&lt;p&gt;req&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;99&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;POST /v2.1/servers HTTP/1.0
Accept: application/json
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 323
Content-Type: application/json
Host: 192.168.252.134:8774
User-Agent: python-novaclient
X-Auth-Project-Id: 836c0b02b549489eac82733267830e60
&lt;span&gt;X-Auth-Token: 31475f46361e41d49c3aa519531192c2&lt;/span&gt;
X-Domain-Id: None
X-Domain-Name: None
X-Identity-Status: Confirmed
X-Is-Admin-Project: False
X-Project-Domain-Id: default
X-Project-Domain-Name: Default
X-Project-Id: 836c0b02b549489eac82733267830e60
X-Project-Name: demo
X-Role: Member,anotherrole
X-Roles: Member,anotherrole
&lt;span&gt;X-Service-Catalog: [{&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:8774/v2.1&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:8774/v2.1&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:8774/v2.1&quot;}], &quot;type&quot;: &quot;compute&quot;, &quot;name&quot;: &quot;nova&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:8774/v2/836c0b02b549489eac82733267830e60&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:8774/v2/836c0b02b549489eac82733267830e60&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:8774/v2/836c0b02b549489eac82733267830e60&quot;}], &quot;type&quot;: &quot;compute_legacy&quot;, &quot;name&quot;: &quot;nova_legacy&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:8776/v2/836c0b02b549489eac82733267830e60&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:8776/v2/836c0b02b549489eac82733267830e60&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:8776/v2/836c0b02b549489eac82733267830e60&quot;}], &quot;type&quot;: &quot;volumev2&quot;, &quot;name&quot;: &quot;cinderv2&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:9696/&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:9696/&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:9696/&quot;}], &quot;type&quot;: &quot;network&quot;, &quot;name&quot;: &quot;neutron&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134/identity_v2_admin&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134/identity&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134/identity&quot;}], &quot;type&quot;: &quot;identity&quot;, &quot;name&quot;: &quot;keystone&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:8776/v1/836c0b02b549489eac82733267830e60&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:8776/v1/836c0b02b549489eac82733267830e60&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:8776/v1/836c0b02b549489eac82733267830e60&quot;}], &quot;type&quot;: &quot;volume&quot;, &quot;name&quot;: &quot;cinder&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:8080&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:8080/v1/AUTH_836c0b02b549489eac82733267830e60&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:8080/v1/AUTH_836c0b02b549489eac82733267830e60&quot;}], &quot;type&quot;: &quot;object-store&quot;, &quot;name&quot;: &quot;swift&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:8776/v3/836c0b02b549489eac82733267830e60&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:8776/v3/836c0b02b549489eac82733267830e60&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:8776/v3/836c0b02b549489eac82733267830e60&quot;}], &quot;type&quot;: &quot;volumev3&quot;, &quot;name&quot;: &quot;cinderv3&quot;}, {&quot;endpoints&quot;: [{&quot;adminURL&quot;: &quot;http://192.168.252.134:9292&quot;, &quot;region&quot;: &quot;RegionOne&quot;, &quot;internalURL&quot;: &quot;http://192.168.252.134:9292&quot;, &quot;publicURL&quot;: &quot;http://192.168.252.134:9292&quot;}], &quot;type&quot;: &quot;image&quot;, &quot;name&quot;: &quot;glance&quot;}]
&lt;span&gt;X-Tenant: demo&lt;/span&gt;&lt;/span&gt;
X-Tenant-Id: 836c0b02b549489eac82733267830e60
X-Tenant-Name: demo
X-User: demo
X-User-Domain-Id: default
X-User-Domain-Name: Default
X-User-Id: ac86920aec8c443f9fad33283599a17c
X-User-Name: demo

{&quot;&lt;span&gt;server&lt;/span&gt;&quot;: {&quot;name&quot;: &quot;demo&quot;, &quot;imageRef&quot;: &quot;ec8f8b10-beb4-4802-9158-7b3ca8357d16&quot;, &quot;availability_zone&quot;: &quot;nova&quot;, &quot;flavorRef&quot;: &quot;1&quot;, &quot;OS-DCF:diskConfig&quot;: &quot;AUTO&quot;, &quot;max_count&quot;: 1, &quot;min_count&quot;: 1, &quot;networks&quot;: [{&quot;uuid&quot;: &quot;cf8411d0-85b4-4534-9b7c-aed9dbecaafe&quot;}], &quot;security_groups&quot;: [{&quot;name&quot;: &quot;2a2f7994-a555-45be-9909-3bb06b1f4811&quot;}]}}&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;req是http报文的全部内容，包括报文头，报文内容。其中很熟悉的字段：X-Auth-Token是已经获得的token，还有获得Token时返回的服务列表Catalog。会不会有人好奇为什么发送的不是账号和密码？而是Token？在登陆上openstack dashboard时账号和密码都被验证，后面的操作全都是基于Token来操作的。&lt;/p&gt;
&lt;p&gt;报文内容中包含一个server字典，这是我们填写的创建虚机的数据。可以看到下面的代码中有在创建虚机时必填的参数，name，镜像，flavor，network等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;{&quot;server&quot;: 
    {
        &quot;name&quot;: &quot;demo&quot;, 
        &quot;imageRef&quot;: &quot;ec8f8b10-beb4-4802-9158-7b3ca8357d16&quot;, 
        &quot;availability_zone&quot;: &quot;nova&quot;, 
        &quot;flavorRef&quot;: &quot;1&quot;, 
        &quot;OS-DCF:diskConfig&quot;: &quot;AUTO&quot;, 
        &quot;max_count&quot;: 1, 
        &quot;min_count&quot;: 1, 
        &quot;networks&quot;: [{&quot;uuid&quot;: &quot;cf8411d0-85b4-4534-9b7c-aed9dbecaafe&quot;}], 
        &quot;security_groups&quot;: [{&quot;name&quot;: &quot;2a2f7994-a555-45be-9909-3bb06b1f4811&quot;}]
    }
}&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再来看body中的内容是什么&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;{&lt;br/&gt;u'server':&lt;br/&gt;{&lt;br/&gt;u'name': u'demo', &lt;br/&gt;u'imageRef': u'ec8f8b10-beb4-4802-9158-7b3ca8357d16', &lt;br/&gt;u'availability_zone': u'nova', &lt;br/&gt;u'flavorRef': u'1', &lt;br/&gt;u'OS-DCF:diskConfig': u'AUTO', &lt;br/&gt;u'max_count': 1, &lt;br/&gt;u'min_count': 1, &lt;br/&gt;u'networks': [{u'uuid': u'cf8411d0-85b4-4534-9b7c-aed9dbecaafe'}], &lt;br/&gt;u'security_groups': [{u'name': u'2a2f7994-a555-45be-9909-3bb06b1f4811'}]&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到body中的内容是req内容的一部分，是post方法的内容。&lt;/p&gt;

&lt;p&gt; 搞清楚了传入的数据，下面就是函数处理过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107111631184-2096357749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107111835169-1751379653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





















&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107111812872-1950535684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;








&lt;p&gt;这里是该函数最重要的调用。调用了compute/api.py中的create方法去创建虚机。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060878/201711/1060878-20171107112052794-133206125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;总结来说，该函数主要做的工作：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/nova/api/openstack/compute/server.py::create()  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;1 获取客户端传入的虚拟机参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2 获取虚拟机名并检查是否合理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3 检查API版本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4 构造用户id，项目id，可用域字典&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5 获取可用域&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6 块设备映射&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7 获取虚机的磁盘镜像uuid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8 获取客户端需求的网络&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9 获取续集规格ID&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10 调用compute_api.create()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11 将虚拟机信息转化为字典&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12 添加访问当前虚拟机资源的url&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主要任务是从传递过的req中获取各种创建虚拟机所需要的参数信息，做简单必要验证，然后将获取的一系列参数（image_uuid,name,insts_type等）&lt;/p&gt;
&lt;p&gt;作为nova/compute/api.py中的API类的create()方法参数，最后将返回的信息处理。那么下一节的内容就是要探究调用函数/nova/compute/api.py中的create()函数&lt;/p&gt;
&lt;p&gt;完成了什么样的工作。&lt;/p&gt;

</description>
<pubDate>Tue, 07 Nov 2017 03:30:00 +0000</pubDate>
<dc:creator>金色旭光</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goldsunshine/p/7717694.html</dc:identifier>
</item>
<item>
<title>荐书 : 调试九法 - 指路灯 - Rudolph_Browne</title>
<link>http://www.cnblogs.com/CARPE-DIEM-wu/p/7798119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CARPE-DIEM-wu/p/7798119.html</guid>
<description>&lt;h3&gt;文章概述&lt;/h3&gt;
&lt;p&gt;偶然的情况下在豆瓣上看到这本《调试九法》,心想一本142页的书居然评分达到9.0,索性也读下以便了解软件测试.&lt;/p&gt;
&lt;p&gt;这本书引言部分说明这本书的魅力所在,也就6-7页,但不看也不会影响后面章节的阅读.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107104835575-2051622298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么会觉得这本书是指路灯,因为它通过例子提醒你可能已经知道但是忽略的方向.&lt;/p&gt;
&lt;p&gt;告诉你,你为什么会出错.&lt;/p&gt;
&lt;p&gt;这本书并没有告诉你专门详细的测试技术,更多地是告诉你怎么进行排错.&lt;/p&gt;
&lt;p&gt;以下是章节小结内容,&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;理解系统&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107105719044-1883355652.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;制造失败&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107105835013-530740949.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;不要想,而要看&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110012294-568048278.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;分而治之&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110114513-1731886584.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一次只改一个地方&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110214747-1648000798.png&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;保持审计跟踪&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110321653-769235863.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;检查插头&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110408966-943561161.png&quot; alt=&quot;&quot; width=&quot;627&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;获得全新观点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110539013-421671239.png&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;481&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;如果你不修复bug,它将始终存在&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107110707184-1378075214.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;从帮助台得到的观点是不明确的&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107111004138-1462259054.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;黄金规则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171107111126247-779079743.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 07 Nov 2017 03:16:00 +0000</pubDate>
<dc:creator>Rudolph_Browne</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CARPE-DIEM-wu/p/7798119.html</dc:identifier>
</item>
</channel>
</rss>