<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM学习六：JVM之类加载器之双亲委派机制 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/8654678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/8654678.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面我们知道类加载有系统自带的3种加载器，也有自定义的加载器，那么这些加载器之间的关系是什么，已经在加载类的时候，谁去加载呢？这节，我们将进行讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、双亲委派机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180326223226827-1656372278.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JVM的ClassLoader采用的是树形结构，除了BootstrapClassLoader以外？每个ClassLoader都会有一个parentClassLoader，用户自定义的ClassLoader默认的parentClassLoader是SystemClassLoader，当然你可以自己指定需要用哪一个ClassLoader的实例，我们来看他的API：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180326223328017-1478716917.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认的无参构造方法使用的是SystemClassLoader，你可以通过传入一个ClassLoader的实例来指定他的父类加载器。&lt;span&gt;这里强调一点，很多人认为各个父子类加载器之间是继承关系，这里澄清一下，父子类加载器之间是组合关系，子类类加载器会含有一个parentClassLoader的对象，类加载的时候通常会按照树形结构的原则来进行，也就是说，首先是从parentClassLoader中尝试进行加载，当parent无法进行加载时，再从当前的类加载器进行加载，以此类推。JVM会保证一个类在同一个ClassLoader中只会被加载一次。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ClassLoader抽象类为我们定义了一系列的关键的方法，下来让我们来看一下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;1、loadClass方法&lt;/strong&gt;，&lt;strong&gt;此方法用来加载指定名字的类&lt;/strong&gt;，ClassLoader会先从已加载的类中寻找，如果没有，则使用父加载器进行加载，如果加载成功则加载，否则从当前的类加载器中进行加载，如果还没有找到该类的class文件则会抛出异常ClassNotFoundException&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180326223510938-282595648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果该类需要链接，则通过resolveClass进行链接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、defineClass，此方法用来将二进制的字节码转换为Class对象&lt;/strong&gt;，这个对类的自定义加载非常重要，当然前文我们已经说了，当类的二进制文件被加载到内存之后，要进行语法分析，语义分析等一系列的验证，如果不符合JVM规范，则抛出ClassFormateError错误，如果生成的类名和字节码中的不一致，则抛出NoClassDefFoundException，如果加载的class是受保护的、采用不同的标签名的，或者一java.*开头的，则抛出SecurityException，如果要加载的class在之前已经被加载过，则直接抛出LinkageError。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180326223644906-1637114492.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、resolveClass，此方法完成Class的链接，如果链接过则直接返回&lt;/strong&gt;。当Java开发人员调用Class.forName来获取一个class对象的时候，JVM会从方法栈上寻找第一个ClassLoader，通常也就是执行Class.forName的ClassLoader，并使用这个ClassLoader来加载此类。JVM为了保护加载、执行的类的安全，不允许ClassLoader直接卸载加载了的类，只有JVM才可以卸载，在SUN的JDK中，只有ClassLoader没有 被引用的时候，次ClassLoader加载的类才会被卸载！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180326223801874-950780044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;附：JDK中ClassLoader的部分源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;1、&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ClassLoader(ClassLoader parent) {
    SecurityManager security &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (security != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        security.checkCreateClassLoader();
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
    initialized &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ClassLoader() {
    SecurityManager security &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (security != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        security.checkCreateClassLoader();
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; getSystemClassLoader();
    initialized &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;loadClass&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; loadClass(name, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; resolve)
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException
    {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, check if the class has already been loaded&lt;/span&gt;
    Class c =&lt;span&gt; findLoadedClass(name);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
           c &lt;/span&gt;= parent.loadClass(name, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
           c &lt;/span&gt;=&lt;span&gt; findBootstrapClass0(name);
       }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If still not found, then invoke findClass in order
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to find the class.&lt;/span&gt;
            c =&lt;span&gt; findClass(name);
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resolve) {
        resolveClass(c);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; c;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类的这种加载机制我们称之为父委托加载机制，&lt;span&gt;父委托机制的优点就是能够提高软件系统的安全性&lt;/span&gt;。因为在此机制下，用户自定义的类加载器不可能加载本应该由父加载器加载的可靠类，从而防止不可靠的甚至恶意的代码代替由父类加载器加载的可靠代码。如，java.lang.Object类总是由根类加载器加载的，其他任何用户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;被定义的类加载器，而它的父类加载器则被称为初始类加载器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道java中很可能出现类名相同的类，但是JVM却能正常的加载，是因为我们将相同的类名的类放在了不通的包（package）下面，这个也成为命名空间，每个类加载器都有自己的命名空间，命名空间是由该加载器以及所有父加载器所加载的类组成。&lt;span&gt;在同一个命名空间中，不会出现类的完整名字（包名+类名）相同的两个类；在不同的命名空间中，有可能出现类的完整名字相同的两个类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由同一类加载器加载的属于相同包的类组成了运行时包。决定两个类是不是属于同一个运行时包，不仅要看他们的包名称是否相同，还要看定义类加载器是否相同。只有属于同一运行时包的类之间才能相互访问可见（默认访问级别）的类和成员&lt;/span&gt;。假设用户自定义了一个类java.lang.TestCase并由用于自定义的类加载器加载，由于java.lang.TestCase和核心类库java.lang.*由不同的类加载器加载，他们属于不同的运行时包，所以java.lang.TestCase不能访问核心库java.lang包中的包可见成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同一个命名空间内的类是相互可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子类加载器的命名空间包含所有父类加载器的命名空间，因此由子类加载器加载的类能看见父类加载器加载的类，相反，由父类加载器加载的类不能看见子类加载器加载的类。如果两个加载器之间没有直接或者间接的父子关系，那么他们各自加载的类互不可见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、自定义类加载器 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先类的双亲委派流程为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201803/401339-20180326224719578-1082444131.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们定义一个待加载的普通&lt;code&gt;Java&lt;/code&gt;类:&lt;code&gt;Test.java&lt;/code&gt;。放在&lt;code&gt;com.pony.cl&lt;/code&gt;包下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pony.cl;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hello() {
        System.out.println(&lt;/span&gt;&quot;恩，是的，我是由 &quot; +&lt;span&gt; getClass().getClassLoader().getClass()
                &lt;/span&gt;+ &quot; 加载进来的&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你是直接在当前项目里面创建，待&lt;code&gt;Test.java&lt;/code&gt;编译后，请把&lt;code&gt;Test.class&lt;/code&gt;文件拷贝走，再将&lt;code&gt;Test.java&lt;/code&gt;删除。因为如果&lt;code&gt;Test.class&lt;/code&gt;存放在当前项目中，根据双亲委派模型可知，会通过&lt;code&gt;sun.misc.Launcher$AppClassLoader&lt;/code&gt; 类加载器加载。为了让我们自定义的类加载器加载，我们把Test.class文件放入到其他目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就是自定义我们的类加载器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyClassLoader &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ClassLoader {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String classPath;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyClassLoader(String classPath) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.classPath =&lt;span&gt; classPath;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] loadByte(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            name &lt;/span&gt;= name.replaceAll(&quot;\\.&quot;, &quot;/&quot;&lt;span&gt;);
            FileInputStream fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileInputStream(classPath + &quot;/&quot; +&lt;span&gt; name
                    &lt;/span&gt;+ &quot;.class&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; fis.available();
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[len];
            fis.read(data);
            fis.close();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;

        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data =&lt;span&gt; loadByte(name);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; defineClass(name, data, 0&lt;span&gt;, data.length);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException();
            }
        }

    };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String args[]) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MyClassLoader classLoader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MyClassLoader(&quot;D:/test&quot;&lt;span&gt;);
        Class clazz &lt;/span&gt;= classLoader.loadClass(&quot;com.pony.cl.Test&quot;&lt;span&gt;);
        Object obj &lt;/span&gt;=&lt;span&gt; clazz.newInstance();
        Method helloMethod &lt;/span&gt;= clazz.getDeclaredMethod(&quot;hello&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        helloMethod.invoke(obj, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意点：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Object obj =&lt;span&gt; clazz.newInstance();
不能写成：
Test obj &lt;/span&gt;= (Test)clazz.newInstance();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果写成这样会报错，因为当前的这个类是由系统加载器加载，而Test是由自定义加载器加载，那么系统类加载和自定义类的加载器不属于同一个运行时包，这个时候是没有办法直接转换的，只能通过反射的方式去访问，反射是唯一一种可以跨越在不同运行时包的方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;圣思园张龙老师深入Java虚拟机系列&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 15:31:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/8654678.html</dc:identifier>
</item>
<item>
<title>4.Apache POI使用详解 - 豆豆de思念</title>
<link>http://www.cnblogs.com/lukelook/p/8660798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lukelook/p/8660798.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;span&gt;POI介绍&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Apache POI是Apache软件基金会的开源项目，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。 .NET的开发人员则可以利用NPOI (POI for .NET) 来存取 Microsoft Office文档的功能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.&lt;span&gt;POI结构说明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;包名称 &lt;span class=&quot;Apple-tab-span&quot;&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HSSF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读写Microsoft Excel XLS格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;XSSF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读写Microsoft Excel OOXML XLSX格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HWPF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读写Microsoft Word DOC格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HSLF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读写Microsoft PowerPoint格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HDGF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读Microsoft Visio格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HPBF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读Microsoft Publisher格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HSMF &lt;span class=&quot;Apple-tab-span&quot;&gt;提供读Microsoft Outlook格式档案的功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3&lt;/span&gt;.&lt;span&gt;POI常用类说明&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类名&lt;/strong&gt;                &lt;strong&gt;说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFWorkbook        Excel的文档对象&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFSheet &lt;span class=&quot;Apple-tab-span&quot;&gt;    　　　Excel的表单&lt;br/&gt;HSSFRow &lt;span class=&quot;Apple-tab-span&quot;&gt;            Excel的行&lt;br/&gt;HSSFCell &lt;span class=&quot;Apple-tab-span&quot;&gt;   　　　　 Excel的格子单元&lt;br/&gt;HSSFFont            Excel字体&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFDataFormat      格子单元的日期格式&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFHeader          Excel文档Sheet的页眉&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFFooter          Excel文档Sheet的页脚&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle       格子单元样式&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFDateUtil        日期&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFPrintSetup      打印&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFErrorConstants  错误信息&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.my.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.hssf.usermodel.HSSFWorkbook;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.hssf.util.HSSFColor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.usermodel.Cell;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.usermodel.CellStyle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.usermodel.Row;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.usermodel.Sheet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.usermodel.Workbook;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UsePoiCreateExcle {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        String path = &quot;D:\\java\\test\\test.xls&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create workbook&lt;/span&gt;
        Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFWorkbook();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create sheet&lt;/span&gt;
        Sheet sheet1 = workbook.createSheet(&quot;teacher&quot;&lt;span&gt;);
        Sheet sheet2 &lt;/span&gt;= workbook.createSheet(&quot;student&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置为当前页面&lt;/span&gt;
        workbook.setActiveSheet(0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建行&lt;/span&gt;
        Row row = sheet1.createRow(0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建表格&lt;/span&gt;
        Cell cell1 = row.createCell(0&lt;span&gt;);
        Cell cell2 &lt;/span&gt;= row.createCell(1&lt;span&gt;);
        Cell cell3 &lt;/span&gt;= row.createCell(2&lt;span&gt;);

        CellStyle style &lt;/span&gt;=&lt;span&gt; workbook.createCellStyle();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对齐方式&lt;/span&gt;
&lt;span&gt;        style.setAlignment(CellStyle.ALIGN_CENTER);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先设置样式再设置颜色&lt;/span&gt;
&lt;span&gt;        style.setBorderBottom(CellStyle.BORDER_THICK);
        style.setBottomBorderColor(HSSFColor.RED.index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先设置填充样式再设置颜色&lt;/span&gt;
&lt;span&gt;        style.setFillPattern(CellStyle.ALT_BARS);
        style.setFillForegroundColor(HSSFColor.GREEN.index);
        cell1.setCellValue(&lt;/span&gt;&quot;序号&quot;&lt;span&gt;);
        cell1.setCellStyle(style);
        cell2.setCellValue(&lt;/span&gt;&quot;姓名&quot;&lt;span&gt;);
        cell3.setCellValue(&lt;/span&gt;&quot;年龄&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;=============&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            FileOutputStream out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(path);
            workbook.write(out);
            out.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;创建文档摘要信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
workbook.createInformationProperties();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档信息&lt;/span&gt;
DocumentSummaryInformation dsi= workbook.getDocumentSummaryInformation();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;摘要信息&lt;/span&gt;
dsi.setCategory(&quot;类别:Excel文件&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类别&lt;/span&gt;
dsi.setManager(&quot;管理者:李志伟&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;管理者&lt;/span&gt;
dsi.setCompany(&quot;公司:--&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公司&lt;/span&gt;
SummaryInformation si = workbook.getSummaryInformation();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;摘要信息&lt;/span&gt;
si.setSubject(&quot;主题:--&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主题&lt;/span&gt;
si.setTitle(&quot;标题:测试文档&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
si.setAuthor(&quot;作者:李志伟&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;作者&lt;/span&gt;
si.setComments(&quot;备注:POI测试文档&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;备注&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327223755756-49922571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;创建批注&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
HSSFSheet sheet = workbook.createSheet(&quot;Test&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFPatriarch patr =&lt;span&gt; sheet.createDrawingPatriarch();
HSSFClientAnchor anchor &lt;/span&gt;= patr.createAnchor(0, 0, 0, 0, 5, 1, 8, 3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建批注位置&lt;/span&gt;
HSSFComment comment = patr.createCellComment(anchor);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建批注&lt;/span&gt;
comment.setString(&lt;span&gt;new&lt;/span&gt; HSSFRichTextString(&quot;这是一个批注段落！&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置批注内容&lt;/span&gt;
comment.setAuthor(&quot;李志伟&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置批注作者&lt;/span&gt;
comment.setVisible(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置批注默认显示&lt;/span&gt;
HSSFCell cell = sheet.createRow(2).createCell(1&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;测试&quot;&lt;span&gt;);
cell.setCellComment(comment);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把批注赋值给单元格&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327223904912-1424708606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建批注位置HSSFPatriarch.createAnchor(dx1, dy1, dx2, dy2, col1, row1, col2, row2)方法参数说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dx1         第1个单元格中x轴的偏移量
dy1         第1个单元格中y轴的偏移量
dx2         第2个单元格中x轴的偏移量
dy2         第2个单元格中y轴的偏移量
col1        第1个单元格的列号
row1        第1个单元格的行号
col2        第2个单元格的列号
row2        第2个单元格的行号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;span&gt;创建页眉和页脚&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HSSFSheet sheet = workbook.createSheet(&quot;Test&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFHeader header =sheet.getHeader();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到页眉&lt;/span&gt;
header.setLeft(&quot;页眉左边&quot;&lt;span&gt;);
header.setRight(&lt;/span&gt;&quot;页眉右边&quot;&lt;span&gt;);
header.setCenter(&lt;/span&gt;&quot;页眉中间&quot;&lt;span&gt;);
HSSFFooter footer &lt;/span&gt;=sheet.getFooter();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到页脚&lt;/span&gt;
footer.setLeft(&quot;页脚左边&quot;&lt;span&gt;);
footer.setRight(&lt;/span&gt;&quot;页脚右边&quot;&lt;span&gt;);
footer.setCenter(&lt;/span&gt;&quot;页脚中间&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327224128869-1805556494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 也可以使用Office自带的标签定义，你可以通过HSSFHeader或HSSFFooter访问到它们，都是静态属性，列表如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HSSFHeader.tab                  &amp;amp;&lt;span&gt;A    表名
HSSFHeader.file                 &lt;/span&gt;&amp;amp;&lt;span&gt;F    文件名
HSSFHeader.startBold            &lt;/span&gt;&amp;amp;&lt;span&gt;B    粗体开始
HSSFHeader.endBold              &lt;/span&gt;&amp;amp;&lt;span&gt;B    粗体结束
HSSFHeader.startUnderline       &lt;/span&gt;&amp;amp;&lt;span&gt;U    下划线开始
HSSFHeader.endUnderline         &lt;/span&gt;&amp;amp;&lt;span&gt;U    下划线结束
HSSFHeader.startDoubleUnderline &lt;/span&gt;&amp;amp;&lt;span&gt;E    双下划线开始
HSSFHeader.endDoubleUnderline   &lt;/span&gt;&amp;amp;&lt;span&gt;E    双下划线结束
HSSFHeader.time                 &lt;/span&gt;&amp;amp;&lt;span&gt;T    时间
HSSFHeader.date                 &lt;/span&gt;&amp;amp;&lt;span&gt;D    日期
HSSFHeader.numPages             &lt;/span&gt;&amp;amp;&lt;span&gt;N    总页面数
HSSFHeader.page                 &lt;/span&gt;&amp;amp;P    当前页号
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;span&gt;设置数据格式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HSSFSheet sheet = workbook.createSheet(&quot;Test&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFRow row=sheet.createRow(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置日期格式--使用Excel内嵌的格式&lt;/span&gt;
HSSFCell cell=row.createCell(0&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
HSSFCellStyle style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(HSSFDataFormat.getBuiltinFormat(&lt;/span&gt;&quot;m/d/yy h:mm&quot;&lt;span&gt;));
cell.setCellStyle(style);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置保留2位小数--使用Excel内嵌的格式&lt;/span&gt;
cell=row.createCell(1&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;12.3456789&lt;span&gt;);
style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(HSSFDataFormat.getBuiltinFormat(&lt;/span&gt;&quot;0.00&quot;&lt;span&gt;));
cell.setCellStyle(style);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置货币格式--使用自定义的格式&lt;/span&gt;
cell=row.createCell(2&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;12345.6789&lt;span&gt;);
style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(workbook.createDataFormat().getFormat(&lt;/span&gt;&quot;￥#,##0&quot;&lt;span&gt;));
cell.setCellStyle(style);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置百分比格式--使用自定义的格式&lt;/span&gt;
cell=row.createCell(3&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;0.123456789&lt;span&gt;);
style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(workbook.createDataFormat().getFormat(&lt;/span&gt;&quot;0.00%&quot;&lt;span&gt;));
cell.setCellStyle(style);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置中文大写格式--使用自定义的格式&lt;/span&gt;
cell=row.createCell(4&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;12345&lt;span&gt;);
style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(workbook.createDataFormat().getFormat(&lt;/span&gt;&quot;[DbNum2][$-804]0&quot;&lt;span&gt;));
cell.setCellStyle(style);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置科学计数法格式--使用自定义的格式&lt;/span&gt;
cell=row.createCell(5&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;12345&lt;span&gt;);
style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(workbook.createDataFormat().getFormat(&lt;/span&gt;&quot;0.00E+00&quot;&lt;span&gt;));
cell.setCellStyle(style);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;HSSFDataFormat.getFormat和HSSFDataFormat.getBuiltinFormat的区别：&lt;/strong&gt;当使用Excel内嵌的（或者说预定义）的格式时，直接用HSSFDataFormat.getBuiltinFormat静态方法即可。当使用自己定义的格式时，必须先调用HSSFWorkbook.createDataFormat()，因为这时在底层会先找有没有匹配的内嵌FormatRecord，如果没有就会新建一个FormatRecord，所以必须先调用这个方法，然后你就可以用获得的HSSFDataFormat实例的getFormat方法了，当然相对而言这种方式比较麻烦，所以内嵌格式还是用HSSFDataFormat.getBuiltinFormat静态方法更加直接一些。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;span&gt;合并单元格&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
HSSFSheet sheet = workbook.createSheet(&quot;Test&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFRow row=sheet.createRow(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并列&lt;/span&gt;
HSSFCell cell=row.createCell(0&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;合并列&quot;&lt;span&gt;);
CellRangeAddress region&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; CellRangeAddress(0, 0, 0, 5&lt;span&gt;);
sheet.addMergedRegion(region);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并行&lt;/span&gt;
cell=row.createCell(6&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;合并行&quot;&lt;span&gt;);
region&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; CellRangeAddress(0, 5, 6, 6&lt;span&gt;);
sheet.addMergedRegion(region);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327224639150-197433185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CellRangeAddress对象其实就是表示一个区域，其构造方法如下：CellRangeAddress(firstRow, lastRow, firstCol, lastCol)，参数的说明：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;firstRow        区域中第一个单元格的行号
lastRow         区域中最后一个单元格的行号
firstCol        区域中第一个单元格的列号
lastCol         区域中最后一个单元格的列号 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.单元格对齐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HSSFCell cell=row.createCell(0&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;单元格对齐&quot;&lt;span&gt;);
HSSFCellStyle style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setAlignment(HSSFCellStyle.ALIGN_CENTER);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;水平居中&lt;/span&gt;
style.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;垂直居中&lt;/span&gt;
style.setWrapText(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动换行&lt;/span&gt;
style.setIndention((&lt;span&gt;short&lt;/span&gt;)5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩进&lt;/span&gt;
style.setRotation((&lt;span&gt;short&lt;/span&gt;)60);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本旋转，这里的取值是从-90到90，而不是0-180度。&lt;/span&gt;
cell.setCellStyle(style);  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;水平对齐相关参数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;如果是左侧对齐就是   HSSFCellStyle.ALIGN_FILL;
如果是居中对齐就是   HSSFCellStyle.ALIGN_CENTER;
如果是右侧对齐就是   HSSFCellStyle.ALIGN_RIGHT;
如果是跨列举中就是   HSSFCellStyle.ALIGN_CENTER_SELECTION;
如果是两端对齐就是   HSSFCellStyle.ALIGN_JUSTIFY;
如果是填充就是       HSSFCellStyle.ALIGN_FILL;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;垂直对齐相关参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;如果是靠上就是     HSSFCellStyle.VERTICAL_TOP;
如果是居中就是     HSSFCellStyle.VERTICAL_CENTER;
如果是靠下就是     HSSFCellStyle.VERTICAL_BOTTOM;
如果是两端对齐就是 HSSFCellStyle.VERTICAL_JUSTIFY;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;边框和其他单元格设置一样也是调用CellStyle接口，CellStyle有2种和边框相关的属性，分别是:&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;边框相关属性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;329&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;范例&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;&lt;span&gt;Border+方向&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;
&lt;p&gt;&lt;span&gt;边框类型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;329&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;BorderLeft, BorderRight等&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;&lt;span&gt;方向+BorderColor&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;87&quot;&gt;
&lt;p&gt;&lt;span&gt;边框颜色&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;329&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;TopBorderColor,BottomBorderColor等&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HSSFCell cell=row.createCell(1&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;设置边框&quot;&lt;span&gt;);
HSSFCellStyle style&lt;/span&gt;=&lt;span&gt;workbook.createCellStyle();
style.setBorderTop(HSSFCellStyle.BORDER_DOTTED);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上边框&lt;/span&gt;
style.setBorderBottom(HSSFCellStyle.BORDER_THICK);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下边框&lt;/span&gt;
style.setBorderLeft(HSSFCellStyle.BORDER_DOUBLE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边框&lt;/span&gt;
style.setBorderRight(HSSFCellStyle.BORDER_SLANTED_DASH_DOT);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边框&lt;/span&gt;
style.setTopBorderColor(HSSFColor.RED.index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上边框颜色&lt;/span&gt;
style.setBottomBorderColor(HSSFColor.BLUE.index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下边框颜色&lt;/span&gt;
style.setLeftBorderColor(HSSFColor.GREEN.index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边框颜色&lt;/span&gt;
style.setRightBorderColor(HSSFColor.PINK.index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右边框颜色&lt;/span&gt;
cell.setCellStyle(style);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327225007224-862343408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中边框类型分为以下几种：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;边框范例图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;对应的静态值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657095397412.png&quot; alt=&quot;1&quot; width=&quot;49&quot; height=&quot;14&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_DOTTED&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657101643055.png&quot; alt=&quot;2&quot; width=&quot;49&quot; height=&quot;13&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_HAIR&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657109923870.png&quot; alt=&quot;3&quot; width=&quot;47&quot; height=&quot;13&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_DASH_DOT_DOT&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657115559297.png&quot; alt=&quot;4&quot; width=&quot;49&quot; height=&quot;11&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_DASH_DOT&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657121171427.png&quot; alt=&quot;5&quot; width=&quot;49&quot; height=&quot;10&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_DASHED&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657130244283.png&quot; alt=&quot;6&quot; width=&quot;49&quot; height=&quot;9&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_THIN&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657136647452.png&quot; alt=&quot;7&quot; width=&quot;49&quot; height=&quot;9&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_MEDIUM_DASH_DOT_DOT&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657144453282.png&quot; alt=&quot;8&quot; width=&quot;49&quot; height=&quot;12&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_SLANTED_DASH_DOT&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657149455195.png&quot; alt=&quot;9&quot; width=&quot;49&quot; height=&quot;11&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_MEDIUM_DASH_DOT&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657154457109.png&quot; alt=&quot;10&quot; width=&quot;49&quot; height=&quot;10&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_MEDIUM_DASHED&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657163995951.png&quot; alt=&quot;11&quot; width=&quot;49&quot; height=&quot;13&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_MEDIUM&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657169453851.png&quot; alt=&quot;12&quot; width=&quot;49&quot; height=&quot;13&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_THICK&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;112&quot;&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/601464/201503/041657180557178.png&quot; alt=&quot;13&quot; width=&quot;49&quot; height=&quot;13&quot;/&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;HSSFCellStyle.&lt;em&gt;BORDER_DOUBLE&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.设置字体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HSSFCell cell = row.createCell(1&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;设置字体&quot;&lt;span&gt;);
HSSFCellStyle style &lt;/span&gt;=&lt;span&gt; workbook.createCellStyle();
HSSFFont font &lt;/span&gt;=&lt;span&gt; workbook.createFont();
font.setFontName(&lt;/span&gt;&quot;华文行楷&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体名称&lt;/span&gt;
font.setFontHeightInPoints((&lt;span&gt;short&lt;/span&gt;)28);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字号&lt;/span&gt;
font.setColor(HSSFColor.RED.index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体颜色&lt;/span&gt;
font.setUnderline(FontFormatting.U_SINGLE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置下划线&lt;/span&gt;
font.setTypeOffset(FontFormatting.SS_SUPER);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置上标下标&lt;/span&gt;
font.setStrikeout(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置删除线&lt;/span&gt;
&lt;span&gt;style.setFont(font);
cell.setCellStyle(style);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;下划线选项值：
        单下划线 FontFormatting.U_SINGLE
        双下划线 FontFormatting.U_DOUBLE
        会计用单下划线 FontFormatting.U_SINGLE_ACCOUNTING
        会计用双下划线 FontFormatting.U_DOUBLE_ACCOUNTING
    无下划线 FontFormatting.U_NONE
    上标下标选项值：
        上标 FontFormatting.SS_SUPER
        下标 FontFormatting.SS_SUB
        普通，默认值 FontFormatting.SS_NONE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
SSFCellStyle style =&lt;span&gt; workbook.createCellStyle();
style.setFillForegroundColor(HSSFColor.GREEN.index);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图案颜色&lt;/span&gt;
style.setFillBackgroundColor(HSSFColor.RED.index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图案背景色&lt;/span&gt;
style.setFillPattern(HSSFCellStyle.SQUARES);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图案样式&lt;/span&gt;
cell.setCellStyle(style);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327225559164-1896687708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1132619/201803/1132619-20180327225629723-932634804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10.&lt;strong&gt;&lt;span&gt;设置宽度和高度&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HSSFSheet sheet = workbook.createSheet(&quot;Test&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFRow row = sheet.createRow(1&lt;span&gt;);
HSSFCell cell &lt;/span&gt;= row.createCell(1&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&quot;123456789012345678901234567890&quot;&lt;span&gt;);
sheet.setColumnWidth(&lt;/span&gt;1, 31 * 256);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第一列的宽度是31个字符宽度&lt;/span&gt;
row.setHeightInPoints(50);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置行的高度是50个点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.&lt;strong&gt;&lt;span&gt;判断单元格是否为日期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//判断单元格是否为日期类型，使用DateUtil.isCellDateFormatted(cell)方法，例如：
HSSFCell cell &lt;/span&gt;= row.createCell(1&lt;span&gt;);
cell.setCellValue(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Date());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置日期数据&lt;/span&gt;
System.out.println(DateUtil.isCellDateFormatted(cell));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：false&lt;/span&gt;
HSSFCellStyle style =&lt;span&gt;workbook.createCellStyle();
style.setDataFormat(HSSFDataFormat.getBuiltinFormat(&lt;/span&gt;&quot;m/d/yy h:mm&quot;&lt;span&gt;));
cell.setCellStyle(style);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置日期样式&lt;/span&gt;
System.out.println(DateUtil.isCellDateFormatted(cell));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HSSFWorkbook workbook = &lt;span&gt;new&lt;/span&gt; HSSFWorkbook();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Excel文件(Workbook)&lt;/span&gt;
workbook.createSheet(&quot;Test0&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.createSheet(&quot;Test1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.createSheet(&quot;Test2&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.createSheet(&quot;Test3&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.setActiveSheet(2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置默认工作表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HSSFWorkbook workbook = &lt;span&gt;new&lt;/span&gt; HSSFWorkbook();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Excel文件(Workbook)&lt;/span&gt;
workbook.createSheet(&quot;Test0&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.createSheet(&quot;Test1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.createSheet(&quot;Test2&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.createSheet(&quot;Test3&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
workbook.setSheetName(2, &quot;1234&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重命名工作表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;14.&lt;/strong&gt;调整表单显示比例&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
HSSFWorkbook workbook = &lt;span&gt;new&lt;/span&gt; HSSFWorkbook();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Excel文件(Workbook)&lt;/span&gt;
HSSFSheet sheet1= workbook.createSheet(&quot;Test0&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFSheet sheet2=workbook.createSheet(&quot;Test1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFSheet sheet3=workbook.createSheet(&quot;Test2&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
sheet1.setZoom(1,2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;50%显示比例&lt;/span&gt;
sheet2.setZoom(2,1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;200%显示比例&lt;/span&gt;
sheet3.setZoom(1,10);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10%显示比例&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;15.&lt;/strong&gt;显示/隐藏网格线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
HSSFWorkbook workbook = &lt;span&gt;new&lt;/span&gt; HSSFWorkbook();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建Excel文件(Workbook)&lt;/span&gt;
HSSFSheet sheet1= workbook.createSheet(&quot;Test0&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
HSSFSheet sheet2=workbook.createSheet(&quot;Test1&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建工作表(Sheet)&lt;/span&gt;
sheet1.setDisplayGridlines(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏Excel网格线,默认值为true&lt;/span&gt;
sheet2.setGridsPrinted(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印时显示网格线,默认值为false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;16.&lt;/strong&gt;遍历Sheet&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
String filePath = &quot;d:\\users\\lizw\\桌面\\POI\\sample.xls&quot;&lt;span&gt;;
FileInputStream stream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(filePath);
HSSFWorkbook workbook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HSSFWorkbook(stream);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取现有的Excel&lt;/span&gt;
HSSFSheet sheet= workbook.getSheet(&quot;Test0&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到指定名称的Sheet&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Row row : sheet)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cell cell : row)
    {
        System.out.print(cell &lt;/span&gt;+ &quot;\t&quot;&lt;span&gt;);
    }
    System.out.println();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;其他详见：http://www.cnblogs.com/LiZhiW/p/4313789.html&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;










</description>
<pubDate>Tue, 27 Mar 2018 14:45:00 +0000</pubDate>
<dc:creator>豆豆de思念</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lukelook/p/8660798.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(一) lightning简单介绍以及org开启lightning - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/7899260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/7899260.html</guid>
<description>&lt;p&gt;lightning对于开发salesforce人员来说并不陌生，即使没有做过lightning开发，这个名字肯定也是耳熟能详。原来的博客基本都是基于classic基于配置以及开发，后期博客会以lightning为主。&lt;/p&gt;
&lt;p&gt;那么问题来了，why lightning?&lt;/p&gt;
&lt;p&gt;lightning针对classic，不管是针对界面上来说还是开发上来说，都有很大的改变。lightning基于sales，service增加了很多很便捷的功能，针对列表视图也增加了kanban 视图，列表，详情页面更加友好，可以基于组件对UI界面进行的配置，lightning也提供了好多标准功能组件。当然，说的lightning的有点太过于片面，lightning的优点很多，这里不一一例举。当然，有一些功能在salesforce的classic可以使用的，却没法在lightning使用或者不好移植过来，具体的区别以及优点感兴趣的可以自己去查看。既然lightning有很多的好处，并且lightning越来越热，那么如何开启lightning呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.启用Lightning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1.配置自定义域名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Lightning前提需要org拥有自定义的域名。此步为必需的操作，只要org使用lightning，则必须拥有唯一的自定义域名。点击SetUp后，搜索My Domain,按照步骤注册即可。对步骤有问题的可以参考：&lt;a href=&quot;https://help.salesforce.com/articleView?id=domain_name_overview.htm&amp;amp;type=5&quot; target=&quot;_blank&quot;&gt;https://help.salesforce.com/articleView?id=domain_name_overview.htm&amp;amp;type=5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201802/910966-20180201223356562-2027630455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.指定Profile或者指定用户开启Lightning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 配置完第一步以后，作为System Admin的你便可以点击右上角你的名称选择Switch To Lightning Experience体验Lightning了。好多项目可能原来是在Classic基础上慢慢的向Lightning迁移，对于部分功能有可能指定的Profile或者指定的User使用Lightning功能模块，其他的用户还是使用Classic，这时便需要针对指定的Profile或者指定的用户进行开启Lightning权限了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;针对Profile：&lt;/strong&gt;找到需要启用Lightning Experience的简档，勾选Lightning Experience User选项。这里针对Sales Profile简档开启了Lightning Experience。&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201802/910966-20180201232051921-1489882692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;test1用户登录后便可以切换成Lightning Experience.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201802/910966-20180201232945859-789567332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;针对指定用户：&lt;/strong&gt;新建Lightning Experience User Permission Set(名称自己起)，保存后点击System Permissions.Edit后将Lightning Experience User勾选。点击Manage Assignments将需要设置Lightning的用户添加进去即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/910966/201802/910966-20180202220746593-720012943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：不是所有的情况都支持启用Lightning,以下情况不支持启用Lightning。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;org使用了&lt;a href=&quot;https://help.salesforce.com/articleView?id=account_person.htm&amp;amp;type=5&quot; target=&quot;_blank&quot;&gt;personal Account&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;以下版本不允许：Contact Manager Edition, Personal Edition, Database.com Edition, and Chatter.com Edition&lt;/li&gt;
&lt;li&gt;以下License对应的Profile的User不允许使用Lightning，相关的Permission Set方式配置Assign User时也会相应的报错：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Customer Community/Customer Community &lt;em id=&quot;__mceDel&quot;&gt;Plus/Partner Community/All Portal licenses/Force.com Free/Work.comDatabase.com/Content Only/Ideas Only/Knowledge Only/Site.com Only&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 二.Lightning简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lightning相对Classic，除了在UI方面上变得更加用户友好外，还增加了很多特性，例举几个点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Performance Chart&lt;/li&gt;
&lt;li&gt;Assistant：展示过期的Task/今天到期的Task/今天分配给你的Lead/包含过期Task的Opportunity/30天内无Activity的Opportunity/无Open Activity的Opportunity&lt;/li&gt;
&lt;li&gt;首页Chart可以filter&lt;/li&gt;
&lt;li&gt;增加Sales Path&lt;/li&gt;
&lt;li&gt;更加美观的Dashboard&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Lightning特性以及使用（偏Admin）感兴趣的可以查看此PDF文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://resources.docs.salesforce.com/206/latest/en-us/sfdc/pdf/lightning_experience_guide.pdf&quot; target=&quot;_blank&quot;&gt;https://resources.docs.salesforce.com/206/latest/en-us/sfdc/pdf/lightning_experience_guide.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：Lightning针对SetUp中的设置，有一些内容进行了位置的更改以及整合，也有一些新增的模块内容。建议Lightning零基础的同学详细看一遍上面的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;针对开发者来说，我们可能更关注于和经典模式的区别，以及Lightning如何开发。Lightning开发的模式如下图所示。可以简单的总结以下几点：&lt;/p&gt;
&lt;p&gt;1.Lightning开发采用View-Controller(js)-Controller(server)-Database模式，而Classic采用View-Controller(server)-Database模式，Lightning通过事件驱动方式单独将js的事件处理从页面中拿出来放在Controller(js)中，View里面不允许存在js，而且Lightning更多的是开发可复用的Component并嵌套到需要的Lightning App Builder中；&lt;/p&gt;
&lt;p&gt;2.Lightning前端UI以及框架整体采用aura UI框架,可以更好的兼容网页端以及手机端，而且提供了很多已经封装好的标签，&lt;a href=&quot;https://www.lightningdesignsystem.com/getting-started/&quot; target=&quot;_blank&quot;&gt;Lightning Design System&lt;/a&gt;提供了标签实现的样式写法，当然，这些样式也可以使用到classic中；&lt;/p&gt;
&lt;p&gt;3.创建一个Lightning Component会创建一个bundle，bundle中包括lightning component,lightning controller,lightning helper,lightning style,lightning design,lightning document,lightning renderer svg元素。可以通过几种方式创建lightning component，比如idea，sublime以及develper console。bundle中包含的这些内容后期会详解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201802/910966-20180224164838186-621786628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;此篇只是简单的介绍Lightning配置以及提供Lightning的一些特性以及和classic的区别，详细的内容参看篇中的链接PDF。开发的内容后期的博客会有更新。有写错的地方欢迎指出，有不懂的欢迎留言。&lt;/p&gt;

</description>
<pubDate>Tue, 27 Mar 2018 14:35:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/7899260.html</dc:identifier>
</item>
<item>
<title>EF Core利用Transaction对数据进行回滚保护 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/8660592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/8660592.html</guid>
<description>

&lt;p&gt;首先，说一下什么是EF Core中的Transaction&lt;/p&gt;
&lt;p&gt;Transaction允许以原子方式处理多个数据库操作，如果事务已提交，则所有操作都应用于数据库，如果事务回滚，则没有任何操作应用于数据库。&lt;/p&gt;
&lt;p&gt;所谓原子方式 是指对数据库的每一个操作是对立开来的，但是多个操作能合成一个整体（个人理解）。&lt;/p&gt;
&lt;p&gt;当操作到某一步失败了，那么会触发事物的回滚，把前面成功的操作也进行撤销，为什么这一操作这么重要呢？我举个例子你就知道了&lt;/p&gt;
&lt;p&gt;就那拿一行转账这件事情来说。正常的A给B转账X元有两步：&lt;/p&gt;
&lt;p&gt;1. 从A的账户余额中减去X元。&lt;/p&gt;
&lt;p&gt;2. 往B的银行账户中添加X元。&lt;/p&gt;
&lt;p&gt;假如，第一步执行完了，第二部因为某种原因执行失败了，那么，是不是A的账户平白无故地少了X元而B并没有多X元呢？显然这种事情是不能发生的，正确的做法是，把第一步撤销，即把A账户减去的X元加上。&lt;/p&gt;
&lt;p&gt;然而在在.Net中，如果你使用EF Core来操作数据库，这些都不用我们手动完成了，EF Core的事物完全可以帮我们完成这样的操作。&lt;/p&gt;

&lt;p&gt;下面我们利用一个asp.net core webapi的例子来讲解EF Core中这种Transaction的用法。&lt;/p&gt;
&lt;h2&gt;新建一个webapi应用程序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220945813-1538552316.gif&quot;&gt;&lt;img title=&quot;clip_image002[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220946137-972187197.gif&quot; alt=&quot;clip_image002[1]&quot; width=&quot;670&quot; height=&quot;381&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择Asp.NET Core Web应用程序&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220946351-102130089.gif&quot;&gt;&lt;img title=&quot;clip_image004[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220946527-873749395.gif&quot; alt=&quot;clip_image004[1]&quot; width=&quot;662&quot; height=&quot;344&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.选择WebApi&lt;/p&gt;
&lt;h2&gt;搭建EF Core&lt;/h2&gt;
&lt;p&gt;创建Model文件夹和BankContext数据库上下文，Walet钱包实体，如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220946691-477422422.gif&quot;&gt;&lt;img title=&quot;clip_image006[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220946840-1868073869.gif&quot; alt=&quot;clip_image006[1]&quot; width=&quot;244&quot; height=&quot;221&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Wallet的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EFCoreRollback.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Wallet
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Money { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BankContext的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EFCoreRollback.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BankContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BankContext(DbContextOptions&amp;lt;BankContext&amp;gt; options) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Wallet&amp;gt; Wallets { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我是用Mysql数据库进行数据存储的，所以需要添加Mysql的EF Core引用，选中依赖项，右键菜单 选择管理Nuget程序包，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220947316-608385804.gif&quot;&gt;&lt;img title=&quot;clip_image008[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220947843-1290801679.gif&quot; alt=&quot;clip_image008[1]&quot; width=&quot;543&quot; height=&quot;298&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装下列引用项目（Pomelo.EntityFrameworkCore.MySql）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220948324-872418853.gif&quot;&gt;&lt;img title=&quot;clip_image010[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220948500-503469436.gif&quot; alt=&quot;clip_image010[1]&quot; width=&quot;609&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在appsettings.json中加入数据库连接字符串，如下：&lt;/p&gt;
&lt;p&gt;&quot;ConnectionStrings&quot;: { &quot;Connection&quot;: &quot;Data Source=127.0.0.1;Database=bank;User ID=root;Password=123456;&quot; }&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220949005-254653301.png&quot;&gt;&lt;img title=&quot;QQ截图20180327202848&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220949216-2006426322.png&quot; alt=&quot;QQ截图20180327202848&quot; width=&quot;800&quot; height=&quot;281&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改statup.cs，进行BankContext的依赖注入，主要修改了灰色部分，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; EFCoreRollback.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EFCoreRollback
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
           &lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; connectString = Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;); services.AddDbContext&lt;/span&gt;&amp;lt;BankContext&amp;gt;(options =&amp;gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;
&lt;span&gt;            {
                options.UseMySql(connectString);
                options.UseLoggerFactory(&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;new&lt;/span&gt; LoggerFactory().AddConsole()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入该句会把EF Core执行过程中的Sql语句在控制台输出&lt;/span&gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;            });&lt;/span&gt;
            services.AddMvc();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建数据库和表&lt;/h2&gt;
&lt;p&gt;打开NuGet报管理器下的程序包管理控制台&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220949734-35012957.gif&quot;&gt;&lt;img title=&quot;clip_image014[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220950260-171386117.gif&quot; alt=&quot;clip_image014[1]&quot; width=&quot;709&quot; height=&quot;264&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先后执行以下两条语句&lt;/p&gt;
&lt;p&gt;Add-Migrition Init&lt;/p&gt;
&lt;p&gt;Updata-Database&lt;/p&gt;
&lt;p&gt;执行效果如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220951115-2031771879.gif&quot;&gt;&lt;img title=&quot;clip_image016[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220951992-820981884.gif&quot; alt=&quot;clip_image016[1]&quot; width=&quot;701&quot; height=&quot;553&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行成功后，Mysql数据库中多了Bank数据库和walets表，如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220952210-774391109.gif&quot;&gt;&lt;img title=&quot;clip_image018[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220952368-1722085653.gif&quot; alt=&quot;clip_image018[1]&quot; width=&quot;553&quot; height=&quot;187&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;添加控制器（业务代码）&lt;/h2&gt;
&lt;p&gt;在Controllers下新建一个BankController.cs，完整代码如下（核心部分为灰色背景）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; EFCoreRollback.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EFCoreRollback.Controllers
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BankController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; BankContext _bankContext;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BankController(BankContext context)
        {
            _bankContext &lt;/span&gt;=&lt;span&gt; context;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据初始化
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bangk/InitData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; InitData()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_bankContext.Wallets.ToList().Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                Wallet AUser &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wallet()
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Money &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
                };
                Wallet BUser &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wallet()
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Money &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
                };
                _bankContext.Wallets.Add(AUser);
                _bankContext.Wallets.Add(BUser);
                _bankContext.SaveChanges();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 进行转账
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bank/TransferAccounts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; TransferAccounts()
        {
            &lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; transaction =&lt;/span&gt; &lt;span&gt;&lt;span&gt;_bankContext.Database.BeginTransaction()) {&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;
&lt;span&gt;                {
                    AAction();
                    BAction();

                    &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果未执行到Commit()就执行失败遇到异常了，EF Core会自动进行数据回滚（前提是使用Using）&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;transaction.Commit(); }&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;(Exception ex) {&lt;/span&gt; &lt;span&gt;//&lt;/span&gt; &lt;span&gt;TODO: Handle failure&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;ex.Message; } }&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从A的账户里面减掉10元
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AAction()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; AUser = _bankContext.Wallets.Where(u =&amp;gt; u.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).FirstOrDefault();
            AUser.Money &lt;/span&gt;-= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
            _bankContext.SaveChanges();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从B的账户里面加上10元
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BAction()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; BUser = _bankContext.Wallets.Where(u =&amp;gt; u.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).FirstOrDefault();
            BUser.Money &lt;/span&gt;+= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B的数据在保存前出现异常了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用该方法模拟出现数据保存异常&lt;/span&gt;
&lt;span&gt;            _bankContext.SaveChanges();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 展示钱包账户
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bank/Show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Wallet&amp;gt;&lt;span&gt; ShowWallets()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _bankContext.Wallets.ToList();
        }



    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;通过InitData方法，我们把数据初始化，往数据库中插入A、B用户，他们钱包的初始金额都为100元。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;通过TransferAccounts方法，我们执行转账操作，通过using引入了EF Core的Transaction，如果未执行到Commit()就执行失败遇到异常了，EF Core会自动进行数据回滚（前提是使用Using）。&lt;/p&gt;
&lt;p&gt;在执行AAction后，执行BAction，其中BAction在数据保存前，设置了一个异常。&lt;/p&gt;
&lt;h2&gt;执行接口（调用业务）&lt;/h2&gt;
&lt;p&gt;首先，其启动方式从IIS切换到WebAPi程序本身，为的是在控制台中看到输出的SQL语句。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220952604-763049690.png&quot;&gt;&lt;img title=&quot;QQ截图20180327205604&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220952857-1335416063.png&quot; alt=&quot;QQ截图20180327205604&quot; width=&quot;546&quot; height=&quot;198&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;程序成功启动后，我们调用数据初始化接口，效果如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220953149-442494962.gif&quot;&gt;&lt;img title=&quot;clip_image020[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220953425-249853614.gif&quot; alt=&quot;clip_image020[1]&quot; width=&quot;800&quot; height=&quot;332&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了数据后，我们调用转账接口进行转账操作，如图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220953689-818038325.gif&quot;&gt;&lt;img title=&quot;clip_image022[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220953978-528937754.gif&quot; alt=&quot;clip_image022[1]&quot; width=&quot;760&quot; height=&quot;263&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进行转账操作，在A的账户成功减掉10元后，在B的账户加上10元保存时，由于我们设置了异常，程序跳出了。&lt;/p&gt;
&lt;p&gt;如果按照我们正常的思维方式，因为B在保存数据前异常了，所以最终结果因该是：A的账户少了10元，而B的账户金额未变。事实是不是这样呢？&lt;/p&gt;
&lt;p&gt;我们执行Show接口，展示A和B用户的钱包金额情况，可以看到，A和B的钱包金额都是100，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220954210-1272456260.gif&quot;&gt;&lt;img title=&quot;clip_image024[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180327220954428-1766644796.gif&quot; alt=&quot;clip_image024[1]&quot; width=&quot;780&quot; height=&quot;236&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为什么A的账户明明执行了减去10元的操作，而最后没有生效呢？原来是在执行transaction.Commit()之前，程序遇到异常了，它会自动调用transaction.Rollback()进行数据回滚，撤销A的减去10元这一操作。&lt;/p&gt;


&lt;p&gt;使用EF Core的Transaction要么所有操作全部成功，要么一个操作都不执行，可以保护数据安全。&lt;/p&gt;

&lt;p&gt;该项目的完整代码：&lt;a title=&quot;https://github.com/liuzhenyulive/EFCoreTransaction&quot; href=&quot;https://github.com/liuzhenyulive/EFCoreTransaction&quot;&gt;https://github.com/liuzhenyulive/EFCoreTransaction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得有帮助，请点击推荐，谢谢。&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;</description>
<pubDate>Tue, 27 Mar 2018 14:10:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/8660592.html</dc:identifier>
</item>
<item>
<title>职场新人碰到的几个常见误区 - 沐榕休</title>
<link>http://www.cnblogs.com/sankt/p/8658028.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sankt/p/8658028.html</guid>
<description>&lt;p&gt;自己工作10+年了，大概5年前从技术转管理后，多少还是发现一些职场新人职业发展的问题。&lt;/p&gt;
&lt;p&gt;表现惊艳的新人肯定有，这种人往往在学校里面或者进入职场后就养成了一些非常良好的做事方式和工作习惯，工作效率高，产出多，甚至很短时间内就可以带新人，年度最佳新人当之无愧。&lt;/p&gt;
&lt;p&gt; 然而表现不到位的似乎更多一些，这些员工工作时间短（比如说应届毕业生或者不到两年）尤其性格内向的往往容易掉入错误泥潭，无法自拔，而这些错误的行为会对未来的发展造成非常负面的影响，从而导致职场发展往失败的道路上越走越远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/373479/201803/373479-20180327224337653-1642330312.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我分别从以下角度来阐述一下，&lt;/p&gt;
&lt;h3&gt;1. 不愿意和同事沟通，不愿意向同事多学习&lt;/h3&gt;
&lt;p&gt;这种员工大多比较内向或者性情有点高冷，须不知三人行，必有我师。多向同事学习，互通有无，对自己以后的发展有百利而无一害。有导师制或者老员工带，情况或许会有所改善，但如果内因没有改变，最终效果依旧不容乐观。&lt;/p&gt;
&lt;p&gt;技术开发工作中遇到一些技术难题非常正常，当然独立思考固然可贵，但是公司项目往往有一定的时间限制，优先解决问题永远放在第一位，而不是一个人在那里苦苦挣扎和搜索解决方案。如果时间压力不大，多思考一下也未尝不可。考虑到交付压力，这个时候就需要积极和同事，技术经理沟通，寻找解决思路，通常情况下，积极的沟通好过自己的单打独斗。也许同事或者老板的一句话，就应了那据古诗，山重水复疑无路，柳暗花明又一村。与此同时也和同事建立了更好的友谊，在老板心里也留下了做事有方法的好印象。&lt;/p&gt;

&lt;h3&gt;2.视野狭窄，只关注自己的一亩三分地，囿于角色.&lt;/h3&gt;
&lt;p&gt;这种情况其实在职场中多见不仅是初级程序员，甚至工作五年以上的程序员也有类似的问题，不是自己的事情不闻不问，而且危害更大。&lt;/p&gt;
&lt;p&gt;公司项目往往大而全，如果仅仅专注自己的那个角落，那么永远都是只见树木，不见森林。&lt;/p&gt;
&lt;p&gt;我相信没有老板会介意下面的程序员多承担一些责任，多做一些事情，最后给项目组多一些产出。&lt;/p&gt;
&lt;p&gt;既然老板不介意，那么就应该大胆的跳出自己的职责范围，多看看公司的其他项目，丰富自己的行业知识。&lt;/p&gt;
&lt;p&gt;职责外的事情，帮的上的不要躲避,，努力承担更多的东西。帮助别人就是提高自己，教学相长就是这个意思。况且你这次帮了别人，下次你的项目紧或者遇到技术难题了，受助之人肯定投桃报李，这样就形成了良性互助氛围，整个项目组的产出也同步提升了。&lt;/p&gt;
&lt;p&gt;一般来说，公司要提升一个人，最好的策略就是先让候选人做一些将来职位才需要做的事情。做的好，理所当然就要提拔。做的不好，则可以提前发现该员工的问题，暂缓提拔，需要多考察一段时间。这样的试错成本毫无疑问是最低的。&lt;/p&gt;

&lt;h3&gt;3.格局太小，对项目以外的技术视而不见，知识面陈旧，匮乏，技能极其单一。&lt;/h3&gt;
&lt;p&gt; 这里其实谈到了整个IT行业的问题，技术发展太快了。主要还是一个持续提升竞争力的一个话题。&lt;/p&gt;
&lt;p&gt;今天还是桌面开发，明天web开发就成为主流。&lt;/p&gt;
&lt;p&gt;好不容易掌握了关系型数据库，No-SQL成为主流。&lt;/p&gt;
&lt;p&gt;费了九牛二虎之力，熟练掌握Java, C#等静态语言，发现动态语言GO, Python成为云计算，机器学习的标配。&lt;/p&gt;
&lt;p&gt;移动开发昨天还是Object-C, Java, 今天就变成Swift, Kotlin。&lt;/p&gt;

&lt;p&gt;当然这里不是说让大家紧跟潮流，扼住时尚。那样做除了疲于奔命，累死在工作台，没有其他的结果。&lt;/p&gt;
&lt;p&gt;其实只要选择一个方向，纵深学习和积累，必有所成。&lt;/p&gt;

&lt;p&gt;比如说，你熟悉Java, 那么学习Kotlin绝对驾轻就熟。&lt;/p&gt;
&lt;p&gt;你有扎实的关系型数据库基础，那么掌握MangoDB肯定是件轻而易举的事情。&lt;/p&gt;
&lt;p&gt;编成思想和解决问题的思路都是相通的，平时的学习和工作中要善于思考，举一反三。并且做到与时俱进，及时更新自己的知识库和技能属性，保持良好的市场竞争力。&lt;/p&gt;
&lt;p&gt;做完事情后多思考，怎样做得更好，站在更好的要求上看问题.&lt;/p&gt;

&lt;p&gt;我举两个实际案例，&lt;/p&gt;
&lt;p&gt;程序员A在某国企里面，持续开发 Windows Form, 拖拉控件为主，对SQL Server数据库增删改查，时间长达五年之久，突然有一天打算离职，看看新的机会，以为有五年工作经验，可以很轻松找一个更好的工作。但是实际上求职之路异常艰辛，名义上的五年工作经验，其实就是极其单一的技能重复使用了五年。而且大环境也变了，主流已经是web开发，移动开发了。因为没有及时更新自己的知识库和技能储备，那么真要跳槽的时候可能已经跳不动了。&lt;/p&gt;

&lt;p&gt;程序员B在某外企，氛围比较安逸轻松，项目节奏慢，看似也作了不少项目，但做的项目几乎比较类似，难度一般，涉及面挺广，但技术点都是蜻蜓点水，浅尝辄止。这样过了三年，其实积累也是比较松散，知识的深度没有，核心技能并没有养成。&lt;/p&gt;

&lt;h3&gt;4.对未来没有想法，根本不考虑三五年自己要做什么&lt;/h3&gt;
&lt;p&gt;作者本人就犯过类似的错误，幡然醒悟的时候，三年时间已经过去了。&lt;/p&gt;
&lt;p&gt;程序员的职业生涯里面最初的三年其实是一个非常重要的打磨和规划时期，如果在迷茫中度过，那么事后想起肯定会扼腕叹息，奈何流水已经东去，再无复返之理。&lt;/p&gt;
&lt;p&gt;有目标，而没有具体的计划，那么就是一个愿景而已。&lt;/p&gt;
&lt;p&gt;建议不管是初级还是高级程序员，都应该积极向前辈或者直属老板沟通，看看他们有没有值得借鉴的规划和建议。&lt;/p&gt;
&lt;p&gt;职场大忌就是被动等待命运的安排，作者本人也是在职业生涯初期等待老板来帮我规划未来，到现在为止，十年过去了，也没有等到。。。&lt;/p&gt;
&lt;p&gt;所以老板不会主动帮助你规划未来，最重要的事情还是自己对自身的要求和期望。&lt;/p&gt;

&lt;h3&gt;5.没有意识到是给自己打工还是公司打工&lt;/h3&gt;
&lt;p&gt;这也是一个非常好的话题，很多人都没有想明白，甚至包括一些工作十年之久的程序员。&lt;/p&gt;
&lt;p&gt;想明白这一点，工作积极性明显就会好太多。自我驱动, 让工作更加有趣和有意义。&lt;/p&gt;
&lt;p&gt;国内知名的互联网公司大老板说过一句话，非常值得深思。&lt;/p&gt;
&lt;p&gt;“我每年付你20万，五年也就是100万。如果你在这里混日子，那么最后吃亏的肯定是你。你的五年青春就只值100万吗？”&lt;/p&gt;
&lt;p&gt;所以职场新人的主人翁意识一定要加强，你要持续提升自己的能力，持续强化自己创造价值的能力。&lt;/p&gt;
&lt;p&gt;举个例子，比如说现在公司支付你20万每年，那么你应该有目标能给公司带来远超过20万的收益，多多益善。&lt;/p&gt;
&lt;p&gt;你有这个能力，公司肯定也会对你相应回报。如果公司不给你升职加薪，那么一走了之，潇洒痛快。优质的人才从来都是抢着要。&lt;/p&gt;

&lt;h3&gt;6.不愿意走出舒适区域,不敢尝试新的东西&lt;/h3&gt;
&lt;p&gt;这点倒是因人而异，不可强求。这个话题其实有点广义。&lt;/p&gt;
&lt;p&gt;如果你在某个方向做的非常好，而且回报也不错，那么不愿意涉足其他领域也无可厚非。&lt;/p&gt;
&lt;p&gt;这个世界唯一不变的东西就是世界一直在改变。今天还有的岗位，明天也许就要消失。世界要抛弃你，都不会打一声招呼。&lt;/p&gt;

&lt;p&gt;举个例子，你在公司是SQL Server或者Oracle专家，但是公司计划转非关系型数据库，如果你害怕改变甚至拒绝改变，那么意味着你可能要错过另外一个全新的数据存储平台。进而错过很多机会，而那些勇于接受变化，顺应趋势的人肯定会获得更好的时代回报。&lt;/p&gt;

&lt;p&gt;又比如说，你现在用的技术在日常项目中都刚好够用，那么从改善用户体验和使用更加主流的技术角度看，是不是应该要尝试一些新的东西，同时也刷新了自己的技术栈，一举两得，何乐而不为呢？&lt;/p&gt;

&lt;p&gt;还有一个例子是一位资深程序员习惯了长期的慢节奏的工作氛围，因为公司改组被裁员，不过自身条件不错，很快就加入国内一家一线互联网公司，但是完全适应不了互联网快节奏，工作一段时间就以公司管理”混乱”，战略规划”经常”改变为借口离职了，接下来很长一段时间找不到一个合适自己的工作，加上中年已到，如果自身不积极调整，接下来的工作和生活肯定困难重重。&lt;/p&gt;

&lt;p&gt;最后再简单小结一下，职场新人需要做的就是从小事做起，学会吃亏，以结果为目标导向，日常工作中积极和同事，老板沟通。&lt;/p&gt;
&lt;p&gt;工作中要善于总结方法，经常更新问题的思考模式，对职业负责，对目标负责，对自己负责，脚踏实地，主动找事情做，而不是被动等事情来找你。&lt;/p&gt;
&lt;p&gt;相信职场新人如果能成功避开上面说的几个误区，那么在职业发展道路上就可以少走一些弯路，少犯一些错误，从而更快地实现自己的小目标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/373479/201803/373479-20180327221401913-1809206973.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sankt/p/8660884.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后如果觉得不错，可以移步赞赏页面支持作者发布更多原创文章。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Mar 2018 14:09:00 +0000</pubDate>
<dc:creator>沐榕休</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sankt/p/8658028.html</dc:identifier>
</item>
<item>
<title>canvas星空和图形变换 - starof</title>
<link>http://www.cnblogs.com/starof/p/8626422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starof/p/8626422.html</guid>
<description>&lt;p&gt;图形变换。&lt;/p&gt;

&lt;p&gt;先画一片canvas.width宽canvas.height高的黑色星空，再画200个随机位置，随机大小，随机旋转角度的星星。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('805f684c-034d-4f60-88a8-7cb841d59b28')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_805f684c-034d-4f60-88a8-7cb841d59b28&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_805f684c-034d-4f60-88a8-7cb841d59b28&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('805f684c-034d-4f60-88a8-7cb841d59b28',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_805f684c-034d-4f60-88a8-7cb841d59b28&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&quot;canvas&quot;&lt;span&gt;);

    canvas.width&lt;/span&gt;=800&lt;span&gt;;
    canvas.height&lt;/span&gt;=800&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&quot;2d&quot;&lt;span&gt;);
    
    context.fillStyle&lt;/span&gt;=&quot;black&quot;&lt;span&gt;;
    context.fillRect(&lt;/span&gt;0,0&lt;span&gt;,canvas.width,canvas.height);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;200;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r=Math.random()*10+10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x=Math.random()*&lt;span&gt;canvas.width;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y=Math.random()*&lt;span&gt;canvas.height;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a=Math.random()*360&lt;span&gt;;
        drawStar(context,x,y,r,r&lt;/span&gt;/2.0,a);
&lt;span&gt;    }
    
}        




&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rot顺时针旋转的角度&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawStar(ctx,x,y,r,R,rot){
    ctx.beginPath();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;角度转弧度：除以180*PI&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
        ctx.lineTo(Math.cos((&lt;/span&gt;18+i*72-rot)/180*Math.PI)*R+x,
            -Math.sin((18+i*72-rot)/180*Math.PI)*R+y);
            ctx.lineTo(Math.cos((54+i*72-rot)/180*Math.PI)*r+x,
            -Math.sin((54+i*72-rot)/180*Math.PI)*r+y);
&lt;span&gt;    }

    ctx.closePath();

    ctx.fillStyle&lt;/span&gt;=&quot;#fb3&quot;&lt;span&gt;;
    ctx.strokeStyle&lt;/span&gt;=&quot;#fd5&quot;&lt;span&gt;;
    ctx.lineWidth&lt;/span&gt;=3&lt;span&gt;;
    ctx.lineJoin&lt;/span&gt;=&quot;round&quot;&lt;span&gt;;

    ctx.fill();
    ctx.stroke();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 产生一个扁平化设计中200个星星的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180322203314588-2015131514.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1、用标准路径+图形变换思想重构&lt;/h2&gt;
&lt;p&gt;上面drawStar函数承载的功能太多来，整个绘制路径的指定，同时把五角星的位移，大小，旋转多少度全部揉合在一个函数里了。&lt;/p&gt;
&lt;p&gt;假如需要变为画一个四角形？六角形？代码改起来就比较麻烦了。&lt;/p&gt;
&lt;p&gt;标准做法：修改函数结构。&lt;/p&gt;
&lt;p&gt;接口不变，省去了旋转角度，画一个标准星星。假设外圆半径是内圆半径的两倍，所以只需要传入一个小r。drawStar里调用一个startPath()函数来绘制一个标准五角星的路径。&lt;/p&gt;
&lt;p&gt;标准的五角星路径：只传入一个context，在(0,0)的位置绘制来一个大圆半径为1，同时没有任何偏移，任何旋转的的五角星。&lt;/p&gt;
&lt;p&gt;在drawStar里勾绘出标准五角星后再通过图形变换使得标准五角星的位移变成在(x,y)的位置，大小变成R这么大，同时旋转rot角度。再进行具体的绘制。&lt;/p&gt;
&lt;p&gt;这样一个设计的结构可以避免之前的问题。比如需求变成要画六角形，四角形，只需要把starPath()里面路径勾绘的代码进行相应的更改即可。&lt;/p&gt;
&lt;p&gt;更高级的复用：starPath()函数以参数的形式传入drawStar()中。这样drawStar可以叫drawSheap用户可以绘制任意的图形，只需要传入绘制图形的标准路径，变更的位移量，大小量，旋转量即可。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rot顺时针旋转的角度&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawStar(ctx,x,y,r,R,rot){
    starPath(ctx);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制在(x,y)大小为R，旋转rot度的五角星&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; starPath(ctx){
    ctx.beginPath();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;角度转弧度：除以180*PI&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
        ctx.lineTo(Math.cos((&lt;/span&gt;18+i*72)/180*Math.PI),
            -Math.sin((18+i*72)/180*Math.PI));
            ctx.lineTo(Math.cos((54+i*72)/180*Math.PI),
            -Math.sin((54+i*72)/180*Math.PI));
&lt;span&gt;    }
    ctx.closePath();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：图形学里绘制先绘制标准路径，再通过图形变换成需求大小。&lt;/p&gt;
&lt;h2&gt;2，图形变换&lt;/h2&gt;
&lt;p&gt;三种基本操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;位移translate(x,y)&lt;/li&gt;
&lt;li&gt;旋转rotate(deg)&lt;/li&gt;
&lt;li&gt;缩放 scale(sx,sy)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;translate会叠加&lt;/p&gt;
&lt;p&gt;绿色正方形位置经过2次translate后到达了(200,200)。并不是代码里看起来的(150,150)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1f81bf5e-627d-4993-a420-57b1f18edfff')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_1f81bf5e-627d-4993-a420-57b1f18edfff&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1f81bf5e-627d-4993-a420-57b1f18edfff&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1f81bf5e-627d-4993-a420-57b1f18edfff',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1f81bf5e-627d-4993-a420-57b1f18edfff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&quot;canvas&quot;&lt;span&gt;);

    canvas.width&lt;/span&gt;=400&lt;span&gt;;
    canvas.height&lt;/span&gt;=400&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&quot;2d&quot;&lt;span&gt;);

    context.fillStyle&lt;/span&gt;=&quot;red&quot;&lt;span&gt;;
    context.translate(&lt;/span&gt;50,50&lt;span&gt;);
    context.fillRect(&lt;/span&gt;0,0,200,200&lt;span&gt;);

    context.fillStyle&lt;/span&gt;=&quot;green&quot;&lt;span&gt;;
    context.translate(&lt;/span&gt;150,150&lt;span&gt;);
    context.fillRect(&lt;/span&gt;0,0,200,200&lt;span&gt;);
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180322212351619-1083147652.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了避免上述问题，&lt;span&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;是使用图形变换之后，再反向操作把图形变换的结果逆转过来。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('fae058ca-7c39-4a82-81c5-7423efddcf3f')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_fae058ca-7c39-4a82-81c5-7423efddcf3f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fae058ca-7c39-4a82-81c5-7423efddcf3f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('fae058ca-7c39-4a82-81c5-7423efddcf3f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fae058ca-7c39-4a82-81c5-7423efddcf3f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&quot;canvas&quot;&lt;span&gt;);

    canvas.width&lt;/span&gt;=400&lt;span&gt;;
    canvas.height&lt;/span&gt;=400&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&quot;2d&quot;&lt;span&gt;);

    context.fillStyle&lt;/span&gt;=&quot;red&quot;&lt;span&gt;;
    context.translate(&lt;/span&gt;50,50&lt;span&gt;);
    context.fillRect(&lt;/span&gt;0,0,200,200&lt;span&gt;);
    context.translate(&lt;/span&gt;-50,-50);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反向操作&lt;/span&gt;
&lt;span&gt;
    context.fillStyle&lt;/span&gt;=&quot;green&quot;&lt;span&gt;;
    context.translate(&lt;/span&gt;150,150&lt;span&gt;);
    context.fillRect(&lt;/span&gt;0,0,200,200&lt;span&gt;);
    context.translate(&lt;/span&gt;-150,-150);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反向操作&lt;/span&gt;
}  
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180322212807487-1540319853.png&quot; alt=&quot;&quot; width=&quot;235&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3，canvas状态的保存save()和恢复restore()&lt;/h2&gt;
&lt;p&gt;逆转图形变换太麻烦了，canvas提供了一个save()API,保存当前的图形状态，状态包括所有我们设置的状态，自然也包括图形变换的状态。&lt;/p&gt;
&lt;p&gt;在完成图形变换并且具体绘制以后，在最后再调用一次context.restore()。&lt;/p&gt;
&lt;p&gt;restore()和save()是成对出现的，restore()返回在save()时候canvas的所有状态， 这是一个非常好的保持canvas绘图状态的方法，在save()和restore()之间可以随意的更改canvas的状态而不影响后续的绘制效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&quot;canvas&quot;&lt;span&gt;);

    canvas.width&lt;/span&gt;=400&lt;span&gt;;
    canvas.height&lt;/span&gt;=400&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&quot;2d&quot;&lt;span&gt;);

    &lt;span&gt;context.save();&lt;/span&gt;
    context.fillStyle&lt;/span&gt;=&quot;red&quot;&lt;span&gt;;
    context.translate(&lt;/span&gt;50,50&lt;span&gt;);
    context.fillRect(&lt;/span&gt;0,0,200,200&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.translate(-50,-50);//反向操作&lt;/span&gt;
&lt;span&gt;&lt;span&gt;    context.restore();&lt;/span&gt;

    context.save()
    context.fillStyle&lt;/span&gt;=&quot;green&quot;&lt;span&gt;;
    context.translate(&lt;/span&gt;150,150&lt;span&gt;);
    context.fillRect(&lt;/span&gt;0,0,200,200&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; context.translate(-150,-150);//反向操作&lt;/span&gt;
&lt;span&gt;    context.restore();
}   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Note&lt;/span&gt;&lt;/strong&gt;:绘制整体元素，特别是在其中使用图形变换的时候，都应该先save()一下，最终结束绘制时再restore()一下以保证canvas图形绘制的正确。&lt;/p&gt;

&lt;h2&gt;1、使用translate和rotate绘制固定大小星星的星空&lt;/h2&gt;
&lt;p&gt;没有用scale.&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;ctx.translate(x,y);&lt;/p&gt;
&lt;p&gt;ctx.rotate(rot/180*Math.PI);&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e2d76a16-d4d2-413a-b85e-7d0ce337b9ed')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_e2d76a16-d4d2-413a-b85e-7d0ce337b9ed&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e2d76a16-d4d2-413a-b85e-7d0ce337b9ed&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e2d76a16-d4d2-413a-b85e-7d0ce337b9ed',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2d76a16-d4d2-413a-b85e-7d0ce337b9ed&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&lt;span&gt;&quot;canvas&quot;&lt;/span&gt;&lt;span&gt;);

    canvas.width&lt;/span&gt;=800&lt;span&gt;;
    canvas.height&lt;/span&gt;=800&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&lt;span&gt;&quot;2d&quot;&lt;/span&gt;&lt;span&gt;);
    
    context.fillStyle&lt;/span&gt;=&lt;span&gt;&quot;black&quot;&lt;/span&gt;&lt;span&gt;;
    context.fillRect(&lt;/span&gt;0,0&lt;span&gt;,canvas.width,canvas.height);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;200;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r=Math.random()*10+10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x=Math.random()*&lt;span&gt;canvas.width;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y=Math.random()*&lt;span&gt;canvas.height;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a=Math.random()*360&lt;span&gt;;
        drawStar(context,x,y,r,a);
    }
    
}        


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rot顺时针旋转的角度&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawStar(ctx,x,y,R,rot){
    
    ctx.save();

    ctx.translate(x,y);
    ctx.rotate(rot&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;180*Math.PI);
&lt;span&gt;    starPath(ctx);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制在(x,y)大小为R，旋转rot度的五角星&lt;/span&gt;
&lt;span&gt;
    ctx.fillStyle&lt;/span&gt;=&lt;span&gt;&quot;#fb3&quot;&lt;/span&gt;&lt;span&gt;;
    ctx.strokeStyle&lt;/span&gt;=&lt;span&gt;&quot;#fd5&quot;&lt;/span&gt;&lt;span&gt;;
    ctx.lineWidth&lt;/span&gt;=3&lt;span&gt;;
    ctx.lineJoin&lt;/span&gt;=&lt;span&gt;&quot;round&quot;&lt;/span&gt;&lt;span&gt;;

    ctx.fill();
    ctx.stroke();

    ctx.restore();
}


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; starPath(ctx){
    ctx.beginPath();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;角度转弧度：除以180*PI&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
        ctx.lineTo(Math.cos((&lt;/span&gt;18+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI)*20,
            -Math.sin((18+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI)*20);
            ctx.lineTo(Math.cos((54+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI)*0.5*20,
            -Math.sin((54+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI)*0.5*20);
&lt;span&gt;    }
    ctx.closePath();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;效果和上面图片一样。&lt;/p&gt;
&lt;h2&gt;2、scale副作用&lt;/h2&gt;
&lt;p&gt;不仅放在大小，还会放大坐标，边框等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&lt;span&gt;&quot;canvas&quot;&lt;/span&gt;&lt;span&gt;);

    canvas.width&lt;/span&gt;=400&lt;span&gt;;
    canvas.height&lt;/span&gt;=400&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&lt;span&gt;&quot;2d&quot;&lt;/span&gt;&lt;span&gt;);

    context.save();
    context.scale(&lt;/span&gt;1,1&lt;span&gt;);
    context.strokeRect(&lt;/span&gt;10,10,100,100&lt;span&gt;);
    context.restore();

    context.save()
    context.scale(&lt;/span&gt;2,2&lt;span&gt;,);
    context.strokeRect(&lt;/span&gt;10,10,100,100&lt;span&gt;);
    context.restore();

    context.save()
    context.scale(&lt;/span&gt;3,3&lt;span&gt;,);
    context.strokeRect(&lt;/span&gt;10,10,100,100&lt;span&gt;);
    context.restore();
}   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180327072740039-1195443209.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;255&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3， 应用scale绘制星空&lt;/h2&gt;
&lt;p&gt;坐标是通过translate变换的，始终是(0,0)所以scale后还是(0,0)。&lt;/p&gt;
&lt;p&gt;放弃外边框的绘制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('51d62b17-0d86-45b7-9404-6d317c9e53ad')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_51d62b17-0d86-45b7-9404-6d317c9e53ad&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_51d62b17-0d86-45b7-9404-6d317c9e53ad&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('51d62b17-0d86-45b7-9404-6d317c9e53ad',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_51d62b17-0d86-45b7-9404-6d317c9e53ad&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&lt;span&gt;&quot;canvas&quot;&lt;/span&gt;&lt;span&gt;);

    canvas.width&lt;/span&gt;=800&lt;span&gt;;
    canvas.height&lt;/span&gt;=800&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&lt;span&gt;&quot;2d&quot;&lt;/span&gt;&lt;span&gt;);
    
    context.fillStyle&lt;/span&gt;=&lt;span&gt;&quot;black&quot;&lt;/span&gt;&lt;span&gt;;
    context.fillRect(&lt;/span&gt;0,0&lt;span&gt;,canvas.width,canvas.height);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;200;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r=Math.random()*10+10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x=Math.random()*&lt;span&gt;canvas.width;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y=Math.random()*&lt;span&gt;canvas.height;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a=Math.random()*360&lt;span&gt;;
        drawStar(context,x,y,r,a);
    }
    
}        


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rot顺时针旋转的角度&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawStar(ctx,x,y,R,rot){
    
    ctx.save();

    ctx.translate(x,y);
    ctx.rotate(rot&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;180*Math.PI);
&lt;span&gt;    ctx.scale(R,R);

    starPath(ctx);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制在(x,y)大小为R，旋转rot度的五角星&lt;/span&gt;
&lt;span&gt;
    ctx.fillStyle&lt;/span&gt;=&lt;span&gt;&quot;#fb3&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放弃外边框的绘制&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctx.strokeStyle=&quot;#fd5&quot;;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctx.lineWidth=3;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctx.lineJoin=&quot;round&quot;;&lt;/span&gt;
&lt;span&gt;
    ctx.fill();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ctx.stroke();&lt;/span&gt;
&lt;span&gt;
    ctx.restore();
}


&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; starPath(ctx){
    ctx.beginPath();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;角度转弧度：除以180*PI&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
        ctx.lineTo(Math.cos((&lt;/span&gt;18+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI),
            -Math.sin((18+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI));
            ctx.lineTo(Math.cos((54+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI)*0.5,
            -Math.sin((54+i*72)&lt;span&gt;/&lt;/span&gt;180*Math.PI)*0.5);
&lt;span&gt;    }
    ctx.closePath();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;星星没有外边框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180327073748834-194598282.png&quot; alt=&quot;&quot; width=&quot;305&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图形变换的实质是对图形的顶点坐标的再计算。计算过程通过变换矩阵来完成。&lt;/p&gt;
&lt;p&gt;二维的变换矩阵是3*3，三维的变换矩阵是4*4。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/315302/201803/315302-20180327074052562-794770679.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用transform(a,b,c,d,e,f)设置变换矩阵每次设置是在之前的基础上设置的。&lt;/p&gt;
&lt;p&gt;可以用setTransform(a,b,c,d,e,f))忽略掉之前所有的变换矩阵。先设置为单位矩阵再变换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById(&lt;span&gt;&quot;canvas&quot;&lt;/span&gt;&lt;span&gt;);

    canvas.width&lt;/span&gt;=400&lt;span&gt;;
    canvas.height&lt;/span&gt;=400&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context=canvas.getContext(&lt;span&gt;&quot;2d&quot;&lt;/span&gt;&lt;span&gt;);

    context.fillStyle&lt;/span&gt;=&lt;span&gt;&quot;red&quot;&lt;/span&gt;&lt;span&gt;;
    context.strokeStyle&lt;/span&gt;=&lt;span&gt;&quot;#058&quot;&lt;/span&gt;&lt;span&gt;;
    context.lineWidth&lt;/span&gt;=5&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;///////////////////////////&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a c e&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b d f &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0 0 1&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;///////////////////////////&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a,d 水平，垂直缩放&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b,c 水平，垂直倾斜&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e,f 水平，垂直位移&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;///////////////////////////&lt;/span&gt;
&lt;span&gt;    context.save();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; context.transform(1,0,0,1,0,0);&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;transform级联操作&lt;/span&gt;
    context.transform(1,0,0,1,50,100&lt;span&gt;);
    context.transform(&lt;/span&gt;2,0,0,1.5,0,0&lt;span&gt;);
    context.transform(&lt;/span&gt;1,-0.2,-0.2,1,0,0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setTransform()只使用当前变换&lt;/span&gt;
    context.setTransform(1,0,0,1,100,100&lt;span&gt;);
    context.fillRect(&lt;/span&gt;50,50,100,100&lt;span&gt;);
    context.strokeRect(&lt;/span&gt;50,50,100,100&lt;span&gt;);
    context.restore();
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这部分内容和css3的动画的内容本质都是一样的，都是图形学的内容。&lt;/p&gt;
&lt;p&gt;css3动画可以参考我之前的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/starof/p/4560076.html&quot;&gt;css3中变形与动画（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/starof/p/4582367.html&quot;&gt;css3中变形与动画（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/starof/p/4585324.html&quot;&gt;css3中变形与动画（三）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文作者&lt;a href=&quot;http://www.cnblogs.com/starof/&quot; target=&quot;_blank&quot;&gt;starof&lt;/a&gt;,因知识本身在变化，作者也在不断学习成长，文章内容也不定时更新，为避免误导读者，方便追根溯源，请诸位转载注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 星空和图形变换&quot; href=&quot;http://www.cnblogs.com/starof/p/8626422.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/starof/p/8626422.html&lt;/a&gt; 有问题欢迎与我讨论，共同进步。 &lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 13:39:00 +0000</pubDate>
<dc:creator>starof</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/starof/p/8626422.html</dc:identifier>
</item>
<item>
<title>c# 基于FTP协议的简易软件自动升级程序 - 奚云刀</title>
<link>http://www.cnblogs.com/vice/p/8659817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vice/p/8659817.html</guid>
<description>&lt;p&gt;最近在重写了一个老的产品条码扫描程序，客户端数越有30个，因为经常有更新，C/S维护非常不方便，所以做一个自动更新程序特别有必要。&lt;/p&gt;
&lt;p&gt;在网上随便找了找自动更新的方案，大多使用VS的发布/更新功能，不太喜欢此方案，觉得太麻烦，然后自己初步琢磨了一下如下方案。&lt;/p&gt;
&lt;p&gt;现在比较喜欢的编程方式，先画图。&lt;/p&gt;
&lt;h3&gt;软件更新流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686853/201803/686853-20180327191951881-869067441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;安装包的制作&lt;/h3&gt;
&lt;p&gt;为了简单，采用了自解压压缩包的方式制作更新包，将整个新程序包打包为一个自解压压缩包。&lt;/p&gt;
&lt;p&gt;以下是我的自解压包的参数设置，怎样制作自解压包网上有很多教程，可以自己去搜索。&lt;/p&gt;
&lt;p&gt;常规-解压路径：&quot;c:\barcodeSys&quot;&lt;br/&gt;设置-解压后运行：&quot;c:\barcodeSys\updateLog.txt&quot;&lt;br/&gt;模式：隐藏启动对话框。&lt;br/&gt;高级：添加快捷方式到桌面&lt;br/&gt;源文件：&quot;c:\barcodeSys\BarcodeMain.exe&quot;&lt;br/&gt;快捷方式名：条码扫描程序&lt;br/&gt;更新：解压替换、覆盖所有。&lt;/p&gt;
&lt;h3&gt;制作更新程序&lt;/h3&gt;
&lt;p&gt;因为软件在更新时Update程序是一直在运行的，这样在自解压包解压时就会无法替换更新程序，所以将Update程序作为一个单独的窗体程序来做，由主程序启动时调用。&lt;/p&gt;
&lt;p&gt;制作更新程序前，首先解决怎样判断是否存在最新版本的问题，我采用FTP服务器上新建一个文本文档名称为SvrVer.txt，内容为最新版本号，本地程序文件夹中建立一个文本文档名称为Version，内容为本地程序版本号。方法检查服务器版本号是否与本地版本一致，如果一致则表示不需要更新，否则相反，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686853/201803/686853-20180327194129755-189960298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下为更新程序下载文件部分的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　　long&lt;/span&gt; fileSize = helper.GetFileSize(dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Release.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);   //获得更新程序文件大小
                fileSizes &lt;/span&gt;=&lt;span&gt; fileSize;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileSize &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    updateLabelDelegate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发现最新版本&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ serVer + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;！文件大小:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + fileSize+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字节&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); //更新界面label控件的委托
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; readSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FileStream fs = &lt;span&gt;new&lt;/span&gt; FileStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Release.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileMode.Create))
                    {
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ftp://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ftpAddress + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+dir+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Release.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        Console.WriteLine(url);
                        FtpWebRequest request &lt;/span&gt;= (FtpWebRequest)FtpWebRequest.Create(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(url));
                        request.Credentials &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetworkCredential(ftpUserName, ftpPassword);
                        request.Method &lt;/span&gt;=&lt;span&gt; WebRequestMethods.Ftp.DownloadFile; ;
                        Console.WriteLine(request);
                        request.ContentOffset &lt;/span&gt;=&lt;span&gt; fs.Length;
                        updateLabelDelegate(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在下载新版本...  0字节/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + fileSize + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字节&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);　　
                        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FtpWebResponse response =&lt;span&gt; (FtpWebResponse)request.GetResponse())
                        {
                            fs.Position &lt;/span&gt;=&lt;span&gt; fs.Length;
                            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = response.GetResponseStream().Read(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
                            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                            {
                                fs.Write(buffer, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, count);
                                count &lt;/span&gt;= response.GetResponseStream().Read(buffer, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
                                readSize &lt;/span&gt;+=&lt;span&gt; count;
                                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; pa = (((&lt;span&gt;double&lt;/span&gt;)readSize / (&lt;span&gt;double&lt;/span&gt;)fileSizes) * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                                updateProgDelegate((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)pa) ;  //更新进度条的委托
                                UpdateUILabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;正在下载更新...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ (readSize) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字节/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (fileSize) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字节&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                                Application.DoEvents();
                            }
                            UpdateUILabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下载完成，正在安装新版本，请稍等...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (fileSize) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字节/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (fileSize) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;字节&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            updateProgDelegate(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                            response.GetResponseStream().Close();
                        }
                    }
                    Process p &lt;/span&gt;= Process.Start(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Release.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);   //下载完成后调用自解压包
                    p.WaitForExit();    //等待自解压包解压完成
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　　　　　　　　p.StartInfo.FileName = &quot;BarcodeMain.exe&quot;;//启动主程序&lt;br/&gt;　　　　　　　　　　　　　p.StartInfo.Arguments = &quot;update&quot;;//传递主启动程序的参数，以免启动主程序后再次启动更新程序&lt;br/&gt;　　　　　　　　　　　　　p.Start();//启动&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;                    this&lt;span&gt;.Close();       //关闭更新程序窗口&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;主程序的部分小修改&lt;/h3&gt;
&lt;p&gt;因为每次启动时主程序时会调用Update程序，同时关闭自身进程以准备更新，所以需要在主程序里做一些小事情，否则陷入启动主程序-启动更新程序-启动主程序的就无限循环中了。&lt;/p&gt;
&lt;p&gt;1、修改主程序入口Main方法，增加参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        [STAThread]
        static void Main(string[] arg)  //接受参数
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Index(arg));  //传递给主程序窗体的构造函数
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、主程序增加带参数的构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        private string[] targ ;  //接收的参数
        public Index()
        {
            InitializeComponent();
        }
        public Index(string[] arg)  //带参数的构造函数
        {
            InitializeComponent();
            targ = arg;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、判断是否是否带参数启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//检查执行参数&lt;br/&gt;　　        private static System.Diagnostics.Process p;&lt;br/&gt;if (targ.Length==0)    //如果没有传递参数，则调用update程序
            {
                if (p == null)
                {
                    p = new System.Diagnostics.Process();
                    p.StartInfo.FileName = &quot;UpdatePrg.exe&quot;;
                    p.Start();
                    Application.Exit();
                }
                else 
                {
                    if (p.HasExited) //是否正在运行
                    {
                        p.Start();
                    }
                }
                p.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Normal;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;最终的运行效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686853/201803/686853-20180327200406560-624064743.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;最后推荐一个绿色版比较好用的简易FTP软件 Quick Easy FTP Server，足以满足更新所用。&lt;/h3&gt;
</description>
<pubDate>Tue, 27 Mar 2018 12:05:00 +0000</pubDate>
<dc:creator>奚云刀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vice/p/8659817.html</dc:identifier>
</item>
<item>
<title>【源码分析】你必须知道的string.IsNullOrEmpty &amp;&amp; string.IsNullOrWhiteSpace - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8657579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8657579.html</guid>
<description>&lt;p&gt;之前自信撸码时踩了一次小坑，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private static void AppServer_NewMessageReceived(WebSocketSession session, string value)
        {
            if (string.IsNullOrEmpty(value))
             {
                return;
             }
            value = HttpUtility.UrlDecode(value);                    
            SuperSocketTemp&amp;lt;string&amp;gt; model = JsonConvert.DeserializeObject&amp;lt;SuperSocketTemp&amp;lt;string&amp;gt;&amp;gt;(value);          
             //具体业务...
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这段代码在测试环境抛错，说起来全是泪啊。这段代码的具体业务场景是Websocket即时通讯接收来自客户端的消息，消息以json字符串的形式传输。首先判断是否空字符串，如果不是，为了防止乱码进行Url解码，然后反序列化消息解析成需要的数据格式，最后执行具体的业务操作。&lt;/p&gt;
&lt;p&gt;测试环境抛的错是万恶的“未将对象引用到对象的实例”，很简单就可以定位到问题的所在——反序列化失败了，只要在序列化之后执行具体业务逻辑之前加上非空判断就可以解决掉这个问题。这也怪自己思维还不够严密，没有养成防御性编码的习惯。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private static void AppServer_NewMessageReceived(WebSocketSession session, string value)
        {
            if (string.IsNullOrEmpty(value))
             {
                return;
             }
            value = HttpUtility.UrlDecode(value);                    
            SuperSocketTemp&amp;lt;string&amp;gt; model = JsonConvert.DeserializeObject&amp;lt;SuperSocketTemp&amp;lt;string&amp;gt;&amp;gt;(value);
            if(model==null)
            {
                return;
            }   
             //具体业务...
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过日志分析反序列失败的原因，日志中记录的消息是空白的，但是代码中明明有&lt;code&gt;string.IsNullOrEmpty(value)&lt;/code&gt;的判断，为啥还会出现空的情况呢？仔细一看，原来是多个连续的空格，吐血。于是乎立马把&lt;code&gt;string.IsNullOrEmpty(value)&lt;/code&gt;改为&lt;code&gt;string.IsNullOrWhiteSpace(value)&lt;/code&gt;,当value是多个连续的空格时，直接返回，不会继续往下执行。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private static void AppServer_NewMessageReceived(WebSocketSession session, string value)
        {
            if (string.IsNullOrWhiteSpace(value))
             {
                return;
             }
            value = HttpUtility.UrlDecode(value);                    
            SuperSocketTemp&amp;lt;string&amp;gt; model = JsonConvert.DeserializeObject&amp;lt;SuperSocketTemp&amp;lt;string&amp;gt;&amp;gt;(value);
            if(model==null)
            {
                return;
            }   
             //具体业务...
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们都知道，string.IsNullOrEmpty方法是判断字符串是否为：null或者string.Empty；string.IsNullOrWhiteSpace方法是判断null或者所有空白字符，功能相当于string.IsNullOrEmpty和str.Trim().Length总和。那么具体方法内部是怎么实现的呢？我们可以通过ILSpy反编译窥探一番。&lt;/p&gt;

&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// string
/// &amp;lt;summary&amp;gt;Indicates whether the specified string is null or an &amp;lt;see cref=&quot;F:System.String.Empty&quot; /&amp;gt; string.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;value&quot;&amp;gt;The string to test. &amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;true if the &amp;lt;paramref name=&quot;value&quot; /&amp;gt; parameter is null or an empty string (&quot;&quot;); otherwise, false.&amp;lt;/returns&amp;gt;
[__DynamicallyInvokable]
public static bool IsNullOrEmpty(string value)
{
    return value == null || value.Length == 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;string.IsNullOrEmpty实现很简单，无非就是判断传入的字符串参数，当是null或者空字符串string.Empty就返回true;否则返回false。&lt;/p&gt;

&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// string
/// &amp;lt;summary&amp;gt;Indicates whether a specified string is null, empty, or consists only of white-space characters.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;value&quot;&amp;gt;The string to test.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;true if the &amp;lt;paramref name=&quot;value&quot; /&amp;gt; parameter is null or &amp;lt;see cref=&quot;F:System.String.Empty&quot; /&amp;gt;, or if &amp;lt;paramref name=&quot;value&quot; /&amp;gt; consists exclusively of white-space characters. &amp;lt;/returns&amp;gt;
[__DynamicallyInvokable]
public static bool IsNullOrWhiteSpace(string value)
{
    if (value == null)
    {
        return true;
    }
    for (int i = 0; i &amp;lt; value.Length; i++)
    {
        if (!char.IsWhiteSpace(value[i]))
        {
            return false;
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;string.IsNullOrWhiteSpace的实现就稍微复杂一些，首先当传入的字符串参数为null时肯定返回true;如果不是就开始遍历字符串，取出字符执行char.IsWhiteSpace(value[i])方法，如果char.IsWhiteSpace(value[i])方法返回false,就终止遍历，返回fasle;否则返回true。所以char.IsWhiteSpace方法应该判断的是传入的字符是否为空字符，是空字符返回true,不是返回false。我们可以进入char.IsWhiteSpace方法看一下具体实现：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// char
/// &amp;lt;summary&amp;gt;Indicates whether the specified Unicode character is categorized as white space.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;c&quot;&amp;gt;The Unicode character to evaluate. &amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;true if &amp;lt;paramref name=&quot;c&quot; /&amp;gt; is white space; otherwise, false.&amp;lt;/returns&amp;gt;
[__DynamicallyInvokable]
public static bool IsWhiteSpace(char c)
{
    if (char.IsLatin1(c))
    {
        return char.IsWhiteSpaceLatin1(c);
    }
    return CharUnicodeInfo.IsWhiteSpace(c);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现方法内部判断了char.IsLatin1(c)，符合的话执行char.IsWhiteSpaceLatin1(c),看不明白，继续往下走。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// char
private static bool IsLatin1(char ch)
{
    return ch &amp;lt;= 'ÿ';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;'ÿ'&lt;/strong&gt;是什么鬼？看不懂。但是char.IsWhiteSpace方法调用了CharUnicodeInfo.IsWhiteSpace(c)方法，那应该是和Unicode有关。而且到了char字符的级别上，更加可以肯定和Unicode编码有关。从&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8&quot;&gt;Unicode字符列表&lt;/a&gt;搜索&lt;strong&gt;'ÿ'&lt;/strong&gt;，果然搜到了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180327/9edbhaldF0.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现&lt;strong&gt;'ÿ'&lt;/strong&gt;是拉丁字母辅助的最后一个字符，再往后的的字符基本不会出现，所以在大多数情况下&lt;code&gt;ch &amp;lt;= 'ÿ'&lt;/code&gt;可以满足的。当满足&lt;code&gt;ch &amp;lt;= 'ÿ'&lt;/code&gt;时执行下面的方法：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// char
private static bool IsWhiteSpaceLatin1(char c)
{
    return c == ' ' || (c &amp;gt;= '\t' &amp;amp;&amp;amp; c &amp;lt;= '\r') || c == '\u00a0' || c == '\u0085';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IsWhiteSpaceLatin1(char c)负责判断字符c是否是空白字符。&lt;/p&gt;
&lt;p&gt;① &lt;code&gt;c == ' '&lt;/code&gt; 很好理解，判断c是不是空格字符。对应下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180327/ij0k3091Aj.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② &lt;code&gt;c &amp;gt;= '\t' &amp;amp;&amp;amp; c &amp;lt;= '\r'&lt;/code&gt; 对照&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8&quot;&gt;Unicode字符列表&lt;/a&gt;就可以理解。下图红框圈出的5个字符都认定为空白字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180327/A3CaFCCflf.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180327/j6KGBJE39I.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③ &lt;code&gt;c == '\u00a0'&lt;/code&gt; 如下图被认定为空白字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180327/2FEcFDcDJ0.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;④ &lt;code&gt;c == '\u0085'&lt;/code&gt; 如下图被认定为空白字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p66d6e5qt.bkt.clouddn.com/blog/180327/Lklm2e60BA.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;满足①②③④其中任意一个，便会被判定为空白字符。&lt;/p&gt;
&lt;p&gt;那么假设char.IsLatin1(c)返回false呢？此时执行CharUnicodeInfo.IsWhiteSpace(c)。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// System.Globalization.CharUnicodeInfo
internal static bool IsWhiteSpace(char c)
{
    switch (CharUnicodeInfo.GetUnicodeCategory(c))
    {
    case UnicodeCategory.SpaceSeparator:
    case UnicodeCategory.LineSeparator:
    case UnicodeCategory.ParagraphSeparator:
        return true;
    default:
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CharUnicodeInfo.GetUnicodeCategory(c)会返回一个UnicodeCategory枚举类型。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// System.Globalization.CharUnicodeInfo
/// &amp;lt;summary&amp;gt;Gets the Unicode category of the specified character.&amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;ch&quot;&amp;gt;The Unicode character for which to get the Unicode category. &amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;A &amp;lt;see cref=&quot;T:System.Globalization.UnicodeCategory&quot; /&amp;gt; value indicating the category of the specified character.&amp;lt;/returns&amp;gt;
[__DynamicallyInvokable]
public static UnicodeCategory GetUnicodeCategory(char ch)
{
    return CharUnicodeInfo.InternalGetUnicodeCategory((int)ch);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CharUnicodeInfo是一个静态类，根据MSDN说明，Unicode标准定义了许多Unicode字符类别。例如，一个字符可能被分类为大写字母，小写字母，小数位数字，字母数字，段落分隔符，数学符号或货币符号。所述UnicodeCategory枚举定义了可能的字符的类别。&lt;/p&gt;
&lt;p&gt;使用CharUnicodeInfo类来获取特定字符的UnicodeCategory值。该CharUnicodeInfo类定义了返回下面的Unicode字符值的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符或代理对所属的特定类别。返回的值是UnicodeCategory枚举的成员。&lt;/li&gt;
&lt;li&gt;数字值。仅适用于数字字符，包括分数，下标，上标，罗马数字，货币分子，圈出的数字和脚本特定的数字。&lt;/li&gt;
&lt;li&gt;数字值。适用于可与其他数字字符组合的数字字符，以表示编号系统中的整数。&lt;/li&gt;
&lt;li&gt;十进制数字值。仅适用于表示小数点（基10）系统中的十进制数字的字符。十进制数字可以是十个数字之一，从零到九。这些字符是UnicodeCategory的成员DecimalDigitNumber类别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当GetUnicodeCategory方法返回的枚举值是&lt;strong&gt;UnicodeCategory.SpaceSeparator&lt;/strong&gt;、&lt;strong&gt;UnicodeCategory.LineSeparator&lt;/strong&gt;、&lt;strong&gt;UnicodeCategory.ParagraphSeparator&lt;/strong&gt;其中任意之一，则判定为空白字符，返回true。&lt;/p&gt;

&lt;p&gt;踩坑不要紧，要紧的是要知道为什么会有这个坑。&lt;/p&gt;
&lt;p&gt;软件80%的bug都拜“未将对象引用到对象的实例”所赐，要养成防御性编码的好习惯。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。&lt;/p&gt;
&lt;p&gt;如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 11:36:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8657579.html</dc:identifier>
</item>
<item>
<title>漫谈Java IO之基础篇 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/8659436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/8659436.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java的网络编程如果不是专门搞服务器性能开发或者消息分发，几乎可能涉及不到。但是它却是面试找工作必问的一个知识点，涵盖的知识体系也非常广泛，从Java底层IO原理到操作系统内核组成，再到网络TCP、UDP、HTTP的应用实践....因此，即便是职场多年的老油条，仍然需要时刻复习，更别提我这种只有七秒钟记忆的小菜鸟了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java网络IO的演化，从最开始JDK1.4之前是基于阻塞的IO；发展到1.4发布后的Nio提供了selector多路复用的机制以及channel和buffer，再到1.7的NIO升级提供了真正的异步api；再发展到后来崭露头角的MINA和Netty。因此整个网络IO编程的学习整理，也会按照下面的几个步骤来进行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/xing901022/p/8659436.html&quot;&gt;网络IO的基本知识与概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;普通IO以及BIO服务器&lt;/li&gt;
&lt;li&gt;NIO的使用与服务器Hello world&lt;/li&gt;
&lt;li&gt;Netty入门与服务器Hello world&lt;/li&gt;
&lt;li&gt;Netty深入浅出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天就简单的了解下网络IO需要具备的基本知识与概念。&lt;/p&gt;

&lt;p&gt;经常听人提起，同步阻塞服务器或者异步非阻塞服务器，网上有很多的文章针对这个概念作出了讲解，每个人理解的貌似都不太一样。最容易把异步和非阻塞搞混....我这里简单的说下自己的理解：&lt;/p&gt;
&lt;p&gt;同步synchronous、异步asynchronous，他们的区别就是发起任务后，本身的一个状态——如果是一直等待结果，那就是同步；如果立即返回，并采用其他的方式得到结果就是异步（比如，状态、通知、回调）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1522156208424&amp;amp;di=9f7e47066163c83fdc7f9b46b751d0b7&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimg3.utuku.china.com%2F500x0%2Fnews%2F20161229%2F5f8a6ce9-e0d0-4efe-89ca-55198f5e7631.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在过去科技不发达的时候，银行取钱都是排队的模式。想取钱就得去排队，直到轮到自己，这就是同步；&lt;/li&gt;
&lt;li&gt;现在去银行一般直接叫号，然后去休息位置休息打游戏，登到轮到自己的时候，会有通知，这就是异步；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;阻塞blocking、非阻塞non-blocking，则聚焦的是CPU在等待结果的过程中的状态。比如前面的例子，排队的过程中什么也不做就是阻塞；一边排队，一遍玩王者荣耀就是非阻塞的。&lt;/p&gt;

&lt;p&gt;这个概念就涉及操作系统了，为了保护操作系统的安全，会将内存分为&lt;strong&gt;用户空间&lt;/strong&gt;和&lt;strong&gt;内核空间&lt;/strong&gt;两个部分。如果用户想要操作内核空间的数据，需要把数据从内和空间拷贝到用户控件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-182426.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;服务器接收客户端发过来的请求，想要进行处理，大致会经过下面几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务器的网络驱动接收到消息，去内核上申请空间；并等待完整的数据包到达（有可能分组传送，没传完...），复制到内核空间；&lt;/li&gt;
&lt;li&gt;数据从内核空间拷贝到用户空间&lt;/li&gt;
&lt;li&gt;用户程序进行处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此大致可以把接收消息理解为两个阶段：1. 等待数据到达 2. 拷贝到用户空间&lt;/p&gt;
&lt;p&gt;了解了这个过程，就能明白为什么会出现经典的5大网络模型了.&lt;/p&gt;

&lt;p&gt;这几个网络模型还是学生时代的时候也看过，但是理解的不够透彻，也不知道到底有什么区别。最近网上也看过不少的文章，发现有一些文章引用的小例子不错，能很简单的了解这些模型的意思。所以我这边也借鉴一下：&lt;/p&gt;
&lt;p&gt;在大连高新万达后面有一条叫做金街的小吃街，有一个露天的路边摊叫做“小红旗”，主要是做炸臭豆腐和冷面，然后用冷面把臭豆腐卷起来，刷上臭烘烘的酱料，非常好吃。每次路过都能看到不少人在排队，队伍长的有种想让人辞职加盟的感觉....基本上排个队伍都得半个小时-一个小时吧。&lt;/p&gt;
&lt;p&gt;这个排队的过程，明显就是上面所说的同步阻塞模式....那我这边就设想下，如果小红旗的生意做大了，可以怎么发展？正好套用下网络模型的概念...&lt;/p&gt;
&lt;h2 id=&quot;同步阻塞io&quot;&gt;1. 同步阻塞IO&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-182924.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就不详细说了，排队的过程哪也去不了，如果你还没有带手机，排队的过程中就只能干瞪眼了。这就是很明显的同步+阻塞模式。&lt;/p&gt;
&lt;h2 id=&quot;同步非阻塞io&quot;&gt;2. 同步非阻塞IO&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-182951.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果小红旗的老板搞了一个点菜机，来点单的顾客把自己想吃的划上，然后等着老板去做，自己可以在这一个小时的时间里去周围商场溜达下。但是由于没有任何通信方式，只能不停的回来问老板，做好了没有。&lt;/p&gt;
&lt;p&gt;回来询问的时间是由顾客自己掌控的，如果时间很短，那么可以尽量早的知道臭豆腐炸好没，但是也会影响逛街的体验；如果时间很长，有可能臭豆腐早就做好了..结果放的时间长了，反而不好吃了。&lt;/p&gt;
&lt;p&gt;因此非阻塞IO基于状态轮训的方式，虽然能让程序在等待的过程中做点其他的事情，但是频繁的切换运行程序，反而会造成很大的压力。&lt;/p&gt;
&lt;h2 id=&quot;io多路复用事件驱动&quot;&gt;3. IO多路复用/事件驱动&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-183022.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小红旗老板升级了系统，放弃使用点菜机，改用麦当劳那种点餐大屏。同样是点餐，但是一个大屏里面显示了很多人的臭豆腐进度，即节省了资源，也避免大家不停的询问。&lt;/p&gt;
&lt;p&gt;其实Nio活着Netty就是基于这种模式，一个线程就可以监听很多IO操作，这样在IO等待上就高效多了。具体实现是依赖于操作系统的，windows和linux都有不同的实现方式。最初的select或者poll，都有并发数的限制，并且NIO的select还有空轮训的问题；epool则突破了连接数的限制，一个线程就可以监听大量的IO操作。这个感兴趣的朋友，可以深入了解下select、poll、epool的原理。&lt;/p&gt;
&lt;h2 id=&quot;信号驱动io&quot;&gt;4. 信号驱动IO&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-183038.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小红旗老板又时髦了，搞了一个升级版的美味不用等。顾客基于微信小程序点菜，菜做好了自动提醒顾客取餐....这个提醒的过程，就像是发射了一个特殊的信号。&lt;/p&gt;
&lt;p&gt;不过UNIX网络编程里面的信号驱动，可没这么简单，这个信号是依赖于操作系统底层的，捕获信号或者处理都很麻烦，所以现在应用的也不是很广泛。&lt;/p&gt;
&lt;h2 id=&quot;异步非阻塞io&quot;&gt;5. 异步非阻塞IO&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-183107.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一对小情侣李雷和韩梅梅，韩梅梅口味很重，特别喜欢吃臭豆腐，但是李雷完全不感兴趣，闻到味道就想吐。于是李雷就跟韩梅梅约定，让韩梅梅自己去吃，李雷跑到旁边的咖啡厅喝咖啡。韩梅梅自己去排队买臭豆腐，买完顺便吃完，然后回来找李雷....&lt;/p&gt;
&lt;p&gt;这个过程就是异步非阻塞的，消息的等待和处理都在服务器端完成，用户只要最后接收到消息处理完的通知就行了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180327-183131.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结来说，这几种网络模型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;同步阻塞：强调的是我要做！ —— 别的啥也别说，就是要做！&lt;/li&gt;
&lt;li&gt;同步非阻塞：强调的是我想做！ —— 在想的过程中，干点其他的事情更好。&lt;/li&gt;
&lt;li&gt;异步非阻塞：强调的是我做完了！—— 等得到结果通知的时候，工作已经做完了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中细节，还需慢慢体会...后面的文章将会挑几个模型做代码的演示，更多内容还请持续关注。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://ifeve.com/java-nio-all/&quot;&gt;并发编程网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/u010412719/article/details/78107741&quot;&gt;Netty源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/c5068caab217&quot;&gt;Netty源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/0d0eece6d467&quot;&gt;Netty源码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jeakeven/p/5435916.html&quot;&gt;IO多路复用之select、poll、epoll&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/486b0965c296&quot;&gt;聊聊Linux五种IO模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/aed6067eeac9&quot;&gt;聊聊同步、异步、阻塞、非阻塞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://netty.io/&quot;&gt;Netty官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;amp;mid=2247486463&amp;amp;idx=1&amp;amp;sn=50e44aec22ae3077b65061039a174f09&amp;amp;source=41#wechat_redirect&quot;&gt;一篇文章，读懂Netty的高性能架构之道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/xinghalo/JDK-Learning&quot;&gt;代码示例分享&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 27 Mar 2018 11:05:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/8659436.html</dc:identifier>
</item>
<item>
<title>详细分析du和df的统计结果为什么不一样 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8659301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8659301.html</guid>
<description>&lt;p&gt;今天有个人问我du和df的统计结果为什么会不同。给他解析了一番，后来想想还是写篇文章从原理上来分析分析。&lt;/p&gt;
&lt;p&gt;我们常常使用du和df来获取目录或文件系统已占用空间的情况。但它们的统计结果是不一致的，大多数时候，它们的结果相差不会很大，但有时候它们的统计结果会相差非常大。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;##### df的统计结果&lt;/span&gt;
[root@xuexi ~]&lt;span class=&quot;hljs-preprocessor&quot;&gt;# df -hT &lt;/span&gt;
Filesystem          Type   Size  Used Avail Use% Mounted on
/dev/sda2           ext4    &lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;1.7&lt;/span&gt;G   &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;% /
tmpfs               tmpfs  &lt;span class=&quot;hljs-number&quot;&gt;491&lt;/span&gt;M     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;491&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;% /dev/shm
/dev/sda1           ext4   &lt;span class=&quot;hljs-number&quot;&gt;239&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;68&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;159&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;% /boot


&lt;span class=&quot;hljs-preprocessor&quot;&gt;##### du对根目录的统计结果&lt;/span&gt;
[root@xuexi ~]&lt;span class=&quot;hljs-preprocessor&quot;&gt;# du -sh /  2&amp;gt;/dev/null&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;244&lt;/span&gt;G    /
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;df中&quot;/&quot;的使用空间是1.7G，但是du的结果却是244G。这里du的统计结果大于df。&lt;/p&gt;
&lt;p&gt;再看看对/boot分区的统计结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
Filesystem     Type  Size  Used Avail Use% Mounted &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;
/dev/sda1      ext4  &lt;span class=&quot;hljs-number&quot;&gt;239&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;68&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;159&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;% /boot

&lt;span class=&quot;hljs-number&quot;&gt;66&lt;/span&gt;M     /boot
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;du的结果是66M，df的结果是68M，相差不大，但df的结果大于du。&lt;/p&gt;

&lt;h2 id=&quot;1-&quot;&gt;1.文件存储和删除的底层过程&lt;/h2&gt;
&lt;p&gt;这里简单说明下文件系统相关的底层机制，详细的内容参见：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7016077.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ext文件系统机制&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先说明下文件是怎么存储到文件系统中的。假如要存储a.txt到/tmp目录下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180327171608567-1495159252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当a.txt文件要存储到/tmp下时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).首先从inode table中找一个空闲的inode号分配给a.txt，例如2222。再将inode map(imap)中2222这个inode号标记为已使用。&lt;/li&gt;
&lt;li&gt;(2).在/tmp的data block中添加一条a.txt文件的记录。该记录中包括一个指向inode号的指针，例如&quot;0x2222&quot;。&lt;/li&gt;
&lt;li&gt;(3).然后从block map(bmap)中找出空闲的data block，并开始将a.txt中的数据写入到data block中。每写一段空间(每次分配一段空间)就从bmap中找一次空闲的data block，直到存完所有数据。&lt;/li&gt;
&lt;li&gt;(4).设置inode table中关于2222这条记录的data block指针，通过该指针可以找到a.txt使用了哪些data block。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当要删除a.txt文件时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).在inode table中删除指向a.txt的data block指针。这里只要一删除，外界就找不到a.txt的数据了。但是这个文件还存在，只是它是被&quot;损坏&quot;的文件，因为没有任何指针指向数据块。&lt;/li&gt;
&lt;li&gt;(2).在imap中将2222的inode号标记为未使用。于是这个inode号就被释放，可以被后续的文件重用。&lt;/li&gt;
&lt;li&gt;(3).删除父目录/tmp的data block中关于a.txt的记录。这里只要一删除，外界就看不到也找不到这个文件了。&lt;/li&gt;
&lt;li&gt;(4).在bmap中将a.txt占用的block标记为未使用。这里被标记为未使用后，这些data block就可以被后续文件覆盖重用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑一种情况，当一个文件被删除时，但此时还有进程在使用这个文件，这时是怎样的情况呢？&lt;span&gt;&lt;strong&gt;外界是看不到也找不到这个文件的，所以删除的过程已经进行到了第(3)步。但进程还在使用这个文件的数据，也能找到这个文件的数据，是因为进程在加载这个文件的时候就已经获取到了该文件占用哪些data block，虽然删除了文件，但bmap中这些data block还没有标记为未使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-du-&quot;&gt;2.du统计的原理&lt;/h2&gt;
&lt;p&gt;du是通过stat命令来统计每个文件(包括子目录)的空间占用总和。因为会对每个涉及到的文件使用stat命令，所以速度较慢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.如果统计目录下挂载了其他文件系统，那么也会对这个文件系统进行统计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如&quot;du -sh /&quot;的时候，会统计所有分区的文件，包括挂载上来的。正如本文开头统计的&quot;/&quot;一样，du的结果是244G，明显比df统计的结果大，就是因为将某个分区挂载到了/mnt目录下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;##### df的统计结果&lt;/span&gt;
[root@xuexi ~]&lt;span class=&quot;hljs-preprocessor&quot;&gt;# df -hT &lt;/span&gt;
Filesystem          Type   Size  Used Avail Use% Mounted on
/dev/sda2           ext4    &lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;1.7&lt;/span&gt;G   &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;% /
tmpfs               tmpfs  &lt;span class=&quot;hljs-number&quot;&gt;491&lt;/span&gt;M     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;491&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;% /dev/shm
/dev/sda1           ext4   &lt;span class=&quot;hljs-number&quot;&gt;239&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;68&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;159&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;% /boot


&lt;span class=&quot;hljs-preprocessor&quot;&gt;##### du对根目录的统计结果&lt;/span&gt;
[root@xuexi ~]&lt;span class=&quot;hljs-preprocessor&quot;&gt;# du -sh /  2&amp;gt;/dev/null&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;244&lt;/span&gt;G    /
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.如果文件被删除，即使被其他进程引用了，du命令也无法对其统计。因为&lt;/strong&gt;stat命令找不到这个文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.可以跨分区统计某些你想统计的文件大小总和。因为它们都能被stat找到并统计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;统计Linux下所有img文件的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;M     /boot/initramfs-&lt;span class=&quot;hljs-number&quot;&gt;2.6&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;504&lt;/span&gt;.el6.x86_64.img
&lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;M     /mnt/linux工具/cirros-&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;3.4&lt;/span&gt;-x86_64-disk.img
&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;M     total
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里统计的两个img文件就是在不同分区内的。&lt;/p&gt;

&lt;h2 id=&quot;3-df-&quot;&gt;3.df统计的原理&lt;/h2&gt;
&lt;p&gt;df是读取每个分区的superblock来获取空闲数据块、已使用数据块，从而计算出空闲空间和已使用空间，因此df统计的速度极快(superblock才占用1024字节)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.当某个文件系统下挂载了其他分区，df不会把这个分区也统计进去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这很容易理解，因为df读取的是各自分区的superblock，即使分区1挂载在分区0的目录下，df统计分区0的时候，也只能读取分区0的superblock。&lt;/p&gt;
&lt;p&gt;例如，下面的/mnt、/boot都没有统计在&quot;/&quot;中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
Filesystem          Type   Size  Used Avail Use% Mounted &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;hljs-regexp&quot;&gt;/dev/sda2           ext4    18G  1.7G   15G  11% /&lt;/span&gt;
tmpfs               tmpfs  &lt;span class=&quot;hljs-number&quot;&gt;491&lt;/span&gt;M     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;491&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;% /dev/shm
/dev/sda1           ext4   &lt;span class=&quot;hljs-number&quot;&gt;239&lt;/span&gt;M   &lt;span class=&quot;hljs-number&quot;&gt;68&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;159&lt;/span&gt;M  &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;% /boot
&lt;span class=&quot;hljs-regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.0.124/win cifs   &lt;span class=&quot;hljs-number&quot;&gt;381&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;243&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;138&lt;/span&gt;G  &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;% /mnt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.由于df每次统计都是读取superblock，所以df对文件系统中的某个文件进行统计时，会自动转为统计这个文件系统的信息。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
Filesystem     Type  Size  Used Avail Use% Mounted &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;hljs-regexp&quot;&gt;/dev/sda2      ext4   18G  1.7G   15G  11% /&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.df会统计已删除但却仍有进程引用的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正常情况下，删除文件会立刻释放相关指针，并将imap和bmap中相关的位图标记为未使用。&lt;span&gt;&lt;strong&gt;bmap只要一改变，文件系统立刻就能知道每个块组中哪些数据块是空闲的，哪些数据块是被使用的，这些信息都会更新到分区的superblock中&lt;/strong&gt;&lt;/span&gt;。于是df能立刻统计到实时的空间信息。&lt;/p&gt;
&lt;p&gt;但是当一个文件被删除时，如果还有进程在引用这个文件，根据前文的分析，bmap中不会将这个文件的data block标记为未使用，也就不会将数据块的使用情况更新到superblock中。由于df是根据superblock中空闲和使用数据块的数量来计算空闲空间和已使用空间的，所以df统计的时候会将这个已被&quot;删除&quot;的文件统计到已使用空间中。&lt;/p&gt;
&lt;p&gt;例如，创建一个较大一点的文件放在&quot;/&quot;目录下，并du和df统计根目录的已使用空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]

[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
Filesystem     Type  Size  Used Avail Use% Mounted &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;hljs-regexp&quot;&gt;/dev/sda2      ext4   18G  2.7G   14G  17% /&lt;/span&gt;

[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;G    /
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们在GB级的单位上是相等的。&lt;/p&gt;
&lt;p&gt;现在使用一个进程来引用这个文件，然后删除这个文件，再du和df统计。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]

[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;ls&lt;/span&gt;: cannot access /my.&lt;span class=&quot;hljs-attribute&quot;&gt;iso&lt;/span&gt;: No such file &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; directory

[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-number&quot;&gt;1.8&lt;/span&gt;G    /

[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
Filesystem     Type  Size  Used Avail Use% Mounted &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;hljs-regexp&quot;&gt;/dev/sda2      ext4   18G  2.7G   14G  17% /&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，外界已经获取不到my.iso文件了，所以du无法统计这个文件。而df却将该文件大小统计进去了，因为my.iso占用的data block还未被标记为未使用。&lt;/p&gt;
&lt;p&gt;再关掉tail进程，然后df再统计空间，结果将和du一样显示为正常的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]+  Running                 tail -f /my.iso &amp;amp;
[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]

[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
Filesystem     Type  Size  Used Avail Use% Mounted &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;hljs-regexp&quot;&gt;/dev/sda2      ext4   18G  1.7G   15G  11% /&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不知道文件系统中哪些已被删除，但却还被进程引用的文件，可以使用lsof来获取。通过它还能获取到文件的大小，看看到底是哪个文件在&quot;占着茅坑以及占了多少茅坑&quot;。&lt;/p&gt;
&lt;p&gt;例如，关掉tail进程前，使用lsof查看。可以看到tail进程占用了/my.iso，且这个文件的大小为1048576000字节。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
php-fpm   &lt;span class=&quot;hljs-number&quot;&gt;12597&lt;/span&gt;      root  txt     REG   &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;4058416&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;931143&lt;/span&gt; /usr/sbin/php-fpm (deleted)
php-fpm   &lt;span class=&quot;hljs-number&quot;&gt;12657&lt;/span&gt;    nobody  txt     REG   &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;4058416&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;931143&lt;/span&gt; /usr/sbin/php-fpm (deleted)
php-fpm   &lt;span class=&quot;hljs-number&quot;&gt;12707&lt;/span&gt;    nobody  txt     REG   &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;4058416&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;931143&lt;/span&gt; /usr/sbin/php-fpm (deleted)
php-fpm   &lt;span class=&quot;hljs-number&quot;&gt;12708&lt;/span&gt;    nobody  txt     REG   &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;4058416&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;931143&lt;/span&gt; /usr/sbin/php-fpm (deleted)
tail      &lt;span class=&quot;hljs-number&quot;&gt;14437&lt;/span&gt;      root    &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;r    REG   &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1048576000&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;7171&lt;/span&gt; /&lt;span class=&quot;hljs-keyword&quot;&gt;my&lt;/span&gt;.iso (deleted)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过上面的分析，想必对du和df的结果不会再有任何疑惑了吧。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8659301.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8659301.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Mar 2018 10:49:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8659301.html</dc:identifier>
</item>
</channel>
</rss>