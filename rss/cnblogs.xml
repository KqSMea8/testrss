<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SSM项目中整合WebService - 城_府</title>
<link>http://www.cnblogs.com/clack/p/10001375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clack/p/10001375.html</guid>
<description>&lt;p&gt;　　先了解一下&lt;span&gt;WebService的一些相关术语&lt;/span&gt;吧：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebService&lt;/span&gt;：&lt;br/&gt;WebService是一种跨编程语言和跨操作系统平台的远程调用技术。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WSDL(web service definition language)&lt;/span&gt;：&lt;br/&gt;WSDL是webservice定义语言, 对应.wsdl文档, 一个webservice会对应一个唯一的wsdl文档, 定义了客户端与服务端发送请求和响应的数据格式和过程&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SOAP(simple object access protocal)&lt;/span&gt;：&lt;br/&gt;SOAP是&quot;简单对象访问协议&quot;&lt;br/&gt;是一种简单的、基于HTTP和XML的协议, 用于在WEB上交换结构化的数据&lt;br/&gt;soap消息：请求消息和响应消息&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SEI(WebService EndPoint Interface)&lt;/span&gt;：&lt;br/&gt;SEI是web service的终端接口，就是WebService服务器端用来处理请求的接口&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CXF(Celtix + XFire)&lt;/span&gt;：&lt;br/&gt;一个apache的用于开发webservice服务器端和客户端的框架。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本次采用的就是CXF框架来整合，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先引入相关的pom包：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;!-- webservice --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;cxf-rt-frontend-jaxws&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${cxf.version}&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;cxf-rt-transports-http&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${cxf.version}&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于版本的冲突，我将spring的版本调了，并且由于cglib包中的asm包和cxf框架中的asm包有冲突，我做了以下更改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;!-- spring版本号 --&amp;gt;
                &amp;lt;spring.version&amp;gt;4.1.9.RELEASE&amp;lt;/spring.version&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;3.2.5&amp;lt;/version&amp;gt;
                        &amp;lt;exclusions&amp;gt;
                                &amp;lt;exclusion&amp;gt;
                                        &amp;lt;groupId&amp;gt;org.ow2.asm&amp;lt;/groupId&amp;gt;
                                        &amp;lt;artifactId&amp;gt;asm&amp;lt;/artifactId&amp;gt;
                                &amp;lt;/exclusion&amp;gt;
                        &amp;lt;/exclusions&amp;gt;
                &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. &lt;span&gt;接着引入spring-context-webservice.xml和cxf-config.xml:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:cxf=&quot;http://cxf.apache.org/core&quot;
       xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd
        http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd&quot;&amp;gt;

    &amp;lt;import resource=&quot;cxf-config.xml&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;
        xsi:schemaLocation=&quot;http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd
                http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                http://cxf.apache.org/jaxrs
        http://cxf.apache.org/schemas/jaxrs.xsd&quot;&amp;gt;

        &amp;lt;import resource=&quot;classpath*:META-INF/cxf/cxf.xml&quot; /&amp;gt;
        &amp;lt;import resource=&quot;classpath*:META-INF/cxf/cxf-extension-soap.xml&quot; /&amp;gt;
        &amp;lt;import resource=&quot;classpath*:META-INF/cxf/cxf-servlet.xml&quot; /&amp;gt;


&amp;lt;!-- id 不能重复 --&amp;gt;
        &amp;lt;jaxws:endpoint id=&quot;servicemanWebService&quot; implementor=&quot;clack.webserviceImp.ServicemanWebServiceImp&quot;  address=&quot;/servicemanws&quot; /&amp;gt; 

&amp;lt;!--         &amp;lt;jaxrs:server id=&quot;restContainer&quot; address=&quot;/&quot;&amp;gt;
                &amp;lt;jaxrs:serviceBeans&amp;gt;
                        &amp;lt;ref bean=&quot;roomService&quot; /&amp;gt;
                &amp;lt;/jaxrs:serviceBeans&amp;gt;
                &amp;lt;jaxrs:providers&amp;gt;
                        &amp;lt;bean class=&quot;org.codehaus.jackson.jaxrs.JacksonJaxbJsonProvider&quot; /&amp;gt;
                &amp;lt;/jaxrs:providers&amp;gt;
                &amp;lt;jaxrs:extensionMappings&amp;gt;
                &amp;lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&amp;gt;
                &amp;lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&amp;gt;
                &amp;lt;/jaxrs:extensionMappings&amp;gt;
        &amp;lt;/jaxrs:server&amp;gt; --&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中&lt;span&gt;&amp;lt;jaxws:endpoint id=&quot;servicemanWebService&quot; implementor=&quot;clack.webserviceImp.ServicemanWebServiceImp&quot; address=&quot;/servicemanws&quot; /&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&lt;em&gt;&lt;br/&gt;中的设置后续会用到。&lt;br/&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;pre class=&quot;brush:java;gutter:false;&quot; readability=&quot;4.5&quot;&gt;
&lt;em id=&quot;__mceDel&quot; readability=&quot;3&quot;&gt;&lt;p&gt;3. &lt;span&gt;更改相应的web.xml加载顺序并加入cxf配置（反正是先加载spring，后加载springmvc）&lt;/span&gt;&lt;/p&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; 
    xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; 
    id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&amp;gt;
    &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;
    
    &amp;lt;context-param&amp;gt;
                &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
                &amp;lt;param-value&amp;gt;classpath:spring-context*.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/context-param&amp;gt;
&amp;lt;listener&amp;gt;
                &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
        &amp;lt;/listener&amp;gt;
        &amp;lt;listener&amp;gt;
                &amp;lt;listener-class&amp;gt;org.springframework.web.context.request.RequestContextListener&amp;lt;/listener-class&amp;gt;
        &amp;lt;/listener&amp;gt;
        &amp;lt;!-- ================配置SpringMVC核心调度器================ --&amp;gt;
        &amp;lt;!-- 不指定具体文件的话，默认为&quot;/WEB-INF/&amp;lt;servlet name&amp;gt;-servlet.xml&quot; --&amp;gt;
        &amp;lt;!-- load-on-startup代表启动顺序，设置为大于等于0表示容器在应用启动时就加载并初始化这个servlet --&amp;gt;
        &amp;lt;!-- 推荐拦截/，风格优雅 --&amp;gt;
        &amp;lt;servlet&amp;gt;
                &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
                &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
                &amp;lt;init-param&amp;gt;
                        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
                        &amp;lt;param-value&amp;gt;classpath*:spring-mvc.xml&amp;lt;/param-value&amp;gt;
                &amp;lt;/init-param&amp;gt;
                &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
        &amp;lt;/servlet&amp;gt;
        &amp;lt;servlet-mapping&amp;gt;
                &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
                &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/servlet-mapping&amp;gt;
        &amp;lt;servlet&amp;gt;
                &amp;lt;servlet-name&amp;gt;CXFServlet&amp;lt;/servlet-name&amp;gt;
                &amp;lt;servlet-class&amp;gt;org.apache.cxf.transport.servlet.CXFServlet&amp;lt;/servlet-class&amp;gt;
                &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
        &amp;lt;/servlet&amp;gt;
        &amp;lt;servlet-mapping&amp;gt;
                &amp;lt;servlet-name&amp;gt;CXFServlet&amp;lt;/servlet-name&amp;gt;
                &amp;lt;url-pattern&amp;gt;/ws/*&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4. &lt;span&gt;接着添加一个工具类用于调出springmvc中加载的service注解&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
package clack.utils;

import java.util.Enumeration;
import javax.servlet.ServletContext;

import org.springframework.web.context.ContextLoader;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.WebApplicationContextUtils;

public class ContextUtils {
        public static WebApplicationContext getSpringMVCContext() {
                WebApplicationContext rootWac = ContextLoader.getCurrentWebApplicationContext();
                // 获取servletContext
                System.out.println(rootWac+&quot;ddddd&quot;);
                ServletContext servletContext = rootWac.getServletContext();
                // 获取子容器，名字最后对应servlet名字
                //1.查看spring容器中的对象名称
                String[] beannames = rootWac.getBeanDefinitionNames();
                for(String beanname:beannames){
                        System.out.println(beanname);
                }
                
                System.out.println(servletContext);
        
                
                //2.查看servlet中容器列表
                Enumeration&amp;lt;String&amp;gt; servletnames  = servletContext.getAttributeNames();
                while(servletnames.hasMoreElements()){
                        System.out.println(servletnames.nextElement());
                }
                
                WebApplicationContext springmvc = WebApplicationContextUtils.getWebApplicationContext(servletContext,
                                &quot;org.springframework.web.servlet.FrameworkServlet.CONTEXT.SpringMVC&quot;);
                //System.out.println(springmvc+&quot;eee&quot;);
                return springmvc;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5. &lt;span&gt;准备工作就绪后就建立webservice接口和webservice实现类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
package clack.webservice;

import java.util.List;

import javax.jws.WebMethod;
import javax.jws.WebService;

import clack.entity.Serviceman;

@WebService
public interface ServicemanWebService {
        //使用@WebMethod注解标注WebServiceI接口中的方法
    @WebMethod
        List&amp;lt;Serviceman&amp;gt; getAllServiceman() throws Exception;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中使用的 getAllServiceman()方法是本身的service中的方法调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
package clack.webserviceImp;

import java.util.List;

import javax.jws.WebService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import clack.entity.Serviceman;
import clack.service.ServicemanService;
import clack.utils.ContextUtils;
import clack.webservice.ServicemanWebService;
//endpointInterface 编写实现接口类名 service name 网络访问的名字 对应&amp;lt;wsdl:service name=&quot;studentws&quot;&amp;gt;
@Component(&quot;servicemanWebService&quot;)
@WebService(endpointInterface = &quot;clack.webservice.ServicemanWebService&quot;, serviceName = &quot;servicemanws&quot;)
public class ServicemanWebServiceImp implements ServicemanWebService{
        @Autowired
        private ServicemanService servicemanService;
        
        
        public ServicemanService getServicemanService() {
                return servicemanService;
        }


        public void setServicemanService(ServicemanService servicemanService) {
                this.servicemanService = servicemanService;
        }


        @Override
        public List&amp;lt;Serviceman&amp;gt; getAllServiceman() throws Exception {
                // TODO Auto-generated method stub
                servicemanService = (ServicemanService)ContextUtils.getSpringMVCContext().getBean(&quot;servicemanService&quot;);
                List&amp;lt;Serviceman&amp;gt; servicemans = servicemanService.getAllServiceman();
                return servicemans;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　理清其中注解的对应关系后问题不大，&lt;/p&gt;
&lt;p&gt;启动项目，输入地址：&lt;span&gt;&lt;strong&gt;http://localhost:8080/StudyMaven1/ws/servicemanws?wsdl&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529417/201811/1529417-20181122153844209-1369382149.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 测试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建立一个简单的maven项目并导入相关的cxf包：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;clack&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;MyWebService&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  
  &amp;lt;properties&amp;gt;
                &amp;lt;cxf.version&amp;gt;2.2.3&amp;lt;/cxf.version&amp;gt;
        &amp;lt;/properties&amp;gt;

        &amp;lt;dependencies&amp;gt;
                &amp;lt;!-- webservice --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;cxf-rt-frontend-jaxws&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${cxf.version}&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;cxf-rt-transports-http&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${cxf.version}&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;



        &amp;lt;/dependencies&amp;gt;
        &amp;lt;build&amp;gt;
                &amp;lt;defaultGoal&amp;gt;compile&amp;lt;/defaultGoal&amp;gt;
                &amp;lt;finalName&amp;gt;MyWebService&amp;lt;/finalName&amp;gt;
                &amp;lt;plugins&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
                                &amp;lt;configuration&amp;gt;
                                        &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                                        &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                                        &amp;lt;encoding&amp;gt;utf-8&amp;lt;/encoding&amp;gt;
                                &amp;lt;/configuration&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;maven-resources-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
                                &amp;lt;configuration&amp;gt;


                                        &amp;lt;failOnMissingWebXml&amp;gt;false&amp;lt;/failOnMissingWebXml&amp;gt;

                                &amp;lt;/configuration&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                &amp;lt;/plugins&amp;gt;
                &amp;lt;resources&amp;gt;
                        &amp;lt;!--编译之后包含xml --&amp;gt;
                        &amp;lt;resource&amp;gt;
                                &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
                                &amp;lt;includes&amp;gt;
                                        &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
                                &amp;lt;/includes&amp;gt;
                        &amp;lt;/resource&amp;gt;
                        &amp;lt;resource&amp;gt;
                                &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
                                &amp;lt;includes&amp;gt;
                                        &amp;lt;include&amp;gt;**/*&amp;lt;/include&amp;gt;
                                &amp;lt;/includes&amp;gt;
                        &amp;lt;/resource&amp;gt;

                &amp;lt;/resources&amp;gt;
        &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　2. &lt;span&gt;使用了一个插件生成相关的文件 apache-cxf-3.2.7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. 将所得的文件拷入maven项目中，并新建一个测试类测试是否能取得数据：&lt;/p&gt;
&lt;p&gt;目录树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529417/201811/1529417-20181122153048711-701825477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中WebServiceApp是测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:false;&quot;&gt;
package clack.webserviceimp;

import java.net.URL;
import java.util.List;

import javax.xml.namespace.QName;
import javax.xml.ws.Service;

import org.apache.cxf.endpoint.Client;
import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;

import clack.webservice.Serviceman;
import clack.webservice.ServicemanWebService;

/**
 * 通过客户端编程的方式调用Webservice服务
 *
 */
public class WebServiceApp {

        //1. 自定义方法
        public void mysoap() throws Exception {

                // CXF动态客户端工厂
                JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance();

                // WSDL文档url配置()
                String wsdlUrl = &quot;http://localhost:8080/StudyMaven1/ws/servicemanws?wsdl&quot;;

                Object[] objects = null;
                try {
                        // 获取CXF客户端
                        Client client = dcf.createClient(wsdlUrl);
                        // 调用Web Service方法
                        objects = client.invoke(&quot;add&quot;, 1, 2);
                } catch (Exception e) {
                        e.printStackTrace();
                }

                // 获取调用结果
                System.out.println(&quot;调用结果：&quot; + objects[0]);

                System.out.println(&quot;=========&amp;gt;&quot;);
                try {
                        // 获取CXF客户端
                        Client client = dcf.createClient(wsdlUrl);
                        // 调用Web Service方法
                        objects = client.invoke(&quot;sayHello&quot;, &quot;World!&quot;);
                } catch (Exception e) {
                        e.printStackTrace();
                }

                // 获取调用结果
                System.out.println(&quot;调用结果：&quot; + objects[0]);
        }
        //第二种 client工具生成辅助类 需使用apche cxf工具  
        //步骤 cmd wsdl2java   -encoding  utf8 http://localhost:8080/StudyMavenSSM/ws/studentws?wsdl
        //
        public void clientsoap() throws Exception{
                // 创建WSDL的URL，注意不是服务地址
                                URL url = new URL(&quot;http://localhost:8080/StudyMaven1/ws/servicemanws?wsdl&quot;);

                                // 创建服务名称
                                // 1.namespaceURI - 命名空间地址 (wsdl文档中的targetNamespace
                                // targetNamespace=&quot;http://webserviceImp.gxa/&quot;)
                                // 2.localPart - 服务视图名 (wsdl文档中服务名称，例如&amp;lt;wsdl:service name=&quot;studentws&quot;&amp;gt;)
                                QName qname = new QName(&quot;http://webserviceImp.clack/&quot;, &quot;servicemanws&quot;);

                                // 创建服务视图
                                // 参数解释：
                                // 1.wsdlDocumentLocation - wsdl地址
                                // 2.serviceName - 服务名称
                                Service service = Service.create(url, qname);
                                // 获取服务实现类
                                // 参数解释:serviceEndpointInterface - 服务端口(wsdl文档中服务端口的name属性，例如&amp;lt;wsdl:port
                                // binding=&quot;tns:studentwsSoapBinding&quot; name=&quot;StudentWebServiceImpPort&quot;&amp;gt;)
                                ServicemanWebService studentWebService =
                                service.getPort(ServicemanWebService.class);
                                 //调用查询方法
                                 List&amp;lt;Serviceman&amp;gt; students = studentWebService.getAllServiceman();
                                 for(Serviceman serviceman:students){
                                         System.out.println(serviceman.getSname());
                                 }
        }

        public static void main(String[] args) throws Exception {
                new WebServiceApp().clientsoap();
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4. 最后运行如下，成功调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529417/201811/1529417-20181122153256692-337416800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，一个简单的webservice就整合进去了，但是，其中还有很多细节无法言说，学而无涯。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Nov 2018 07:34:00 +0000</pubDate>
<dc:creator>城_府</dc:creator>
<og:description>先了解一下WebService的一些相关术语吧： WebService：WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 WSDL(web service definition l</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clack/p/10001375.html</dc:identifier>
</item>
<item>
<title>解放劳动力—Cobbler批量自动化部署多版本系统 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9996931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9996931.html</guid>
<description>&lt;h3&gt;1 Cobbler  介绍&lt;/h3&gt;
&lt;p&gt;Cobbler 是一个 Linux 服务器安装的服务，可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理 DHCP，DNS 等。&lt;br/&gt;Cobbler 可以使用命令行方式管理，也提供了基于 Web 的界面管理工具(cobbler-web)，还提供了API 接口，可以方便二次开发使用。&lt;br/&gt;Cobbler 是较早前的 kickstart 的升级版，优点是比较容易配置，还自带 web 界面比较易于管理。&lt;br/&gt;Cobbler 内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如 Puppet，暂时不支持 SaltStack。&lt;br/&gt;Cobbler 官网：https://fedorahosted.org/cobbler/&lt;/p&gt;
&lt;h4&gt;1.1 Cobbler  集成的服务&lt;/h4&gt;
&lt;p&gt;PXE 服务支持&lt;br/&gt;DHCP 服务管理&lt;br/&gt;DNS 服务管理(可选 bind,dnsmasq)&lt;br/&gt;电源管理&lt;br/&gt;Kickstart 服务支持&lt;br/&gt;YUM 仓库管理&lt;br/&gt;TFTP(PXE 启动时需要)&lt;br/&gt;Apache(提供 kickstart 的安装源，并提供定制化的 kickstart 配置)&lt;/p&gt;
&lt;h4&gt;1.2 Cobbler的工作流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181121183800512-1865378583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 Cobbler安装&lt;/h3&gt;
&lt;p&gt;#必要服务&lt;br/&gt;（1）cobbler （cobbler 的核心）&lt;br/&gt;（2）httpd （提供 cobbler 的 web 界面）&lt;br/&gt;（3）dhcpd （为自动安装系统分配 IP 地址）&lt;br/&gt;（4）epel-release （为之提供 yum 源）&lt;br/&gt;（5）rsync （cobbler 需要同步信息）&lt;br/&gt;（6）cobbler-web （cobbler 的一个 web 插件）&lt;br/&gt;（7）xinetd （为 rsync 和 tftp 的守护进程）&lt;br/&gt;（8）tftp （传送安装的一些文件的类似 ftp）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;1. 关闭防火墙和 selinux&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
/etc/init.d/iptables stop
chkconfig iptables off
getenforce
sed -i '/SELINUX/s/enforcing/disabled/' /etc/selinux/config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.开始安装cobbler  &lt;br/&gt;#1. 安装第三方源：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo
yum repolist
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;升级Django大于1.4版本否则安装cobbler-web时报以下错(如果不用可以先忽略)：&lt;/span&gt;&lt;br/&gt;Error: Package: cobbler-web-2.6.11-7.git95749a6.el6.noarch (epel)&lt;br/&gt;           Requires: Django &amp;gt;= 1.4&lt;/p&gt;&lt;p&gt;升级Django方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
wget &quot;https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz#md5=834b2904f92d46aaa333267fb1c922bb&quot; --no-check-certificat
tar -xf pip-1.5.4.tar.gz
cd pip-1.5.4
python setup.py install
pip install Django==1.5.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#2.cobbler安装相关服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
yum -y install cobbler dhcp tftp-server pykickstart httpd xinetd 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#3.检查&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
rpm -qa cobbler dhcp tftp-server pykickstart httpd xinetd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#4.查看cobbler配置文件&lt;br/&gt;rpm -ql cobbler&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
/etc/cobbler # 配置文件目录
/etc/cobbler/settings # cobbler 主配置文件，这个文件是 YAML 格式，Cobbler 是 python 写的程序。
/etc/cobbler/dhcp.template # DHCP 服务的配置模板
/etc/cobbler/tftpd.template # tftp 服务的配置模板
/etc/cobbler/rsync.template # rsync 服务的配置模板
/etc/cobbler/iso # iso 模板配置文件目录
/etc/cobbler/pxe # pxe 模板文件目录
/etc/cobbler/power # 电源的配置文件目录
/etc/cobbler/users.conf # Web 服务授权配置文件
/etc/cobbler/users.digest #用于 web 访问的用户名密码配置文件
/etc/cobbler/dnsmasq.template #DNS 服务的配置模板
/etc/cobbler/modules.conf # Cobbler 模块配置文件
/var/lib/cobbler # Cobbler 数据目录
/var/lib/cobbler/config #配置文件
/var/lib/cobbler/kickstarts # 默认存放 kickstart 文件
/var/lib/cobbler/loaders # 存放的各种引导程序
/var/www/cobbler # 系统安装镜像目录
/var/www/cobbler/ks_mirror # 导入的系统镜像列表
/var/www/cobbler/images # 导入的系统镜像启动文件
/var/www/cobbler/repo_mirror # yum 源存储目录
/var/log/cobbler # 日志目录
/var/log/cobbler/install.log # 客户端系统安装日志
/var/log/cobbler/cobbler.log # cobbler 日志
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#启动相关服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
/etc/init.d/httpd restart
/etc/init.d/cobblerd restart
/etc/init.d/xinetd restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#4. 检查cobbler配置会列出存在的问题，我们只要把问题都解决都ok了&lt;br/&gt;#cobbler check的检查命令&lt;br/&gt;[root@localhost ~]# cobbler check&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
The following are potential configuration items that you may want to fix:

1 : The 'server' field in /etc/cobbler/settings must be set to something other than localhost, or kickstarting features will not work.  This should be a resolvable hostname or IP for the boot server as reachable by all machines that will use it.
2 : For PXE to be functional, the 'next_server' field in /etc/cobbler/settings must be set to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.
3 : change 'disable' to 'no' in /etc/xinetd.d/tftp
4 : some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run 'cobbler get-loaders' to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The 'cobbler get-loaders' command is the easiest way to resolve these requirements.
5 : change 'disable' to 'no' in /etc/xinetd.d/rsync
6 : debmirror package is not installed, it will be required to manage debian deployments and repositories
7 : The default password used by the sample templates for newly installed machines (default_password_crypted in /etc/cobbler/settings) is still set to 'cobbler' and should be changed, try: &quot;openssl passwd -1 -salt 'random-phrase-here' 'your-password-here'&quot; to generate new one
8 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them
Restart cobblerd and then run 'cobbler sync' to apply changes.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#解决方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1. /etc/cobbler/settings 中'server'配置成具体的服务器 ip 地址，我这修改为内网的
2. /etc/cobbler/settings 中'next_server'也修改为具体的 ip 地址
3. /etc/xinetd.d/tftp 中把'disable' 从'yes' 'no'
4. 运行'cobbler get-loaders'网络引导加载程序
5. 开启 rsync 服务并设置为开机启动，systemctl start rsyncd、systemctl enable rsyncd
6. debian 系统需要安装 debmirror 包，我们这里是 centos 所以不用安装
7. &quot;openssl passwd -1 -salt 'random-phrase-here' 'your-password-here'&quot;生成新密码并修改配置/etc/cobbler/settings 中'default_password_crypted'字段
8. 应用修改后运行service restart cobblerd、cobbler sync
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;针对以上问题进行整改：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cp /etc/cobbler/settings{,.ori} &amp;amp;&amp;amp; ll /etc/cobbler/settings{,.ori}
sed -i 's/server: 127.0.0.1/server: 192.168.247.141/' /etc/cobbler/settings &amp;amp;&amp;amp; grep &quot;server: 192.168.247.141&quot; /etc/cobbler/settings
sed -i 's/next_server: 127.0.0.1/next_server: 192.168.247.141/' /etc/cobbler/settings
sed -i 's/manage_dhcp: 0/manage_dhcp: 1/' /etc/cobbler/settings &amp;amp;&amp;amp; grep 'manage_dhcp: 1' /etc/cobbler/settings
sed -i 's/pxe_just_once: 0/pxe_just_once: 1/' /etc/cobbler/settings &amp;amp;&amp;amp; grep 'pxe_just_once: 1' /etc/cobbler/settings
vim /etc/cobbler/settings
或者手动修改如下地方：
manage_dhcp: 1
manage_rsync: 1

#生成新密码并修改配置/etc/cobbler/settings 中'default_password_crypted'字段

hejianlai=`openssl passwd -1 -salt 'hejianlai' '123456'`
echo $hejianlai
#注意: &quot;default_password_crypted: &quot;后面有一个空格的，如果不留空格会报错
sed -i &quot;/default_password_crypted/c\default_password_crypted: \&quot;$hejianlai&quot;\&quot; /etc/cobbler/settings
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#网络引导加载程序会从官网自动下载&lt;br/&gt;[root@localhost ~]# cobbler get-loaders&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
task started: 2018-11-21_005408_get_loaders
task started (id=Download Bootloader Content, time=Wed Nov 21 00:54:08 2018)
path /var/lib/cobbler/loaders/README already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/COPYING.elilo already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/COPYING.yaboot already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/COPYING.syslinux already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/elilo-ia64.efi already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/yaboot already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/pxelinux.0 already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/menu.c32 already exists, not overwriting existing content, use --force if you wish to update
path /var/lib/cobbler/loaders/grub-x86.efi already exists, not overwriting existing content, use --force if you wish to update
downloading http://cobbler.github.io/loaders/grub-0.97-x86_64.efi to /var/lib/cobbler/loaders/grub-x86_64.efi
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#下载的内容&lt;br/&gt;ll /var/lib/cobbler/loaders/&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181121184403924-1304210126.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;#修改rsync、tftp的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@localhost ~]# vim /etc/xinetd.d/rsync
disable = no
[root@localhost ~]# vim /etc/xinetd.d/tftp
disable = no
#重启
[root@localhost loaders]# /etc/init.d/xinetd restart
Stopping xinetd:                                           [FAILED]
Starting xinetd:                                           [  OK  ]
[root@localhost loaders]# /etc/init.d/cobblerd restart
Stopping cobbler daemon:                                   [  OK  ]
Starting cobbler daemon:                                   [  OK  ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#再检查&lt;br/&gt;[root@localhost loaders]# cobbler check&lt;/p&gt;&lt;p&gt;# 修改cobbler的 dhcp 模版，不要直接修改 dhcp 本身的配置文件，因为 cobbler 会覆盖,下面只列出修改的部分&lt;br/&gt;vim /etc/cobbler/dhcp.template&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
...
subnet 192.168.247.0 netmask 255.255.255.0 {
     option routers             192.168.247.5;
     option domain-name-servers 192.168.247.5;
     option subnet-mask         255.255.255.0;
     range dynamic-bootp        192.168.247.100 192.168.247.254;
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5  同步cobbler配置出现TASK COMPLETE表示成功&lt;br/&gt;# 同步最新 cobbler 配置，它会根据配置自动修改 dhcp 等服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@localhost ~]# cobbler sync
...
*** TASK COMPLETE ***
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#设置开机自启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
chkconfig httpd on
chkconfig xinetd on
chkconfig cobblerd on
chkconfig dhcpd on
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#重启所有服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
/etc/init.d/httpd restart
/etc/init.d/xinetd restart
/etc/init.d/cobblerd restart
/etc/init.d/dhcpd restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6 挂载光盘让 cobbler 处理生成&lt;br/&gt;#1.挂载光盘或者导入系统镜像的方式，导入系统镜像请看下面部署多个系统部分内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
mount /dev/cdrom /mnt/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 导入系统镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@localhost ~]# cobbler import --path=/mnt/ --name=CentOS-6.8-x86_64 --arch=x86_64
# --path 镜像路径
# --name 为安装源定义一个名字
# --arch 指定安装源是 32 位、64 位、ia64, 目前支持的选项有: x86│x86_64│ia64
# 安装源的唯一标示就是根据 name 参数来定义，本例导入成功后，安装源的唯一标示就是
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 查看镜像列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@localhost ~]# cobbler distro list
   CentOS-6.8-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 镜像存放目录，cobbler 会将镜像中的所有安装文件拷贝到本地一份，放在/var/www/cobbler/ks_mirror 下的 CentOS-6.8-x86_64 目录下。因此/var/www/cobbler目录必须具有足够容纳安装文件的空间&lt;br/&gt;[root@localhost ~]# ll /var/www/cobbler/ks_mirror/CentOS-6.8-x86_64&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
total 276
-r--r--r-- 1 root root     14 May 22  2016 CentOS_BuildTag
dr-xr-xr-x 3 root root   4096 May 22  2016 EFI
-r--r--r-- 1 root root    212 Nov 27  2013 EULA
-r--r--r-- 1 root root  18009 Nov 27  2013 GPL
dr-xr-xr-x 3 root root   4096 May 23  2016 images
dr-xr-xr-x 2 root root   4096 May 22  2016 isolinux
dr-xr-xr-x 2 root root 212992 May 23  2016 Packages
-r--r--r-- 1 root root   1359 May 22  2016 RELEASE-NOTES-en-US.html
dr-xr-xr-x 2 root root   4096 May 23  2016 repodata
-r--r--r-- 1 root root   1706 Nov 27  2013 RPM-GPG-KEY-CentOS-6
-r--r--r-- 1 root root   1730 Nov 27  2013 RPM-GPG-KEY-CentOS-Debug-6
-r--r--r-- 1 root root   1730 Nov 27  2013 RPM-GPG-KEY-CentOS-Security-6
-r--r--r-- 1 root root   1734 Nov 27  2013 RPM-GPG-KEY-CentOS-Testing-6
-r--r--r-- 1 root root   3380 May 23  2016 TRANS.TBL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开浏览器输入 &lt;a href=&quot;http://192.168.247.141/cobbler/ks_mirror/CentOS-6.8-x86_64/&quot; target=&quot;_blank&quot;&gt;http://192.168.247.141/cobbler/ks_mirror/CentOS-6.8-x86_64/&lt;/a&gt;&lt;br/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181121184820690-1316262654.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;7 指定ks.cfg文件及调整内核参数&lt;br/&gt;# Cobbler 的 ks.cfg 文件存放位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[root@localhost ~]# cd  /var/lib/cobbler/kickstarts/
[root@localhost kickstarts]# ll
total 60
-rw-r--r-- 1 root root  115 Nov 21 01:59 default.ks
-rw-r--r-- 1 root root   22 Nov 21 01:59 esxi4-ks.cfg
-rw-r--r-- 1 root root   22 Jul 14  2016 esxi5-ks.cfg
drwxr-xr-x 2 root root 4096 Nov 21 00:37 install_profiles
-rw-r--r-- 1 root root 1424 Jul 14  2016 legacy.ks
-rw-r--r-- 1 root root  292 Jul 14  2016 pxerescue.ks
-rw-r--r-- 1 root root 2916 Jul 14  2016 sample_autoyast.xml
-rw-r--r-- 1 root root 1825 Nov 21 01:59 sample_end.ks
-rw-r--r-- 1 root root    0 Jul 14  2016 sample_esx4.ks
-rw-r--r-- 1 root root  324 Jul 14  2016 sample_esxi4.ks
-rw-r--r-- 1 root root  386 Jul 14  2016 sample_esxi5.ks
-rw-r--r-- 1 root root 1784 Jul 14  2016 sample.ks
-rw-r--r-- 1 root root 3419 Jul 14  2016 sample_old.seed
-rw-r--r-- 1 root root 5879 Jul 14  2016 sample.seed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 在第一次导入系统镜像后，Cobbler 会给镜像指定一个默认的 kickstart 自动安装文件在&lt;span&gt;/var/lib/cobbler/kickstarts 下的 sample_end.ks&lt;/span&gt;。&lt;br/&gt;默认用sample_end.ks文件，以下是新建的一个名字为&lt;span&gt;CentOS-6.8-x86_64.cfg&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# kickstart template for Fedora 8 and later.
# (includes %end blocks)
# do not use with earlier distros
 
#platform=x86, AMD64, or Intel EM64T
# System authorization information
#auth  --useshadow  --enablemd5
authconfig --enableshadow --passalgo=sha512
# System bootloader configuration
bootloader --location=mbr --driveorder=sda --append=&quot;nomodeset crashkernel=auto rhgb quiet&quot;
# Partition clearing information
clearpart --all --initlabel
# Use text mode install
text
# Firewall configuration
firewall --disabled
# Run the Setup Agent on first boot
firstboot --disable
# System keyboard
keyboard us
# System language
lang en_US
# Use network installation
url --url=$tree
# If any cobbler repo definitions were referenced in the kickstart profile, include them here.
$yum_repo_stanza
# Network information
$SNIPPET('network_config')
# Reboot after installation
reboot
logging --level=info
 
#Root password
rootpw --iscrypted $default_password_crypted
# SELinux configuration
selinux --disabled
# Do not configure the X Window System
skipx
# System timezone
timezone  Asia/Shanghai
# Install OS instead of upgrade
install
# Clear the Master Boot Record
zerombr
# Allow anaconda to partition the system as needed
#autopart
part /boot --fstype=ext4 --asprimary --size=500
part swap --asprimary --size=1024
part / --fstype=ext4 --grow --asprimary --size=20480
 
%pre
$SNIPPET('log_ks_pre')
$SNIPPET('kickstart_start')
$SNIPPET('pre_install_network_config')
# Enable installation monitoring
$SNIPPET('pre_anamon')
%end
 
%packages
@base
@compat-libraries
@core
@debugging
@development
@dial-up
@hardware-monitoring
@performance
@server-policy
sgpio
device-mapper-persistent-data
systemtap-client
tree
lrzsz
telnet
nmap
dos2unix
%end
 
%post --nochroot
$SNIPPET('log_ks_post_nochroot')
%end
 
%post
$SNIPPET('log_ks_post')
# Start yum configuration
$yum_config_stanza
# End yum configuration
$SNIPPET('post_install_kernel_options')
$SNIPPET('post_install_network_config')
$SNIPPET('func_register_if_enabled')
$SNIPPET('download_config_files')
$SNIPPET('koan_environment')
$SNIPPET('redhat_register')
$SNIPPET('cobbler_register')
# Enable post-install boot notification
$SNIPPET('post_anamon')
# Start final steps
$SNIPPET('kickstart_done')
# End final steps
%end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 查看安装镜像文件信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler distro report --name=CentOS-6.8-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 查看指定的 profile 设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler profile report --name=CentOS-6.8-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 编辑profile，修改关联的ks文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler profile edit --name=CentOS-6.8-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-6.8-x86_64.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;# 每次修改完都要同步一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler sync
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ok，这时我们新建虚拟机配置分配高点就能成功自动安装系统了！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122100223532-499154099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装中。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122100518047-1764954943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完毕默认密码：root/123456,IP地址会自动分配。耶。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122101113279-487310325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 3 部署多版本系统&lt;/h3&gt;
&lt;p&gt;1. 导入光盘&lt;/p&gt;&lt;p&gt;(1)挂载光盘&lt;br/&gt;给虚拟机配置两个光盘，分别挂载CentOS6和CentOS7的光盘，注意如果/mnt有挂载要先umonut。&lt;br/&gt;挂载光盘到目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
mkdir /mnt/centos6
mkdir /mnt/centos7
mount /dev/sr0 /mnt/centos6
mount /dev/sr1 /mnt/centos7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是拷贝的iso文件到服务器，可以mount iso到目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
mkdir /mnt/centos6
mkdir /mnt/centos7
mount -o loop CentOS-6.9-x86_64-minimal.iso /mnt/centos6
mount -o loop CentOS-7-x86_64-Minimal-1708.iso /mnt/centos6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; (2)&lt;code&gt;cobbler import&lt;/code&gt;导入光盘&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler import --name=CentOS6.9 --path=/mnt/centos6 &amp;amp;&amp;amp; cobbler import --name=CentOS7.4 --path=/mnt/centos7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122141815257-1042439976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图可以看到，我们添加了两个发行版本到&lt;code&gt;distros&lt;/code&gt;,也创建了两个&lt;code&gt;profile&lt;/code&gt;(使用的是sample的ks文件），名字都是&lt;code&gt;CentOSx.x-x86_64&lt;/code&gt;，是cobblerd自动侦测了是x86_64的版本，自动添加到上面&lt;code&gt;import&lt;/code&gt;命令的&lt;code&gt;name&lt;/code&gt;后面。&lt;/p&gt;
&lt;p&gt;#查看发行版文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler distro list
cobbler profile list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122142257772-1298928812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;#查看导入的发行版操作系统信息(&lt;code&gt;distro&lt;/code&gt;)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler distro report --name=CentOS6.9-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122142445790-2134181730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;#编写ks文件&lt;/p&gt;
&lt;p&gt; 放到/var/lib/cobbler/kickstarts目录下：&lt;/p&gt;
&lt;p&gt;ks-centos6-mini.cfg模板;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# kickstart template for Fedora 8 and later.
# (includes %end blocks)
# do not use with earlier distros
 
#platform=x86, AMD64, or Intel EM64T
# System authorization information
#auth  --useshadow  --enablemd5
authconfig --enableshadow --passalgo=sha512
# System bootloader configuration
bootloader --location=mbr --driveorder=sda --append=&quot;nomodeset crashkernel=auto rhgb quiet&quot;
# Partition clearing information
clearpart --all --initlabel
# Use text mode install
text
# Firewall configuration
firewall --disabled
# Run the Setup Agent on first boot
firstboot --disable
# System keyboard
keyboard us
# System language
lang en_US
# Use network installation
url --url=$tree
# If any cobbler repo definitions were referenced in the kickstart profile, include them here.
$yum_repo_stanza
# Network information
$SNIPPET('network_config')
# Reboot after installation
reboot
logging --level=info
 
#Root password
rootpw --iscrypted $default_password_crypted
# SELinux configuration
selinux --disabled
# Do not configure the X Window System
skipx
# System timezone
timezone  Asia/Shanghai
# Install OS instead of upgrade
install
# Clear the Master Boot Record
zerombr
# Allow anaconda to partition the system as needed
#autopart
part /boot --fstype=ext4 --asprimary --size=500
part swap --asprimary --size=1024
part / --fstype=ext4 --grow --asprimary --size=20480
 
%pre
$SNIPPET('log_ks_pre')
$SNIPPET('kickstart_start')
$SNIPPET('pre_install_network_config')
# Enable installation monitoring
$SNIPPET('pre_anamon')
%end
 
%packages
@base
@compat-libraries
@core
@debugging
@development
@dial-up
@hardware-monitoring
@performance
@server-policy
sgpio
device-mapper-persistent-data
systemtap-client
tree
telnet
nmap
dos2unix
%end
 
%post --nochroot
$SNIPPET('log_ks_post_nochroot')
%end
 
%post
$SNIPPET('log_ks_post')
# Start yum configuration
$yum_config_stanza
# End yum configuration
$SNIPPET('post_install_kernel_options')
$SNIPPET('post_install_network_config')
$SNIPPET('func_register_if_enabled')
$SNIPPET('download_config_files')
$SNIPPET('koan_environment')
$SNIPPET('redhat_register')
$SNIPPET('cobbler_register')
# Enable post-install boot notification
$SNIPPET('post_anamon')
# Start final steps
$SNIPPET('kickstart_done')
# End final steps
%end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ks-centos7-mini.cfg模板：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#platform=x86, AMD64, or Intel EM64T
#version=DEVEL
# System authorization information
auth --enableshadow --passalgo=sha512
# Install OS instead of upgrade
install
# Use Cobbler's network installation
url --url=$tree
# Root password
# Use graphical install
text
# ignore other disk
ignoredisk --only-use=sda
# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8 --addsupport=zh_CN.UTF-8
# SELinux configuration
selinux --disabled
# Firewall configuration
firewall --disabled
# Do not configure the X Window System
skipx
# Reboot after installation
reboot
# Network information
network  --bootproto=dhcp --device=eth0 --onboot=on  --ipv6=auto --activate
# Root password
rootpw --plaintext hejianlai
# Add User
# System services
services --disabled=&quot;chronyd&quot;
# System timezone
timezone Asia/Shanghai --nontp
# System bootloader configuration
bootloader --append=&quot; crashkernel=auto&quot; --location=mbr
# Clear the Master Boot Record
zerombr
# Partition clearing information
clearpart --all
# Disk partitioning information
part /boot --fstype=&quot;xfs&quot; --ondisk=sda --size=1024
part swap --fstype=&quot;swap&quot; --ondisk=sda --size=4096
part / --fstype=&quot;xfs&quot; --ondisk=sda --grow --size=1
# Agree EULA
eula --agreed

%post
# config local yum

%end

%packages
@^minimal
@core
kexec-tools

%end

%addon com_redhat_kdump --enable --reserve-mb='auto'

%end

%anaconda
pwpolicy root --minlen=6 --minquality=50 --notstrict --nochanges --notempty
pwpolicy user --minlen=6 --minquality=50 --notstrict --nochanges --notempty
pwpolicy luks --minlen=6 --minquality=50 --notstrict --nochanges --notempty
%end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删掉默认例子，来重新添加新的kickstart文件对应关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler profile remove --name=&quot;CentOS6.9-x86_64&quot; 
cobbler profile remove --name=&quot;CentOS7.4-x86_64&quot; 
cobbler profile add --name=CentOS6.9-Mini-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks-centos6-mini.cfg --distro=CentOS6.9-x86_64 
cobbler profile add --name=CentOS7.4-Mini-x86_64 --kickstart=/var/lib/cobbler/kickstarts/ks-centos7-mini.cfg --distro=CentOS7.4-x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查看&lt;code&gt;pxelinux.cfg/default&lt;/code&gt;文件就能看到菜单选项也跟着变。&lt;/p&gt;
&lt;p&gt; &lt;code class=&quot;bash&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122152227306-8864011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新同步数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
cobbler sync
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 新建虚拟机：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122152411373-602768907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201811/1271786-20181122152439790-788100927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 22 Nov 2018 07:30:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>1 Cobbler 介绍 Cobbler 是一个 Linux 服务器安装的服务，可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理 DHCP，DNS 等。Cobbler</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9996931.html</dc:identifier>
</item>
<item>
<title>还在用Synchronized？Atomic你了解不？ - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10000999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10000999.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前已经写过多线程相关的文章了，有兴趣的同学可以去了解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673996015ea6b59?w=1920&amp;amp;h=903&amp;amp;f=png&amp;amp;s=53268&quot; alt=&quot;多线程文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在阅读&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484402&amp;amp;idx=1&amp;amp;sn=786686c4d2abd958c535065de044701d&amp;amp;chksm=ebd742f3dca0cbe5f6f401e38391369f28287858125d52a1a169523dc4f9600e20335446a629&amp;amp;token=634992186&amp;amp;lang=zh_CN#rd&quot;&gt;《阿里巴巴 Java开发手册》读后感&lt;/a&gt;时，还有未解决的问题：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果是count++操作，使用如下类实现: AtomicInteger count = new AtomicInteger(); count.addAndGet(1);如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前在学习的时候也看过AtomicInteger类很多次了，一直没有去做相关的笔记。现在遇到问题了，于是就过来写写笔记，并希望在&lt;strong&gt;学习的过程中解决掉问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;首先我们来个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class AtomicMain {

    public static void main(String[] args) throws InterruptedException {

        ExecutorService service = Executors.newCachedThreadPool();

        Count count = new Count();
        // 100个线程对共享变量进行加1
        for (int i = 0; i &amp;lt; 100; i++) {
            service.execute(() -&amp;gt; count.increase());
        }

        // 等待上述的线程执行完
        service.shutdown();
        service.awaitTermination(1, TimeUnit.DAYS);


        System.out.println(&quot;公众号：Java3y---------&quot;);
        System.out.println(count.getCount());
    }

}

class Count{

    // 共享变量
    private Integer count = 0;
    public Integer getCount() {
        return count;
    }
    public  void increase() {
        count++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你们猜猜得出的结果是多少？是100吗？&lt;/p&gt;
&lt;p&gt;多运行几次可以发现：&lt;strong&gt;结果是不确定的&lt;/strong&gt;，可能是95，也可能是98，也可能是100&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995fea017a5b&quot; alt=&quot;结果不确定&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据结果我们得知：上面的代码是&lt;strong&gt;线程不安全&lt;/strong&gt;的！如果线程安全的代码，多次执行的结果是一致的！&lt;/p&gt;
&lt;p&gt;我们可以发现问题所在：&lt;code&gt;count++&lt;/code&gt;并&lt;strong&gt;不是原子&lt;/strong&gt;操作。因为&lt;code&gt;count++&lt;/code&gt;需要经过&lt;code&gt;读取-修改-写入&lt;/code&gt;三个步骤。举个例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果某一个时刻：线程A读到count的值是10，线程B读到count的值也是10&lt;/li&gt;
&lt;li&gt;线程A对&lt;code&gt;count++&lt;/code&gt;，此时count的值为11&lt;/li&gt;
&lt;li&gt;线程B对&lt;code&gt;count++&lt;/code&gt;，此时count的值也是11(因为线程B读到的count是10)&lt;/li&gt;
&lt;li&gt;所以到这里应该知道为啥我们的结果是不确定了吧。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要将上面的代码变成线程安全的(每次得出的结果是100)，那也很简单，毕竟我们是学过synchronized锁的人：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;increase()&lt;/code&gt;加synchronized锁就好了&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public synchronized void increase() {
    count++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论执行多少次，得出的都是100：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995fe9d2a24c?w=884&amp;amp;h=138&amp;amp;f=png&amp;amp;s=4407&quot; alt=&quot;结果都是100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的代码我们也可以发现，只做一个&lt;code&gt;++&lt;/code&gt;这么简单的操作，都用到了synchronized锁，未免有点小题大做了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Synchronized锁是独占的，意味着如果有别的线程在执行，当前线程只能是等待！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是我们&lt;strong&gt;原子变量&lt;/strong&gt;的类就登场了！&lt;/p&gt;
&lt;h2 id=&quot;cas再来看看&quot;&gt;1.2CAS再来看看&lt;/h2&gt;
&lt;p&gt;在写文章之前，本以为对CAS有一定的了解了(因为之前已经看过相关概念，以为自己理解了)..但真正敲起键盘写的时候，还是发现没完全弄懂...所以再来看看CAS吧。&lt;/p&gt;
&lt;p&gt;来源维基百科：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;比较并交换(compare and swap, CAS)，是&lt;strong&gt;原子&lt;/strong&gt;操作的一种，可用于在多线程编程中实现&lt;strong&gt;不被打断的数据交换操作&lt;/strong&gt;，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CAS有3个操作数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存值V&lt;/li&gt;
&lt;li&gt;旧的预期值A&lt;/li&gt;
&lt;li&gt;要修改的新值B&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当多个线程尝试使用CAS同时更新同一个变量时，&lt;strong&gt;只有其中一个线程能更新变量的值&lt;/strong&gt;(A和内存值V相同时，将内存值V修改为B)，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，&lt;strong&gt;并可以再次尝试(或者什么都不做)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们画张图来理解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995fec2109f9?w=686&amp;amp;h=296&amp;amp;f=png&amp;amp;s=36466&quot; alt=&quot;CAS理解&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现CAS有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果内存值V和我们的预期值A&lt;strong&gt;相等&lt;/strong&gt;，则将内存值修改为B，操作成功！&lt;/li&gt;
&lt;li&gt;如果内存值V和我们的预期值A&lt;strong&gt;不相等&lt;/strong&gt;，一般也有两种情况：
&lt;ul&gt;&lt;li&gt;重试(自旋)&lt;/li&gt;
&lt;li&gt;什么都不做&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们再继续往下看，如果内存值V和我们的预期值A&lt;strong&gt;不相等&lt;/strong&gt;时，应该什么时候重试，什么时候什么都不做。&lt;/p&gt;
&lt;h3 id=&quot;cas失败重试自旋&quot;&gt;1.2.1CAS失败重试(自旋)&lt;/h3&gt;
&lt;p&gt;比如说，我上面用了100个线程，对count值进行加1。我们都知道：如果在线程安全的情况下，这个count值最终的结果一定是为100的。那就意味着：&lt;strong&gt;每个线程都会对这个count值实质地进行加1&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我继续画张图来说明一下CAS是如何重试(循环再试)的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995ff0117a59?w=1046&amp;amp;h=1697&amp;amp;f=png&amp;amp;s=191720&quot; alt=&quot;CAS循环重试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面图只模拟出两个线程的情况，但足够说明问题了。&lt;/p&gt;
&lt;h3 id=&quot;cas失败什么都不做&quot;&gt;1.2.2CAS失败什么都不做&lt;/h3&gt;
&lt;p&gt;上面是每个线程都要为count值加1，但我们也可以有这种情况：&lt;strong&gt;将count值设置为5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我也来画个图说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995fecc0fc19?w=1156&amp;amp;h=1075&amp;amp;f=png&amp;amp;s=152144&quot; alt=&quot;CAS失败什么都不做&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解CAS的核心就是：&lt;strong&gt;CAS是原子性的&lt;/strong&gt;，虽然你可能看到比较后再修改(compare and swap)觉得会有两个操作，但终究是原子性的！&lt;/p&gt;

&lt;p&gt;原子变量类在&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;包下，总体来看有这么多个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995e024d3c40?w=573&amp;amp;h=478&amp;amp;f=png&amp;amp;s=9613&quot; alt=&quot;原子变量类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以对其进行分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本类型：
&lt;ul&gt;&lt;li&gt;AtomicBoolean：布尔型&lt;/li&gt;
&lt;li&gt;AtomicInteger：整型&lt;/li&gt;
&lt;li&gt;AtomicLong：长整型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数组：
&lt;ul&gt;&lt;li&gt;AtomicIntegerArray：数组里的整型&lt;/li&gt;
&lt;li&gt;AtomicLongArray：数组里的长整型&lt;/li&gt;
&lt;li&gt;AtomicReferenceArray：数组里的引用类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;引用类型：
&lt;ul&gt;&lt;li&gt;AtomicReference：引用类型&lt;/li&gt;
&lt;li&gt;AtomicStampedReference：带有版本号的引用类型&lt;/li&gt;
&lt;li&gt;AtomicMarkableReference：带有标记位的引用类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象的属性：
&lt;ul&gt;&lt;li&gt;AtomicIntegerFieldUpdater：对象的属性是整型&lt;/li&gt;
&lt;li&gt;AtomicLongFieldUpdater：对象的属性是长整型&lt;/li&gt;
&lt;li&gt;AtomicReferenceFieldUpdater：对象的属性是引用类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;JDK8新增DoubleAccumulator、LongAccumulator、DoubleAdder、LongAdder
&lt;ul&gt;&lt;li&gt;是对AtomicLong等类的改进。比如LongAccumulator与LongAdder在高并发环境下比AtomicLong更高效。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Atomic包里的类基本都是使用&lt;strong&gt;Unsafe&lt;/strong&gt;实现的包装类。&lt;/p&gt;
&lt;p&gt;Unsafe里边有几个我们喜欢的方法(CAS)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
// 第一和第二个参数代表对象的实例以及地址，第三个参数代表期望值，第四个参数代表更新值
public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);

public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);

public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从原理上概述就是：Atomic包的类的实现绝大调用Unsafe的方法，而Unsafe底层实际上是调用C代码，C代码调用汇编，最后生成出&lt;strong&gt;一条&lt;/strong&gt;CPU指令cmpxchg，完成操作。这也就为啥CAS是原子性的，因为它是一条CPU指令，不会被打断。&lt;/p&gt;
&lt;h2 id=&quot;原子变量类使用&quot;&gt;2.1原子变量类使用&lt;/h2&gt;
&lt;p&gt;既然我们上面也说到了，使用Synchronized锁有点小题大作了，我们用原子变量类来改一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
class Count{

    // 共享变量(使用AtomicInteger来替代Synchronized锁)
    private AtomicInteger count = new AtomicInteger(0);
    
    public Integer getCount() {
        return count.get();
    }
    public void increase() {
        count.incrementAndGet();
    }
}


// Main方法还是如上
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完，无论执行多少次，我们的结果永远是100！&lt;/p&gt;
&lt;p&gt;其实Atomic包下原子类的使用方式都不会差太多，了解原子类各种类型，看看API，基本就会用了(网上也写得比较详细，所以我这里果断偷懒了)...&lt;/p&gt;
&lt;h2 id=&quot;aba问题&quot;&gt;2.2ABA问题&lt;/h2&gt;
&lt;p&gt;使用CAS有个缺点就是ABA的问题，什么是ABA问题呢？首先我用文字描述一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现在我有一个变量&lt;code&gt;count=10&lt;/code&gt;，现在有三个线程，分别为A、B、C&lt;/li&gt;
&lt;li&gt;线程A和线程C同时读到count变量，所以线程A和线程C的内存值和预期值都为10&lt;/li&gt;
&lt;li&gt;此时线程A使用CAS将count值修改成100&lt;/li&gt;
&lt;li&gt;修改完后，就在这时，线程B进来了，读取得到count的值为100(内存值和预期值都是100)，将count值修改成10&lt;/li&gt;
&lt;li&gt;线程C拿到执行权，发现内存值是10，预期值也是10，将count值修改成11&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的操作都可以正常执行完的，这样会发生什么问题呢？？线程C无法得知线程A和线程B修改过的count值，这样是有&lt;strong&gt;风险&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;下面我再画个图来说明一下ABA的问题(以链表为例)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673995e101cdd0d?w=1276&amp;amp;h=1452&amp;amp;f=png&amp;amp;s=207716&quot; alt=&quot;CAS ABA的问题讲解&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决aba问题&quot;&gt;2.3解决ABA问题&lt;/h2&gt;
&lt;p&gt;要解决ABA的问题，我们可以使用JDK给我们提供的AtomicStampedReference和AtomicMarkableReference类。&lt;/p&gt;
&lt;p&gt;AtomicStampedReference：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;An {@code AtomicStampedReference} maintains an object referencealong with an integer &quot;stamp&quot;, that can be updated atomically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说就是在给为这个对象提供了一个&lt;strong&gt;版本&lt;/strong&gt;，并且这个版本如果被修改了，是自动更新的。&lt;/p&gt;
&lt;p&gt;原理大概就是：维护了一个Pair对象，Pair对象存储我们的对象引用和一个stamp值。每次CAS比较的是两个Pair对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;

    // Pair对象
    private static class Pair&amp;lt;T&amp;gt; {
        final T reference;
        final int stamp;
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        static &amp;lt;T&amp;gt; Pair&amp;lt;T&amp;gt; of(T reference, int stamp) {
            return new Pair&amp;lt;T&amp;gt;(reference, stamp);
        }
    }

    private volatile Pair&amp;lt;V&amp;gt; pair;

    // 比较的是Pari对象
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
        Pair&amp;lt;V&amp;gt; current = pair;
        return
            expectedReference == current.reference &amp;amp;&amp;amp;
            expectedStamp == current.stamp &amp;amp;&amp;amp;
            ((newReference == current.reference &amp;amp;&amp;amp;
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为多了一个版本号比较，所以就不会存在ABA的问题了。&lt;/p&gt;
&lt;h2 id=&quot;longadder性能比atomiclong要好&quot;&gt;2.4LongAdder性能比AtomicLong要好&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好(减少乐观锁的重试次数)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;去查阅了一些博客和资料，大概的意思就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用AtomicLong时，在高并发下大量线程会同时去竞争更新&lt;strong&gt;同一个原子变量&lt;/strong&gt;，但是由于同时只有一个线程的CAS会成功，所以其他线程会不断尝试自旋尝试CAS操作，这会浪费不少的CPU资源。&lt;/li&gt;
&lt;li&gt;而LongAdder可以概括成这样：内部核心数据value&lt;strong&gt;分离&lt;/strong&gt;成一个数组(Cell)，每个线程访问时,通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的&lt;strong&gt;求和累加&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;简单来说就是将一个值分散成多个值，在并发的时候就可以&lt;strong&gt;分散压力&lt;/strong&gt;，性能有所提高。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;如果你觉得我写得还不错，了解一下：&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 06:49:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 只有光头才能变强 之前已经写过多线程相关的文章了，有兴趣的同学可以去了解一下：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10000999.html</dc:identifier>
</item>
<item>
<title>给萌新的Flexbox简易入门教程 - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/10000927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/10000927.html</guid>
<description>&lt;blockquote readability=&quot;7.2426470588235&quot;&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.grapecity.com.cn/events/specialoffers/?from=cnblogs&quot; target=&quot;_blank&quot;&gt;【年末促销】葡萄城 2018 岁末福利火热放送中&lt;/a&gt; &lt;img class=&quot;ml-1&quot; src=&quot;https://www.grapecity.com.cn/images/metalsmith/developer/hot.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原文出处：https://www.sitepoint.com/flexbox-css-flexible-box-layout/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;近几年，CSS领域出现了一些复杂的专用布局工具，用以代替原有的诸如使用表格、浮动和绝对定位之类的各种变通方案。&lt;a href=&quot;http://dev.w3.org/csswg/css3-flexbox/&quot; target=&quot;_blank&quot;&gt;Flexbox&lt;/a&gt;，或者说是弹性盒子布局模块（Flexible Box Layout Module）是这些新布局工具中的第一个，接着是&lt;a href=&quot;https://www.sitepoint.com/introduction-css-grid-layout-module/&quot; target=&quot;_blank&quot;&gt;CSS网格布局模块（CSS Grid Layout Module）&lt;/a&gt;。我们会在本文给出一个易于理解的flexbox入门介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;随着CSS网格布局的引入，你可能会问flexbox布局是否真的还有必要。虽然它们所能做的事情有一些重叠，但其各自在CSS布局中有着非常特别的目的。一般来说，flexbox在一维场景（比如，一串类似的元素）下有最佳应用，而网格是二维场景下理想的布局方案（例如整个页面的元素）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;即便如此，flexbox仍可以用于整个页面的布局，这样它能为那些还不支持网格布局的浏览器提供合适的兼容处理。（必须承认，&lt;a href=&quot;https://caniuse.com/#feat=css-grid&quot; target=&quot;_blank&quot;&gt;网格布局正在大多数现代浏览器中快速得到支持&lt;/a&gt;，不过&lt;a href=&quot;https://caniuse.com/#feat=flexbox&quot; target=&quot;_blank&quot;&gt;对flexbox的支持&lt;/a&gt;仍然更为广泛，所以如果你想让你的布局在稍微老旧的浏览器中也生效，使用flexbox作为网格布局的降级方案是很容易的）。&lt;/p&gt;
&lt;div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;使用Flexbox的好处&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;flexbox的一些好处是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;页面元素能被任意方向地放置（靠左、靠右、从上往下甚至从下往上）&lt;/li&gt;
&lt;li&gt;布局内容的可视顺序能够被反转或重排&lt;/li&gt;
&lt;li&gt;元素大小能“弹性”适应可用空间，并根据容器或者兄弟元素进行相应地对齐&lt;/li&gt;
&lt;li&gt;能轻松实现等列宽布局（与每一列里面的内容无关）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了阐述其多样的属性和可能性，让我们假设下面有这样的布局用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;example&quot;&amp;gt;
  &amp;lt;header&amp;gt;
    header content here
  &amp;lt;/header&amp;gt;
  &amp;lt;main class=&quot;main&quot;&amp;gt;
    &amp;lt;nav&amp;gt;
      nav content here
    &amp;lt;/nav&amp;gt;
    &amp;lt;div class=&quot;content&quot;&amp;gt;
      main content here
    &amp;lt;/div&amp;gt;
    &amp;lt;aside&amp;gt;
      aside content here
    &amp;lt;/aside&amp;gt;
  &amp;lt;/main&amp;gt;
  &amp;lt;footer&amp;gt;
    footer content here
  &amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首先，是把元素一起放进.main里，比如，&amp;lt;nav&amp;gt;和&amp;lt;aside&amp;gt;。如果没有flexbox，我们可能会把三个元素全部进行浮动，但想让它按理想的方式工作显得并不直观。而且，按传统的方式做这件事会出现一个众所周知的问题：每一列仅仅和它的内容一样高。因此，你可能需要把三个元素都设置为统一的高度，或者使用某种&lt;a href=&quot;http://pmob.co.uk/pob/equal-columns.htm&quot; target=&quot;_blank&quot;&gt;黑科技&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;让flexbox来救场吧。&lt;/p&gt;
&lt;div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;让我们Flex&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;flexbox的要点是出现在display属性上的flex值，它需要被设置在容器元素上。如此设置会让它的子元素变成“弹性项目（flex item）”。这些弹性项目拥有一些易于使用的默认属性。比如，它们被紧挨着放置，那些没有特别指明宽度的元素自动占满了剩余的空间。&lt;/p&gt;
&lt;p&gt;因此，如果你给.main设置了display:flex，它的子元素.content就被自动挤在&amp;lt;nav&amp;gt;和&amp;lt;aside&amp;gt;之间。不需要再多余的计算，多么方便是吧？作为附加奖赏，所有三个元素神奇地拥有了相同的高度。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.main {
  display: flex;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;请查看下面的例子，包含了所有的细节：&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-1.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-1&lt;/a&gt;。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;项的顺序：Flebox的&lt;/strong&gt;&lt;strong&gt;order&lt;/strong&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;另外一个flexbox的能力，是能够轻松改变元素的显示顺序。让我们假设你为一个客户制作了上面的布局，而她现在想要.content出现在&amp;lt;nav&amp;gt;之前。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通常，你需要深入到HTML源码中去，在那里改变元素的顺序。而有了Flexbox，你可以完全使用CSS完成这项任务。只需把.content的order属性设置为-1，那么这一列就会出现在前面，这本例就是最左边。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.main {
  display: flex;
}

.content {
  order: -1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;本例中，你不需要改变其他列的order。例子在&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-2.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-2&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果你倾向于显式地为每一列指定order，你可以将.content的order设为1，把&amp;lt;nav&amp;gt;的order设为2，把&amp;lt;aside&amp;gt;的设为3。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;strong&gt;源码独立于CSS的Flexbox样式&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;但你的客户并不满足。她想让&amp;lt;footer&amp;gt;成为页面的第一个元素，显示在&amp;lt;header&amp;gt;之前。那好，同样的，flexbox是你的朋友（虽然像在此例中，可能你得跟你的客户好好谈谈，而不是跟随指示）。因为你不仅要重排列内部元素，还要重排外部的，display:flex规则将被设置在&amp;lt;div class=&quot;example&quot;&amp;gt;之上。&lt;strong&gt;注意这里是如何在页面中嵌套使用flex容器来达到你想要的效果的。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;因为&amp;lt;header&amp;gt;，&amp;lt;main class=&quot;main&quot;&amp;gt;和&amp;lt;footer&amp;gt;相互堆叠着，你需要首先设置一个垂直上下文，它能够通过设置flex-direction:column来快速完成。还有，&amp;lt;footer&amp;gt;的order被设置为-1，如此一来它就出现在页面的最上头。就这么简单。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.example {
  display: flex;
  flex-direction: column;
}

footer {
  order: -1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;所以，如果你想把一行元素修改为一列，或者相反，你可以使用flex-direction属性，并设置它相应地为column或row（row是默认值）。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;完整的例子在&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-3.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-3&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然而，强大的能力也到来了更多的责任：谨记，一些用户可能会使用键盘来导航你的基于flexbox的网站，如果你HTML源码中元素的顺序和屏幕上显示的有所出入，那么无障碍访问的能力就成为需要认真对待的问题。如果想了解得更多，请不要错过&lt;a href=&quot;http://adrianroselli.com/2015/10/html-source-order-vs-css-display-order.html&quot; target=&quot;_blank&quot;&gt;HTML源码顺序 vs CSS显示顺序&lt;/a&gt;，网站无障碍访问和易用性的专家Adrian Roselli针对这个问题给出了深入讨论。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;如何在Flexbox中对齐子项&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;Flexbox能非常直观地处理子项的水平对齐和垂直对齐。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;你可以使用align-items对flex容器中的所有子项设置统一的对齐。如果你想给个别元素设置不同的对齐方式，使用align-self。元素的对齐方式跟它所在父容器的flex-direction有关。如果它的值是row（意味着元素水平排列），对齐方式是指在垂直轴上。如果flex-direction被设置为column（意味着元素垂直排列），对齐方式就是指在水平轴上。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例如，你让一些元素在容器中分别有不同的对齐方式，你需要：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置每个元素的align-self属性为合适的值。可能的值有：center，stretch（元素撑满它的容器），flex-start，flex-end和baseline（元素被放置在父容器的baseline上）&lt;/li&gt;
&lt;li&gt;把容器元素设置为display:flex&lt;/li&gt;
&lt;li&gt;最后，注意父容器的flex-direction属性，因为它关系到子元素的对齐方式。　　&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.example {
  display: flex;
  flex-direction: column;
}

.red {
  align-self: center;
}

.blue {
  align-self: flex-start;
}

.pink {
  align-self: flex-end;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;试试在下面的例子中，把父容器的flex-direction在row和column之间切换，看看它们引起的实时变化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例子&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-4.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-4.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果想要容器中所有的元素有统一的对齐方式，你可以在容器上使用align-items。可以的值有center，flex-start，flex-end，stretch（默认值：子项被拉伸以适应它们的容器）和baseline（子项被放置在父容器的baseline上）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.example {
  display: flex;
  align-items: center;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;像往常一样，试着把父容器的flex-direction在row和column之间切换，看看它们如何影响着你设置align-items值时所发生的作用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例子&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-5.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-5.html&lt;/a&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;在Flexbox里两端对齐&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;另一个控制对齐的属性是justify-content，当你想让多个元素等分空间时非常有用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;可接受的值有：center，flex-start，flex-end， space-between（元素利用主轴之间的空间而排布）和space-around（元素利用主轴之前、之间和之后的空间而排布）。&lt;/p&gt;
&lt;p&gt;例如，在之前你一直使用的简单HTML模板里，你可以在&amp;lt;main&amp;gt;里找到三个元素：&amp;lt;nav&amp;gt;，.content和&amp;lt;aside&amp;gt;。之前，它们都被挤在页面的左边。如果你想让它们之间有一些空间，但是不让第一个元素的左边有空间，也不想让最后一个元素的右边有空间，你可以把.main（即它们的父容器）里的justify-content设置为space-between。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.main {
  display: flex;
  justify-content: space-between;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;也试一下设置为space-around，观察不同的结果。例子在&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-6.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-6&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上面的例子中，我同样把&amp;lt;header&amp;gt;中的文字水平和垂直对齐了，分别是把justify-content（水平居中）和align-items（垂直居中）都设置为center。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
header {
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Flexbox&lt;/strong&gt;&lt;strong&gt;中弹性子项的大小&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;使用flex属性，你能够对照flex容器中其他元素来控制弹性子项的大小。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这个属性是以下独立属性的简写：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flex-grow：一个数字，指明元素如何相对其他flex项来拉伸&lt;/li&gt;
&lt;li&gt;flex-shrink：一个数字，指明元素如何相对其他flex项来收缩&lt;/li&gt;
&lt;li&gt;flex-basis：元素的长度。可接受的值有：auto，inherit或者一个数字后面紧跟着%，px，em或其他长度单位。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，想得到三个等宽的列，只需给每一列设置flex:1，其他什么都不用做：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
nav, aside, .content {
  flex: 1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;如果你需要.content占据&amp;lt;nav&amp;gt;和&amp;lt;aside&amp;gt;的两倍宽，那么就把.content设为flex:2，让其他两个为1。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;例子在&lt;a href=&quot;https://gitee.com/GrapeTech/flexbox-demo/blob/master/flexbox-demo-7.html&quot; target=&quot;_blank&quot;&gt;flexbox-demo-7.html&lt;/a&gt;。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那仅仅是对flex属性最简单的应用。同样可以设置flex-grow，flex-shrink和flex-basis这些值，不过那超出本文的话题范围了。&lt;/p&gt;
&lt;div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;进一步的资源&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;如果你准备好继续前进，并想学着精通flexbox的更多东西，请查看下面的资源：&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;如你所见，如果我们想控制元素在网页中的布局，flexbox可以让我们的生活更加轻松。它非常稳固和可靠，让以前那些我们每天使用的诸如使 让容器坍缩之类的奇技淫巧，成为了过去。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;像我们说的，如今，在针对整个页面进行布局时，CSS网格是更好的方案，但我们仍然值得去了解flexbox能做的那些事情。flexbox的最佳应用场景，体现在对元素的一维排列上，但如果有需要，它也能在稍老旧的浏览器中，为CSS网格布局提供方便的替代方案。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.grapecity.com.cn/events/specialoffers/?from=cnblogs&quot; target=&quot;_blank&quot;&gt;【年末促销】葡萄城 2018 岁末福利火热放送中&lt;/a&gt; &lt;img class=&quot;ml-1&quot; src=&quot;https://www.grapecity.com.cn/images/metalsmith/developer/hot.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 06:36:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>转载请注明出处：葡萄城官网，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。 【年末促销】葡萄城 2018 岁末福利火热放送中 原文出处：https://www.sitepoint.co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powertoolsteam/p/10000927.html</dc:identifier>
</item>
<item>
<title>KDtree浅谈 - Yang1208</title>
<link>http://www.cnblogs.com/yangsongyi/p/10000756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsongyi/p/10000756.html</guid>
<description>&lt;h3&gt;1.对KDtree的理解&lt;/h3&gt;
&lt;p&gt;　　首先要知道$KDtree$的用处，$KDtree$是用来进行多维数点的，一般这些点都是在在而二维及二维以上，因为一维上的问题，我们基本都可以运用线段树来解决。我对$KDtree$的理解就是一个自带剪枝的暴力，并且这个剪枝因为我们对这些多维上的点的较优秀的排列而显得十分有用。&lt;/p&gt;
&lt;h3&gt;2.前置知识&lt;/h3&gt;
&lt;p&gt;　　在学习$KDtree$之前要先知道并会运用西面三个知识点：&lt;/p&gt;
&lt;p&gt;​　　1) 首先，要会建二叉搜索树，因为整个$KDtree$就是一颗二叉搜索树。&lt;/p&gt;
&lt;p&gt;　　2) 还需要知道什么事估价函数，因为剪枝的时候要运用到估价函数。&lt;/p&gt;
&lt;p&gt;​　　3) 对空间的想象能力，因为$KDtree$是处理图形上的问题，所以还需要有一定的空间想象能力。&lt;/p&gt;
&lt;h3&gt;3.KDTree的讲解&lt;/h3&gt;
&lt;p&gt;　　因为$KDtree$是一种优美的暴力，并且我们要在上面剪枝，所以我们自然想让每一次剪枝，剪下去尽可能大的部分，所以我们能想到每一次将区间等大的分割，既然要的等大的分割，又要是二叉搜索树，我们就要让中间值作为当前节点，所有比它小的都放在它的左面，比它大的都放在它的右面。&lt;/p&gt;
&lt;p&gt;　　知道大致思路了，就要来定义什么是大小了，因为一个点是在多维里，所以和它有关的值有多个。最好想的就是按读入的顺序，进行排序，第一维作为第一关键字，第二维作为第二关键字，以此类推。我们根据这些点的维度将它们从小到大排序（下面已二维上的点为例），每一次取当前区间的中间值来建树。这样我们就能将整个图分成下面的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257114/201811/1257114-20181122141106498-1490320838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　显然这种分法分出的图并不是最有利，因为每一点的管辖范围都太小了。我们考虑另一种分割方式，我们将这些点的排序方式进行改变，我们将排序的关键字每一次向顺时针进行转动，即我们第一次排序的第一关键字是第一维，第二次是第二维……第$n$次是第$n\%维数+1$维。这样上面的图形就可以改变成为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257114/201811/1257114-20181122141141630-1597483177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样我们在剪枝的时候就能剪去更多的节点。&lt;/p&gt;
&lt;p&gt;　　知道了如何去排序，我们现在就要知道怎么来找中间值。在函数库里面有一个函数$nth\_element$，这个就能实现我们要的功能。这个函数不知道实现的话，可以上网上找一下学习一下。我们在建树的时候要维护出来几个值，这几个值的运用在下面会进行讲解。这几个值是$mn[0]，mx[0]，mn[1]，mx[1]$，分别表示以当前节点为根的子树第一维的最小值和最大值，第二维的最小值和最大值，这样我们在建树的时候应该更新。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct Node {long long pla[2],mn[2],mx[2];int id,lson,rson;}node[N];
bool cmp(const Node &amp;amp;a,const Node &amp;amp;b) {return a.pla[sta]&amp;lt;b.pla[sta];}
void up(int p,int k)
{
        node[p].mn[0]=min(node[p].mn[0],node[k].mn[0]);
        node[p].mx[0]=max(node[p].mx[0],node[k].mx[0]);
        node[p].mn[1]=min(node[p].mn[1],node[k].mn[1]);
        node[p].mx[1]=max(node[p].mx[1],node[k].mx[1]);
}
int build(int l,int r,int now)
{
        sta=now;int mid=(l+r)&amp;gt;&amp;gt;1;
        nth_element(node+l,node+mid,node+r+1,cmp);
        node[mid].mn[0]=node[mid].mx[0]=node[mid].pla[0];
        node[mid].mn[1]=node[mid].mx[1]=node[mid].pla[1];
        if(l!=mid) node[mid].lson=build(l,mid-1,(now+1)%2);
        if(r!=mid) node[mid].rson=build(mid+1,r,(now+1)%2);
        if(node[mid].lson) up(mid,node[mid].lson);
        if(node[mid].rson) up(mid,node[mid].rson);
        return mid;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　建树之后，我们就可以在里面进行一些操作，比如找离定点的最远点，最近点，维护矩形内信息等等，下面就是一些估价函数的代码，以及矩形内区间赋值。&lt;/p&gt;
&lt;p&gt;　　找离当前点的最远点的估价函数及查询（欧几里得距离）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
long long dis(int p) {return squ(node[p].pla[0]-x)+squ(node[p].pla[1]-y);}
long long getdis(int p)
{
        long long tmp=0;
        tmp+=squ(max(abs(node[p].mx[0]-x),abs(node[p].mn[0]-x)));
        tmp+=squ(max(abs(node[p].mx[1]-y),abs(node[p].mn[1]-y)));
        return tmp;
}
void ask(int p)
{
        long long tmp=dis(p);tmpx.dis=tmp,tmpx.id=node[p].id;
        if(q.top().dis&amp;lt;=tmpx.dis) q.push(tmpx),q.pop();
        long long tmpl=(node[p].lson)?getdis(node[p].lson):-inf;
        long long tmpr=(node[p].rson)?getdis(node[p].rson):-inf;
        if(tmpl&amp;gt;tmpr)
        {
                if(tmpl&amp;gt;=q.top().dis&amp;amp;&amp;amp;node[p].lson) ask(node[p].lson);
                if(tmpr&amp;gt;=q.top().dis&amp;amp;&amp;amp;node[p].rson) ask(node[p].rson);
        }
        else
        {
                if(tmpr&amp;gt;=q.top().dis&amp;amp;&amp;amp;node[p].rson) ask(node[p].rson);
                if(tmpl&amp;gt;=q.top().dis&amp;amp;&amp;amp;node[p].lson) ask(node[p].lson);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　找离当前点的最远点的估价函数及查询（曼哈顿距离）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int getdis_mx(int p)
{
    int tmp=0;
    tmp+=max(abs(node[p].mx[0]-x),abs(node[p].mn[0]-x));
    tmp+=max(abs(node[p].mx[1]-y),abs(node[p].mn[1]-y));
    return tmp;
}
void ask_mx(int p)
{
    int tmp=abs(node[p].pla[0]-x)+abs(node[p].pla[1]-y);
    if(tmp&amp;gt;lenth_mx) lenth_mx=tmp;
    int tmpl=(node[p].lson)?(getdis_mx(node[p].lson)):-inf;
    int tmpr=(node[p].rson)?(getdis_mx(node[p].rson)):-inf;
    if(tmpl&amp;gt;tmpr)
    {
        if(tmpl&amp;gt;lenth_mx) ask_mx(node[p].lson);
        if(tmpr&amp;gt;lenth_mx) ask_mx(node[p].rson);
    }
    else
    {
        if(tmpr&amp;gt;lenth_mx) ask_mx(node[p].rson);
        if(tmpl&amp;gt;lenth_mx) ask_mx(node[p].lson);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　找离当前点的最远点的估价函数及查询（曼哈顿距离）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int getdis_mn(int p)
{
    int tmp=0;
    if(x&amp;lt;node[p].mn[0]) tmp+=node[p].mn[0]-x;
    if(x&amp;gt;node[p].mx[0]) tmp+=x-node[p].mx[0];
    if(y&amp;lt;node[p].mn[1]) tmp+=node[p].mn[1]-y;
    if(y&amp;gt;node[p].mx[1]) tmp+=y-node[p].mx[1];
    return tmp;
}
void ask_mn(int p)
{
    int tmp=abs(node[p].pla[0]-x)+abs(node[p].pla[1]-y);
    if(tmp&amp;amp;&amp;amp;tmp&amp;lt;lenth_mn) lenth_mn=tmp;
    int tmpl=(node[p].lson)?(getdis_mn(node[p].lson)):inf;
    int tmpr=(node[p].rson)?(getdis_mn(node[p].rson)):inf;
    if(tmpl&amp;lt;tmpr)
    {
        if(tmpl&amp;lt;lenth_mn) ask_mn(node[p].lson);
        if(tmpr&amp;lt;lenth_mn) ask_mn(node[p].rson);
    }
    else
    {
        if(tmpr&amp;lt;lenth_mn) ask_mn(node[p].rson);
        if(tmpl&amp;lt;lenth_mn) ask_mn(node[p].lson);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　矩阵赋值，矩阵查找：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void pushdown(int p)
{
    if(!node[p].tag) return;
    if(node[p].lson) node[node[p].lson].tag=node[node[p].lson].col=node[p].tag;
    if(node[p].rson) node[node[p].rson].tag=node[node[p].rson].col=node[p].tag;
    node[p].tag=0;
}
void change(int p,int w,int x,int y,int z,int col)
{
    if(!p) return;
    if(node[p].mx[0]&amp;lt;w||node[p].mn[0]&amp;gt;x) return;
    if(node[p].mx[1]&amp;lt;y||node[p].mn[1]&amp;gt;z) return;
    pushdown(p);
    if(node[p].pla[0]&amp;gt;=w&amp;amp;&amp;amp;node[p].pla[0]&amp;lt;=x&amp;amp;&amp;amp;
        node[p].pla[1]&amp;gt;=y&amp;amp;&amp;amp;node[p].pla[1]&amp;lt;=z) node[p].col=col;
    if(node[p].mn[0]&amp;gt;=w&amp;amp;&amp;amp;node[p].mx[0]&amp;lt;=x&amp;amp;&amp;amp;
        node[p].mn[1]&amp;gt;=y&amp;amp;&amp;amp;node[p].mx[1]&amp;lt;=z) {node[p].tag=node[p].col=col;return;}
    change(node[p].lson,w,x,y,z,col),change(node[p].rson,w,x,y,z,col);
}
int find(int p,int w,int x,int y,int z)
{
    if(!p) return 0;
    if(node[p].mx[0]&amp;lt;w||node[p].mn[0]&amp;gt;x) return 0;
    if(node[p].mx[1]&amp;lt;y||node[p].mn[1]&amp;gt;z) return 0;
    pushdown(p);
    if(node[p].pla[0]==w&amp;amp;&amp;amp;node[p].pla[1]==y) return node[p].col;
    return max(find(node[p].lson,w,x,y,z),find(node[p].rson,w,x,y,z));
}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 22 Nov 2018 06:14:00 +0000</pubDate>
<dc:creator>Yang1208</dc:creator>
<og:description>KDtree浅谈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsongyi/p/10000756.html</dc:identifier>
</item>
<item>
<title>CentOS下Docker与.netcore(三）之 三剑客之一Docker-Compose - 伊辛伊忆</title>
<link>http://www.cnblogs.com/chenyishi/p/10000693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10000693.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1.什么是Docker-Compose&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;dockerfile&quot; href=&quot;https://www.cnblogs.com/chenyishi/p/9996815.html&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;&lt;span&gt;我们讲了通过Dockerfile创建镜像，这在一个小项目中是没问题的，但如果在一个包含多个项目的情况下，我们每次部署都需要执行多次创建镜像与运行容器的命令，这样就比较麻烦，为了解决这种情况，Docker-Compose出现了。Docker-Compose主要就是为了解决在一台服务器创建镜像与运行容器复杂的问题，有了Docker-Compose我们就可以通过一条命令，生成多镜像与运行容器。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.Docker-Compose安装&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; curl -L &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o /usr/local/bin/docker-&lt;span&gt;compose
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; +x /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查看安装是否成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181122112004657-1507119970.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;34&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.创建两个.netcore项目，不启用https&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;ServerProvider项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新增Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.1&lt;span&gt;-aspnetcore-runtime
&lt;/span&gt;&lt;span&gt;MAINTAINER&lt;/span&gt;&lt;span&gt; yishi.chen

&lt;/span&gt;&lt;span&gt;LABEL&lt;/span&gt; description=&quot;this is a serverprovider website&quot;
&lt;span&gt;LABEL&lt;/span&gt; version=&quot;1.0&quot;

&lt;span&gt;ARG&lt;/span&gt;&lt;span&gt; serverport

&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt; bin/Release/netcoreapp2.1&lt;span&gt;/publish/ .
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt;&lt;span&gt; $serverport
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;,&quot;ServerProvider.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Program.cs改动&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                .UseUrls($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:{Environment.GetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;serverport&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ValuesController.cs改动&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ServerProvider.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is serverprovider's result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ServerConsumer项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新增Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.1&lt;span&gt;-aspnetcore-runtime
&lt;/span&gt;&lt;span&gt;MAINTAINER&lt;/span&gt;&lt;span&gt; yishi.chen

&lt;/span&gt;&lt;span&gt;LABEL&lt;/span&gt; description=&quot;this is a serverconsumer website&quot;
&lt;span&gt;LABEL&lt;/span&gt; version=&quot;1.0&quot;

&lt;span&gt;ARG&lt;/span&gt;&lt;span&gt; consumerport

&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt; bin/Release/netcoreapp2.1&lt;span&gt;/publish/ .
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt;&lt;span&gt; $consumerport
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;,&quot;ServerComsumer.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Program.cs改动&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                .UseUrls($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:{Environment.GetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;consumerport&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ValueController.cs改动&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http.Headers;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ServerComsumer.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values/5&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            httpClient.DefaultRequestHeaders.Accept.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MediaTypeWithQualityHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; httpClient.GetAsync(Environment.GetEnvironmentVariable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;serverurl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).Result.Content.ReadAsStringAsync();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;新建docker-compose.yml编排文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181122140408828-2048272709.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容如下（docker-compose的配置请见&lt;a title=&quot;docker-compsoe&quot; href=&quot;https://www.cnblogs.com/chenyishi/p/9965479.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenyishi/p/9965479.html&lt;/a&gt;）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: '3'&lt;span&gt;
services:
  s_provider:
    build:
      context: ./ServerProvider/
      dockerfile: Dockerfile
      args:
        serverport: &lt;/span&gt;1000&lt;span&gt;
    ports:
      - &lt;/span&gt;&quot;1000:1000&quot;&lt;span&gt;
    environment:
      serverport: &lt;/span&gt;1000&lt;span&gt;
    container_name: c_provider
  s_consumer:
    build:
      context: ./ServerComsumer/
      dockerfile: Dockerfile
      args:
        consumerport: &lt;/span&gt;2000&lt;span&gt;
    ports:
      - &lt;/span&gt;&quot;2000:2000&quot;&lt;span&gt;
    links:
      - s_provider:s_provider
    environment:
      consumerport: &lt;/span&gt;2000&lt;span&gt;
      serverurl: http:&lt;/span&gt;//s_provider:1000/api/values/
    container_name: c_consumer
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt; 4.定位到docker-compose文件所在目录，运行docker-compose&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos WebDocker]# docker-compose up
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行成功，状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181122140712885-1262600231.png&quot; alt=&quot;&quot; width=&quot;1009&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5.另起一个命令窗口，测试接口&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos ~]# curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:1000/api/values&lt;/span&gt;
[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is serverprovider's result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
root@cys-test-centos ~]# curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:2000/api/values&lt;/span&gt;
[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos ~]# curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:2000/api/values/1&lt;/span&gt;
[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is serverprovider's result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是通过docker-compose 新建镜像，并运行容器，如果镜像已存在，则可以去掉构建的过程，我们稍微对docker-compose文件做一下调整&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6.在上面步骤的前提下，先CtrlC停止容器，然后docker-compsoe down删除容器&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos WebDocker]# docker-&lt;span&gt;compose down
Removing c_consumer ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Removing c_provider ... &lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;
Removing network webdocker_default&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;7.查看生成的镜像&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@cys-test-&lt;span&gt;centos WebDocker]# docker images
REPOSITORY             TAG                      IMAGE ID            CREATED             SIZE
webdocker_s_consumer   latest                   cc95654856e1        &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt; minutes ago      253MB
webdocker_s_provider   latest                   5b744758b56b        &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt; minutes ago      253MB
microsoft&lt;/span&gt;/dotnet       &lt;span&gt;2.1&lt;/span&gt;-aspnetcore-runtime   db366d73508b        &lt;span&gt;4&lt;/span&gt; days ago          253MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;镜像名为：webdocker_s_provider与webdocker_s_consumer&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;8.修改docker-compose.yml文件&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
version: '3'&lt;span&gt;
services:
  s_provider:
    image: webdocker_s_provider
    ports:
      - &lt;/span&gt;&quot;1000:1000&quot;&lt;span&gt;
    environment:
      serverport: &lt;/span&gt;1000&lt;span&gt;
    container_name: c_provider
  s_consumer:
    image: webdocker_s_consumer
    ports:
      - &lt;/span&gt;&quot;2000:2000&quot;&lt;span&gt;
    links:
      - s_provider:s_provider
    environment:
      consumerport: &lt;/span&gt;2000&lt;span&gt;
      serverurl: http:&lt;/span&gt;//s_provider:1000/api/values/
    container_name: c_consumer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;9.验证接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos ~]# curl http://localhost:2000/api/values/1
[&quot;this is serverprovider's result&quot;]
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Thu, 22 Nov 2018 06:05:00 +0000</pubDate>
<dc:creator>伊辛伊忆</dc:creator>
<og:description>1.什么是Docker-Compose 上一章我们讲了通过Dockerfile创建镜像，这在一个小项目中是没问题的，但如果在一个包含多个项目的情况下，我们每次部署都需要执行多次创建镜像与运行容器的命令</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10000693.html</dc:identifier>
</item>
<item>
<title>软件测试员这些坑一定要记住了 - 疯狂的程序员丶</title>
<link>http://www.cnblogs.com/AndroidNO1/p/10000672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AndroidNO1/p/10000672.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;软件测试干了几年，项目一个接着一个，一路从一个坑跳入另一个坑，有些是开发问题，一些是测试本人问题，大家在测试过程中踩过哪些坑尼？&lt;/p&gt;

&lt;p&gt;1.自以为了解业务逻辑，实际浮于表面&lt;br/&gt;这是个深坑，产品迭代跟的久了，功能上闭着眼睛都能说清楚就自以为很了解，实际上连该功能使用的协议，调用的接口都不知道，所以看到问题都是表面的问题。&lt;br/&gt;你只看到了两个操作的入口不一样，提示信息不一样，你就以为是两个问题，而这两个问题都是调同一个接口引起的，但你分析不出来。。&lt;br/&gt;这样导致的问题有：&lt;br/&gt;①修改bug后对影响范围评估不够&lt;br/&gt;②提相同的bug，碰上特别注重bug数量的开发，真是揪心。。&lt;br/&gt;我们公司对于bug定期要做bug根因分析，这在一定程度上也是帮助测试更深入的了解产品，因为每次bug单上开发写的产生原因和解决方案，真是言简意赅。。&lt;/p&gt;
&lt;p&gt;2.思维定死，不会向前多走一步&lt;br/&gt;比如同一个账号添加之后删除再添加，同一份文档导入之后导出再导入，密码修改成功之后再修改，等等，向前多走一步，就可能有意外收获。&lt;/p&gt;


&lt;p&gt;3.忽略偶现的问题&lt;br/&gt;测试要记住：所有偶现的问题，都只是没有找到必现的规律！&lt;br/&gt;不要以为偶现的问题，没有出现，就不提出来，等上线后用户发现这个问题，你再说曾经遇到过，只是没有提出来，那测试不背锅还有谁背？？&lt;br/&gt;提出问题但不解决，测试就可以甩锅给产品，给开发，完美！（这个真是从踩过的坑里得出血淋淋的教训）&lt;br/&gt;这里有个好的习惯：遇到问题先截图！！！先录视频！！！再分析原因，再提交给开发，最怕偶现的问题口说无凭，又没有证据证明，开发说你逗我呢？？？&lt;/p&gt;
&lt;p&gt;4.避免随机测试&lt;br/&gt;避免没有用例而进行的随机测试，虽然随机测试能发现一些问题，但是它的特点是我们测试人员想到什么就测试什么，这样就会导致有些功能点重复测试，而有的业务流程却没有覆盖到，出现漏测，一旦上线后出现Bug，就不好说了。&lt;/p&gt;



&lt;p&gt;5.Bug的复现步骤描述必须要详细&lt;br/&gt;这个其实算不上坑，只是个人总结。之前提交过一个Bug，Bug描述非常简单，在后期给开发复现的时候，费了很大的劲儿，如果我们能在Bug描述中，准确描述Bug的复现步骤，就可以明显缩短开发分析问题、定位问题的时间。&lt;/p&gt;


&lt;p&gt;6.不要 “动” 之前的业务逻辑，因为会 “牵一发而动全身”&lt;br/&gt;要 “遵守” 之前的业务逻辑，现有的业务逻辑尽量不要和之前的冲突，为啥呢？&lt;br/&gt;因为啊，一旦按照现在业务逻辑的话，就得把之前的改了，改之前的业务逻辑会非常的复杂，不仅开发需要改代码，而且我们测试要重新再测，所以，不要动之前的业务逻辑。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Nov 2018 06:01:00 +0000</pubDate>
<dc:creator>疯狂的程序员丶</dc:creator>
<og:description>恢复内容开始 软件测试干了几年，项目一个接着一个，一路从一个坑跳入另一个坑，有些是开发问题，一些是测试本人问题，大家在测试过程中踩过哪些坑尼？ 1.自以为了解业务逻辑，实际浮于表面这是个深坑，产品迭代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AndroidNO1/p/10000672.html</dc:identifier>
</item>
<item>
<title>Squid实现正向代理及访问控制--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9994370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9994370.html</guid>
<description>
&lt;h2&gt;Squid及正向代理简介&lt;/h2&gt;
&lt;p&gt;Squid cache(简称为Squid)是一个流行的自由软件，它符合GNU通用公共许可证。Squid作为网页服务器的前置cache服务器，可以代理用户向web服务器请求数据并进行缓存，也可以用在局域网中，使局域网用户通过代理上网。Squid主要设计用于在Linux一类系统运行。--摘自360百科&lt;/p&gt;
&lt;p&gt;本篇博客将详细演示如何使用squid实现正向代理以及浏览内容过滤。&lt;/p&gt;
&lt;p&gt;所谓正向代理模式，是指让用户通过Squid服务程序获取网站页面等资源，以及基于访问控制列表（ACL）功能对用户访问网站行为进行限制，在具体的服务方式上又分为标准代理模式与透明代理模式。标准正向代理模式是把网站数据缓存到服务器本地，提高数据资源被再次访问时的效率，但是用户在上网时必须在浏览器等软件中填写代理服务器的IP地址与端口号信息，否则默认不使用代理服务。&lt;/p&gt;

&lt;h2&gt;Squid正向代理访问流程&lt;/h2&gt;

&lt;p&gt;使用Squid服务程序提供正向代理服务的拓扑如下图所示。局域网内的主机如果想要访问外网，则必须要通过Squid服务器提供的代理才行，这样当Squid服务器接收到用户的指令后会向外部发出请求，然后将接收到的数据交还给发出指令的那个用户，从而实现了用户的代理上网需求。另外，从拓扑图中也不难看出，企业中的主机要想上网，就必须要经过公司的网关服务器，既然这是一条流量的必经之路，因此企业一般还会把Squid服务程序部署到公司服务器位置，并通过CL（访问控制列表）功能对企业内员工进行上网审计及限制。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121144118767-626632566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Squid安装环境准备&lt;/h2&gt;
&lt;p&gt;这里我准备了两台虚拟机，鉴于工作中大部分都是Windows使用代理，所以我就使用windows来演示了。一台安装linux,另外一台安装windows，无论是windows还是linux都是一样的！&lt;/p&gt;
&lt;p&gt;服务器端需要准备两块网卡，一块网卡负责对内通信，另外一张网卡负责对外通信。&lt;/p&gt;
&lt;p&gt;服务器端linux：   外网IP： 172.20.10.2&lt;/p&gt;
&lt;p&gt;                            内网IP：  192.168.11.2&lt;/p&gt;
&lt;p&gt;客户端windows：内网IP:    192.168.11.137&lt;/p&gt;

&lt;h4&gt;linux服务器&lt;/h4&gt;
&lt;p&gt;第一步：代理服务器添加网卡&lt;/p&gt;
&lt;p&gt;一个连接外网，一个连接内网&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121191748751-1789308204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：生成网卡配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken network-scripts]# cp ifcfg-eth0 ifcfg-&lt;span&gt;eth1
[root@ken network&lt;/span&gt;-scripts]# vim ifcfg-&lt;span&gt;eth1
NAME&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eth1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
DEVICE&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eth1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ONBOOT&lt;/span&gt;=&lt;span&gt;yes
NETBOOT&lt;/span&gt;=&lt;span&gt;yes
BOOTPROTO&lt;/span&gt;=&lt;span&gt;static&lt;/span&gt;&lt;span&gt;
TYPE&lt;/span&gt;=&lt;span&gt;Ethernet
IPADDR&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;11.2&lt;/span&gt;&lt;span&gt;
NETMASK&lt;/span&gt;=&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：重启网络&lt;/p&gt;
&lt;p&gt;至此linux网卡配置完成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@ken network-scripts]# ip a |&lt;span&gt; grep eth1
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1500&lt;/span&gt; qdisc pfifo_fast state UNKNOWN group &lt;span&gt;default&lt;/span&gt; qlen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
    inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;11.2&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; brd &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;108.255&lt;/span&gt; scope &lt;span&gt;global&lt;/span&gt; noprefixroute eth1
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;windows客户端&lt;/h4&gt;
&lt;p&gt;只需要给客户端添加一个内网IP即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121225346104-944081341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在可以使用仅主机模式下的windows访问外网，发现是访问不通的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121225613871-834800109.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Squid安装&lt;/h2&gt;
&lt;p&gt;第一步：关闭防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl stop firewalld
[root@ken &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：下载squid服务程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install squid -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：启动squid&lt;/p&gt;
&lt;p&gt;squid默认监听的是3128端口,安全起见，在公司内部布置的正向代理服务器建议修改监听的端口号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl restart squid
[root@ken &lt;/span&gt;~]# ss -tnl | grep &lt;span&gt;3128&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;1024&lt;/span&gt;        :::&lt;span&gt;3128&lt;/span&gt;                    :::*    
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Squid实现正向代理&lt;/h2&gt;
&lt;p&gt;其实下载并启动完成之后，我们就可以使用squid代理服务了。&lt;/p&gt;
&lt;p&gt;第一步：打开你的浏览器工具&amp;gt;Internet选项，看到如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121145916301-526477677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步：点击连接&amp;gt;局域网设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121150021829-1479335710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到如下的界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121150100901-296928900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：填写服务器端内网IP及squid的端口号，点击确定即可。&lt;/p&gt;
&lt;p&gt;填写的是内网代理端的内网IP，可以和客户端通信的IP网段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121225808869-18471945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第四步：浏览器测试&lt;/p&gt;
&lt;p&gt;刷新浏览器即可发现仅主机模式下的windows也可以上网了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121230100351-590623272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Squid常用的访问控制列表&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121160655754-285029605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;url_regex与urlpath_regex的区别&lt;/h4&gt;
&lt;h5&gt;1.  url_regex&lt;/h5&gt;
&lt;p&gt;url_regex ACL用于匹配请求URL的任何部分，包括传输协议和原始服务器主机名。例如，如下ACL匹配从FTP服务器的MP3文件请求：&lt;/p&gt;
&lt;pre&gt;
acl FTPMP3 url_regex -i ^ftp://.*\.mp3$
&lt;/pre&gt;
&lt;h5&gt;2.  urlpath_regex&lt;/h5&gt;
&lt;p&gt;urlpath_regex与url_regex非常相似，不过传输协议和主机名不包含在匹配条件里。这让某些类型的检测非常容易。例如，假设你必须拒绝URL里的&quot;sex&quot;，但仍允许在主机名里含有&quot;sex&quot;的请求，那么这样做：&lt;/p&gt;
&lt;pre&gt;
acl Sex urlpath_regex sex
&lt;/pre&gt;
&lt;p&gt;另一个例子，假如你想特殊处理cgi-bin请求，你能这样捕获它们：&lt;/p&gt;
&lt;pre&gt;
acl CGI1 urlpath_regex ^/cgi-bin
&lt;/pre&gt;
&lt;p&gt;当然，CGI程序并非总在/cgi-bin/目录下，这样你应该编写其他的ACL来捕获它们。&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;p&gt;                  1. url_regex匹配整个URL部分，包含传输协议和主机名&lt;/p&gt;
&lt;p&gt;                  2. urlpath_regex不包含传输协议和主机名   &lt;/p&gt;
&lt;p&gt;                  3. 可以单独使用url_regex完成百分之90以上的工作&lt;/p&gt;
&lt;p&gt;                  4. url_regex和urlpath_regex都支持正则&lt;/p&gt;
&lt;p&gt;                  5. URL中的.需要使用\进行转义     &lt;/p&gt;

&lt;h2&gt;Squid正向代理之ACL访问控制&lt;/h2&gt;

&lt;h4&gt;演示一：只允许192.168.43.1主机使用代理服务&lt;/h4&gt;
&lt;p&gt; 第一步：修改配置文件&lt;/p&gt;
&lt;pre&gt;
acl ken src 192.168.43.1/24 ：定义了一个别名ken
&lt;/pre&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;http_access all ken         ：定义了允许来自ken的访问&lt;p&gt;http_access deny all        ：拒绝其他任何主机的访问&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/squid/squid.conf&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;27&lt;/span&gt; acl ken src &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.1&lt;/span&gt;/&lt;span&gt;24   &lt;/span&gt;
 &lt;span&gt;28&lt;/span&gt; 
 &lt;span&gt;29&lt;/span&gt;&lt;span&gt; #
 &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt; # Recommended minimum Access Permission configuration:
 &lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt; #
 &lt;/span&gt;&lt;span&gt;32&lt;/span&gt; # Deny requests to certain &lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt; ports
 &lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt; http_access all ken
 &lt;/span&gt;&lt;span&gt;34&lt;/span&gt; http_access deny all&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：重启squid服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart squid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：window端刷新界面&lt;/p&gt;
&lt;p&gt;发现已经上不去网了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121230626739-1185194804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;演示二：禁止访问www.baidu.com网站&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在做一个演示的时候把之前定义的规则都删掉&lt;/p&gt;
&lt;p&gt;第一步：修改配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;acl ken url_regex www.baidu.com   #定义url_regex规则
acl kenken src &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;11.137     #定义客户端地址&lt;/span&gt;&lt;span&gt;

#
# Recommended minimum Access Permission configuration:
#
# Deny requests to certain &lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt; ports
http_access deny ken             #拒接url
http_access allow kenken         #接受客户端地址的访问&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：重启服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart squid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：window端查看&lt;/p&gt;
&lt;p&gt;现在我的博客又能访问了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121231247945-817397292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在访问下百度网站试试&lt;/p&gt;
&lt;p&gt;现在访问被拒绝了，说明我们配置是生效的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121231338514-181697127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;演示三：禁止网址中包含redis的网站&lt;/h4&gt;
&lt;p&gt; 第一步：修改配置文件&lt;/p&gt;
&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;p&gt;.*表示任意长度的任意内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
acl ken url_regex .*redis.*&lt;span&gt;
acl kenken src &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;11.137&lt;/span&gt;&lt;span&gt;

#
# Recommended minimum Access Permission configuration:
#
# Deny requests to certain &lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt; ports
http_access deny ken
http_access allow kenken&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：重启服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart squid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：windows端查看&lt;/p&gt;
&lt;p&gt;现在我的博客还是能访问的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121231624192-160410106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;浏览一下redisdoc网站&lt;/p&gt;
&lt;p&gt;可以发现只要带有redis的网站都会被拒绝访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121231713573-2058702122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;演示四：禁止访问网址中以mp3为结尾的网站&lt;/h4&gt;
&lt;p&gt;这个我就不演示了无非就是添加一条 acl ken url_regex .*mp3$&lt;/p&gt;
&lt;p&gt;acl写来写去还是考验大家的正则表达式&lt;/p&gt;
&lt;p&gt;大家有兴趣的可以找一个这样的网站来测试一下&lt;/p&gt;

&lt;h4&gt;演示五：基于时间段20:00-8:00&lt;/h4&gt;
&lt;p&gt; 第一步：修改配置文件&lt;/p&gt;
&lt;p&gt;定义一个时间段&lt;/p&gt;
&lt;p&gt;拒绝该时间段的访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
acl ken time &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;50   &lt;/span&gt;&lt;span&gt;
acl kenken src &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;11.137&lt;/span&gt;&lt;span&gt;

#
# Recommended minimum Access Permission configuration:
#
# Deny requests to certain &lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt; ports
http_access deny ken
http_access allow kenken&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：重启服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart squid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：windows端查看&lt;/p&gt;
&lt;p&gt;该时段下的上网服务会被拒绝&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181121233117418-1867949172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 22 Nov 2018 06:01:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>Squid及正向代理简介 Squid cache(简称为Squid)是一个流行的自由软件，它符合GNU通用公共许可证。Squid作为网页服务器的前置cache服务器，可以代理用户向web服务器请求数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9994370.html</dc:identifier>
</item>
<item>
<title>redis 系列16 持久化 RDB - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9999957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9999957.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一.概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Redis是内存数据库，一旦服务器进程退出，服务器中的数据库内存数据状态也会消失。为了解决这个问题，Redis提供了RDB 持久化功能，这个功能可以将redis在内存中的数据库状态保存到磁盘中，避免数据意外丢失。&lt;/p&gt;
&lt;p&gt;　　RDB持久化可以手动执行，也可以根据服务器配置选项定期执行，是在指定的时间间隔,对你的数据进行快照存储。该RDB文件快照是一个经过压缩的二进制文件。文件名为dump.rdb，该文件保存在redis目录下，当redis服务器停机后，只要RDB文件存在，下次重启Redis服务时就会自动还原数据库数据状态。&lt;/p&gt;

&lt;p&gt;　　1.1 RDB文件的创建&lt;/p&gt;
&lt;p&gt;　　　　通过Redis两个命令来生成RDB文件，一是SAVE，另一个是BGSAVE。SAVE命令是会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在阻塞期间，服务器不能处理任何命令请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; save   --&lt;span&gt; 等待RDB文件创建完毕
    OK    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　与SAVE不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。当BGSAVE命令在执行期间，客户端再发送BGSAVE命令会被服务器拒绝，因为同时执行两个GBSAVE命令也会产生竞争条件。最后BGREWRITEAOF和GBSAVE两个命令也不能同时执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; bgsave  --&lt;span&gt;派生子进程，并由子进程创建RDB文件
    Background saving started&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1.2 RDB文件载入&lt;/p&gt;
&lt;p&gt;　　　　和创建文件不同，RDB文件的载入是在服务器启动时自动执行的，并没有用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件的存在，它就会自动载入RDB文件。能过启动时日志记录可以查看。需要注意的是，如果打开了AOF持久化，那么服务器会优先使用AOF文件来还原数据库状态。&lt;/p&gt;

&lt;p&gt;　　1.3 自动间隔性保存&lt;/p&gt;
&lt;p&gt;　　　　文件的创建除了SAVE和GBSAVE保存RDB 文件，还可以通过配置SAVE选项，让服务器每隔一段时间自动执行一次BGSAVE命令。可以配置SAVE选项设置多个保存条件，只要任意一个条件被满足，服务器就会执行BGSAVE命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    --&lt;span&gt;默认配置的SAVE选项，保存方式有三种条件，满足任意一种就可以，如下：
    &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; config &lt;span&gt;get&lt;/span&gt;&lt;span&gt; save
    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;save&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;900 1 300 10 60 10000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(1) 服务器在900秒之内，对数据库进行了至少1次修改。&lt;/p&gt;
&lt;p&gt;　　　　(2) 服务器在300秒之内，对数据库进行了至少10次修改。&lt;/p&gt;
&lt;p&gt;　　　　(3) 服务器在60秒之内，对数据库进行了至少10000次修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201811/151560-20181122111900058-777542157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1.4 检查保存条件是否满足&lt;/p&gt;
&lt;p&gt;　　　　Redis的服务器周期性操作默认每隔100毫秒就会检查执行一次，用于对正在运行的服务器进行维护，其中一项工作是检查save 选项所设置的保存条件是否已经满足，如果满足就调用BGSAVE命令。&lt;/p&gt;

&lt;p&gt;　　1.5  RDB工作方式&lt;/p&gt;
&lt;p&gt;　　　　当Redis需要保存dump.rdb文件时，服务器执行以下操作：&lt;/p&gt;
&lt;p&gt;　　　　(1)Redis调用forks. 同时拥有父进程和子进程。&lt;/p&gt;
&lt;p&gt;　　　　(2)子进程将数据集写入到一个临时 RDB 文件中。&lt;/p&gt;
&lt;p&gt;　　　　(3)当子进程完成对新 RDB 文件的写入时，Redis用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。&lt;/p&gt;

&lt;p&gt;　　1.6  RDB 文件结构&lt;/p&gt;
&lt;p&gt;　　　　下面简单了解一下RDB文件结构，这里不再深入了解。下面脚本显示了本机dump.rdb文件的位置。该rdb文件结构中各部分 如下图表格所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [root@xuegod64 redis]# pwd
    &lt;/span&gt;/usr/local/&lt;span&gt;redis
    [root@xuegod64 redis]# ls &lt;/span&gt;-&lt;span&gt;l
    &lt;/span&gt;-rwxrwxrwx &lt;span&gt;1&lt;/span&gt; root root    &lt;span&gt;1687&lt;/span&gt; 11月 &lt;span&gt;22&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt; dump.rdb
&lt;/pre&gt;&lt;/div&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;文件结构各部份&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;redis&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;RDB文件最开头是REDIS部分，保存五个字符，程序在载入文件时，快速检查所载入的文件是否是RDB文件&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Db_version&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;一个字符串表示的整数，4个字节，记录了RDB文件的版本号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;databases&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;该部份包含着0个或任意多个数据库，以及各数据库中的键值对数据&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Eof&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;占1个字节，标志着RDB文件正文内容的结束，当程序遇到这个值的时候，就知道所有数据库的所有键值对都已经载入完毕了&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Check_sum&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;占8字节的无符号整数，保存一个校验和，通过前四部分内容进行计算得出。用来检查RDB文件是否出错或者损坏&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　下面通过linux的od命令来查看redis服务器产生的RDB 文件，并指定-c参数可以以ASCII编码方式打印信息。信息中能直接看到的信息是：第一部分是redis,  Db_version部分是0008, Eof部分是372 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201811/151560-20181122112111786-1516465301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1.7  RDB优势&lt;/p&gt;
&lt;p&gt;　　　　(1) RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集。&lt;/p&gt;
&lt;p&gt;　　　　(2)RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心，非常适用于灾难恢复。&lt;/p&gt;
&lt;p&gt;　　　　(3)RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能。&lt;/p&gt;
&lt;p&gt;　　　　(4)与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些。&lt;/p&gt;

&lt;p&gt;　　1.8  RDB缺点&lt;/p&gt;
&lt;p&gt;　　　　(1)如果数据不允许任何丢失，那么RDB不适合（虽然可以配置不同的save时间点）。&lt;/p&gt;
&lt;p&gt;　　　　(2)经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二. RDB持久化测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;(1) 首先关闭redis服务。当关闭服务时报错，首先检查一下是否是权限的问题，因为在shutdown命令的时候，会进行save操作，而save需要操作dump.rdb文件，如果没有权限则会报这个错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [root@xuegod64 redis]# redis-&lt;span&gt;cli shutdown
    (error) ERR Errors trying to SHUTDOWN. Check logs
    &lt;/span&gt;--&lt;span&gt; 需要放开对dump.rdb文件的写入权限，服务关闭成功
    [root@xuegod64 redis]# redis&lt;/span&gt;-&lt;span&gt;cli shutdown
    [root@xuegod64 redis]# redis&lt;/span&gt;-cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(2) 服务启动，首先set 写入一条数据,然后关闭服务进程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    [hsr@xuegod64 redis]$ redis-&lt;span&gt;serverredis.conf
    &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;set&lt;/span&gt; name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    OK
    &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt; exit
    [hsr@xuegod64 redis]$ redis&lt;/span&gt;-cli shutdown
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(3)重次重启服务,查看持久化&lt;/p&gt;
&lt;p&gt;　　　　查看刚才的键值对，发现键值对已存在，说明数据持久化保存到了磁盘中，原理是在关闭服务时，会先调用save操作，保存到dump.rdb文件中,在重启服务后，加载dump.rdb文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    [hsr@xuegod64 redis]$ redis-&lt;span&gt;serverredis.conf
    [hsr@xuegod64 redis]$ redis&lt;/span&gt;-&lt;span&gt;cli
    &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;strong&gt;　总结：作为RDB快照持久化，如果是正常关闭redis服务，再重启后数据是不会丢失的，但如果系统崩溃或者强杀，用户将会丢失最近一次生成快照之后更改的所有数据。&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 22 Nov 2018 04:35:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 Redis是内存数据库，一旦服务器进程退出，服务器中的数据库内存数据状态也会消失。为了解决这个问题，Redis提供了RDB 持久化功能，这个功能可以将redis在内存中的数据库状态保存到磁盘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9999957.html</dc:identifier>
</item>
<item>
<title>创建型设计模式对比总结 设计模式(八) - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9995954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9995954.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;创建型模式是new 的一种替代方式，可以将对象的创建与具体的类型进行分离&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前已经介绍了5种创建型设计模式（如果简单工厂算一种的话，那就是6种）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式、单例模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;简单工厂模式&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;静态工厂方法是一种最简单的创建的替代方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本上不涉及复杂的处理过程，可能执行的仅仅是包装、转换等 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如，一个静态方法，根据参数进行if else判断，或者switch选择进而确定需要创建的对象类型 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，Long内部的valueOf 接受不同类型的参数，进而转换为Long类型对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他可以是一个方法，也可以有多个静态方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管通常简单工厂模式将只会创建一种类型的产品对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，你也可以N个静态方法，创建N多种不同类型的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过一般不这么用，不够清晰，没有条理杂乱，完全不符合单一职责原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以对于简单工厂模式，我们一般说简单工厂模式只能创建一种类型的产品&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单工厂模式它的核心就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一个类  静态方法    来解决对象的创建问题&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一个类吃遍天下&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;工厂方法模式&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;简单工厂模式一个类吃遍天下，职责过多，就会有各种原因可能要修改这个类，好比你是两个班级的班主任，不管哪个班级的学生有事情都要找你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既不符合单一职责原则，也不符合开闭原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以为了解决这个问题，进化出来工厂方法模式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;工厂方法模式不再是一个类吃遍天下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;工厂方法模式通过与产品等级结构相同的工厂等级结构，对产品进行创建&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个工厂不再是多个职责，仅仅创建一种类型的产品，符合单一职责&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，对于新增的产品等级，只需要扩展工厂，而不需要修改现有的工厂&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说&lt;span&gt;&lt;strong&gt;工厂方法模式是简单工厂模式的标准版本，规范版本&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工厂方法定义了一个用于创建对象的接口，他的子类（具体的工厂类）负责具体产品的创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个抽象的工厂角色并不知道他所创建的对象的具体类型，因为是子类决定了具体类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;将创建对象的职责委托给了多个子类中的一个，所以也说工厂方法模式将对象的创建延迟到其子类&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Creator creator = new ConcreteCreator（）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Product product= creator.create（）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端通过creator.create（）获得产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不用关心Creator具体的类型，也不知道Product具体的类型，都是面向抽象的编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建的产品的具体的类型完全是动态的根据creator的具体的类型ConcreteCreator决定的&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;所以工厂方法模式也叫做&lt;span&gt;&lt;strong&gt;多态工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;抽象工厂模式&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;工厂方法模式虽然解决了简单工厂模式中的各种问题，进行了升级改良&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;工厂模式只能创建一种类型的产品&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为工厂模式的顶级抽象角色规定了创建的协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他只有一种返回类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;为了解决工厂方法只能创建一种类型的产品的弊端，又拓展出抽象工厂的模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;将工厂的创建能力拓展到产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是顶级的抽象角色中，可以创建一系列类型的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一系列类型的产品中的一员（每种类型一个）就组成了一个产品族的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际使用的时候，一定要注意，他们&lt;span&gt;&lt;strong&gt;必须要有产品族的概念&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你没有产品族的概念，非要生搬硬套的组织在一起，比如一个工厂生产轮胎和CPU和热水袋，他们之间使用时毫无关联，必然不会符合单一职责原则 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了产品族的概念，而且这一族产品也很可能一起出现使用，才是抽象工厂模式最好的运用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;当一个系统要由多个产品系列中的一个来配置时，典型的就是类似厂家替换这种场景，非常适合抽象工厂&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;建造者模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;span&gt;在有了能够生产一族产品的能力之后，比如可以生产 轮胎 发动机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，就会有应用这一族产品的需求 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对于这一族产品的运用，又可以将他们使用逻辑，也就是装配逻辑进行分离，这个分离就是&lt;/span&gt;&lt;span&gt;建造者模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;建造者模式仅仅关心构造一个完整复杂产品的步骤，而不关心生产细节&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;细节由具体的builder进行实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;builder就相当于抽象工厂模式中的Creator，只不过builder还要负责每一个步骤的装配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者模式也通常借助于抽象工厂模式来进行实现，就是Creator也负责最终产品的组装交付&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;原型模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;span&gt;原型模式类似与工厂模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工厂模式是通过&lt;/span&gt;&lt;span&gt;“创建”&lt;/span&gt; &lt;span&gt;来获得对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;而原型模式则是通过&lt;/span&gt;&lt;span&gt;“复制”&lt;/span&gt;&lt;span&gt;来获得对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java语言的机制---所有的类都继承自Object，使得&lt;span&gt;&lt;strong&gt;Java天然的支持原型模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要实现Cloneable接口即可，另外按照你的需要看是否实现clone方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于稍微复杂点的原型模式下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如创建的原型对象数量不固定或者产品种类较多，不方便管理，还出现了 带“管家”的原型模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过管理器这个管家对原型对象进行管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他提供获取对象的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原型模式是另一种视角的创建&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;span&gt;单例模式逻辑含义比较简单，就是&lt;span&gt;&lt;strong&gt;有些场景就是需要唯一的对象，或者说有些场景没必要使用多个对象&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;保证类只有一个实例，并提供一个访问他的全局访问点&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，原型模式中的管理器，除非特殊必要，否则他就应该是一个单例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再比如，windows的任务管理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重点是实现的过程---如何保证的确只有一个对象被产生&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;这个全局唯一的访问点往往又是简单工厂模式---一个静态方法提供&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;对比、联系、区别&lt;/span&gt;&lt;/h3&gt;
&lt;hr noshade=&quot;noshade&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;本身作为创建型模式，他们必然拥有相同的特征--“创建”对象，只不过是侧重点不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且各种类型模式之间，很难不发生点关系&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最基本的共性就是&lt;span&gt;&lt;strong&gt;都是用来创建对象，都是new的替代方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单工厂、工厂方法、抽象工厂、建造者、原型都是创建对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而单例除了第一次创建，其余时候都是返回一个已经存在的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者模式又特别关注比较复杂的对象&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单工厂模式、工厂方法模式、抽象工厂模式都是工厂模式的形态之一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工厂方法模式是简单工厂模式的规范化与标准化扩展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;如果只有一个具体工厂类，工厂方法模式自然可以改造成简单工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂模式是工厂模式中最为抽象和最具一般性的一种形态&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂经常通过工厂方法来实现&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（也可以借助于原型模式来实现，抽象工厂可以存储一个被拷贝的原型对象的集合，然后返回产品的对象）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简单工厂模式和工厂方法模式都是针对一个产品等级结构，而抽象工厂则可以生产多个等级结构的产品&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;建造者模式与抽象工厂模式都可以用来创建同时属于几个产品族的对象，也就是他们都可以创建复杂的对象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;但是建造者模式进一步的对组装过程进行了分离&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象工厂模式中，每一次的工厂对象调用都会创建一个完整的产品对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端来决定到底如何处理这些产品，可以组装为更大的产品，也可能不会 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者模式则关注借助于产品族的各个产品，一点点的构造出一个更为复杂的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，产品的组装过程发生在建造者内部封装起来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者模式重点在于组装，复杂对象构建逻辑的分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是复杂对象的的每一个组成部分往往又都是工厂模式创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建者模式与工厂模式经常结合使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;建造者模式在最后一步返回一个完整的产品（一般都是复杂的）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂模式则是立即返回每一个产品，具体的产品如何处理随便你&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说，&lt;span&gt;&lt;strong&gt;建造者模式是抽象工厂模式在某种场景下的一种延伸拓展&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;单例模式保证只有一个对象，它提供了一个静态方法用于获取这个唯一的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说，&lt;span&gt;&lt;strong&gt;单例模式使用了简单工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过提供工厂方法的这个类就是他自身，而且静态方法返回的对象也是他自身，是自己的工厂&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;单例模式与其他创建型模式并不冲突也不矛盾&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他模式中的对象，也可以是单例的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;创建型模式之间是相互发展，相互借鉴的，结合具体的情况，适用于不同的场合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;工厂方法模式，抽象工厂模式是最基础的创建，以代替new 达到对象的创建与使用的隔离&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;建造者模式把产品组装为复杂的产品&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原型模式是要求通过“复制”来创建，单例模式要求只能创建一个，是进一步的需求升级&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 22 Nov 2018 04:19:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>创建型设计模式是设计模式的入门基础,主要包括工厂方法模式、抽象工厂模式、建造者模式、原型模式、单例模式,以及简单工厂模式,本文对他们进行了分析对比,总结了创建型模式之间的区别联系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9995954.html</dc:identifier>
</item>
</channel>
</rss>