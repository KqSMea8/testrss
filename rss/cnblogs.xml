<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>PowerDesigner如何将设计的表更新到数据库中 - eshine</title>
<link>http://www.cnblogs.com/eshinex/p/PowerDesigner.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eshinex/p/PowerDesigner.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件开发的过程中，将设计的表更新到数据库中是一件繁琐的事情，使用好工具，能够事半功倍。&lt;/p&gt;
&lt;p&gt;环境介绍：Oracle 11g x64&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前期准备：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.PowerDesigner工具（本人是32位的）&lt;/p&gt;
&lt;p&gt;2.Odbc驱动&lt;/p&gt;
&lt;p&gt;3.创建好表空间，用户，以及赋予权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实际操作步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行如下命令，创建表空间、表、用户、为用户赋值权限：&lt;/p&gt;
&lt;p&gt;CREATE SMALLFILE TABLESPACE &lt;span&gt;TS（你自己的表空间）&lt;/span&gt;DATAFILE 'D:\app\&lt;span&gt;用户（你自己的目录）&lt;/span&gt;\oradata\orcl\&lt;span&gt;DB_NAME（你自己的数据库名称）&lt;/span&gt;' SIZE 100M AUTOEXTEND ON NEXT 100M MAXSIZE UNLIMITED LOGGING EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO ;&lt;/p&gt;
&lt;p&gt;CREATE USER &lt;span&gt;USER_NAME（你自己的用户名）&lt;/span&gt; PROFILE DEFAULT IDENTIFIED BY &lt;span&gt;PWD（你自己的密码）&lt;/span&gt; DEFAULT TABLESPACE  &lt;span&gt;TS（你自己的表空间）&lt;/span&gt; TEMPORARY TABLESPACE TEMP ACCOUNT UNLOCK;&lt;/p&gt;
&lt;p&gt;GRANT DBA TO &lt;span&gt;USER_NAME（你自己的用户名，根据实际需要赋值权限）&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第2步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据当前系统数据库环境，添加ODBC驱动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1下载驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;驱动下载地址：&lt;a title=&quot;Instant Client Downloads for Microsoft Windows 32-bit&quot; href=&quot;http://www.oracle.com/technetwork/topics/winsoft-085727.html&quot; target=&quot;_blank&quot;&gt;http://www.oracle.com/technetwork/topics/winsoft-085727.html&lt;/a&gt;   。&lt;/p&gt;
&lt;p&gt;下载： &lt;a id=&quot;file150&quot; name=&quot;file150&quot; href=&quot;http://www.oracle.com/technetwork/topics/winsoft-085727.html&quot;&gt;instantclient-basic-nt-11.2.0.4.0.zip&lt;/a&gt;   和  &lt;a id=&quot;file155&quot; name=&quot;file155&quot; href=&quot;http://www.oracle.com/technetwork/topics/winsoft-085727.html&quot;&gt;instantclient-odbc-nt-11.2.0.4.0.zip&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;注意：此处因为我的PowerDesigner是32位的，所以选择的驱动都是32位，如果您是64位，也可以选择64位。同时，因为我的数据库是11g，顾选择的版本是11.2.0.4.0，如果您的是12c，请选择高版本，高版本不兼容低版本。&lt;/p&gt;
&lt;p&gt;下载地址为：&lt;a href=&quot;http://www.oracle.com/technetwork/topics/winx64soft-089540.html&quot; target=&quot;_blank&quot;&gt;http://www.oracle.com/technetwork/topics/winx64soft-089540.html&lt;/a&gt;  ，分别下载： &lt;a id=&quot;file150&quot; name=&quot;file150&quot; href=&quot;http://www.oracle.com/technetwork/topics/winx64soft-089540.html&quot;&gt;instantclient-basic-windows.x64-11.2.0.4.0.zip&lt;/a&gt;   和    &lt;a id=&quot;file155&quot; name=&quot;file155&quot; href=&quot;http://www.oracle.com/technetwork/topics/winx64soft-089540.html&quot;&gt;instantclient-odbc-windows.x64-11.2.0.4.0.zip&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2解压驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将驱动解压到同一个目录，如：C:\ODBC_11g_X32&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518063818436-395607446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3通过CMD安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以管理员身份运行CMD命令，输入：cd /d C:\ODBC_11g_X32 回车&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518064117528-832128692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再输入：odbc_install.exe 回车，此时会提示安装成功（因为先前安装过，提示已经存在了）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518064332029-1462113160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第3步：通过PowerDesigner创建相关的表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518064508363-1342726746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518064538025-1232067540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4步：将表导入数据库中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1通过PowerDesigner创建ODBC数据源连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DataBase --&amp;gt; Generate DataBase &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518064959911-795511920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;选择：Direct generation，然后点击右侧的连接数据库源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518065112393-668622810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;打开连接数据库源，选择Congiure（配置，由于我先前都做了一次，所以我这里截图全部存在）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518065501043-1000431044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置数据源：新建（点击红色方框标记处）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518065614975-1940489291.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;选择：文件数据源--&amp;gt;下一步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518065808654-1441118176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到先前安装的odbc驱动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518065912313-2040362652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击浏览，选择数据源存放的位置，并为数据源起名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518070036628-1094832428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如：起名为“我的数据源”，存放到D盘根目录（这里大家随意，只要用的时候记住就好，我一般是和PowerDesigner的数据设计文件存放在一起）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518070238046-1863684531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518070344835-400084931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写服务名称，账号，密码等，注意服务名称是你本地oracle数据库的服务名称，填写格式为：localhost:1521/ORCL&lt;/p&gt;
&lt;p&gt;注意：由于我是本机的oracle，以及端口为默认的1521，同时数据库服务名称名为ORCL，顾如此填写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518070854147-878864032.jpg&quot; alt=&quot;&quot;/&gt;                   &lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518070959055-801532379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击OK，新建好数据源，选择 ODBC FILE Data Sources ，浏览，找到新建好的数据源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518071342092-783586919.png&quot; alt=&quot;&quot;/&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518071425770-607996665.png&quot; alt=&quot;&quot;/&gt;、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518071508491-250279400.png&quot; alt=&quot;&quot;/&gt;         &lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518071624717-2046484749.png&quot; alt=&quot;&quot;/&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518071735702-323331054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2准备更新表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面测试设计的表是否能正常更新到数据库中，如图，我的 T_WX_GZH_CONFIG 目前只有：WX_CONFIG_ID、WX_GZH_ID、WX_CONFIG_NAME、WX_CONFIG_VAL、ADD_DT等几个字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518071932110-1814045052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在PD中添加新字段，添加一列叫做字典序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072225239-33893515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4.3操作更新&lt;/p&gt;
&lt;p&gt;同样是：DataBase --&amp;gt; Generate DataBase （注意，在物理模型中操作，不是概念模型）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072425783-1548633147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;general中选择 表和视图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072521898-657637455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;options选择中也只选择表和视图，如果选择其他的，你的Preview里面的代码会多出修改你表空间，用户等sql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072628719-831243703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Format中，勾选相关操作，名称自动替换空的备注，然后选择简体中文编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072736170-907558469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;selection中选择你所要更新的表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072817559-1720878337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;summary的截图，里面存放你的sql文件位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072856409-581249494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Preview截图，你所要更新表的sql语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518072942092-920672034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518073045781-952995421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518073105753-379360539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再点击是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518073125601-1763431113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击RUN，提示执行成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518073158063-35330582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在数据库中查看表，看看新加的字段是否添加上去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518073249999-999283632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/249616/201805/249616-20180518073311056-924727800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这样，你就完成了表的更新。但是，注意这种方法的缺点，这种更新是需要先删除掉表，再创建，如果你有重要数据，请先备份，不然后悔莫及。&lt;/p&gt;

</description>
<pubDate>Thu, 17 May 2018 23:38:00 +0000</pubDate>
<dc:creator>eshine</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eshinex/p/PowerDesigner.html</dc:identifier>
</item>
<item>
<title>(细节)My SQL中主键为0和主键自排约束的关系 - 汪凡</title>
<link>http://www.cnblogs.com/wf-skylark/p/9054191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wf-skylark/p/9054191.html</guid>
<description>&lt;td valign=&quot;top&quot;&gt;
&lt;table align=&quot;center&quot; width=&quot;100%&quot; height=&quot;1400&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot; border=&quot;0&quot; class=&quot;index&quot; readability=&quot;3.8237395791981&quot;&gt;&lt;tr readability=&quot;7.6474791583962&quot;&gt;&lt;td class=&quot;banner&quot; valign=&quot;top&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;block&quot;&gt;

&lt;div class=&quot;post&quot;&gt;
&lt;div class=&quot;postcontent&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;
&lt;h4&gt;开始不设置主键&lt;/h4&gt;
&lt;h4&gt;表的设计如下：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014047814-1678762037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014054689-1556990964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;如果&lt;/span&gt;id&lt;span&gt;的位置有好几个&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的话：设置主键并且自动排序时，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;会从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始递增；&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014203656-15357768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014219884-779588288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;Insert &lt;span&gt;进去&lt;/span&gt; &lt;span&gt;id = 0&lt;/span&gt;&lt;span&gt;的数据，数据会从实际的行数开始增加，和从&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;变化不一样；&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014355273-1189565813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014402873-246103889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014408436-1534764981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;现在主键是没有&lt;/span&gt;0&lt;span&gt;的，如果把某个&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;改成&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的话，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;不会变！直接会进行排序；&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014506187-1687102527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014510877-1682994137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;再&lt;/span&gt;insert&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;id=0&lt;/span&gt;&lt;span&gt;的看看，居然还是跟刚才一样直接跟行数相关！&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014604036-2135612409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014608334-584835991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;再重置一下自动排序，看看这个&lt;/span&gt;0&lt;span&gt;会不会有变化，&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;先取消自排&lt;/span&gt;;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014651621-158836088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014704154-1090447815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;再加上自排，果然跟想的一样，&lt;/span&gt;0&lt;span&gt;要变成&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;了，错误提示说的是主键有重复的&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;所以不让自排，&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014743027-449452508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;修改之后，果真可以了，&lt;/span&gt;0&lt;span&gt;变成&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;了，&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014820941-1278362570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180518014836046-1767612402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;       我觉得也就这几种情况吧，无符号的情况应该没什么区别，还有什么没有考虑的希望大家给我留言，可以告诉我你是怎么想的，我也很想知道，现在抛砖引玉我把我的总结和想法写一下：&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;　　对我来说，&lt;/span&gt;0&lt;span&gt;在数据库里很特殊。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　使用&lt;/span&gt;limit&lt;span&gt;查看指定范围数据的时候这时候表就会是从&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;开始往下排的顺序，但是&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;添加一行数据的时候反而是跟行数有关系，这时候又是按照从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始往下排的顺序。如果使用主键自排约束以前表里有&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，再设置完主键自排以后所有的&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;又不会根据行数，而是直接按照自上而下的顺序从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始排。如果把表中的某个主键的数改成&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，那直接就会进行排序放到正数前面，也就是说主键自排是允许有&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;存在的，那为什么本身存在的&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;要去修改成从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始的递增序列呢？哪怕没加主键自排以前只有一个&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，加了主键自排以后还是会变成&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　开始有&lt;/span&gt;0&lt;span&gt;，增加主键自排约束，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;依次变为&lt;/span&gt;&lt;span&gt;1,2,3,4.......&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　开始没&lt;/span&gt;0&lt;span&gt;，增加主键自排约束，新添加的主键是&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;的行会根据行数自行变化，注意这里是新添加的行，使用的是&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　开始没&lt;/span&gt;0&lt;span&gt;，把某个主键的数修改成&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，这个&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;会直接在排好序了再在表里显示出来。&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;说得简单一点就是，增加主键自排约束后：&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;　　　主键的值：修改成的&lt;/span&gt;0&lt;span&gt;，可以存在，就是排个序。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　　　　　　　新添加的&lt;/span&gt;0&lt;span&gt;，不允许存在，要根据行号改变。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　　　　　　　本身存在的&lt;/span&gt;0&lt;span&gt;，不允许存在，要从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;开始递增变化。&lt;/span&gt;&lt;/h4&gt;
&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;



&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td width=&quot;200&quot; valign=&quot;top&quot;&gt;
&lt;/td&gt;
</description>
<pubDate>Thu, 17 May 2018 17:56:00 +0000</pubDate>
<dc:creator>汪凡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wf-skylark/p/9054191.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Java集合类详解（一） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/8921974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/8921974.html</guid>
<description>&lt;p&gt;　　今天来看看Java里的一个大家伙，那就是集合。&lt;/p&gt;
&lt;p&gt;　　集合嘛，就跟它的名字那样，是一群人多势众的家伙，如果你学过高数，没错，就跟里面说的集合是一个概念，就是一堆对象的集合体。集合就是用来存放和管理其他类对象的地方，也可以叫做容器，你可以把它理解为仓库管家，当你有东西需要存放和管理的时候，就要记得来找它。你也许会说，不是有数组吗？确实，用数组存放一堆相同类型对象也是一个不错的选择，但是有一个很大的缺陷，那就是数组大小只能是固定的，不能从数组里动态添加和删除一个对象，要扩容的时候，就只能新建一个数组然后把原来的对象全部复制到新的数组里，而且只能存放相同类型的对象，使用起来不够灵活。然而我们的管家就不一样了。&lt;/p&gt;
&lt;p&gt;　　国际惯例，先来看一个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明打算学Java，买了三本书&lt;/span&gt;
        Book bookA = &lt;span&gt;new&lt;/span&gt; Book(&quot;Java核心技术（卷一）&quot;, 88.9&lt;span&gt;);
        Book bookB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book(&quot;Java核心技术（卷二）&quot;, 88.6&lt;span&gt;);
        Book bookC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Book(&quot;Java编程思想&quot;, 99.0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;他想了想，放哪呢？到处放怕之后会找不到，放书架以后书变多了找起来就很麻烦
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;于是他找了个管家&lt;/span&gt;
        Map&amp;lt;String, Book&amp;gt; bookMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(3&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后跟管家说，这三本书先放你这了，要用的时候找你拿&lt;/span&gt;
&lt;span&gt;        bookMap.put(bookA.getName(), bookA);
        bookMap.put(bookB.getName(), bookB);
        bookMap.put(bookC.getName(), bookC);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;勤劳的管家兢兢业业的保存好了三本书
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明回到家，想检查一下管家老不老实
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;“管家，把Java核心技术（卷一）给我拿过来”&lt;/span&gt;
        Book bookD = bookMap.get(&quot;Java核心技术（卷一）&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;他查看了一下这本书的信息并跟原来的信息校验了一番&lt;/span&gt;
&lt;span&gt;        System.out.println(bookD);
        System.out.println(bookA.equals(bookD));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并同样校验了另外两本书&lt;/span&gt;
        Book bookE = bookMap.get(&quot;Java核心技术（卷二）&quot;&lt;span&gt;);
        System.out.println(bookE);
        System.out.println(bookB.equals(bookE));
        Book bookF &lt;/span&gt;= bookMap.get(&quot;Java编程思想&quot;&lt;span&gt;);
        System.out.println(bookF);
        System.out.println(bookC.equals(bookF));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;嗯，看来管家没有玩花样，还是原来的书，晚饭给他加个蛋&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double price;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Book(String name, Double price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Double getPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPrice(Double price) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Book{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, price=&quot; + price +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Book{name='Java核心技术（卷一）', price=88.9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
Book{name&lt;/span&gt;='Java核心技术（卷二）', price=88.6&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
Book{name&lt;/span&gt;='Java编程思想', price=99.0&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相信大家看过小明和管家的故事之后，对集合这个概念应该有初步的了解了。集合一般来说就是在你需要存放一系列对象时，可以给你管理对象的好管家。&lt;/p&gt;
&lt;p&gt;　　当然，集合里并不只有HashMap这一个管家，最开始就说了，集合可是一个庞大的家族。先来看一张图感受一下吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201805/1043143-20180517013803012-232600270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好像有点多？关系有点复杂。没错，除了并发包里的集合类以外的大部分集合类差不多都在这了，这个图，emmmm...看看就好，我们还是看下面这个图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201805/1043143-20180517014103874-576506606.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　别慌，其实最常用的就是这么几个了，Collection和Map是两个大的接口，Collection下有三个子接口，List，Queue，Set，下面是最常用的三个类，ArrayList，LinkedList，HashSet。Map接口下最常用的就要数上面栗子里的HashMap了。正如你看到的那样，集合类里有很多不同的实现类，也就是不同的管家，他们有的不同的能力，各有所长也各有所短，至于他们的具体介绍，将会留到之后的几篇文章里介绍，本篇作为集合的介绍篇就不多做讲解了。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，集合只能存放对象。比如你存一个 int 型数据 1放入集合中，其实它是自动转换成 Integer 类后存入的，Java中每一种基本类型都有对应的引用类型。在集合存放的是多个对象的引用，对象本身还是放在堆内存中。集合可以存放不同类型，不限数量的数据类型。&lt;/p&gt;
&lt;h2&gt;Collection接口&lt;/h2&gt;
&lt;p&gt;　　Collection接口是集合家族里的老大哥，是最基本的集合接口，但是这里的Collection跟集合并不是等价关系，因为你仔细看看上面的图就知道，集合家族里还有另外一个老大哥，那就是Map接口。一个Collection代表一组Object，即Collection的元素（Elements）。Collection接口下有三个子接口，分别是List，Set，Queue，它们各有各的特点，下面会一一介绍，但是都继承于Collection接口，所以继承了Collection的所有特性。 　　&lt;/p&gt;
&lt;p&gt;　　我们可以来看看Collection接口都有哪些方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Collection&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; Iterable&amp;lt;E&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询操作&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回集合中元素个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 集合是否为空
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否包含某个元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取迭代器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    Iterator&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; iterator();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转到数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Object[] toArray();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转到指定数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;T&amp;gt;&lt;span&gt; T[] toArray(T[] a);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改操作&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o);


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批量操作&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否全部包含
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; containsAll(Collection&amp;lt;?&amp;gt;&lt;span&gt; c);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 全部添加
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; addAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 全部移除
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; removeAll(Collection&amp;lt;?&amp;gt;&lt;span&gt; c);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 条件移除
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;default&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; removeIf(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; filter) {
        Objects.requireNonNull(filter);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; removed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;E&amp;gt; each =&lt;span&gt; iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (each.hasNext()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (filter.test(each.next())) {
                each.remove();
                removed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removed;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保留全部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; retainAll(Collection&amp;lt;?&amp;gt;&lt;span&gt; c);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清空
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear();


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较和哈希&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较是否相等
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取哈希值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode();


    @Override
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; spliterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;, 0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;流操作&lt;/span&gt;

    &lt;span&gt;default&lt;/span&gt; Stream&amp;lt;E&amp;gt;&lt;span&gt; stream() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; StreamSupport.stream(spliterator(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Stream&amp;lt;E&amp;gt;&lt;span&gt; parallelStream() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; StreamSupport.stream(spliterator(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，Collection的操作还是蛮多的，集合的增删该查和批量操作都有，至于迭代器是什么东西，后面的篇章会有详细介绍。最后两个方法涉及到了流操作，这是Java8里新添加的特性，关于流操作的知识，这里暂时不多说，以后在做讲解。&lt;/p&gt;
&lt;p&gt;　　通过本篇，你只需要了解一下集合是什么，为什么要有集合，集合家族的全貌，了解一下Collection接口中有哪些方法就足够了，之后的文章会从以下几方面来介绍集合：&lt;/p&gt;
&lt;p&gt;　　1.Map接口&lt;/p&gt;
&lt;p&gt;　　2.Iterable接口&lt;/p&gt;
&lt;p&gt;　　3.List，Set，Queue接口&lt;/p&gt;
&lt;p&gt;　　4.ArrayList使用方式和应用场景+源码剖析&lt;/p&gt;
&lt;p&gt;　　5.HashSet使用方式和应用场景+源码剖析&lt;/p&gt;
&lt;p&gt;　　6.LinkedList使用方式和应用场景+源码剖析&lt;/p&gt;
&lt;p&gt;　　7.HashMap使用方式和应用场景+源码剖析&lt;/p&gt;
&lt;p&gt;　　今天的讲解就到此为止了，仅仅介绍了集合的基本概念，作为集合学习的开胃菜，后面一系列的文章都会围绕集合展开，希望大家继续关注！&lt;/p&gt;
</description>
<pubDate>Thu, 17 May 2018 17:02:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/8921974.html</dc:identifier>
</item>
<item>
<title>你必须知道的EntityFramework 6.x和EntityFramework Core变更追踪状态 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/9043744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/9043744.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;只要有时间就会时不时去看最新EF Core的进展情况，同时也会去看下基础，把握好基础至关重要，本节我们对比看看如标题EF 6.x和EF Core的不同，希望对正在学习EF Core的同行能有所帮助，同时也希望通过本文能对您心中可能产生的疑惑进行解答，本文略长，请耐心阅读。&lt;/p&gt;
&lt;h2&gt;深入探讨EF 6.x和EF Core变更追踪状态话题&lt;/h2&gt;
&lt;p&gt;请注意虽然EF 6.x和EF Core在使用方式上没有什么不同，但是内置实现却有所不同，了解它们的不同很重要，同时也希望更多同行选择EF Core，EF 6.x令人诟病毋庸置疑，在使用上不了解基本知识就会出很大的问题，这一点我已经明确阐述过，EF Core为我们做了许多，只是我们并未知道而已，看完本文相信您会认同我说的这句话，为了便于大家理解我们用实例来说明。&lt;/p&gt;
&lt;h3&gt;EntityState状态设置和使用对应方法是否匹配？&lt;/h3&gt;
&lt;p&gt;无论是在EntityFramework 6.x还是EntityFramework Core中DbSet上始终包含有Add、Attath、Remove等方法，当我们调用Add方法来添加对象时，此时内部则是将对象状态置为添加状态（Add），如果我们调用Remove方法删除对象，内部则是将对象置为删除状态（Deleted），在EF 6.x中没有Update方法，若是更新所有列则是只需将对象状态修改为Modified，无论怎样都是通过EntityState来根据我们的操作来设置对象相应的状态，下面我们一起来看下例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt; Customer() { Id = &lt;span&gt;1&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

                ctx.Entry(customer).State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;

                ctx.Customers.Add(customer);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; ctx.Entry(customer).State;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上示例是在EF 6.x中，我们首先实例化一个customer，然后将其状态修改为Modified，最后我们调用Add方法添加到上下文中，此时我们得到customer的状态会是怎样的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517214705852-1424556711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没毛病，对不对，最终调用Add方法其状态将覆盖我们手动通过Entry设置的Modified状态，接下来我们将如上通过Entry方法修改为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  ctx.Entry(customer).State = EntityState.Unchanged;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们这样做了，结果当然也是好使的，那要是我们继续修改为如下形式呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt; Customer() { Id = &lt;span&gt;1&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

                ctx.Entry(customer).State &lt;/span&gt;=&lt;span&gt; EntityState.Deleted;

                ctx.Customers.Add(customer);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; ctx.Entry(customer).State;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果还是Added状态，依然好使，我们继续进行如下修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt; Customer() { Id = &lt;span&gt;1&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

                ctx.Entry(customer).State &lt;/span&gt;=&lt;span&gt; EntityState.Added;

                ctx.Customers.Attach(customer);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; ctx.Entry(customer).State;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517215219516-922566032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恩，还是没问题，这里我们可以得出我们通过Entry方法手动设置未被跟踪对象的状态后，最后状态会被最终调用的方法所覆盖，一切都是明朗，还没完全结束。那接下来我们添加导航属性看看呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt; Customer() { Id = &lt;span&gt;1&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order = &lt;span&gt;new&lt;/span&gt; Order() { Id = &lt;span&gt;1&lt;/span&gt;, CustomerId = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
                customer.Orders.Add(order);

                ctx.Entry(order).State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;

                ctx.Customers.Attach(customer);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; ctx.Entry(order).State;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反观上述代码，我们实例化customer和order对象，并将order添加到customer导航属性中，接下来我们将order状态修改为Modified，最后调用Attath方法附加customer，根据我们上述对单个对象的结论，此时order状态理论上应该是Unchanged，但是真的是这样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517215839087-925285937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和我们所期望的截然相反，此时通过调用attach方法并未将我们手动通过Entry方法设置状态为Modified覆盖，换言之此时造成了对象状态不一致问题，这是EF 6.x的问题，接下来我们再来看一种情况，你会发现此时会抛出异常，抛出的异常我也看不懂，也不知道它想表达啥意思（在EF Core中不会出现这样的情况，我就不占用一一篇幅说明，您可自行实践）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt; Customer() { Id = &lt;span&gt;1&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order = &lt;span&gt;new&lt;/span&gt; Order() { Id = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };
                customer.Orders.Add(order);

                ctx.Entry(order).State &lt;/span&gt;=&lt;span&gt; EntityState.Deleted;

                ctx.Customers.Attach(customer);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state =&lt;span&gt; ctx.Entry(order).State;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517220144643-373295641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上我们得出什么结论呢？在EF 6.x中使用Entry设置对象状态和调用方法对相关的对象影响将出现不一致的情况，接下来我们来对比EF 6.x和EF Core在使用上的区别，对此我们会有深刻的理解，如果我们还沿袭EF 6.x那一套，你会发现居然不好使，首先我们来看EF 6.x例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer()
                {&lt;/span&gt;&lt;span&gt;
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Orders &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Order&amp;gt;&lt;span&gt;()
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order()
                        {
                            Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                            ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                            Price &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                            Quantity &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
                        }
                    }
                };
                &lt;span&gt;ctx.Customers.Add(customer);
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要说明的是我将customer和order是配置了一对多的关系，从如上例子也可看出，我们调用SaveChanges方法毫无疑问会将customer和order插入到数据库表中，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517221603579-1707157038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们手动通过Entry方法设置customer状态为Added，再来看看，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer()
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Orders &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Order&amp;gt;&lt;span&gt;()
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order()
                        {
                            Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                            ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                            Price &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                            Quantity &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
                        }
                    }
                };
                &lt;span&gt;ctx.Entry(customer).State &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= EntityState.Added;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517221846458-1020458068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对照如上我们再来看看在EF Core中是如何处理的呢？直接调用Add方法就不浪费时间演示了，用过EF Core的都知道必然好使，我们看看手动设置状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; GetBlog();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; post = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Post()
                {
                    CommentCount &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
                    CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                };
                context.Entry(blog).State &lt;/span&gt;=&lt;span&gt; EntityState.Added;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }
            Console.ReadKey();
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Blog GetBlog()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog()
            {
                IsDeleted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Status &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.blogs/com/createmyself&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517222451901-1202057445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过实践证明此时不会将Post添加到表中，为什么会如此呢？因为我们只是手动设置了blog的状态为Added，而未对Post进行设置，看到这里想必您知道了EF 6.x和EF Core的不同。&lt;span&gt;EF团队之所以这么做的目的在于如EF 6.x一样手动设置根对象的状态其导航属性即相应关联的对象也会设置，这样做会造成混乱，当我们添加对象时其导航属性也会对应添加，虽然看起来很自然，也适应一些情况，但是对象模型并不清楚主体和依赖关系，所以在EF Core中则发生了改变，通过Entry方法只会对传入对象的状态有所影响而对关联的对象不会发生任何改变，这点尤其重要，我们在使用EF Core时要格外注意，额外多说一句在EF Core通过Entry().State这个APi设置状态只会对单个对象产生影响不会对关联对象产生任何影响即忽略关联对象。 &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;EntityFramework Core为什么在上下文中添加对应方法？&lt;/h3&gt;
&lt;p&gt;不知道使用过EF Core的您有没有发现，在EF 6.x中我们发现在上下文中并没有如暴露的DbSet上的方法比如Add、AddRange、Remove、RemoveRange等等，但是在EF Core则存在对应的方法，不知道您发现过没有，我虽然发现，但是一直不明白为何如此这样做，这样做的目的在哪里呢？我还特意看了EF Core实现源码，结果发现其内部好像还是调用了暴露在DbSet上的方法，如果我没记错的话，这样不是多此一举，吃饱了撑着了吗，有这个时间实现这样一个玩意，那怎么不早早实现通过Incude进行过滤数据呢？EF Core团队在github上讨论当前这不是优先级比较高的特性，其实不然，很多时候我们需要通过导航属性来筛选数据，少了这一步，我们只能加载到内存中再进行过滤。好了回到话题，我也是偶然看到一篇文章，才发现这样设计的目的何在，接下来我们首先来看看在EF 6.x中的上下文中没有对应的方法结果造成的影响是怎样的呢？通过实例我们一看便知。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order =&lt;span&gt; ctx.Orders.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newOrder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order()
                {
                    CustomerId &lt;/span&gt;=&lt;span&gt; order.CustomerId,
                    CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addOrder&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Price &lt;/span&gt;= &lt;span&gt;200&lt;/span&gt;&lt;span&gt;,
                    Quantity &lt;/span&gt;= &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
                };
                ctx.Orders.Add(order);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517224316752-1302206929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;特意给出如上表中数据来进行对比，如上代码我们查询出第一个Order即上图标注，然后我们重新实例化一个Order进行添加，此时您能想象到会发生什么吗？瞧瞧吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517224521814-295180015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果是添加到表中了，但是但是但是，重要的事情说三遍，仔细看看数据和我们要添加的Order数据对照看看，万万没想到，此时得到的数据是主键等于1的数据也就是旧数据。让我们再次回到EF Core中演示上述例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; post =&lt;span&gt; context.Posts.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newPost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Post()
                {
                    CreatedTime &lt;/span&gt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    ModifiedTime &lt;/span&gt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;《你必须掌握的Entity Framework 6.x与Core 2.0》书籍出版&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    CommentCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                    BlogId &lt;/span&gt;=&lt;span&gt; post.BlogId 
                };
                &lt;span&gt;context.Add(newPost);
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517230347544-1585250420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码重新实例化一个Blog并添加到表中数据和如上图中数据完全不一样，我们通过上下文中暴露的Add方法来添加Blog，我们来看看最终在表中的数据是怎样的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517230433777-650799277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在EF Core上下文中有了Add，Attach、Remove方法以及Update和四个相关的Range方法（AddRange等等）和暴露在DbSet上的方法一样。 同时在上下文中的方法更加聪明了。 它们现在可以确定类型并自动将实体对象关联到我们想要的的DbSet。不能说很方便，而是非常方便，因为它允许我们编写通用代码而完全不需要再实例化DbSet，当然我们也可以这样做，只不过现在又多了一条康庄大道罢了，代码简易且易于发现。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;即使是如下动态对象，EF Core也能正确关联到对应的对象，您亲自实践便知。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; newBlog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog()
                {
                    IsDeleted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    CreatedTime &lt;/span&gt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    ModifiedTime &lt;/span&gt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;《你必须掌握的Entity Framework 6.x与Core 2.0》书籍出版&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Status &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                    Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/CreateMyself/p/8655069.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                };
                context.Add(newBlog);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们再来看看一种情况来对比EF 6.x和EF Core在使用方式上的不同，首先我们来看看EF 6.x例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EfDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; customer = ctx.Customers.Include(d =&amp;gt;&lt;span&gt; d.Orders).FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newOrder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order()
                {
                    CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    Code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addOrder&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Price &lt;/span&gt;= &lt;span&gt;200&lt;/span&gt;&lt;span&gt;,
                    Quantity &lt;/span&gt;= &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;,
                    CustomerId &lt;/span&gt;=&lt;span&gt; customer.Id
                };
                ctx.Orders.Attach(newOrder);  
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; ctx.SaveChanges();
            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517235636917-974112738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们能够看到我们只是通过Attatch方法附加了newOrder，然后进行通过SaveChanges进行提交，此时并未提交到数据库表中，那EF Core处理机制是不是也一样呢？我们来看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; context.Blogs.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newPost = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Post()
                {
                    CreatedTime &lt;/span&gt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    ModifiedTime &lt;/span&gt;= Convert.ToDateTime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;《你必须掌握的Entity Framework 6.x与Core 2.0》书籍出版&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    CommentCount &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                    BlogId &lt;/span&gt;=&lt;span&gt; blog.Id
                };
                context.Attach(newPost);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180517235844813-346224140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很惊讶是不是，在EF Core最终添加到数据库表中了，依照我们对EF 6.x的理解，通过Attach方法只是将实体对象状态修改为Unchanged，如果我们想添加对象那么必须调用Add方法，此时对象状态将变为Added状态，也就是说在EF 6.x中如果我们调用Attatch方法，但是需要将对象添加到数据库表中，此时必须要调用Add方法，反之如果我们调用Add方法，那么调用Attath方法附加对象则多此一举，但是在EF Core中这种情况通过上述演示很显然发生了改变。那么EF Core内部是根据什么来判断的呢？我们来看如下源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180518000331606-2063392489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上述源代码不难看出在EF Core对于未设置主键都将视为添加换句话说则是如果调用Attach方法附加一个未被跟踪的对象时且主键值未被填充时，EF Core将其视为添加，所以如果我们需要添加对象时此时可直接调用Attach而无需调用Add方法。&lt;/span&gt;如果您依然不信，您可自行进行如下测试，也同样会被添加到表中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; GetBlog();
                context.Attach(blog);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }
            Console.ReadKey();
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; Blog GetBlog()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog()
            {
                IsDeleted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Status &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.blogs/com/createmyself&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;EF Core团队这么做的目的是什么呢？大部分情况下通过调用Attach方法将可抵达图中所有未跟踪实体的状态设置为Unchanged，除非实体对象的主键我们没有设置且正在使用值生成，对于更新/修改同理。很显然 这对许多断开连接的实体的常见情况非常有用。但是，在许多情况下它不起作用，因为在特殊情况下是根实体，即使我们未设置主键也强制它的状态保持不变，这样做显然不合理。如果我们通过未设置主键调用Attach并最终添加它，这被认为是意外行为，我们需要放开对根实体的特殊封装，通过调用Attach方法来改变这种行为，这会使得Attach变得更加适用，它并不是突破性的改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Jeff自问自答模式来了，那么我们是否允许我们多次调用Attach来附加实体对象呢？您觉得是否可行呢？我们来验证下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; GetBlog();
                context.Attach(blog);
                context.Attach(blog);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180518002039776-462869331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;EntityFramework Core为什么添加无连接跟踪图（Disconnected TrackGraph）？&lt;/h3&gt;
&lt;p&gt;追踪图是EF中全新的概念，它提供了我们对对象状态的完全控制，TrackGraph遍历图（即遍历图中的每个对象）并将指定的函数应用于每个对象。 该函数是TrackGraph方法的第二个参数。此特性的出现也是为了调用对应方法和手动设置状态而造成的混乱而给。比如我们想实现如EF 6.x一样，当调用Attach方法时不添加实体，那么我们可以如下这样做。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; GetBlog();
                context.ChangeTracker.TrackGraph(blog, node &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;node.Entry.IsKeySet)
                    {
                        node.Entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    }
                });
                context.Attach(blog);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201805/589642-20180518005638448-279327501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文我们详细讲解了EF 6.x和EF Core在实体状态上使用方式的不同且讲解了我们需要注意到二者的不同，接下来我们会继续回顾基础，感谢您的阅读，我们下节再会。&lt;/p&gt;
</description>
<pubDate>Thu, 17 May 2018 16:59:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/9043744.html</dc:identifier>
</item>
<item>
<title>linux ubuntukylin和deepin操作系统的比较及改进方向的建议 - 远航。</title>
<link>http://www.cnblogs.com/yuanhang110/p/9054104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanhang110/p/9054104.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;研发中国的操作系统的需求在我看来是安全，还有就是自主。如果做的好还可以在创新上，使用体验上进行一波超越。现有的所谓的国产操作系统我了解的除了基于安卓的凤凰系统就是基于Linux的像优麒麟和deepin这样的系统。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一.ubuntu kylin优麒麟系统：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;优点：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.基于ubuntu18.04lts，软件源比较多，论坛比较活跃，使用时问题的解答比较多。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.带搜狗输入法，wps&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;缺点：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.界面感觉介于win xp和win 7界面效果之间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.wps需要配置字体&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.和deepin共有问题，双系统时win10时间晚8小时。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4.新安个应用会重叠应用图标&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5.主菜单界面和终端界面字体太小不能在设置中调大&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;6.安装应用麻烦，像qq我按官方教程安了几遍都失败了，steam也是一样，在解决显卡驱动的安装后steam倒是安成功了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;7. 想到时补充&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;二.deepin深度系统&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;优点：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.安装过程简单一点，分区时有简单模式和高级模式&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.界面好看。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.有50多款打包wine的windows应用，qq等，还有安卓模拟器，应用数量还是比较多的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4.深度终端设置比较丰富，图标类型大小设置丰富&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;缺点：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.对硬盘的读写速度的利用不高，像win10，用固态后打开系统的文件还有设置都响应迅速&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.对大内存的利用效率不高，像windows，内存大小在一定范围内，你内存越大，系统初始内存占用就越高，内存大后运行速度也会有所改善。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.前两点总结后就是感觉不够流畅丝滑，不如win10&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4.像我qq最小化的时候有时托盘里就没了，也不能重新打开，在任务管理器里qq仍在占用资源。我注销重新登陆再打开就可以用了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;建议：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.针对主要人群适配或开发专业应用，满足专用用途&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.完善日常应用，像linux没有的，就用wine兼容优化，不求多，我觉得日常应用有一两百款优化良好的就可以了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.汲取其他发行版优点，我觉得应有专人进行测试比较的工作。来提升自己&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4.稳定性和速度很重要&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;5.定制性也很重要，deepin的安装过程安装内容应可选，有最小安装和普通安装模式等。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;6.加强社区建设，可以让活跃度高的用户志愿担任版主，像贴吧一样。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;7.加强线下活动，可以进行linux开源应用比赛和高校巡讲，像kylin一样&lt;/p&gt;
</description>
<pubDate>Thu, 17 May 2018 16:31:00 +0000</pubDate>
<dc:creator>远航。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanhang110/p/9054104.html</dc:identifier>
</item>
<item>
<title>[ 搭建Redis本地服务器实践系列三 ] ：图解Redis客户端工具连接Redis服务器 - 野原新之助，嘿</title>
<link>http://www.cnblogs.com/tczeus/p/9054092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tczeus/p/9054092.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一章 &lt;a href=&quot;http://www.cnblogs.com/tczeus/p/9048890.html&quot;&gt;&lt;span&gt;[ 搭建Redis本地服务器实践系列二 ] ：图解CentOS7配置Redis&lt;/span&gt;&lt;/a&gt;  介绍了Redis的初始化脚本文件及启动配置文件，并图解如何以服务的形式来启动、终止Redis服务，可以说我们的Redis本地服务器已基本搭建完成，那可能就有小伙伴要问了，什么叫基本搭建完成，原因是此时的Redis服务虽然已经可以正常启\停，但是客户端还无法远程连接到Redis并执行响应的操作。若要实现远程客户端正常连接，我们仍需要对Redis启动配置文件进行一些设置，这个章节我们重点来讲解下如何对Redis启动配置文件进行设置才能实现客户端远程连接。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开始之前我们准备好一样东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis客户端软件：&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://redisdesktop.com/download&quot;&gt;&lt;span&gt;Redis Desktop Manager&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说起Redis启动配置文件，不知道小伙伴们是否还有印象，记不清楚的可以重新温习下上一章的内容，我们从Redis服务初始化脚本（文件目录地址：~/etc/init.d/redis.conf）中来查看Redis启动配置文件的存放地址，具体配置项如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#设置redis服务的监听端口
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; REDISPORT=&lt;span&gt;6379&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#设置redis服务启动所需的配置文件路径
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; CONF=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/redis/${REDISPORT}.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过上面的配置我们，可以看出Redis启动配置文件目录地址：/etc/redis/6379.conf，我们对其做如下配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：释放并设置Redis服务监听接口，这里我们使用默认端口6379&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; port &lt;span&gt;6379&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180517232147186-51774878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：释放并设置Redis服务绑定IP地址，这里我们使用当前网卡IP：192.168.1.117&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; bind &lt;span&gt;192&lt;/span&gt;.&lt;span&gt;168&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;117&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180517232339660-567170795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：释放并设置服务授权密码（主要出于安全考虑），为了方便演示，我们这里就设置的简单一点，实际生产过程中可根据实际情况设置的复杂一点&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; requirepass &lt;span&gt;123456789&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180517232705996-641585949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过了上面的三项基本设置，我们对Redis启动配置文件6379.conf的设置也就可以告一段落，为什么呢？因为要实现客户端的远程连接足够了，这个时候有的小伙伴就要问了，你阿是不是可以使用客户单开始连接Redis了？别着急，我们还需要根据6379.conf文件的配置内容对Redis服务初始化脚本进行相应修改。修改后的服务初始化脚本如下（有兴趣的小伙伴可以参考&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/tczeus/p/9048890.html&quot;&gt;&lt;span&gt;上一章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中的配置文件看看有什么不同）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/bin/sh&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; chkconfig:   2345 90 10&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Simple Redis init.d script conceived to work on Linux systems&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; as it does use of the /proc filesystem.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务的监听端口&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; REDISPORT=6379
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务的监听IP&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; REDISIP=192.168.1.117
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务的授权密码&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; REDISPWD=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis-server的默认执行路径（redis的安装目录）&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; EXEC=/usr/local/redis/4.0.9/bin/redis-&lt;span&gt;server
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis-cli的默认执行路径（redis的安装目录）&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; CLIEXEC=/usr/local/redis/4.0.9/bin/redis-&lt;span&gt;cli
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务运行进程文件路径&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; PIDFILE=/var/run/redis_&lt;span&gt;${REDISPORT}&lt;/span&gt;&lt;span&gt;.pid
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置redis服务启动所需的配置文件路径&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; CONF=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/redis/${REDISPORT}.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt;  
&lt;span&gt;23&lt;/span&gt; case &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    start)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;$PIDFILE&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        then
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PIDFILE exists, process is already running or crashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting Redis server...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;$EXEC&lt;/span&gt; &lt;span&gt;$CONF&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        fi
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        ;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    stop)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ ! &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;$PIDFILE&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        then
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PIDFILE does not exist, process is not running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                 PID=$(cat &lt;span&gt;$PIDFILE&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stopping ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;$CLIEXEC&lt;/span&gt; -a &lt;span&gt;$REDISPWD&lt;/span&gt; -h &lt;span&gt;$REDISIP&lt;/span&gt; -p &lt;span&gt;$REDISPORT&lt;/span&gt;&lt;span&gt; shutdown
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; [ -x /proc/&lt;span&gt;${PID}&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                     echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Waiting for Redis to shutdown ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                     sleep 1
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                done
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis stopped&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        fi
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        ;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     *&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please use start or stop as first argument&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        ;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; esac
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;备注：Redis启动配置文件是Redis运行的核心配置文件，其包含了Redis的各种指标配置，Redis服务初始化脚本中的配置项内容必须与启动配置文件的保持一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此为止，我们对Redis服务器的配置已经完成，接下来我们启动Redis服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; service redis start&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180518000822783-149688436.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 然后，开放监听端口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#查看指定端口是否开放
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; firewall-cmd --query-port=&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;/tcp
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#开放指定端口
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; firewall-cmd --&lt;span&gt;add&lt;/span&gt;-port=&lt;span&gt;6379&lt;/span&gt;/tcp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;方法如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，查看端口6379是否开放，执行结果为no，未开放&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，开放端口6379，执行结果为success，开放成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，查看端口6379是否开放，执行结果为yes，已开放&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180518000053769-1579010703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;打开Redis客户端&lt;span&gt;&lt;a href=&quot;https://redisdesktop.com/download&quot;&gt;&lt;span&gt;Redis Desktop Manager&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，创建一个新的Redis服务器连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180518001402012-2012878186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接创建成功后，我们就可以通过客户端对Redis进行操作了，对于不会使用客户端操作的小伙伴可以找下度娘补补课哦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/598316/201805/598316-20180518001852448-1267488118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 好了，就写到这里吧，希望能对需要的小伙伴有所帮助&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 17 May 2018 16:22:00 +0000</pubDate>
<dc:creator>野原新之助，嘿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tczeus/p/9054092.html</dc:identifier>
</item>
<item>
<title>Xor Sum 01字典树 hdu4825 - 弃疗大表哥</title>
<link>http://www.cnblogs.com/qldabiaoge/p/9054066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qldabiaoge/p/9054066.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 132768/132768 K (Java/Others)&lt;br/&gt;Total Submission(s): 4119    Accepted Submission(s): 1796&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Problem Description&lt;/p&gt;
&lt;p&gt;Zeus 和 Prometheus 做了一个游戏，Prometheus 给 Zeus 一个集合，集合中包含了N个正整数，随后 Prometheus 将向 Zeus 发起M次询问，每次询问中包含一个正整数 S ，之后 Zeus 需要在集合当中找出一个正整数 K ，使得 K 与 S 的异或结果最大。Prometheus 为了让 Zeus 看到人类的伟大，随即同意 Zeus 可以向人类求助。你能证明人类的智慧么？&lt;/p&gt;


&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入包含若干组测试数据，每组测试数据包含若干行。&lt;br/&gt;输入的第一行是一个整数T（T &amp;lt; 10），表示共有T组数据。&lt;br/&gt;每组数据的第一行输入两个正整数N，M（&amp;lt;1=N,M&amp;lt;=100000），接下来一行，包含N个正整数，代表 Zeus 的获得的集合，之后M行，每行一个正整数S，代表 Prometheus 询问的正整数。所有正整数均不超过2^32。&lt;/p&gt;


&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;对于每组数据，首先需要输出单独一行”Case #?:”，其中问号处应填入当前的数据组数，组数从1开始计算。&lt;br/&gt;对于每个询问，输出一个正整数K，使得K与S异或值最大。&lt;/p&gt;


&lt;p&gt;Sample Input&lt;/p&gt;
&lt;div class=&quot;panel_content&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3 2&lt;/p&gt;
&lt;p&gt;3 4 5&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;4 1&lt;/p&gt;
&lt;p&gt;4 6 5 6&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Sample Output&lt;/p&gt;
&lt;div class=&quot;panel_content&quot;&gt;
&lt;p&gt;Case #1: 4 3&lt;/p&gt;
&lt;p&gt;Case #2: 4&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;panel_bottom&quot; readability=&quot;17&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;vector&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include&amp;lt;queue&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; inf 0x3fffffff
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Memset(x, a) memset(x, a, sizeof(x))
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; typedef &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; LL;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;100000&lt;/span&gt; + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tree[&lt;span&gt;32&lt;/span&gt; * maxn][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; LL val[&lt;span&gt;32&lt;/span&gt; *&lt;span&gt; maxn];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sz;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     memset(tree[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(tree[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   Memset(tree[0],0);&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     sz = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(LL a) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; u = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;32&lt;/span&gt; ; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; ; i--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; b = ((a &amp;gt;&amp;gt; i) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) ;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tree[u][b]) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;            memset(tree[sz], &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tree[sz]));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Memset(tree[sz],0);&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             val[sz] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             tree[u][b] = sz++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         u =&lt;span&gt; tree[u][b];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     val[u] =&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;LL query(LL a ) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; u = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;32&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt; ; i--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; b = ((a &amp;gt;&amp;gt; i) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) ;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (tree[u][b ^ &lt;span&gt;1&lt;/span&gt;]) u = tree[u][b ^ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; u =&lt;span&gt; tree[u][b];
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; val[u];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; t, n, m, cas = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    LL a;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;t);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(t--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        init();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;&lt;span&gt;m);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            add(a);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Case #%d:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, cas++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; m ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, query(a));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Thu, 17 May 2018 16:01:00 +0000</pubDate>
<dc:creator>弃疗大表哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qldabiaoge/p/9054066.html</dc:identifier>
</item>
<item>
<title>Spring MVC温故而知新 – 从零开始 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9054036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9054036.html</guid>
<description>&lt;h3&gt;  Spring MVC简介&lt;/h3&gt;
&lt;p&gt;Spring MVC是一款基于MVC架构模式的轻量级Web框架，目的是将Web开发模块化，对整体架构进行解耦。&lt;/p&gt;
&lt;p&gt;Spring MVC有一下优点：&lt;/p&gt;
&lt;p&gt;作为Spring框架的一部分，拥有Spring的优点（IOC,AOP等）&lt;/p&gt;
&lt;p&gt;支持灵活的URL到页面控制器的映射&lt;/p&gt;
&lt;p&gt;提供灵活的数据验证、格式化、数据绑定机制&lt;/p&gt;
&lt;p&gt;支持RESTful风格&lt;/p&gt;
&lt;h3&gt;  Spring MVC请求流程&lt;/h3&gt;
&lt;p&gt;Spring MVC框架的整体请求流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180518000218660-450095568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图中涉及到Spring MVC的几个功能组件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端控制器(DispatcherServlet)&lt;/strong&gt;：接收用户请求并返回请求结果。它的作用相当于一个转发器或中央处理器，控制整个执行流程，对各逐渐进行调度降低组件之间的耦合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器映射器(HandlerMapping)&lt;/strong&gt;：根据用户请求的URL，通过注解或者XML配置，查找相应的处理器Handler&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器适配(HandlerAdapter)&lt;/strong&gt;：根据映射器查找出的Handler，完成调用处理器中的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器(Handler)&lt;/strong&gt;：请求处理的具体逻辑，返回数据和视图信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图解析器(View Resolver)&lt;/strong&gt;：解析具体视图，通过ModelAndView对象中的View信息，将逻辑视图名解析成真正的视图View&lt;/p&gt;
&lt;p&gt; 请求流程具体步骤详解：&lt;/p&gt;
&lt;p&gt;1：用户发起请求，请求会被前端控制器(DispatcherServlet)拦截&lt;/p&gt;
&lt;p&gt;2：前端控制器(DispatcherServlet)请求处理器映射器(HandlerMapping)查找Handler&lt;/p&gt;
&lt;p&gt;3：处理器映射器(HandlerMapping)根据配置找到相应Handler（可以更具注解或者XML配置），可能包含多个Interceptor拦截器，返回给前端控制器&lt;/p&gt;
&lt;p&gt;4：前端控制器(DispatcherServlet)请求处理器适配器(HandlerAdapter)去执行相应的Handler&lt;/p&gt;
&lt;p&gt;5：适配器交由对应Handler处理器执行&lt;/p&gt;
&lt;p&gt;6:  Handler处理器执行完成后返回ModelAndView对象给处理器适配器&lt;/p&gt;
&lt;p&gt;7：处理器适配器接受Handler处理器的返回结果，并将该结果返回给前端控制器(DispatcherServlet)&lt;/p&gt;
&lt;p&gt;8：前端控制器(DispatcherServlet)接收处理器适配器返回的数据和视图信息，请求视图解析器，解析对应的视图&lt;/p&gt;
&lt;p&gt;9：视图解析器根据View信息匹配的相应的视图结果，反回给前端控制器&lt;/p&gt;
&lt;p&gt;10:前端控制器接收具体视图，进行视图渲染，将Model数据填充到View视图中，生成最终视图&lt;/p&gt;
&lt;p&gt;11：前端控制器向用户返回结果&lt;/p&gt;
&lt;h3&gt;  从零开始搭建demo&lt;/h3&gt;
&lt;h4&gt;  创建工程:&lt;/h4&gt;
&lt;p&gt;Eclipse下新建一个动态Web项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517234848194-267825716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工程默认目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517234859671-1326525459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;  添加jar包依赖&lt;/h4&gt;
&lt;p&gt;WebContent &amp;gt; WEB-INF &amp;gt; lib 文件夹下导入相应的jar包，其中核心的jar包是spring-webmvc-5.0.0.RELEASE.jar，其他是几个主要是spring用于管理上下文和beande 包、jstl标签库和一个用于打印日志的log包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517234939619-1967526227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;  在web.xml中配置前端控制器&lt;/h4&gt;
&lt;p&gt; 前端控制器相当于Spring MVC的专有servlet,用于拦截所有符合条件的请求，交由框架做后续处理&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; 
        xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;&lt;span&gt; 
        xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;&lt;/span&gt;&lt;span&gt; 
        id&lt;/span&gt;&lt;span&gt;=&quot;WebApp_ID&quot;&lt;/span&gt;&lt;span&gt; 
        version&lt;/span&gt;&lt;span&gt;=&quot;3.1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置前端控制器-DispatchServlet  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springMvcNext&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+&quot;-servlet.xml&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;classpath:applicationContext.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springMvcNext&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;根据url-pattern设定的规则拦截用户发来的请求 此处拦截所有请求，包括静态资源 -&amp;gt;
  &lt;span&gt;&amp;lt;/&lt;span&gt;servlet-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&amp;lt;servlet-mapping&amp;gt;标签中定义url匹配规则为符合*.action的形式，对应的servlet名为springMvcNext，而&amp;lt;servlet&amp;gt;配置的控制器为org.springframework.web.servlet.DispatchServlet，该控制器为当前SpringMVC项目的前端控制器，&amp;lt;init-param&amp;gt;标签为当前控制器依赖的参数，两个参数分别代表上下文参数和参数加载路径。&lt;/p&gt;
&lt;p&gt;关于classpath:代表web项目编译后编译后的输出路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235200982-952791777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235218782-921649858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;配置spring MVC配置&lt;/h4&gt;
&lt;p&gt;在java源代码更目录下添加applicationContext.xml文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235251846-792865026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 包扫描器  标签将用于激活Spring MVC注释扫描功能，允许使用@Controller和@RequestMapping等注释。&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.sl.controller&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注解驱动 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置视图解析器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;  id&lt;/span&gt;&lt;span&gt;=&quot;internalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/WEB-INF/view/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suffix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.jsp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;  添加控制器Controller与视图View&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235340897-770943482.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;Src目录下添加包com.sl.controller，添加控制器代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloWorldController {
    
    @RequestMapping(&lt;/span&gt;&quot;/index&quot;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理URL路径中以/index开头的所有请求： 包括 /index/* 和 /index.html&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView helloWorld() {

        String message &lt;/span&gt;= &quot;Hello Spring MVC&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ModelAndView(&quot;index&quot;, &quot;message&quot;&lt;span&gt;, message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在WEB-INF/view中添加视图文件index.jsp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Spring MVC &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${message}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235503837-1937594215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 17 May 2018 15:56:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9054036.html</dc:identifier>
</item>
<item>
<title>vi/vim操作 - Young233</title>
<link>http://www.cnblogs.com/young233/p/9054050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/young233/p/9054050.html</guid>
<description>&lt;p&gt;vi/vim是unix/linux操作系统下的文本编辑器。&lt;br/&gt;由于unix/linux万物届文件的特性，vi/vim可以编辑任何格式的文件。&lt;br/&gt;下面是常见的知识点，仅供参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编辑方式：vi/vim + 文件路径。其中，文件路径可以是绝对路径，也可以是相对路径。如果这个文件不存在，就会新建一个文件。&lt;/li&gt;
&lt;li&gt;vi/vim常用的模式有两种：命令行模式和输入模式。&lt;/li&gt;
&lt;li&gt;由命令行模式切换到输入模式的命令：&lt;br/&gt;新增 (append)&lt;br/&gt;a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。&lt;br/&gt;A： 从光标所在列最後面的地方开始新增资料。&lt;br/&gt;插入（insert）&lt;br/&gt;i： 从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。&lt;br/&gt;I ：从光标所在列的第一个非空白字元前面开始插入资料。&lt;br/&gt;开始(open)&lt;br/&gt;o ：在光标所在列下新增一列并进入输入模式。&lt;br/&gt;O: 在光标所在列上方新增一列并进入输入模式。&lt;br/&gt;在指令模式下键入:q,:q!,:wq或:x(注意:号），就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出，如果文件已有新的变化，vi会提示你保存文件而:q命令也会失效，这时你可以用:w命令保存文件后再用:q退出，或用:wq或:x命令退出，如果你不想保存改变后的文件，你就需要用:q!命令，这个命令将不保存文件而直接退出vi。&lt;br/&gt;常用操作(命令行模式下)：&lt;br/&gt;Ctrl+F：下翻一页&lt;br/&gt;Ctrl+B:上翻一页&lt;br/&gt;/+单词：查找&lt;br/&gt;dd：删除一行&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 17 May 2018 15:53:00 +0000</pubDate>
<dc:creator>Young233</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/young233/p/9054050.html</dc:identifier>
</item>
<item>
<title>PCA的数学原理(转) - 能力工场-小马哥</title>
<link>http://www.cnblogs.com/hadoop2015/p/9054046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hadoop2015/p/9054046.html</guid>
<description>&lt;p&gt;PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。网上关于PCA的文章有很多，但是大多数只描述了PCA的分析过程，而没有讲述其中的原理。这篇文章的目的是介绍PCA的基本数学原理，帮助读者了解PCA的工作机制是什么。&lt;/p&gt;
&lt;p&gt;当然我并不打算把文章写成纯数学文章，而是希望用直观和易懂的方式叙述PCA的数学原理，所以整个文章不会引入严格的数学推导。希望读者在看完这篇文章后能更好的明白PCA的工作原理。&lt;/p&gt;
&lt;h2&gt;1. 数据的向量表示及降维问题&lt;/h2&gt;
&lt;p&gt;一般情况下，在数据挖掘和&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//lib.csdn.net/base/2&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;机器学习&lt;/a&gt;中，数据被表示为向量。例如某个淘宝店2012年全年的流量及交易情况可以看成一组记录的集合，其中每一天的数据是一条记录，格式如下：&lt;/p&gt;
&lt;p&gt;(日期, 浏览量, 访客数, 下单数, 成交数, 成交金额)&lt;/p&gt;
&lt;p&gt;其中“日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28500%2C240%2C25%2C13%2C2312.15%29%5E%5Cmathsf%7BT%7D&quot; alt=&quot;(500,240,25,13,2312.15)^\mathsf{T}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里我用了转置，因为习惯上使用列向量表示一条记录（后面会看到原因），本文后面也会遵循这个准则。不过为了方便有时我会省略转置符号，但我们说到向量默认都是指列向量。&lt;/p&gt;
&lt;p&gt;我们当然可以对这一组五维向量进行分析和挖掘，不过我们知道，很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。&lt;/p&gt;
&lt;p&gt;降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。&lt;/p&gt;
&lt;p&gt;举个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。&lt;/p&gt;
&lt;p&gt;当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“相关关系”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。后面的章节中我们会给出相关性的严格数学定义。&lt;/p&gt;
&lt;p&gt;这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。&lt;/p&gt;
&lt;p&gt;上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？&lt;/p&gt;
&lt;p&gt;要回答上面的问题，就要对降维问题进行数学化和形式化的讨论。而PCA是一种具有严格数学基础并且已被广泛采用的降维方法。下面我不会直接描述PCA，而是通过逐步分析问题，让我们一起重新“发明”一遍PCA。&lt;/p&gt;
&lt;h2&gt;2. 向量的表示及基变换&lt;/h2&gt;
&lt;p&gt;既然我们面对的数据被抽象为一组向量，那么下面有必要研究一些向量的数学性质。而这些数学性质将成为后续导出PCA的理论基础。&lt;/p&gt;
&lt;h2&gt;3. 内积与投影&lt;/h2&gt;
&lt;p&gt;下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28a_1%2Ca_2%2C%5Ccdots%2Ca_n%29%5E%5Cmathsf%7BT%7D%5Ccdot+%28b_1%2Cb_2%2C%5Ccdots%2Cb_n%29%5E%5Cmathsf%7BT%7D%3Da_1b_1%2Ba_2b_2%2B%5Ccdots%2Ba_nb_n&quot; alt=&quot;(a_1,a_2,\cdots,a_n)^\mathsf{T}\cdot (b_1,b_2,\cdots,b_n)^\mathsf{T}=a_1b_1+a_2b_2+\cdots+a_nb_n&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。假设&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;是两个&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;维向量，我们知道&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;维向量可以等价表示为&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;维空间中的一条从原点发射的有向线段，为了简单起见我们假设&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;均为二维向量，则&lt;img src=&quot;https://www.zhihu.com/equation?tex=A%3D%28x_1%2Cy_1%29&quot; alt=&quot;A=(x_1,y_1)&quot;/&gt;，&lt;img src=&quot;https://www.zhihu.com/equation?tex=B%3D%28x_2%2Cy_2%29&quot; alt=&quot;B=(x_2,y_2)&quot;/&gt;。则在二维平面上&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;可以用两条发自原点的有向线段表示，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/8d64151ceed0eed4d4708d8d9e6374dc_hd.jpg&quot; alt=&quot;&quot; width=&quot;598&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;593&quot; data-original=&quot;https://pic4.zhimg.com/8d64151ceed0eed4d4708d8d9e6374dc_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/8d64151ceed0eed4d4708d8d9e6374dc_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，现在我们从&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;点向&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;所在直线引一条垂线。我们知道垂线与&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的交点叫做&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;在&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;上的投影，再设&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;与&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的夹角是&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Calpha+&quot; alt=&quot;\alpha &quot;/&gt;，则投影的矢量长度为&lt;img src=&quot;https://www.zhihu.com/equation?tex=%7CA%7Ccos%28%5Calpha+%29&quot; alt=&quot;|A|cos(\alpha )&quot;/&gt;，其中&lt;img src=&quot;https://www.zhihu.com/equation?tex=%7CA%7C%3D%5Csqrt%7Bx_1%5E2%2By_1%5E2%7D&quot; alt=&quot;|A|=\sqrt{x_1^2+y_1^2}&quot;/&gt;是向量&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;的模，也就是&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;线段的标量长度。&lt;/p&gt;
&lt;p&gt;注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。&lt;/p&gt;
&lt;p&gt;到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5Ccdot+B%3D%7CA%7C%7CB%7Ccos%28%5Calpha+%29&quot; alt=&quot;A\cdot B=|A||B|cos(\alpha )&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在事情似乎是有点眉目了：&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;与&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的内积等于&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;到&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的投影长度乘以&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的模。再进一步，如果我们假设&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的模为1，即让&lt;img src=&quot;https://www.zhihu.com/equation?tex=%7CB%7C%3D1&quot; alt=&quot;|B|=1&quot;/&gt;，那么就变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=A%5Ccdot+B%3D%7CA%7Ccos%28%5Calpha+%29&quot; alt=&quot;A\cdot B=|A|cos(\alpha )&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，设向量&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的模为1，则&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;与&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;的内积值等于&lt;img src=&quot;https://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt;向&lt;img src=&quot;https://www.zhihu.com/equation?tex=B&quot; alt=&quot;B&quot;/&gt;所在直线投影的矢量长度！这就是内积的一种几何解释，也是我们得到的第一个重要结论。在后面的推导中，将反复使用这个结论。&lt;/p&gt;
&lt;h2&gt;4. 基&lt;/h2&gt;
&lt;p&gt;下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/df6a713c1b97cc55bd20afce46ace718_hd.jpg&quot; alt=&quot;&quot; width=&quot;599&quot; data-rawwidth=&quot;599&quot; data-rawheight=&quot;596&quot; data-original=&quot;https://pic2.zhimg.com/df6a713c1b97cc55bd20afce46ace718_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/df6a713c1b97cc55bd20afce46ace718_b.jpg&quot;/&gt;在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为&lt;img src=&quot;https://www.zhihu.com/equation?tex=%283%2C2%29&quot; alt=&quot;(3,2)&quot;/&gt;，这是我们再熟悉不过的向量表示。&lt;/p&gt;

&lt;p&gt;不过我们常常忽略，只有一个&lt;img src=&quot;https://www.zhihu.com/equation?tex=%283%2C2%29&quot; alt=&quot;(3,2)&quot;/&gt;本身是不能够精确表示一个向量的。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量&lt;img src=&quot;https://www.zhihu.com/equation?tex=%283%2C2%29&quot; alt=&quot;(3,2)&quot;/&gt;实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。&lt;/p&gt;
&lt;p&gt;更正式的说，向量(x,y)实际上表示线性组合：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=x%281%2C0%29%5E%5Cmathsf%7BT%7D%2By%280%2C1%29%5E%5Cmathsf%7BT%7D&quot; alt=&quot;x(1,0)^\mathsf{T}+y(0,1)^\mathsf{T}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不难证明所有二维向量都可以表示为这样的线性组合。此处&lt;img src=&quot;https://www.zhihu.com/equation?tex=%281%2C0%29&quot; alt=&quot;(1,0)&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=%280%2C1%29&quot; alt=&quot;(0,1)&quot;/&gt;叫做二维空间中的一组基。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/4533331b5b4b5ea98c90f2abed81d470_hd.jpg&quot; alt=&quot;&quot; width=&quot;598&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;594&quot; data-original=&quot;https://pic3.zhimg.com/4533331b5b4b5ea98c90f2abed81d470_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/4533331b5b4b5ea98c90f2abed81d470_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了。只不过我们经常省略第一步，而默认以(1,0)和(0,1)为基。&lt;/p&gt;
&lt;p&gt;我们之所以默认选择(1,0)和(0,1)为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。&lt;/p&gt;
&lt;p&gt;例如，(1,1)和(-1,1)也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%2C%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%29&quot; alt=&quot;(\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28-%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%2C%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%29&quot; alt=&quot;(-\frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}})&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;现在，我们想获得(3,2)在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为&lt;img src=&quot;https://www.zhihu.com/equation?tex=%28%5Cfrac%7B5%7D%7B%5Csqrt%7B2%7D%7D%2C-%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%29&quot; alt=&quot;(\frac{5}{\sqrt{2}},-\frac{1}{\sqrt{2}})&quot;/&gt;。下图给出了新的基以及(3,2)在新基上坐标值的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/ff47d66fa67d12918e4e83678fa6b78d_hd.jpg&quot; alt=&quot;&quot; width=&quot;598&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;595&quot; data-original=&quot;https://pic4.zhimg.com/ff47d66fa67d12918e4e83678fa6b78d_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/ff47d66fa67d12918e4e83678fa6b78d_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外这里要注意的是，我们列举的例子中基是正交的（即内积为0，或直观说相互垂直），但可以成为一组基的唯一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。&lt;/p&gt;
&lt;h2&gt;5. 基变换的矩阵表示&lt;/h2&gt;
&lt;p&gt;下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5C%5C+-1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D+%5Cbegin%7Bpmatrix%7D+3+%5C%5C+2+%5Cend%7Bpmatrix%7D+%3D+%5Cbegin%7Bpmatrix%7D+5%2F%5Csqrt%7B2%7D+%5C%5C+-1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} 1/\sqrt{2} &amp;amp; 1/\sqrt{2} \\ -1/\sqrt{2} &amp;amp; 1/\sqrt{2} \end{pmatrix} \begin{pmatrix} 3 \\ 2 \end{pmatrix} = \begin{pmatrix} 5/\sqrt{2} \\ -1/\sqrt{2} \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;太漂亮了！其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如(1,1)，(2,2)，(3,3)，想变换到刚才那组基上，则可以这样表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5C%5C+-1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D+%5Cbegin%7Bpmatrix%7D+1+%26+2+%26+3+%5C%5C+1+%26+2+%26+3+%5Cend%7Bpmatrix%7D+%3D+%5Cbegin%7Bpmatrix%7D+2%2F%5Csqrt%7B2%7D+%26+4%2F%5Csqrt%7B2%7D+%26+6%2F%5Csqrt%7B2%7D+%5C%5C+0+%26+0+%26+0+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} 1/\sqrt{2} &amp;amp; 1/\sqrt{2} \\ -1/\sqrt{2} &amp;amp; 1/\sqrt{2} \end{pmatrix} \begin{pmatrix} 1 &amp;amp; 2 &amp;amp; 3 \\ 1 &amp;amp; 2 &amp;amp; 3 \end{pmatrix} = \begin{pmatrix} 2/\sqrt{2} &amp;amp; 4/\sqrt{2} &amp;amp; 6/\sqrt{2} \\ 0 &amp;amp; 0 &amp;amp; 0 \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是一组向量的基变换被干净的表示为矩阵的相乘。&lt;/p&gt;
&lt;p&gt;一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。&lt;/p&gt;
&lt;p&gt;数学表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+p_1+%5C%5C+p_2+%5C%5C+%5Cvdots+%5C%5C+p_R+%5Cend%7Bpmatrix%7D+%5Cbegin%7Bpmatrix%7D+a_1+%26+a_2+%26+%5Ccdots+%26+a_M+%5Cend%7Bpmatrix%7D+%3D+%5Cbegin%7Bpmatrix%7D+p_1a_1+%26+p_1a_2+%26+%5Ccdots+%26+p_1a_M+%5C%5C+p_2a_1+%26+p_2a_2+%26+%5Ccdots+%26+p_2a_M+%5C%5C+%5Cvdots+%26+%5Cvdots+%26+%5Cddots+%26+%5Cvdots+%5C%5C+p_Ra_1+%26+p_Ra_2+%26+%5Ccdots+%26+p_Ra_M+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} p_1 \\ p_2 \\ \vdots \\ p_R \end{pmatrix} \begin{pmatrix} a_1 &amp;amp; a_2 &amp;amp; \cdots &amp;amp; a_M \end{pmatrix} = \begin{pmatrix} p_1a_1 &amp;amp; p_1a_2 &amp;amp; \cdots &amp;amp; p_1a_M \\ p_2a_1 &amp;amp; p_2a_2 &amp;amp; \cdots &amp;amp; p_2a_M \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ p_Ra_1 &amp;amp; p_Ra_2 &amp;amp; \cdots &amp;amp; p_Ra_M \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://www.zhihu.com/equation?tex=p_i&quot; alt=&quot;p_i&quot;/&gt;是一个行向量，表示第&lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;个基，&lt;img src=&quot;https://www.zhihu.com/equation?tex=a_j&quot; alt=&quot;a_j&quot;/&gt;是一个列向量，表示第&lt;img src=&quot;https://www.zhihu.com/equation?tex=j&quot; alt=&quot;j&quot;/&gt;个原始数据记录。&lt;/p&gt;
&lt;p&gt;特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。&lt;/p&gt;
&lt;p&gt;最后，上述分析同时给矩阵相乘找到了一种物理解释：两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。&lt;/p&gt;

&lt;p&gt;上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？&lt;/p&gt;
&lt;p&gt;要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。&lt;/p&gt;
&lt;p&gt;为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+1+%26+1+%26+2+%26+4+%26+2+%5C%5C+1+%26+3+%26+3+%26+4+%264+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} 1 &amp;amp; 1 &amp;amp; 2 &amp;amp; 4 &amp;amp; 2 \\ 1 &amp;amp; 3 &amp;amp; 3 &amp;amp; 4 &amp;amp;4 \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。&lt;/p&gt;
&lt;p&gt;我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+-1+%26+-1+%26+0+%26+2+%26+0+%5C%5C+-2+%26+0+%26+0+%26+1+%26+1+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} -1 &amp;amp; -1 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 \\ -2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看下五条数据在平面直角坐标系内的样子：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/e01296f282109b59e18086843866f81a_hd.jpg&quot; alt=&quot;&quot; width=&quot;598&quot; data-rawwidth=&quot;598&quot; data-rawheight=&quot;592&quot; data-original=&quot;https://pic2.zhimg.com/e01296f282109b59e18086843866f81a_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/e01296f282109b59e18086843866f81a_b.jpg&quot;/&gt;现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？&lt;/p&gt;

&lt;p&gt;通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。&lt;/p&gt;
&lt;p&gt;那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。&lt;/p&gt;
&lt;p&gt;以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。&lt;/p&gt;
&lt;p&gt;下面，我们用数学方法表述这个问题。&lt;/p&gt;
&lt;h2&gt;7. 方差&lt;/h2&gt;
&lt;p&gt;上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Var%28a%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B%28a_i-%5Cmu%29%5E2%7D&quot; alt=&quot;Var(a)=\frac{1}{m}\sum_{i=1}^m{(a_i-\mu)^2}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Var%28a%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Ba_i%5E2%7D&quot; alt=&quot;Var(a)=\frac{1}{m}\sum_{i=1}^m{a_i^2}&quot;/&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Var%28a%29%3D%5Cfrac%7B1%7D+%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Ba_i%5E2%7D&quot; alt=&quot;Var(a)=\frac{1} {m}\sum_{i=1}^m{a_i^2}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。&lt;/p&gt;
&lt;h2&gt;8. 协方差&lt;/h2&gt;
&lt;p&gt;对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。&lt;/p&gt;
&lt;p&gt;如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。&lt;/p&gt;
&lt;p&gt;数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Cov%28a%2Cb%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Ba_ib_i%7D&quot; alt=&quot;Cov(a,b)=\frac{1}{m}\sum_{i=1}^m{a_ib_i}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。&lt;/p&gt;
&lt;p&gt;当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。&lt;/p&gt;
&lt;p&gt;至此，我们得到了降维问题的优化目标：将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。&lt;/p&gt;
&lt;h2&gt;9. 协方差矩阵&lt;/h2&gt;
&lt;p&gt;上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。&lt;/p&gt;
&lt;p&gt;我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：&lt;/p&gt;
&lt;p&gt;假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=X%3D%5Cbegin%7Bpmatrix%7D+a_1+%26+a_2+%26+%5Ccdots+%26+a_m+%5C%5C+b_1+%26+b_2+%26+%5Ccdots+%26+b_m+%5Cend%7Bpmatrix%7D&quot; alt=&quot;X=\begin{pmatrix} a_1 &amp;amp; a_2 &amp;amp; \cdots &amp;amp; a_m \\ b_1 &amp;amp; b_2 &amp;amp; \cdots &amp;amp; b_m \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们用X乘以X的转置，并乘上系数1/m：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Cmathsf%7BT%7D%3D%5Cbegin%7Bpmatrix%7D+%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Ba_i%5E2%7D+%26+%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Ba_ib_i%7D+%5C%5C+%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Ba_ib_i%7D+%26+%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7Bb_i%5E2%7D+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\frac{1}{m}XX^\mathsf{T}=\begin{pmatrix} \frac{1}{m}\sum_{i=1}^m{a_i^2} &amp;amp; \frac{1}{m}\sum_{i=1}^m{a_ib_i} \\ \frac{1}{m}\sum_{i=1}^m{a_ib_i} &amp;amp; \frac{1}{m}\sum_{i=1}^m{b_i^2} \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;奇迹出现了！这个矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。&lt;/p&gt;
&lt;p&gt;根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：&lt;/p&gt;
&lt;p&gt;设我们有&lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot;/&gt;个&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;维数据记录，将其按列排成&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;乘&lt;img src=&quot;https://www.zhihu.com/equation?tex=m&quot; alt=&quot;m&quot;/&gt;的矩阵&lt;img src=&quot;https://www.zhihu.com/equation?tex=+X&quot; alt=&quot; X&quot;/&gt;，设&lt;img src=&quot;https://www.zhihu.com/equation?tex=C%3D%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Cmathsf%7BT%7D&quot; alt=&quot;C=\frac{1}{m}XX^\mathsf{T}&quot;/&gt;，则&lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot;/&gt;是一个对称矩阵，其对角线分别个各个字段的方差，而第&lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;行&lt;img src=&quot;https://www.zhihu.com/equation?tex=j&quot; alt=&quot;j&quot;/&gt;列和&lt;img src=&quot;https://www.zhihu.com/equation?tex=j&quot; alt=&quot;j&quot;/&gt;行&lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;列元素相同，表示&lt;img src=&quot;https://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=j&quot; alt=&quot;j&quot;/&gt;两个字段的协方差。&lt;/p&gt;
&lt;h2&gt;10. 协方差矩阵对角化&lt;/h2&gt;
&lt;p&gt;根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：&lt;/p&gt;
&lt;p&gt;设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl+l+l%7D+D+%26+%3D+%26+%5Cfrac%7B1%7D%7Bm%7DYY%5E%5Cmathsf%7BT%7D+%5C%5C+%26+%3D+%26+%5Cfrac%7B1%7D%7Bm%7D%28PX%29%28PX%29%5E%5Cmathsf%7BT%7D+%5C%5C+%26+%3D+%26+%5Cfrac%7B1%7D%7Bm%7DPXX%5E%5Cmathsf%7BT%7DP%5E%5Cmathsf%7BT%7D+%5C%5C+%26+%3D+%26+P%28%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Cmathsf%7BT%7D%29P%5E%5Cmathsf%7BT%7D+%5C%5C+%26+%3D+%26+PCP%5E%5Cmathsf%7BT%7D+%5Cend%7Barray%7D&quot; alt=&quot;\begin{array}{l l l} D &amp;amp; = &amp;amp; \frac{1}{m}YY^\mathsf{T} \\ &amp;amp; = &amp;amp; \frac{1}{m}(PX)(PX)^\mathsf{T} \\ &amp;amp; = &amp;amp; \frac{1}{m}PXX^\mathsf{T}P^\mathsf{T} \\ &amp;amp; = &amp;amp; P(\frac{1}{m}XX^\mathsf{T})P^\mathsf{T} \\ &amp;amp; = &amp;amp; PCP^\mathsf{T} \end{array}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在事情很明白了！我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了寻找一个矩阵P，满足&lt;img src=&quot;https://www.zhihu.com/equation?tex=PCP%5E%5Cmathsf%7BT%7D&quot; alt=&quot;PCP^\mathsf{T}&quot;/&gt;是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件。&lt;/p&gt;
&lt;p&gt;至此，我们离“发明”PCA还有仅一步之遥！&lt;/p&gt;
&lt;p&gt;现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。&lt;/p&gt;
&lt;p&gt;由上文知道，协方差矩阵&lt;img src=&quot;https://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot;/&gt;是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：&lt;/p&gt;
&lt;p&gt;1）实对称矩阵不同特征值对应的特征向量必然正交。&lt;/p&gt;
&lt;p&gt;2）设特征向量&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot;/&gt;重数为r，则必然存在r个线性无关的特征向量对应于&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda&quot; alt=&quot;\lambda&quot;/&gt;，因此可以将这r个特征向量单位正交化。&lt;/p&gt;
&lt;p&gt;由上面两条可知，一个&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;行&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;列的实对称矩阵一定可以找到n个单位正交特征向量，设这&lt;img src=&quot;https://www.zhihu.com/equation?tex=n&quot; alt=&quot;n&quot;/&gt;个特征向量为&lt;img src=&quot;https://www.zhihu.com/equation?tex=e_1%2Ce_2%2C%5Ccdots%2Ce_n&quot; alt=&quot;e_1,e_2,\cdots,e_n&quot;/&gt;，我们将其按列组成矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=E%3D%5Cbegin%7Bpmatrix%7D+e_1+%26+e_2+%26+%5Ccdots+%26+e_n+%5Cend%7Bpmatrix%7D&quot; alt=&quot;E=\begin{pmatrix} e_1 &amp;amp; e_2 &amp;amp; \cdots &amp;amp; e_n \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则对协方差矩阵C有如下结论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=E%5E+%5Cmathsf%7BT%7DCE%3D%5CLambda%3D%5Cbegin%7Bpmatrix%7D+%5Clambda_1+%26+%26+%26+%5C%5C+%26+%5Clambda_2+%26+%26+%5C%5C+%26+%26+%5Cddots+%26+%5C%5C+%26+%26+%26+%5Clambda_n+%5Cend%7Bpmatrix%7D&quot; alt=&quot;E^ \mathsf{T}CE=\Lambda=\begin{pmatrix} \lambda_1 &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; \lambda_2 &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda_n \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CLambda&quot; alt=&quot;\Lambda&quot;/&gt;为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。&lt;/p&gt;
&lt;p&gt;以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。&lt;/p&gt;
&lt;p&gt;到这里，我们发现我们已经找到了需要的矩阵P：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%3DE%5E%5Cmathsf%7BT%7D&quot; alt=&quot;P=E^\mathsf{T}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5CLambda&quot; alt=&quot;\Lambda&quot;/&gt;中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。&lt;/p&gt;
&lt;p&gt;至此我们完成了整个PCA的数学原理讨论。在下面的一节，我们将给出PCA的一个实例。&lt;/p&gt;

&lt;p&gt;为了巩固上面的理论，我们在这一节给出一个具体的PCA实例。&lt;/p&gt;
&lt;p&gt;PCA算法&lt;/p&gt;
&lt;p&gt;总结一下PCA的算法步骤：&lt;/p&gt;
&lt;p&gt;设有m条n维数据。&lt;/p&gt;
&lt;p&gt;1）将原始数据按列组成n行m列矩阵X&lt;/p&gt;
&lt;p&gt;2）将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值&lt;/p&gt;
&lt;p&gt;3）求出协方差矩阵&lt;img src=&quot;https://www.zhihu.com/equation?tex=C%3D%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Cmathsf%7BT%7D&quot; alt=&quot;C=\frac{1}{m}XX^\mathsf{T}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4）求出协方差矩阵的特征值及对应的特征向量&lt;/p&gt;
&lt;p&gt;5）将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P&lt;/p&gt;
&lt;p&gt;6）Y=PX即为降维到k维后的数据&lt;/p&gt;
&lt;p&gt;实例1&lt;/p&gt;
&lt;p&gt;这里以上文提到的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+-1+%26+-1+%26+0+%26+2+%26+0+%5C%5C+-2+%26+0+%26+0+%26+1+%26+1+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} -1 &amp;amp; -1 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 \\ -2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为例，我们用PCA方法将这组二维数据其降到一维。&lt;/p&gt;
&lt;p&gt;因为这个矩阵的每行已经是零均值，这里我们直接求协方差矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=C%3D+%5Cfrac+%7B1%7D%7B5%7D%5Cbegin%7Bpmatrix%7D+-1+%26+-1+%26+0+%26+2+%26+0+%5C%5C+-2+%26+0+%26+0+%26+1+%26+1+%5Cend%7Bpmatrix%7D%5Cbegin%7Bpmatrix%7D+-1+%26+-2+%5C%5C+-1+%26+0+%5C%5C+0+%26+0+%5C%5C+2+%26+1+%5C%5C+0+%26+1+%5Cend%7Bpmatrix%7D%3D%5Cbegin%7Bpmatrix%7D+%5Cfrac%7B6%7D%7B5%7D+%26+%5Cfrac%7B4%7D%7B5%7D+%5C%5C+%5Cfrac%7B4%7D%7B5%7D+%26+%5Cfrac%7B6%7D%7B5%7D+%5Cend%7Bpmatrix%7D&quot; alt=&quot;C= \frac {1}{5}\begin{pmatrix} -1 &amp;amp; -1 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 \\ -2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \end{pmatrix}\begin{pmatrix} -1 &amp;amp; -2 \\ -1 &amp;amp; 0 \\ 0 &amp;amp; 0 \\ 2 &amp;amp; 1 \\ 0 &amp;amp; 1 \end{pmatrix}=\begin{pmatrix} \frac{6}{5} &amp;amp; \frac{4}{5} \\ \frac{4}{5} &amp;amp; \frac{6}{5} \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后求其特征值和特征向量，具体求解方法不再详述，可以参考相关资料。求解后特征值为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Clambda_1%3D2%2C%5Clambda_2%3D2%2F5&quot; alt=&quot;\lambda_1=2,\lambda_2=2/5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其对应的特征向量分别是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1%3D%5Cbegin%7Bpmatrix%7D+1+%5C%5C+1+%5Cend%7Bpmatrix%7D%2Cc_2%3D%5Cbegin%7Bpmatrix%7D+-1+%5C%5C+1+%5Cend%7Bpmatrix%7D&quot; alt=&quot;c_1=\begin{pmatrix} 1 \\ 1 \end{pmatrix},c_2=\begin{pmatrix} -1 \\ 1 \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中对应的特征向量分别是一个通解，&lt;img src=&quot;https://www.zhihu.com/equation?tex=c_1&quot; alt=&quot;c_1&quot;/&gt;和&lt;img src=&quot;https://www.zhihu.com/equation?tex=c_2&quot; alt=&quot;c_2&quot;/&gt;可取任意实数。那么标准化后的特征向量为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%5C%5C+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D%2C%5Cbegin%7Bpmatrix%7D+-1%2F%5Csqrt%7B2%7D+%5C%5C+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D&quot; alt=&quot;\begin{pmatrix} 1/\sqrt{2} \\ 1/\sqrt{2} \end{pmatrix},\begin{pmatrix} -1/\sqrt{2} \\ 1/\sqrt{2} \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们的矩阵P是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=P%3D%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5C%5C+-1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D&quot; alt=&quot;P=\begin{pmatrix} 1/\sqrt{2} &amp;amp; 1/\sqrt{2} \\ -1/\sqrt{2} &amp;amp; 1/\sqrt{2} \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以验证协方差矩阵C的对角化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=PCP%5E%5Cmathsf%7BT%7D%3D%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5C%5C+-1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D%5Cbegin%7Bpmatrix%7D+6%2F5+%26+4%2F5+%5C%5C+4%2F5+%26+6%2F5+%5Cend%7Bpmatrix%7D%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%26+-1%2F%5Csqrt%7B2%7D+%5C%5C+1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D%3D%5Cbegin%7Bpmatrix%7D+2+%26+0+%5C%5C+0+%26+2%2F5+%5Cend%7Bpmatrix%7D&quot; alt=&quot;PCP^\mathsf{T}=\begin{pmatrix} 1/\sqrt{2} &amp;amp; 1/\sqrt{2} \\ -1/\sqrt{2} &amp;amp; 1/\sqrt{2} \end{pmatrix}\begin{pmatrix} 6/5 &amp;amp; 4/5 \\ 4/5 &amp;amp; 6/5 \end{pmatrix}\begin{pmatrix} 1/\sqrt{2} &amp;amp; -1/\sqrt{2} \\ 1/\sqrt{2} &amp;amp; 1/\sqrt{2} \end{pmatrix}=\begin{pmatrix} 2 &amp;amp; 0 \\ 0 &amp;amp; 2/5 \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们用P的第一行乘以数据矩阵，就得到了降维后的表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=Y%3D%5Cbegin%7Bpmatrix%7D+1%2F%5Csqrt%7B2%7D+%26+1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D%5Cbegin%7Bpmatrix%7D+-1+%26+-1+%26+0+%26+2+%26+0+%5C%5C+-2+%26+0+%26+0+%26+1+%26+1+%5Cend%7Bpmatrix%7D%3D%5Cbegin%7Bpmatrix%7D+-3%2F%5Csqrt%7B2%7D+%26+-1%2F%5Csqrt%7B2%7D+%26+0+%26+3%2F%5Csqrt%7B2%7D+%26+-1%2F%5Csqrt%7B2%7D+%5Cend%7Bpmatrix%7D&quot; alt=&quot;Y=\begin{pmatrix} 1/\sqrt{2} &amp;amp; 1/\sqrt{2} \end{pmatrix}\begin{pmatrix} -1 &amp;amp; -1 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 \\ -2 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \end{pmatrix}=\begin{pmatrix} -3/\sqrt{2} &amp;amp; -1/\sqrt{2} &amp;amp; 0 &amp;amp; 3/\sqrt{2} &amp;amp; -1/\sqrt{2} \end{pmatrix}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;降维投影结果如下图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/2988668d28bfefee84b03bbff7dde06f_hd.jpg&quot; alt=&quot;&quot; width=&quot;595&quot; data-rawwidth=&quot;595&quot; data-rawheight=&quot;593&quot; data-original=&quot;https://pic3.zhimg.com/2988668d28bfefee84b03bbff7dde06f_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/2988668d28bfefee84b03bbff7dde06f_b.jpg&quot;/&gt;实例2&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-matlab&quot;&gt;&lt;span class=&quot;k&quot;&gt;function &lt;span class=&quot;nf&quot;&gt;linear_PCA 

&lt;span class=&quot;c&quot;&gt;%% PARAMETERS

&lt;span class=&quot;n&quot;&gt;N &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;mi&quot;&gt;500&lt;span class=&quot;p&quot;&gt;;                       &lt;span class=&quot;c&quot;&gt;% number of data points
&lt;span class=&quot;n&quot;&gt;R &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;mi&quot;&gt;9 &lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;; &lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;mi&quot;&gt;1 &lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;];        &lt;span class=&quot;c&quot;&gt;% covariance matrix

&lt;span class=&quot;c&quot;&gt;%% PROGRAM
&lt;span class=&quot;n&quot;&gt;tic

&lt;span class=&quot;n&quot;&gt;X &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;nb&quot;&gt;randn&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;N&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;R&lt;span class=&quot;p&quot;&gt;;     &lt;span class=&quot;c&quot;&gt;% correlated two-dimensional data

&lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;n&quot;&gt;v&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;n&quot;&gt;Xp&lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;km_pca&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;);                &lt;span class=&quot;c&quot;&gt;% obtain eigenvector matrix E, eigenvalues v and principal components Xp

&lt;span class=&quot;n&quot;&gt;toc
&lt;span class=&quot;c&quot;&gt;%% OUTPUT
&lt;span class=&quot;n&quot;&gt;Y &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(:,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;);
&lt;span class=&quot;n&quot;&gt;figure&lt;span class=&quot;p&quot;&gt;; &lt;span class=&quot;n&quot;&gt;hold &lt;span class=&quot;n&quot;&gt;on
&lt;span class=&quot;n&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;p&quot;&gt;(:,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;),&lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;p&quot;&gt;(:,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;),&lt;span class=&quot;s&quot;&gt;'.'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;Xp&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;Xp&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'.r'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;Y&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;Y&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'.b'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;([&lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;)],[&lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;)],&lt;span class=&quot;s&quot;&gt;'g'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'LineWidth'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;([&lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)],[&lt;span class=&quot;mi&quot;&gt;0 &lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)],&lt;span class=&quot;s&quot;&gt;'k'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'LineWidth'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;axis &lt;span class=&quot;n&quot;&gt;equal
&lt;span class=&quot;n&quot;&gt;legend&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;'data'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'first principal components'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'second principal components'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'first principal direction'&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'second principal direction'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;n&quot;&gt;title&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s&quot;&gt;'linear PCA demo'&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;k&quot;&gt;function&lt;span class=&quot;w&quot;&gt; [E,v,Xp] &lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;w&quot;&gt; &lt;span class=&quot;nf&quot;&gt;km_pca&lt;span class=&quot;p&quot;&gt;(X,m&lt;span class=&quot;p&quot;&gt;)&lt;span class=&quot;w&quot;&gt;
&lt;span class=&quot;n&quot;&gt;N &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;nb&quot;&gt;size&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;);
&lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;n&quot;&gt;V&lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;eig&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;o&quot;&gt;'*&lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;o&quot;&gt;/&lt;span class=&quot;n&quot;&gt;N&lt;span class=&quot;p&quot;&gt;);

&lt;span class=&quot;n&quot;&gt;v &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;nb&quot;&gt;diag&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;V&lt;span class=&quot;p&quot;&gt;);
&lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;n&quot;&gt;v&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;n&quot;&gt;ind&lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;sort&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;v&lt;span class=&quot;p&quot;&gt;,&lt;span class=&quot;s&quot;&gt;'descend'&lt;span class=&quot;p&quot;&gt;);
&lt;span class=&quot;n&quot;&gt;E &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;E&lt;span class=&quot;p&quot;&gt;(:,&lt;span class=&quot;n&quot;&gt;ind&lt;span class=&quot;p&quot;&gt;);

&lt;span class=&quot;n&quot;&gt;Xp &lt;span class=&quot;p&quot;&gt;= &lt;span class=&quot;n&quot;&gt;X&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;E&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 17 May 2018 15:52:00 +0000</pubDate>
<dc:creator>能力工场-小马哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hadoop2015/p/9054046.html</dc:identifier>
</item>
</channel>
</rss>