<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构6 队列 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8277506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8277506.html</guid>
<description>&lt;p&gt;上一篇讲了&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8273323.html&quot; target=&quot;_blank&quot;&gt;栈&lt;/a&gt;，这一篇要讲的是我们常用的队列，我会从以下几个方面进行总结。&lt;/p&gt;
&lt;p&gt;1、什么是队列 &lt;br/&gt;2、队列的存储结构&lt;br/&gt;3、队列的常用操作及实现代码&lt;/p&gt;

&lt;h2&gt;1、什么是队列 &lt;/h2&gt;
&lt;p&gt;（1）首先，队列也是一种特殊的&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8247210.html&quot; target=&quot;_blank&quot;&gt;线性表&lt;/a&gt;，它是一种操作受限的线性表。只允许在表的一端进行元素插入，而在另一端进行元素删除。允许插入的一端称为队尾，允许删除的一端称为队头。&lt;/p&gt;
&lt;p&gt;（2）队列与现实生活中的排队类似（如下图），新加入的成员总是在队尾，而排在队列最前面的总是最先离开队列，即先进先出 First In First Out (FIFO)，因此队列就是先进先出线性表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180112220910582-1413905351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （3）线性表分为顺序表和链表，所以队列也分为&lt;strong&gt;顺序队列&lt;/strong&gt;和&lt;strong&gt;链式队列，&lt;/strong&gt;为了方便演示，下文所使用的队列都是&lt;strong&gt;顺序队列&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;2、队列的存储结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180112221749222-487751836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用java语言自己封装一个顺序队列：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SeqQueue.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 封装一个顺序队列
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeqQueue {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存数据&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] data;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头指针&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; head;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾指针&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rear;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列的最大容量&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxSize;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SeqQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxSize) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maxSize =&lt;span&gt; maxSize;
        data &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[maxSize];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3、队列的常用操作及实现代码&lt;/h2&gt;
&lt;h3&gt;3-1、初始化队列&lt;/h3&gt;
&lt;p&gt;思路：构造一个空队列，并将头指针head和尾指针rear都设置为0。&lt;/p&gt;
&lt;p&gt;代码：&lt;span&gt;SeqQueueOperate.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 封装队列的常见操作
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeqQueueOperate {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初始化
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; maxSize
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; SeqQueue init(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxSize) {
        SeqQueue queue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SeqQueue(maxSize);
        queue.head &lt;/span&gt;= 0&lt;span&gt;;
        queue.rear &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; queue;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3-2、入队&lt;/h3&gt;
&lt;p&gt;思路：若队列没有满，则将数据插入到尾指针rear指向的位置，然后再将rear加1。&lt;/p&gt;
&lt;p&gt;代码：在 &lt;span&gt;SeqQueueOperate.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 入队
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enter(SeqQueue queue, Object obj) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断队列是否已经满了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (queue.rear &amp;gt;=&lt;span&gt; queue.maxSize) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        queue.data[queue.rear] &lt;/span&gt;=&lt;span&gt; obj;
        queue.rear&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3-3、出队&lt;/h3&gt;
&lt;p&gt;思路：若队列不为空，则将头指针指向的元素删除，然后将头指针加1。&lt;/p&gt;
&lt;p&gt;代码：在 &lt;span&gt;SeqQueueOperate.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 出队
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object dequeue(SeqQueue queue) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断队列是否为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (queue.head ==&lt;span&gt; queue.rear) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        Object obj &lt;/span&gt;=&lt;span&gt; queue.data[queue.head];
        queue.data[queue.head] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        queue.head&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3-4、取队头&lt;/h3&gt;
&lt;p&gt;思路：若队列不为空，则返回队头元素。&lt;/p&gt;
&lt;p&gt;代码：在 &lt;span&gt;SeqQueueOperate.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取队头
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getHead(SeqQueue queue) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断队列是否为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (queue.head ==&lt;span&gt; queue.rear) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        Object obj &lt;/span&gt;=&lt;span&gt; queue.data[queue.head];
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3-5、取队长&lt;/h3&gt;
&lt;p&gt;思路：即尾指针 - 头指针的值。&lt;/p&gt;
&lt;p&gt;代码：在 &lt;span&gt;SeqQueueOperate.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取队长
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getLength(SeqQueue queue) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; queue.rear -&lt;span&gt; queue.head;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3-6、判队空&lt;/h3&gt;
&lt;p&gt;思路：只需要判断头指针和尾指针是否相等即可&lt;/p&gt;
&lt;p&gt;代码：在 &lt;span&gt;SeqQueueOperate.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断队列是否为空
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty(SeqQueue queue) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; queue.head ==&lt;span&gt; queue.rear;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3-7、判队满&lt;/h3&gt;
&lt;p&gt;思路：只需判断尾指针与maxSize是否相等即可&lt;/p&gt;
&lt;p&gt;代码：在 &lt;span&gt;SeqQueueOperate.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断队列是否已经满了
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isFull(SeqQueue queue) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; queue.rear &amp;gt;=&lt;span&gt; queue.maxSize;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4、测试&lt;/h2&gt;
&lt;p&gt;添加一个用来测试的类&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QueueTest.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 用来测试
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueueTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SeqQueueOperate seqQueueOperate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SeqQueueOperate();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大容量设置为5&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; maxSize = 5&lt;span&gt;;
        SeqQueue queue &lt;/span&gt;=&lt;span&gt; seqQueueOperate.init(maxSize);
        System.out.println(&lt;/span&gt;&quot;队列的最大容量是：&quot; +&lt;span&gt; maxSize);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前队列的长度&lt;/span&gt;
        System.out.println(&quot;当前队列的长度是：&quot; +&lt;span&gt; seqQueueOperate.getLength(queue));
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;===========入队start ===========&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;插入6个元素试试&quot;&lt;span&gt;);
        seqQueueOperate.enter(queue, &lt;/span&gt;1&lt;span&gt;);
        seqQueueOperate.enter(queue, &lt;/span&gt;2&lt;span&gt;);
        seqQueueOperate.enter(queue, &lt;/span&gt;3&lt;span&gt;);
        seqQueueOperate.enter(queue, &lt;/span&gt;4&lt;span&gt;);
        seqQueueOperate.enter(queue, &lt;/span&gt;5&lt;span&gt;);
        seqQueueOperate.enter(queue, &lt;/span&gt;6&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;===========入队end =============&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前队列的长度&lt;/span&gt;
        System.out.println(&quot;当前队列的长度是：&quot; +&lt;span&gt; seqQueueOperate.getLength(queue));
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出队&lt;/span&gt;
        System.out.println(&quot;===========出队start ===========&quot;&lt;span&gt;);
        Object obj &lt;/span&gt;=&lt;span&gt; seqQueueOperate.dequeue(queue);
        System.out.println(&lt;/span&gt;&quot;出队的元素是：&quot; +&lt;span&gt; obj);
        System.out.println(&lt;/span&gt;&quot;===========出队end =============&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前队列的长度&lt;/span&gt;
        System.out.println(&quot;当前队列的长度是：&quot; +&lt;span&gt; seqQueueOperate.getLength(queue));
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;------------------------------------&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;队头元素是：&quot; +&lt;span&gt; queue.data[queue.head]);
        System.out.println(&lt;/span&gt;&quot;队尾元素是：&quot; + queue.data[queue.rear-1&lt;span&gt;]);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180113000011660-1083394343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注意：在一个非空的队列中，头指针始终指向队头元素，而尾指针始终指向&lt;strong&gt;队尾元素的下一个位置&lt;/strong&gt;。&lt;/p&gt;


&lt;p&gt;欢迎转载，但请保留文章原始出处&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 数据结构6 队列&quot; href=&quot;http://www.cnblogs.com/nnngu/p/8277506.html&quot;&gt;http://www.cnblogs.com/nnngu/p/8277506.html&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Fri, 12 Jan 2018 16:10:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8277506.html</dc:identifier>
</item>
<item>
<title>有关求任意一个正整数的n的因数的个数的求解思路 - 顾河建</title>
<link>http://www.cnblogs.com/cittysteven/p/8278114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cittysteven/p/8278114.html</guid>
<description>&lt;p&gt;&lt;strong&gt;已知条件：&lt;/strong&gt;n=p1^a1xp2^a2xp3^a3........xpk^ak;求解n的因数的个数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求解的主要思想：递归&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设所有的因数的个数为U1；&lt;/p&gt;
&lt;p&gt;则U1会等于什么呢？&lt;/p&gt;
&lt;p&gt;不妨设求得p2^a2xp3^a3.......xpk^ak=U2;&lt;/p&gt;
&lt;p&gt;则我们可以这样考虑：&lt;/p&gt;
&lt;p&gt;U1包含3部分：1.只有p1的因素：共有a1种（无非是p1,p1*p1,...）&lt;/p&gt;
&lt;p&gt;                         2.不包含p1: 共有U2种&lt;/p&gt;
&lt;p&gt;                         3.包含p1,但不只是p1: 共有a1xU2种（对于U2中的每一种情况加乘有p1的项，就会构成新的一个因数）&lt;/p&gt;
&lt;p&gt;也许你会有疑问，假如有重复怎么办？答案是不可能的，因为如果重复的那个数是m，则m存在多种素因数分解式，显然矛盾。&lt;/p&gt;
&lt;p&gt;因此，我们可以得到一个递推式：U1=a1+U2+a1xU2=a1+(a1+1)U2;但是，有没有注意到，所有的因数都没有包含1，显然我们上面所包含的因素都大于1；&lt;/p&gt;
&lt;p&gt;所以设n的所有素因数的个数为C则C=U1+1;&lt;/p&gt;
&lt;p&gt;                                           又递推可知：U2=a2+(a2+1)U3&lt;/p&gt;
&lt;p&gt;                                             ...............................................&lt;/p&gt;
&lt;p&gt;                                        以上递推式可解得：U1=a1+a2x(a1+1)+a3x(a2+1)x(a1+1)+.......+akx(a[k-1]+1)x(a[k-2]+1)x....(a1+1)&lt;/p&gt;
&lt;p&gt;                                       C=U1+1=a1+1+a2x(a1+1)+.....=(a1+1）x(a2+1)+........        &lt;/p&gt;
&lt;p&gt;                                       发现了吧:最后C=（a1+1）x(a2+1)x(a3+1).........x(ak+1)&lt;/p&gt;
&lt;p&gt;以上就是借助递归思想进行求解的过程，可见递归还是很强大的。&lt;/p&gt;

</description>
<pubDate>Fri, 12 Jan 2018 15:52:00 +0000</pubDate>
<dc:creator>顾河建</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cittysteven/p/8278114.html</dc:identifier>
</item>
<item>
<title>深入设计电子计算器(一)——CPU指令集设计 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/8254096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/8254096.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/8254096.html 

　　作者：窗户

　　QQ：&lt;span&gt;6679072&lt;/span&gt;

　　E-mail：&lt;span&gt;6679072@qq.com
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　前几天写了一篇&lt;a href=&quot;http://www.cnblogs.com/Colin-Cai/p/8185972.html&quot; target=&quot;_blank&quot;&gt;《如何设计一个电子计算器》&lt;/a&gt;，一个朋友看了之后说实在太low，好吧，依照他的意思，那我就采用文中FPGA设计的方式，然后自己从&lt;strong&gt;&lt;span&gt;指令集设计&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;cpu设计&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;汇编器设计&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;汇编程序设&lt;/span&gt;&lt;/strong&gt;计一路设计过去，再多写个几篇水文，组一个系列，取名就叫《深入设计电子计算器》。基本的计算器原理方面，还是先看一下&lt;a href=&quot;http://www.cnblogs.com/Colin-Cai/p/8185972.html&quot; target=&quot;_blank&quot;&gt;《如何设计一个电子计算器》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; 　   设计的第一步，是设计CPU的指令集，我这里一切从零开始设计。以前想在chinaunix召集人设计一个32位处理器来学习学习，并移植gcc或者llvm来编译C语言，当时考虑做一个RISC，采用三条流水线，最终移植编译器有人而一起设计CPU没人。当然，本系列只是一个抛砖引玉，我并不打算用很深的原理来设计这个CPU，那会花费很多的时间与精力，而只是让这个CPU可以运行起来而已。&lt;/p&gt;
&lt;p&gt;　　此CPU为16位，CPU核中有8个通用寄存器，为r0~r7，都为16位寄存器。指令存储和数据存储分开，采用哈佛结构，两套总线。&lt;/p&gt;
&lt;p&gt;　　有两个中断信号，对于我这个演示来说应该足够了。中断信号外面接一个中断控制器，接入两个中断源。这两个中断源一个接定时器，另外一个直接拖出去给外部用。而中断控制器和定时器都挂在数据总线上，以便CPU来设置。&lt;/p&gt;
&lt;p&gt;　　整个模块架构如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1151747/201801/1151747-20180112211230691-1634853149.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　设置以下指令：（rn、rm这里，n、m为寄存器数字编号,i为立即数，但不同指令范围有区别，=&amp;gt;是赋值,[r7]在这里代表r7地址的数据RAM）&lt;/p&gt;
&lt;p&gt;　　赋值指令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mov rn, rm　　rm=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　movi rn, i　　　i=&amp;gt;rn　　此处i为立即数，范围0~65535&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　movib rn,i　　  i=&amp;gt;rn　　此处i为立即数，范围0~255&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　movtr rn　　　rn=&amp;gt;[r7]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　movfr rn　　　[r7]=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　算术指令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　add rn, rm　　rn+rm=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sub rn,rm　　rn-rm=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　addi rn,i　　  rn+i=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　subi rn,i　　　rn-i=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mul　　　　  r0Xr1=&amp;gt;r2:r3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　umul　　　　r0Xr1=&amp;gt;r2:r3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　div　　　　　r2:r3/r0=&amp;gt;r1,r4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　udiv　　　　 r2:r3/r0=&amp;gt;r1,r4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　逻辑指令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　and rn, rm　　rn&amp;amp;rm=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　or rn,rm　    　rn|rm=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　xor rn, rm　　  rn^rm=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　not rn　　　　 ~rn=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sl rn,i　　　　 rn&amp;lt;&amp;lt;i=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sr rn,i　　　　rn&amp;gt;&amp;gt;i=&amp;gt;rn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　跳转指令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　bz i　　　　如果上一条指令出现了0就跳转到当前指令地址+i　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　bb rn,i,im 　如果寄存器rn的第i位为1就跳转到当前指令地址+i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b i　　　　无条件跳转到i地址　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　call i　　　把下一条指令地址压栈，r0~r7压栈，并跳转到i地址　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ret　　　　把之前call压栈的r0~r7恢复，并回到call压栈的执行地址　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　reti　　　　当中断发生的时候，会把当前执行地址，r0~r7压栈，reti会把这些寄存器弹出，并回到之前执行地址，并通知中断控制器&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　这些指令对于CPU基本是完备了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;以上指令集还有点问题，我也还没有设计准确的opcode，可能会被修改，但我尽我自己完成这一系列，本篇是这个系列的第一篇。尽管偷工减料版也可能会花去我相当的时间，但我想对于来看的网友多少有那么一点点帮助吧，那就可以了，希望支持。&lt;/span&gt;　&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:44:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/8254096.html</dc:identifier>
</item>
<item>
<title>OLEDB数据源 - GunLun</title>
<link>http://www.cnblogs.com/lanuage/p/8278087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanuage/p/8278087.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: OLEDB数据源&lt;br/&gt;date: 2018-01-12 21:42:37&lt;br/&gt;tags: [OLEDB, 数据库编程, VC++, 数据库]&lt;br/&gt;categories: windows 数据库编程&lt;br/&gt;keywords: OLEDB, 数据库编程, VC++, 数据库&lt;br/&gt;---&lt;br/&gt;数据源在oledb中指数据提供者，这里可以简单的理解为数据库程序。数据源对象代表数据库的一个连接，是需要创建的第一个对象。而数据源对象主要用于配置数据库连接的相关属性如连接数据库的用户名密码等等&lt;/p&gt;&lt;p&gt;数据源主要完成的功能如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行数据库身份认证&lt;/li&gt;
&lt;li&gt;为每个连接准备对应的资源，如对应的数据缓冲，网络连接资源&lt;/li&gt;
&lt;li&gt;设置连接属性，给访问者何种权限，设置连接的超时值等等，对象会根据对应的属性打开对应的接口。它的这些设置都是通过属性进行的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OLEDB虽然是基于COM的一组接口，但是它与标准的COM接口有点不同，它的一大特色在于它自身的属性设置，有的接口虽然对象中存在但是调用QueryInterface是查询不出来的，只有设置相应的接口才会打开，有的接口可以根据属性值表现不同的行为。比如设置了对应的只读属性则不允许使用更新接口。&lt;br/&gt;每个属性都有值、类型、说明和读写属性，对于行集对象，还有一个用于指示是否可以逐列应用它的指示器。&lt;br/&gt;属性由一个GUID和一个整数ID进行唯一标识。&lt;br/&gt;属性集是所有具有相同 组GUID 的一组属性。在逻辑上它们都用于同一种功能，比如有的属性集用于设置数据源连接属性，有的用于设置行集属性等等。它们是应用在同一个特定对象上的一组属性。在每个这样的属性组中都有属性每个属性属于一个或者多个属性组。&lt;br/&gt;属性定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; tagDBPROP {
   DBPROPID        dwPropertyID; &lt;span class=&quot;co&quot;&gt;//属性GUID&lt;/span&gt;
   DBPROPOPTIONS   dwOptions; &lt;span class=&quot;co&quot;&gt;//属性的操作方式&lt;/span&gt;
   DBPROPSTATUS    dwStatus; &lt;span class=&quot;co&quot;&gt;//属性设置状态&lt;/span&gt;
   DBID            colid; &lt;span class=&quot;co&quot;&gt;//属性ID，一般给DB_NULLID&lt;/span&gt;
   VARIANT         vValue; &lt;span class=&quot;co&quot;&gt;//属性值&lt;/span&gt;
} DBPROP;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dwOptions:属性的操作方式有3种，但是一般只使用其中的两种：DBPROPOPTIONS_REQUIRED表示必须设置成功，如果设置失败，则设置属性的操作失败，DBPROPOPTIONS_OPTIONAL，表示可选，即即使该属性设置失败，设置属性的操作也返回成功。DBPROPOPTIONS_SETIFCHEAP表示如果在设置属性操作时在在dwStatus参数中返回该属性设置的状态，是否成功，失败的原因等等。&lt;br/&gt;属性集的定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; tagDBPROPSET {
   DBPROP *   rgProperties; &lt;span class=&quot;co&quot;&gt;//属性数组的指针&lt;/span&gt;
   ULONG      cProperties; &lt;span class=&quot;co&quot;&gt;//属性数组中元素个数&lt;/span&gt;
   GUID       guidPropertySet; &lt;span class=&quot;co&quot;&gt;//属性集的GUID&lt;/span&gt;
} DBPROPSET;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前属性组包括初始化属性组、数据源属性组、会话属性组、行集属性组、表属性组和列属性组等等。&lt;br/&gt;设置属性一般包含如下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配一个属性类型DBPRO的数组，一般倾向于多分配一个，最后一个数组元素全0，作为结尾&lt;/li&gt;
&lt;li&gt;确定每个属性的属性GUID，即明确我们需要设置的是对象的哪个属性&lt;/li&gt;
&lt;li&gt;填充对应的属性值，属性操作方式&lt;/li&gt;
&lt;li&gt;填充对应的属性集DBPROPSET结构。设置该属性集的GUID&lt;/li&gt;
&lt;li&gt;调用对应的接口设置属性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据源对象的接口定义如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;CoType TDataSource {
   [mandatory]   interface IDBCreateSession; &lt;span class=&quot;co&quot;&gt;//创建回话对象&lt;/span&gt;
   [mandatory]   interface IDBInitialize; &lt;span class=&quot;co&quot;&gt;//创建数据源连接对象&lt;/span&gt;
   [mandatory]   interface IDBProperties; &lt;span class=&quot;co&quot;&gt;///&lt;/span&gt;创建数据源的属性操作对象
   [mandatory]   interface IPersist;
   [optional]    interface IConnectionPointContainer;
   [optional]    interface IDBAsynchStatus;
   [optional]    interface IDBDataSourceAdmin;
   [optional]    interface IDBInfo;
   [optional]    interface IObjectAccessControl;
   [optional]    interface IPersistFile;
   [optional]    interface ISecurityInfo;
   [optional]    interface ISupportErrorInfo;
   [optional]    interface ITrusteeAdmin;
   [optional]    interface ITrusteeGroupAdmin;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面代码中，mandatory表示是数据源必须提供的接口，optional表示的是可选性提供的接口，在创建对应的接口时尽量使用必须实现的接口，如果需要使用可选择的接口，一定要判断数据源是否支持。在数据源对象中最主要的还是前三个必须提供的接口&lt;/p&gt;

&lt;p&gt;连接到数据源一般使用IDBInitialize接口的Initialize方法，但是生成IDBInitialize接口有几种不同的方式，下面一一列举出来&lt;/p&gt;
&lt;h2 id=&quot;直接创建idbinitialize接口&quot;&gt;直接创建IDBInitialize接口&lt;/h2&gt;
&lt;p&gt;这种方式一般调用CoCreateInstance函数创建，下面是具体的代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;tchar.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;windows.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;strsafe.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define COM_NO_WINDOWS_H    &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//如果已经包含了Windows.h或不使用其他Windows库函数时&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define OLEDBVER 0x0260     &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//MSDAC2.6版&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;oledb.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;oledberr.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define GRS_ALLOC(sz)       HeapAlloc(GetProcessHeap(),0,sz)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_CALLOC(sz)      HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sz)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_SAFEFREE(p)     if(NULL != p){HeapFree(GetProcessHeap(),0,p);p=NULL;}&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define GRS_USEPRINTF() TCHAR pBuf[1024] = {}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//定义输出宏&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_PRINTF(...) &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    GRS_USEPRINTF();&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    StringCchPrintf(pBuf,1024,__VA_ARGS__);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),pBuf,lstrlen(pBuf),NULL,NULL);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安全释放，为了养成良好的编码习惯，特作此宏定义&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_SAFERELEASE(I)&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(NULL != (I))&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        (I)-&amp;gt;Release();&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        (I)=NULL;&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//检测上一步的操作是否成功&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define GRS_COM_CHECK(hr,...)&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    if(FAILED(hr))&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    {&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        GRS_PRINTF(__VA_ARGS__);&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        goto CLEAR_UP;&lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    }&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; _tmain(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; argc, TCHAR* argv[])
{
    CoInitialize(NULL);
    &lt;span class=&quot;co&quot;&gt;//创建OLEDB init接口&lt;/span&gt;
    IDBInitialize *pDBInit = NULL;
    IDBProperties *pIDBProperties = NULL;
    &lt;span class=&quot;co&quot;&gt;//设置链接属性&lt;/span&gt;
    DBPROPSET dbPropset[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    DBPROP dbProps[&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};
    CLSID clsid_MSDASQL = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;}; &lt;span class=&quot;co&quot;&gt;//sql server 的数据源对象&lt;/span&gt;
    
    HRESULT hRes = CLSIDFromProgID(_T(&lt;span class=&quot;st&quot;&gt;&quot;SQLOLEDB&quot;&lt;/span&gt;), &amp;amp;clsid_MSDASQL);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取SQLOLEDB的CLSID失败，错误码：0x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = CoCreateInstance(clsid_MSDASQL, NULL, CLSCTX_INPROC_SERVER, IID_IDBInitialize,(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pDBInit);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;无法创建IDBInitialize接口，错误码：0x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//指定数据库实例名，这里使用了别名local，指定本地默认实例&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].dwPropertyID = DBPROP_INIT_DATASOURCE;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].dwOptions = DBPROPOPTIONS_REQUIRED;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;LIU-PC&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;SQLEXPRESS&quot;&lt;/span&gt;));
    dbProps[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].colid = DB_NULLID;

    &lt;span class=&quot;co&quot;&gt;//指定数据库库名&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].dwPropertyID = DBPROP_INIT_CATALOG;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].dwOptions = DBPROPOPTIONS_REQUIRED;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;Study&quot;&lt;/span&gt;));
    dbProps[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].colid = DB_NULLID;

    &lt;span class=&quot;co&quot;&gt;//指定链接数据库的用户名&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].dwPropertyID = DBPROP_AUTH_USERID;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;sa&quot;&lt;/span&gt;));
    
    &lt;span class=&quot;co&quot;&gt;//指定链接数据库的用户密码&lt;/span&gt;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].dwPropertyID = DBPROP_AUTH_PASSWORD;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].vValue.vt = VT_BSTR;
    dbProps[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;].vValue.bstrVal = SysAllocString(OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;));
    
    
    &lt;span class=&quot;co&quot;&gt;//设置属性&lt;/span&gt;
    hRes = pDBInit-&amp;gt;QueryInterface(IID_IDBProperties, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBProperties);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;查询IDBProperties接口失败, 错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    dbPropset-&amp;gt;guidPropertySet = DBPROPSET_DBINIT;
    dbPropset[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].cProperties = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;
    dbPropset[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;].rgProperties = dbProps;
    hRes = pIDBProperties-&amp;gt;SetProperties(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, dbPropset);
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;设置属性失败, 错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//链接数据库&lt;/span&gt;
    hRes = pDBInit-&amp;gt;Initialize();
    GRS_COM_CHECK(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库失败：错误码:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    &lt;span class=&quot;co&quot;&gt;//do something&lt;/span&gt;
    pDBInit-&amp;gt;Uninitialize();

    GRS_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;数据库操作成功!!!!!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));
CLEAR_UP:
    GRS_SAFEFREE(pDBInit);
    GRS_SAFEFREE(pIDBProperties);
    CoUninitialize();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一份完整的可执行代码，后续的部分对于重复的代码将不再给出。&lt;br/&gt;在上述代码中我们首先根据字符串SQLOLEDB查找到SQL Server对应的数据源对象，然后根据数据源对象查询出IDBProperties对象，接着分配一些空间来设置属性和属性集，调用IDBProperties接口的SetProperties函数来设置对应的数据源对象的接口。最后调用IDBInitialize接口的Initialize链接数据源，调用Uninitialize函数来断开连接。&lt;br/&gt;一般数据源对象的属性集合的GUID为DBPROPSET_DBINIT，下面包含的属性最主要的有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DBPROP_INIT_DATASOURCE:数据连接实例（具体的DBMS实例名）&lt;/li&gt;
&lt;li&gt;DBPROP_INIT_CATALOG：目录名（在SQL Server中对应的是具体的数据库名称，对于ORACLE来说没有意义）&lt;/li&gt;
&lt;li&gt;DBPROP_AUTH_USERID: 用户名&lt;/li&gt;
&lt;li&gt;DBPROP_AUTH_PASSWORD: 密码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们也注意到上面调用SysAllocString的BSTR类型的字符串并没有调用对应的函数进行释放，会不会发生内存泄露？其实不用担心OLEDB在断开连接的时候已经帮助我们释放了这部分空间。&lt;/p&gt;
&lt;h2 id=&quot;使用idbpromptinitialize接口来创建数据源对象&quot;&gt;使用IDBPromptInitialize接口来创建数据源对象&lt;/h2&gt;
&lt;p&gt;上述方法是依托于标准的COM，虽然也成功创建的数据源连接，但是无法在标准的com之上进行更多的初始化操作，导致了有些特定的高级功能无法使用，所以在实践中常用的还是利用IDBPromptInitialize和IDataInitialize的方式比较多。&lt;br/&gt;IDBPromptInitialize创建时会弹出一个数据源选择的对话框，供用户选择相关配置信息（数据源/用户名/密码等）然后根据这些配置自动生成连接对象。&lt;br/&gt;下面看一个弹出数据源对话框的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConnectSQLServerByDialog() &lt;span class=&quot;co&quot;&gt;//通过弹出对话框来链接SQL SERVER数据库&lt;/span&gt;
{
    DECLARE_BUFFER();
    DECLARE_OLEDB_INTERFACE(IDBPromptInitialize);
    DECLARE_OLEDB_INTERFACE(IDBInitialize);

    HWND hDesktop = GetDesktopWindow();
    HRESULT hRes = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER, IID_IDBPromptInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBPromptInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBPromptInitialize接口失败: &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    &lt;span class=&quot;co&quot;&gt;//调用该函数弹出数据源对话框&lt;/span&gt;
    hRes = pIDBPromptInitialize-&amp;gt;PromptDataSource(NULL, hDesktop, DBPROMPTOPTIONS_PROPERTYSHEET, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL, IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;弹出数据源对话框失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    hRes = pIDBInitialize-&amp;gt;Initialize();
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;链接数据库成功&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));

    hRes = pIDBInitialize-&amp;gt;Uninitialize();
__CLEAN_UP:
    SAFE_RELEASE(pIDBPromptInitialize);
    SAFE_RELEASE(pIDBInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了这种方式，他还可以直接创建出IDBInitialize接口，利用之前设置属性的方式来连接到数据库，下面是一个演示的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;    HRESULT hRes = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建接口IDBInitialize失败：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = CLSIDFromProgID(_T(&lt;span class=&quot;st&quot;&gt;&quot;SQLOLEDB&quot;&lt;/span&gt;), &amp;amp;clsid);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;查询SQLOLEDB CLSID 失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = pIDataInitialize-&amp;gt;CreateDBInstance(clsid, NULL,
        CLSCTX_INPROC_SERVER, NULL, IID_IDBInitialize,
        (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    &lt;span class=&quot;co&quot;&gt;//后续的代码就是我们之前写的那段定义属性，设置属性，连接数据库的代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;使用idatainitialize接口来创建数据源对象&quot;&gt;使用IDataInitialize接口来创建数据源对象&lt;/h2&gt;
&lt;p&gt;使用IDataInitialize接口可以直接使用连接字串连接到数据库，下面是使用连接字串的例子:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ConnectSQLServerByConnstr() &lt;span class=&quot;co&quot;&gt;//通过连接字符串连接数据库&lt;/span&gt;
{
    DECLARE_OLEDB_INTERFACE(IDataInitialize);
    DECLARE_OLEDB_INTERFACE(IDBInitialize);
    DECLARE_BUFFER();
    HRESULT hRes = CoCreateInstance(CLSID_MSDAINITIALIZE, NULL, CLSCTX_INPROC_SERVER, IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDataInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

    hRes = pIDataInitialize-&amp;gt;GetDataSource(NULL, CLSCTX_INPROC_SERVER, 
        OLESTR(&lt;span class=&quot;st&quot;&gt;&quot;Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;Password = 123456;Initial Catalog=Study;Data Source=LIU-PC&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;SQLEXPRESS;&quot;&lt;/span&gt;), 
        IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取IDBInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    hRes = pIDBInitialize-&amp;gt;Initialize();
    COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;连接数据库失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
    COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;连接数据库成功&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;));
    pIDBInitialize-&amp;gt;Uninitialize();
__CLEAN_UP:
    SAFE_RELEASE(pIDataInitialize);
    SAFE_RELEASE(pIDBInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实除了上面这种直接创建IDataInitialize接口的方法外，还可以使用IDBPromptInitialize接口Query出一个IDataInitialize接口，然后再设置连接字串连接到数据库。&lt;br/&gt;其实在OLEDB中，可以认为连接字串最终被翻译为对应的属性，也就是说OLEDDB保存着对应连接的属性，我们可以通过不同的方式来获取不同类型的属性，比如使用IDBProperties接口来获取对应的链接属性，或者使用IDataInitialize的GetInitializationString函数来获取连接的链接字串。&lt;br/&gt;既然它保存着每个连接的对应属性，那么是不是可以将用户在数据源对话框上的操作最终保存为数据连接字串呢，答案是肯定的。实现的思路如下：&lt;/p&gt;
&lt;ol readability=&quot;0.48894062863795&quot;&gt;&lt;li&gt;调用IDBPromptInitialize接口的PromptDataSourc方法弹出数据源对话框，让用户操作&lt;/li&gt;
&lt;li&gt;根据IDBPromptInitialize接口Query出IDataInitialize接口&lt;/li&gt;
&lt;li readability=&quot;17.561257216164&quot;&gt;
&lt;p&gt;调用IDataInitialize接口的GetInitializationString来获取连接字串&lt;br/&gt;下面是具体实现的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; GetConnectString()
{
DECLARE_OLEDB_INTERFACE(IDBPromptInitialize);
DECLARE_OLEDB_INTERFACE(IDataInitialize);
DECLARE_OLEDB_INTERFACE(IDBInitialize);
DECLARE_BUFFER();

LPOLESTR pConnStr = NULL;
HWND hDeskTop = GetDesktopWindow();
HRESULT hRes = CoCreateInstance(CLSID_DataLinks, NULL, CLSCTX_INPROC_SERVER, IID_IDBPromptInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDBPromptInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDBPromptInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);
hRes = pIDBPromptInitialize-&amp;gt;PromptDataSource(NULL, hDeskTop, DBPROMPTOPTIONS_PROPERTYSHEET, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NULL, NULL, IID_IDBInitialize, (IUnknown**)&amp;amp;pIDBInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;弹出数据源对话框失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);


hRes= pIDBPromptInitialize-&amp;gt;QueryInterface(IID_IDataInitialize, (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;**)&amp;amp;pIDataInitialize);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;创建IDataInitialize接口失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

hRes = pIDataInitialize-&amp;gt;GetInitializationString(pIDBInitialize, TRUE, &amp;amp;pConnStr);
COM_CHECK_SUCCESS(hRes, _T(&lt;span class=&quot;st&quot;&gt;&quot;获取连接字串失败失败:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08x\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), hRes);

COM_PRINTF(_T(&lt;span class=&quot;st&quot;&gt;&quot;连接字符串:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;), pConnStr);
SysAllocString(pConnStr);
__CLEAN_UP:
SAFE_RELEASE(pIDataInitialize);
SAFE_RELEASE(pIDBInitialize);
SAFE_RELEASE(pIDBPromptInitialize);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;为了节约篇幅，这些笔记内容只会列举部分关键的代码，至完整的代码我会随着博客内容的进度慢慢上传到GitHub项目中，并在博文的最末尾给出对应文件的地址&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/aMonst/OLEDB_Demo/blob/master/ConnectDB.cpp&quot;&gt;本次代码地址1&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/aMonst/OLEDB_Demo/blob/master/DataSource.cpp&quot;&gt;本次代码地址2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 12 Jan 2018 15:41:00 +0000</pubDate>
<dc:creator>GunLun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanuage/p/8278087.html</dc:identifier>
</item>
<item>
<title>【ASP.NET 系列】浅谈缓存技术在ASP.NET中的运用 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8271403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8271403.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110033829004-2140333139.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章虽不谈架构，但是Cache又是架构中不可或缺的部分，因此，在讲解Cache的同时，将会提及到部分架构知识，关于架构部分，读者可以不用理解，或者直接跳过，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你只需关心Cache即可，具体的架构，会在后续文章中与大家分享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一   为什么要在ASP.NET 项目中引入缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 我们先来考虑一个问题，通常，面临高并发问题时，我们应该怎么处理？&lt;/p&gt;
&lt;p&gt;下图为常规的处理思路和方法&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112225929254-1826453911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.为什么引入Cache呢？&lt;/p&gt;
&lt;p&gt;        我们知道，造成高并发的根本原因是大量读写的问题，一般地，对于一个系统，读总是比写多，如我们总是逛淘宝，京东，天猫，唯品会等，但我们并不一定买东西（买东西，即下单，下单的操作，对应DB的Write操作），缓存主要解决都的问题（当然，在后期的文章中，我会讲到消息队列MQ，也是一种缓存机制，其不仅仅解决都得问题，还解决写的问题）。&lt;/p&gt;
&lt;p&gt;        很好，我们知道缓存主要解决读的问题，那么，我们读的东西很多，是不是缓存所有读的内容呢？答案是否定的。缓存主要解决那些高频访问，吃服务器资源，实时性要求比较低，不常更新的内容。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二   ASP.NET 缓存技术概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;（一）ASP.NET缓存技术种类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ASP.NET实际项目开发中，我们可以采取基本的三种缓存技术：页面缓存、局部页面和数据缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112015859019-13930935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;1.整页缓存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  所谓整页缓存，指缓存整个页面，且设置刷新间隔时间，刷新间隔时间一般以秒为单位（缓存不能全部刷新，且刷新间隔不依赖外部事件）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.部分页面缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   所谓部分页面缓存，也叫局部页面缓存，指通过设定影响页面的参数，此时的缓存存储页面的多个版本，一般情况需要按照参数值为这些页面版本设置索引；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.运用程序缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   所谓运用程序缓存，也叫数据缓存，指将需要大量服务器资源的对象存储在内存中，在ASP.NET中，由Cache类来实现（Cache类的每个实例对应具体的每个运用程序，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其生存期依赖于运用程序的生存期，当然，如果系统重启或者断电，则另当别论。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（二）二级缓存技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在ASP.NET一般的项目中，我们采用二级缓存就可以解决服务器缓存问题了，如下为二级缓存的轮廓图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112032109082-519775954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.何为一级缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   一级缓存，指不借助于外部缓存的缓存，上图中的二级缓存去掉外部缓存部分即为一级缓存；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.组成：由Web服务器、数据库服务器和二级缓存系统构成；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.请求-处理流程：对于都数据，采用从内向外的顺序：内部缓存=》外部缓存=》数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    (1)首次请求读数据：蓝色的箭头表示首次请求，从数据库服务器DB中取得数据，并将数据缓存在二级缓存系统中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    (2)非首次请求读数据：先从二级缓存内部缓存中取数据显示页面，如果没有数据，则去二级缓存外部缓存中取数据显示页面，若外部缓存中没有数据，则再去数据库服务器中取数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112031124394-1557879729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;(4)对于写数据，才有从外向内顺序：数据库=》外部缓存=》内部缓存（这样做的目的，主要是维护数据的一致性）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.构成二级缓存系统的外部缓存系统，一般我们可选择MongoDB,Redis,Mencached等;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.基于SOA+Redis的的一般系统架构(当然，本片文章不谈架构，因此不会分析架构，但会在后续的文章中单独讲解架构)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112030205910-1321486861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;6.如何保证数据的一致性？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  对于读数据，采用从内向外的顺序；对于写数据，采用从外向内的顺序；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 7.缓存的有效期？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们以Memcached做外部缓存为例，我对于ASP.NET内部缓存，我们会担心内存不够用，而对于Memcached，则可以不用担心内存不够用的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    采用二级缓存方案，Memcaches缓存与ASP.NET缓存都要进行严格的管理和控制，因为Memcached工作在外层，直接对数据库中的数据进行读取，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;且他的内存空间一般较大，故它的缓存数据有效期应该根据缓存数据在运用中的实际缓存有效期来设定，不会受到内部不足而被释放的影响，而ASP.NET&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存工作在内层，直接与运用程序中的数据进行交互，且ASP.NET框架对自身缓存的内存空间有所限制，缓存空间过大会影响整个运用的性能，为了在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同的内存空间下缓存更多的数据，ASP.NET缓存的有效期应该小于或等于Memcached缓存的有效期，有效期具体多长时间视内存空间和运用程序访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;频率的高低而定，ASP.NET对同意缓存数据的有效期之和不能大于其在Memcached中的有效期，这样才能达到缓存数据的一致性，两个缓存的协同工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;，可以对运用程序的访问速度带啦很大的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）缓存涉及到的一些相关技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缓存是一门技术，不可能花较少的篇幅即可讲明白，如下简要列举一些Cache相关的技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112034014285-840301807.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;1.Cahe维护&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;维护网络上的，本地的Cache;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.路由策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的路由策略要根据Cache架构和设计来设定，大致讲解一下本地缓存路由策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112035710832-453790588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.替换算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.预取技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.Cache性能分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;借助一些性能分析工具来分析，主要关注命中率/缓存对象大小之间关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112040621301-1150966080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;6.过期策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合理设置过期间隙，一般以秒为单位；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.数据一致性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保证主从同步，读写数据的顺序等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.缓存级别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的级别，根据具体的业务需求来设定；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.Cache技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;磁盘缓存，存储器缓存，WWW服务器缓存等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.数据缓存技术&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 客户端数据缓存，分布式数据缓存，集中式数据缓存等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三   Cache在ASP.NET MVC中的运用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）整页缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.ASP.NET MVC中有哪些整页缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 整页缓存是一种比较简单且常用的缓存方式，缓存这个页面。在ASP.NET中，整页缓存一般包括控制器缓存，Action缓存，Web.config缓存等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.哪些页面需要整页缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 一般地，整页缓存页面具有“读取频繁，数据不常更新、编译时需要占用大量时间和资源”等特点；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.ASP.NET MVC中整页缓存的语法格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112214757191-412555397.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; (1)控制器缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器缓存指把缓存作用于控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; PageCacheController.cs&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CacheDemo.Controllers
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     [OutputCache(Duration = &lt;span&gt;70&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerCacheController : Controller
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Default&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ControllerCache()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt;             ViewBag.CurrentTime =&lt;span&gt; System.DateTime.Now;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PageCache.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ViewBag.Title = &quot;ControllerCache&quot;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ControllerCache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    ViewBag的值：@ViewBag.CurrentTime
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Result:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112205300051-466496545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(2)Action缓存&lt;/p&gt;
&lt;p&gt;Action缓存指把缓存作用于Action。控制方法缓存与控制器缓存原理差不多，只不过控制器缓存把缓存作用于控制器，控制器方法缓存把缓存作用于控制器方法。这里就不讲解了。&lt;/p&gt;
&lt;p&gt;(3)Web.config缓存&lt;/p&gt;
&lt;p&gt;Web.config缓存，有点类似于我们将数据库连接字符串添加在配置文件一样，看看下面的代码，是否很熟悉呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&quot;SqlserverConstr&quot; connectionString=&quot;Server=IP;db=DataBaseName;uid=UserName;pwd=Password&quot; providerName=&quot;System.Data.SqlClient&quot; /&amp;gt;
  &amp;lt;/connectionStrings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Web.config将需要缓存的Controller或Action提取抽象到配置文件中，其实就相当于我们使用数据库连接字符串，使用时，调用即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;system.web&amp;gt;
    &amp;lt;caching&amp;gt;
      &amp;lt;outputCacheSettings&amp;gt;
        &amp;lt;outputCacheProfiles&amp;gt;
          &amp;lt;add name =&quot;WebConfiCache&quot; duration=&quot;70&quot;/&amp;gt;
        &amp;lt;/outputCacheProfiles&amp;gt;
      &amp;lt;/outputCacheSettings&amp;gt;
    &amp;lt;/caching&amp;gt;
    &amp;lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.6.1&quot; /&amp;gt;
    &amp;lt;httpRuntime targetFramework=&quot;4.6.1&quot; /&amp;gt;
  &amp;lt;/system.web&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将上面的控制器缓存参数用Web.config来配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CacheDemo.Controllers
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[OutputCache(Duration = 70)]&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     [OutputCache(CacheProfile = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebConfiCache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerCacheController : Controller
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Default&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ControllerCache()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             ViewBag.CurrentTime =&lt;span&gt; System.DateTime.Now;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;其实相当简单，就当作数据库连接字符串来操作或者&amp;lt;appSetting&amp;gt;操作即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112211654707-432577428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （3）缓存依赖&lt;/p&gt;
&lt;p&gt;留给读者朋友们去研究，比较简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）部分页面缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 部分页面缓存，也叫页面部分缓存，主要解决在页面缓存中需要经常实时更新的一部分内容。&lt;/p&gt;
&lt;p&gt; 页面部分缓存就是缓存页面的一部分，而不是缓存整个页面，它适用于页面内某些部分可能需要更新的数据的情况，在常用页面部分缓存的技术下经常采用先将整个页面缓存，然后再替换页面中不需要缓存的部分。(用AJAX局部刷新来理解)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）运用程序缓存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;运用程序缓存是用来存储与运用程序有关的对象，主要由Cache类来实现（命名空间System.Web.Caching），可以以编码的方式灵活地控制缓存的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180112222139066-1292018943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四   版权区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:08:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8271403.html</dc:identifier>
</item>
<item>
<title>SQL Server-聚焦sp_executesql执行动态SQL查询性能真的比exec好？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8277713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8277713.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;之前我们已经讨论过动态SQL查询呢？这里为何再来探讨一番呢？因为其中还是存在一定问题，如标题所言，很多面试题也好或者有些博客也好都在说在执行动态SQL查询时sp_executesql的性能比exec好，但是事实真是如此？下面我们来一探究竟。&lt;/p&gt;
&lt;h2&gt;探讨sp_executesql和exec执行动态SQL查询性能&lt;/h2&gt;
&lt;p&gt; 首先我们创建如下测试表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; dbo.TestDynamicSQL
    (
      Col1 &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; ,
      Col2 &lt;/span&gt;&lt;span&gt;SMALLINT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; ,
      CreatedTime &lt;/span&gt;&lt;span&gt;DATETIME&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;GETDATE&lt;/span&gt;&lt;span&gt;() ,
      OtherValue &lt;/span&gt;&lt;span&gt;CHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    )
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着再来插入数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INSERT&lt;/span&gt;&lt;span&gt;  dbo.TestDynamicSQL
        ( Col1,
          Col2
        )
        &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;number&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt; ,
                &lt;/span&gt;&lt;span&gt;number&lt;/span&gt;
        &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    master..spt_values
        &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   type &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终查询为如下测试数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112212913301-1354551394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们执行如下两个SQL查询语句，执行4次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    dbo.TestDynamicSQL
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   Col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; Col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    dbo.TestDynamicSQL
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   Col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; Col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着我们通过如下SQL语句来查询缓存计划。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  q.&lt;span&gt;text&lt;/span&gt;&lt;span&gt; ,
        cp.usecounts ,
        cp.objtype ,
        p.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; ,
        q.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; ,
        cp.plan_handle
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;    sys.dm_exec_cached_plans cp
        &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt;&lt;span&gt; APPLY sys.dm_exec_query_plan(cp.plan_handle) p
        &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; APPLY sys.dm_exec_sql_text(cp.plan_handle) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; q
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;   cp.cacheobjtype &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Compiled Plan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; q.&lt;span&gt;text&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%dbo.TestDynamicSQL%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;AND&lt;/span&gt; q.&lt;span&gt;text&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%sys.dm_exec_cached_plans %&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112213336644-1611930703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可知，我们看到存在两个查询计划且每个执行了4次，也就是说每一次查询都会重新生成一个新的计划。清除查询计划缓存，通过如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DBCC&lt;/span&gt; FREEPROCCACHE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续往下走，我们接下来通过EXEC来执行动态SQL查询，如下，执行查询完毕后再来看看查询计划次数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@SQL&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@SQL&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112213940722-1704775525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就不做过多解释，我们依然要清除查询计划缓存，我们再利用sp_executesql来查询，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;24&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;
&lt;span&gt;Go&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col2&lt;/span&gt;) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
and Col1 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;@Col1&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112214222504-1395004764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比exec执行动态SQL查询得到的结果是一模一样，正如我所演示的，我们有两个计划，每个执行次数为4。不是说sp_executesql执行动态SQL查询会重用计划缓存么，这是因为我们没有正确使用sp_executesql所以导致SQL引擎无法重用计划。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;当参数值改变为语句是唯一变化时，可以使用sp_executesql代替存储过程多次执行Transact-SQL语句。 因为Transact-SQL语句本身保持不变，只有参数值发生变化，因此SQL Server查询优化器可能会重用为第一次执行生成的执行计划。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是正确参数化的查询方式，我们在字符串里面有一些变量，在执行的时候，我们通过其他变量传递值给它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = @InnerCol2 and Col1 = @InnerCol1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerCol2 smallint ,@InnerCol1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

 
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = @InnerCol2 and Col1 = @InnerCol1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerCol2 smallint ,@InnerCol1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
 
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112215941426-622205865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到只有一个计数为8的计划，而不是像我们上述那样运行查询。 我们也可以只需要声明一次，然后我们只需要在执行之前更改参数的值，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;SMALLINT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;
 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from dbo.TestDynamicSQL
where Col2 = @InnerCol2 and Col1 = @InnerCol1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
 
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@ParmDefinition&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerCol2 smallint ,@InnerCol1 int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
 
 
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;
 
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;change param values and run the same query&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Col2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt; ,
        &lt;/span&gt;&lt;span&gt;@Col1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql &lt;span&gt;@SQL&lt;/span&gt;, &lt;span&gt;@ParmDefinition&lt;/span&gt;, &lt;span&gt;@InnerCol2&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;@InnerCol1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Col1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终查询计划缓存次数和上述正确方式一致。正确使用sp_executesql对于性能非常有利，而且使用sp_executesql还可以为我们提供一些EXEC无法实现的功能。比如如何得到一个表中的行数？ 利用EXEC我们需要使用一个临时表和填充，而用sp_executesql我们只需要使用一个输出变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; IO &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; TIME &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;EXEC (SQL)&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Totalcount&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;&lt;span&gt; ,
    &lt;/span&gt;&lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
 
 
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; #&lt;span&gt;temp&lt;/span&gt; (Totalcount &lt;span&gt;INT&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Insert into #temp Select Count(*) from dbo.TestDynamicSQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;EXEC&lt;/span&gt;( &lt;span&gt;@SQL&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Totalcount&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; Totalcount
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;    #&lt;span&gt;temp&lt;/span&gt;
 
&lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@Totalcount&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; Totalcount
 
&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; #&lt;span&gt;temp&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
 

&lt;span&gt;--&lt;/span&gt;&lt;span&gt;sp_executesql&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TableCount&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@SQL&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT @InnerTableCount = COUNT(*) FROM  dbo.TestDynamicSQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;EXEC&lt;/span&gt; SP_EXECUTESQL &lt;span&gt;@SQL&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@InnerTableCount INT OUTPUT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@TableCount&lt;/span&gt;&lt;span&gt; OUTPUT
 
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@TableCount&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201801/589642-20180112221423191-641697760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然除了EXEC无法实现的功能外，最重要的一点则是SP_EXECUTESQL能够防止SQL注入问题。 &lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;执行SQL动态查询SP_EXECUTESQL比EXEC性能更好的存储过程能够被重用，但是存储过程能够被重用的前提则是正确使用参数，使用参数化查询，否则SP_EXECUTESQL将不会提供任何性能益处。&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:07:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8277713.html</dc:identifier>
</item>
<item>
<title>GO开发[一]：golang开发初探 - 宁生信</title>
<link>http://www.cnblogs.com/gregoryli/p/8278019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gregoryli/p/8278019.html</guid>
<description>&lt;p&gt;&lt;span&gt;一.Golang的安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.https://dl.gocn.io/ （国内下载地址）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112221343613-1630022180.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.https://golang.org/dl/ （国外下载地址）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112232832707-6725384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.现在studygolang中文网也可以了https://studygolang.com/dl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载版本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mac darwin-adm64.tar.gz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;linux amd64.tar.gz&lt;/span&gt;&lt;br/&gt;&lt;span&gt;windows amd64.msi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.window编辑器 &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;atom配合go-plus插件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;sublime配合gosublime插件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;emacs + spacemacs配置（相对来说比较麻烦，也是mac的一个不错的选择.）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Goland JetBrains&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　直接安装的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222901644-1164871321.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Windows推荐goland &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222424191-744545265.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222804566-1597214610.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1230529/201801/1230529-20180112222813488-1883081446.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二 、Ubuntu安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apt install golang-&lt;span&gt;go
root@greg:&lt;/span&gt;&lt;span&gt;# go env
GOARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOBIN&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOEXE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTARCH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOHOSTOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOOS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GORACE&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/lib/go-1.7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOTOOLDIR&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/lib/go-1.7/pkg/tool/linux_amd64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CC&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
GOGCCFLAGS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build765188684=/tmp/go-build -gno-record-gcc-switches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CXX&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;g++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CGO_ENABLED&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;默认安装了1.7，可以自定义更新到最新版1.9&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;root@greg:/usr/local/src/go1.&lt;span&gt;9.2&lt;/span&gt;/src# ./&lt;span&gt;make.bash
##### Building Go bootstrap tool.
cmd&lt;/span&gt;/&lt;span&gt;dist
ERROR: Cannot find &lt;/span&gt;/root/go1.&lt;span&gt;4&lt;/span&gt;/bin/&lt;span&gt;go.
Set $GOROOT_BOOTSTRAP to a working Go tree &lt;/span&gt;&amp;gt;= Go &lt;span&gt;1.4&lt;/span&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;报错了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决：export GOROOT_BOOTSTRAP=/usr/lib/go-1.7&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;初始化环境

    GOROOT放置go的标准库和工具链
        $HOME&lt;/span&gt;/local/&lt;span&gt;go (linux,mac)
        c:\local\go (windows)

    GOPATH放置第三方代码和自己的工程
        $HOME&lt;/span&gt;/&lt;span&gt;go(linux,mac)
        c:\go(windows)
        
    PATH
        export PATH&lt;/span&gt;=$GOROOT/bin:$GOPATH/&lt;span&gt;bin:$PATH
        
        

    vim &lt;/span&gt;~/&lt;span&gt;.bashrc
        export GOROOT&lt;/span&gt;=$HOME/local/&lt;span&gt;go
        export GOPATH&lt;/span&gt;=$HOME/&lt;span&gt;go
        export PATH&lt;/span&gt;=$GOROOT/bin:$GOPATH/&lt;span&gt;bin:$PATH


    我的Ubuntu是这样的
        GOPATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        GOROOT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/local/src/go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        export PATH&lt;/span&gt;=$GOROOT/bin:$GOPATH/bin:$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 三、golang特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 天然并发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在单核时代：一个线程就能把CPU跑满，没必要多个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多核：内存操作、io操作，可以多线程，多进程的流畅执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nginx：多进程架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;redis：单进程单线程，单进程只能跑满一个cpu，目前服务器大部分多于8核，redis一个机器上跑个6/7个，榨干cpu&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;go 天然支持并发，跑一个进程就能使用7/8个核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C++和Java线程是重量级线程，高并发--&amp;gt;线程池，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;纯内存：8核8线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;go降低研发成本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;goroute，轻量级线程，创建成千上万个goroute成为可能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.垃圾回收&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存自动回收，不需要开发人员管理内存&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开发人员专注业务实现，降低了心智负担&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要new分配内存，不需要释放&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. channel&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管道，类似unix/linux中的pipe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个goroute之间通过channel进行通信&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持任何类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多返回值，一个函数返回多个值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四.go第一个程序&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package main

import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fmt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

func main(){
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello golang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;五.运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 1.&lt;span&gt;编译运行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;
    go build hello.go
    ll
        &lt;/span&gt;-rwxr-xr-x  &lt;span&gt;1&lt;/span&gt; greg greg &lt;span&gt;1859967&lt;/span&gt; 12月 &lt;span&gt;23&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;29&lt;/span&gt; hello*
        -rw-r--r--  &lt;span&gt;1&lt;/span&gt; greg greg      &lt;span&gt;75&lt;/span&gt; 12月 &lt;span&gt;23&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;&lt;span&gt; hello.go


    greg@greg:&lt;/span&gt;~/go$ ./&lt;span&gt;hello
    hello golang&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;  跟go没有关系了，脱离了go&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
greg@greg:~/&lt;span&gt;go$ file hello
hello: ELF &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-bit LSB executable, x86-&lt;span&gt;64&lt;/span&gt;, version &lt;span&gt;1&lt;/span&gt; (SYSV), statically linked, not stripped
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;2.go run hello.go&lt;br/&gt;3.各个版本的编译&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;把mac编程Linux程序
    file hello.lua
    go build hello.go
    
    GOOS&lt;/span&gt;=&lt;span&gt;linux go build hello.go
    GOOS&lt;/span&gt;=&lt;span&gt;windows go build hello.go
    GOOS&lt;/span&gt;=&lt;span&gt;darwin go build hello.go
    
GOOS&lt;/span&gt;=linux go build -&lt;span&gt;o hello.linux hello.go
GOOS&lt;/span&gt;=windows go build -&lt;span&gt;o hello.exe hello.go
GOOS&lt;/span&gt;=darwin go build -&lt;span&gt;o hello.mac hello.go


greg@greg:&lt;/span&gt;~/&lt;span&gt;go$ file hello.mac 
hello.mac: Mach&lt;/span&gt;-O &lt;span&gt;64&lt;/span&gt;-bit x86_64 executable, flags:&amp;lt;NOUNDEFS&amp;gt;&lt;span&gt;
greg@greg:&lt;/span&gt;~/go$ ./&lt;span&gt;hello.linux 
hello golang
greg@greg:&lt;/span&gt;~/&lt;span&gt;go$ file hello.exe 
hello.exe: PE32&lt;/span&gt;+ executable (console) x86-&lt;span&gt;64&lt;/span&gt; (stripped to external PDB), &lt;span&gt;for&lt;/span&gt;&lt;span&gt; MS Windows


&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; GOOS=&lt;span&gt;windows
go build hello.go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;六、go常用工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;gofmt -w hello.go代码完美&lt;/p&gt;
&lt;p&gt;goimports -w hello.go 没有包就加上，有多余的包就删除&lt;/p&gt;
&lt;p&gt;一键编译go build&lt;/p&gt;
&lt;p&gt;go build github.com/greg1617/ningxin&lt;/p&gt;
&lt;p&gt;一键测试：go test&lt;/p&gt;
&lt;p&gt;go test github.com/greg1617/ningxin&lt;/p&gt;
&lt;p&gt;一键下载更新依赖并编译go get&lt;/p&gt;
&lt;p&gt;go get github.com/greg1617/ningxin&lt;/p&gt;
&lt;p&gt;自动文档工具godoc&lt;/p&gt;
&lt;p&gt;godoc -http=:9090&lt;/p&gt;
&lt;p&gt;在线查看文档&lt;/p&gt;
&lt;p&gt;godoc.org/github.com/golang/protobuf/proto&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_11003&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>宁生信</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gregoryli/p/8278019.html</dc:identifier>
</item>
<item>
<title>CSS属性：背景属性（图文详解） - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8277895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8277895.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8277895.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;background系列属性&quot;&gt;background系列属性&lt;/h2&gt;
&lt;h3 id=&quot;常见背景属性&quot;&gt;常见背景属性&lt;/h3&gt;
&lt;p&gt;CSS样式中，常见的背景属性有以下几种：（经常用到，要记住）&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-color:#ff99ff;&lt;/code&gt; 设置元素的背景颜色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-image:url(images/2.gif);&lt;/code&gt; 将图像设置为背景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;background-repeat: no-repeat;&lt;/code&gt; 设置背景图片是否重复及如何重复，默认平铺满。（重要）
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no-repeat&lt;/code&gt;不要平铺；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-x&lt;/code&gt;横向平铺；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-y&lt;/code&gt;纵向平铺。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-position:center top;&lt;/code&gt; 设置背景图片在当前容器中的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;background-attachment:scroll;&lt;/code&gt; 设置背景图片是否跟着滚动条一起移动。&lt;br/&gt;属性值可以是：&lt;code&gt;scroll&lt;/code&gt;（背景图片不动）、&lt;code&gt;fixed&lt;/code&gt;（背景图片跟着滚动条一起移动）。注意属性值的含义不要搞反了，它的含义是根据滚动条来定义的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;另外还有一个简写属性叫做&lt;code&gt;background&lt;/code&gt;，它的作用是：将上面的多个属性写在一个声明中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这几个属性经常用到，需要记住。现在我们逐个进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;background-color背景颜色的表示方法&quot;&gt;background-color：背景颜色的表示方法&lt;/h3&gt;
&lt;p&gt;css2.1中，背景颜色的表示方法有三种：单词、rgb表示法、十六进制表示法。&lt;/p&gt;
&lt;p&gt;比如红色可以有下面的三种表示方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color: red;
    background-color: rgb(255,0,0);
    background-color: #ff0000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面分别介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、用英语单词来表示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能够用英语单词来表述的颜色，都是简单颜色。比如红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: red;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、rgb表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rgb表示三原色“红”red、“绿”green、“蓝”blue。&lt;/p&gt;
&lt;p&gt;光学显示器中，每个像素都是由三原色的发光原件组成的，靠明亮度不同调成不同的颜色的。r、g、b的值，每个值的取值范围0~255，一共256个值。&lt;/p&gt;
&lt;p&gt;比如红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: rgb(255,0,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;黑色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: rgb(0,0,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;颜色可以叠加，比如黄色就是红色和绿色的叠加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: rgb(255,255,0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、十六进制表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;background-color: #ff0000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS:所有用#开头的值，都是16进制的。&lt;/p&gt;
&lt;p&gt;这里，我们就要学会16进制与10进制之间的转换。下面举几个例子。&lt;/p&gt;
&lt;p&gt;问：16进制中28等于10进制多少？&lt;br/&gt;答：2*16+8 = 40。&lt;/p&gt;
&lt;p&gt;16进制中的af等于10进制多少？&lt;br/&gt;答：10 * 16 + 15 = 175&lt;/p&gt;
&lt;p&gt;所以，#ff0000就等于rgb(255,0,0)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;background-color: #123456;&lt;/code&gt;等价于&lt;code&gt;background-color: rgb(18,52,86);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;十六进制可以简化为3位，所有#aabbcc的形式，能够简化为#abc&lt;/strong&gt;。举例如下：&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#ff0000;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#f00;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#112233;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#123;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，比如下面这个是无法简化的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#222333;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如，下面这个也是无法简化的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:#123123;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几种常见的颜色简写可以记住。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #000   黑
    #fff   白
    #f00   红
    #222   深灰
    #333   灰
    #ccc   浅灰&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;background-repeat属性重要&quot;&gt;&lt;code&gt;background-repeat&lt;/code&gt;属性（重要）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;background-repeat:no-repeat;&lt;/code&gt;设置背景图片是否重复及如何重复，默认平铺满。属性值可以是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no-repeat&lt;/code&gt;（不要平铺）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-x&lt;/code&gt;（横向平铺）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat-y&lt;/code&gt;（纵向平铺）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个属性在开发的时候也是经常用到的。我们通过设置不同的属性值来看一下效果吧：&lt;/p&gt;
&lt;p&gt;（1）不加这个属性时：（即默认时）（背景图片会被平铺满）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：padding的区域也是有背景图的。&lt;/p&gt;
&lt;p&gt;（2）属性值为&lt;code&gt;no-repeat&lt;/code&gt;（不要平铺）时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-20.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）属性值为&lt;code&gt;repeat-x&lt;/code&gt;（横向平铺）时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-21.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这种属性的作用还是很广的。举个例子，设计师设计一张宽度只有1px、颜色纵向渐变的图片，然后我们通过这个属性将其进行水平方向的平铺，就可以看到整个页面都是渐变的了。&lt;/p&gt;
&lt;p&gt;在搜索引擎上搜“&lt;strong&gt;平铺背景&lt;/strong&gt;”，就可以发现，&lt;strong&gt;周期性的图片&lt;/strong&gt;可以采用此种方法进行平铺。&lt;/p&gt;
&lt;p&gt;（4）属性值为&lt;code&gt;repeat-y&lt;/code&gt;（纵向平铺）时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sby7r.com1.z0.glb.clouddn.com/2015-10-03-css-22.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;background-position属性&quot;&gt;&lt;code&gt;background-position&lt;/code&gt;属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;background-position&lt;/code&gt;属性指的是&lt;strong&gt;背景定位&lt;/strong&gt;属性。公式如下：&lt;/p&gt;
&lt;p&gt;在描述属性值的时候，有两种方式：用像素描述、用单词描述。下面分别介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、用像素值描述属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-position:向右偏移量 向下偏移量;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性值可以是正数，也可以是负数。比如：&lt;code&gt;100px 200px&lt;/code&gt;、&lt;code&gt;-50px -120px&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;举例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1643.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1645.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、用单词描述属性值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-position: 描述左右的词 描述上下的词;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;描述左右的词：left、center、right&lt;/li&gt;
&lt;li&gt;描述上下的词：top 、center、bottom&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如说，&lt;code&gt;right center&lt;/code&gt;表示将图片放到右边的中间；&lt;code&gt;center center&lt;/code&gt;表示将图片放到正中间。&lt;/p&gt;
&lt;p&gt;位置属性有很多使用场景的。我们来举两个例子。&lt;/p&gt;
&lt;p&gt;场景1：（大背景图）&lt;/p&gt;
&lt;p&gt;打开“暗黑3 台湾”的官网&lt;a href=&quot;https://tw.battle.net/d3/zh/&quot; class=&quot;uri&quot;&gt;https://tw.battle.net/d3/zh/&lt;/a&gt;，可以看到官网的效果是比较炫的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1945.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查网页后，找到网站背景图片的url：&lt;a href=&quot;https://tw.battle.net/d3/static/images/layout/bg-repeat.jpg&quot; class=&quot;uri&quot;&gt;https://tw.battle.net/d3/static/images/layout/bg-repeat.jpg&lt;/a&gt;。背景图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170812_1950.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，我们是通过把这张图片作为网站的背景图来达到显示效果的。只需要给body标签加如下属性即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        body{
            background-image: url(/Users/smyhvae/Dropbox/img/20170812_1950.jpg);
            background-repeat: no-repeat;
            background-position: center top;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，如果没加&lt;code&gt;background-position&lt;/code&gt;这个属性，背景图会默认处于浏览器的左上角（显得很丑）；加了此属性之后，图片在水平方向就位于浏览器的中间了。&lt;/p&gt;
&lt;p&gt;场景2：（通栏banner）&lt;/p&gt;
&lt;p&gt;很多网站的首页都会有banner图（网站最上方的全屏大图叫做「&lt;strong&gt;通栏banner&lt;/strong&gt;」），这种图要求横向的宽度特别大。比如说，设计师给你一张1920*465的超大banner图，如果我们把这个banner图作为img标签直接插入网页中，会有问题的：首先，图片不在网页的中间；其次，肯定会出现横向滚动条。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1102.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确的做法是，将banner图作为div的背景图，这样的话，背景图超出div的部分，会自动移溢出。需要给div设置的属性如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;        div&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;465px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-image:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;url(&lt;/span&gt;http://img&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;smyhvae&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;com/&lt;span class=&quot;dt&quot;&gt;20170813&lt;/span&gt;_1053&lt;span class=&quot;dt&quot;&gt;.&lt;/span&gt;jpg&lt;span class=&quot;dt&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-repeat:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;no-repeat&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方代码中，我们给div设置height（高度为banner图的高度），不需要设置宽度（因为宽度会自动霸占整行）。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1119.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看出，将banner图作为div的背景后，banner图会永远处于网页的正中间（水平方向来看）。&lt;/p&gt;
&lt;h3 id=&quot;background-attachment属性&quot;&gt;background-attachment属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;background-attachment:scroll;&lt;/code&gt; 设置背景图片是否固定。属性值可以是：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;fixed&lt;/code&gt;（背景就会被固定住，不会被滚动条滚走）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scroll&lt;/code&gt;（与fixed属性相反，默认属性）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;background-attachment:fixed;&lt;/code&gt;的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1158.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;background综合属性&quot;&gt;background综合属性&lt;/h3&gt;
&lt;p&gt;background属性和border一样，是一个综合属性，可以将多个属性写在一起。(在&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/7256371.html&quot;&gt;盒子模型&lt;/a&gt;这篇文章中专门讲到boder)&lt;/p&gt;
&lt;p&gt;举例1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background:red url(1.jpg) no-repeat 100px 100px fixed;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background-color:red;
    background-image:url(1.jpg);
    background-repeat:no-repeat;
    background-position:100px 100px;
    background-attachment:fixed;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以后，我们可以用小属性层叠掉大属性。&lt;/p&gt;
&lt;p&gt;上面的属性中，可以任意省略其中的一部分。&lt;/p&gt;
&lt;p&gt;比如说，对于下面这样的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    background: blue url(images/wuyifan.jpg) no-repeat 100px 100px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20170813_1515.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：以后的CSS3内容中，我们会接触到更多的background属性： background-origin、background-clip、background-size（在CSS2.1背景图片是不能调整尺寸，IE9开始兼容）、多背景。&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 12 Jan 2018 14:13:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8277895.html</dc:identifier>
</item>
<item>
<title>js上传图片 - 大兔兔</title>
<link>http://www.cnblogs.com/daijie/p/8277747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daijie/p/8277747.html</guid>
<description>&lt;p&gt;额    呆坐许久  感觉 有很多想写的  就是不知从何写起。。贼尴尬。  &lt;/p&gt;
&lt;p&gt;其实 我平时项目中 基本上传图片什么的  都是跟着from 表单 一起提交给后台的  &lt;/p&gt;
&lt;p&gt;实行起来 简单暴力  &lt;/p&gt;
&lt;p&gt;连图片预览的都没有写    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;其实 实行图片的预览功能 非常简单的&lt;/span&gt;&lt;/strong&gt;   比如 代码如下&lt;/p&gt;
&lt;p&gt;html 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='file' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;=&quot;multiple&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='img'  &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='img'  &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;='图片的预览'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fron&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js 代码&lt;/p&gt;
&lt;p&gt;需要先加载 jquery.js 哈  不然  会报错的 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js 预览 方法一   &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 这个是 在对象发生改变时触发  也就是对应的我们 选择完成图片后  会触发&lt;/span&gt;
 $(&quot;#pic&quot;).change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取图片对象数组 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; file=$(&quot;#pic&quot;)[0].files[0&lt;span&gt;];
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片生成blob额  这儿我也不知道叫什么  可以生成一个 本地的临时预览图片的字符串  &lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;暂且叫他 blob对象吧   有知道叫什么的大佬 记得留言告诉我哈  省得改天出门丢人了&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; blob=&lt;span&gt; window.URL.createObjectURL(file);
        $(&lt;/span&gt;&quot;#img&quot;).attr('src',blob);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将blob字符串 赋予给 img标签  即可完成图片的预览&lt;/span&gt;
&lt;span&gt;    })

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js 预览 方法二&lt;/span&gt;
&lt;span&gt;将file对象 转成 dataURL  进行预览   
 $(&lt;/span&gt;&quot;#pic&quot;).change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取图片对象数组 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; file=$(&quot;#pic&quot;)[0].files[0&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个。。好吧 我也不知道这个是叫什么对象  &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fr=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader();
        fr.readAsDataURL(file);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入图片对象 将其转成base64字符串&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个 onload是指的加载完毕的意思  在加载完毕后 将 转好的字符串给赋值给img标签&lt;/span&gt;
        fr.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            $(&lt;/span&gt;&quot;#img&quot;).attr('src',&lt;span&gt;this&lt;/span&gt;.result);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值 进行预览&lt;/span&gt;
&lt;span&gt;        }
    })    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面俩种方式  我更喜欢 blob 一些 &lt;/p&gt;
&lt;p&gt;blob    生成的预览地址  短   只能客户端 本地浏览  退出浏览器时 就会失效   （恩 好像是这样的）&lt;/p&gt;
&lt;p&gt;dataURL     生成的字符串比较长   但是 可以远程访问  或者 直接将这个字符串 发送给后台  返回 进行 base64解码  即可转回二进制  也就是图片数据  然后写出图片 &lt;/p&gt;

&lt;p&gt;图片的预览就说到这里了  不过 单单只是图片预览 那怎么能行   当然还得用js进行提交&lt;/p&gt;
&lt;p&gt;相对于 直接from的表单提交  js提交 有它非常显著的优势  &lt;/p&gt;
&lt;p&gt;1、 页面无需刷新  即可完成提交上传  返回上传状态  给用户良好的体验效果&lt;/p&gt;
&lt;p&gt;2、服务器不给力 或者 上传的图片过大时  会有较长的 等待时间  用js的话 可以做弹出loading 加载层  避免用户重复点击  重复的上传 也是非常利于用户体验度&lt;/p&gt;
&lt;p&gt;3、可以做循环单张上传  实时的告诉用户 上传了几张  还有几张待上传  &lt;/p&gt;
&lt;p&gt;反正就是用户体验度大大加强了&lt;/p&gt;

&lt;p&gt;ajax 提交上传图片demo&lt;/p&gt;
&lt;p&gt;HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='file' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;=&quot;multiple&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;='提交上传' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='sub()'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fron&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JS代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sub(){
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个。。额  参数对象吧  原谅我野路子出身 可以用来添加一些 表单参数的&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fromObj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取图片对象&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; files=$(&quot;#pic&quot;)[0&lt;span&gt;].files;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片对象 添加进待上传参数中&lt;/span&gt;
   fromObj.append('pic'&lt;span&gt;,files);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jquery 的ajax方法   也是我们常用的 前后台交互工具&lt;/span&gt;
&lt;span&gt;        $.ajax({
            url:&lt;/span&gt;'http://localhost/demo/farmer/app-main-pic',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传的路径&lt;/span&gt;
            type:'POST'&lt;span&gt;,
            data:fromObj,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传的方式&lt;/span&gt;
            contentType:&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是传图片则这俩项需要为false&lt;/span&gt;
            processData:&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是传图片则这俩项需要为false&lt;/span&gt;
            success:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
               console.log(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印页面返回的内容&lt;/span&gt;
&lt;span&gt;            }
        })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后端代码的话 就跟我们平常 接收表单上传的图片一样 &lt;/p&gt;
&lt;p&gt;比如 php的话  就是   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就可以查看 我们上传的图片信息了 &lt;/span&gt;
 &lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$_FILES&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在  我们就知道了 怎么js预览上传的图片  以及 用js进行上传图片了  但是仅仅这样 依然是达不到我们的理想效果 &lt;/p&gt;
&lt;p&gt;我们可能还会需要  对预览中的图片 进行 删除操作  图片传多了 不想上传某张图片了&lt;/p&gt;
&lt;p&gt;继续往下看代码吧    天太冷了  代码没怎么整理 仅做了点基础实现  样式优化的话 还得小伙伴们自己努力下哈&lt;/p&gt;
&lt;p&gt;HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;from &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;='file' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='pic' &lt;/span&gt;&lt;span&gt;multiple&lt;/span&gt;&lt;span&gt;=&quot;multiple&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;='提交上传' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='sub()'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;fron&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='show'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 因为有多张图片 所以不适合写死一个img标签了 这儿用来存放img &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这个用来 存img的样式的 没有用js去拼接字符串 直接写好样式后 用js进行 关键字替换 这样 以后修改样式也会毕竟方便 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;='display: &lt;/span&gt;&lt;span&gt;none' id&lt;/span&gt;&lt;span&gt;='jsText'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='{{url}}' &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='img' &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;='{{title}}' &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;='img' &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;='del(this)' &lt;/span&gt;&lt;span&gt;data-name&lt;/span&gt;&lt;span&gt;='{{name}}' &lt;/span&gt;&lt;span&gt;alt&lt;/span&gt;&lt;span&gt;='图片的预览'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JS代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个 存放上传的图片数据的对象  因为 file标签里面 第二次选择的图片 会覆盖掉 第一次的图片 所以 这个是有必要的&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ajax_files=&lt;span&gt;{};
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;预览图片&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    $(&lt;/span&gt;&quot;#pic&quot;).change(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js 获取图片对象 &lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; files=$(&quot;#pic&quot;)[0&lt;span&gt;].files;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取我们写好的img模板&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; text=$('#jsText'&lt;span&gt;).html();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环选中的图片&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;files.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否已经选择过该图片&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;ajax_files.hasOwnProperty(files[i].name)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建blob对象字符串&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; blob=&lt;span&gt; window.URL.createObjectURL(files[i]);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换img模板里面的关键字  其实和js的字符串拼接img代码 是一个意思&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; str=reload(text,{url:blob,title:files[i].name+' 【单击删除】'&lt;span&gt;,name:files[i].name});
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将拼接好的img 放入用于显示的div里面&lt;/span&gt;
                $('#show'&lt;span&gt;).append(str);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并将改图片数据 保存到全局的图片对象内&lt;/span&gt;
                ajax_files[files[i].name]=&lt;span&gt;files[i];
            }
        }
    })
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; del(obj){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图片本身&lt;/span&gt;
&lt;span&gt;        $(obj).remove();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name=$(obj).attr('data-name'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在全局图片对象中删除当前图片&lt;/span&gt;
        &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ajax_files[name];
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;js上传&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sub(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建参数对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; fromObj=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
        console.log(&lt;/span&gt;&quot;以下为待上传图片&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ajax_files){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在控制台打印待上传的图片数据&lt;/span&gt;
&lt;span&gt;            console.log(ajax_files[i].name,ajax_files[i].type,ajax_files[i].size);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片添加至待上传对象中&lt;/span&gt;
             fromObj.append('avatar[]'&lt;span&gt;,ajax_files[i]);
        }
        $.ajax({
            url:&lt;/span&gt;'http://localhost/demo/farmer/app-main-pic'&lt;span&gt;,
            type:&lt;/span&gt;'POST'&lt;span&gt;,
            data:fromObj,
            contentType:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是传图片则这俩项需要为false&lt;/span&gt;
            processData:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(e);&lt;/span&gt;
&lt;span&gt;            }
        })
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字符串替换&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; reload(text,data){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = &lt;span&gt;new&lt;/span&gt; RegExp('({{'+key+'}})','g'&lt;span&gt;);
            text&lt;/span&gt;=&lt;span&gt;text.replace(reg,data[key]);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; text;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无比丑陋的ui界面   一开始选择了4涨图片 不过  有删除了一张 再进行的上传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210608/201801/1210608-20180112211800551-1001623712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上就是本篇文章的全部代码了   首先感谢 小伙伴们耐心的看完了本文章  希望能对你有所帮助&lt;/p&gt;
&lt;p&gt;代码有什么错误 或者 不理解的地方 可以直接联系我哈   能解决的 会尽量帮忙解决哈&lt;/p&gt;

&lt;p&gt;那么。。。晚安了各位！！&lt;/p&gt;

&lt;p&gt; ------------------------该文章来自一只贼蠢贼蠢的程序员&lt;/p&gt;



</description>
<pubDate>Fri, 12 Jan 2018 13:21:00 +0000</pubDate>
<dc:creator>大兔兔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daijie/p/8277747.html</dc:identifier>
</item>
<item>
<title>ActiveMQ入门介绍 - 无涯Ⅱ</title>
<link>http://www.cnblogs.com/wlandwl/p/activemq.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlandwl/p/activemq.html</guid>
<description>&lt;h3&gt; 1.JMS简介&lt;/h3&gt;
&lt;p&gt;    JMS的全称是Java Message Service，即Java消息服务。它主要用于在生产者和消费者之间进行消息传递，生产者负责产生消息，而消费者负责接收消息。把它应用到实际的业务需求中可以在特定的时候利用生产者生成消息，并进行发送，对应的消费者在接收到对应的消息后去完成对应的业务逻辑。对于消息的传递有两种类型，一种是点对点的，即一个生产者和一个消费者一一对应；另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMS编程模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) ConnectionFactory&lt;/p&gt;
&lt;p&gt;    创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。&lt;/p&gt;
&lt;p&gt;(2) Destination&lt;/p&gt;
&lt;p&gt;    Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。&lt;/p&gt;
&lt;p&gt;(3) Connection&lt;/p&gt;
&lt;p&gt;    Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。&lt;/p&gt;
&lt;p&gt;(4) Session&lt;/p&gt;
&lt;p&gt;    Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。&lt;/p&gt;
&lt;p&gt;(5) 消息的生产者&lt;/p&gt;
&lt;p&gt;    消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。&lt;/p&gt;
&lt;p&gt;(6) 消息消费者&lt;/p&gt;
&lt;p&gt;    消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。&lt;/p&gt;
&lt;p&gt;(7) MessageListener&lt;/p&gt;
&lt;p&gt;    消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。&lt;/p&gt;
&lt;h3&gt; 2.ActiveMQ简介&lt;/h3&gt;
&lt;p&gt;    ActiveMQ是Apache软件基金下的一个开源软件，它遵循JMS规范（Java Message Service），是消息驱动中间件软件（MOM）。它为企业消息传递提供高可用，出色性能，可扩展，稳定和安全保障。ActiveMQ使用Apache许可协议。因此，任何人都可以使用和修改它而不必反馈任何改变。这对于商业上将ActiveMQ用在重要用途的人尤为关键。MOM的工作是在分布式的各应用之间调度事件和消息，使之到达指定的接收者。所以高可用，高性能，高可扩展性尤为关键。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ActiveMQ特性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    ⒈支持多种语言客户端,如:Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议有 OpenWire,Stomp REST,WS Notification,XMPP,AMQP。&lt;/p&gt;
&lt;p&gt;    ⒉ 完全支持JMS1.1和J2EE1.4规范,它们包括同步和异步消息传递，一次和只有一次的消息传递，对于预订者的持久消息等。依附于JMS规范意味着，不论JMS消息提供者是谁，同样的基本特性（持久化，XA消息，事务)都是有效的。&lt;/p&gt;
&lt;p&gt;    ⒊ 对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去。&lt;/p&gt;
&lt;p&gt;    ⒋ 通过了常见J2EE服务器（如 Geronimo,JBoss 4,GlassFish,WebLogic)的测试，其中通过JCA 1.5 resource adaptors的配置，可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上。&lt;/p&gt;
&lt;p&gt;    ⒌ ActiveMQ提供各种连接选择，包括HTTP，HTTPS，IP多点传送，SSL，STOMP，TCP，UDP，XMPP等。大量的连接协议支持使之具有更好的灵活性。很多现有的系统使用一种特定协议并且不能改变，所以一个支持多种协议的消息平台降低了使用的门槛。虽然连接很重要，但是和其他容器集成也同样重要。&lt;/p&gt;
&lt;p&gt;    6.ActiveMQ提供多种持久性方案可供选择，也可以完全按自己需求定制验证和授权。例如，ActiveMQ通过KahaDB提供自己的超快速消息持久方案（ultra-fast message persistence），但也支持标准的JDBC方案。ActiveMQ可以通过配置文件提供简单的验证和授权，也提供标准的JAAS登陆模块。&lt;/p&gt;
&lt;p&gt;    7.ActiveMQ是为开发者设计的。它并不需要专门的管理工具，因为它提供各种易用且强大的管理特性。有很多方法去监控ActiveMQ的各个方面，可以通过JMX使用JConsole或ActiveMQ web console；可以运行ActiveMQ消息报告；可以用命令行脚本；可以通过日志。&lt;/p&gt;
&lt;p&gt;    8.代理器集群（Broker clustering）----为了利于扩展，多个ActiveMQ broker能够联合工作。这个方式就是network of brokers并且能支持多种拓扑结构;支持客户端-服务器，点对点。&lt;/p&gt;
&lt;p&gt;    9.支持Ajax, 支持与Axis的整合&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ActiveMQ优势&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    1.与OpenJMS、JbossMQ等开源jms provider相比，ActiveMQ有Apache的支持，持续发展的优势明显。&lt;/p&gt;
&lt;p&gt;    2.消息处理速度很快&lt;/p&gt;
&lt;p&gt;    3.提高系统资源的利用率，主要是任务的派发不是24小时平均的，而是高峰时期任务量很多，比如1秒1000多个，有的时候很低，比如十几秒钟才来一个。应用服务通过JMS队列一个一个的取任务，做完一个再领一个，使系统资源的运用趋于平均。比如ActiveMQ在赛扬（2.40GHz）机器上能够达到2000/s，消息大小为1-2k。好一些的服务器可以达到2万以上/秒。&lt;/p&gt;
&lt;h3&gt; 3.ActiveMQ安装&lt;/h3&gt;
&lt;p&gt;    ActiveMQ在linux服务上安装操作如下：&lt;/p&gt;
&lt;p&gt;    1.在官网下载activemq安装文件。地址：&lt;a href=&quot;http://activemq.apache.org/download.html&quot; target=&quot;_blank&quot;&gt;http://activemq.apache.org/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    2.上传下载的tar.gz安装文件到linux服务器上，并解压到指定目录：如 tar -xf apache-activemq-5.15.2-bin.tar.gz&lt;/p&gt;
&lt;p&gt;    3.运行activemq，进入到解压的 apache-activemq-5.15.2/bin目录，执行命令：activemq start&lt;/p&gt;
&lt;p&gt;    4.开放端口8161，61616，保证端口可访问。&lt;/p&gt;
&lt;p&gt;   运行activemq截图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111214446472-1994868127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 本机访问启动成功的activemq截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111214502285-1679284127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 4.ActiveMQ类别及开发流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;   1)、Point-to-Point (点对点)消息模式开发流程&lt;/strong&gt;&lt;br/&gt;       1、生产者（producer）开发流程： &lt;/p&gt;
&lt;p&gt;         1.1 创建Connection： 根据url，user和password创建一个jms Connection。 &lt;/p&gt;
&lt;p&gt;         1.2 创建Session： 在connection的基础上创建一个session，同时设置是否支持事务和ACKNOWLEDGE标识。 &lt;/p&gt;
&lt;p&gt;         1.3 创建Destination对象： 需指定其对应的主题（subject）名称，producer和consumer将根据subject来发送/接收对应的消息。 &lt;/p&gt;
&lt;p&gt;         1.4 创建MessageProducer： 根据Destination创建MessageProducer对象，同时设置其持久模式。 &lt;/p&gt;
&lt;p&gt;         1.5 发送消息到队列（Queue）： 封装Message消息，使用MessageProducer的send方法将消息发送出去。 &lt;/p&gt;
&lt;p&gt;       2、消费者（consumer）开发流程： &lt;/p&gt;
&lt;p&gt;         2.1 实现MessageListener接口： 消费者类必须实现MessageListener接口，然后在onMessage()方法中监听消息的到达并处理。 &lt;/p&gt;
&lt;p&gt;         2.2 创建Connection： 根据url，user和password创建一个jms Connection，如果是durable模式，还需要给connection设置一个clientId。 &lt;/p&gt;
&lt;p&gt;         2.3 创建Session和Destination： 与ProducerTool.java中的流程类似，不再赘述。 &lt;/p&gt;
&lt;p&gt;         2.4 创建replyProducer【可选】：可以用来将消息处理结果发送给producer。 &lt;/p&gt;
&lt;p&gt;         2.5 创建MessageConsumer：  根据Destination创建MessageConsumer对象。 &lt;/p&gt;
&lt;p&gt;         2.6 消费message：  在onMessage()方法中接收producer发送过来的消息进行处理，并可以通过replyProducer反馈信息给producer &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   样例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在消息生产者中定义一个队列，destination_request,提供消息，同时定义一个监听消息的队列拥有接受消费者回复的消息，destination_response。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_653e5702-903d-4db6-bc38-2e720d6eb501&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_653e5702-903d-4db6-bc38-2e720d6eb501&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_653e5702-903d-4db6-bc38-2e720d6eb501&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.Email;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.TestMqBean;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.service.ProducerService;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerSendTest {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        ConnectionFactory connectionFactory;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        Connection connection;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        Session session;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        Destination destination_request,destination_response;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        MessageProducer producer;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        MessageConsumer consumer;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            connection.start();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数是是否是事务型消息，设置为true,第二个参数无效
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数是
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Session.AUTO_ACKNOWLEDGE为自动确认，客户端发送和接收消息不需要做额外的工作。异常也会确认消息，应该是在执行之前确认的
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Session.CLIENT_ACKNOWLEDGE为客户端确认。客户端接收到消息后，必须调用javax.jms.Message的acknowledge方法。jms服务器才会删除消息。可以在失败的
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时候不确认消息,不确认的话不会移出队列，一直存在，下次启动继续接受。接收消息的连接不断开，其他的消费者也不会接受（正常情况下队列模式不存在其他消费者）
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DUPS_OK_ACKNOWLEDGE允许副本的确认模式。一旦接收方应用程序的方法调用从处理消息处返回，会话对象就会确认消息的接收；而且允许重复确认。在需要考虑资源使用时，这种模式非常有效。
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待测试&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             session = connection.createSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, Session.CLIENT_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             destination_request = session.createQueue(&quot;request-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             destination_response = session.createQueue(&quot;response-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             producer =&lt;span&gt; session.createProducer(destination_request);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             consumer =&lt;span&gt; session.createConsumer(destination_response);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;优先级不能影响先进先出。。。那这个用处究竟是什么呢呢呢呢&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             TestMqBean bean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestMqBean();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             bean.setAge(13&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 bean.setName(&quot;send to data -&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                producer.send(session.createObjectMessage(bean));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            producer.close();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             System.out.println(&quot;消息发送成功...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; message) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                             TextMessage textMsg =&lt;span&gt; (TextMessage) message;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                             System.out.println(&quot;收到回馈消息&quot; +&lt;span&gt;textMsg.getText());
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    在消息消费者中定义一个队列，destination_request,用于接受消息，同时定义一个回复收到消息的队列回复生产者已经收到消息，destination_response。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_28ab27d0-a564-403a-967c-7c9738fbc935&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_28ab27d0-a564-403a-967c-7c9738fbc935&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_28ab27d0-a564-403a-967c-7c9738fbc935&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.TestMqBean;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerReceiveTest {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        ConnectionFactory connectionFactory;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection ：JMS 客户端到JMS Provider 的连接&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Connection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Session： 一个发送或接收消息的线程&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Session session;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destination ：消息的目的地;消息发送给谁.&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        Destination destination_request,destination_response;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费者，消息接收者&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        MessageConsumer consumer;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回复接收到的消息&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageProducer producer;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         connectionFactory = &lt;span&gt;new&lt;/span&gt; ActiveMQConnectionFactory(&quot;admin&quot;, &quot;admin&quot;, &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造从工厂得到连接对象&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            connection.start();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取操作连接
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个最好还是有事务&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             session =&lt;span&gt; connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取session注意参数值xingbo.xu-queue是一个服务器的queue，须在在ActiveMq的console配置&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             destination_request = session.createQueue(&quot;request-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             destination_response = session.createQueue(&quot;response-queue&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             consumer =&lt;span&gt; session.createConsumer(destination_request);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             producer=&lt;span&gt; session.createProducer(destination_response);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageListener() {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         TestMqBean bean =&lt;span&gt; (TestMqBean) ((ObjectMessage) message).getObject();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                        System.out.println(bean);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; message) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                             System.out.println(&quot;收到消息&quot; +&lt;span&gt; bean.getName());
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                             Message textMessage = session.createTextMessage(&quot;已经成功收到消息，现在开始回复&quot;+&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toString());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                            producer.send(textMessage);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    消息消费者收到消息，并打印出来，同时发送回复消息。截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111212654957-1210408589.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    消息生产者生产消息，同时接受到消费者回复的消息并打印出来。截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111212731051-2120619361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   2)、Publisher/Subscriber(发布/订阅者)消息模式开发流程 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       1、订阅者（Subscriber）开发流程： &lt;/p&gt;
&lt;p&gt;         1.1 实现MessageListener接口： 在onMessage()方法中监听发布者发出的消息队列，并做相应处理。 &lt;/p&gt;
&lt;p&gt;         1.2 创建Connection： 根据url，user和password创建一个jms Connection。 &lt;/p&gt;
&lt;p&gt;         1.3 创建Session： 在connection的基础上创建一个session，同时设置是否支持事务和ACKNOWLEDGE标识。 &lt;/p&gt;
&lt;p&gt;          1.4 创建Topic：  创建2个Topic， topictest.messages用于接收发布者发出的消息，topictest.control 用于向发布者发送消息，实现双方的交互。 &lt;/p&gt;
&lt;p&gt;         1.5 创建consumer和producer对象：根据topictest.messages创建consumer，根据topictest.control创建 producer。 &lt;/p&gt;
&lt;p&gt;         1.6 接收处理消息：在onMessage()方法中，对收到的消息进行处理，可直接简单在本地显示消息，或者根据消息内容不同处理对应的业务逻辑（比如：数据库更新、文件操作等等），并且可以使用producer对象将处理结果返回给发布者。 &lt;/p&gt;
&lt;p&gt;       2、发布者（Publisher）开发流程：&lt;/p&gt;
&lt;p&gt;         2.1 实现MessageListener接口：在onMessage()方法中接收订阅者的反馈消息。 &lt;/p&gt;
&lt;p&gt;         2.2 创建Connection： 根据url，user和password创建一个jms Connection。 &lt;/p&gt;
&lt;p&gt;         2.3 创建Session： 在connection的基础上创建一个session，同时设置是否支持事务和ACKNOWLEDGE标识。 &lt;/p&gt;
&lt;p&gt;         2.4 创建Topic： 创建2个Topic，topictest.messages用于向订阅者发布消息，topictest.control用于接 收订阅者反馈的消息。这2个topic与订阅者开发流程中的topic是一一对应的。 &lt;/p&gt;
&lt;p&gt;         2.5 创建consumer和producer对象： 根据topictest.messages创建publisher； 根据topictest.control 创建consumer，同时监听订阅者反馈的消息。&lt;/p&gt;
&lt;p&gt;         2.6 给所有订阅者发送消息，并接收反馈消息。 注：可同时运行多个订阅者测试查看此模式效果 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   样例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    消息发布者发布消息，定义一个主题example.A&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_3653d8e4-e8ec-427e-a68d-9dac06152380&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3653d8e4-e8ec-427e-a68d-9dac06152380&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3653d8e4-e8ec-427e-a68d-9dac06152380&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.entity.TestMqBean;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicProducerSendTest {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String user = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String password = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String url = &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConnectionFactory ：连接工厂，JMS 用它创建连接&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveMQConnectionFactory(user,password,url);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection ：JMS 客户端到JMS Provider 的连接&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         Connection connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection 启动&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        connection.start();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.println(&quot;Connection is start...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Session： 一个发送或接收消息的线程&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Session session =&lt;span&gt; connection.createSession(Boolean.TRUE,Session.AUTO_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Topicr ：消息的目的地;消息发送给谁.&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         Topic  destination = session.createTopic(&quot;example.A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MessageProducer：消息发送者&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         MessageProducer producer =&lt;span&gt; session.createProducer(destination);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不持久化，此处学习，实际根据项目决定&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        producer.setDeliveryMode(DeliveryMode.PERSISTENT);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造消息，此处写死，项目就是参数，或者方法获取&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        sendMessage(session, producer);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        session.commit();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        connection.close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         System.out.println(&quot;send text ok.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMessage(Session session, MessageProducer producer)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= 10; i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有限制&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             TextMessage message = session.createTextMessage(&quot;ActiveMq 发送的消息&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送消息到目的地方&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            producer.send(message);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;     消息订阅者接收消息，定义一个与发布者相对应的主题example.A。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7138e616-8b77-45c2-85fd-474677a531df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7138e616-8b77-45c2-85fd-474677a531df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7138e616-8b77-45c2-85fd-474677a531df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tiantian.springintejms.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.activemq.ActiveMQConnectionFactory;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.jms.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TopicSubscriberTest {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String user = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String password = &quot;admin&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String url = &quot;tcp://192.168.210.128:61616&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ConnectionFactory ：连接工厂，JMS 用它创建连接&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         ConnectionFactory connectionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveMQConnectionFactory(user,password,url);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection ：JMS 客户端到JMS Provider 的连接&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Connection connection =&lt;span&gt; connectionFactory.createConnection();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        connection.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Session： 一个发送或接收消息的线程&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Session session =&lt;span&gt; connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Destination ：消息的目的地;消息发送给谁.&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         Topic destination=session.createTopic(&quot;example.A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费者，消息接收者&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         MessageConsumer consumer =&lt;span&gt; session.createConsumer(destination);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         consumer.setMessageListener(&lt;span&gt;new&lt;/span&gt; MessageListener(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有事务限制&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onMessage(Message message) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     TextMessage textMessage=&lt;span&gt;(TextMessage)message;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     System.out.println(&quot;接收到消息：&quot;+&lt;span&gt;textMessage.getText());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e1) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    e1.printStackTrace();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    session.commit();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JMSException e) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;    消息发布者发布消息，并打印截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111213951566-1861631683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  消息订阅者接受消息并打印截图如下：（消息订阅者需在发布者之前启动，可保证能取到订阅的消息）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/626790/201801/626790-20180111213920176-923231449.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 12 Jan 2018 13:19:00 +0000</pubDate>
<dc:creator>无涯Ⅱ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wlandwl/p/activemq.html</dc:identifier>
</item>
</channel>
</rss>