<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux 桌面玩家指南：05. 发博客必备的图片处理和视频录制神器 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop005.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;写博客时，总免不了要贴图片，有时是对屏幕进行截图，有时是自己画示意图，要求更高的时候，甚至还需要 GIF 动画或者屏幕录像，所以熟练掌握几个图片处理软件极其重要。在这里，我把我自己在 Linux 系统下使用到的运行稳定、界面美观、功能强大的图片处理工具介绍给大家。&lt;/p&gt;
&lt;h2 id=&quot;录制-gif-动画的工具-peek&quot;&gt;录制 GIF 动画的工具 Peek&lt;/h2&gt;
&lt;p&gt;这个工具 Ubuntu 官方软件仓库中没有，但是 PPA 中有。PPA是 personal package archive 的缩写，即个人维护的软件包，非 Ubuntu 官方维护的软件包。使用PPA，软件制作者可以轻松地发布软件，并且能够准确地对用户进行升级。Ubuntu用户使用 PPA 源将更加方便的获得软件的最新版本。关于PPA的详细情况，可以参考：&lt;a href=&quot;https://help.launchpad.net/Packaging/PPA&quot; class=&quot;uri&quot;&gt;https://help.launchpad.net/Packaging/PPA&lt;/a&gt;。针对 ubuntu 的用户，访问这个网站 &lt;a href=&quot;https://launchpad.net/&quot; class=&quot;uri&quot;&gt;https://launchpad.net/&lt;/a&gt;，搜索需要的软件，就可以得到该软件的PPA源。当然，对于很多开源软件，github 中也可以找到它。我们到 github 中搜索 peek，找到该软件，查看它的安装说明，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930123354827-681492510.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该说明中还是指导用户使用 PPA 进行安装。命令如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo add-apt-repository ppa:peek-developers/stable
sudo apt update
sudo apt install peek&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Peek 的使用很简单，只需要把它的窗口拖动到要录像的区域，开始录制就行了。如下 GIF 动画：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930124425439-1732770513.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重要的是，使用 Peek 录制的 GIF 动画文件比较小，适合发博客。顺便提一句，在 Windows 下好用的录制 GIF 动画的软件是 ScreenToGif，我也是在 github 下找到的。&lt;/p&gt;
&lt;h2 id=&quot;gnome-自带的截图工具-gnome-screenshot&quot;&gt;Gnome 自带的截图工具 gnome-screenshot&lt;/h2&gt;
&lt;p&gt;这个软件不用自己安装，它是 Gnome 桌面自带的截图软件，一般在 Linux 系统安装完成后就自动安装了，它的软件名是 gnome-screenshot，中文名就叫截图，很直接。虽然 Linux 下还有很多其它更优秀的截图软件，但是我认为这个系统自带的已经完全够用了。而且很好用。&lt;/p&gt;
&lt;p&gt;使用该工具甚至都不需要特别运行它，只需要记住 Gnome 桌面的几个快捷键就足够了，这几个快捷键分别如下：&lt;/p&gt;
&lt;p&gt;1、PrintScreen 键：直接按下键盘右上方的“Print Screen”键，就可以对整个屏幕进行截图，“咔擦”一声之后，就会跳出保存图片的对话框，非常方便。&lt;/p&gt;
&lt;p&gt;2、Alt + PrintScreen 键：如果只需要对当前窗口进行截图，按下 Alt + PrintScreen 即可。&lt;/p&gt;
&lt;p&gt;3、Shift + PrintScreen 键：如果只想对某个区域进行截图，按下 Shift + PrintScreen 键，然后鼠标指针就变了形状，按住鼠标左键拖动，选择屏幕上的哪个范围就可以对哪个范围进行截图。&lt;/p&gt;
&lt;p&gt;小技巧：使用快捷键截图时，往往难以截下如菜单项、下拉选框等弹出式界面里的内容。要截取这些内容，就不能使用上面的快捷键，必须打开截图软件，并设置延迟几秒后截图，然后打开菜单进行操作，设定的延迟时间一到，就把菜单、下拉选框中的内容截下了。&lt;/p&gt;
&lt;h2 id=&quot;功能更强大的截图工具-shutter&quot;&gt;功能更强大的截图工具 shutter&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;sudo aptitude install shutter&lt;/code&gt;命令就可以安装。该工具比 Gnome 自带的截图工具要稍微强大一点，可以针对选区、窗口、工作区进行截图，还可以针对菜单进行截图。截图后，还可以通过运行插件的方式对图片应用简单的特效，比如我最喜欢的手撕纸效果。Shutter 的界面如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930130546372-1623333673.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行插件的界面：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930130712219-574908257.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;位图处理软件-gimp&quot;&gt;位图处理软件 GIMP&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;sudo aptitude install gimp&lt;/code&gt;命令就可以安装。这款软件可以算得上是 Linux 系统下的 Photoshop，功能强大。正是因为功能强大，所以要驾驭它必须得下点功夫。由于本人以前有 Photoshop 基础，所以上手该软件也不算难。该软件启动后的初始界面可能不太符合大家的习惯，如下图：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201410/201708311373249.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过没关系，通过窗口菜单中的单窗口模式选项，可以更改为以下界面：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201410/201709564965273.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更适合绘图板使用的工具-mypaint&quot;&gt;更适合绘图板使用的工具 MyPaint&lt;/h2&gt;
&lt;p&gt;同样使用&lt;code&gt;sudo aptitude install mypaint&lt;/code&gt;即可安装。为什么说它更适合绘图板使用呢？因为它定义笔刷更自由。其界面如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930132059243-817776112.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;矢量图绘制软件-inkscape&quot;&gt;矢量图绘制软件 Inkscape&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;sudo aptitude install inkscape&lt;/code&gt;安装。先来看看 Inkscape 的界面，功能很强大的说：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201410/201712477468288.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么我这里要介绍一个位图处理软件，然后又介绍一个矢量图绘制软件呢？那是因为位图处理和矢量图处理还是有区别的。举例说明：比如我经常要在我截下的图片中，重点标出某个命令或菜单，这时我习惯在目标上画一个红色的线框表示强调。对于画框这么一件简单的事，用 Inkscape 就很方便，在矢量图绘制软件中，画框就是画框，画完框后可以改变这个框的边线颜色及样式，可以改变它的填充颜色及样式，可以拖动它的位置，可以改变它的大小，但是在位图处理软件中，就得换一种思考模式，在位图处理软件中，要画框只能先建立一个矩形的选区，然后对这个选区进行描边和填充，还可以对选取进行羽化，这样可以得到一个模模糊糊的框框，一旦描边和填充结束，则这个框框就再不能更改。所以 Inkscape 适合做添加框框、文字这样的工作，而 GIMP 适合做对选区羽化、非规则区域切图、添加阴影和发光这样的工作。&lt;/p&gt;
&lt;h2 id=&quot;示意图绘制软件-dia&quot;&gt;示意图绘制软件 Dia&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;sudo aptitude install dia&lt;/code&gt;进行安装。Dia 功能也非常强大，它最大的优势是它里面内置很多图像元素，非常适合画流程图、UML 图等各种示意图。界面如下：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201410/201724386377672.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面几个类图是我随便乱画的，就是体现一下 DIA 的效果，里面的背景颜色没有特殊意义。&lt;/p&gt;
&lt;h2 id=&quot;在线示意图绘制工具-draw.io&quot;&gt;在线示意图绘制工具 Draw.io&lt;/h2&gt;
&lt;p&gt;直接在浏览器的地址栏输入&lt;code&gt;www.draw.io&lt;/code&gt;就可以使用该工具了，其界面如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930132304377-865668408.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，也可以直接下载它的桌面版进行安装，然后离线使用。桌面版界面如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930132538572-1272159779.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;估计也就是对在线版做了个简单的封装。&lt;/p&gt;
&lt;h2 id=&quot;uml-建模工具-umbrello&quot;&gt;UML 建模工具 umbrello&lt;/h2&gt;
&lt;p&gt;为了找一款好用的的 UML 建模工具我是花了不少的心思，好的工具都要钱，比如 Rose、Enterprise Architecture、Microsoft Visual Studio 等等；不要钱的工具，品质总是不那么令人满意。经过多方测试后，我最终选择了 umbrello。这是 KDE 桌面自带的建模软件，但是在 Gnome 桌面下也可以完美运行，使用&lt;code&gt;sudo aptitude install umbrello&lt;/code&gt;就可以安装。界面如下：&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/16576/201410/201728508087999.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和 DIA 相比，它最大的优势就是支持 UML 的前向功能和逆向功能。也就是说，它可以从 UML 模型生成代码，也可以从我们写好的代码生成 UML 图。而 DIA 则是纯粹的绘图工具，UML 图就是图，它不能理解它的内涵，更不能生成代码。&lt;/p&gt;
&lt;h2 id=&quot;思维导图工具-xmind&quot;&gt;思维导图工具 XMind&lt;/h2&gt;
&lt;p&gt;我试过好几个开源的思维导图工具，包括 vym、 freemind 及其分支 freeplane，最后发现界面最美观，且生成的图片最美观的，依然是 XMind。其官网是 &lt;a href=&quot;https://www.xmind.net/&quot; class=&quot;uri&quot;&gt;https://www.xmind.net/&lt;/a&gt;。它是个开源软件，但同时也收费。除了官网，github 上也可以找到它。下载安装后，其界面如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930133753792-718408228.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;视频录制工具&quot;&gt;视频录制工具&lt;/h2&gt;
&lt;p&gt;要将我们的操作录制为视频，可以使用的软件比较多，有 recordmydesktop、simplescreenrecorder 和 kazam 可以用。前者在命令行使用，后两者都可以在图形界面下使用，并且在录制视频的同时还可以录制音频。这三个软件都可以使用&lt;code&gt;sudo aptitude install&lt;/code&gt;安装。下面是后两者的界面截图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180930134143392-1167246794.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年10月01日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Sun, 30 Sep 2018 21:42:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop005.html</dc:identifier>
</item>
<item>
<title>Unity 如何高效的解析数据 - wuzhang</title>
<link>http://www.cnblogs.com/wuzhang/p/wuzhang20181001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuzhang/p/wuzhang20181001.html</guid>
<description>&lt;p&gt;昨天和朋友聊天时，他遇到这么一个问题：现在有按照一定格式的数据，例如：&lt;br/&gt;&lt;strong&gt;#code==text 此处是注释&lt;br/&gt;100==确定&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;101==取消&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;key==value&lt;/strong&gt; 这么个格式的,说白了就是怎样解析这些固定格式字符串的Key和Value而已。他们项目已经做过了数据的解析，现在他在做项目优化，发现这一块数据解析部分GC偏高,&lt;span&gt;何谓GC，就是&lt;em&gt;Garbage Collection，&lt;/em&gt;在.Net中GC是由系统自动调用的，对内存的释放和回收&lt;em&gt;。&lt;/em&gt;&lt;span&gt;程序员是特别害怕遇上GC的，数据结构设计不合理，导致系统频繁调用GC，从而导致GC的代数增加，最终结果就是你的程序就会越来越卡，直到无响应！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;他就问我：“要是我，我会选择什么样的方式去解析这些数据?&quot;&lt;/p&gt;
&lt;p&gt;我当时不假思索：“格式固定，那就按这个固定的格式去解析，不就可以了!&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;我们可以按照”==“进行分割，分割后刚好得到我们想要的Key和Value！刚好系统提供了N多分割的方法，在这里刚好用字符串的分割&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string[] keyPair = Regex.Split(data,@&quot;==&quot;,RegexOptions.IgnoreCase);&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 正则表达式分割字符串
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;infoDic&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;解析后的kv&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ParseDataTable(&lt;span&gt;string&lt;/span&gt; filePath,&lt;span&gt;ref&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; infoDic)
{
    infoDic.Clear();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(filePath))
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(filePath,FileMode.Open,FileAccess.Read))
        {
            StreamReader sr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(fs);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; data =&lt;span&gt; sr.ReadLine();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (data != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略注释行&lt;/span&gt;
&lt;span&gt;                {
                    data &lt;/span&gt;=&lt;span&gt; sr.ReadLine();
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分割key和value&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt;[] keyPair = Regex.Split(data,&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,RegexOptions.IgnoreCase);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (keyPair.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!infoDic.ContainsKey(keyPair[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]))
                        {
                            infoDic.Add(keyPair[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;], keyPair[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            Debug.LogError(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERROR]:Has same key:{0},value:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,keyPair[&lt;span&gt;0&lt;/span&gt;],keyPair[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]));
                        }
                    }
                }
                data &lt;/span&gt;=&lt;span&gt; sr.ReadLine();
            }
            sr.Close();
            fs.Close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506960/201809/506960-20180930233204776-1147116243.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;好了，方法一到此完美分割出key和value！&lt;strong&gt;But......&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;朋友说这就是他们正在使用的解析方式，正因为正则表达式使用及其的方便不需要关心它是怎么实现的所有产生大量的GC，导致我们束手无策，因为字符串匹配解析的同时会生成许多字符串临时变量，这些都要在内存堆上申请空间，在profiler中看到解析时有大概10M的GC。所以我想到的这个解析方式被否了！朋友让我继续想想有没有什么好的办法，过了一会他给我说了他的想法，为何我们不自己去写一种解析方式呢，正则耗内存，我们可以不用它，string临时变量占用内存我们也可以不用它改用StringBuilder来替代它。这么说是可行的啊！无论是我们自己解析还是使用正则去解析，这个读取还是肯定要做的，读取后针对这个string我们逐字节去解析，特殊字符就去特殊处理，添加特殊的标记，例如：&lt;br/&gt;‘&lt;strong&gt;#&lt;/strong&gt;’：表示该行是注释行，解析时可以忽略；&lt;br/&gt;‘&lt;strong&gt;\n&lt;/strong&gt;’：表示要换行了，也意味着接下来key要出现了;&lt;br/&gt;‘&lt;strong&gt;\r&lt;/strong&gt;’：回车键的标识符号；&lt;br/&gt;‘&lt;strong&gt;=&lt;/strong&gt;’：这是一个很重要的符号，这个要特殊照顾，对它采取计数，&lt;strong&gt;奇数个&lt;/strong&gt;出现时刚好是&lt;strong&gt;key的结束&lt;/strong&gt;位置，&lt;strong&gt;偶数个&lt;/strong&gt;出现时刚好是&lt;strong&gt;value的起始&lt;/strong&gt;位置，这里是不是信息量很大，你会很快的　　想到计数个数对2取余做判断处理；&lt;br/&gt;也就这几个关键字符，那么接下来看如何处理，取出我们想要的key和value呢！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据解析
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;数据字典kv&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; ParseDatatable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
{
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isKey = &lt;span&gt;false&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key开始&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; isValue = &lt;span&gt;false&lt;/span&gt;;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;value开始&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; isValueStart = &lt;span&gt;false&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否value首次检测&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; equalIndex = &lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; = 出现次数的计数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; valueStartIndex = &lt;span&gt;0&lt;/span&gt;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Value的起始索引&lt;/span&gt;
    StringBuilder sbKey = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
    StringBuilder sbvalue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msg.Length; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (msg[i])
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                isKey &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isValue)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;收集颜色码中的#&lt;/span&gt;
&lt;span&gt;                    sbvalue.Append(msg[i]);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                isKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                isValue &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(sbKey.ToString()) &amp;amp;&amp;amp; !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(sbvalue.ToString()))
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (infoDic.ContainsKey(sbKey.ToString()))
                        Debug.LogError(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERROR]:has the same key:{0}, value:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sbKey.ToString(), sbvalue.ToString().Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        infoDic.Add(sbKey.ToString(), sbvalue.ToString().Replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                }
                sbKey.Remove(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, sbKey.Length);
                sbvalue.Remove(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, sbvalue.Length);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isValue)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略value里的 = 计数&lt;/span&gt;
                    equalIndex++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (equalIndex % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; equalIndex &amp;gt; &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key end&lt;/span&gt;
&lt;span&gt;                {
                    isKey &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    isValue &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (valueStartIndex !=&lt;span&gt; equalIndex)
                    {
                        isValueStart &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        valueStartIndex &lt;/span&gt;=&lt;span&gt; equalIndex;
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isValue)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isValueStart &amp;amp;&amp;amp; msg[i - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略==value前最开始的那个=&lt;/span&gt;
&lt;span&gt;                    {
                        isValueStart &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }
                    sbvalue.Append(msg[i]);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isKey)
                    sbKey.Append(msg[i]);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isValue)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg[i - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; msg[i + &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略转义字符'\'&lt;/span&gt;
                        &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    sbvalue.Append(msg[i]);
                    DealEndLine((i &lt;/span&gt;== msg.Length - &lt;span&gt;1&lt;/span&gt;), &lt;span&gt;ref&lt;/span&gt;&lt;span&gt; infoDic, sbKey, sbvalue);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; infoDic;
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 行尾特殊处理
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;lastLine&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否最后一行&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dictionary&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;infoDic&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;key&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DealEndLine(&lt;span&gt;bool&lt;/span&gt; lastLine, &lt;span&gt;ref&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; dictionary, StringBuilder key, StringBuilder value)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lastLine)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (infoDic.ContainsKey(key.ToString()))
            Debug.Log(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ERROR]:has the same key:{0}, value:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, key.ToString(), value.ToString().Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            infoDic.Add(key.ToString(), value.ToString().Replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是后期比较完善的代码了，这里做了以下错误兼容：&lt;br/&gt;1，兼容了策划在value里配置==或者===，均不影响解析。&lt;br/&gt;2，兼容了颜色码&amp;lt;color=#7893AA&amp;gt;{1}&amp;lt;/color&amp;gt;的’#‘和’=‘，此处不再是特殊转义字符处理。&lt;br/&gt;3，兼容了系统默认会添加&quot;\\n&quot;多个转义字符’\‘导致在Text上无法换行的问题。&lt;br/&gt;4，兼容了策划最后一行无回车换行导致无法解析的bug。&lt;br/&gt;目前就发现以上问题，对以上发现问题进行了解决！&lt;br/&gt;不早了，写这么点东西花了近三个多小时，如果有幸被您读到请留下你的脚印，得洗洗睡了，明天回家了，祝大家十一玩的愉快！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS:“纸上得来终觉浅 绝知此事要躬行”只有在实践中才能发现问题，交流是很好的灵感碰撞，遇到问题了多和小伙伴交流可能会有不一样的解决方案！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传送门：&lt;a title=&quot;Unity 数据解析&quot; href=&quot;https://gitee.com/wuzhang/UnityParseData.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/wuzhang/UnityParseData.git&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Sep 2018 16:15:00 +0000</pubDate>
<dc:creator>wuzhang</dc:creator>
<og:description>昨天和朋友聊天时，他遇到这么一个问题：现在有按照一定格式的数据，例如：#code==text 此处是注释100==确定101==取消key==value 这么个格式的,说白了就是怎样解析这些固定格式字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuzhang/p/wuzhang20181001.html</dc:identifier>
</item>
<item>
<title>word转PDF,PDF转Image,使用oppenOffice注意事项等 - 致未来的自己</title>
<link>http://www.cnblogs.com/liran123/p/9733833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liran123/p/9733833.html</guid>
<description>&lt;h2&gt;最近在电子合同等项目中需要把word或者pdf转换成image，用到了openOffice把word转换pdf,以及把pdf转换成图片&lt;/h2&gt;
&lt;h4&gt;感谢小伙伴张国清花费了三天时间来实现了此功能。下面我将把具体的步骤和注意事项说明。防止重复造轮子，最后我会把我的demo工程，以及对应的jar等发送到百度云。提供各位下载&lt;/h4&gt;
&lt;h3&gt;一、首先，列出maven依赖以及jar包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;!--PDF转图片--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.icepdf.os&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;icepdf-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;6.2.2&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;javax.media&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;jai_core&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.icepdf.os&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;icepdf-viewer&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;6.2.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--word转pdf--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.openoffice&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jurt&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.openoffice&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;ridl&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.openoffice&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;juh&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.openoffice&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;unoil&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--需要手动添加到本地仓库 word 转 pdf--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.artofsolving.jodconverter&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jodconverter-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.0-beta-4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里注意：&lt;strong&gt;你还一个需要把一个jar的文件夹（文章最下边有相应的百度云下载地址）你找到自己的maven仓库把对应的jar手动放入到 【repository/org/】目录下&lt;/strong&gt;，在idea右边导入后会有有红色波浪线警告。整个可忽略，不影响使用&lt;/p&gt;
&lt;p&gt;　　下图是对应怎么找到自己的maven repository路径&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1087466/201809/1087466-20180930234108455-398066038.jpg&quot; alt=&quot;&quot; width=&quot;1023&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　二、这里贴出详细的代码和配置，注意如果有的地方不正确或者不理解，欢迎评论或者在文章末尾下载我的demo工程来实际运行。以进一步详细熟悉&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;　word转换pdf工具类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.artofsolving.jodconverter.OfficeDocumentConverter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.artofsolving.jodconverter.office.DefaultOfficeManagerConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.artofsolving.jodconverter.office.OfficeManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PostConstruct;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.regex.Pattern;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * FileName: OfficeToPdfUtil
 * author:   zhangguoqing
 * Date:     2018/9/19 9:18
 * 说明:  word文件转换成pdf文件(必须安装Openoffice)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OfficeToPdfUtil {
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; OfficeManager officeManager;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ReentrantLock OfficeLock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();

    @PostConstruct
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        DefaultOfficeManagerConfiguration config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultOfficeManagerConfiguration();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置OpenOffice.org 3的安装目录&lt;/span&gt;
&lt;span&gt;        config.setOfficeHome(getOfficeHome());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动OpenOffice的服务&lt;/span&gt;
        OfficeManager getOfficeManager =&lt;span&gt; config.buildOfficeManager();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getOfficeManager == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            getOfficeManager.start();
        }
        officeManager &lt;/span&gt;=&lt;span&gt; getOfficeManager;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(OfficeToPdfUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * windows下openoffice安装地址
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String windowsOpenOfficeUrl;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * linux下openoffice安装地址
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String linuxOpenOfficeUrl;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * mac下opneoffice安装地址
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String macOpenofficeUrl = &quot;/Applications/OpenOffice.org.app/Contents/&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使Office2003-2007全部格式的文档(.doc|.docx|.xls|.xlsx|.ppt|.pptx) 转化为pdf文件&amp;lt;br&amp;gt;
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; inputFilePath 源文件路径，如：&quot;e:/test.docx&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 转换后的图片地址
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String officeToPdf(String inputFilePath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (officeManager == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果openOffice中途关闭了 再次启动 防止报错&lt;/span&gt;
                officeManager =&lt;span&gt; getOfficeManager();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(inputFilePath)) {
                logger.info(&lt;/span&gt;&quot;输入文件地址为空，转换终止!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            File inputFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(inputFilePath);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换后的pdf文件路径&lt;/span&gt;
            String outputFilePath_end =&lt;span&gt; getOutputFilePath(inputFilePath);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;inputFile.exists()) {
                logger.info(&lt;/span&gt;&quot;输入文件不存在，转换终止!&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连接OpenOffice&lt;/span&gt;
            OfficeDocumentConverter converter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OfficeDocumentConverter(officeManager);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; converterFile(inputFile, outputFilePath_end, inputFilePath, converter);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;word转化pdf出错!&quot;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: zhangguoqing
     * @date: 2018/9/19 14:03
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;: [inputFilePath] word源文件路径 如：&quot;e:/test.docx&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;: java.util.List&amp;lt;java.lang.String&amp;gt; 转换后图片地址列表
     * @Description: word转成图片
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; officeToImg(String inputFilePath) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;word转成pdf&lt;/span&gt;
            String pdfFilePath =&lt;span&gt; officeToPdf(inputFilePath);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pdf转图片&lt;/span&gt;
            List&amp;lt;String&amp;gt; iamgeFilePath =&lt;span&gt; PdfToImageUtil.pdfToIamge(pdfFilePath);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String string : iamgeFilePath) {
                logger.info(&lt;/span&gt;&quot;图片地址:&quot; +&lt;span&gt; string);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除pdf文件&lt;/span&gt;
            &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(pdfFilePath).delete();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; iamgeFilePath;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;word转化图片出错!&quot;&lt;span&gt;, e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取输出文件
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; inputFilePath
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getOutputFilePath(String inputFilePath) {
        String outputFilePath &lt;/span&gt;= inputFilePath.replaceAll(&quot;.&quot; + getPostfix(inputFilePath), &quot;.pdf&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; outputFilePath;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取inputFilePath的后缀名，如：&quot;e:/test.pptx&quot;的后缀名为：&quot;pptx&quot;&amp;lt;br&amp;gt;
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; inputFilePath
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getPostfix(String inputFilePath) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; inputFilePath.substring(inputFilePath.lastIndexOf(&quot;.&quot;) + 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 连接OpenOffice.org 并且启动OpenOffice.org
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; OfficeManager getOfficeManager() {
        DefaultOfficeManagerConfiguration config &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultOfficeManagerConfiguration();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置OpenOffice.org 3的安装目录&lt;/span&gt;
&lt;span&gt;        config.setOfficeHome(getOfficeHome());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动OpenOffice的服务&lt;/span&gt;
        OfficeManager getOfficeManager =&lt;span&gt; config.buildOfficeManager();
        getOfficeManager.start();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getOfficeManager;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据操作系统的名称，获取OpenOffice.org 3的安装目录&amp;lt;br&amp;gt;
     * 如我的OpenOffice.org 3安装在：C:/Program Files (x86)/OpenOffice.org 3&amp;lt;br&amp;gt;
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; OpenOffice.org 3的安装目录
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getOfficeHome() {
        String osName &lt;/span&gt;= System.getProperty(&quot;os.name&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;操作系统名称:&quot; +&lt;span&gt; osName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Pattern.matches(&quot;Linux.*&quot;&lt;span&gt;, osName)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; linuxOpenOfficeUrl;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Pattern.matches(&quot;Windows.*&quot;&lt;span&gt;, osName)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; windowsOpenOfficeUrl;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Pattern.matches(&quot;Mac.*&quot;&lt;span&gt;, osName)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; macOpenofficeUrl;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: zhangguoqing
     * @date: 2018/9/19 11:35
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;: [inputFile, outputFilePath_end, inputFilePath, converter]
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;: java.util.List&amp;lt;java.lang.String&amp;gt; 转换后的图片地址列表
     * @Description: 文件转换
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String converterFile(File inputFile, String outputFilePath_end, String inputFilePath,
                                       OfficeDocumentConverter converter) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        File outputFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(outputFilePath_end);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假如目标路径不存在,则新建该路径&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;outputFile.getParentFile().exists()) {
            outputFile.getParentFile().mkdirs();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断转换文件的编码方式，如果不是UTF-8，则改为UTF-8编码&lt;/span&gt;
&lt;span&gt;        converter.convert(inputFile, outputFile);
        logger.info(&lt;/span&gt;&quot;文件：&quot; + inputFilePath + &quot;\n转换为\n目标文件：&quot; + outputFile + &quot;\n成功!&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outputFile.isFile() &amp;amp;&amp;amp;&lt;span&gt; outputFile.exists()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; outputFilePath_end;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;转换的目标文件不存在 路径&quot; +&lt;span&gt; outputFilePath_end);
        }
    }

    @Value(&lt;/span&gt;&quot;${officeToPdf.linuxOpenOfficeUrl}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLinuxOpenOfficeUrl(String linuxOpenOfficeUrl) {
        OfficeToPdfUtil.linuxOpenOfficeUrl &lt;/span&gt;=&lt;span&gt; linuxOpenOfficeUrl;
    }

    @Value(&lt;/span&gt;&quot;${officeToPdf.windowsOpenOfficeUrl}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setWindowsOpenOfficeUrl(String windowsOpenOfficeUrl) {
        OfficeToPdfUtil.windowsOpenOfficeUrl &lt;/span&gt;=&lt;span&gt; windowsOpenOfficeUrl;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;pdf转换image工具类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.icepdf.core.pobjects.Document;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.icepdf.core.pobjects.Page;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.icepdf.core.util.GraphicsRenderingHints;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.imageio.ImageIO;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.awt.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.image.BufferedImage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.image.RenderedImage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * FileName: PdfToImageUtil
 * Author:   zhangguoqing
 * Date:     2018/9/18 17:53
 * 说明:  PDF转图片
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PdfToImageUtil {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(PdfToImageUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水印透明度&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; alpha = 0.2f&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水印横向位置&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; positionWidth = 150&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水印纵向位置&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; positionHeight = 300&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水印文字字体&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Font font = &lt;span&gt;new&lt;/span&gt; Font(&quot;仿宋&quot;, Font.BOLD, 26&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水印文字颜色&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Color color =&lt;span&gt; Color.GRAY;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 水印文字&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String watermark;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片宽度(做成可配置项)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Integer width;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片高度(做成可配置项)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Integer height;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片格式(做成可配置项)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String imgType;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PdfToImageUtil() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 有参构造,传参水印文字,生成图片时根据是否传参选择是否生成水印
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; watermark 水印内容
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PdfToImageUtil(String watermark) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.watermark =&lt;span&gt; watermark;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置水印&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BufferedImage setGraphics(BufferedImage bfimage) {
        Graphics2D g &lt;/span&gt;=&lt;span&gt; bfimage.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5、设置水印文字颜色&lt;/span&gt;
&lt;span&gt;        g.setColor(color);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6、设置水印文字Font&lt;/span&gt;
&lt;span&gt;        g.setFont(font);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7、设置水印文字透明度&lt;/span&gt;
&lt;span&gt;        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, alpha));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置旋转&lt;/span&gt;
        g.rotate(-Math.PI / 6&lt;span&gt;);
        g.drawString(watermark, &lt;/span&gt;0, (bfimage.getHeight() / 2) * 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9、释放资源&lt;/span&gt;
&lt;span&gt;        g.dispose();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bfimage;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: zhangguoqing
     * @date: 2018/9/18 17:55
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;: [inputFile] pdf文件路径
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;: java.util.List&amp;lt;java.lang.String&amp;gt; 图片地址列表
     * @Description: pdf文件转图片
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; pdfToIamge(String inputFile) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取inputFile的后缀名前的内容，如：&quot;e:/test.pptx&quot;的后缀名为：&quot;e:/test&quot;&lt;/span&gt;
        String imgPath_start = inputFile.substring(0, inputFile.lastIndexOf(&quot;.&quot;&lt;span&gt;));

        List&lt;/span&gt;&amp;lt;String&amp;gt; list=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Document document &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

            document &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            document.setFile(inputFile);
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; rotation = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转角度&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; maxPages =&lt;span&gt; document.getPageTree().getNumberOfPages();

            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList(maxPages);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; maxPages; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zoom 缩放比例 ,记住这里调清晰度,我用的是8.5超清晰,9以上就报错了&lt;/span&gt;
                BufferedImage bfimage = (BufferedImage) document.getPageImage(i, GraphicsRenderingHints.SCREEN, Page.BOUNDARY_CROPBOX, rotation, 2.1f&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图片的宽和高&lt;/span&gt;
                Image tempImage =&lt;span&gt; bfimage.getScaledInstance(width, height, Image.SCALE_SMOOTH);
                BufferedImage biTemp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
                Graphics gTemp &lt;/span&gt;=&lt;span&gt; biTemp.getGraphics();
                gTemp.drawImage(tempImage, &lt;/span&gt;0, 0, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加水印&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isNotBlank(watermark)) {
                    biTemp &lt;/span&gt;=&lt;span&gt; setGraphics(biTemp);
                }
                RenderedImage rendImage &lt;/span&gt;=&lt;span&gt; biTemp;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接图片地址&lt;/span&gt;
                String imgPath = imgPath_start + &quot;_&quot; + i + &quot;.&quot; +&lt;span&gt; imgType;
                ImageIO.write(rendImage, imgType, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(imgPath));
                bfimage.flush();
                list.add(imgPath);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;pdf转化图片出错!&quot;&lt;span&gt;, e);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (document != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            document.dispose();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    @Value(&lt;/span&gt;&quot;${pdfToImg.imgWidth}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setWidth(Integer width) {
        PdfToImageUtil.width &lt;/span&gt;=&lt;span&gt; width;
    }

    @Value(&lt;/span&gt;&quot;${pdfToImg.imgHeight}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHeight(Integer height) {
        PdfToImageUtil.height &lt;/span&gt;=&lt;span&gt; height;
    }

    @Value(&lt;/span&gt;&quot;${pdfToImg.imgType}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setImgType(String imgType) {
        PdfToImageUtil.imgType &lt;/span&gt;=&lt;span&gt; imgType;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　spring boot yml配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#word转pdf
officeToPdf:
  #linux下openoffice安装地址
  linuxOpenofficeUrl: &lt;/span&gt;/opt/&lt;span&gt;openoffice4
  #windows下openoffice安装地址 默认 请不要改变 (安装在哪个盘符都是这样)
  windowsOpenofficeUrl: C:\Program Files (x86)\OpenOffice &lt;/span&gt;4&lt;span&gt;
#pdf转图片
pdfToImg:
  #图片宽度
  imgWidth: &lt;/span&gt;1080&lt;span&gt;
  #图片高度
  imgHeight: &lt;/span&gt;1920&lt;span&gt;
  #图片格式
  imgType: png&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、最后说明一下oppenOffice安装时候的注意事项&lt;/h3&gt;
&lt;p&gt;　　windows下（我的是win10）oppenOffice在安装时候一路确定就可以,&lt;/p&gt;
&lt;p&gt;　　在linux我在自己的阿里云Centos7.4上安装linux遇到了一些问题。开始下载的【download language pack】但是在安装过程中会缺少依赖出问题，后来选择了 【download full installation】&lt;/p&gt;
&lt;p&gt;　　1、首先linux上安装需要把下面的安装包下载&lt;/p&gt;
&lt;p&gt;　　2、然后解压 运行命令解压文件：tar -xzvf  Apache_OpenOffice_4.1.5_Linux_x86-64_install-rpm_zh-CN.tar.gz&lt;/p&gt;
&lt;p&gt;　　3、然后运行安装命令：cd zh-CN/RPMS/   &lt;em id=&quot;__mceDel&quot;&gt;rpm -ivh *.rpm&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1087466/201809/1087466-20180930234304158-852149600.jpg&quot; alt=&quot;&quot; width=&quot;806&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　四、最后提供大家下载对应的工程demo和对应的jar包，以及oppenoffice下载的安装包&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;链接：https://pan.baidu.com/s/1RQQgmeSIpEiJVPkKVC2zuw 密码：ttp4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;再次注意：maven jar 对应直接解压放入到org目录下，然后刷新maven依赖或者重启ide&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后请大家转文章时不要复制粘贴一部分导致别人看不懂。如果我写的哪里有不懂了直接评论刷一下，看到我会及时回复的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 30 Sep 2018 16:04:00 +0000</pubDate>
<dc:creator>致未来的自己</dc:creator>
<og:description>word转PDF,PDF转Image,使用oppenOffice注意事项等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liran123/p/9733833.html</dc:identifier>
</item>
<item>
<title>TensorFlow 实现线性回归 - (•̀ω•́)y</title>
<link>http://www.cnblogs.com/laishenghao/p/9571343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laishenghao/p/9571343.html</guid>
<description>
&lt;p&gt;1、生成高斯分布的随机数&lt;/p&gt;
&lt;p&gt;导入numpy模块，通过numpy模块内的方法生成一组在方程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
y = 2 * x + 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;周围小幅波动的随机坐标。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plot
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getRandomPoints(count):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     xList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     yList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(count):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         x = np.random.normal(0, 0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         y = 2 * x + 3 + np.random.normal(0, 0.3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        xList.append(x)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        yList.append(y)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; xList, yList
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     X, Y = getRandomPoints(1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    plot.scatter(X, Y)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     plot.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行上述代码，输出图形如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/855030/201809/855030-20180901184823846-1570475630.png&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、采用TensorFlow来获取上述方程的系数&lt;/p&gt;
&lt;p&gt;　　首先搭建基本的预估模型y = w * x + b，然后再采用梯度下降法进行训练，通过最小化损失函数的方法进行优化，最终训练得出方程的系数。&lt;/p&gt;
&lt;p&gt;　　在下面的例子中，梯度下降法的学习率为0.2，训练迭代次数为100次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train(x, y):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机系数&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     w = tf.Variable(tf.random_uniform([1], -1, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机截距&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     b = tf.Variable(tf.random_uniform([1], -1, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预估值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     preY = w * x +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 损失值：预估值与实际值之间的均方差&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     loss = tf.reduce_mean(tf.square(preY -&lt;span&gt; y))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 优化器：梯度下降法,学习率为0.2&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     optimizer = tf.train.GradientDescentOptimizer(0.2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练：最小化损失函数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     trainer =&lt;span&gt; optimizer.minimize(loss)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    with tf.Session() as sess:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        sess.run(tf.global_variables_initializer())
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印初始随机系数&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;init w:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sess.run(w), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, sess.run(b))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先训练个100次：&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            sess.run(trainer)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每10次打印下系数&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; i % 10 == 9&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sess.run(w), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, sess.run(b))
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     X, Y = getRandomPoints(1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     train(X, Y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行上面的代码，某次的最终结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
w = 1.9738449&lt;span&gt;
b &lt;/span&gt;= 3.0027733
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅100次的训练迭代，得出的结果已十分接近方程的实际系数。&lt;/p&gt;
&lt;p&gt;　　某次模拟训练中的输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
init w: [-0.6468966] b: [0.52244043&lt;span&gt;]
w: [&lt;/span&gt;1.0336646] b: [2.9878206&lt;span&gt;]
w: [&lt;/span&gt;1.636582] b: [3.0026987&lt;span&gt;]
w: [&lt;/span&gt;1.8528996] b: [3.0027785&lt;span&gt;]
w: [&lt;/span&gt;1.930511] b: [3.0027752&lt;span&gt;]
w: [&lt;/span&gt;1.9583567] b: [3.0027738&lt;span&gt;]
w: [&lt;/span&gt;1.9683474] b: [3.0027735&lt;span&gt;]
w: [&lt;/span&gt;1.9719319] b: [3.0027733&lt;span&gt;]
w: [&lt;/span&gt;1.9732181] b: [3.0027733&lt;span&gt;]
w: [&lt;/span&gt;1.9736794] b: [3.0027733&lt;span&gt;]
w: [&lt;/span&gt;1.9738449] b: [3.0027733]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、完整代码和结果&lt;/p&gt;
&lt;p&gt; 完整测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;&lt;img id=&quot;code_img_closed_9f5d447e-c5b9-4027-8861-c79a1320fe86&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9f5d447e-c5b9-4027-8861-c79a1320fe86&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9f5d447e-c5b9-4027-8861-c79a1320fe86&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plot
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; getRandomPoints(count, xscale=0.5, yscale=0.3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     xList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     yList =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(count):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         x =&lt;span&gt; np.random.normal(0, xscale)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         y = 2 * x + 3 +&lt;span&gt; np.random.normal(0, yscale)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        xList.append(x)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        yList.append(y)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; xList, yList
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; train(x, y, learnrate=0.2, cycle=100&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机系数&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     w = tf.Variable(tf.random_uniform([1], -1, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机截距&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     b = tf.Variable(tf.random_uniform([1], -1, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预估值&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     preY = w * x +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 损失值：预估值与实际值之间的均方差&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     loss = tf.reduce_mean(tf.square(preY -&lt;span&gt; y))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 优化器：梯度下降法&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     optimizer =&lt;span&gt; tf.train.GradientDescentOptimizer(learnrate)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练：最小化损失函数&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     trainer =&lt;span&gt; optimizer.minimize(loss)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    with tf.Session() as sess:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        sess.run(tf.global_variables_initializer())
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印初始随机系数&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;init w:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sess.run(w), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, sess.run(b))
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(cycle):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            sess.run(trainer)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每10次打印下系数&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; i % 10 == 9&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sess.run(w), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, sess.run(b))
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sess.run(w), sess.run(b)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     X, Y = getRandomPoints(1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     w, b =&lt;span&gt; train(X, Y)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    plot.scatter(X, Y)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     plot.plot(X, w * X + b, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     plot.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　最终效果图如下，蓝色为高斯随机分布数据，红色为最终得出的直线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/855030/201809/855030-20180901194530587-1598557505.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;


&lt;p&gt;本文地址：&lt;a href=&quot;https://www.cnblogs.com/laishenghao/p/9571343.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/laishenghao/p/9571343.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 30 Sep 2018 15:44:00 +0000</pubDate>
<dc:creator>(•̀ω•́)y</dc:creator>
<og:description>1、生成高斯分布的随机数 导入numpy模块，通过numpy模块内的方法生成一组在方程 周围小幅波动的随机坐标。代码如下： 运行上述代码，输出图形如下： 2、采用TensorFlow来获取上述方程的系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laishenghao/p/9571343.html</dc:identifier>
</item>
<item>
<title>使用神经网络预测航班起飞准点率 - 牛云杰</title>
<link>http://www.cnblogs.com/NosenLiu/p/9733765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NosenLiu/p/9733765.html</guid>
<description>&lt;p&gt;前些日子，参加了一个解放号的行业大数据创新应用大赛，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://1024.jfh.com/question/detail?contestId=6&quot;&gt;https://1024.jfh.com/question/detail?contestId=6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　赛题是根据西安机场上半年的航班起降信息，建立适当预测模型，预测未来七天的航班准点率，(航班实际起飞时间-航班计划起飞时间)&amp;lt; 15 分钟即为准点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.问题分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为解决这个问题，首先需要对比赛数据进行深入了解。赛会提供的数据是一个csv文件，由15万条航班起降数据组成。每条记录包含如下九种属性：[航班号,出发地,到达地,机型,计划起飞时间,计划到达时间,实际起飞时间,实际到达时间,进出港类型]。&lt;/p&gt;
&lt;p&gt;下面是几条数据示例：&lt;/p&gt;
&lt;p&gt;HV2380,XIY,KUL,A330,2018/1/1 0:30,2018/1/1 5:40,2018/1/1 0:39,2018/1/1 5:59,出港&lt;/p&gt;
&lt;p&gt;IU6364,XIY,DMK,B737,2018/1/1 1:35,2018/1/1 5:30,2018/1/1 1:40,2018/1/1 5:17,出港&lt;/p&gt;
&lt;p&gt;IU5438,XIY,HKT,B737,2018/1/1 1:35,2018/1/1 6:35,2018/1/1 3:18,2018/1/1 7:51,出港&lt;/p&gt;
&lt;p&gt;其中，可以用于预测的特征只有 航班号、机型、出发地、到达地、计划起飞时间这5种特征，仅使用这些特征来建立预测模型的话是不够充分的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1 特征补充——爬取天气数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为此，我们额外收集了西安机场半年以来的天气数据，根据日常经验可知，天气对于航班起降的影响是巨大的。在给定的数据文件中，仅有2018年1月1日到2018年6月30日的数据，因此，我们在网上爬取了这些日期的天气情况。经过浏览网页，决定使用”逍遥天气”网站的数据，对每天天气新闻进行爬取(如：http://www.xaoyo.com/news/xian/20180629.html)。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930230039572-975886417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图1.天气网站示例&lt;/p&gt;
&lt;p&gt; 　　我们使用selenium+phantomJS的框架来对网站的标题进行爬取，发现每天的新闻的URL格式相对固定，仅后方的日期略有差别；此外，每天的新闻标题都存储在&amp;lt;div class=’hed_tit’&amp;gt;中的&amp;lt;h1&amp;gt;标签下，可以使用BeautifulSoup将其解析出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; title = BeautifulSoup(driver.page_source,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html.parser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hed_tit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).text
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取了标题字符串之后，我们对其进行解析切分，使用python自带的split()函数，将三种属性：天气、气温、风力 解析出来。经过粗略分析，感觉气温属性对航班的准点率影响不大，便仅留下天气与风力属性，保存在weather.csv文件中。&lt;/p&gt;
&lt;p&gt;　　这里爬虫的具体实现我就不再进行细致讲解，对爬虫没有太多基础的同学可以看我之前的博文(基于selenium+phantomJS的动态网站全站爬取)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.2非线性特征数据处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　现在，我们有了航班号、机型、出发地、到达地、计划起飞时间、天气、风力这7种属性。&lt;/p&gt;
&lt;p&gt;　　第一个问题是，神经往往要求我们的输入在[0~1]之间，但航班号、机型、出发地、到达地、天气这5个属性并不是线性的，我们无法使用算数计算的方式将其归一化。为了解决这个问题，直觉上想到One-Hot Vector编码。即将该特征编码成一条N*1的向量，该特征所处的位置赋值为1，向量中的其他位置赋值为0。One-Hot Vector 在网上已有丰富的资料可供查阅，这里我们就简单举例说明一下。&lt;/p&gt;
&lt;p&gt;　　假设现在一共有“HV2380”，“IW5079”，“SY6658”，“WJ5723”，“VQ9535”共5种航班，那么对于数据文件中的第一条数据：&lt;/p&gt;
&lt;p&gt;HV2380,XIY,KUL,A330,2018/1/1 0:30,2018/1/1 5:40,2018/1/1 0:39,2018/1/1 5:59,出港&lt;/p&gt;
&lt;p&gt;可以将航班号这个特征编码为 [1, 0, 0, 0, 0]。 对于另一条数据：&lt;/p&gt;
&lt;p&gt;WJ5723,XIY,TGO,B737,2018/1/1 13:50,2018/1/1 16:30,2018/1/1 13:58,2018/1/1 16:04,出港&lt;/p&gt;
&lt;p&gt;可以将航班号这个特征编码为 [0, 0, 0, 1, 0]。&lt;/p&gt;
&lt;p&gt;为了准确的对所有航班号属性进行One-Hot编码，我们遍历所有数据条目，统计出一共有1266中不同的航班。也就是说，对于这一种特征来说，就会产生一个1266*1的One-Hot向量，这会导致在神经网络训练的时候产生一个相当大的稀疏矩阵。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三.基于数据统计的多步预测模型建立&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1数据统计及特征提取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上文讲到直接对航班进行One-Hot编码，会产生一个较大的稀疏向量，进而在搭建网络的过程中会出现一个相当大的稀疏矩阵。直观上我会怀疑模型能否可以正确的对其进行训练，达到理想的效果。&lt;/p&gt;
&lt;p&gt;　　因为稀疏矩阵的存在，看起来对每一条航班信息进行准点率预测的模型不是那么好实现。等等，我们再重新审一下题~~赛题的要求是： &lt;strong&gt;预测未来七天的航班准点率！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　即，我们不是预测每个航班的起降准点率，而是预测每日所有航班的准点率：(准点航班数量/当日航班总数)*100%。也就是说，对于给定数据文件中的数据，我们没有必要对每一条航班信息建模训练，我们完全可以统计出每一天的航班起降情况，并以天为单位来进行建模预测。&lt;/p&gt;
&lt;p&gt;　　因此，我们着手开始进行数据统计的工作。首先，就是以天为单位，统计每天的航班起降总数与准点航班数目。为达到这个目的，我先初始化了两个长度为181的全0向量(赛题数据一共包含有181天)，分别表示第n天的航班总数与准点航班数目。之后开始对数据文档中的15万条数据进行一次遍历，对于每条数据，计算其所属的日期，与其是否准点，分别在对应向量的位置中+=1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; count_list = list(np.zeros(day_num))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算每天有多少班次飞机的list&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; accurate_num_list = list(np.zeros(day_num))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每天准点的飞机数量list&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(fin))[1:]:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首行是标注，非数据&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         plan_fly_time = time.mktime(time.strptime(fin[4][i],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y/%m/%d%H:%M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         day_index = int((plan_fly_time-begin_stamp)/(3600*24&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         count_list[day_index] += 1  
&lt;span&gt;7&lt;/span&gt;         actual_fly_time = time.mktime(time.strptime(fin[6][i],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y/%m/%d %H:%M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; actual_fly_time-plan_fly_time &amp;lt; 15*60&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             accurate_num_list[day_index] += 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在进行统计的过程中，还会遇见一些有问题的数据，例如说有部分数据的机型一项为NULL，有一部分数据的起飞、降落时间为NULL：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930231225084-747125305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.1 值为NA的脏数据示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930231250252-1195865769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3.2 值为#NA的脏数据示例&lt;/p&gt;
&lt;p&gt;在数据处理的过程中，我们选择对这些数据条目进行删除。整体删除量较小(总共删除&amp;lt;20条数据)，对建模不会产生任何影响。&lt;/p&gt;
&lt;p&gt;         在统计完每日航班数目与每日准点率之后，画出其图像，来对其关系进行直观的对比：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930231317594-246012223.png&quot; alt=&quot;&quot; width=&quot;1212&quot; height=&quot;626&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.3 每日起降航班数目与准点率关系统计图&lt;/p&gt;
&lt;p&gt;　　根据图像，我们可以得出，航班准点率整体趋于一个稳定序列，即没有明显上升、下降趋势的序列，平均准点率大概在60%左右；此外，可以略微的看出每日起降数量与准点率呈反比(如第45~75日)，这也与我们的直觉相契合，即航运压力大的时候飞机准点率不高。我们对前两个准点率低谷进行分析，发现在1月3日和1月24日有降雪，降雪不但对当天的航班准点率有影响，还会继续影响后续几天的航班，尤其是降雪过后第二日，航班准点率会比降雪当天还要低。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930231409157-947628795.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930231415021-1867085348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.4 降雪会明显影响后续几日航班准点率&lt;/p&gt;
&lt;p&gt;　　此外，继续观察天气数据与航班准点率统计图，可以发现气温对航班准点率几乎没有影响(数据从冬天到夏天，准点率没有明显上升、下降趋势)。因此，在对气象特征进行提取的时候，我们仅仅对天气和风力进行建模。&lt;/p&gt;
&lt;p&gt;　　对于天气建模，我们使用One-Hot编码的方式，将天气分为3类，第一类是{阴，晴，多云}，第二类是{小雨，中雨，大雨，暴雨}，第三类是{雨夹雪，小雪，中雪，大雪，暴雪}。最终生成一个形状为3*1的向量。如某日天气为“中雨”，特征向量为[0,1,0]，某日天气为“多云”，其特征向量为[1,0,0]。而对于风力，我们将其风力的级别提取出来，根据其级别0~12级将其归一化到[0,1]之间。此时，我们就可以将统计数据抽象提取出6个特征，即航班数，准点率，阴晴，雨，雪，风力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;   /*  接下来对剩下来的航班号、机型、出发地、降落地进行筛选，考虑到航班号确定时，其机型，出发地，将落地也将是确定的，在构造模型时，我们仅仅保留航班号这一个特征。最终，我们的预测模型拥有。 */&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2多步预测模型建立&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Nguyen Hoang An曾对神经网络进行多步预测的策略进行过总结[1]， 包括直接预测策略、迭代策略，MIMO策略，DirREC策略以及DirMO策略。其中，直接预测策略、DirREC策略和DirMO策略都需要建立多个预测模型，训练开销比较大。而MIMO策略的预测效果并不好，因此我们使用迭代策略来进行多步预测。国内也有学者对传统Airline Passenger数据进行多步预测[2]，取得了不错的效果。迭代策略就是训练出一个预测模型，预测出下一个时间节点的数据，之后将预测输出作为输入，对第二个时间节点进行预测，如此迭代反复，获得多步预测结果。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在上一节的处理中，我们最终留下了航班数，准点率，阴晴，雨，雪，风力6个特征用于预测。其中，模型并不能预测天气情况，仅仅能对航班数、准点率两个特征进行预测，&lt;strong&gt;在这次建模中，假设我们可以获得第二天准确的天气情况。每次将预测得到的航班数和准点率与已知的天气数据进行拼接，迭代的预测后续的航班数和准点率，预测得到未来7天的航班起降准点率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　预测模型搭建如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; model =&lt;span&gt; Sequential()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; model.add(LSTM(128, input_shape=(self.window_len,6),return_sequences=False))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO: input_shape=(timesteps ,data_dim)&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; model.add(Dropout(0.2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; model.add(Dense(2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; model.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sigmoid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; model.compile(loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rmsprop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用keras的序贯模型来构造训练模型。考虑到天气会对准点率有持续的影响，这里使用LSTM循环神经网络来进行预测，时间窗口(self.window_len)设置为6，输入特征数目也是6(即input_shape中的第二个参数)。尤其注意最后一层一定要使用Dense(2)，使我们的输出模型可以输出两个结果，第一个结果是第二天航班数的预测效果，第二个结果是第二天准点率的预测结果。&lt;/p&gt;
&lt;p&gt;         本次数据共有181天，排除掉最后7天的数据(最后七天的仅仅包含入港的数据、没有出港的数据)，再减去时间窗口6，得到168个样本。其中划出10个样本作为测试集，158个样本作为训练集。使用这158个样本进行训练，训练2000个epoch，获得模型并保存。&lt;/p&gt;
&lt;p&gt;使用这个模型来对10个测试样本进行预测，每次仅预测第二天的航班数和准点率：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930232026706-1258777702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.5 航班数目预测结果（单点预测）&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930232115315-366975568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3.6 航班准点率预测结果（单点预测）&lt;/p&gt;
&lt;p&gt;　　使用倒数第7天的样本输出作为初始样本，使用迭代策略来对未来7天的航班数目和准点率进行预测(假设已有未来7天准确的天气预报)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930232235366-1168036965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.7 航班数目预测结果（连续预测7天）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201809/1463653-20180930232309263-73921536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3.8 准点率预测结果（连续预测7天）&lt;/p&gt;
&lt;p&gt;　　通过上图可以看出，不论是对航班数目还是准点率，模型都可以对其趋势进行较好的把握，7天准点率预测结果的均方根误差约为5.3%。&lt;/p&gt;
&lt;p&gt;　　当然，在模型训练的时候，我们还可以对其窗口大小、训练次数、批处理大小、dropout比例等进行调整。时间充裕的情况下可以反复调整模型，获得更好的预测效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reference：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;Default&quot;&gt;[1] NH An, DT Anh. Comparison of Strategies for Multi-step-Ahead Prediction of Time Series Using Neural Network[C]. &lt;em&gt;2015 International Conference on Advanced Computing and Applications (ACOMP)&lt;/em&gt;, Ho Chi Minh City, 2015, pp. 142-149.&lt;/p&gt;
&lt;p class=&quot;Default&quot;&gt;[2] Liu YP, Hou D, Bao JP, et al. Multi-step Ahead Time Series Forecasting for Different Data Patterns Based on LSTM Recurrent Neural Network[C]. &lt;em&gt;2017 14th Web Information Systems and Applications Conference (WISA)&lt;/em&gt;, Liuzhou, Guangxi Province, China, 2017, pp. 305-310.&lt;/p&gt;

&lt;p&gt;后记：此次也有尝试已知未来7日每天航班计划(即已知每日航班数)来仅对航班准点率这一个属性进行预测。但预测效果不如上述模型理想。也许是因为数据较少(仅181天的数据，包括最后7日的残缺数据)的原因，可以后续对该模型继续留待观察。&lt;/p&gt;

</description>
<pubDate>Sun, 30 Sep 2018 15:34:00 +0000</pubDate>
<dc:creator>牛云杰</dc:creator>
<og:description>前些日子，参加了一个解放号的行业大数据创新应用大赛， https://1024.jfh.com/question/detail?contestId=6 一.问题描述 赛题是根据西安机场上半年的航班起降</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NosenLiu/p/9733765.html</dc:identifier>
</item>
<item>
<title>PE知识复习之PE的RVA与FOA的转换 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9733703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9733703.html</guid>
<description>&lt;h2&gt;一丶简介PE的两种状态&lt;/h2&gt;
&lt;p&gt;　　首先我们知道PE有两种状态.一种是内存展开.一种是在文件中的状态.那么此时我们有一个需求.&lt;/p&gt;
&lt;p&gt;我们想改变一个全局变量的初始值.此时应该怎么做.你知道虚拟地址.或者文件位置了.那么你怎么自己进行转换.&lt;/p&gt;
&lt;p&gt;也就是说通过文件中的节数据找到在内存中这块数据的位置.或者反之.&lt;/p&gt;
&lt;p&gt;寻找之前我们要先弄前几个概念.&lt;/p&gt;
&lt;p&gt;ImageBase:  模块基址.程序一开始的地址.&lt;/p&gt;
&lt;p&gt;VA: 全名virtualAddress 虚拟地址. 就是内存中虚拟地址. 例如 0x00401000&lt;/p&gt;
&lt;p&gt;RVA: RVA就是相对虚拟偏移. 就是偏移地址. 例如 0x1000. 虚拟地址0x00401000的RVA就是 0x1000. RVA = 虚拟地址-ImageBase&lt;/p&gt;
&lt;p&gt;FOA: 文件偏移. 就是文件中所在的地址.&lt;/p&gt;
&lt;h2&gt;二丶因为PE的两种状态.所以需要转换.&lt;/h2&gt;
&lt;p&gt;上面简介了一下什么是VA RVA 以及FOA 那么我们为什么要转换.&lt;/p&gt;
&lt;p&gt;原因是这样的. 我们程序的数据.在PE文件中的地址假设是0x400, 那么在内存中展开的时候就是0x1000位置处.&lt;/p&gt;
&lt;p&gt;那么我们如何通过内存位置.找到文件中这个数据的位置. 或者反之. 如果找到就可以进行修改了.&lt;/p&gt;
&lt;p&gt;原因就是PE有两种状态.有内存对齐跟文件对齐. 如果内存对齐跟文件对齐一样.那么不管在内存中还是在文件中.数据的位置都是一样的.&lt;/p&gt;
&lt;p&gt;例如文件对齐是0x1000,内存也是一样. 那么文件中0x1000位置存放的值.跟PE在内存中展开的时候存放的值是一样的.所以就不需要转换了.直接在文件中更改或者在内存中更改就行了.&lt;/p&gt;
&lt;p&gt;因为对齐值不一样.所以我们才需要进行转换.&lt;/p&gt;
&lt;p&gt;例如下图:&lt;/p&gt;
&lt;p&gt;文件对齐值是0x200,内存对齐是0x1000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930223046605-1176539761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三丶转换方法&lt;/h2&gt;
&lt;p&gt;既然上方了解了PE的内存状态.以及文件状态形式. 那么转换就很好理解了.&lt;/p&gt;
&lt;h3&gt;1.内存转文件偏移计算&lt;/h3&gt;
&lt;h3&gt;　　1.1.计算RVA&lt;/h3&gt;
&lt;p&gt;　　这一个讲的就是内存转文件偏移.就是知道一个内存地址.我们要看看在文件中是哪里存储的.&lt;/p&gt;
&lt;p&gt;第一步: 我们知道PE在内存中展开.是在ImageBase位置展开的.头跟文件是一样的.只不过节数据展开位置不一样.&lt;/p&gt;
&lt;p&gt;　　所以首先就是 我们的内存地址-Image得出RVA&lt;/p&gt;
&lt;p&gt;下方我们的内存地址我就设为x了. &lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;x - ImageBase == RVA&lt;/span&gt;  得出了我们的x位置在内存中的相对偏移.相对偏移就是我们计算的这个地址在开始位置的什么地方.&lt;/p&gt;
&lt;p&gt;　　ImageBase是在扩展头中存放的.我们可以查看一下.具体可以看看前几讲.属性解析.&lt;/p&gt;
&lt;p&gt;　　注意都是16进制进行加算的.&lt;/p&gt;
&lt;p&gt;　　根据上方我们得出的RVA.然后我们就在文件中从开头数RVA个字节,去寻找我们的这个数据.这样是不行的.因为文件对齐跟内存对齐是不一样的.所以我们要考虑对齐方式. 如果文件对齐跟内存对齐一样.那么这样就可以去找.&lt;/p&gt;
&lt;h3&gt;　　2.寻址FOA&lt;/h3&gt;
&lt;p&gt;　既然找到了RVA了.那么就找一下FOA在哪里.也就是文件偏移在哪里.寻找这个值很简单.需要几个步骤.&lt;/p&gt;
&lt;p&gt;　　2.&lt;strong&gt;1.判断RVA属于哪个节/头. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果RVA属于头(DOS+NT)那么不需要进行计算了.因为头在文件中根内存中都是一样展开的.直接从开始位置寻找到RVA个字节即可.&lt;/p&gt;
&lt;p&gt;　　　　如果不在头,就要判断在那个节里面. 判断节开始位置.跟结束位置. 我们的RVA在这个值里面.&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;其中节虚拟地址结束位置 就是用节数据对齐后的大小+虚拟地址大小. 具体可以参考上一讲节表解析.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;公式: RVA  &amp;gt;= 节.VirtualAddress  &amp;amp;&amp;amp; RVA &amp;lt;= (节.VirtualAddress + 节.SizeofRawData)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;em&gt;2.2 计算差值偏移. 虚拟地址距离节数据的开始位置的偏移.&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;然后计算差值偏移:&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;差值  = RVA - 节.VirtuallAddress&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;差值偏移:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;为什么要计算差值.因为我们计算的差值偏移就是我们的 RVA距离我们节数据开始位置 的偏移是多少. 因为这个位置是不会改变的.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如: 节数据开始位置是 0x1000  我们的RVA = 0x1024  那么差值是0x24. 如果文件中节数据开始的位置是0x400. 那么我们的差值偏移是不会变的. 那么文件偏移 + 差值偏移. 那么就是在文件中的位置. 例如 0x424&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2.3 计算FOA&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　FOA就很好计算了.  差值偏移已经得出来了. 就知道我们的RVA距离节数据开始位置的偏移. 那么我们加上文件偏移就是FOA&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;公式: FOA = 差值偏移 + 节.PointToRawData&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;内存转文件偏移总结:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1.计算RVA 公式: x - ImageBase == RVA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2.计算差值偏移.  RVA - 节.VirtualAddress == 差值偏移.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3.计算FOA         差值偏移 + 节.PointerToRawData == FOA&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;2.文件偏移转内存虚拟地址&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　上面讲解了我们根据虚拟地址可以定位到在文件中的那个位置.那么反之.我们也可以通过文件位置.定位到虚拟地址.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要理解的还是差值偏移. 只不过角色互换了. .&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　设x 为节数据的任意一位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　1.计算差值偏移:    x - 节.PointerToRawData(节数据在文件中开始的位置) == 差值偏移.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　2.计算RVA            差值偏移 + 节.VirtuallAddress(节数据在内存中展开的位置) == RVA&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　3.计算虚拟地址:   RvA + ImageBase == VA&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要注意的就是我们的 x在哪一个节中.  x &amp;lt;= 节.PointerToRawData + 节.SizeofRawData&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 四丶实战演练&lt;/h2&gt;
&lt;p&gt;　　我们写一个程序.其代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;


&lt;span&gt;int&lt;/span&gt; g_TestValue = &lt;span&gt;0x12345678&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;全局变量地址 = %p \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;g_TestValue);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;全局变量值 = %X \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, g_TestValue);

    getchar();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PS: 如果是VS系列编译器,请在属性 -&amp;gt; 连接 中去掉随机基址. 不然你需要计算一下.或者自己在PE中将文件头的文件属性更改. 更改为. 0x0103 &lt;/p&gt;
&lt;p&gt;程序截图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930233124263-229374490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时我们已经知道了全局变量地址.那么我们要转换到文件中.将这个全局变量地址进行修改.也就是说.我们通过修改文件.达到修改我们的全局变量值的一种手段.&lt;/p&gt;
&lt;p&gt;思路:&lt;/p&gt;
&lt;p&gt;　　1.计算出RVA.  RVA怎么计算我们也知道了.我们需要查看PE中扩展头的ImageBase成员的值. 这里我已经查看好了.值为0x400000. 那么我们的RVA = 19000&lt;/p&gt;
&lt;p&gt;　　2.判断属于哪个节,计算出差值偏移&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930233350011-761815850.png&quot; alt=&quot;&quot;/&gt; 在我们的.data节中.差值偏移计算出结果为0.&lt;/p&gt;
&lt;p&gt;　　3.计算FOA位置.&lt;/p&gt;
&lt;p&gt;　　因为现在编译器的文件对齐以及内存对齐都是一样了.所以我们不许要进行计算了. 直接就是文件偏移就是FOA位置.&lt;/p&gt;
&lt;p&gt;否则我们差值偏移加文件偏移 = = FOA.  现在我们的差值偏移是 0 0 + 节偏移 就是全局变量在文件中的位置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930233555987-28379218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7400 就是我们的FOA&lt;/p&gt;
&lt;p&gt;　　4.跳转到FOA修改全局变量的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930233638604-111560314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转到我们的FOA位置,可以看到我们全局变量的初始值为小端模式的 0x12345678,那么我们进行修改.进行文件保存即可.&lt;/p&gt;
&lt;p&gt;　5.修改文件重新打开程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930233751746-1233784301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　修改为0x55555555了,重新打开程序观看结果.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201809/1197364-20180930233843339-1529032561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是内存转文件偏移的实战. 如果学过逆向的人应该接触过OD.或者x64DBG. 如果我们在内存中修改后.要保存到文件.那么计算公式就是这个.&lt;/p&gt;

</description>
<pubDate>Sun, 30 Sep 2018 15:12:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>PE知识复习之PE的RVA与FOA的转换 一丶简介PE的两种状态 首先我们知道PE有两种状态.一种是内存展开.一种是在文件中的状态.那么此时我们有一个需求. 我们想改变一个全局变量的初始值.此时应该怎</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9733703.html</dc:identifier>
</item>
<item>
<title>Windows应用程序进程级别统一监控实践 - 静若清池</title>
<link>http://www.cnblogs.com/liugh/p/9733637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liugh/p/9733637.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;        一般的系统级别指标监控，更多关注CPU、内存、磁盘、网络等运行情况，对应用程序运行时的进程指标关注不够，导致不能深入了解系统运行状态。本文根据笔者应用实践，探讨一下进程级别监控涉及到的监控内容以及监控方式，供感兴趣的同行做参考。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/380081/201809/380081-20180930224732064-1792555053.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;347&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一、监控内容&lt;/p&gt;
&lt;p&gt;        众所周知，应用软件最终表现为应用程序，程序是指令、数据及其组织形式的描述，其本身没有任何运行的含义，是一个静态的概念；进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是程序的实体，是一个动态的概念。&lt;/p&gt;
&lt;p&gt;进程的主要属性有：进程ID、进程名称、进程用户名称、进程状态、进程优先级、进程启动时间、包含的线程、使用的CPU时间、使用的内存、句柄等。进程的属性虽多，但根据笔者的应用实践，只要重点监控几个关键指标即可抓住进程的运行状态，进而对应用程序的健康状况做出正确的判断，并在发生故障前快速采取止损措施。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;CPU&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        CPU描述了进程占用的计算资源，监控主要关注进程级别CPU的两种场景：High CPU、Low CPU。&lt;/p&gt;
&lt;p&gt;        当进程长时间处于High CPU状态时，除了正常负载高的情况，程序内部可能：&lt;/p&gt;
&lt;p&gt;        a.在不断产生大量异常&lt;/p&gt;
&lt;p&gt;        b.发生了死循环&lt;/p&gt;
&lt;p&gt;        c.在频繁做垃圾回收（Garbage Collection，GC）&lt;/p&gt;
&lt;p&gt;        当进程长时间处于Low CPU状态时，程序内部可能：&lt;/p&gt;
&lt;p&gt;        a.发生了死锁&lt;/p&gt;
&lt;p&gt;        b.发生了阻塞&lt;/p&gt;
&lt;p&gt;      2.内存&lt;/p&gt;
&lt;p&gt;        内存描述了进程占用的存储资源，由于Windows资源分为托管资源和非托管资源，因此监控进程级别的内存，应该关注同时包含这两种资源的提交内存（Commit Size）。&lt;/p&gt;
&lt;p&gt;监控主要关注进程级别High Memory场景，当进程长时间处于High Memory状态时，程序内部可能:&lt;/p&gt;
&lt;p&gt;        a.发生了内存泄漏，对象一直被使用，无法及时释放&lt;/p&gt;
&lt;p&gt;        b.产生了内存碎片，导致内存溢出（Out Of Memory，OOM）&lt;/p&gt;
&lt;p&gt;        3.端口数&lt;/p&gt;
&lt;p&gt;        端口数描述了进程占用的网络资源，通过命令“netstat -ano”可以获得整个机器的网络端口数占用情况，但无法直接获得每个进程的网络端口数占用情况，因此需要对“netstat -ano”输出的进程ID做分组汇总，以便获得每个进程占用的端口数，从而对进程的监控深入一个层次。&lt;/p&gt;
&lt;p&gt;当进程占用的端口数过高时，程序内部可能发生了端口泄漏。&lt;/p&gt;
&lt;p&gt;        4.活跃线程数&lt;/p&gt;
&lt;p&gt;        进程是线程的容器，一个进程可以包括多个线程，进程和线程都是CPU工作时间段的描述。线程具有生命周期，因此具有很多状态（新建、就绪、运行、阻塞、死亡），从Windows任务管理器看到的某个进程包含的线程数，是所有状态的线程数，监控粒度比较粗。&lt;/p&gt;
&lt;p&gt;        进程级别的线程监控，应该关注活跃线程数，也就是真正在运行的线程数，这可以通过如下方法得到：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;18.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;636&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;private int GetActiveThreadCount()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;int MaxWorkerThreads, miot, AvailableWorkerThreads, aiot;&lt;/p&gt;
&lt;p&gt;ThreadPool.GetMaxThreads(out MaxWorkerThreads, out miot);&lt;/p&gt;
&lt;p&gt;AvailableWorkerThreads = aiot = 0;&lt;/p&gt;
&lt;p&gt;    ThreadPool.GetAvailableThreads(out AvailableWorkerThreads, out aiot);&lt;/p&gt;
&lt;p&gt;    return MaxWorkerThreads - AvailableWorkerThreads;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;        当进程包含的活跃线程数过高时，程序内部可能发生了线程泄漏。&lt;/p&gt;
&lt;p&gt;        5.同一进程组流量分布&lt;/p&gt;
&lt;p&gt;        前面的几个指标关注的是单一进程，当不同机器上的进程组成一个集群时，需要同时关注这些进程组间的指标，比如流量分布。&lt;/p&gt;
&lt;p&gt;当一个集群负载均衡的处理请求时，流量应该是均分到每一个处理进程的，如果监控到某一个进程处理的TPS远小于整个集群的平均TPS时，该进程很可能发生了阻塞或宕机&lt;/p&gt;
&lt;p&gt;        6.可用性指标&lt;/p&gt;
&lt;p&gt;        可用性指标是指可以作为度量系统死活点（Dead Live Point，DLP）的指标，一般关注两个方面：进程可用性、进程上运行的服务可用性。&lt;/p&gt;
&lt;p&gt;        进程可用性主要判断进程是否仍然存活，可以通过调用系统接口判断进程是否存在，也可以通过进程埋点上报心跳信息。&lt;/p&gt;
&lt;p&gt;        进程上运行的服务可用性主要关注服务运行的成功率或失败率，因此涉及到的业务因素比较多，限于篇幅不再展开。如果整个系统基于微服务框架，比如高速服务框架（High Speed Framework，HSF），则可以对服务调用进行统一监控，从而可以统一计算服务可用性。&lt;/p&gt;
&lt;p&gt;二、监控方式&lt;/p&gt;
&lt;p&gt;        对进程级别的监控由于比较底层，一般采用两种手段：监控主动收集、进程埋点上报。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;监控主动收集&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        主动收集又分为两种方式：通过系统接口获得机器上所有进程信息、通过性能计数器获得进程级别监控指标，两种方式都是非侵入式的，不会影响进程的正常运行，是首要考虑的监控方式。&lt;/p&gt;
&lt;p&gt;        2.进程埋点上报&lt;/p&gt;
&lt;p&gt;        埋点是一种常见的数据采集方式，在要精准获得进程级别监控数据时，代码埋点可能是最好的选择。比如前面提到的获得进程包含的活跃线程数，以及可用性指标，都需要进程埋点上报才能获得比较精确的监控指标。当然进程埋点并不需要对每个进程都做埋点开发，可以在框架层面进行统一埋点，从而降低埋点开发及实施成本。&lt;/p&gt;
&lt;p&gt;三、总结&lt;/p&gt;
&lt;p&gt;        只有深刻认识到进程级别监控涉及的监控内容及监控方式，才能更深入的掌握系统运行状态，并在系统开始恶化前针对不同进程指标快速做出点杀动作（比如通过自动运维进行有顺序的进程重启），从而做到及时止损。&lt;/p&gt;
&lt;p&gt;四、特来电云计算与大数据微信公众号&lt;/p&gt;
&lt;p&gt;1.微信公众号名称：特来电云计算与大数据&lt;/p&gt;
&lt;p&gt; 2.二维码：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/380081/201805/380081-20180531163346171-1799422996.png&quot; alt=&quot;&quot; width=&quot;214&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Sep 2018 14:51:00 +0000</pubDate>
<dc:creator>静若清池</dc:creator>
<og:description>一般的系统级别指标监控，更多关注CPU、内存、磁盘、网络等运行情况，对应用程序运行时的进程指标关注不够，导致不能深入了解系统运行状态。本文根据笔者应用实践，探讨一下进程级别监控涉及到的监控内容以及监控</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liugh/p/9733637.html</dc:identifier>
</item>
<item>
<title>【数据科学】Python数据可视化概述 - 昕-2008</title>
<link>http://www.cnblogs.com/Belter/p/9650433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Belter/p/9650433.html</guid>
<description>&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：很早之前就打算专门写一篇与Python数据可视化相关的博客，对一些基本概念和常用技巧做一个小结。今天终于有时间来完成这个计划了！&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;0. Python中常用的可视化工具&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;Python在数据科学中的地位，不仅仅是因为numpy, scipy, pandas, scikit-learn这些高效易用、接口统一的科学计算包，其强大的数据可视化工具也是重要组成部分。在Python中，使用的最多的数据可视化工具是matplotlib，除此之外还有很多其他可选的可视化工具包，主要包括以下几大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;matplotlib以及基于matplotlib开发的工具包：pandas中的封装matplotlib API的画图功能，seaborn，networkx等；&lt;/li&gt;
&lt;li&gt;基于JavaScript和d3.js开发的可视化工具：plotly等，这类工具可以显示动态图且具有一定的交互性；&lt;/li&gt;
&lt;li&gt;其他提供了Python调用接口的可视化工具：OpenGL, GraphViz等，这一类工具各有特点且在特定领域应用广泛.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于数据科学，用的比较多的是matplotlib和seaborn，对数据进行动态或交互式展示时会用到plotly.&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1. matplotlib与MATLAB&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;Matplotlib是建立在NumPy数组基础上的多平台数据可视化程序库，John Hunter在2002年提出了matplotlib的初步构想——在Python中画出类似MATLAB风格的交互式图形。鉴于此种渊源，类似MATLAB风格的画图接口是matplotlib的两种画图接口之一。这类接口直观、便捷，许多语法与MATLAB类似，也是初学者常用的方式。&lt;/p&gt;
&lt;p&gt;这种接口最重要的特性是有状态的（stateful）：它会持续跟踪&quot;当前的&quot;图形和坐标轴，所有&lt;span&gt;plt&lt;/span&gt;命令都可以应用。可以用&lt;span&gt;plt.gcf()&lt;/span&gt;（获取当前图形）和&lt;span&gt;plt.gca()&lt;/span&gt;（获取当前坐标轴）来查看具体信息。&lt;/p&gt;
&lt;p&gt;matplotlib画图的基本设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib as mpl
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; mpl.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axes.linewidth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 1.5 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;set the value globally, 设置坐标轴线宽&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; seaborn as sns
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; sns.set()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用seaborn设置绘图风格&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多自定义设置可以参考官方文档：&lt;a href=&quot;https://matplotlib.org/users/customizing.html&quot; target=&quot;_blank&quot;&gt;Customizing matplotlib&lt;/a&gt;&lt;a href=&quot;https://matplotlib.org/api/matplotlib_configuration_api.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面使用MATLAB风格画图，对一组分类变量（categorical variables）进行可视化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; names = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;group_a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;group_b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;group_c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不同分类的名称&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; values = [1, 10, 100]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不同分类对应的值&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; plt.figure(1, figsize=(9, 3))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置图片大小&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; plt.subplot(131)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1x3, 第一个子图&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; plt.bar(names, values)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 柱状图&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; plt.subplot(132)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1x3, 第二个子图&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; plt.scatter(names, values)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 散点图&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; plt.subplot(133)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1x3, 第三个子图&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; plt.plot(names, values)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 折线图&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; plt.suptitle(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Categorical Plotting&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图片的标题&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; w_pad设置子图之间的间隔宽度;rect设置整个图像部分（矩形）的左上点坐标和右下点坐标，默认值为[0, 0, 1, 1]&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; plt.tight_layout(w_pad=0.1, rect=[0, 0.03, 1, 0.95&lt;span&gt;]) 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo1.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dpi=200)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存图片&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图片如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1035701/201809/1035701-20180928192846728-1456663118.png&quot; alt=&quot;&quot; width=&quot;807&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图1：分类变量的可视化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这种方式画图非常直观，每一步都对&quot;&lt;span&gt;plt&lt;/span&gt;&quot;对象有一个特定的操作，画图的过程至上而下，画好之后保存图片。其他命令说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;subplot(131)&lt;/span&gt;表示设置子图为1行3列，且当前为第1个子图；&lt;/li&gt;
&lt;li&gt;在保存图片之前调用&lt;span&gt;tight_layout()&lt;/span&gt;函数可以使图片更加紧凑，边框更窄，更多关于该函数的用法可参考&lt;a href=&quot;https://matplotlib.org/users/tight_layout_guide.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;保存图片是可以使用参数&lt;span&gt;dpi&lt;/span&gt;设置图片的分辨率.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在官方文档中，这种风格的API被称为&quot;&lt;span&gt;pyplot API&lt;/span&gt;&quot;.&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2. matplotlib的第二种风格——面向对象的画图接口&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;在面向对象编程中有一句口号：&quot;一切皆对象&quot;，Python既然是一种面向对象的编程语言，画图也自然可以使用面向对象的方式。MATLAB风格的画图接口直观易用，但是遇到一些精细操作时，就会比较麻烦。面向对象的画图接口可以适应更复杂的场景，更精细的控制需要展示的图形。&lt;/p&gt;
&lt;p&gt;在面向对象接口中，画图函数不再受到当前&quot;活动&quot;图形或坐标轴的限制，而变成了显式的&lt;span&gt;Figure&lt;/span&gt;和&lt;span&gt;Axes&lt;/span&gt;的方法。在画图的过程中，实际操作的是这两个类的实例：figure和axes.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;figure&lt;/span&gt;（&lt;span&gt;plt.Figure&lt;/span&gt;类的一个实例）可以被看成是一个能够容纳各种坐标轴、图形、文字和标签的容器。&lt;span&gt;axes&lt;/span&gt;（&lt;span&gt;plt.Axes&lt;/span&gt;类的一个实例）是一个带有刻度和标签的矩形，最终会包含所有可视化的图形元素。通常使用变量&lt;span&gt;fig&lt;/span&gt;表示一个图形实例，用变量&lt;span&gt;ax&lt;/span&gt;表示一个坐标轴实例或一组坐标轴实例。&lt;/p&gt;
&lt;p&gt;下面是一个使用面向对象的API画图的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; %&lt;span&gt;matplotlib inline
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; example data&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; x = np.arange(0.1, 4, 0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; y = np.exp(-&lt;span&gt;x)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置error bar的(单侧)长度&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; error = 0.1 + 0.2 *&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用subplots返回fig和ax实例&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; fig, (ax0, ax1) = plt.subplots(nrows=2, sharex=True, figsize=(8, 6))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两个子图，返回两个Axes实例&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一个子图，对称的error bar&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; ax0.errorbar(x, y, yerr=error, fmt=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; ax0.set_title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;variable, symmetric error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分别设置error bar两侧的长度&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; lower_error = 0.4 *&lt;span&gt; error
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; upper_error =&lt;span&gt; error
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; asymmetric_error =&lt;span&gt; [lower_error, upper_error]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二个子图，不对称的error&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; ax1.errorbar(x, y, xerr=asymmetric_error, fmt=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; ax1.set_title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;variable, asymmetric error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; ax1.set_yscale(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;fig.tight_layout()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; fig.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo2.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dpi=200)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存图片&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1035701/201809/1035701-20180928203444912-22905744.png&quot; alt=&quot;&quot; width=&quot;842&quot; height=&quot;632&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2：error bar的可视化 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如上面的例子显示的那样，可以使用函数&lt;span&gt;plt.subplots()&lt;/span&gt;返回&lt;span&gt;fig&lt;/span&gt;和&lt;span&gt;ax&lt;/span&gt;实例，也可以直接使用&lt;span&gt;plt.Figure&lt;/span&gt;和&lt;span&gt;plt.Axes&lt;/span&gt;这两个类来返回各自的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; plt.style.use(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-whitegrid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; %&lt;span&gt;matplotlib inline
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; fig = plt.figure(figsize=(8, 6&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; ax =&lt;span&gt; plt.axes()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; x = np.linspace(0, 10, 100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;ax.plot(x, np.sin(x))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; ax.set_xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, size=14&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; ax.set_ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sin x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, size=14&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; ax.set_title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sin plot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, size=16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;fig.tight_layout()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; fig.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo3.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dpi=200)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1035701/201809/1035701-20180928205225435-1634113408.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;530&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3：sin函数图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们获取&lt;span&gt;fig&lt;/span&gt;和&lt;span&gt;ax&lt;/span&gt;实例后，就可以直接操作这两个实例来完成想要可视化效果。操作这两个实例的方法众多，可参考下面的官方文档：&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;3. 统计作图以及图片的风格&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;除了matplotlib之外，&lt;a href=&quot;https://seaborn.pydata.org/index.html&quot; target=&quot;_blank&quot;&gt;seaborn&lt;/a&gt;是专门为统计制图开发的可视化工具。除了直接用于数据的可视化之外，还能够完成一些常见的统计功能来辅助画图，例如误差线的估计，密度估计，箱形图分位数的计算等。此外，与matplotlib相比，seborn画图的风格更美观。因此该可视化工具在数据分析中也用的比较多。&lt;/p&gt;
&lt;p&gt;按照文档中对&lt;a href=&quot;https://seaborn.pydata.org/api.html&quot; target=&quot;_blank&quot;&gt;API的介绍&lt;/a&gt;，seaborn主要将统计制图分为下面几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关系图&lt;/li&gt;
&lt;li&gt;分类图&lt;/li&gt;
&lt;li&gt;分布图&lt;/li&gt;
&lt;li&gt;回归图&lt;/li&gt;
&lt;li&gt;矩阵图：heatmap或聚类图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用seaborn画图的例子可以参考：&lt;a href=&quot;http://www.cnblogs.com/Belter/p/Example%20gallery&quot; target=&quot;_blank&quot;&gt;Example gallery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面例子中涉及到两次对画图风格的设置，风格主要包括对图的配色，背景色、坐标轴、字体、透明度等的设置。在matplotlib中主要有以下风格可选：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre readability=&quot;29&quot;&gt;
&lt;span&gt;&amp;gt; print&lt;/span&gt;&lt;span&gt;(plt.style.available)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;---output---#&lt;/span&gt;
[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dark_background&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-notebook&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-darkgrid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_classic_test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ggplot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-bright&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;classic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;p&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Solarize_Light2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fast&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fivethirtyeight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-dark-palette&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tableau-colorblind10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-muted&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/p&gt;&lt;p&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-whitegrid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-ticks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-dark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grayscale&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-deep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-poster&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;/p&gt;&lt;p&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-talk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-colorblind&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bmh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-pastel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;seaborn-paper&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考上面的Customizing matplotlib链接，各种不同样式的比较可以参考：&lt;a href=&quot;https://tonysyu.github.io/raw_content/matplotlib-style-gallery/gallery.html&quot; target=&quot;_blank&quot;&gt;Matplotlib Style Gallery&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;4. 常见的作图类型及功能&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;matplotlib可以画大部分常见的图，例如柱状图、折线图、饼图、直方图等。&lt;/p&gt;
&lt;p&gt;更多详情可以参考：&lt;a href=&quot;https://matplotlib.org/api/axes_api.html#plotting&quot; target=&quot;_blank&quot;&gt;Plotting-basic&lt;/a&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;https://tonysyu.github.io/raw_content/matplotlib-style-gallery/gallery.html&lt;/p&gt;
&lt;p&gt;https://jakevdp.github.io/PythonDataScienceHandbook/&lt;/p&gt;
&lt;p&gt;https://seaborn.pydata.org/index.html&lt;/p&gt;
&lt;p&gt;https://matplotlib.org/index.html&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/8248467/matplotlib-tight-layout-doesnt-take-into-account-figure-suptitle&lt;/p&gt;

</description>
<pubDate>Sun, 30 Sep 2018 14:50:00 +0000</pubDate>
<dc:creator>昕-2008</dc:creator>
<og:description>注：很早之前就打算专门写一篇与Python数据可视化相关的博客，对一些基本概念和常用技巧做一个小结。今天终于有时间来完成这个计划了！ 0. Python中常用的可视化工具 Python在数据科学中的地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Belter/p/9650433.html</dc:identifier>
</item>
<item>
<title>【Unity Shader】（五） ------ 透明效果之半透明效果的实现及原理 - 爱喝柠檬的二哈</title>
<link>http://www.cnblogs.com/BFXYMY/p/9717734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BFXYMY/p/9717734.html</guid>
<description>&lt;p&gt;笔者使用的是 Unity 2018.2.0f2 + VS2017，建议读者使用与 Unity 2018 相近的版本，避免一些因为版本不一致而出现的问题&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;相信读者对透明效果都不陌生，因为透明效果是游戏中经常使用的一种效果。要实现透明效果，通常会在渲染模型时控制它的&lt;strong&gt;透明通道&lt;/strong&gt;。而其透明度则控制是其是否会显示，0 表示完全不显示，1 表示完全显示。&lt;/p&gt;
&lt;p&gt;Unity 中通常使用两种方法来实现透明效果：&lt;strong&gt;透明度测试（Alpha Test）&lt;/strong&gt;和 &lt;strong&gt;透明度混合（Alpha Blending）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;透明度测试。透明度测试是一种十分 “简单粗暴” 的机制，当有一个片元的透明度不符合条件时，就直接舍弃，不再任何处理（不会对颜色缓冲有影响）；如果符合，就进行正常的处理（深度测试，深度写入等）；所以这带来的效果也是两极分化的，要么完全透明，要么完全不透明。&lt;/li&gt;
&lt;li&gt;透明度混合。透明度混合可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与颜色缓冲中的值进行混合，得到新的颜色。&lt;strong&gt;需要注意的是，此方法需要关闭深度写入，而因此带来的问题就是要 十分十分十分 地注意渲染顺序。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便读者理解，先解释一下深度缓冲，深度测试和深度写入&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;深度缓冲。用于解决可见性问题的强大存在。决定了哪个物体的哪些部分会被渲染，哪些部分会被遮挡&lt;/li&gt;
&lt;li&gt;深度测试。开启后，当渲染一个片元时，根据它的深度值判断该片元距离摄像机的距离，然后将它的深度值和深度缓冲中的值进行比较&lt;/li&gt;
&lt;li&gt;深度写入。开启后，当一个片元进行了深度测试后，如果它的值距离更远，则说明有物体挡在了它前面，那么它就不会被渲染，如果更近，那么这个片元就应该覆盖掉颜色缓冲中的值，并把它的深度值更新到深度缓冲中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能会有读者会问：为什么透明度混合需要关闭深度写入呢？我们可以同过一张图来解释&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/01.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;平面 1 和 平面 2 都是在摄像机视线上，平面 1 是透明的而平面 2 是不透明的且平面 1 挡住了平面 2。理论上我们应该可以透过平面 1 来看到平面 2。事实上，如果没有关闭深度写入，平面 1 和 平面 2在渲染时进行深度测试，测试结果为平面 2更远，所以平面 2不会被渲染到屏幕上，即我们看不到平面 2。这很显然是不符合我们所要的。&lt;/p&gt;

&lt;h2&gt;一. 渲染顺序&lt;/h2&gt;

&lt;h3&gt;1.1 渲染顺序的重要性&lt;/h3&gt;
&lt;p&gt;前文说过，关闭了深度写入后，渲染顺序就变得十分重要，为什么这么说呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/02.png&quot; alt=&quot;&quot; width=&quot;678&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如图，A 和 B渲染顺序不一样。有两种情况&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;先渲染 B 再 渲染 A。此时深度缓冲中没有数据，B 直接写入它的颜色缓冲和深度缓冲；然后渲染 A，A进行深度测试，结果为 A 更近，所以此时会用 A 的透明度与颜色缓冲中值进行混合，得到正确的半透明效果。&lt;/li&gt;
&lt;li&gt;先渲染 A 再 渲染 B。此时深度缓冲中并没有数据，&lt;strong&gt;A 会写入颜色缓冲，但不会写入深度缓冲（因为关闭了深度写入）&lt;/strong&gt;；然后渲染 B ，&lt;strong&gt;B 进行深度测试，而此时深度缓冲中并没有数据，所以  B 会直接写进颜色缓冲和深度缓冲，就会覆盖掉颜色缓冲中 A 的颜色&lt;/strong&gt;，所以最终渲染出来，从视觉上是 B 在 A 的前面&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;1.2 渲染队列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Unity 中提供了 &lt;strong&gt;渲染队列，&lt;/strong&gt;并用整数索引表示渲染队列，&lt;strong&gt;索引越小，越早渲染&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/03.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;137&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;也可以使用 SubShader 中的 Queue 标签来决定该模型属于哪个渲染队列&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;名称&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;队列索引号&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Background&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;这个队列会在任何队列 之前被渲染，通常用来渲染绘制在背景的物体&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Geometry&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2000&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;默认的队列，非透明物体使用此队列&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Alpha Test&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2450&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;进行透明度测试的物体使用的队列&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Overlay&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;3000&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;按后往前顺序渲染，使用透明度混合的物体应该使用此队列&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;4000&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;在最后渲染的物体使用此队列&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h2&gt;二. 透明度测试&lt;/h2&gt;
&lt;p&gt;新建一个工程，去掉天空盒；新建一个Material 和 shader ，命名为 Alpha Test；新建一个 cube&lt;/p&gt;

&lt;p&gt;需要提前了解的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; ZWrite Off 用于关闭深度写入，可以写在 Pass里面，也可以写在 SubShader 里，如果是后者，那么就会对所有的 Pass 产生效果，即所有的 Pass 都会关闭深度写入。&lt;/li&gt;
&lt;li&gt;我们在后面的代码将会使用 clip 函数进行透明度测试。参数为裁剪时使用的标量或矢量，如果参数的任一分量为负数，就舍弃当前像素的输出颜色。我们同样可以在MSDN上找到它的定义&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://github.com/BFXYMY/ShaderPictureForBlog/blob/master/%E9%80%8F%E6%98%8E/04.png?raw=true&quot; alt=&quot;&quot; width=&quot;848&quot; height=&quot;647&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/05.png&quot; alt=&quot;&quot; width=&quot;840&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I. 创建一个场景，去掉天空盒；新建一个 Material 和 shader ，命名为 Alpha Test；创建一个 Cube；准备一张不同区域透明度不同的透明纹理（读者可以在本文最下方下载）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;II. 定义 Propreties 语义块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/06.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;107&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Properites 语义块并没有什么特别的属性，_Cutoff 属性用来控制透明度，范围为【0,1】，因为纹理像素的透明度范围就在此范围。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;III.  指定渲染队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/07.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;28&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 SubShader 中定义一个 Tags，IgnoreProjector 决定 shader 是否会受投影器的影响，RenderType 可以让 shader 归入提前定义的组（这里是 TransparentCutout）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IV. 定义与 Properties 中相匹配的变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/08.png&quot; alt=&quot;&quot; width=&quot;213&quot; height=&quot;102&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;V. 定义输入输出结构体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/09.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VI. 定义顶点着色器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/10.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;271&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; TRANSFORM_TEX 函数我们在之前已经解释过了，如果读者对此不太了解，可以翻看我的上一篇文章&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VII. 定义片元着色器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/11.png&quot; alt=&quot;&quot; width=&quot;798&quot; height=&quot;321&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;这些代码相信读者都不陌生，这里 clip 函数对不符合条件的片元舍弃了，即不渲染了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VIII. 最后设置 FallBack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/12.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;44&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Shader &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unity/01-AlphaTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Properties {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         _Color (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Tint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         _MainTex (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Tex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2D) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         _Cutoff(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alpha Cutoff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Range(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)) = &lt;span&gt;0.5&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    SubShader {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AlphaTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IgnoreProjector&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RenderType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TransparentCutout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        Cull Off
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        Pass
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt;17&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnityCG.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            fixed4 _Color;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            sampler2D _MainTex;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            float4 _MainTex_ST;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;fixed&lt;/span&gt;&lt;span&gt; _Cutoff;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                float4 texcoord : TEXCOORD0;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                float2 uv : TEXCOORD2;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld,v.vertex).xyz;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;                 o.uv =&lt;span&gt; TRANSFORM_TEX(v.texcoord,_MainTex);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_TARGET0
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 fixed3 worldLightDir =&lt;span&gt; normalize(UnityWorldSpaceLightDir(i.worldPos));
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;                 fixed4 texcolor =&lt;span&gt; tex2D(_MainTex,i.uv);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;                 clip(texcolor.a -&lt;span&gt; _Cutoff);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;                 fixed3 albedo = texcolor.rgb *&lt;span&gt; _Color.rgb;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz *&lt;span&gt; albedo;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 fixed3 diffues = _LightColor0.rgb * albedo * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,dot(worldNormal,worldLightDir));
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4(ambient + diffues,&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            ENDCG
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         FallBack &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent/Cutout/VertexLit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;IX. 保存，回到Unity，查看效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同 Cutoff 的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/13.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到通过透明度测试实现的效果在边界处并不理想，有锯齿，而为了解决这个问题，我们就应该使用透明度混合，来得到更柔和的效果。&lt;/p&gt;


&lt;h2&gt;三. 透明度混合&lt;/h2&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;3.1 透明度混合的实现&lt;/h3&gt;
&lt;p&gt;回想一下，我们前面所说的透明度混合的原理：&lt;strong&gt;把自身的颜色和颜色缓冲中的颜色进行混合，得到新的颜色&lt;/strong&gt;。既然要混合，那就需要混合命令 &lt;strong&gt;Blend&lt;/strong&gt;。混合语义有许多，我们稍后会具体地介绍，在这里，我们使用 &lt;strong&gt;Blend SrcFactor DstFactor&lt;/strong&gt; 这条语义，其中 Blend 是操作，SrcFactor，DstFactor 是因子；我们把 SrcFactor 设为 SrcAlpha，DstFactor 设为 OneMinusSrcAlpha。即我们即将使用的混合语义代码为 &lt;strong&gt;Blend SrcAlpha OneMinusSrcAlpha，&lt;/strong&gt;这相当于，混合后颜色为：&lt;/p&gt;
&lt;p&gt;               &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20DstColor_%7Bnew%7D%20%3D%20%5C%20SrcAlpha%20%5Ctimes%20%5C%20SrcColor%20&amp;amp;plus;%20%281%20-%20SrcAlpha%29%20%5Ctimes%20DstColor_%7Bold%7D%7D&quot; alt=&quot;{\color{Blue} \ DstColor_{new} = \ SrcAlpha \times \ SrcColor + (1 - SrcAlpha) \times DstColor_{old}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不明白这条公式的读者不用着急，我们稍后会具体解释，这里先知道我们即将使用这条式子便可。&lt;/p&gt;
&lt;p&gt; 代码和透明度测试类似，所以这里只列出需要注意的修改的地方。&lt;/p&gt;



&lt;p&gt;I. 新建一个 Material 和 shader ，命名为 Alpha Blend；创建一个 Cube；使用同一张透明纹理。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II.修改 Properties 语义块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/14.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;111&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中 _AlphaScale 用来控制整体的透明度。当然也要在CG代码片中定义与其对应的变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;III. 修改 Tags&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/15.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;34&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;IV. 关闭深度写入和开启混合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/16.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;113&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;V.修改片元着色器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/17.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;275&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们用透明纹理的透明通道和 _AlphaScale 来控制整体透明度&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VI. 修改 FallBack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/18.png&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;52&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Shader &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unity/02-AlphaBlend&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Properties {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         _Color (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Tint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         _MainTex (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Tex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2D) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         _AlphaScale(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alpha Scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Range(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)) = &lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    SubShader {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IgnoreProjector&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RenderType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        Pass
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            ZWrite Off
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            Blend SrcAlpha OneMinusSrcAlpha
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt;20&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnityCG.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            fixed4 _Color;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            sampler2D _MainTex;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            float4 _MainTex_ST;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;fixed&lt;/span&gt;&lt;span&gt; _AlphaScale;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                float4 texcoord : TEXCOORD0;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                float2 uv : TEXCOORD2;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld,v.vertex).xyz;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;                 o.uv =&lt;span&gt; TRANSFORM_TEX(v.texcoord,_MainTex);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_TARGET0
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 fixed3 worldLightDir =&lt;span&gt; normalize(UnityWorldSpaceLightDir(i.worldPos));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;                 fixed4 texcolor =&lt;span&gt; tex2D(_MainTex,i.uv);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;                 fixed3 albedo = texcolor.rgb *&lt;span&gt; _Color.rgb;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz *&lt;span&gt; albedo;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                 fixed3 diffues = _LightColor0.rgb * albedo * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,dot(worldNormal,worldLightDir));
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4(ambient + diffues,texcolor.a *&lt;span&gt; _AlphaScale);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;            ENDCG
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         FallBack &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent/VertexLit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;strong&gt;VII. 保存，回到Unity，查看效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 不同  _AlphaScale 的效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/19.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对比透明度测试，我们可以看到透明度混合更加柔和平滑。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt; 3.2 混合命令&lt;/strong&gt;&lt;/h3&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Blend SrcFactor DstFactor&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;开启混合，设置因子。源颜色 x ScrFacor  + 目标颜色 x DstFactor，结构存入颜色缓冲&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;Blend SrcFactor DstFactor，SrcFactorA DstFactorA&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;和上面类似，只是混合透明通道的因子不同&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 混合有两个操作数：&lt;strong&gt;源颜色（source color）&lt;/strong&gt;和 &lt;strong&gt;目标颜色（destination color）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;源颜色。指片元着色器产生的颜色值，用 S 表示。&lt;/li&gt;
&lt;li&gt;目标颜色。指颜色缓冲中的值，用 D 表示。&lt;/li&gt;
&lt;li&gt;两者混合后，得到的新颜色用 O 表示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而上面三者都包含了 &lt;strong&gt;RGBA&lt;/strong&gt; 通道。&lt;/p&gt;
&lt;p&gt;除了 &lt;strong&gt;Blend Off&lt;/strong&gt; 以外&lt;strong&gt;，&lt;/strong&gt;使用Blend 命令，Unity 会为我们开启混合，因为只有开启了混合，混合命令才起效。&lt;/p&gt;
&lt;p&gt;混合命令由 &lt;strong&gt;操作&lt;/strong&gt; 和 &lt;strong&gt;因子&lt;/strong&gt; 组成，操作默认是使用 &lt;strong&gt;加操作，&lt;/strong&gt;而为了混合RGB 通道 和 A通道，所以我们需要 4 个因子&lt;/p&gt;
&lt;p&gt;以混合命令 Blend SrcFactor DstFactor 为例，&lt;strong&gt;默认为加操作，SrcFactor 为源颜色， DstFactor 为目标颜色&lt;/strong&gt;，然后计算&lt;/p&gt;
&lt;p&gt;                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20O_%7Brgb%7D%20%3D%20SrcFactor%20%5Ctimes%20S_%7Brgb%7D%20&amp;amp;plus;%20DstFactor%20%5Ctimes%20D_%7Brgb%7D%7D&quot; alt=&quot;{\color{Blue} \ O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20O_%7Ba%7D%20%3D%20SrcFactor%20%5Ctimes%20S_%7Ba%7D%20&amp;amp;plus;%20DstFactor%20%5Ctimes%20D_%7Ba%7D%7D&quot; alt=&quot;{\color{Blue} \ O_{a} = SrcFactor \times S_{a} + DstFactor \times D_{a}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面是 ShaderLab 支持的一些混合因子：&lt;/p&gt;
&lt;p&gt; 混合有两个操作数：&lt;strong&gt;源颜色（source color）&lt;/strong&gt;和 &lt;strong&gt;目标颜色（destination color）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;源颜色。指片元着色器产生的颜色值，用 S 表示。&lt;/li&gt;
&lt;li&gt;目标颜色。指颜色缓冲中的值，用 D 表示。&lt;/li&gt;
&lt;li&gt;两者混合后，得到的新颜色用 O 表示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而上面三者都包含了 &lt;strong&gt;RGBA&lt;/strong&gt; 通道。&lt;/p&gt;
&lt;p&gt;除了 &lt;strong&gt;Blend Off&lt;/strong&gt; 以外&lt;strong&gt;，&lt;/strong&gt;使用Blend 命令，Unity 会为我们开启混合，因为只有开启了混合，混合命令才起效。&lt;/p&gt;
&lt;p&gt;混合命令由 &lt;strong&gt;操作&lt;/strong&gt; 和 &lt;strong&gt;因子&lt;/strong&gt; 组成，操作默认是使用 &lt;strong&gt;加操作，&lt;/strong&gt;而为了混合RGB 通道 和 A通道，所以我们需要 4 个因子&lt;/p&gt;
&lt;p&gt;以混合命令 Blend SrcFactor DstFactor 为例，&lt;strong&gt;默认为加操作，SrcFactor 为源颜色， DstFactor 为目标颜色&lt;/strong&gt;，然后计算&lt;/p&gt;
&lt;p&gt;                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20O_%7Brgb%7D%20%3D%20SrcFactor%20%5Ctimes%20S_%7Brgb%7D%20&amp;amp;plus;%20DstFactor%20%5Ctimes%20D_%7Brgb%7D%7D&quot; alt=&quot;{\color{Blue} \ O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20O_%7Ba%7D%20%3D%20SrcFactor%20%5Ctimes%20S_%7Ba%7D%20&amp;amp;plus;%20DstFactor%20%5Ctimes%20D_%7Ba%7D%7D&quot; alt=&quot;{\color{Blue} \ O_{a} = SrcFactor \times S_{a} + DstFactor \times D_{a}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面是 ShaderLab 支持的一些混合因子：&lt;/p&gt;

&lt;p&gt; 混合有两个操作数：&lt;strong&gt;源颜色（source color）&lt;/strong&gt;和 &lt;strong&gt;目标颜色（destination color）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;源颜色。指片元着色器产生的颜色值，用 S 表示。&lt;/li&gt;
&lt;li&gt;目标颜色。指颜色缓冲中的值，用 D 表示。&lt;/li&gt;
&lt;li&gt;两者混合后，得到的新颜色用 O 表示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而上面三者都包含了 &lt;strong&gt;RGBA&lt;/strong&gt; 通道。&lt;/p&gt;
&lt;p&gt;除了 &lt;strong&gt;Blend Off&lt;/strong&gt; 以外&lt;strong&gt;，&lt;/strong&gt;使用Blend 命令，Unity 会为我们开启混合，因为只有开启了混合，混合命令才起效。&lt;/p&gt;
&lt;p&gt;混合命令由 &lt;strong&gt;操作&lt;/strong&gt; 和 &lt;strong&gt;因子&lt;/strong&gt; 组成，操作默认是使用 &lt;strong&gt;加操作，&lt;/strong&gt;而为了混合RGB 通道 和 A通道，所以我们需要 4 个因子&lt;/p&gt;
&lt;p&gt;以混合命令 Blend SrcFactor DstFactor 为例，&lt;strong&gt;默认为加操作，SrcFactor 为源颜色， DstFactor 为目标颜色&lt;/strong&gt;，然后计算&lt;/p&gt;
&lt;p&gt;                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20O_%7Brgb%7D%20%3D%20SrcFactor%20%5Ctimes%20S_%7Brgb%7D%20&amp;amp;plus;%20DstFactor%20%5Ctimes%20D_%7Brgb%7D%7D&quot; alt=&quot;{\color{Blue} \ O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                              &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B150%7D%20%7B%5Ccolor%7BBlue%7D%20%5C%20O_%7Ba%7D%20%3D%20SrcFactor%20%5Ctimes%20S_%7Ba%7D%20&amp;amp;plus;%20DstFactor%20%5Ctimes%20D_%7Ba%7D%7D&quot; alt=&quot;{\color{Blue} \ O_{a} = SrcFactor \times S_{a} + DstFactor \times D_{a}}&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面是 ShaderLab 支持的一些混合因子：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;1&quot; cellpadding=&quot;1&quot; data-cke-table-faked-selection-table=&quot;&quot;&gt;&lt;thead readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;th class=&quot;cke_table-faked-selection&quot; scope=&quot;col&quot;&gt;参数&lt;/th&gt;
&lt;th class=&quot;cke_table-faked-selection&quot; scope=&quot;col&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;One&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;因子为1&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;Zero&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;因子为0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;SrcColor&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;源颜色值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;SrcAlpha&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;源颜色的透明通道的值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;DstColor&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;目标颜色值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;DstAlpha&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;目标颜色的透明通道的值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;OneMinusSrcColor&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;1-源颜色值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;OneMinusSrcAlpha&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;1-源颜色的透明通道的值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;OneMinusDstColor&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;1-目标颜色值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;OneMinusDstAlpha&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;cke_table-faked-selection&quot;&gt;&lt;span&gt;1-目标颜色的透明通道的值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;
&lt;p&gt;读者可以自行选择因子来试试效果&lt;/p&gt;


&lt;h2&gt;四. 双面渲染&lt;/h2&gt;
&lt;p&gt;一般来说，如果一个物体是透明的，要么我们应该可以看到它的内部和它的任一个面，但前面我们实现的透明中并没有实现这个效果，因为 Unity 在默认引擎下剔除了物体背面（&lt;strong&gt;是相对于摄像机方向的背面，而不是世界坐标中前后左右的背面&lt;/strong&gt;），不渲染。而剔除的指令为&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cull Back | Front | Off&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了实现双面渲染，我们可以这样实现：设置两个 &lt;strong&gt;Pass ，&lt;/strong&gt;一个只渲染前面，一个只渲染背面。不过需要注意的是，由于开启了深度测试，所以要注意渲染顺序，&lt;strong&gt;要先渲染背面，再渲染正面，&lt;/strong&gt;这样就能确保背面会被渲染出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/20.png&quot; alt=&quot;&quot; width=&quot;823&quot; height=&quot;350&quot;/&gt; &lt;/p&gt;
&lt;p&gt;两个 Pass 中，除了 Cull 指令不一样外，其余代码都是和透明度混合中的代码一样，所以，这里直接给出完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Upgrade NOTE: replaced '_Object2World' with 'unity_ObjectToWorld'&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; Shader &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unity/04-AlphaBlendBothSide&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;    Properties {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         _Color (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Tint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Color) = (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         _MainTex (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main Tex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2D) = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         _AlphaScale(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alpha Scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Range(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)) = &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;    SubShader {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AlphaTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IgnoreProjector&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RenderType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        Pass
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            Cull Front
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            ZWrite Off
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;            Blend SrcAlpha OneMinusSrcAlpha
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt; 25&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnityCG.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            fixed4 _Color;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            sampler2D _MainTex;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;            float4 _MainTex_ST;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;fixed&lt;/span&gt;&lt;span&gt; _AlphaScale;
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;                float4 texcoord : TEXCOORD0;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;                float2 uv : TEXCOORD2;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld,v.vertex).xyz;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;                 o.uv =&lt;span&gt; TRANSFORM_TEX(v.texcoord,_MainTex);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_TARGET0
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 fixed3 worldLightDir =&lt;span&gt; normalize(UnityWorldSpaceLightDir(i.worldPos));
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;                 fixed4 texcolor =&lt;span&gt; tex2D(_MainTex,i.uv);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;                 fixed3 albedo = texcolor.rgb *&lt;span&gt; _Color.rgb;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz *&lt;span&gt; albedo;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 fixed3 diffues = _LightColor0.rgb * albedo * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,dot(worldNormal,worldLightDir));
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4(ambient + diffues,texcolor.a *&lt;span&gt; _AlphaScale);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;            ENDCG
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        Pass
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             Tags{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LightMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ForwardBase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;            Cull Back
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            ZWrite Off
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            Blend SrcAlpha OneMinusSrcAlpha
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            CGPROGRAM
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; vertex vert
&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;#pragma&lt;/span&gt; fragment frag
&lt;span&gt; 96&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lighting.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnityCG.cginc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            fixed4 _Color;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            sampler2D _MainTex;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            float4 _MainTex_ST;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;fixed&lt;/span&gt;&lt;span&gt; _AlphaScale;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; a2v
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                float4 vertex : POSITION;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                float3 normal : NORMAL;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                float4 texcoord : TEXCOORD0;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; v2f
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                float4 pos : SV_POSITION;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                float3 worldNormal : TEXCOORD0;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                float3 worldPos : TEXCOORD1;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;                float2 uv : TEXCOORD2;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            v2f vert(a2v v)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                v2f o;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 o.pos =&lt;span&gt; UnityObjectToClipPos(v.vertex);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 o.worldNormal =&lt;span&gt; UnityObjectToWorldNormal(v.normal);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 o.worldPos =&lt;span&gt; mul(unity_ObjectToWorld,v.vertex).xyz;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;                 o.uv =&lt;span&gt; TRANSFORM_TEX(v.texcoord,_MainTex);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;            fixed4 frag(v2f i) : SV_TARGET0
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 fixed3 worldNormal =&lt;span&gt; normalize(i.worldNormal);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 fixed3 worldLightDir =&lt;span&gt; normalize(UnityWorldSpaceLightDir(i.worldPos));
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;                 fixed4 texcolor =&lt;span&gt; tex2D(_MainTex,i.uv);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;                 fixed3 albedo = texcolor.rgb *&lt;span&gt; _Color.rgb;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz *&lt;span&gt; albedo;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 fixed3 diffues = _LightColor0.rgb * albedo * max(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,dot(worldNormal,worldLightDir));
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; fixed4(ambient + diffues,texcolor.a *&lt;span&gt; _AlphaScale);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            ENDCG
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;         FallBack &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent/VertexLit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 现在来查看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/21.gif&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 现在我们可以清楚地看到物体的内部了。&lt;/p&gt;


&lt;h2&gt;五. 总结&lt;/h2&gt;
&lt;p&gt;透明效果是十分常见且有用的一种实现，我们可以利用它来实现很多有趣的效果。要实现透明，更多地是对渲染的一种理解。本文只是对Unity中渲染的一些基础解释，希望能对读者有所帮助。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/BFXYMY/Shaders/blob/master/Alpha.zip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;本文所用透明纹理及shader&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/BFXYMY/ShaderPictureForBlog/master/%E9%80%8F%E6%98%8E/22.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Sep 2018 13:35:00 +0000</pubDate>
<dc:creator>爱喝柠檬的二哈</dc:creator>
<og:description>笔者使用的是 Unity 2018.2.0f2 + VS2017，建议读者使用与 Unity 2018 相近的版本，避免一些因为版本不一致而出现的问题 前言 相信读者对透明效果都不陌生，因为透明效果是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BFXYMY/p/9717734.html</dc:identifier>
</item>
<item>
<title>基础排序算法详解与优化 - GodBMW</title>
<link>http://www.cnblogs.com/geyouneihan/p/9733206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9733206.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章图片存储在&lt;code&gt;GitHub&lt;/code&gt;，网速不佳的朋友，请看&lt;a href=&quot;https://godbmw.com/passage/56&quot;&gt;《基础排序算法详解与优化》&lt;/a&gt; 或者 来我的技术小站 &lt;a href=&quot;https://godbmw.com/&quot;&gt;godbmw.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;谈谈基础排序&quot;&gt;1. 谈谈基础排序&lt;/h2&gt;
&lt;p&gt;常见的基础排序有选择排序、冒泡排序和插入排序。众所周知，他们的时间复杂度是 O(n*n)。&lt;/p&gt;
&lt;p&gt;但是，现在要重新认识一下基础排序算法，尤其是“插入排序”：在近乎有序的情况下，插入排序的时间复杂度可以降低到 O(n)的程度。&lt;/p&gt;
&lt;p&gt;因此，在处理系统日志的任务中，因为日志记录是按照时间排序，但偶尔会有几条是乱序，此时使用插入排序再好不过。而对于高级排序算法，一个常见的优化就是利用插入排序做局部数据排序优化。&lt;/p&gt;
&lt;h2 id=&quot;算法实现&quot;&gt;2. 算法实现&lt;/h2&gt;
&lt;p&gt;排序算法被封装在了&lt;code&gt;SortBase.h&lt;/code&gt;中的&lt;code&gt;SortBase&lt;/code&gt;命名空间中，以实现模板化和防止命名冲突。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;2.1 选择排序&lt;/h3&gt;
&lt;p&gt;假设从小到大排序，那么，刚开始指针指向第一个数据，选择从当前指针所指向数据到最后一个数据间最小的数据，将它放在指针位置。&lt;/p&gt;
&lt;p&gt;指针后移一位，重复上述步骤，直到指针移动到最后一个数据。&lt;/p&gt;
&lt;p&gt;这种重复保证了每次，指针前面的数据都是从小到大排好顺序的数据。所以，从头到尾扫描一遍，自然排好序了。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
void selectionSort(T arr[], int n) {
  int minIndex = -1;
  for(int i = 0; i &amp;lt; n; i++) {
    minIndex = i;
    for(int j = i+1; j &amp;lt; n; ++j) {
      if(arr[j] &amp;lt; arr[minIndex]) {
        minIndex = j;
      }
    }
    swap(arr[i], arr[minIndex]);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;2.2 冒泡排序&lt;/h3&gt;
&lt;p&gt;假设排序是从小到大排序。&lt;/p&gt;
&lt;p&gt;我一直感觉冒泡排序是和选择排序反过来了（如果说错请指正）。因为选择排序是每次选择最小的数据，放到当前指针位置；而冒泡排序是把不停交换相邻数据，直到把最大的数据“冒泡”到应该到的位置。&lt;/p&gt;
&lt;p&gt;优化的地方是：记录每次交换的最后位置，在此之后的元素在下一轮扫描中均不考虑。因为交换的最后位置之后的元素已经是从小到大排序好了的。&lt;/p&gt;
&lt;p&gt;在实现过程中，因为需要不停交换相邻两个数据，因此，消耗了很多额外时间。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
void bubbleSort(T arr[], int n) {
  int newn;
  do {
    newn = 0;
    for(int i = 1; i &amp;lt; n; i++) {
      if(arr[i-1] &amp;gt; arr[i]) {
        swap(arr[i-1], arr[i]);
        // 优化
        newn = i;
      }
    }
    n = newn; // 不再考虑 newn 后的数据
  } while (newn &amp;gt; 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插入排序&quot;&gt;2.3 插入排序&lt;/h3&gt;
&lt;p&gt;插入排序容易和上面两个算法搞混。可以类比打扑克牌时候的对扑克牌进行排序：我们会先排序前 1 张、然后是前 2 张、前 3 张 ... 一直到前 n 张。算法实现显然是双重循环，如下所示：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
void insertionSort(T arr[], int n) {
  for(int i = 1; i &amp;lt; n; i++) {
    for(int j = i ; j &amp;gt; 0; j--) {
      if(arr[j - 1] &amp;gt; arr[j]) {
        swap(arr[j], arr[j - 1]);
      } else {
        break; // 优化：已经保证之前都是正常排序，直接跳出即可
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，插入排序也能在局部排好序的情况下跳出循环（代码中的优化），以减少算法消耗时间。&lt;/p&gt;
&lt;p&gt;然而上述算法其实跑分并比不上选择排序，因为&lt;code&gt;swap(arr[j], arr[j - 1]);&lt;/code&gt;这行代码交换了一次，相当于赋值 3 次，在大数据量情况下，比较消耗时间。&lt;/p&gt;
&lt;p&gt;优化: 内层循环，每次保存&lt;code&gt;arr[i]&lt;/code&gt;, 在检测到当前数据大于&lt;code&gt;arr[i]&lt;/code&gt;的时候，后移一位当前元素&lt;code&gt;arr[j] = arr[j-1];&lt;/code&gt;。当跳出内层循环时，直接将保存的&lt;code&gt;arr[i]&lt;/code&gt;赋值给&lt;code&gt;arr[j]&lt;/code&gt;即可。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
void insertionSort(T arr[], int n) {
  for(int i = 1; i &amp;lt; n; i++) {
    T e = arr[i];
    int j = i ;
    for(; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1] &amp;gt; e; j--) {
      arr[j] = arr[j-1];
    }
    arr[j] = e;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;3. 性能测试&lt;/h2&gt;
&lt;p&gt;首先利用 &lt;code&gt;SortTestHelper::generateRandomArray&lt;/code&gt;函数生成大量无序随机数据，然后进行排序和时间测定。代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;SortHelper.h&quot;
#include &quot;SortBase.h&quot;
#include &quot;SortAdvance.h&quot;

using namespace std;

int main() {
  int n = 50000, left = 0, right = n;

  int *arr = SortTestHelper::generateRandomArray&amp;lt;int&amp;gt;(n, left, right);
  int *brr = SortTestHelper::copyArray&amp;lt;int&amp;gt;(arr, n);
  int *crr = SortTestHelper::copyArray&amp;lt;int&amp;gt;(arr, n);
  SortTestHelper::testSort&amp;lt;int&amp;gt;(arr, n, SortBase::selectionSort&amp;lt;int&amp;gt;, &quot;selection sort&quot;);
  SortTestHelper::testSort&amp;lt;int&amp;gt;(brr, n, SortBase::insertionSort&amp;lt;int&amp;gt;, &quot;insertion sort&quot;);
  SortTestHelper::testSort&amp;lt;int&amp;gt;(crr, n, SortBase::bubbleSort&amp;lt;int&amp;gt;, &quot;bubble sort&quot;);
  delete[] brr;
  delete[] arr;
  delete[] crr;

  return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了大量无序随机数据，类似于系统日志的数据就是基本有序的大量数据。此时，测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &quot;SortHelper.h&quot;
#include &quot;SortBase.h&quot;
#include &quot;SortAdvance.h&quot;

using namespace std;

int main() {

  int n = 50000, left = 0, right = n;
  int *arr = SortTestHelper::generateNearlyOrderedArray&amp;lt;int&amp;gt;(n, 10);
  int *brr = SortTestHelper::copyArray&amp;lt;int&amp;gt;(arr, n);
  int *crr = SortTestHelper::copyArray&amp;lt;int&amp;gt;(arr, n);
  SortTestHelper::testSort&amp;lt;int&amp;gt;(arr, n, SortBase::selectionSort&amp;lt;int&amp;gt;, &quot;selection sort&quot;);
  SortTestHelper::testSort&amp;lt;int&amp;gt;(brr, n, SortBase::insertionSort&amp;lt;int&amp;gt;, &quot;insertion sort&quot;);
  SortTestHelper::testSort&amp;lt;int&amp;gt;(crr, n, SortBase::bubbleSort&amp;lt;int&amp;gt;, &quot;bubble sort&quot;);
  delete[] brr;
  delete[] arr;
  delete[] crr;

  return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图所示，插入排序的只用了 0.002 秒。在这种数据情况下，插入排序的时间复杂度近似 O(N)，绝对快于高级排序的 O(NlogN)。除此之外，还保证了稳定性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/3.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;感谢&quot;&gt;4. 感谢&lt;/h2&gt;
&lt;p&gt;本篇博客是总结于慕课网的&lt;a href=&quot;https://coding.imooc.com/class/chapter/71.html&quot;&gt;《学习算法思想 修炼编程内功》&lt;/a&gt;的笔记，liuyubobobo 老师人和讲课都很 nice，欢迎去买他的课程。&lt;/p&gt;
&lt;h2 id=&quot;更多内容&quot;&gt;5. 更多内容&lt;/h2&gt;
</description>
<pubDate>Sun, 30 Sep 2018 12:05:00 +0000</pubDate>
<dc:creator>GodBMW</dc:creator>
<og:description>常见的基础排序有选择排序、冒泡排序和插入排序。众所周知，他们的时间复杂度是 O(n\*n)。 但是，现在要重新认识一下基础排序算法，尤其是“插入排序”：在近乎有序的情况下，插入排序的时间复杂度可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9733206.html</dc:identifier>
</item>
</channel>
</rss>