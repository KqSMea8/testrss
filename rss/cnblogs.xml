<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kafka 使用Java实现数据的生产和消费demo - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8371127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8371127.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/xuwujing/p/8361629.html&quot;&gt;上一篇&lt;/a&gt;中讲述如何搭建kafka集群，本篇则讲述如何简单的使用 kafka 。不过在使用kafka的时候，还是应该简单的了解下kafka。&lt;/p&gt;
&lt;h2 id=&quot;kafka的介绍&quot;&gt;Kafka的介绍&lt;/h2&gt;
&lt;p&gt;Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。&lt;br/&gt;Kafka 有如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。&lt;/li&gt;
&lt;li&gt;高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。&lt;/li&gt;
&lt;li&gt;支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。&lt;/li&gt;
&lt;li&gt;同时支持离线数据处理和实时数据处理。&lt;/li&gt;
&lt;li&gt;Scale out：支持在线水平扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;kafka的术语&quot;&gt;kafka的术语&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker。&lt;/li&gt;
&lt;li&gt;Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）&lt;/li&gt;
&lt;li&gt;Partition：Partition是物理上的概念，每个Topic包含一个或多个Partition。&lt;/li&gt;
&lt;li&gt;Producer：负责发布消息到Kafka broker。&lt;/li&gt;
&lt;li&gt;Consumer：消息消费者，向Kafka broker读取消息的客户端。&lt;/li&gt;
&lt;li&gt;Consumer Group:每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;kafka核心api&quot;&gt;kafka核心Api&lt;/h3&gt;
&lt;p&gt;kafka有四个核心API&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序使用producer API发布消息到1个或多个topic中。&lt;/li&gt;
&lt;li&gt;应用程序使用consumer API来订阅一个或多个topic,并处理产生的消息。&lt;/li&gt;
&lt;li&gt;应用程序使用streams API充当一个流处理器,从1个或多个topic消费输入流,并产生一个输出流到1个或多个topic,有效地将输入流转换到输出流。&lt;/li&gt;
&lt;li&gt;connector API允许构建或运行可重复使用的生产者或消费者,将topic链接到现有的应用程序或数据系统。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例图如下:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128125655810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;kafka-应用场景&quot;&gt;kafka 应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;构建可在系统或应用程序之间可靠获取数据的实时流数据管道。&lt;/li&gt;
&lt;li&gt;构建实时流应用程序，可以转换或响应数据流。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上介绍参考kafka官方文档。&lt;/p&gt;
&lt;h2 id=&quot;开发准备&quot;&gt;开发准备&lt;/h2&gt;
&lt;p&gt;如果我们要开发一个kafka的程序，应该做些什么呢？&lt;br/&gt;首先，在搭建好kafka环境之后，我们要考虑的是我们是生产者还是消费者，也就是消息的发送者还是接受者。&lt;br/&gt;不过在本篇中，生产者和消费者都会进行开发和讲解。&lt;/p&gt;
&lt;p&gt;在大致的了解kafka之后，我们来开发第一个程序。&lt;br/&gt;这里用的开发语言是Java，构建工具Maven。&lt;br/&gt;Maven的依赖如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;kafka_2.12&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; 
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;kafka-clients&amp;lt;/artifactId&amp;gt;
              &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;kafka-streams&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;kafka-producer&quot;&gt;Kafka Producer&lt;/h2&gt;
&lt;p&gt;在开发生产的时候，先简单的介绍下kafka各种配置说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bootstrap.servers： kafka的地址。&lt;/li&gt;
&lt;li&gt;acks:消息的确认机制，默认值是0。&lt;br/&gt;acks=0：如果设置为0，生产者不会等待kafka的响应。&lt;br/&gt;acks=1：这个配置意味着kafka会把这条消息写到本地日志文件中，但是不会等待集群中其他机器的成功响应。&lt;br/&gt;acks=all：这个配置意味着leader会等待所有的follower同步完成。这个确保消息不会丢失，除非kafka集群中所有机器挂掉。这是最强的可用性保证。&lt;/li&gt;
&lt;li&gt;retries：配置为大于0的值的话，客户端会在消息发送失败时重新发送。&lt;/li&gt;
&lt;li&gt;batch.size:当多条消息需要发送到同一个分区时，生产者会尝试合并网络请求。这会提高client和生产者的效率。&lt;/li&gt;
&lt;li&gt;key.serializer: 键序列化，默认org.apache.kafka.common.serialization.StringDeserializer。&lt;/li&gt;
&lt;li&gt;value.deserializer:值序列化，默认org.apache.kafka.common.serialization.StringDeserializer。&lt;br/&gt;...&lt;br/&gt;还有更多配置，可以去查看官方文档，这里就不在说明了。&lt;br/&gt;那么我们kafka 的producer配置如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        Properties props = new Properties();
        props.put(&quot;bootstrap.servers&quot;, &quot;master:9092,slave1:9092,slave2:9092&quot;);
        props.put(&quot;acks&quot;, &quot;all&quot;);
        props.put(&quot;retries&quot;, 0);
        props.put(&quot;batch.size&quot;, 16384);
        props.put(&quot;key.serializer&quot;, StringSerializer.class.getName());
        props.put(&quot;value.serializer&quot;, StringSerializer.class.getName());
        KafkaProducer&amp;lt;String, String&amp;gt; producer = new KafkaProducer&amp;lt;String, String&amp;gt;(props);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;kafka的配置添加之后，我们便开始生产数据，生产数据代码只需如下就行:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; producer.send(new ProducerRecord&amp;lt;String, String&amp;gt;(topic,key,value));&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;topic: 消息队列的名称，可以先行在kafka服务中进行创建。如果kafka中并未创建该topic，那么便会自动创建！&lt;/li&gt;
&lt;li&gt;key:键值，也就是value对应的值，和Map类似。&lt;/li&gt;
&lt;li&gt;value:要发送的数据，数据格式为String类型的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在写好生产者程序之后，那我们先来生产吧！&lt;br/&gt;我这里发送的消息为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; String messageStr=&quot;你好，这是第&quot;+messageNo+&quot;条数据&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且只发送1000条就退出，结果如下:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128140154683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到信息成功的打印了。&lt;br/&gt;如果不想用程序进行验证程序是否发送成功，以及消息发送的准确性，可以在kafka服务器上使用命令查看。&lt;/p&gt;
&lt;h2 id=&quot;kafka-consumer&quot;&gt;Kafka Consumer&lt;/h2&gt;
&lt;p&gt;kafka消费这块应该来说是重点，毕竟大部分的时候，我们主要使用的是将数据进行消费。&lt;/p&gt;
&lt;p&gt;kafka消费的配置如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bootstrap.servers： kafka的地址。&lt;/li&gt;
&lt;li&gt;group.id：组名 不同组名可以重复消费。例如你先使用了组名A消费了kafka的1000条数据，但是你还想再次进行消费这1000条数据，并且不想重新去产生，那么这里你只需要更改组名就可以重复消费了。&lt;/li&gt;
&lt;li&gt;enable.auto.commit：是否自动提交，默认为true。&lt;/li&gt;
&lt;li&gt;auto.commit.interval.ms: 从poll(拉)的回话处理时长。&lt;/li&gt;
&lt;li&gt;session.timeout.ms:超时时间。&lt;/li&gt;
&lt;li&gt;max.poll.records:一次最大拉取的条数。&lt;/li&gt;
&lt;li&gt;auto.offset.reset：消费规则，默认earliest 。&lt;br/&gt;earliest: 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费 。&lt;br/&gt;latest: 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据 。&lt;br/&gt;none: topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常。&lt;/li&gt;
&lt;li&gt;key.serializer: 键序列化，默认org.apache.kafka.common.serialization.StringDeserializer。&lt;/li&gt;
&lt;li&gt;value.deserializer:值序列化，默认org.apache.kafka.common.serialization.StringDeserializer。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们kafka 的consumer配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Properties props = new Properties();
        props.put(&quot;bootstrap.servers&quot;, &quot;master:9092,slave1:9092,slave2:9092&quot;);
        props.put(&quot;group.id&quot;, GROUPID);
        props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);
        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);
        props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);
        props.put(&quot;max.poll.records&quot;, 1000);
        props.put(&quot;auto.offset.reset&quot;, &quot;earliest&quot;);
        props.put(&quot;key.deserializer&quot;, StringDeserializer.class.getName());
        props.put(&quot;value.deserializer&quot;, StringDeserializer.class.getName());
        KafkaConsumer&amp;lt;String, String&amp;gt; consumer = new KafkaConsumer&amp;lt;String, String&amp;gt;(props);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我这是设置的自动提交，所以消费代码如下:&lt;br/&gt;我们需要先订阅一个topic，也就是指定消费哪一个topic。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;consumer.subscribe(Arrays.asList(topic));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订阅之后，我们再从kafka中拉取数据:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ConsumerRecords&amp;lt;String, String&amp;gt; msgList=consumer.poll(1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说进行消费会使用监听，这里我们就用for(;;)来进行监听， 并且设置消费1000条就退出！&lt;br/&gt;结果如下:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128142903484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们这里已经成功消费了生产的数据了。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;那么生产者和消费者的代码如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Properties;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.StringSerializer;

/**
 * 
* Title: KafkaProducerTest
* Description: 
* kafka 生产者demo
* Version:1.0.0  
* @author pancm
* @date 2018年1月26日
 */
public class KafkaProducerTest implements Runnable {

    private final KafkaProducer&amp;lt;String, String&amp;gt; producer;
    private final String topic;
    public KafkaProducerTest(String topicName) {
        Properties props = new Properties();
        props.put(&quot;bootstrap.servers&quot;, &quot;master:9092,slave1:9092,slave2:9092&quot;);
        props.put(&quot;acks&quot;, &quot;all&quot;);
        props.put(&quot;retries&quot;, 0);
        props.put(&quot;batch.size&quot;, 16384);
        props.put(&quot;key.serializer&quot;, StringSerializer.class.getName());
        props.put(&quot;value.serializer&quot;, StringSerializer.class.getName());
        this.producer = new KafkaProducer&amp;lt;String, String&amp;gt;(props);
        this.topic = topicName;
    }

    @Override
    public void run() {
        int messageNo = 1;
        try {
            for(;;) {
                String messageStr=&quot;你好，这是第&quot;+messageNo+&quot;条数据&quot;;
                producer.send(new ProducerRecord&amp;lt;String, String&amp;gt;(topic, &quot;Message&quot;, messageStr));
                //生产了100条就打印
                if(messageNo%100==0){
                    System.out.println(&quot;发送的信息:&quot; + messageStr);
                }
                //生产1000条就退出
                if(messageNo%1000==0){
                    System.out.println(&quot;成功发送了&quot;+messageNo+&quot;条&quot;);
                    break;
                }
                messageNo++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            producer.close();
        }
    }
    
    public static void main(String args[]) {
        KafkaProducerTest test = new KafkaProducerTest(&quot;KAFKA_TEST&quot;);
        Thread thread = new Thread(test);
        thread.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;消费者:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Arrays;
import java.util.Properties;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.common.serialization.StringDeserializer;


/**
 * 
* Title: KafkaConsumerTest
* Description: 
*  kafka消费者 demo
* Version:1.0.0  
* @author pancm
* @date 2018年1月26日
 */
public class KafkaConsumerTest implements Runnable {

    private final KafkaConsumer&amp;lt;String, String&amp;gt; consumer;
    private ConsumerRecords&amp;lt;String, String&amp;gt; msgList;
    private final String topic;
    private static final String GROUPID = &quot;groupA&quot;;

    public KafkaConsumerTest(String topicName) {
        Properties props = new Properties();
        props.put(&quot;bootstrap.servers&quot;, &quot;master:9092,slave1:9092,slave2:9092&quot;);
        props.put(&quot;group.id&quot;, GROUPID);
        props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);
        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);
        props.put(&quot;session.timeout.ms&quot;, &quot;30000&quot;);
        props.put(&quot;auto.offset.reset&quot;, &quot;earliest&quot;);
        props.put(&quot;key.deserializer&quot;, StringDeserializer.class.getName());
        props.put(&quot;value.deserializer&quot;, StringDeserializer.class.getName());
        this.consumer = new KafkaConsumer&amp;lt;String, String&amp;gt;(props);
        this.topic = topicName;
        this.consumer.subscribe(Arrays.asList(topic));
    }

    @Override
    public void run() {
        int messageNo = 1;
        System.out.println(&quot;---------开始消费---------&quot;);
        try {
            for (;;) {
                    msgList = consumer.poll(1000);
                    if(null!=msgList&amp;amp;&amp;amp;msgList.count()&amp;gt;0){
                    for (ConsumerRecord&amp;lt;String, String&amp;gt; record : msgList) {
                        //消费100条就打印 ,但打印的数据不一定是这个规律的
                        if(messageNo%100==0){
                            System.out.println(messageNo+&quot;=======receive: key = &quot; + record.key() + &quot;, value = &quot; + record.value()+&quot; offset===&quot;+record.offset());
                        }
                        //当消费了1000条就退出
                        if(messageNo%1000==0){
                            break;
                        }
                        messageNo++;
                    }
                }else{  
                    Thread.sleep(1000);
                }
            }       
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            consumer.close();
        }
    }  
    public static void main(String args[]) {
        KafkaConsumerTest test1 = new KafkaConsumerTest(&quot;KAFKA_TEST&quot;);
        Thread thread1 = new Thread(test1);
        thread1.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; master、slave1、slave2 是因为我在自己的环境做了关系映射，这个可以换成服务器的IP。&lt;/p&gt;
&lt;p&gt;当然项目我放在Github上了，有兴趣的可以看看。 &lt;a href=&quot;https://github.com/xuwujing/kafka&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/kafka&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;简单的开发一个kafka的程序需要以下步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;成功搭建kafka服务器，并成功启动！&lt;/li&gt;
&lt;li&gt;得到kafka服务信息，然后在代码中进行相应的配置。&lt;/li&gt;
&lt;li&gt;配置完成之后，监听kafka中的消息队列是否有消息产生。&lt;/li&gt;
&lt;li&gt;将产生的数据进行业务逻辑处理！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;kafka介绍参考官方文档:&lt;br/&gt;&lt;a href=&quot;http://kafka.apache.org/intro&quot; class=&quot;uri&quot;&gt;http://kafka.apache.org/intro&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到此，本文就结束了，谢谢阅读！&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 06:38:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8371127.html</dc:identifier>
</item>
<item>
<title>将js进行到底：node学习笔记2 - devilyouwei</title>
<link>http://www.cnblogs.com/devilyouwei/p/8371074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/devilyouwei/p/8371074.html</guid>
<description>&lt;p&gt;所谓的“fs”就是file system！&lt;br/&gt;当下几乎任何一门编程语言都会提供对文件系统读写的API，比如c语言的open()函数。&lt;/p&gt;
&lt;p&gt;而文件系统读写API最广泛的用处就是&lt;strong&gt;CLI编程&lt;/strong&gt;。&lt;br/&gt;什么是CLI？就是client（&lt;strong&gt;客户端编程&lt;/strong&gt;），早期的电脑没有图形界面，比如UNIX时代，一般客户端指的就是terminal（命令行终端）。俗称“命令行程序”。计算机系学生c语言第一课乃至第一学期都是在做命令行编程，所有的编程只能看到黑底白字的字符在电脑屏幕前输入输出。与CLI编程对应的就是GUI编程（图形界面编程）&lt;/p&gt;
&lt;h2 id=&quot;进入正题fs-api&quot;&gt;进入正题“FS API”&lt;/h2&gt;
&lt;h3 id=&quot;io输入输出&quot;&gt;IO输入输出&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128134434464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ2NjEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同c语言一样，把输入叫&lt;strong&gt;stdin&lt;/strong&gt;，输出叫&lt;strong&gt;stdout&lt;/strong&gt;，这两个都是IO操作，合称：&lt;strong&gt;stdio&lt;/strong&gt;。stdio属于node全局对象process的一部分！&lt;/p&gt;
&lt;p&gt;哪些环境下要用到stdio？当用户需要在终端输入以及查看输出时。&lt;/p&gt;
&lt;p&gt;关于node中stdio的使用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stdout：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdout&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[33mEnter your choice: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//输出一行&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;stdout.write和console.log是不同的，console.log封装了前者并加上了换行符&quot;\n&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stdin：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resume&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//重置输入，建议每一次重新输入前加上，清空之前输入数据&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setEncoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'utf8'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//编码设置，UNIX类操作系统设置为UTF-8&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(d)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(d)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128121545510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ2NjEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：node的process对象有三个流：stdout，stderr这两个是可写流，stdin是可读流&lt;/p&gt;
&lt;h3 id=&quot;fs模块文件读写&quot;&gt;fs模块——文件读写&lt;/h3&gt;
&lt;p&gt;引入文件模块并获取暴露的API：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fs&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//fs获取暴露的API&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;同步读取&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readdirSync&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'.'&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//读取当前目录内容&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128122137455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ2NjEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前说过在node.js中最好搭配异步IO而不是这种同步IO，因为读取目录过程会阻塞之后的代码，我们看看异步读取这个目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步读取&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//定义一个事件回调函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;async&lt;/span&gt; (err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;files)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(files)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readdir&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;async)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果同上，不过是异步加载了，所以需要一个回调函数。&lt;br/&gt;你看readdir默认就是异步读取的，这是node的特色，如需强制使用同步读取就要用&lt;strong&gt;readDirSync&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单介绍创建文件并写入字符串方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fs&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//在当前运行目录下创建文件并写入字符串&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;writeFile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./message.txt'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'hello node.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;(err)&lt;span class=&quot;op&quot;&gt;=&amp;gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(err) &lt;span class=&quot;cf&quot;&gt;throw&lt;/span&gt; err&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;file saved&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;fs-cli编程实战目录浏览&quot;&gt;FS CLI编程实战——目录浏览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;浏览指定目录下的文件与目录&lt;/li&gt;
&lt;li&gt;用户可选择打开文件或目录查看&lt;/li&gt;
&lt;li&gt;若是文件则打印文件内容，若是目录则进入目录查看目录内文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fs&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;//获取fs API&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; files &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//存储读取目录下的文件和目录&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; stats &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;//存储文件状态（属性）&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; dir &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;argv&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;//取得CLI输入的参数&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readdir&lt;/span&gt;(dir&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;f)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    files &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; f&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;files&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;files)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[31m No files to show &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Select a file or dir&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;file&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//递归处理文件函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;file&lt;/span&gt;(i)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; filename &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; files[i]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stat&lt;/span&gt;(dir&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;filename&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;stat)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        stats[i] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; stat&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stat&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isDirectory&lt;/span&gt;())
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'   ['&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;']  &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[36m'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;filename&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'   ['&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;']  &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[90m'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;filename&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        i&lt;span class=&quot;op&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//执行到最后一个文件&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(i&lt;span class=&quot;op&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;files&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;read&lt;/span&gt;(filename)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;file&lt;/span&gt;(i)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//读取文件函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;read&lt;/span&gt;(filename)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdout&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[33mEnter your choice: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resume&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setEncoding&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'utf8'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(d)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; file &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; files[&lt;span class=&quot;at&quot;&gt;Number&lt;/span&gt;(d)]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; stat &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; stats[&lt;span class=&quot;at&quot;&gt;Number&lt;/span&gt;(d)]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;file)
            &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdout&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[33mEnter your choice: &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;pause&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;stat&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;isDirectory&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(dir&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;file&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readdir&lt;/span&gt;(dir&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;file&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(e&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;f)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'files:'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;f&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;va&quot;&gt;f&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;forEach&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(fn)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;fn)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readFile&lt;/span&gt;(dir&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;file&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;utf8&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;data)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;dir)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[90m&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;data&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\033&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;[39m&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128140401304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ2NjEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个小程序代码十分简单，比起c语言实现一定是简单多的。需要注意的几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;process.argv是个数组，用于获取命令行执行后输入的参数，比如上面的目录地址。但数组参数要从第三个开始，前两个是：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180128141743518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDQ2NjEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;file函数递归处理了readdir获取的文件和目录，可以使用files.forEach()遍历，效果相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码中出现的”\033[33m“等用于格式化字体颜色，可以暂时忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 28 Jan 2018 06:19:00 +0000</pubDate>
<dc:creator>devilyouwei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/devilyouwei/p/8371074.html</dc:identifier>
</item>
<item>
<title>Python 3 利用 Dlib 19.7 和 sklearn机器学习模型 实现人脸笑脸检测 - TimeStamp</title>
<link>http://www.cnblogs.com/AdaminXie/p/8367348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AdaminXie/p/8367348.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;0.引言&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt; 利用机器学习的方法训练微笑检测模型，输入一张人脸照片，判断是否微笑；&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　 &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;识别&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;精度在95%&lt;/strong&gt;附近（使用的数据集中69张没笑脸，65张有笑脸）；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128133807459-924013155.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;图1 测试图像与检测结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　&lt;br/&gt;　　　&lt;strong&gt;项目实现的笑脸识别，并不是通过计算嘴唇角度，满足一定弧度认定为笑脸进行判定，&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　　而是通过机器学习模型，让模型去学习嘴唇的坐标和笑容的关系；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　借助Dlib进行&lt;span&gt; &lt;strong&gt;人脸嘴部20个特征点坐标（40维特征）&lt;/strong&gt;&lt;/span&gt;的提取;&lt;/p&gt;
&lt;p&gt;　　　然后根据这&lt;span&gt; &lt;span&gt;&lt;strong&gt;40维输入特征&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 作为&lt;strong&gt;模型输入&lt;/strong&gt;，&lt;span&gt; &lt;strong&gt;1维特征&lt;/strong&gt;&lt;/span&gt;（1代表有微笑 / 0代表没微笑）作为&lt;strong&gt;输出&lt;/strong&gt;，进行ML建模;&lt;/p&gt;
&lt;p&gt;　　　利用几种机器学习模型进行建模，达到一个&lt;span&gt;&lt;strong&gt;二分类（分类有/无笑脸）&lt;/strong&gt;&lt;/span&gt;的目的，然后分析模型识别精度和性能，并且可以识别给定图片的人脸是否微笑；&lt;/p&gt;
&lt;p&gt;　　　源码上传到了github,地址在文末；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　源码py文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;Get_features&lt;/strong&gt;.py : &lt;/p&gt;
&lt;p&gt;　　　　　　returnfeatures():　　输入人脸图像路径，利用dlib的“shape_predictor_68_face_landmarks.dat”提取嘴部20个特征点坐标的40个特征值；&lt;/p&gt;
&lt;p&gt;　　　　　　writeintoCSV():　　将40维特征输入和1维的输出标记（1代表有微笑/0代表没微笑）写入CSV文件中；&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;2. ML_ways.py:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　&lt;/strong&gt;　pre_data():　　  读取CSV中的数据，然后提取出训练集和测试集；&lt;/p&gt;
&lt;p&gt;　　　　　　way_LR():　　   Logistic Regressio, 罗吉斯特回归方法建模；&lt;/p&gt;
&lt;p&gt;　　　　　　way_SGD():　　Stochastic Gradient Decent, 随机梯度下降法建模；&lt;/p&gt;
&lt;p&gt;　　　　　　way_SVM():　　Supported Vector Machine, 支持向量机法建模；&lt;/p&gt;
&lt;p&gt;　　　　　　way_MLP():　　 Multi-Layer Perceptron, 多层神经网络法建模；&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　3. test_single_pic.py:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　输入给定测试图像，用ML模型检测其有/无笑脸；&lt;/p&gt;

&lt;p&gt;　　　（实现稍微比较复杂，感兴趣的可以结合之前博客看看：&lt;/p&gt;
&lt;p&gt;　　　Python 3 利用 Dlib 19.7 进行人脸识别：&lt;/p&gt;
&lt;p&gt;　　　　&lt;a title=&quot;Python 3 利用 Dlib 19.7 进行人脸识别&quot; href=&quot;http://www.cnblogs.com/AdaminXie/p/7905888.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/p/7905888.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　   　 Python 3 利用 Dlib 19.7 进行人脸68个特征点的标定：&lt;/p&gt;
&lt;p&gt;　　　　&lt;a title=&quot;Python 3 利用 Dlib 19.7 实现人脸68个特征点的标定&quot; href=&quot;http://www.cnblogs.com/AdaminXie/p/8137580.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/p/8137580.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　Python 3 利用机器学习模型进行手写体识别：&lt;/p&gt;
&lt;p&gt;　　　　&lt;a title=&quot;Python 3 利用机器学习模型 进行手写体数字识别&quot; href=&quot;http://www.cnblogs.com/AdaminXie/p/8249858.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/p/8249858.html&lt;/a&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;开发环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　python:　　3.6.3&lt;/p&gt;
&lt;p&gt;　　dlib:　　　 19.7&lt;/p&gt;
&lt;p&gt;　　OpenCv, numpy, sklearn, pandas, os, csv等&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;Get_features.py&lt;/strong&gt;中调用的库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; dlib         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 人脸识别的库dlib&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; numpy as np  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据处理的库numpy&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; cv2          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像处理的库OpenCv&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; os           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; csv          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; csv操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;strong&gt;ML_ways.py&lt;/strong&gt;中调用的库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pd读取CSV&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分割数据&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于数据预加工标准化&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; StandardScaler
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用的四种ML模型&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LogisticRegression
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SGDClassifier
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.svm &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LinearSVC
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.neural_network &lt;span&gt;import&lt;/span&gt; MLPClassifier
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　使用的人脸来自于 &lt;strong&gt;The MUCT Face Database&lt;/strong&gt;（Link: &lt;a title=&quot;The MUCT Face Database&quot; href=&quot;http://www.milbo.org/muct/&quot; target=&quot;_blank&quot;&gt;http://www.milbo.org/muct/&lt;/a&gt;），在此十分感谢！&lt;/p&gt;
&lt;p&gt;　　(&lt;em&gt;The MUCT database was prepared by Stephen Milborrow, John Morkel, and Fred Nicolls in December 2008 at the University Of Cape Town. We would like to send out a thanks to the people who allowed their faces to be used.&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.设计流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;工作内容主要以下两大块&lt;strong&gt;：&lt;span&gt;提取人脸特征&lt;/span&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;span&gt;ML建模&lt;/span&gt;&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;整体的设计流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128121551912-2129222085.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;378&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　图2 总体设计流程图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2.1 提取人脸特征：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　该部分的设计流程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128112732584-1557752471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;图3 人脸提取特征部分流程图&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　　　我先在项目目录下建立两个文件夹，分别存放&lt;strong&gt;有笑脸的人脸&lt;/strong&gt;，和&lt;strong&gt;无笑脸的人脸&lt;/strong&gt;，这样之后读取的时候就可以知道人脸的标记有/无人脸；&lt;/p&gt;
&lt;p&gt;　　　　关于利用dlib进行人脸68个特征点的提取，在我之前另一篇博客里面介绍过:&lt;/p&gt;
&lt;p&gt;　　　　（link: &lt;a title=&quot;Python 3 利用 Dlib 19.7 实现人脸68个特征点的标定&quot; href=&quot;http://www.cnblogs.com/AdaminXie/p/8137580.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/p/7905888.html&lt;/a&gt;）；&lt;/p&gt;
&lt;p&gt;　　　　本项目中只使用其中嘴部20个特征点的坐标作为特征输入，20个点的序号如下图所示：　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128113206553-425865406.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;418&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;图4 dlib标定的嘴部特征点序号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　20个特征点40个坐标值，和输出标记的获取，由returnfeatures函数实现；&lt;/p&gt;
&lt;p&gt;　　输入图像文件所在路径，返回的的是数组features_csv（前40个为特征点坐标值，第41个为标记（1代表有笑脸，0代表无笑脸））&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ML_smiles&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-1-27&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; detector =&lt;span&gt; dlib.get_frontal_face_detector()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; predictor = dlib.shape_predictor(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shape_predictor_68_face_landmarks.dat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入图像文件所在路径，返回一个41维数组（包含提取到的40维特征和1维输出标记）&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; returnfeatures(path_pic, XXXpic, features_csv):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入:  path_pic:    图像文件所在目录&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;       XXXpic:      图像文件名&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出:  features_csv 41维度的数组，前40维为(提取的20个特征点坐标的40个值)，第41维为标记output&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比如 path_pic + XXXpic = &quot;F:/code/test.jpg&quot; 精确到jpg&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     img = cv2.imread(path_pic +&lt;span&gt; XXXpic)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取灰度&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     img_gray =&lt;span&gt; cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算68点坐标&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     pos_68 =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     rects =&lt;span&gt; detector(img_gray, 0)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     landmarks = np.matrix([[p.x, p.y] &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; predictor(img, rects[0]).parts()])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; idx, point &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(landmarks):
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 68点的坐标&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         pos = (point[0, 0], point[0, 1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        pos_68.append(pos)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将点49-68写入csv&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 即pos_68[48]-pos_68[67]&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(48, 68&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        features_csv.append(pos_68[i][0])
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         features_csv.append(pos_68[i][1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(features_csv)&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; features_csv
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　然后就遍历两个存放有/无笑脸的文件夹，读取图像文件，然后利用returnfeatures()函数得到特征值，写入CSV中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ML_smiles&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-1-27&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Get_features.py&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取图像所在的路径&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; path_pic_smile = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/code/python/P_ML_smile/pic/database/smile/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; path_pic_nosmile = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/code/python/P_ML_smile/pic/database/no/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取路径下的图像文件&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; namedir_smile =&lt;span&gt; os.listdir(path_pic_smile)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; namedir_nosmile =&lt;span&gt; os.listdir(path_pic_nosmile)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储提取特征数据的CSV的路径&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; path_csv = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/code/python/P_ML_smile/data_csv/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; writeintoCSV():
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     with open(path_csv+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, newline=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;) as csvfile:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         writer =&lt;span&gt; csv.writer(csvfile)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理带笑脸的图像&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;######## with smiles #########&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(namedir_smile)):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pic:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, path_pic_smile, namedir_smile[i])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用来存放41维特征&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             features_csv_smiles =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用 returnfeatures 函数提取特征&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            returnfeatures(path_pic_smile, namedir_smile[i], features_csv_smiles)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             features_csv_smiles.append(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;features:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, features_csv_smiles, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入CSV&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            writer.writerow(features_csv_smiles)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理不带笑脸的图像&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;######## no smiles #########&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(namedir_nosmile)):
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pic:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, path_pic_nosmile, namedir_nosmile[i])
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用来存放41维特征&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;             features_csv_nosmiles =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用 returnfeatures 函数提取特征&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            returnfeatures(path_pic_nosmile, namedir_nosmile[i], features_csv_nosmiles)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            features_csv_nosmiles.append(0)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;features:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, features_csv_nosmiles, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入CSV&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             writer.writerow(features_csv_nosmiles)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　会得到一个41列的CSV文件，前40列为40维的输入特征，第41列为笑脸标记。 　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2.2 ML建模和测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　这部分机器学习模型使用比较简单，之前的特征提取已经完成，写入了CSV文件中；&lt;/p&gt;
&lt;p&gt;　　　　接下来就是要从CSV中将想要的数据集提取出来，利用sklearn进行机器学习建模。&lt;/p&gt;
&lt;p&gt;　　2.2.1 数据预加工&lt;/p&gt;
&lt;p&gt;　　　　利用pands.read_csv读取CSV文件，然后利用train_test_split进行数据分割；&lt;/p&gt;
&lt;p&gt;　　　　得到 &lt;strong&gt;训练集：X_train, y_train&lt;/strong&gt; 和 &lt;strong&gt;测试集：X_test, y_test&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ML_smiles&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-1-27&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pre_data() in ML_ways.py&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从CSV读取数据&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; pre_data():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 41维表头&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     column_names =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, 40&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         column_names.append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;feature_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(i+1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     column_names.append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     path_csv = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/code/python/P_ML_smile/data_csv/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     rd_csv = pd.read_csv(path_csv+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, names=&lt;span&gt;column_names)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出CSV文件的维度&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shape:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, rd_csv.shape)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; X_train, X_test, y_train, y_test
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     X_train, X_test, y_train, y_test =&lt;span&gt; train_test_split(
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         rd_csv[column_names[0:40&lt;span&gt;]],
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         rd_csv[column_names[40&lt;span&gt;]],
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         test_size=0.25&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         random_state=33)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.2.2 机器学习建模&lt;/p&gt;
&lt;p&gt;　　　　几种建模方法在sklearn中实现的代码类似，所以在此只介绍LR，Logisitic Regression罗吉斯特回归方法；&lt;/p&gt;
&lt;p&gt;　　　　返回ss_LR和LR，需要这两个返回值，是因为之后要利用它们对给定图像的进行检测，之后2.2.3节会介绍；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ML_smiles&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-1-27&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; way_LR() in ML_ways.py&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 罗吉斯特回归LR&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; way_LR():
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     X_train_LR =&lt;span&gt; X_train
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     y_train_LR =&lt;span&gt; y_train
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     X_test_LR =&lt;span&gt; X_test
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     y_test_LR =&lt;span&gt; y_test
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标准化数据预加工&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     ss_LR =&lt;span&gt; StandardScaler()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     X_train_LR =&lt;span&gt; ss_LR.fit_transform(X_train_LR)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     X_test_LR =&lt;span&gt; ss_LR.transform(X_test_LR)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化LogisticRegression&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     LR =&lt;span&gt; LogisticRegression()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用LogisticRegression中的fit()来训练模型参数&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    LR.fit(X_train_LR, y_train_LR)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用训练好的模型lr对X_test进行预测，结果储存在lr_y_predict中&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; y_predict_LR
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     y_predict_LR =&lt;span&gt; LR.predict(X_test_LR)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; lr_score
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     lr_score=&lt;span&gt;LR.score(X_test_LR, y_test_LR)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The accurary of LR:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, LR.score(X_test_LR, y_test_LR))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ss_LR, LR
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我的数据集里面是69张没笑脸，65张有笑脸，测试精度如下，&lt;span&gt;&lt;strong&gt;精度在95%&lt;/strong&gt;&lt;/span&gt;附近：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
The accurary of LR: 0.941176470588&lt;span&gt;
The accurary of SGD: &lt;/span&gt;0.882352941176&lt;span&gt;
The accurary of SVM: &lt;/span&gt;0.941176470588&lt;span&gt;
The accurary of MLP: &lt;/span&gt;0.970588235294
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2.2.3 测试单张图片&lt;/p&gt;
&lt;p&gt;　　现在我们已经建好机器学习模型，在2.2.2中可以利用sklearn机器学习模型的score函数得到模型精度，但是如果想检测给定图像的笑脸，需要进行该部分工作：&lt;/p&gt;
&lt;p&gt;　　path_test_pic+XXXpic就是需要进行检测的文件路径，需要精确到图像文件，比如“F:/pic/test.pic”;&lt;/p&gt;
&lt;p&gt;　　然后调用Get.features.py中的returnfeatures()函数进行特征提取，得到给定图像的40维特征数组single_features；&lt;/p&gt;
&lt;p&gt;　　如果想利用LR模型测试，接受way_LR()的返回值ss_LR和LR，利用ss_LR对single_features进行标准化处理，然后调用LR.predict进行预测；&lt;/p&gt;
&lt;p&gt;　　然后生成图像窗口，将几种模型的结果显示在图像上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;96&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ML_smiles&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-1-27&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; test_single_pic.py&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ML_ways &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pre_data
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ML_ways &lt;span&gt;import&lt;/span&gt;&lt;span&gt; way_LR
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ML_ways &lt;span&gt;import&lt;/span&gt;&lt;span&gt; way_MLP
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ML_ways &lt;span&gt;import&lt;/span&gt;&lt;span&gt; way_SGD
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; ML_ways &lt;span&gt;import&lt;/span&gt;&lt;span&gt; way_SVM
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得单张人脸的特征点&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; path_test_pic = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F:/code/python/P_ML_smile/pic/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;path_test_pic = &quot;F:/code/pic/faces/the_muct_face_database/jpg/&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; XXXpic = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练LR模型&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;pre_data()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用标准化参数和ML模型&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; ss_LR, LR =&lt;span&gt; way_LR()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; ss_SGD, SGD =&lt;span&gt; way_SGD()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; ss_SVM, SVM =&lt;span&gt; way_SVM()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; ss_MLP, MLP =&lt;span&gt; way_MLP()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取单张40维度特征&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Get_features &lt;span&gt;import&lt;/span&gt;&lt;span&gt; returnfeatures
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; single_features =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;returnfeatures(path_test_pic, XXXpic, single_features)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(&quot;single_40_features: &quot;, single_features)&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############# LR模型预测 ##############&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特征数据预加工&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; X_single_LR =&lt;span&gt; ss_LR.transform([single_features])
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用训练好的LR模型预测&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; y_predict_LR_single =&lt;span&gt; LR.predict(X_single_LR)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; con_LR = str(y_predict_LR_single[0]).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no_smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LR:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, con_LR)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############# SGD模型预测 ##############&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特征数据预加工&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; X_single_SGD =&lt;span&gt; ss_SGD.transform([single_features])
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用训练好的SGD模型预测&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; y_predict_SGD_single =&lt;span&gt; SGD.predict(X_single_SGD)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; con_SGD = str(y_predict_SGD_single[0]).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no_smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SGD:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, con_SGD)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############# SVM模型预测 ##############&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特征数据预加工&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; X_single_SVM =&lt;span&gt; ss_SVM.transform([single_features])
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用训练好的SVM模型预测&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; y_predict_SVM_single =&lt;span&gt; SVM.predict(X_single_SVM)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt; con_SVM = str(y_predict_SVM_single[0]).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no_smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SVM:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, con_SVM)
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############# MLP模型预测 ##############&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特征数据预加工&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; X_single_MLP =&lt;span&gt; ss_MLP.transform([single_features])
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用训练好的MLP模型预测&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; y_predict_MLP_single =&lt;span&gt; MLP.predict(X_single_MLP)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; con_MLP = str(y_predict_MLP_single[0]).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no_smiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MLP:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, con_MLP)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt; img = cv2.imread(path_test_pic+&lt;span&gt;XXXpic)
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt; font =&lt;span&gt; cv2.FONT_HERSHEY_SIMPLEX
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt; cv2.putText(img, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LR: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+con_LR, (20, 50), font, 1, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; cv2.putText(img, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SGD: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+con_SGD, (20, 100), font, 1, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; cv2.putText(img, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SVM: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+con_SVM, (20, 150), font, 1, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; cv2.putText(img, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MLP: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+con_MLP, (20, 200), font, 1, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt; cv2.namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;, 2)&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt; cv2.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img)
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; cv2.waitKey(0)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128133807459-924013155.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;图5 同一个人不同表情的笑脸检测结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128144205209-210351400.png&quot; alt=&quot;&quot; width=&quot;878&quot; height=&quot;692&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128144249303-879237833.png&quot; alt=&quot;&quot; width=&quot;863&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;图6 检测到没微笑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128144356365-1200361105.png&quot; alt=&quot;&quot; width=&quot;876&quot; height=&quot;487&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1152352/201801/1152352-20180128144432834-1419007068.png&quot; alt=&quot;&quot; width=&quot;876&quot; height=&quot;543&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　图7 检测到有微笑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　自己最近经常使用dlib做人脸识别这块，又在学习机器学习，两者结合尝试做到笑容检测这块；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　数据集中有无笑脸是自己进行分类的，而且有写的表情不太好界定，所以选取的是一些笑容比较明显的照片作为有笑脸，所以可能出来模型在检测一些微笑上有误差；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　笑容检测模型的数据集测试精度在95%左右，比较理想；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　其实人脸笑容检测的话，光靠嘴部特征去判断不太合适，要结合整张人脸特征点进行训练，改进的话也比较简单；&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;# Github:&lt;/strong&gt; &lt;a title=&quot;ML_smiles&quot; href=&quot;https://github.com/coneypo/ML_smiles&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/ML_smiles&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;# 请尊重他人劳动成果，转载或者使用源码请注明出处（&lt;a title=&quot;xie&quot; href=&quot;http://www.cnblogs.com/AdaminXie/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;# 交流学习可以联系邮箱 coneypo@foxmail.com&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 05:56:00 +0000</pubDate>
<dc:creator>TimeStamp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AdaminXie/p/8367348.html</dc:identifier>
</item>
<item>
<title>Angular CLI: 发布到 GitHub Pages - 冠军</title>
<link>http://www.cnblogs.com/haogj/p/8370715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haogj/p/8370715.html</guid>
<description>&lt;p&gt;发布 Angular 应用的简单方式是使用 &lt;a href=&quot;https://help.github.com/articles/what-is-github-pages/&quot; target=&quot;_blank&quot;&gt;GitHub Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://haoguanjun.github.io/ng-hello/&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt; 可以查看发布之后的应用。&lt;/p&gt;

&lt;p&gt;首先需要创建一个 GitHub 账号，随后，为您的项目创建一个仓库。记下 GitHub 中的用户名和项目名称。&lt;/p&gt;
&lt;p&gt;例如，我的 GitHub 账号是 haoguanjun，我创建的项目名称是 ng-hello。&lt;/p&gt;
&lt;p&gt;然后，您要做的就是运行 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng build --prod --output-path docs --base-href &lt;span&gt;ng-hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个 PROJECT_NAME 就是您的项目在 GitHub 中的名称。这个示例中使用的项目名称是 ng-hello，将 docs/index.html 复制为 docs/404.html。&lt;/p&gt;
&lt;p&gt;提交修改并 Push 到仓库中。&lt;/p&gt;
&lt;p&gt;您应该在项目的主页 https://github.com/haoguanjun/ng-hello 上，看到一个 docs 的文件夹，其中包含了一个 404.html 页面。&lt;/p&gt;
&lt;p&gt;页面内容如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;base &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;ng-hello&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;icon&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;image/x-icon&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;favicon.ico&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;styles.d41d8cd98f00b204e980.bundle.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-root&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-root&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;inline.97a5517db35cb02cdd8d.bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;polyfills.f20484b2fa4642e0dca8.bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;main.352a0febf476a50f1de9.bundle.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 GitHub 项目的页面上，配置为 &lt;a href=&quot;https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch&quot; target=&quot;_blank&quot;&gt;publish from the docs folder&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;点击项目中的 &lt;img src=&quot;https://images2017.cnblogs.com/blog/13475/201801/13475-20180128115258990-530821076.png&quot; alt=&quot;&quot;/&gt;，进入项目配置页面。找到 GitHub Pages 配置部分。&lt;/p&gt;
&lt;p&gt;在 Source 下面的下拉列表中，找到 master branch/docs folder ，选中并保存。如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/13475/201801/13475-20180128115403756-256639074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这就是所有您需要做的！现在可以访问地址 https://USER_NAME.github.io/PROJECT_NAME 来访问页面了。&lt;/p&gt;
&lt;p&gt;这个示例的寄宿在 GitHub 的 &lt;a href=&quot;https://haoguanjun.github.io/ng-hello/&quot; target=&quot;_blank&quot;&gt;https://haoguanjun.github.io/ng-hello/&lt;/a&gt; 中，可以直接点击查看。&lt;/p&gt;
&lt;p&gt;这个示例所有的代码都保存在 &lt;a href=&quot;https://github.com/haoguanjun/ng-hello&quot; target=&quot;_blank&quot;&gt;https://github.com/haoguanjun/ng-hello&lt;/a&gt; 中，您可以直接下载查看。&lt;/p&gt;
&lt;p&gt;您还可以使用 &lt;a href=&quot;https://github.com/angular-buch/angular-cli-ghpages&quot; target=&quot;_blank&quot;&gt;angular-cli-ghpages&lt;/a&gt;，这是一个全功能的包，可以帮助您做所有这些工作，且还有额外的功能。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Jan 2018 03:59:00 +0000</pubDate>
<dc:creator>冠军</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haogj/p/8370715.html</dc:identifier>
</item>
<item>
<title>P2P结构与Quorum机制------《Designing Data-Intensive Applications》读书笔记8 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/8370764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/8370764.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前文涉及到了很多与Leader相关的算法，大家有木有想过，王侯将相，宁有种乎，既然Leader这么麻烦，干脆还是采用P2P模型吧，来个大家平等的架构。本篇需要和大家探讨的就是多副本下实现民主政治的&lt;strong&gt;Quorum机制&lt;/strong&gt;。至于它是怎么样解决我们在前文提及的各种问题的，接着这篇文章我们继续聊聊～～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;no-leader机制&quot;&gt;1. No-Leader机制&lt;/h3&gt;
&lt;p&gt;有些数据存储系统放弃了Leader的机制，允许任何副本直接接受用户的写操作。（&lt;strong&gt;如Amazon的Dynamo，FaceBook的Cassandra，虽然最终FaceBook放弃了Cassandra转而支持Hbase，但是Uber的强势介入让Cassandra后来在开源社区大放异彩。&lt;/strong&gt;) 每个接受到客户端写请求的节点会转换为一个协调器节点，而协调器节点不强制执行特定的写入顺序。正是这种设计上的差异对数据库的使用方式与数据模型产生了深远的影响。&lt;/p&gt;
&lt;h4 id=&quot;多副本的读写&quot;&gt;多副本的读写&lt;/h4&gt;
&lt;p&gt;No-Leader机制是怎么样消除Leader这个角色的存在的呢？答案也很简单：&lt;strong&gt;多副本读写&lt;/strong&gt;。接下来我们来看一个栗子：&lt;/p&gt;
&lt;p&gt;假设我们在数据系统之中采用了三副本的结构，如下图所示：User 1234 并行地将所有的副本发送给三个存储节点，并且两个节点可以接受副本的写入，但是其中一个节点不在线，所以副本写入失败。所以在三个副本中有两个副本确认写入成功了：在User 1234收到两个OK响应之后，User就认为写入操作是成功的，忽略了一个副本写入失败。（&lt;strong&gt;当然，不是简单的就不管这个写入失败了，后续会有修复机制来补齐这个副本的数据&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-db23c58a4c3cca9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在假设User 2345开始读取新写入的数据。由于一个节点写入失败了，所以User 234 可能会得到过期的值作为响应。为了解决这个问题，当User 从数据系统之中读取数据时，它不只是将请求发送到一个副本，而是将&lt;strong&gt;读取请求并行地发送到多个副本节点&lt;/strong&gt;。User可以从不同节点获得不同的响应，即来自其他节点的最新值和另一个节点的过期值。这里通过了版本号用于确定哪个值是更新的值。&lt;/p&gt;
&lt;h4 id=&quot;副本修复&quot;&gt;副本修复&lt;/h4&gt;
&lt;p&gt;No-Leader机制导致了数据系统之中可能存在大量过期的值，所以一个节点怎么来修复自身的副本来获取最新值的过程我们就称之为&lt;strong&gt;副本修复&lt;/strong&gt;,No-Leader机制也是通过这样的方式来达到&lt;strong&gt;最终一致性&lt;/strong&gt;的。通常会有这样几种方式：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;读修复&lt;/strong&gt;&lt;br/&gt;当用户并行读取多个节点时，它可以获取到其他过期的值的响应。所以用户会发现其中有些节点拥有过期的值，这时用户可以主动将新值写入该节点。这种方法称之为&lt;strong&gt;读修复&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;反熵过程（其实是一个物理学概念）&lt;/strong&gt;&lt;br/&gt;每个数据存储节点都会有一个后台进程，不断的比对自己的副本与其他节点副本的差异，发现自己拥有过期的值之后，会主动修复自己过期的副本。与基于写入顺序日志不同，这种反熵过程不以任何特定的顺序复制写操作，并且在复制数据之前可能会有显著的延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;quorum机制&quot;&gt;2. Quorum机制&lt;/h3&gt;
&lt;p&gt;上文之中提及的例子在三个副本中的两个之上写入成功，我们认为写操作成功了。但是如果三个副本只有的一个副本写入成功了？这时的写操作是否是成功的呢？&lt;/p&gt;
&lt;p&gt;答案是否定的？这里其实就是简单的鸽巢原理，这里我不做数学证明了，大家有兴趣的可以自行证明一下。&lt;br/&gt;假设有n个副本，每次写操作必须由w个节点确认为成功，每个读操作读取r个节点。（在上文的例子中，n＝3，w＝2，r＝2）。只要w + r &amp;gt; n，如果读和写操作的总次数大于n，那么读和写操作必然至少有一个副本是相同的，也就是读操作必然可以读到最新写操作的数据。这被我们称之为：&lt;strong&gt;Quorum机制，每次读写都需要达到法定人数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常 n、w和r通常是可配置的，根据您的需要来修改这些数字。一个常见的选择是使n为奇数（通常为3或5），并设置w＝r＝（n + 1）/ 2 。如下图所示，如果w &amp;lt; n，如果有n - w个节点不可用，我们仍然可以处理写操作。同样的如果r＜n，如果有n - r个节点不可用，我们仍然可以处理读操作。而如果小于所需的w或r节点可用，则写或读操作就会返回错误。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;n＝3，w＝2，r＝2，我们可以容忍一个不可用的节点。&lt;/li&gt;
&lt;li&gt;n＝5，w＝3，r＝3，我们可以容忍两个不可用的节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-19f5e6d789222b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Quorum机制保证了一定能读到最新的副本&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;高可用与hinted-handoff&quot;&gt;高可用与Hinted handoff&lt;/h4&gt;
&lt;p&gt;Quorum机制实现了最终一致性的模型，但是在可用性上还是有一些极端情况，没法很好处理。如：出现网络抖动时，但是可能系统仍然有许多正常工作的节点。但是副本应该被写入的n个节点发生网络问题，导致了会少于w或r个成功的读写操作，由于不能达到法定的人数，读写操作都会失败。所以这时候数据库系统的设计者面临权衡取舍，能不能通过一些机制，实现更好的可用性呢？&lt;/p&gt;
&lt;p&gt;所以这种情况下，我们就可以利用&lt;strong&gt;Hinted handoff&lt;/strong&gt;了（原谅我翻译不好）。这种方式是怎么样实现的呢？&lt;strong&gt;写和读操作仍然需要w和r成功的响应，但是可以不强制一定要写如指定的n个节点&lt;/strong&gt; (&lt;strong&gt;这个涉及到一致性哈希，数据分布的知识，暂时要是理解不了，我后续会有专门的专题来写这个内容，可以先放一放。&lt;/strong&gt;) 打个比方说，如果你把自己锁在门外，你可能会敲邻居的门，问你是否可以暂时呆在他们的沙发上，一旦你找到钥匙了，你就自己回家了。所以其他节点可以暂存本应该放在另一个节点上的副本，一旦网络中断被修复，其他节点就会把副本转交给主人节点。&lt;/p&gt;
&lt;p&gt;所以这种模式既保证了不违反Quorum机制，也大大提高了系统的可用性，被No-leader数据系统广泛采用。&lt;/p&gt;
&lt;h3 id=&quot;写入冲突与quorum机制&quot;&gt;3 写入冲突与Quorum机制&lt;/h3&gt;
&lt;p&gt;同样的Quorum机制的设计本身就可以允许并发读写操作，并容忍网络中断与高峰延迟。但是这也必然会带来一致性问题，我们来看下面这个例子：&lt;/p&gt;
&lt;p&gt;如图所示，有两个Client A与B，同时写入关键字X在一个三副本的数据存储系统之中。Node 1接收来自A的写入，但由于网络中断而从未接收来自B的写入。Node 2首先接收来自A的写入，然后接收B写入。而Node 3则是首先接收来自B的写入，然后接收A的写入。Node 2认为X的最终值是B，而其他Node认为最终值是A.&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-49660630c069e4ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;并发写导致副本冲突&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这样的场景下如何仲裁写入结果成为了一个大问题，思路和我们之前提到的类型：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Last Write Win&lt;/strong&gt;&lt;br/&gt;我们可以为每个写操作附加一个时间戳，选择最大的时间戳作为最新的值，并丢弃任何具有早期时间戳的写操作的值。这种冲突解决算法，称为Last Write Win。这种情况要求每个写操作具有幂等性，否则会出现写丢失的情况，如何能保证不出现依赖的写丢失呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并“happens-before”关系&lt;/strong&gt;&lt;br/&gt;每当有两个操作A和B时，有三种可能：A发生在B之前，B发生在A之前，A或B是并发的。我们需要的是一个算法，告诉我们两个操作是否并发。如果一个操作在另一个操作之前发生，那么后面的操作应该覆盖前面的操作，但是如果操作是并行的，那么我们需要解决一个冲突。怎么样去捕获并合并“happen-before”的关系呢？可以在服务器节点维护一个版本号，每次写操作时递增版本号，并将新版本号存储在写入的值中。
&lt;ul&gt;&lt;li&gt;客户端&lt;br/&gt;当客户端读取一个键时，服务节点会返回所有未被覆盖的值，以及最新版本号。当客户端需要写一个键时，它必须包含从先前读取中的版本号，并且它必须合并它在前面读取中接收到的所有值。&lt;/li&gt;
&lt;li&gt;服务器&lt;br/&gt;当服务器接收到具有特定版本号的写入时，它可以覆盖该版本号或以下的所有值，因为它知道已经合并到新值，但必须保留所有值具有更高版本号。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;版本向量&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;合并“happen-before&quot;使用一个单一的版本号来捕捉操作之间的依赖关系，但这不足以解决当有多个副本并行写入的情况。相反，我们需要使用每个副本的版本号以及每个键。每个副本在处理写时递增自己的版本号，并跟踪从其他副本中看到的版本号。此信息指示要覆盖哪些值以及作为兄弟版本保存着哪些值。而所有副本的版本号的集合称为&lt;strong&gt;版本向量&lt;/strong&gt;。版本向量从数据节点发送给客户端，所以&lt;strong&gt;版本向量让我们可以区分覆盖写与发并行写操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;4. 小结&lt;/h3&gt;
&lt;p&gt;好了，到此为止我们终于总结完整了分布式系统之中的副本机制。从Leader-Follower 机制到多Leader机制，最后到No-Leader的机制，并且详细总结了各个机制的实现细节与优缺点，希望大家阅读完之后也能有所收获。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 03:26:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/8370764.html</dc:identifier>
</item>
<item>
<title>01 整合IDEA+Maven+SSM框架的高并发的商品秒杀项目之业务分析与DAO层 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8370641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8370641.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://github.com/nnngu&quot;&gt;nnngu&lt;/a&gt;&lt;br/&gt;项目源代码：&lt;a href=&quot;https://github.com/nnngu/nguSeckill&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu/nguSeckill&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这是一个整合IDEA+Maven+SSM框架的高并发的商品秒杀项目。我们将分为以下几篇文章来进行详细的讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;01 Java高并发秒杀项目之业务分析与DAO层&lt;/li&gt;
&lt;li&gt;02 Java高并发秒杀项目之Service层&lt;/li&gt;
&lt;li&gt;03 Java高并发秒杀项目之web层&lt;/li&gt;
&lt;li&gt;04 Java高并发秒杀项目之高并发优化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;项目的效果图&quot;&gt;项目的效果图&lt;/h2&gt;
&lt;h3 id=&quot;秒杀商品列表&quot;&gt;秒杀商品列表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517020356103.jpg&quot; alt=&quot;秒杀商品列表&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;开始秒杀提示界面&quot;&gt;开始秒杀提示界面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517020518954.jpg&quot; alt=&quot;开始秒杀提示界面&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;秒杀结束提示界面&quot;&gt;秒杀结束提示界面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517020478158.jpg&quot; alt=&quot;秒杀结束提示界面&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新建一个maven项目&quot;&gt;新建一个Maven项目&lt;/h2&gt;
&lt;p&gt;以IntelliJ IDEA为例，点击&lt;code&gt;File &amp;gt; New &amp;gt; Project &amp;gt; Maven&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517021726058.jpg&quot; alt=&quot;然后点击Next继续；&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击Next继续；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517021904910.jpg&quot; alt=&quot;填写相关信息，点击Next；&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写相关信息，点击Next；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517022082406.jpg&quot; alt=&quot;最后点击Finish，完成创建。&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后点击Finish，完成创建。&lt;/p&gt;
&lt;p&gt;如果右下角弹出下面这个提示，点击&lt;code&gt;Enable Auto-Import&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517022266134.jpg&quot; alt=&quot;如果弹出这个提示，点击Enable Auto-Import&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建webapp目录&quot;&gt;创建webapp目录&lt;/h2&gt;
&lt;p&gt;点击&lt;code&gt;File &amp;gt; Project Structure&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;步骤1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517061858789.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517062252122.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517061346663.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤4&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517061459422.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517061601898.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤6&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517064377716.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤7&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517064456606.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/27/1517065310557.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;构建pom文件&quot;&gt;构建pom文件&lt;/h2&gt;
&lt;p&gt;Maven项目创建好了，接下来我们要添加一些jar包的依赖，也就是在&lt;code&gt;pom.xml&lt;/code&gt;中添加各种开源组件的坐标。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;project&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;         xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;         xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;kw&quot;&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.nnngu&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;nguSeckill&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 代码省略，请参照项目的源代码 --&amp;gt;&lt;/span&gt;
        ... ...
        &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的代码，请查看项目里的&lt;code&gt;pom.xml&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;到此，我们项目的初始化工作完成。&lt;/p&gt;
&lt;h2 id=&quot;秒杀系统业务分析&quot;&gt;秒杀系统业务分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;秒杀系统业务流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517078418982.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由图可以发现，整个系统其实是针对库存做的系统。用户成功秒杀商品，对于我们系统的操作就是：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;减库存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;记录用户的购买明细。下面看看我们用户对库存的业务分析：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517078595990.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记录用户的秒杀成功信息，我们需要记录：1、谁购买成功了。2、购买成功的时间/有效期。3、付款/发货信息。这些数据组成了用户的秒杀成功信息，也就是用户的购买行为。&lt;/p&gt;
&lt;p&gt;为什么我们的系统需要事务？看如下这些故障：1、若是用户成功秒杀商品我们记录了其购买明细却没有减库存。导致商品的超卖。2、减了库存却没有记录用户的购买明细。导致商品的少卖。对于上述两个故障，若是没有事务的支持，损失最大的无疑是我们的用户和商家。在MySQL中，它内置的事务机制，可以准确的帮我们完成减库存和记录用户购买明细的过程。&lt;/p&gt;
&lt;p&gt;MySQL实现秒杀的难点分析：当用户A秒杀id为10的商品时，此时MySQL需要进行的操作是：1、开启事务。2、更新商品的库存信息。3、添加用户的购买明细，包括用户秒杀的商品id以及唯一标识用户身份的信息如电话号码等。4、提交事务。若此时有另一个用户B也在秒杀这件id为10的商品，他就需要等待，等待到用户A成功秒杀到这件商品然后MySQL成功的提交了事务他才能拿到这个id为10的商品的锁从而进行秒杀，而同一时间是不可能只有用户B在等待，肯定是有很多很多的用户都在等待拿到这个行级锁。秒杀的难点就在这里，如何高效的处理这些竞争？如何高效的完成事务？在后面第4个模块如何进行高并发的优化为大家讲解。&lt;/p&gt;
&lt;p&gt;我们这个系统需要完成秒杀的哪些功能？先来看看天猫的一个秒杀库存系统：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517078980637.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家看了是不是觉得很复杂？当然不用担心，我们只是实现秒杀的一些功能：1、秒杀接口的暴露。2、执行秒杀的操作。3、相关查询，比如说列表查询，详情页查询。我们实现这三个功能即可。接下来进行具体的编码工作，首先是建立数据库以及Dao层的编码。&lt;/p&gt;
&lt;h2 id=&quot;建立数据库&quot;&gt;建立数据库&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 创建一个数据库&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;DATABASE&lt;/span&gt; ngu_seckill;

&lt;span class=&quot;co&quot;&gt;-- 使用数据库&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;USE&lt;/span&gt; ngu_seckill;

&lt;span class=&quot;co&quot;&gt;-- 省略...&lt;/span&gt;
... ...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的数据库sql代码，在项目的&lt;code&gt;sql&lt;/code&gt;文件夹里的&lt;code&gt;ngu_seckill.sql&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建实体类&quot;&gt;创建实体类&lt;/h2&gt;
&lt;p&gt;先创建秒杀商品类&lt;code&gt;com/nnngu/entity/Seckill.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.nnngu.entity;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.Serializable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.time.LocalDateTime;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 秒杀商品&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Seckill &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Serializable {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; serialVersionUID = 2912164127598660137L;
    &lt;span class=&quot;co&quot;&gt;/* 主键ID*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; seckillId;
    &lt;span class=&quot;co&quot;&gt;/*  秒杀商品名字 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String name;
    
    &lt;span class=&quot;co&quot;&gt;/* 代码省略，请参照项目的源代码 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;...
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建秒杀状态类&lt;code&gt;com/nnngu/entity/SuccessKilled.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.nnngu.entity;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.Serializable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.time.LocalDateTime;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 秒杀后的状态&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SuccessKilled &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Serializable {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; serialVersionUID = 1834437127882846202L;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; seckillId;
    
    &lt;span class=&quot;co&quot;&gt;/* 用户的手机号码*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; userPhone;
    
    &lt;span class=&quot;co&quot;&gt;/* 代码省略，请参照项目的源代码 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;...
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;为实体类创建对应的mapper接口也就是dao接口&quot;&gt;为实体类创建对应的mapper接口，也就是dao接口&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;com/nnngu/dao/SeckillMapper.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.nnngu.dao;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.nnngu.entity.Seckill;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.annotations.Param;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.time.LocalDateTime;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Map;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; SeckillMapper {
    &lt;span class=&quot;co&quot;&gt;/* 代码省略，请参照项目的源代码 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;...
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;com/nnngu/dao/SuccessKilledMapper.java&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.nnngu.dao;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.nnngu.entity.SuccessKilled;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.annotations.Param;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; SuccessKilledMapper {
    &lt;span class=&quot;co&quot;&gt;/* 代码省略，请参照项目的源代码 */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;...
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;创建对应的mapper.xml&quot;&gt;创建对应的&lt;code&gt;mapper.xml&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;resources&lt;/code&gt;目录下创建&lt;code&gt;com.nnngu.dao&lt;/code&gt;包，然后创建&lt;code&gt;SeckillMapper.xml&lt;/code&gt; 和 &lt;code&gt;SuccessKilledMapper.xml&lt;/code&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517069800569.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;com.nnngu.dao/SeckillMapper.xml&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 这里的代码省略 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 请参照项目的源代码 --&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;com.nnngu.dao/SuccessKilledMapper.xml&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 这里的代码省略 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 请参照项目的源代码 --&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;创建mybatis的配置文件mybatis-config.xml&quot;&gt;创建Mybatis的配置文件mybatis-config.xml&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517070510826.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mybatis-config.xml&lt;/code&gt;配置文件的内容参照项目的源代码&lt;/p&gt;
&lt;h2 id=&quot;建立连接数据库的配置文件jdbc.properties&quot;&gt;建立连接数据库的配置文件&lt;code&gt;jdbc.properties&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517071709680.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;jdbc.properties&lt;/code&gt; 里面的属性要根据自己的情况进行修改。&lt;/p&gt;
&lt;h2 id=&quot;建立spring的dao的配置文件&quot;&gt;建立Spring的dao的配置文件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建&lt;code&gt;applicationContext-dao.xml&lt;/code&gt;如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517072120210.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;applicationContext-dao.xml&lt;/code&gt;文件的具体代码请参照项目的源代码。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;创建测试类 &lt;code&gt;com/nnngu/dao/SeckillMapperTest.java&lt;/code&gt; 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517076548761.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该文件的具体代码请参照项目的源代码。&lt;/p&gt;
&lt;h3 id=&quot;测试结果&quot;&gt;测试结果&lt;/h3&gt;
&lt;p&gt;测试查询所有商品的方法&lt;code&gt;queryAll()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517076812755.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/28/1517077063824.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此，我们成功完成了Dao层开发及测试。下篇文章 &lt;a href=&quot;https://github.com/nnngu/LearningNotes/blob/master/nguSeckill/02%20Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%B9%8BService%E5%B1%82.md&quot;&gt;02 Java高并发秒杀项目之Service层&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jan 2018 02:30:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8370641.html</dc:identifier>
</item>
<item>
<title>WPF与Win32互操作 - 水果味的C</title>
<link>http://www.cnblogs.com/SyMind/p/8370519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SyMind/p/8370519.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、WPF如何使用HWND&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        当您创建WPF Window时，WPF会创建顶级HWND，并使用HwndSource将Window及其WPF内容放入HWND中。应用程序中其余的WPF内容共享此单个HWND。&lt;span id=&quot;mt36&quot; class=&quot;sentence&quot; data-guid=&quot;82c44a814f34c2cf6c525618ee145470&quot; data-source=&quot;An exception is menus, combo box drop downs, and other pop-ups.&quot;&gt;不过，菜单、组合框下拉列表和其他弹出窗口例外。 &lt;span id=&quot;mt37&quot; class=&quot;sentence&quot; data-guid=&quot;60a2e3bf97da578ab476b6b7501c2759&quot; data-source=&quot;These elements create their own top-level window, which is why a WPF menu can potentially go past the edge of the window HWND that contains it.&quot;&gt;这些元素创建它们自己的顶级窗口，这正是 WPF 菜单能跳出包含它的窗口 HWND 之外的原因。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;82c44a814f34c2cf6c525618ee145470&quot; data-source=&quot;An exception is menus, combo box drop downs, and other pop-ups.&quot;&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;60a2e3bf97da578ab476b6b7501c2759&quot; data-source=&quot;These elements create their own top-level window, which is why a WPF menu can potentially go past the edge of the window HWND that contains it.&quot;&gt;二、HwndSource类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        一个HwndSource实现Win32窗口可以包含WPF内容。在窗口中的WPF内容是可安排的，可测量的，和可渲染的；是可交互式输入的。因为HwndSource是专被设计来与Win32进行交互的，这个类展示了底层的Win32的特点。您可以使用这个类执行以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定窗口样式、窗口类样式和扩展窗口样式。&lt;/li&gt;
&lt;li&gt;在窗口程序的钩子中添加处理函数。&lt;/li&gt;
&lt;li&gt;提供窗口句柄（HWND）。&lt;/li&gt;
&lt;li&gt;销毁窗口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         HwndSource类被设计来用于处理一般的互操作，并不是被设计成一个包装管理HWND的角色。一般来说，它不提供用于管理窗口或检查属性状态的托管方法。相反，该HwndSource类可以通过Handle属性访问Win32窗口句柄（HWND），可以通过PInvoke Win32 API技术操作窗口。&lt;br/&gt;&lt;strong&gt;1 创建&lt;/strong&gt;&lt;br/&gt;        HwndSource只能在构造时被指定。创建一个HwndSource，首先要创建一个HwndSourceParameters结构并用所需的参数填充它。这些参数包括以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类、窗口和扩展的窗口样式。您必须在窗口被创建前使用PInvoke去改变样式。并非所有样式都可以在创建窗口后更改。更改窗口样式之前请参考win32文档。&lt;/li&gt;
&lt;li&gt;窗口的初始位置。&lt;/li&gt;
&lt;li&gt;窗口的初始大小，包括是否指定尺寸或以WPF内容大小的确定窗口的大小。&lt;/li&gt;
&lt;li&gt;父窗口。&lt;/li&gt;
&lt;li&gt;HwndSourceHook包括窗口的处理函数链。如果在构建时指定钩子，它将接收窗口的所有消息。你可以使用AddHook后创建窗口添加一个钩子。&lt;/li&gt;
&lt;li&gt;透明度设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2 对象生存周期&lt;/strong&gt;&lt;br/&gt;        HwndSource是正规的公共语言运行库（CLR）对象，其生命周期是由垃圾收集器管理。因为HwndSource代表非托管资源，所以HwndSource实现IDisposable接口。如果从所有者线程调用，同步调用处理立即破坏win32窗口。如果从另一个线程调用，win32窗口将异步销毁。在互操作的代码中显式调用Dispose可能对某些互操作场景是必要的。&lt;br/&gt;&lt;strong&gt;3 窗口处理函数&lt;/strong&gt;&lt;br/&gt;        HwndSource类实现了它自己的窗口处理函数。此窗口处理函数用于处理重要的窗口消息，如与布局、呈现和输入相关的消息。不过，您也可以在钩子上添加自己的处理函数。你可以在构造时,通过设置HwndSourceParameters.HwndSourceHook属性,在钩子中指定自己的处理函数，或者你也可以使用AddHook和RemoveHook在窗口创建之后添加和删除钩子中的处理函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;82c44a814f34c2cf6c525618ee145470&quot; data-source=&quot;An exception is menus, combo box drop downs, and other pop-ups.&quot;&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;60a2e3bf97da578ab476b6b7501c2759&quot; data-source=&quot;These elements create their own top-level window, which is why a WPF menu can potentially go past the edge of the window HWND that contains it.&quot;&gt;三、HwndSource类&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;82c44a814f34c2cf6c525618ee145470&quot; data-source=&quot;An exception is menus, combo box drop downs, and other pop-ups.&quot;&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;60a2e3bf97da578ab476b6b7501c2759&quot; data-source=&quot;These elements create their own top-level window, which is why a WPF menu can potentially go past the edge of the window HWND that contains it.&quot;&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span class=&quot;sentence&quot; data-guid=&quot;82c44a814f34c2cf6c525618ee145470&quot; data-source=&quot;An exception is menus, combo box drop downs, and other pop-ups.&quot;&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;60a2e3bf97da578ab476b6b7501c2759&quot; data-source=&quot;These elements create their own top-level window, which is why a WPF menu can potentially go past the edge of the window HWND that contains it.&quot;&gt;该例子中在钩子中扩展处理函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在Window类中&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; overried &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnSourceInitialized(EventArgs e)
{
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnSourceInitialized(e);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取窗体句柄&lt;/span&gt;
    IntPtr hwnd = &lt;span&gt;new&lt;/span&gt; WindowInteropHelper(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).Handle;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取HwndSource对象&lt;/span&gt;
    HwndSource hwndSource =&lt;span&gt; HwndSource.FromHwnd(hwnd);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向钩子中添加处理程序&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(hwndSource != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        hwndSource.AddHook(WndProc);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IntPtr WndProc(IntPtr hWnd, &lt;span&gt;int&lt;/span&gt; msg, IntPtr wideParam, IntPtr longParam, &lt;span&gt;ref&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; handled)
{
    swicth(msg)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对特定消息进行处理&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IntPtr.Zero;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 28 Jan 2018 00:48:00 +0000</pubDate>
<dc:creator>水果味的C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SyMind/p/8370519.html</dc:identifier>
</item>
<item>
<title>Oracle实战笔记（第四天） - 风之之</title>
<link>http://www.cnblogs.com/fzz9/p/8341984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzz9/p/8341984.html</guid>
<description>&lt;h2&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;今天的主要内容是：两个管理员用户sys&amp;amp;system、数据库的逻辑备份和逻辑恢复、数据字典、表空间&amp;amp;数据文件。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、Oracle数据库管理员的职责（了解）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;数据库管理员（dba）是对数据库数据进行维护和管理的工作者，一般有以下职责/工作：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;安装和升级Oracle数据库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;建库、表空间、表、视图、索引......&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指定并实施数据的备份和恢复计划。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据库权限管理、&lt;strong&gt;调优、故障排除&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于高级dba，要求能参与项目开发，会&lt;strong&gt;编写&lt;/strong&gt;sql语句、存储过程、触发器、规划、约束、包等内容。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;二、Oracle的两个管理员用户：sys&amp;amp;system&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;Oracle中的数据库管理员用户主要是：sys和system。但这两个用户是有&lt;strong&gt;区别&lt;/strong&gt;的：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　1、最重要的区别，存储的数据的重要性不同&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;sys&lt;/strong&gt;：&lt;strong&gt;是oracle权限最高的用户&lt;/strong&gt;：所有的oracle的数据字典的基表和视图都存放在sys用户中，这些基表和视图对于oracle的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。 sys用户拥有sysdba（系统数据库管理员）、sysoper（系统操作员）、dba（数据库管理员）三个角色或权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;system&lt;/strong&gt;：用户用于存放&lt;strong&gt;次一级&lt;/strong&gt;的内部数据，如oracle的一些特性或工具的管理信息。system用户拥有sysoper权限、dba角色权限或系统权限，比sys。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2、其次的区别：权限的不同&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;sys&lt;/strong&gt;：用户具有“SYSDBA”或者“SYSOPER”系统权限，所以&lt;strong&gt;必须&lt;/strong&gt;用&quot;as sysdba&quot;或“as sysoper”登录，不能用normal。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;注意：&lt;/strong&gt;可能你使用普通用户 as sysdba也能登录成功，比如SQL&amp;gt; conn scott/tiger as sysdba 也能登录成功，但这不代表scott具有sysdba的权限。甚至有时候你随便输入一个不存在的账号密码然后输入 as sysdba也能登录成功，这是因为Oracle登录除了口令认证外还能使用操作系统认证，这就是&lt;strong&gt;外部认证方式&lt;/strong&gt;，验证时oracle会对数据库配置文件sqlnet.ora进行读取，这文件就是oracle登录需要验证读取的文件。该文件的位置为：D:\oracle\product\10.2.0\db_1\network\ADMIN\sqlnet.ora，该文件中的SQLNET.AUTHENTICATION_SERVICES= (NTS)，参数值：NTS就是指定使用操作系统认证方式。不输入用户名密码登录成功还有重要一点：安装oracle时，oracle会自动创建一个操作系统数据库管理员组“ora_dba”，将当前操作系统用户添加至ora_dba组中，才可登录成功。所以如果你访问的是本地Oracle，那么你的电脑本身就已经相当于是sys用户了，就好比在自己家，当个皇帝肿么了的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;system&lt;/strong&gt;：拥有sysoper和dba角色权限。正常登录即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3、sysdba、sysoper和dba三个角色的区别&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;首先权限大小不同，sysdba权限最大，sysoper次之，dba最小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　sysdba和sysoper的权限对比图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180124170459459-1434328475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;而dba的权限相对就更小一些了：上面两种特权用户sys和sysoper都能启动和关闭数据库，而dba用户只有在启动数据库后才能执行各种操作。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、数据库的逻辑备份&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;逻辑备份&lt;/strong&gt;是指使用&lt;strong&gt;工具export&lt;/strong&gt;将数据对象的结构和数据导出到文件的过程，&lt;strong&gt;逻辑恢复&lt;/strong&gt;是指当数据库对象被破坏而使用&lt;strong&gt;工具import&lt;/strong&gt;利用备份的文件把数据对象导入到数据库的过程，逻辑备份和恢复只能在open即数据库打开的情况下进行。（简单来说备份就是将数据库对象存到磁盘中，恢复就是将备份的数据导入数据库）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　1、导出(3种)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;导出具体分为三种：导出表、导出方案、导出数据库三种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　导出使用exp命令来完成的，该命令常用的选项有：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;userid:&lt;/strong&gt; 用于指定执行导出操作的用户名、口令、连接字符串&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;tables:&lt;/strong&gt; 用户指定执行导出操作的&lt;strong&gt;表&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;owner:&lt;/strong&gt; 用于指定执行导出操作的&lt;strong&gt;方案&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;full=y:  &lt;/strong&gt; 用户指定执行导出操作的&lt;strong&gt;数据库&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;inctype:&lt;/strong&gt;用于指定执行导出操作的增量类型     ，也叫增量备份(当第一次备份完之后,第二次备份只会备份新的数据,老的数据不会进行备份)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;rows:    &lt;/strong&gt;用于指定执行导出操作是否要导出&lt;strong&gt;表数据&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;file:      &lt;/strong&gt; 用于指定导出文件名路径&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　注意：使用导出操作的口令不能在sqlplus工具中运行（但是需要先连接数据库），而是在&lt;strong&gt;exp.exe&lt;/strong&gt;程序中执行导出操作。该文件一般位于H:\app\Administrator\product\11.2.0\dbhome_1\&lt;strong&gt;BIN，&lt;/strong&gt;H盘是我的Oracle安装盘，你可以直接点击exe进行操作界面，获取你可以使用cmd，进入界面，下面是使用cmd的导出过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1250367/201801/1250367-20180124173544694-1783887865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2、导出之导出表&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导出自己的表&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;用户名&lt;span&gt;/&lt;/span&gt;密码&lt;span&gt;@数据库实例名&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(表名) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;导出表的路径
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导出其他用户的表&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;用户名&lt;span&gt;/&lt;/span&gt;密码&lt;span&gt;@数据库实例名&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(方案名.表名) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;导出表的路径
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;导出多张表&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp userid&lt;span&gt;=用户名&lt;span&gt;/密码&lt;span&gt;@数据库实例名 tables&lt;span&gt;=(表1名,表2名,表3名) &lt;span&gt;file&lt;span&gt;=导出表的路径&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;只导出表的结构(当表中的数据特别大时,只导出表的结构)&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;scott&lt;span&gt;/&lt;/span&gt;tiger&lt;span&gt;@orcl&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(emp) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:&lt;span&gt;/&lt;/span&gt;test.dmp &lt;span&gt;&lt;strong&gt;rows&lt;/strong&gt;=&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;当&lt;/span&gt;&lt;span&gt;&lt;span&gt;表的数据量非常大时,使用&quot;直接导出的方式&quot;来处理这种大表,速度比常规的方法要快&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;scott&lt;span&gt;/&lt;/span&gt;tiger&lt;span&gt;@orcl&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(emp) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\aaa.dmp &lt;span&gt;&lt;strong&gt;direct=y&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　3、导出之导出方案&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;导出方案是指导出一个方案或者多个方案中的所有对象(表、索引、约束..)和数据,并存放到文件中。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导出自己的方案&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;scott&lt;span&gt;/&lt;/span&gt;tiger&lt;span&gt;@orcl&lt;/span&gt; owner&lt;span&gt;=&lt;/span&gt;scott &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\scott.dm
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导出他人的方案&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;system&lt;span&gt;/&lt;/span&gt;manager&lt;span&gt;@orcl&lt;/span&gt; owner&lt;span&gt;=&lt;/span&gt;(scott) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;D:\scott.dmp
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;导出多个方案&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;system&lt;span&gt;/&lt;/span&gt;manager&lt;span&gt;@orcl&lt;/span&gt; owner&lt;span&gt;=&lt;/span&gt;(system,scott) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\test.dmp
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　4、导出之导出数据库&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导出数据库是指使用export工具导出数据库中的所有对象及数据,要求用户必须具有sysdba或是exp_full_database的权限。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;exp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;system&lt;span&gt;/&lt;/span&gt;manager&lt;span&gt;@orcl&lt;/span&gt; &lt;span&gt;full&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;y inctype&lt;span&gt;=&lt;/span&gt;complete &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;orcl.dmp
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;四、数据库的逻辑恢复&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;导入就是使用工具import将文件中的对象和数据导入到数据库中,导入的文件必须对应导出的文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面是导入关键字imp的常用口令：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;userid：&lt;/strong&gt;用于指定要执行导入操作的用户名、密码、连接字符串(也就是数据库实例名)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;tables：&lt;/strong&gt;用于指定要执行导入操作的表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;formuser：&lt;/strong&gt;用于指定源用户&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;touser：&lt;/strong&gt;用于指定目标用户&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;file：&lt;/strong&gt;用于指定导入文件名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;full=y ：&lt;/strong&gt;用于指定导入整个文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;inctype：&lt;/strong&gt;用于指定执行导入操作的增量类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;rows：&lt;/strong&gt;用于指定是否要导入表行(数据)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;ignore：&lt;/strong&gt;如果表存在,则只导入数据&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　1、导入表&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;scott&lt;span&gt;/&lt;/span&gt;tiger&lt;span&gt;@orcl&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(emp) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\emp.dmp;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;导入表到其他用户&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;system&lt;span&gt;/&lt;/span&gt;manager&lt;span&gt;@orcl&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(emp) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\test.dmp touser&lt;span&gt;=&lt;/span&gt;scott
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;只导入表的结构&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=scott&lt;span&gt;/tiger&lt;span&gt;@orcl tables&lt;span&gt;=(emp) &lt;span&gt;file&lt;span&gt;=d:\emp.dmp rows&lt;span&gt;=n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;只导入数据&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;scott&lt;span&gt;/&lt;/span&gt;tiger&lt;span&gt;@orcl&lt;/span&gt; tables&lt;span&gt;=&lt;/span&gt;(emp) &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\emp.dmp ignore&lt;span&gt;=&lt;/span&gt;y
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　2、导入方案&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导入自身的方案&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;scott&lt;span&gt;/&lt;/span&gt;tiger&lt;span&gt;@orcl&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\scott.dmp
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;导入到其他方案&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;system&lt;span&gt;/&lt;/span&gt;manager&lt;span&gt;@orcl&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\scott.dmp fromuser&lt;span&gt;=&lt;/span&gt;system touser&lt;span&gt;=&lt;/span&gt;scott
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　3、导入数据库&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;imp&lt;/span&gt; userid&lt;span&gt;=&lt;/span&gt;system&lt;span&gt;/&lt;/span&gt;manager &lt;span&gt;full&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;y &lt;span&gt;file&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;d:\xxx.emp
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt; 五、数据字典&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　1、概念&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;数据字典&lt;/strong&gt;是Oracle数据库中最重要的组成部分，它提供了数据库的一些系统信息（静态信息）。数据字典是描述数据的信息集合，是对系统中使用的所有数据元素的定义的集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;动态性能&lt;/strong&gt;记载了例程启动后的相关信息（动态信息）。当启动oracle  server时，系统会自动建立动态性能视图；当停止oracle serve时，系统会删除动态性能视图。oracle的所有动态性能视图都以v-$开始的，并且oracle为每个动态性能视图都提供了相应的同义词，并且同义词是以v$开始的，例如v-$da tafile的同义词为v$da tafile；动态性能视图的所有者为sys，一般情况下，有dab或是特权用户来查询动态性能视图。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2、数据字典视图&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;数据字典的所有者是sys用户，所以用户只能在数据字典上执行查询操作，而其他操作都是系统自动完成的。Oracle中的数据字典包括数据字典基表和数据字典视图，其中&lt;strong&gt;基表&lt;/strong&gt;存储数据库的基本信息，普通用户不能直接访问；而&lt;strong&gt;数据字典视图&lt;/strong&gt;是基于数据字典基表所建立的视图，普通用户可以通过查询数据字典视图查询系统信息，数据字典视图主要包括&lt;strong&gt;user_xxx、all_xxx、dba_xxx&lt;/strong&gt;三种类型。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;strong&gt;user_tables：&lt;/strong&gt;用于返回用户对应方案的所有表。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;显示用户所有表名&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;  table_name &lt;span&gt;from&lt;/span&gt; user_tables
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;all_tables：&lt;/strong&gt;返回当前客户可以访问的所有表。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;dba_tables：&lt;/strong&gt;返回所有方案拥有的数据库表，但这种查询需要具有dba角色权限或具有select any table的系统权限。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在建立用户时，Oracle会把用户的信息存到数据库的数据字典中；当给用户授予权限或角色时，Oracle也会将权限或角色的信息存放到数据字典中。所以，通过查询数据字典可以查询用户信息、权限和角色等信息：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;&lt;span&gt;&lt;strong&gt;dba_users：&lt;/strong&gt;可以显示所有数据库用户的详尽信息。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询数据库中的所有用户名,密码&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; username,password &lt;span&gt;from&lt;/span&gt; dba_user;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;dba_sys_privs：&lt;/strong&gt;可以显示用户具有的系统权限。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;strong&gt;dba_tab_privs：&lt;/strong&gt;可以显示用户具有的对象权限。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询用户SCOTT的对象权限&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dba_tab_privs &lt;span&gt;where&lt;/span&gt; grantee&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCOTT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;dba_col_privs：&lt;/strong&gt;可以显示用户具有的列权限。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;&lt;strong&gt;dba_role_privs：&lt;/strong&gt;可以显示用户具有的角色。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询scott拥有的角色信息(用户名大写)&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dba_role_privs &lt;span&gt;where&lt;/span&gt; grantee&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCOTT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;strong&gt;dba_rules&lt;/strong&gt;：系统角色&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;数据库中的角色信息&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dba_roles;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;&lt;strong&gt;dba_sys_privs：&lt;/strong&gt;系统权限&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询角色为&quot;CONNECT&quot; 的系统权限&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dba_sys_privs &lt;span&gt;where&lt;/span&gt; grantee&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CONNECT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;扩展：&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;显示当前用户可以访问的所有数据字典视图&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; dict &lt;span&gt;where&lt;/span&gt; comments &lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%grant%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;显示当前数据库全称&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; global_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;六、表空间和数据文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;表空间是数据库的逻辑组成部分。从物理上讲，数据是存放在数据文件中的，而从逻辑上讲，数据是存放在表空间中的，一个表空间有若干个数据文件组成。把oracle数据库看作一个实在房间，表空间可以看作这个房间的空间，是可以自由分配，在这空间里面可以堆放多个箱子（箱子可以看作数据库文件），箱子里面再装物件（物件看作表）。用户指定表空间也就是你希望把属于这个用户的表放在那个房间（表空间）里面。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　数据库的逻辑结构&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;Oracle中的逻辑结构包括：表空间、段、区、块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据库是由表空间构成，而表空间由段构成，段又由区构成，最后区又由Oracle块构成。这样分级是为了提高数据库的效率。数据库就好比一个国家，为了方便管理，我们将国家分为省，省又分为市，依次类推。Oracle也是如此，表空间的设计大大提高了数据库的效率，表空间能：1）控制数据库占用的磁盘空间大小；2）dba可以&lt;strong&gt;将不同的数据类型部署到不同的位置&lt;/strong&gt;，这样有利于提高I/O性能，同时利于备份和恢复等操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2、表空间的操作&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;strong&gt;创建表空间：&lt;/strong&gt;使用create tablespace来创建（操作用户需要具有dba权限或create tablespace的系统权限）。在创建数据库后为了方便管理表，我们通常要建立自己的表空间。&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建一个名为sp01，数据文件大小为20m，段大小为128k的表空间，存储位置为：d:\test\sp01.dbf&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; tablespace sp01 dbfile&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d:\test\sp01.dbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; size 20m uniform size 128k;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;&lt;span&gt;&lt;strong&gt;使用表空间&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;将新表存放到表中间sp01中&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; myemp(empno &lt;span&gt;number&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;),ename vachar2(&lt;span&gt;10&lt;/span&gt;),sal &lt;span&gt;number&lt;/span&gt;) tablespace sp01;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;&lt;strong&gt;改变表空间的状态&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当建立表空间的时，表空间处于联机状态（online）。联机状态下允许进行访问和读写等操作，但在某些时候如系统维护或数据维护时需要改变表空间的状态（需要特权用户进行操作）：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1）脱机状态offline&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace 表空间名 offline
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）联机状态&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace 表空间名 online
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3）只读状态&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace 表空间名 &lt;span&gt;read&lt;/span&gt; &lt;span&gt;only&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;span&gt;删除表空间&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; tablespace 表空间名 including contents &lt;span&gt;and&lt;/span&gt; datafiles;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;contents和datafiles分别表示删除表时将所有数据库对象和数据库文件也删除。&lt;/span&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;span&gt;扩展表空间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;表空间是由数据文件组成的，表空间的实际大小就是数据文件占用的大小，那么如果文件大小超过了表空间大小初始值那么继续插入数据就会报错，所以需要进行表空间扩展，一般有三种方法：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1）增加数据文件&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace 表空间名 &lt;span&gt;add&lt;/span&gt; datafile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d:\test\sp02.dbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; size 20m;
&lt;/pre&gt;&lt;/div&gt;
&lt;span&gt;2）增加文件的大小（单个文件一般不要超过500m）&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace 表空间名 datafile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d:\test\sp02.dbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; resize 50m;
&lt;/pre&gt;&lt;/div&gt;
&lt;span&gt;3）设置文件的自动增长&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;空间不足时自动增加10m，最大空间500m&lt;/span&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace 空间名 &lt;span&gt;add&lt;/span&gt; datafile &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d:\test\sp01.dbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; autoextend &lt;span&gt;on&lt;/span&gt; &lt;span&gt;next&lt;/span&gt; 10m maxsize 500m;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;&lt;span&gt;移动数据文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有时磁盘的损坏导致数据文件无法再继续使用，为了能够继续使用需要将这些数据文件副本进行转移到其他磁盘，然后进行数据恢复。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下面以移动数据文件sp01.dbf进行说明：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1）确定数据文件所在的表空间&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; tablespace_name &lt;span&gt;from&lt;/span&gt; dba_data_files &lt;span&gt;where&lt;/span&gt; filename&lt;span&gt;=&lt;span&gt;'&lt;span&gt;d:\test\sp01.dbf&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）使表空间脱机：为了保证数据一致性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace sp01 offline;
&lt;/pre&gt;&lt;/div&gt;
&lt;span&gt;3）使数据文件移动到指定的目录&lt;/span&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
host move &lt;span&gt;&lt;span&gt;'&lt;span&gt;d:\test\sp01.dbf&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;'&lt;span&gt;c:\test\sp01.dbf&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4）执行alter tablespace 命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在物理迁移后，为了使用户能访问到该数据文件，需要对数据文件进行逻辑上的修改：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace sp01 rename &lt;span&gt;&lt;span&gt;'&lt;span&gt;d:\test\sp01.dbf&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;to &lt;span&gt;&lt;span&gt;'c&lt;span&gt;:\test\sp01.dbf&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5）如果需要访问该表空间，需要将表空间联机&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alter&lt;/span&gt; tablespace sp01 online
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 27 Jan 2018 16:26:00 +0000</pubDate>
<dc:creator>风之之</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzz9/p/8341984.html</dc:identifier>
</item>
<item>
<title>QT5 Thread线程 - 疯颠研究者</title>
<link>http://www.cnblogs.com/flowingwind/p/8361939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flowingwind/p/8361939.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;QT5 Thread线程继承QThread方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;一.首先分析一下 QTimer Class与 Sleep()函数之间的秘密&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QTimer *t = new QTimer(*parent); //创建QTimer 对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t-&amp;gt;start(_time); //计时开始每隔_time时间自动触发&amp;amp;QTimer::timeout信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t-&amp;gt;stop(); //结束计时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Sleep() //windows.h里面的系统延时函数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过以上方法实现案例:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180126215049006-1123233500.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;button 槽函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Widget::on_buttonstart_clicked()
{
    t&lt;/span&gt;-&amp;gt;start(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
    Sleep(&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;　　qDebug() &amp;lt;&amp;lt; &quot;hello world!&quot;; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;timeout信号处理函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;connect(t, &lt;/span&gt;&amp;amp;&lt;span&gt;QTimer::timeout,
            [&lt;/span&gt;=&lt;span&gt;]()
    {
        ui&lt;/span&gt;-&amp;gt;lcd_1-&amp;gt;display(++&lt;span&gt;i);
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分析,在没有Sleep()函数的情况下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击开始立马在控制台显示&lt;span&gt;hello world!;&lt;/span&gt;每隔2秒lcd显示+1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有Sleep()的存在后;点击开始程序本质是想每隔2秒lcd显示+1;3秒后控制台显示&lt;span&gt;hello world!;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180126223912006-1128054455.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终结果是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击开始,计时器计时,2秒后,不运行connect();3秒后connect()第一次运行;再过4秒,第二次timeout信号触发,再次运行connect();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终显示结果为; 过时&lt;span&gt;3&lt;/span&gt;秒制台显示&lt;span&gt;hello world!lcd&lt;/span&gt;显示 &lt;span&gt;1&lt;/span&gt; 再过时1秒显示&lt;span&gt;2&lt;/span&gt; 再过&lt;span&gt;2&lt;/span&gt;秒显示&lt;span&gt;3&lt;/span&gt; 依次经过2秒显示累加1;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;二.线程的引入;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果我们想要的结果是,点击按钮,lcd每一秒显示+1, 3秒控制台回显hello world!  也就是Sleep(3000)显示hello world!并不会去影响到Qtrimer计时;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180126225242553-227814321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 单独创建线程A,在A线程是实现延时3秒输出hello world!;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.一个简单的控制台线程例子&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建一个qt控制台程序 自定义一个类  这里就叫class mythread&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//mythread.h&lt;/span&gt;&lt;p&gt;#ifndef MYTHREAD_H
&lt;/p&gt;&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MYTHREAD_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QThread&amp;gt;

&lt;span&gt;class&lt;/span&gt; myThread: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QThread
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    myThread();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(); &lt;span&gt;&lt;span&gt;//声明继承于QThread虚函数 run()&lt;/span&gt;&lt;/span&gt;
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MYTHREAD_H&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mythread.cpp&lt;/span&gt;
&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QDebug&amp;gt;&lt;span&gt;

myThread::myThread()
{

}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; myThread::run()
{
  qDebug() &lt;/span&gt;&amp;lt;&amp;lt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; &lt;span&gt;//复写QThread类的 run()函数&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.cpp&lt;/span&gt;
#include &amp;lt;QCoreApplication&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包涵头文件&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QCoreApplication a(argc, argv);

    myThread &lt;/span&gt;*thread1 = &lt;span&gt;new&lt;/span&gt; myThread; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建线程对象&lt;/span&gt;
    thread1-&amp;gt;start();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
 
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上例启动了一个新线程中输出hello world!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;改进上例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//mythread.h&lt;/span&gt;&lt;br/&gt;#ifndef MYTHREAD_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MYTHREAD_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QThread&amp;gt;

&lt;span&gt;class&lt;/span&gt; myThread: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QThread
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    myThread();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
    QString name; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个 name 对象&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MYTHREAD_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mythread.cpp&lt;/span&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QDebug&amp;gt;&lt;span&gt;

myThread::myThread()
{

}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; myThread::run()
{
  qDebug() &lt;/span&gt;&amp;lt;&amp;lt;  &lt;span&gt;this&lt;/span&gt;-&amp;gt;name &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个for循环&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
  {
      qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;name &amp;lt;&amp;lt;&lt;span&gt; i;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.cpp&lt;/span&gt;
&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QCoreApplication&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QCoreApplication a(argc, argv);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连续创建三个子线程&lt;/span&gt;&lt;span&gt;
    myThread &lt;/span&gt;*thread1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; myThread;
    thread1&lt;/span&gt;-&amp;gt;name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythred1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    thread1&lt;/span&gt;-&amp;gt;&lt;span&gt;start();
    
    myThread &lt;/span&gt;*thread2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; myThread;
    thread2&lt;/span&gt;-&amp;gt;name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythred2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    thread2&lt;/span&gt;-&amp;gt;&lt;span&gt;start();

    myThread &lt;/span&gt;*thread3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; myThread;
    thread3&lt;/span&gt;-&amp;gt;name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythred3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    thread3&lt;/span&gt;-&amp;gt;&lt;span&gt;start();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行结果:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180127032440053-1676492209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果显示输出为无序输出,结论三个线程完全独立运行,互不影响;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.三个线程,自然会有优先权的问题,也就是cpu,先运行哪个线程;下面&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;00:00:47.879 ~ 00:00:49.770 that let's talk about priority a little  &quot;&gt;让我们来谈谈优先权&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;00:00:47.879 ~ 00:00:49.770 that let's talk about priority a little  &quot;&gt;线程权限由线程启动函数start(&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;00:00:47.879 ~ 00:00:49.770 that let's talk about priority a little  &quot;&gt;&lt;span&gt;Priority&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;00:00:47.879 ~ 00:00:49.770 that let's talk about priority a little  &quot;&gt;枚举&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;)控制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;00:00:47.879 ~ 00:00:49.770 that let's talk about priority a little  &quot;&gt;如上例:在启动函数中加入枚枚量,具体参数可查帮助文档:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;00:00:47.879 ~ 00:00:49.770 that let's talk about priority a little  &quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180127034317740-367238355.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;span&gt;QMutex 类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;QMutex类提供了线程之间的访问序列化。&lt;br/&gt;QMutex的目的是保护对象，数据结构或代码段，以便一次只有一个线程可以访问它（这与Java synchronized关键字类似）。 QMutexLocker通常最好使用互斥锁，因为这样可以很容易地确保锁定和解锁一致地执行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;int&lt;/span&gt; number = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; method1()
  {
      number &lt;/span&gt;*= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
      number &lt;/span&gt;/= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; method2()
  {
      number &lt;/span&gt;*= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
      number &lt;/span&gt;/= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 如果线程thread1 ,thread2分别顺序执行&lt;span&gt;method1()&lt;/span&gt;,&lt;span&gt;method2();最终结果将会是:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; method1()&lt;/span&gt;
  number *= &lt;span&gt;5&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 30&lt;/span&gt;
  number /= &lt;span&gt;4&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 7

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; method2()&lt;/span&gt;
  number *= &lt;span&gt;3&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 21&lt;/span&gt;
  number /= &lt;span&gt;2&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;number = 10;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但如果线程1在行动时,被系统挂载,或其它种种因素受到延时运行,比如有更高优先级线程申请运行,而线程2确并不受影响,最终结果将会是:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread 1 calls method1()&lt;/span&gt;
  number *= &lt;span&gt;5&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 30

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread 2 calls method2().
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Most likely Thread 1 has been put to sleep by the operating
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; system to allow Thread 2 to run.&lt;/span&gt;
  number *= &lt;span&gt;3&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 90&lt;/span&gt;
  number /= &lt;span&gt;2&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 45

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Thread 1 finishes executing.&lt;/span&gt;
  number /= &lt;span&gt;4&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; number is now 11, instead of 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时number = 11; 并不等于10; 同一程序运行不同结果,这是不允许的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时就要借助于QMutex 类;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; QMutex mutex;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; number = &lt;span&gt;6&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; method1()
  {
      mutex.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
      number &lt;/span&gt;*= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
      number &lt;/span&gt;/= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
      mutex.unlock();
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; method2()
  {
      mutex.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
      number &lt;/span&gt;*= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
      number &lt;/span&gt;/= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
      mutex.unlock();
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;当你在一个线程中调用lock（）时，其他&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;线程&lt;/span&gt;会试图在同一个地方调用lock（），直到获得锁的&lt;span id=&quot;result_box&quot; lang=&quot;zh-CN&quot;&gt;线程&lt;/span&gt;调用unlock（）。 lock（）的一个非阻塞替代是tryLock（）。&lt;br/&gt;QMutex在非竞争情况下进行了优化。 如果该互斥体没有争用，则非递归QMutex将不分配内存。 它的构建和销毁几乎没有开销，这意味着有很多互斥体作为其他类的一部分是很好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;当线程1被cpu延时处理,而线程2处理到method2()时自动会进入method1()继续处理number /=4;再回到method2();而此时如果线程1继续执行时,自动又会进入到method2();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;4.QThread 启动暂停等待信号与槽控制实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 延续控制台线程例子 在每个线程后面加上 &lt;span&gt;thread1-&amp;gt;&lt;span&gt;wait(); qDebug() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;span&gt;hello world!&lt;span&gt;&quot;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;预期的结果将会是, 在线程输出完后才会输出&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;QCoreApplication&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QCoreApplication a(argc, argv);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连续创建三个子线程&lt;/span&gt;
    myThread *thread1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; myThread;
    thread1&lt;/span&gt;-&amp;gt;name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mythred1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    thread1&lt;/span&gt;-&amp;gt;&lt;span&gt;start();
    
    thread1&lt;/span&gt;-&amp;gt;&lt;span&gt;wait();
    qDebug() &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在转到GUI下,下面一个例子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180127230847912-1965757322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程类,头文件&lt;/span&gt;
&lt;span&gt;#ifndef NITHREAD_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; NITHREAD_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QThread&amp;gt;

&lt;span&gt;class&lt;/span&gt; nithread : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QThread
{
    Q_OBJECT
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; nithread(QObject *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; stop;

signals:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; sig(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; slots:
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NITHREAD_H&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程类cpp&lt;/span&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nithread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QMutex&amp;gt;&lt;span&gt;
nithread::nithread(QObject &lt;/span&gt;*&lt;span&gt;parent) : QThread(parent)
{

}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; nithread::run()
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
    {
        QMutex mutex;
        mutex.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;-&amp;gt;stop) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        mutex.unlock();
        emit sig(i);
        msleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GUi窗口类头文件&lt;/span&gt;
&lt;span&gt;#ifndef DIALOG_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; DIALOG_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;QDialog&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;nithread.h&amp;gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dialog;
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dialog : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QDialog
{
    Q_OBJECT

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;explicit&lt;/span&gt; Dialog(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;~&lt;span&gt;Dialog();

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_buttonstart_clicked();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; lot(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_buttonstop_clicked();

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Ui::Dialog &lt;/span&gt;*&lt;span&gt;ui;
    nithread &lt;/span&gt;*&lt;span&gt;threadd;
};

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DIALOG_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GUI类cpp&lt;/span&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialog.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_dialog.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

Dialog::Dialog(QWidget &lt;/span&gt;*&lt;span&gt;parent) :
    QDialog(parent),
    ui(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::Dialog)
{
    ui&lt;/span&gt;-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    threadd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; nithread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    connect(threadd, SIGNAL(sig(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;)), &lt;span&gt;this&lt;/span&gt;, SLOT(lot(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)));
}

Dialog::&lt;/span&gt;~&lt;span&gt;Dialog()
{
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dialog::on_buttonstart_clicked()
{
    threadd&lt;/span&gt;-&amp;gt;&lt;span&gt;start();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Dialog::lot(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num)
{
    ui&lt;/span&gt;-&amp;gt;numberlabel-&amp;gt;&lt;span&gt;setText(QString::number(num));
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dialog::on_buttonstop_clicked()
{
    threadd&lt;/span&gt;-&amp;gt;stop = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main.cpp&lt;/span&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialog.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;QApplication&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    QApplication a(argc, argv);
    Dialog w;
    w.show();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最终结果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当点击start 开启线程 stop 停止线程 通过显号与槽显示结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;然而方法一Thread线程继承QThread方式,在实际问题中却有着很多的问题如下文简介:早在2006年已经被qt工程师提出;(&lt;strong&gt;&lt;span&gt;更&lt;/span&gt;&lt;/strong&gt;直指此方法是错误的用法)&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;我们（Qt用户）正广泛地使用IRC来进行交流。我在Freenode网站挂出了#qt标签，用于帮助大家解答问题。我经常看到的一个问题（这让我不厌其烦），是关于理解Qt的线程机制以及如何让他们写的相关代码正确工作。人们贴出他们的代码，或者用代码写的范例，而我则总是以这样的感触告终：&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;你们都用错了！&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;我觉得有件重要的事情得澄清一下，也许有点唐突了，然而，我不得不指出，下面的这个（假想中的）类是对面向对象原则的错误应用，同样也是对Qt的错误应用。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div id=&quot;crayon-5a6babd3c7609598315212&quot; class=&quot;crayon-syntax crayon-theme-github crayon-font-monaco crayon-os-pc print-yes notranslate&quot; data-settings=&quot; minimize scroll-always&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;
&lt;textarea readonly=&quot;readonly&quot; data-settings=&quot;dblclick&quot;&gt;
class MyThread : public QThread
{
public:
    MyThread()
    {
        moveToThread(this);
    }

    void run();

signals:
    void progress(int);
    void dataReady(QByteArray);

public slots:
    void doWork();
    void timeoutHandler();
};
&lt;/textarea&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;我对这份代码最大的质疑在于 &lt;span&gt;moveToThread(this);  我见过太多人这么使用，并且完全不明白它做了些什么。那么你会问，它究竟做了什么？moveToThread()函数通知Qt准备好事件处理程序，让扩展的信号（signal）和槽（slot）在指定线程的作用域中调用。QThread是线程的接口，所以我们是在告诉这个线程在“它内部”执行代码。我们也应该在线程运行之前做这些事。即使这份代码看起来可以运行，但它很混乱，并不是QThread设计中的用法（QThread中写的所有函数都应该在创建它的线程中调用，而不是QThread开启的线程）。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;在我的印象中，moveToThread(this);  是因为人们在某些文章中看到并且使用而流传开来的。一次快速的网络搜索就能找到此类文章，所有这些文章中都有类似如下情形的段落：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;em&gt;继承QThread类&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;添加用来进行工作的信号和槽&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;测试代码，发现槽函数并没有在“正确的线程”中执行&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;谷歌一下，发现了moveToThread(this);  然后写上“看起来的确管用，所以我加上了这行代码”&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;我认为，这些都源于第一步。QThread是被设计来作为一个操作系统线程的接口和控制点，而不是用来写入你想在线程里执行的代码的地方。我们（面向对象程序员）编写子类，是因为我们想扩充或者特化基类中的功能。我唯一想到的继承QThread类的合理原因，是添加QThread中不包含的功能，比如，也许可以提供一个内存指针来作为线程的堆栈，或者可以添加实时的接口和支持。用于下载文件、查询数据库，或者做任何其他操作的代码都不应该被加入到QThread的子类中；它应该被封装在它自己的对象中。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;通常，你可以简单地把类从继承QThread改为继承QObject，并且，也许得修改下类名。QThread类提供了start()信号，你可以将它连接到你需要的地方来进行初始化操作。为了让你的代码实际运行在新线程的作用域中，你需要实例化一个QThread对象，并且使用moveToThread()函数将你的对象分配给它。你同过moveToThread()来告诉Qt将你的代码运行在特定线程的作用域中，让线程接口和代码对象分离。如果需要的话，现在你可以将一个类的多个对象分配到一个线程中，或者将多个类的多个对象分配到一个线程。换句话说，将一个实例与一个线程绑定并不是必须的。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;我已经听到了许多关于编写Qt多线程代码时过于复杂的抱怨。原始的QThread类是抽象类，所以必须进行继承。但到了Qt4.4不再如此，因为QThread::run()有了一个默认的实现。在之前，唯一使用QThread的方式就是继承。有了线程关联性的支持，和信号槽连接机制的扩展，我们有了一种更为便利地使用线程的方式。我们喜欢便利，我们想使用它。不幸的是，我太晚地意识到之前迫使人们继承QThread的做法让新的方式更难普及。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;我也听到了一些抱怨，是关于没有同步更新范例程序和文档来向人们展示如何用最不令人头疼的方式便利地进行开发的。如今，我能引用的最佳的资源是&lt;a href=&quot;http://blog.qt.io/blog/2006/12/04/threading-without-the-headache/&quot; target=&quot;_blank&quot;&gt;我数年前写的一篇博客&lt;/a&gt;。()&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;免责声明：你所看到的上面的一切，当然都只是个人观点。我在这些类上面花费了很多精力，因此关于要如何使用和不要如何使用它们，我有着相当清晰的想法。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;译者注：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;最新的Qt帮助文档同时提供了建立QThread实例和继承QThread的两种多线程实现方式。根据文档描述和范例代码来看，若想在子线程中使用信号槽机制，应使用分别建立QThread和对象实例的方式；若只是单纯想用子线程运行阻塞式函数，则可继承QThread并重写QThread::run()函数。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;由于继承QThread后，必须在QThread::run()函数中显示调用QThread::exec()来提供对消息循环机制的支持，而QThread::exec()本身会阻塞调用方线程，因此对于需要在子线程中使用信号槽机制的情况，并不推荐使用继承QThread的形式，否则程序编写会较为复杂。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从Qt4.4开始,可以采用新的方法也是被称为正确的方法也是qt想推广的方法:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
// &lt;span&gt;Worker 类定义 cpp&lt;/span&gt;&lt;br/&gt;#include &amp;lt;QtCore&amp;gt;  
    &lt;span&gt;class&lt;/span&gt; Worker : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QObject  
    {  
        Q_OBJECT  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:  
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; onTimeout()  
        {  
            qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker::onTimeout get called from?: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;QThread::currentThreadId();  
        }  
    };  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//main函数cpp
&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])  
    {  
        QCoreApplication a(argc, argv);  
        qDebug()&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;From main thread: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;QThread::currentThreadId();  
       
        QThread t;  
        QTimer timer;  
        Worker worker;  
       
        QObject::connect(&lt;/span&gt;&amp;amp;timer, SIGNAL(timeout()), &amp;amp;&lt;span&gt;worker, SLOT(onTimeout()));  
        timer.start(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);  
       
        worker.moveToThread(&lt;/span&gt;&amp;amp;&lt;span&gt;t);  
       
        t.start();  
       
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.exec();  
    }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继承QThread老式方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.定义继承QThread的类A 复写run()函数;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在主线程中实例化A对象a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.通过调用a-&amp;gt;start()启动线程,线程会自动调用run()虚函数;run不可直接调用;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新方法:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.创建继承Obeject的类A 将要在线程中实现的方法在A类中实现&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.在主线程中实例化A对象a,再实例化QThread类对象b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.通过a.moveToThread(&amp;amp;b);将a对象的实现移入线程b对象作用范围内运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.b-&amp;gt;start()启动线程;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.通过信号与槽的方式启动调用A类成员函数;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用函数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QThread类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;start(),//启动线程;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait()//等待线程运行结束;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;quit(),//线程运行结束退出线程&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 16:18:00 +0000</pubDate>
<dc:creator>疯颠研究者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flowingwind/p/8361939.html</dc:identifier>
</item>
<item>
<title>数据库 MySQL进阶之索引 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8353262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8353262.html</guid>
<description>&lt;p&gt;&lt;strong&gt;数据库的索引非常重要，基本面试数据库的问题都在索引上，所以这里小编整理出来，一方面为了自己复习，一方面也方便大家。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt; 一，索引前传&lt;/h3&gt;
&lt;p&gt;　　在了解数据库索引之前，首先有必要了解一下数据库索引的数据结构基础，那么什么样的数据结构可以作为索引呢？&lt;/p&gt;
&lt;p&gt;　　B-tree是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。&lt;/p&gt;
&lt;p&gt;       B+是一个树数据结构，通常用于数据库和操作系统的文件系统中，B+树的特点是能够保持数据稳定有序，其插入与修改拥有比较稳定的对数时间复杂度，B+树元素自底向上插入，这个和二叉树刚好相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;B＋tree&lt;strong&gt; &lt;/strong&gt;是一个n叉树，每个节点有多个叶子节点，一颗B+树包含根节点，内部节点，叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上叶子节点的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　B＋tree的性质：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt;
&lt;p&gt;　　　　2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt;
&lt;p&gt;　　　　3.所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt;
&lt;p&gt;　　      由于B+tree的性质， 它通常被用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引，因为B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度（B+ 树元素自底向上插入）。&lt;/p&gt;
&lt;p&gt;B＋tree结构原型图大概如下（引用）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180126233802475-1520182255.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;哈希表索引是怎么工作的&quot;&gt;哈希表索引是怎么工作的？&lt;/h4&gt;
&lt;p&gt;　　哈希表是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高。所以，如果使用哈希索引，对于比较字符串是否相等的查询能够极快的检索出的值。&lt;/p&gt;
&lt;h4 id=&quot;哈希索引的缺点&quot;&gt;哈希索引的缺点是什么呢？&lt;/h4&gt;
&lt;p&gt;　　哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力。举例来说，假如你想要找出所有小于40岁的员工。你怎么使用使用哈希索引进行查询？这不可行，因为哈希表只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的。这就是为什么哈希索引通常不是数据库索引的默认数据结构-&lt;strong&gt;因为在作为索引的数据结构时，其不像B-Tree那么灵活&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;还有什么其他类型的索引&quot;&gt;还有什么其他类型的索引？&lt;/h4&gt;
&lt;p&gt;　　使用R-Tree作为数据结构的索引通常用来为空间问题提供帮助。例如，一个查询要求“查询出所有距离我两公里之内的星巴克”，如果数据库表使用R- Tree索引，这类查询的效率将会提高。&lt;br/&gt;　　另一种索引是位图索引（bitmap index）， 这类索引适合放在包含布尔值(true 和 false)的列上，但是这些值（表示true或false的值）的许多实例-基本上都是&lt;a href=&quot;http://www.programmerinterview.com/index.php/database-sql/selectivity-in-sql-databases/&quot; target=&quot;_blank&quot;&gt;选择性（selectivity）&lt;/a&gt;低的列。&lt;/p&gt;
&lt;h3&gt; 二，索引内容&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1、索引&lt;/strong&gt;&lt;br/&gt;　　索引是对数据库表中一列或者多列的值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息，索引有助于更快的获取信息。索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。&lt;/p&gt;
&lt;p&gt;　　索引的一个主要的目的就是加快检索表中数据的方法，也可以协助信息搜寻者能尽快的找到符合限制条件的记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2、索引种类&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;普通索引：仅加速查询&lt;/li&gt;
&lt;li&gt;唯一索引：加速查询 + 列值唯一（可以有null）
&lt;ul&gt;&lt;li&gt;唯一索引是不允许其中任何两行具有相同索引值的索引，当现有数据存在大量的重复的键值的时候，大多数数据库不允许唯一索引与表一起保存，数据库还可能防止添加将表中创建重复键值的新数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;主键索引：加速查询 + 列值唯一 +　表中只有一个（不可以有null）
&lt;ul&gt;&lt;li&gt;数据库表经常有一列或者多列组合，其值唯一标识表中的每一行，每一列称为表的主键，在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型，该索引要求主键索引的每个值都唯一。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;组合索引：多列值组成一个索引，&lt;br/&gt;              专门用于组合搜索，其效率大于索引合并&lt;/li&gt;
&lt;li&gt;全文索引：对文本的内容进行分词，进行搜索 &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;——普通索引&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; -1，创建表 + 索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in1(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    index ix_name (name)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; -2，创建表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create index index_name on table_name(column_name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-3，删除表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
drop index_name on table_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-4，查看索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
show index from table_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　注意：对于创建索引时如果是BLOB 和 TEXT 类型，必须指定length。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create index ix_extra on in1(extra(32));
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;——唯一索引&lt;/h4&gt;
&lt;p&gt;-1，创建表 + 唯一索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in1(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    unique ix_name (name)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，创建唯一索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create unique index 索引名 on 表名(列名)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-3，删除唯一索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
drop unique index 索引名 on 表名
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;——主键索引&lt;/h4&gt;
&lt;p&gt;-1，创建表+创建主键&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in1(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    index ix_name (name)
)

OR

create table in1(
    nid int not null auto_increment,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    primary key(ni1),
    index ix_name (name)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，创建主键&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
alter table 表名 add primary key(列名);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-3，删除主键&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
alter table 表名 drop primary key;
alter table 表名  modify  列名 int, drop primary key;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;——组合索引&lt;/h4&gt;
&lt;p&gt;组合索引是将n个列组合成一个索引&lt;/p&gt;
&lt;p&gt;其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = 'alex' and n2 = 666。&lt;/p&gt;
&lt;p&gt;-1，创建表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in3(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，创建组合索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create index ix_name_email on in3(name,email);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上创建组合索引之后，查询：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name and email  -- 使用索引&lt;/li&gt;
&lt;li&gt;name                 -- 使用索引&lt;/li&gt;
&lt;li&gt;email                 -- 不使用索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：对于同时搜索n个条件时，组合索引的性能好于多个单一索引合并。&lt;/p&gt;
&lt;h4&gt; ——其他&lt;/h4&gt;
&lt;p&gt;-1，条件语句（if条件语句例子）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
CREATE PROCEDURE proc_if ()
BEGIN
    
    declare i int default 0;
    if i = 1 THEN
        SELECT 1;
    ELSEIF i = 2 THEN
        SELECT 2;
    ELSE
        SELECT 7;
    END IF;

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，while循环语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
CREATE PROCEDURE proc_while ()
BEGIN

    DECLARE num INT ;
    SET num = 0 ;
    WHILE num &amp;lt; 10 DO
        SELECT
            num ;
        SET num = num + 1 ;
    END WHILE ;

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-3，repeat循环语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
CREATE PROCEDURE proc_repeat ()
BEGIN

    DECLARE i INT ;
    SET i = 0 ;
    repeat
        select i;
        set i = i + 1;
        until i &amp;gt;= 5
    end repeat;

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-4，loop循环语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
BEGIN
    
    declare i int default 0;
    loop_label: loop
        
        set i=i+1;
        if i&amp;lt;8 then
            iterate loop_label;
        end if;
        if i&amp;gt;=10 then
            leave loop_label;
        end if;
        select i;
    end loop loop_label;

END
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-5，动态执行SQL语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
DROP PROCEDURE IF EXISTS proc_sql \\
CREATE PROCEDURE proc_sql ()
BEGIN
    declare p1 int;
    set p1 = 11;
    set @p1 = p1;

    PREPARE prod FROM 'select * from tb2 where nid &amp;gt; ?';
    EXECUTE prod USING @p1;
    DEALLOCATE prepare prod; 

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;2.3、相关命令&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
查看表结构
    desc 表名
 
- 查看生成表的SQL
    show create table 表名
 
- 查看索引
    show index from  表名
 
- 查看执行时间
    set profiling = 1;
    SQL...
    show profiles;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4、索引的优缺点（使用索引和不使用索引）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点：&lt;/p&gt;

&lt;ul class=&quot;custom_dot para-list list-paddingleft-1&quot; readability=&quot;4&quot;&gt;&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;能提高数据的搜索及检索速度，符合数据库建立的初衷。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点  ：&lt;/p&gt;
&lt;ul class=&quot;custom_dot para-list list-paddingleft-1&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
由于索引是专门用于加速搜索而生，所以加上索引之后，查询效率会快到飞起来。
 
# 有索引
mysql&amp;gt; select * from tb1 where name = 'wupeiqi-888';
+-----+-------------+---------------------+----------------------------------+---------------------+
| nid | name        | email               | radom                            | ctime               |
+-----+-------------+---------------------+----------------------------------+---------------------+
| 255 | tonm        | 12474565666@qq.com  | cdccccce76a16a90b8a8301d5314204b | 2017-08-03 09:33:35 |
+-----+-------------+---------------------+----------------------------------+---------------------+
1 row in set (0.00 sec)
 
# 无索引
mysql&amp;gt; select * from tb1 where email = 'wupeiqi888@live.com';
+-----+-------------+---------------------+----------------------------------+---------------------+
| nid | name        | email               | radom                            | ctime               |
+-----+-------------+---------------------+----------------------------------+---------------------+
| 256 | tonm        | 12474565666@qq.com  | 5312269e76a1clslclscc01d5314204b | 2017-08-03 09:33:35 |
+-----+-------------+---------------------+----------------------------------+---------------------+
1 row in set (1.23 sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;25、正确使用索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。&lt;br/&gt;即使建立索引，索引也不会生效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
- like '%xx'
    select * from tb1 where name like '%cn';
- 使用函数
    select * from tb1 where reverse(name) = 'wupeiqi';
- or
    select * from tb1 where nid = 1 or email = 'seven@live.com';
    特别的：当or条件中有未建立索引的列才失效，以下会走索引
            select * from tb1 where nid = 1 or name = 'seven';
            select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex'
- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select * from tb1 where name = 999;
- !=
    select * from tb1 where name != 'alex'
    特别的：如果是主键，则还是会走索引
        select * from tb1 where nid != 123
- &amp;gt;
    select * from tb1 where name &amp;gt; 'alex'
    特别的：如果是主键或索引是整数类型，则还是会走索引
        select * from tb1 where nid &amp;gt; 123
        select * from tb1 where num &amp;gt; 123
- order by
    select email from tb1 order by name desc;
    当根据索引排序时候，选择的映射如果不是索引，则不走索引
    特别的：如果对主键排序，则还是走索引：
        select * from tb1 order by nid desc;
 
- 组合索引最左前缀
    如果组合索引为：(name,email)
    name and email       -- 使用索引
    name                 -- 使用索引
    email                -- 不使用索引
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.6，使用索引注意事项&lt;/h4&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.76&quot;&gt;　　&lt;a href=&quot;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95&quot; target=&quot;_blank&quot;&gt;索引&lt;/a&gt;是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：&lt;/div&gt;
&lt;p&gt;　　在经常需要搜索的列上，可以加快搜索的速度；&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;6.5625&quot;&gt;　　在作为&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E9%94%AE&quot; target=&quot;_blank&quot;&gt;主键&lt;/a&gt;的列上，强制该列的唯一性和组织表中数据的排列结构；&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;9.7333333333333&quot;&gt;　　在经常用在连接的列上，这些列主要是一些&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%96%E9%94%AE&quot; target=&quot;_blank&quot;&gt;外键&lt;/a&gt;，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；&lt;/div&gt;
&lt;p&gt;　　在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.4315789473684&quot;&gt;　　在经常使用在WHERE子句中的列上面创建&lt;a href=&quot;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95&quot; target=&quot;_blank&quot;&gt;索引&lt;/a&gt;，加快条件的判断速度。&lt;/div&gt;
&lt;p&gt;　　同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点：&lt;/p&gt;
&lt;p&gt;　　第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;12.439655172414&quot;&gt;　　第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，&lt;a href=&quot;https://baike.baidu.com/item/%E7%BB%93%E6%9E%9C%E9%9B%86&quot; target=&quot;_blank&quot;&gt;结果集&lt;/a&gt;的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加&lt;a href=&quot;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95&quot; target=&quot;_blank&quot;&gt;索引&lt;/a&gt;，并不能明显加快检索速度。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;11.0625&quot;&gt;　　第三，对于那些定义为text, image和&lt;a href=&quot;https://baike.baidu.com/item/bit%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&quot; target=&quot;_blank&quot;&gt;bit数据类型&lt;/a&gt;的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。&lt;/div&gt;
&lt;p&gt;　　第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。&lt;/p&gt;
&lt;h3&gt; 三，索引后记&lt;/h3&gt;
&lt;h4 id=&quot;把数据库索引类比成什么比较好呢&quot;&gt;3.1把数据库索引类比成什么比较好呢?&lt;/h4&gt;
&lt;p&gt;　　一个非常好的类比是把数据库索引看作是书的索引。如果你有一本关于狗的书，你想要找关于‘黄金猎犬’的那部分。当你可以通过在书背的索引找到哪几页有关于‘黄金猎犬’信息的时候，你为什么要翻完正本书 - 这相当于数据库中的全表扫描。同样的，就像一本书的索引包含页码一样，数据库的索引包含了指针，指向你在SQL中想要查询的值所在的行。&lt;/p&gt;
&lt;h4 id=&quot;使用数据库索引会有什么代价&quot;&gt;3.2使用数据库索引会有什么代价？&lt;/h4&gt;
&lt;p&gt;　　那么，使用数据库索引有什么缺点呢？其一，索引会占用空间 - 你的表越大，索引占用的空间越大。其二，性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住：建立在某列（或多列）索引需要保存该列最新的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3、limit分页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是否有索引，limit分页是一个值得关注的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
每页显示10条：
当前 118 120， 125

倒序：
            大      小
   970  7 6  6 5  54  43  32
19 98     
下一页：

    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;lt; 当前页最小值 order by nid desc limit 每页数据 *【页码-当前页】) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;



    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;lt; 970  order by nid desc limit 40) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;


上一页：

    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;gt; 当前页最大值 order by nid asc limit 每页数据 *【当前页-页码】) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;


    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;gt; 980 order by nid asc limit 20) A order by A.nid desc limit 1)  
    order by 
        nid desc 
    limit 10;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.4、执行计划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
mysql&amp;gt; explain select * from tb2;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | tb2   | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
1 row in set (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
id
        查询顺序标识
            如：mysql&amp;gt; explain select * from (select nid,name from tb1 where nid &amp;lt; 10) as B;
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
            | id | select_type | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
            |  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | ALL   | NULL          | NULL    | NULL    | NULL |    9 | NULL        |
            |  2 | DERIVED     | tb1        | range | PRIMARY       | PRIMARY | 8       | NULL |    9 | Using where |
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
        特别的：如果使用union连接气值可能为null


    select_type
        查询类型
            SIMPLE          简单查询
            PRIMARY         最外层查询
            SUBQUERY        映射为子查询
            DERIVED         子查询
            UNION           联合
            UNION RESULT    使用联合的结果
            ...
    table
        正在访问的表名


    type
        查询时的访问方式，性能：all &amp;lt; index &amp;lt; range &amp;lt; index_merge &amp;lt; ref_or_null &amp;lt; ref &amp;lt; eq_ref &amp;lt; system/const
            ALL             全表扫描，对于数据表从头到尾找一遍
                            select * from tb1;
                            特别的：如果有limit限制，则找到之后就不在继续向下扫描
                                   select * from tb1 where email = 'seven@live.com'
                                   select * from tb1 where email = 'seven@live.com' limit 1;
                                   虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。

            INDEX           全索引扫描，对索引从头到尾找一遍
                            select nid from tb1;

            RANGE          对索引列进行范围查找
                            select *  from tb1 where name &amp;lt; 'alex';
                            PS:
                                between and
                                in
                                &amp;gt;   &amp;gt;=  &amp;lt;   &amp;lt;=  操作
                                注意：!= 和 &amp;gt; 符号


            INDEX_MERGE     合并索引，使用多个单列索引搜索
                            select *  from tb1 where name = 'alex' or nid in (11,22,33);

            REF             根据索引查找一个或多个值
                            select *  from tb1 where name = 'seven';

            EQ_REF          连接时使用primary key 或 unique类型
                            select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid;



            CONST           常量
                            表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。
                            select nid from tb1 where nid = 2 ;

            SYSTEM          系统
                            表仅有一行(=系统表)。这是const联接类型的一个特例。
                            select * from (select nid from tb1 where nid = 1) as A;
    possible_keys
        可能使用的索引

    key
        真实使用的

    key_len
        MySQL中使用索引字节长度

    rows
        mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值

    extra
        该列包含MySQL解决查询的详细信息
        “Using index”
            此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。
        “Using where”
            这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。
        “Using temporary”
            这意味着mysql在对查询结果排序时会使用一个临时表。
        “Using filesort”
            这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。
        “Range checked for each record(index map: N)”
            这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。

详细
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180125212506600-1694538338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）、id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。&lt;/p&gt;

&lt;p&gt;2）、select_type列常见的有：&lt;/p&gt;
&lt;p&gt;A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个&lt;/p&gt;
&lt;p&gt;B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个&lt;/p&gt;
&lt;p&gt;C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union&lt;/p&gt;
&lt;p&gt;D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响&lt;/p&gt;
&lt;p&gt;E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null&lt;/p&gt;
&lt;p&gt;F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery&lt;/p&gt;
&lt;p&gt;G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响&lt;/p&gt;
&lt;p&gt;H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select&lt;/p&gt;

&lt;p&gt;3）、table&lt;/p&gt;
&lt;p&gt;显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的&amp;lt;derived N&amp;gt;就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&amp;lt;union M,N&amp;gt;，与&amp;lt;derived N&amp;gt;类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。&lt;/p&gt;

&lt;p&gt;4）、type&lt;/p&gt;
&lt;p&gt;依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引&lt;/p&gt;
&lt;p&gt;A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index&lt;/p&gt;
&lt;p&gt;B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描&lt;/p&gt;
&lt;p&gt;C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref&lt;/p&gt;
&lt;p&gt;D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。&lt;/p&gt;
&lt;p&gt;E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引&lt;/p&gt;
&lt;p&gt;F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。&lt;/p&gt;
&lt;p&gt;G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值&lt;/p&gt;
&lt;p&gt;H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。&lt;/p&gt;
&lt;p&gt;I：range：索引范围扫描，常见于使用&amp;gt;,&amp;lt;,is null,between ,in ,like等运算符的查询中。&lt;/p&gt;
&lt;p&gt;J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range&lt;/p&gt;
&lt;p&gt;K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。&lt;/p&gt;
&lt;p&gt;L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。&lt;/p&gt;

&lt;p&gt;5）、possible_keys&lt;/p&gt;
&lt;p&gt;查询可能使用到的索引都会在这里列出来&lt;/p&gt;

&lt;p&gt;6）、key&lt;/p&gt;
&lt;p&gt;查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。&lt;/p&gt;

&lt;p&gt;7）、key_len&lt;/p&gt;
&lt;p&gt;用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，&lt;span lang=&quot;EN-US&quot;&gt;key_len只计算&lt;span lang=&quot;EN-US&quot;&gt;where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到&lt;span lang=&quot;EN-US&quot;&gt;key_len中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;8）、ref&lt;/p&gt;
&lt;p&gt;如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func&lt;/p&gt;

&lt;p&gt;9）、rows&lt;/p&gt;
&lt;p&gt;这里是执行计划中估算的扫描行数，不是精确值&lt;/p&gt;

&lt;p&gt;10）、extra&lt;/p&gt;
&lt;p&gt;这个列可以显示的信息非常多，有几十种，常用的有&lt;/p&gt;
&lt;p&gt;A：distinct：在select部分使用了distinc关键字&lt;/p&gt;
&lt;p&gt;B：no tables used：不带from字句的查询或者From dual查询&lt;/p&gt;
&lt;p&gt;C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。&lt;/p&gt;
&lt;p&gt;D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中&lt;/p&gt;
&lt;p&gt;E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。&lt;/p&gt;
&lt;p&gt;F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。&lt;/p&gt;
&lt;p&gt;G：using sort_union，using_union，using intersect，using sort_intersection：&lt;/p&gt;
&lt;p&gt;using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集&lt;/p&gt;
&lt;p&gt;using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集&lt;/p&gt;
&lt;p&gt;using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。&lt;/p&gt;
&lt;p&gt;H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。&lt;/p&gt;
&lt;p&gt;I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition&lt;/p&gt;
&lt;p&gt;J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个&lt;/p&gt;
&lt;p&gt;K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个&lt;/p&gt;

&lt;p&gt;除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息&lt;/p&gt;

&lt;p&gt;11）、filtered&lt;/p&gt;
&lt;p&gt;使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.5、慢日志查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a、配置MySQL自动记录慢日志&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;slow_query_log = OFF                            是否开启慢日志记录&lt;br/&gt;long_query_time = 2                              时间限制，超过此时间，则记录&lt;br/&gt;slow_query_log_file = /usr/slow.log        日志文件&lt;br/&gt;log_queries_not_using_indexes = OFF     为使用索引的搜索是否记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;注：查看当前配置信息：&lt;/em&gt;&lt;br/&gt;&lt;em&gt;　　     show variables like '%query%'&lt;/em&gt;&lt;br/&gt;&lt;em&gt;     修改当前配置：&lt;/em&gt;&lt;br/&gt;&lt;em&gt;　　　　set global 变量名 = 值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b、查看MySQL慢日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysqldumpslow -s at -a  /usr/local/var/mysql/MacBook-Pro-3-slow.log&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&quot;&quot;&quot;
--verbose    版本
--debug      调试
--help       帮助
 
-v           版本
-d           调试模式
-s ORDER     排序方式
             what to sort by (al, at, ar, c, l, r, t), 'at' is default
              al: average lock time
              ar: average rows sent
              at: average query time
               c: count
               l: lock time
               r: rows sent
               t: query time
-r           反转顺序，默认文件倒序拍。reverse the sort order (largest last instead of first)
-t NUM       显示前N条just show the top n queries
-a           不要将SQL中数字转换成N，字符串转换成S。don't abstract all numbers to N and strings to 'S'
-n NUM       abstract numbers with at least n digits within names
-g PATTERN   正则匹配；grep: only consider stmts that include this string
-h HOSTNAME  mysql机器名或者IP；hostname of db server for *-slow.log filename (can be wildcard),
             default is '*', i.e. match all
-i NAME      name of server instance (if using mysql.server startup script)
-l           总时间中不减去锁定时间；don't subtract lock time from total time
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 此篇博客主要参考：http://www.cnblogs.com/wupeiqi/articles/5716963.html；http://www.cnblogs.com/xiaoboluo768/p/5400990.html，写在这里主要是为了巩固学习知识，同时希望更多的同学学习。&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 14:39:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8353262.html</dc:identifier>
</item>
</channel>
</rss>