<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Asp.NetCoreWebApi图片上传接口(二)集成IdentityServer4授权访问(附源码) - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9315644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9315644.html</guid>
<description>&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;
&lt;blockquote readability=&quot;7.6035242290749&quot;&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;http://www.cnblogs.com/yilezhu/p/9315644.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/yilezhu/p/9315644.html&lt;/a&gt;&lt;br/&gt;作者：yilezhu&lt;br/&gt;上一篇关于Asp.Net Core Web Api图片上传的文章使用的是mongoDB进行图片的存储，文章发布后，张队就来了一句，说没有使用GridFS。的确博主只是进行了简单的图片上传以及mongoDB存储操作，目的是提供思路。具体的图片存储，有条件的还是基于阿里云OSS或者七牛吧，如果实在想用MongDB进行存储的话，建议采用GridFS的方式！&lt;br/&gt;又有人说，GridFS大于16M的时候才适合使用，图片上传已经控制小于1M了，就没必要使用GridFS了吧。这里可以指定chunksize的大小。这样性能上就没有什么问题了。而且在性能差不多的时候使用GridFS可以更方便的管理。因此建议如果采用MongDB进行文件存储的话，建议采用GridFS的方式。 这里特别感谢张队的耐心指导！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么使用identityserver4&quot;&gt;为什么使用IdentityServer4？&lt;/h3&gt;
&lt;p&gt;上一篇文章中，给大家讲解了如何通过 Asp.Net Core Web Api实现图片上传的接口，具体的可以[点这里查看][&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9297009.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9297009.html&lt;/a&gt;] 。这个接口是一个公开的接口，如何发布的话，任何知道调用方法的&quot;任何人&quot;都能任意的调用这个接口，俗称“裸奔”。这时候我们就应该给接口加入认证以及访问控制机制，来加强安全性！那么我们怎么来实现接口的认证以及访问控制呢？这时候部分人就会很懵逼了，还有一部分人就会联想到 OpenID Connect 和 OAuth 2.0了！可是怎么实现呢？从到到位搭一个这样的框架，会累死我滴，可能还要经过很长时间的测试呢！别担心，这时候就体现出Asp.Net Core社区的强大了，我们的主角IdentityServer4闪亮登场！&lt;/p&gt;
&lt;h3 id=&quot;identityserver4是什么能帮我们做什么呢&quot;&gt;IdentityServer4是什么？能帮我们做什么呢？&lt;/h3&gt;
&lt;p&gt;IdentityServer4是一套为 ASP.NET Core 2.0开发的基于OpenID Connect 和 OAuth 2.0 的框架，他能让我们的系统很轻松的就能很多认证以及授权相关的功能，比如：单点登录，api访问控制等等！其他的我就不介绍了，社区里面介绍的太多太多了！如果有想了解的OAuth 2.0的可以看看阮一峰的这篇文章[理解OAuth 2.0][&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&lt;/a&gt;] 。最后 IdentityServer4最最最大好处是开源的，用的人也多，而且比较成熟。想想是不是有点小激动，迫不及待的想试试了。在开始之前，附上[开原地址][&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; class=&quot;uri&quot;&gt;https://github.com/IdentityServer/IdentityServer4&lt;/a&gt;] 以及[详细文档][&lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/&quot; class=&quot;uri&quot;&gt;https://identityserver4.readthedocs.io/en/release/&lt;/a&gt;] 。想了解更多自行阅读官方文档吧！&lt;/p&gt;
&lt;blockquote readability=&quot;6.9076923076923&quot;&gt;
&lt;p&gt;为了演示的方便，本文采用的是客户端认证模式，至于其他的几种验证模式，大家可以看下上面给出的阮一峰的文章。还有大家用之前要理解下身份认证服务器（IdentityServer），用户（User），客户端（Client），资源（Resources），身份令牌（Identity Token），访问令牌（Access Token）这些概念。如果不清楚的话可以参考晓晨Master的这篇“&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/7487734.html&quot;&gt;ASP.NET Core的身份认证框架IdentityServer4（3）-术语的解释&lt;/a&gt;”文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;asp.net-core-web-api中如何使用identityserver4呢&quot;&gt;Asp.Net Core Web Api中如何使用IdentityServer4呢？&lt;/h3&gt;
&lt;h4 id=&quot;创建identityserver4服务端即身份认证服务器identityserver&quot;&gt;创建IdentityServer4服务端即“身份认证服务器（IdentityServer）”&lt;/h4&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;新建一个空的Asp.Net Core Web Api项目,名称为IdentityServer端口为5001，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234134038-1566250592.png&quot; alt=&quot;IdentityServer&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过Nuget安装IdentityServer4命令如下，记得程序包管理控制套，上面的项目选择刚刚创建的IdentityServer项目&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package IdentityServer4　&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234133657-1094598098.png&quot; alt=&quot;安装IdentityServer4&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这里因为采用OAuth 2.0的客户端模式，所以简单地使用一个类来硬编码一些资源（Resources）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以及客户端（Client），代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
    /// yilezhu
    /// 2018.7.15
    /// 因为此处采用in-memory，所以硬编码一些api，以及client
    /// &amp;lt;/summary&amp;gt;
    public class ApiConfig
    {
        /// &amp;lt;summary&amp;gt;
        /// 定义ApiResource   这里的资源（Resources）指的就是我们的API
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;ApiResource枚举&amp;lt;/returns&amp;gt;
        public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
        {
            return new[]
            {
                new ApiResource(&quot;PictureApi&quot;, &quot;图片上传的APi&quot;)
            };
        }

        /// &amp;lt;summary&amp;gt;
        /// 定义受信任的客户端 Client
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IEnumerable&amp;lt;Client&amp;gt; GetClients()
        {
            return new[]
            {
                new Client
                {
                    ClientId = &quot;MobileUploadPicture&quot;,//客户端的标识，要是惟一的
                    ClientSecrets = new [] { new Secret(&quot;yilezhu123&quot;.Sha256()) },//客户端密码，进行了加密
                    AllowedGrantTypes = GrantTypes.ClientCredentials,//授权方式，这里采用的是客户端认证模式，只要ClientId，以及ClientSecrets正确即可访问对应的AllowedScopes里面的api资源
                    AllowedScopes = new [] { &quot;PictureApi&quot; }//定义这个客户端可以访问的APi资源数组，上面只有一个api
                }
            };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在Startup.cs中注入IdentityServer服务并使用中间件，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            //注入IdentityServer服务
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()
                .AddInMemoryClients(ApiConfig.GetClients())
                .AddInMemoryApiResources(ApiConfig.GetApiResources());
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            //添加认证中间件
            app.UseIdentityServer();
            app.UseMvc();
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;用Postman测试并获取AccessToken吧！如下图所示,在Post请求中传入，认证类型，client_id以及client_secret即可获取AccessToken：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234133159-966811163.png&quot; alt=&quot;成功获取Access_Token&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当传入错误的Client_id或者密码将出现下面的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234132446-292729815.png&quot; alt=&quot;错误的密码，获取不到&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;至此IdentityServer服务已经简单地完成了！下面改造下我们的图片上传服务。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;改造图片上传接口加入授权认证&quot;&gt;改造图片上传接口，加入授权认证&lt;/h4&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在图片上传api项目中添加IdentityServer nuget包，这里只需要加入AccessTokenValidation包即可，注意选择api项目：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package IdentityServer4.AccessTokenValidation&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234131851-1575824505.png&quot; alt=&quot;安装AccessTokenValidation&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;appsettings.json中加入IdentityServerOptions，进行IdentityServer的一些配置&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&quot;IdentityServerOptions&quot;: {

    &quot;ServerIP&quot;: &quot;localhost&quot;,
    &quot;ServerPort&quot;: 5001,
    &quot;IdentityScheme&quot;: &quot;Bearer&quot;,
    &quot;ResourceName&quot;: &quot;PictureApi&quot;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;新建一个类用来匹配这个options，这样可以爽爽的使用：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
    /// yilezhu
    /// 2018.7.15
    /// IdentityServer的配置选项
    /// &amp;lt;/summary&amp;gt;
    public class IdentityServerOptions
    {
        /// &amp;lt;summary&amp;gt;
        /// 授权服务器的Ip地址
        /// &amp;lt;/summary&amp;gt;
        public string ServerIP { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 授权服务器的端口号
        /// &amp;lt;/summary&amp;gt;
        public int ServerPort { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// access_token的类型，获取access_token的时候返回参数中的token_type一致
        /// &amp;lt;/summary&amp;gt;
        public string IdentityScheme { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 资源名称，认证服务注册的资源列表名称一致，
        /// &amp;lt;/summary&amp;gt;
        public string ResourceName { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Startup.cs中加入identityServer验证&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            //注入Options
            OptionsConfigure(services);
            var identityServerOptions = new IdentityServerOptions();
            Configuration.Bind(&quot;IdentityServerOptions&quot;, identityServerOptions);
            services.AddAuthentication(identityServerOptions.IdentityScheme)
                .AddIdentityServerAuthentication(options =&amp;gt;
                    {
                        options.RequireHttpsMetadata = false; //是否启用https
                        options.Authority = $&quot;http://{identityServerOptions.ServerIP}:{identityServerOptions.ServerPort}&quot;;//配置授权认证的地址
                        options.ApiName = identityServerOptions.ResourceName; //资源名称，跟认证服务中注册的资源列表名称中的apiResource一致
                    }
                );

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseAuthentication();

            app.UseMvc();
        }

        /// &amp;lt;summary&amp;gt;
        /// yilezhu
        /// 2018.7.10
        /// 注册Options
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;services&quot;&amp;gt;服务容器&amp;lt;/param&amp;gt;
        private void OptionsConfigure(IServiceCollection services)
        {
            //MongodbHost信息
            services.Configure&amp;lt;MongodbHostOptions&amp;gt;(Configuration.GetSection(&quot;MongodbHost&quot;));
            //图片选项
            services.Configure&amp;lt;PictureOptions&amp;gt;(Configuration.GetSection(&quot;PictureOptions&quot;));

        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;为需要说全访问的图片上传接口添加[Authorize]特性，当然要引用下命名空间：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Authorization;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
        /// 接口上传图片方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;fileDtos&quot;&amp;gt;文件传输对象,传过来的json数据&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;上传结果&amp;lt;/returns&amp;gt;
        [HttpPost]
        [Authorize]
        public async Task&amp;lt;UploadResult&amp;gt; Post([FromBody] FileDtos fileDtos)
        {
            …………
        }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;把授权服务以及图片上传接口同时启动下，然后Postman再次进行下图片上传的测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234131241-2022170720.png&quot; alt=&quot;多项目启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234130755-1975742015.png&quot; alt=&quot;返回结果，未授权&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在请求头上加入我们获取的token信息，来再次访问下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234129812-1838552154.png&quot; alt=&quot;加入验证头&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180715234129114-1956868286.png&quot; alt=&quot;访问成功&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Asp.Net Core Web Api图片上传接口集成Identity Server 4安全认证实例教程到此结束了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;示例代码&quot;&gt;示例代码&lt;/h3&gt;
&lt;p&gt;[点我下载][&lt;a href=&quot;https://github.com/yilezhu/ImageUploadApiDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/ImageUploadApiDemo&lt;/a&gt;]&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文通过图片上传这个Asp.Net Core Web Api做引子，然后引入Identity Server 4。然后通过一个简单地实例教程阐述了如何创建Identity Server 以及接口中如何进行授权认证访问。博主尽量采用通俗易懂的语言进行阐述，步骤也尽量详细，目的就是为了让初学者也能按照步骤一步一步的实现Identity Server 4的认证。下一篇我会加入SwaggerUI生成接口文档，当然大家也可以看下我的这篇关于SwaggerUI的文章[ASP.NET Core WebApi使用Swagger生成api说明文档看这篇就够了][&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9241261.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9241261.html&lt;/a&gt;] 。这个系列的教程源码，我已经放在github上了，大家可以点这里进行访问源代码。&lt;a href=&quot;https://github.com/yilezhu/ImageUploadApiDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/ImageUploadApiDemo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Jul 2018 23:22:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9315644.html</dc:identifier>
</item>
<item>
<title>1-STM32嵌入LUA开发(控制小灯闪耀) - 杨奉武</title>
<link>http://www.cnblogs.com/yangfengwu/p/9315841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangfengwu/p/9315841.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天因为想让STM32完美的处理字符串,所以就想着让STM32嵌入lua,本来想用f103c8t6,但是一编译就提示内存不足......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以单片机的型号选择的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716055447386-1364855807.png&quot; alt=&quot;&quot;/&gt;\&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我下载到了RBT6的芯片上测试的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先说一下最终实现的效果吧,就是用lua语言控制单片机的PC13  每间隔500Ms反转一次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现功能的部分&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_led_on(lua_State *&lt;span&gt;L)
{
  PCout(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_led_off(lua_State *&lt;span&gt;L)
{
  PCout(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
 
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_delay(lua_State *&lt;span&gt;L)
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
  num&lt;/span&gt;= lua_tointeger(L, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  delay_ms(num);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; luaL_Reg mylib[]=&lt;span&gt;
{
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;led_on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,lua_led_on},
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;led_off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,lua_led_off},
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,lua_delay},
  {NULL,NULL}
};


&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; LUA_SCRIPT_GLOBAL[] =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  \&lt;/span&gt;
off = &lt;span&gt;500&lt;/span&gt;&lt;span&gt;     \
on &lt;/span&gt;= &lt;span&gt;500&lt;/span&gt;&lt;span&gt;       \
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; \
 led_on() \
 delay(off)    \
 led_off()        \
 delay(on)      \
end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        lua_State &lt;/span&gt;*&lt;span&gt;L;
        L &lt;/span&gt;= luaL_newstate(); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 建立Lua运行环境 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      luaopen_base(L);
        luaL_setfuncs(L, mylib, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    luaL_dostring(L, LUA_SCRIPT_GLOBAL); &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 运行Lua脚本 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    
        
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实虽然可以了,但是也没什么感觉....因为可能需要裁剪很多功能才能运行在c8t6上,所以,唉,不开心......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在说一下移植(赋值粘贴加修改)的步骤&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考文章&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tinyfar/article/details/73727484&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://blog.csdn.net/tinyfar/article/details/73727484&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是下载Lua的源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.lua.org/ftp/lua-5.3.5.tar.gz&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.lua.org/ftp/lua-5.3.5.tar.gz&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716060423845-495682325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载之后&lt;/p&gt;

&lt;p&gt; 把这个文件夹拷贝出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716060651371-1938119915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;放在自己的工程目录下,位置随意,只要自己知道就行,因为需要手动设置告诉软件一些.h的位置,这个大家应该知道&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716060808621-1106858091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061243054-103026798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061422254-1477488744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061518030-365089738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 设置头文件位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061549575-1426245581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061625070-351992700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061705084-8459866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716061854908-1219585605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在可以编译&lt;/p&gt;
&lt;p&gt;可能会报这种错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716062126347-1530259669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716062408350-1230772030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716062510567-1458909265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 按理说这样其实可以测试了,,我的源码还修改了个地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716063345970-861094836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实就是重定向一些函数&lt;/p&gt;
&lt;p&gt;现在看主函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;include.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lua.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lauxlib.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lualib.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;



&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __stdin_name[&lt;span&gt;150&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __stdout_name[&lt;span&gt;150&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __stderr_name[&lt;span&gt;150&lt;/span&gt;&lt;span&gt;];

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; FILEHANDLE;
FILEHANDLE _sys_open(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; openmode)
{
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; _sys_close(FILEHANDLE fh)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _sys_write(FILEHANDLE fh, &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *buf, unsigned len, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mode)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _sys_read(FILEHANDLE fh, unsigned &lt;span&gt;char&lt;/span&gt;*buf, unsigned len, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mode)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查句柄是否为终端&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; _sys_istty(FILEHANDLE fh)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _sys_seek(FILEHANDLE fh, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; pos)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新句柄关联的缓冲区&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; _sys_ensure(FILEHANDLE fh)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回文件当前长度&lt;/span&gt;
&lt;span&gt;long&lt;/span&gt;&lt;span&gt; _sys_flen(FILEHANDLE fh)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; _sys_exit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while(1);&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _sys_tmpnam(&lt;span&gt;char&lt;/span&gt; *name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fileno, unsigned maxlength)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个字符写入控制台&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; _ttywrch(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ch)
{
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; remove(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *_sys_command_string(&lt;span&gt;char&lt;/span&gt; *cmd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len)
{
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_led_on(lua_State *&lt;span&gt;L)
{
  PCout(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_led_off(lua_State *&lt;span&gt;L)
{
  PCout(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
 
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lua_delay(lua_State *&lt;span&gt;L)
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
  num&lt;/span&gt;= lua_tointeger(L, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  delay_ms(num);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; luaL_Reg mylib[]=&lt;span&gt;
{
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;led_on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,lua_led_on},
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;led_off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,lua_led_off},
  {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,lua_delay},
  {NULL,NULL}
};


&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; LUA_SCRIPT_GLOBAL[] =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  \&lt;/span&gt;
off = &lt;span&gt;500&lt;/span&gt;&lt;span&gt;     \
on &lt;/span&gt;= &lt;span&gt;500&lt;/span&gt;&lt;span&gt;       \
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt; \
 led_on() \
 delay(off)    \
 led_off()        \
 delay(on)      \
end&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;


&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    NVIC_Configuration();
    GpioInit();
    
    Timer2_Config();
    Uart123Init(&lt;/span&gt;&lt;span&gt;115200&lt;/span&gt;,&lt;span&gt;115200&lt;/span&gt;,&lt;span&gt;115200&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口初始化&lt;/span&gt;
    rbCreate(&amp;amp;Uart1rb,Usart1SendBuff,Usart1SendLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建环形队列--串口1&lt;/span&gt;
    rbCreate(&amp;amp;Uart2rb,Usart2SendBuff,Usart2SendLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建环形队列--串口2&lt;/span&gt;
    rbCreate(&amp;amp;Uart3rb,Usart3SendBuff,Usart3SendLen);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建环形队列--串口3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     FlashReadSaveDataInit();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
    
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ADC_Config();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置ADC采集(不使用DMA)&lt;/span&gt;
&lt;span&gt;    
    DMA_ADC_Config();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用DMA采集ADC&lt;/span&gt;
&lt;span&gt;    DMA_Config();
    
    AdcGpioConfig();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置ADC采集引脚
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     IWDG_Init(IWDG_Prescaler_256,156*5); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时钟40K,分频数为256,156.25HZ,6.4ms;喂狗最小间隔5S&lt;/span&gt;
    
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        lua_State &lt;/span&gt;*&lt;span&gt;L;
        L &lt;/span&gt;= luaL_newstate(); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 建立Lua运行环境 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      luaopen_base(L);
        luaL_setfuncs(L, mylib, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    luaL_dostring(L, LUA_SCRIPT_GLOBAL); &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 运行Lua脚本 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    
        
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        
        
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         IWDG_Feed();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;喂狗
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Testing();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试函数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;         
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         if(Usart1ReadFlage)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;             Usart1ReadFlage = 0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;             PutData(&amp;amp;Uart1rb,USART1,Usart1ReadBuff,Usart1ReadCntCopy);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     }&lt;/span&gt;
&lt;span&gt;        
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
* @brief  测试函数
* @param  
* @param  None
* @param  None
* @retval None
* @example 
*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Testing(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就执行了lua语言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819239/201807/819239-20180716063711546-1597395863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实质是Lua调用C&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源码下载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：https://pan.baidu.com/s/13N0sPkM1f8Egoap0oZCR1g 密码：slxt&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Jul 2018 22:44:00 +0000</pubDate>
<dc:creator>杨奉武</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangfengwu/p/9315841.html</dc:identifier>
</item>
<item>
<title>如何实现蓝牙空中升级BLE OTA - iini</title>
<link>http://www.cnblogs.com/iini/p/9314246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iini/p/9314246.html</guid>
<description>&lt;p&gt;如何实现BLE OTA？什么叫DFU？如何通过UART实现固件升级？又如何通过USB实现固件升级？怎么保证升级的安全性？什么叫双备份（dual bank）DFU？什么叫单备份（single bank）DFU？什么叫后台式（background）DFU？本文将对上述问题进行探讨。&lt;/p&gt;
&lt;h2&gt;1.概述&lt;/h2&gt;
&lt;p&gt;所谓DFU（Device Firmware Update），就是设备固件升级的意思，而OTA是DFU的一种类型，准确说，OTA的全称应该是OTA DFU，只不过大家为了方便起见，直接用OTA来指代固件空中升级（有时候大家也将OTA称为FOTA）。DFU除了可以通过无线方式（OTA）进行升级，也可以通过有线方式进行升级，比如通过UART，USB或者SPI通信接口来升级设备固件。&lt;/p&gt;
&lt;p&gt;不管采用OTA方式还是有线通信方式，DFU包括后台式（background）和非后台式两种模式，目前的智能手机升级Android或者iOS系统都是采用background DFU方式，即新固件在后台悄悄下载，下载成功后，再提示用户升级，整个升级过程中对用户手机使用没有任何影响。而早先的功能机就是采用非后台式 DFU来升级操作系统的，即用户需要先长按某些按键进入bootloader模式，然后再进行升级，在升级过程中，手机的正常功能无法使用。Background DFU必须采用双备份（dual bank）模式进行升级，即老系统（老固件）和新系统（新固件）各占一块存储区，只有当新系统下载完成并校验成功后才会去升级老系统。而非后台式DFU可以采用dual bank或者single bank模式，dual bank的做法是升级时系统先进入bootloader，然后把新系统（新固件）下载下来并校验成功，然后再擦除老系统（老固件）并升级新系统，dual bank方式虽然牺牲了很多存储空间，但是换来了更好的升级体验。Single bank的做法是升级时系统也是先进入bootloader，&lt;strong&gt;然后立马把老系统擦除&lt;/strong&gt;，然后直接把新系统下载到老系统区域，跟dual bank相比，single bank将大大节省Flash存储区域，在系统资源比较紧张的时候，推荐使用single bank方式。不管是single bank还是dual bank，升级过程出现问题后，都可以进行二次升级，都不会出现“变砖”情况。不过dual bank有一个好处，如果升级过程中出现问题或者新固件有问题，它还可以选择之前的老系统继续执行而不受其影响。而single bank碰到这种情况就只能一直待在bootloader中，然后等待二次或者多次升级，此时设备的正常功能就无法使用了，从用户使用这个角度来说，你也可以认为此时设备已经“变砖”了。可参考下面三个图来理解上述过程。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004534190-1008630263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你是第一次接触Nordic nRF5 SDK&lt;/strong&gt;&lt;strong&gt;，那么建议你先看一下这篇文章：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/iini/p/8996025.html&quot;&gt;&lt;strong&gt;开发你的第一个BLE&lt;/strong&gt;&lt;strong&gt;应用程序—Blinky&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;，或者看一下这一篇文章：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/iini/p/9095622.html&quot;&gt;&lt;strong&gt;手把手教你开发BLE&lt;/strong&gt;&lt;strong&gt;数据透传应用程序&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;，以建立Nordic nRF5 SDK&lt;/strong&gt;&lt;strong&gt;的一些基本知识，然后再往下看以下章节。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2. Nordic nRF5 SDK DFU例程&lt;/h2&gt;
&lt;p&gt;Nordic 原生态SDK就提供了OTA（BLE）DFU，UART DFU，以及USB DFU例程，大家可以直接参考Nordic例程来实现自己的DFU。由于Nordic SDK版本很多，而且每个版本之间都或多或少有些差异，下面将分SDK版本来阐述Nordic每个版本SDK中如何实现OTA，至于UART DFU和USB DFU，这里就不再阐述了。感兴趣的同学可以参考Nordic nRF5 SDK v15.0.0如下目录：&lt;/p&gt;
&lt;p&gt;UART serial DFU目录（nRF52832）：nRF5_SDK_15.0.0_a53641a\examples\dfu\secure_bootloader\pca10040_uart\arm5_no_packs&lt;/p&gt;
&lt;p&gt;USB serial DFU目录（nRF52840）：&lt;/p&gt;
&lt;p&gt;nRF5_SDK_15.0.0_a53641a\examples\dfu\secure_bootloader\pca10056_usb\arm5_no_packs&lt;/p&gt;
&lt;p&gt;这里说明一下，目前Nordic只提供非后台式DFU例子，SDK中还没有后台式DFU例子（不过这个实现起来并不难，只要大家搞明白了里面的原理，自己开发起来会很快的），所以下面的论述都是基于非后台式DFU。另外，SDK9/10/11，Nordic只有明文DFU。从SDK12开始，Nordic 开始支持安全DFU（secure DFU）。所谓secure DFU，不是指升级时固件是加密的，而是指升级之前bootloader会先验证新固件的签名，只有验签通过后，才允许后续升级，此时的升级方式仍然是明文；验签失败，则拒绝后续升级。Secure DFU将杜绝黑客的恶意攻击，大大提高系统的安全性。&lt;/p&gt;
&lt;p&gt;Nordic nRF5 SDK软件架构跟其他家有点不一样，程序存储区最开始部分放得不是bootloader，而是蓝牙协议栈softdevice，bootloader则被nRF5 SDK放在程序存储区的最上面，整个存储区结构图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004647154-1439102659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据升级时如何跳转到Bootloader，nRF5 SDK又将DFU分为按键式DFU和非按键式（Buttonless）DFU，所谓按键式DFU，就是上电时长按某个按键以进入bootloader模式。而buttonless DFU，就是整个DFU过程中设备端无任何人工干预，通过BLE指令方式让设备进入bootloader模式。&lt;/p&gt;
&lt;p&gt;按键式DFU比较简单，你只需将softdevice和bootloader image烧入到设备中（application可烧可不烧），按住button4然后上电，设备就会自动进入bootloader模式，然后就可以通过nRF Connect或者nRF Toolbox对设备进行OTA了。一旦buttonless DFU例子从app跳到了bootloader，后续DFU升级过程就跟按键式DFU一模一样，所以如果你对按键式DFU操作过程中有什么不明白的地方，可以参考后面的buttonless DFU的说明，这里就不单独对按键式DFU操作过程进行说明了。&lt;/p&gt;
&lt;p&gt;下面将对buttonless DFU实现过程按照SDK版本一一进行阐述，请选择你感兴趣的SDK版本进行阅读。下文的所有操作步骤所对应的脚本都放在百度云盘上，&lt;strong&gt;云盘链接如下所示&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;建议大家先把对应的脚本下下来，然后对着操作步骤去实现自己的DFU过程。&lt;/p&gt;
&lt;h3&gt;2.1 nRF5 SDK v15.0.0 OTA&lt;/h3&gt;
&lt;p&gt;SDK15既支持明文DFU又支持安全DFU（实际上是签名DFU），而且SDK15既可以实现OTA DFU，也可以实现基于UART或者USB通信的DFU。所谓签名DFU，就是bootloader中预先装载一个公钥，升级时，主机先发一个签名给bootloader，bootloader会对这个签名进行验签，验签通过才能继续DFU，否则拒绝DFU。SDK15 OTA DFU是基于例程ble_app_buttonless_dfu来实现的，而且SDK15只支持nRF52系列产品，它不支持nRF51系列产品，下面我们以nRF52832（开发板编号：PCA10040）为例，来阐述SDK15是如何实现OTA的。&lt;/p&gt;
&lt;h4&gt;nRF52832 OTA&lt;/h4&gt;
&lt;p&gt;请大家先到百度云盘下载压缩包：&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;DFU/SDK15_0/ Script_SDK15_S132_nRF52832.rar&lt;/strong&gt;&lt;strong&gt;”并解压&lt;/strong&gt;，然后对照以下步骤进行操作：&lt;/p&gt;
&lt;p&gt;1)     准备。请先执行如下的“build_all.bat”脚本（Windows系统），以生成相应的micro-ecc库（micro-ecc会用来对签名进行验签等安全功能）。请注意，欲成功执行build_all.bat，大家必须先安装好git和gcc编译器。如果你嫌麻烦，可以到百度云盘下载： micro-ecc_sdk14_15_newer.rar，然后覆盖相关文件，效果也是一样的。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004757881-1291153765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;然后请按照&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_installing.html&amp;amp;cp=5_5_1&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_installing.html&amp;amp;cp=5_5_1&lt;/a&gt;安装最新版nrfutil，nrfutil安装有两种方式，一种是直接下载exe文件，一种是以Python的方式进行安装。&lt;/p&gt;
&lt;p&gt;nrfutil.exe直接下载链接为：（注：如果大家不熟悉Python，推荐使用这种方式）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NordicSemiconductor/pc-nrfutil/releases&quot;&gt;https://github.com/NordicSemiconductor/pc-nrfutil/releases&lt;/a&gt;，&lt;strong&gt;记得把&lt;/strong&gt;&lt;strong&gt;nrfutil.exe&lt;/strong&gt;&lt;strong&gt;所在目录放在Windows&lt;/strong&gt;&lt;strong&gt;环境变量中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者你按照如下步骤去安装nrfutil：&lt;/p&gt;
&lt;p&gt;注：安装完Python2.7后，需要修改Windows path变量值，如果你安装了老版本nrfutil，请先把老版本所在的目录C:\Program Files (x86)\Nordic Semiconductor\nRFgo Studio从path变量中删除，然后添加这2个目录：C:\Python27;C:\Python27\Scripts;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过pip安装最新版的nrfutil，即打开Windows命令行工具CMD，输入如下命令：pip install nrfutil，即可以完成nrfutil的安装。&lt;/li&gt;
&lt;li&gt;安装完成后，在Windows命令行工具输入：nrfutil version，其版本应该在3.2.0以上。&lt;/li&gt;
&lt;li&gt;对于Windows用户，nrfutil运行需要几个特殊的DLL库，而这几个库有些Windows机器是没有的，如此，可往：&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=40784&quot;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=40784&lt;/a&gt;下载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2)     通过nrfutil生成公私钥对。大家可以直接双击“key_generate.bat”以生成相应的私钥（priv.pem）和公钥（dfu_public_key.c）。&lt;strong&gt;大家务必要保存好私钥&lt;/strong&gt;&lt;strong&gt;priv.pem&lt;/strong&gt;，以后每个新image要升级时，都会先通过这个私钥对它进行签名，一旦priv.pem丢失或者被暴露，DFU将无法进行或者变得不安全。&lt;/p&gt;
&lt;p&gt;3)     编译bootloader代码。将刚才的dfu_public_key.c取代目录nRF5_SDK_15.0.0_a53641a\examples\dfu下的同名文件，然后编译如下目录中的工程：&lt;/p&gt;
&lt;p&gt;nRF5_SDK_15.0.0_a53641a\examples\dfu\secure_bootloader\pca10040_ble\arm5_no_packs，将hex改为：bootloader.hex&lt;/p&gt;
&lt;p&gt;4)     编译application代码。请编译工程：nRF5_SDK_15.0.0_a53641a\examples\ble_peripheral\&lt;strong&gt;ble_app_buttonless_dfu&lt;/strong&gt;\pca10040\s132\arm5_no_packs，将hex修改为：app.hex&lt;/p&gt;
&lt;p&gt;5)     生成bootloader settings page。Bootloader settings存储在Flash最后一个page，它将决定复位后芯片的行为，比如是进入DFU模式还是应用模式，同时它还包含image的CRC值和版本等信息。如果要求芯片复位后进入application，必须正确生成该bootloader settings hex，生成脚本见“settings_page_generate.bat”&lt;/p&gt;
&lt;p&gt;6)     烧写softdevice，app和bootloader。请双击“mass_program.bat”来完成整个烧写过程&lt;/p&gt;
&lt;p&gt;7)     生成新image对应的zip包。请双击“zip_generate.bat”，以生成SDK15_app_s132.zip，升级时，该zip包将会由云端下发到手机app中。&lt;/p&gt;
&lt;p&gt;8)     将“SDK15_app_s132.zip”拷贝到手机上。安卓和苹果手机都可以通过微信的‘文件传输助手’拷过去，非常方便。请注意，手机nRF Connect和nRF Toolbox都支持DFU功能，苹果手机拷贝的时候可以随便选择其中一个app。&lt;/p&gt;
&lt;p&gt;9)     使用nRF Connect或者nRF Toolbox来完成DFU过程。这里以nRF Connect为例来阐述整个升级过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DK广播为Nordic_Buttonless，如下&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004824352-1118754845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接该设备，使能CCCD，并选择“DFU”&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004845785-2004139806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;选择升级用的zip包。有些安卓系统自带的文件浏览器会有问题，&lt;strong&gt;建议使用&lt;/strong&gt;&lt;strong&gt;ES explorer&lt;/strong&gt;&lt;strong&gt;来选择zip&lt;/strong&gt;&lt;strong&gt;包&lt;/strong&gt;，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004903802-639704394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004921823-1628571472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;开始升级&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716004955107-1555190974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;升级成功，设备将自动启动，此时你会看到新image已经在运行，广播名字也变成Nordic_new，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005010552-510864861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;后面我会以SDK15.0.0 ble_app_uart为例，详细阐述如何把ble_app_buttonless_dfu的DFU功能移植到ble_app_uart上，从而让ble_app_uart也具有DFU功能，有兴趣的的读者请参考第3章。&lt;/p&gt;
&lt;h4&gt;nRF52840 OTA&lt;/h4&gt;
&lt;p&gt;nRF52840 OTA过程与nRF52832非常相似，唯一不同的是选择pca10056目录，请下载百度云盘脚本“&lt;strong&gt;DFU/SDK15_0/ Script_SDK15_S140_nRF52840.rar&lt;/strong&gt;”，然后按照上述52832的步骤来实现52840的OTA DFU。&lt;/p&gt;

&lt;h3&gt;2.2 nRF5 SDK v14.2.0 OTA&lt;/h3&gt;
&lt;p&gt;SDK14目前只支持安全DFU（实际上是签名DFU），所谓签名DFU，就是bootloader中预先装载一个公钥，升级时，主机先发一个签名给bootloader，bootloader会对这个签名进行验签，验签通过后才能继续DFU，否则拒绝DFU。SDK14既可以实现OTA DFU，也可以实现基于UART或者USB通信的DFU。SDK14 OTA DFU是基于例程ble_app_buttonless_dfu来实现的，而且SDK14只支持nRF52系列产品，它不支持nRF51系列产品，下面我们以nRF52832（开发板编号：PCA10040）为例，来阐述SDK14是如何实现OTA的。&lt;/p&gt;
&lt;h4&gt;nRF52832 OTA&lt;/h4&gt;
&lt;p&gt;请大家先到百度云盘下载压缩包：&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;DFU/SDK14_2/ Script_SDK14_S132_nRF52832.rar&lt;/strong&gt;&lt;strong&gt;”并解压&lt;/strong&gt;，然后对照以下步骤进行操作：&lt;/p&gt;
&lt;p&gt;1)     准备。请先执行如下的“build_all.bat”脚本（Windows系统），以生成相应的micro-ecc库（micro-ecc会用来对签名进行验签等安全功能）。请注意，欲成功执行build_all.bat，大家必须先安装好git和gcc编译器。如果你嫌麻烦，可以到百度云盘下载： micro-ecc_sdk14_15_newer.rar，然后覆盖相关文件，效果也是一样的。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005045206-1924019398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后请按照&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_installing.html&amp;amp;cp=5_5_1&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_installing.html&amp;amp;cp=5_5_1&lt;/a&gt;安装最新版nrfutil，nrfutil安装有两种方式，一种是直接下载exe文件，一种是以Python的方式进行安装。&lt;/p&gt;
&lt;p&gt;nrfutil.exe直接下载链接为：（注：如果大家不熟悉Python，推荐使用这种方式）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NordicSemiconductor/pc-nrfutil/releases&quot;&gt;https://github.com/NordicSemiconductor/pc-nrfutil/releases&lt;/a&gt;，&lt;strong&gt;记得把&lt;/strong&gt;&lt;strong&gt;nrfutil.exe&lt;/strong&gt;&lt;strong&gt;所在目录放在Windows&lt;/strong&gt;&lt;strong&gt;环境变量中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者你按照如下步骤去安装nrfutil：&lt;/p&gt;
&lt;p&gt;注：安装完Python2.7后，需要修改Windows path变量值，如果你安装了老版本nrfutil，请先把老版本所在的目录C:\Program Files (x86)\Nordic Semiconductor\nRFgo Studio从path变量中删除，然后添加这2个目录：C:\Python27;C:\Python27\Scripts;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过pip安装最新版的nrfutil，即打开Windows命令行工具CMD，输入如下命令：pip install nrfutil，即可以完成nrfutil的安装。&lt;/li&gt;
&lt;li&gt;安装完成后，在Windows命令行工具输入：nrfutil version，其版本应该在3.2.0以上。&lt;/li&gt;
&lt;li&gt;对于Windows用户，nrfutil运行需要几个特殊的DLL库，而这几个库有些Windows机器是没有的，如此，可往：&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=40784&quot;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=40784&lt;/a&gt;下载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2)     通过nrfutil生成公私钥对。大家可以直接双击“key_generate.bat”以生成相应的私钥（priv.pem）和公钥（dfu_public_key.c）。&lt;strong&gt;大家务必要保存好私钥&lt;/strong&gt;&lt;strong&gt;priv.pem&lt;/strong&gt;，以后每个新image要升级时，都会先通过这个私钥对它进行签名，&lt;strong&gt;一旦&lt;/strong&gt;&lt;strong&gt;priv.pem&lt;/strong&gt;&lt;strong&gt;丢失或者被暴露&lt;/strong&gt;，&lt;strong&gt;DFU&lt;/strong&gt;&lt;strong&gt;将无法进行或者变得不安全&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3)     编译bootloader代码。将刚才的dfu_public_key.c取代目录nRF5_SDK_14.2.0_17b948a\examples\dfu\dfu_req_handling下的同名文件，然后编译如下目录中的工程：&lt;/p&gt;
&lt;p&gt;nRF5_SDK_14.2.0_17b948a\examples\dfu\bootloader_secure_ble\pca10040\arm5_no_packs，将hex改为：bootloader.hex&lt;/p&gt;
&lt;p&gt;4)     编译application代码。请编译工程：nRF5_SDK_14.2.0_17b948a\examples\ble_peripheral\ble_app_buttonless_dfu\pca10040\s132\arm5_no_packs，将hex修改为：app.hex&lt;/p&gt;
&lt;p&gt;5)     生成bootloader settings page。Bootloader settings存储在Flash最后一个page，它将决定复位后芯片的行为，比如是进入DFU模式还是应用模式，同时它还包含image的CRC值和版本等信息。如果要求芯片复位后进入application，必须正确生成该bootloader settings hex，生成脚本见“settings_page_generate.bat”&lt;/p&gt;
&lt;p&gt;6)     烧写softdevice，app和bootloader。请双击“mass_program.bat”来完成整个烧写过程&lt;/p&gt;
&lt;p&gt;7)     生成新image对应的zip包。请双击“zip_generate.bat”，以生成SDK14_app_s132.zip，升级时，该zip包将会由云端下发到手机app中。&lt;/p&gt;
&lt;p&gt;8)     将“SDK14_app_s132.zip”拷贝到手机上。安卓和苹果手机都可以通过微信的‘文件传输助手’拷过去，非常方便。请注意，手机nRF Connect和nRF Toolbox都支持DFU功能，苹果手机拷贝的时候可以随便选择其中一个app。&lt;/p&gt;
&lt;p&gt;9)     使用nRF Connect或者nRF Toolbox来完成DFU过程。这里以nRF Connect为例来阐述整个升级过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DK广播为Nordic_Buttonless，如下&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005115553-1459620074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接该设备，使能CCCD，并选择“DFU”&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005135448-836733861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;选择升级用的zip包。有些安卓系统自带的文件浏览器会有问题，&lt;strong&gt;建议使用&lt;/strong&gt;&lt;strong&gt;ES explorer&lt;/strong&gt;&lt;strong&gt;来选择zip&lt;/strong&gt;&lt;strong&gt;包&lt;/strong&gt;，如下： &lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005146787-1923871106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005208279-1272233184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;开始升级&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005235642-150921579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;升级成功，设备将自动启动，此时你会看到新image已经在运行，广播名字也变成Nordic_new，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005249933-2000181680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;后面我们会以SDK15.0.0 ble_app_uart为例，详细阐述如何把ble_app_buttonless_dfu的DFU功能移植到ble_app_uart上，从而让ble_app_uart也具有DFU功能，有兴趣的的读者请参考第3章。注意：SDK14.2.0 DFU原理跟SDK15.0.0一模一样，大家可以依葫芦画瓢，完成SDK14.2.0的DFU移植工作。&lt;/p&gt;

&lt;h3&gt;2.3 nRF5 SDK v12.3.0 OTA&lt;/h3&gt;
&lt;p&gt;SDK12目前只支持安全DFU（实际上是签名DFU），所谓签名DFU，就是bootloader中预先装载一个公钥，升级时，主机先发一个签名给bootloader，bootloader会对这个签名进行验签，验签通过后才能继续DFU，否则拒绝DFU。SDK12只有OTA DFU例子，而没有基于串口的DFU例程。SDK12 OTA DFU是基于例程ble_app_buttonless_dfu来实现的，而且SDK12同时支持nRF52832以及nRF51系列产品，下面我们以nRF52832（开发板编号：PCA10040）为例，来详细阐述SDK12是如何实现OTA的。&lt;/p&gt;
&lt;h4&gt;nRF52832 OTA&lt;/h4&gt;
&lt;p&gt;请大家先到百度云盘下载压缩包：&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;DFU/SDK12_3/ Script_SDK12_S132_nRF52832.rar&lt;/strong&gt;&lt;strong&gt;”并解压&lt;/strong&gt;，然后对照以下步骤进行操作：&lt;/p&gt;
&lt;p&gt;1)     准备。请先到百度云盘下载： micro-ecc_sdk12.rar，然后覆盖如下目录：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005305678-812797712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;然后请按照&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_installing.html&amp;amp;cp=5_5_1&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_installing.html&amp;amp;cp=5_5_1&lt;/a&gt;安装最新版nrfutil，nrfutil安装有两种方式，一种是直接下载exe文件，一种是以Python的方式进行安装。&lt;/p&gt;
&lt;p&gt;nrfutil.exe直接下载链接为：（注：如果大家不熟悉Python，推荐使用这种方式）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NordicSemiconductor/pc-nrfutil/releases&quot;&gt;https://github.com/NordicSemiconductor/pc-nrfutil/releases&lt;/a&gt;，&lt;strong&gt;记得把&lt;/strong&gt;&lt;strong&gt;nrfutil.exe&lt;/strong&gt;&lt;strong&gt;所在目录放在Windows&lt;/strong&gt;&lt;strong&gt;环境变量中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者你按照如下步骤去安装nrfutil：&lt;/p&gt;
&lt;p&gt;注：安装完Python2.7后，需要修改Windows path变量值，如果你安装了老版本nrfutil，请先把老版本所在的目录C:\Program Files (x86)\Nordic Semiconductor\nRFgo Studio从path变量中删除，然后添加这2个目录：C:\Python27;C:\Python27\Scripts;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过pip安装最新版的nrfutil，即打开Windows命令行工具CMD，输入如下命令：pip install nrfutil，即可以完成nrfutil的安装。&lt;/li&gt;
&lt;li&gt;安装完成后，在Windows命令行工具输入：nrfutil version，其版本应该在3.2.0以上。&lt;/li&gt;
&lt;li&gt;对于Windows用户，nrfutil运行需要几个特殊的DLL库，而这几个库有些Windows机器是没有的，如此，可往：&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=40784&quot;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=40784&lt;/a&gt;下载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2)     通过nrfutil生成公私钥对。大家可以直接双击“key_generate.bat”以生成相应的私钥（priv.pem）和公钥（dfu_public_key.c）。&lt;strong&gt;大家务必要保存好私钥&lt;/strong&gt;&lt;strong&gt;priv.pem&lt;/strong&gt;，以后每个新image要升级时，都会先通过这个私钥对它进行签名，&lt;strong&gt;一旦&lt;/strong&gt;&lt;strong&gt;priv.pem&lt;/strong&gt;&lt;strong&gt;丢失或者被暴露&lt;/strong&gt;，&lt;strong&gt;DFU&lt;/strong&gt;&lt;strong&gt;将无法进行或者变得不安全&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3)     编译bootloader代码。将刚才的dfu_public_key.c取代目录nRF5_SDK_12.3.0_d7731ad\examples\dfu\bootloader_secure下的同名文件，然后编译如下目录中的工程：&lt;/p&gt;
&lt;p&gt;nRF5_SDK_12.3.0_d7731ad\examples\dfu\bootloader_secure\pca10040\arm5_no_packs，将hex改为：bootloader.hex&lt;/p&gt;
&lt;p&gt;4)     编译application代码。请编译工程：nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\experimental_ble_app_buttonless_dfu\pca10040\s132\arm5_no_packs，将hex修改为：app.hex&lt;/p&gt;
&lt;p&gt;5)     生成bootloader settings page。Bootloader settings存储在Flash最后一个page，它将决定复位后芯片的行为，比如是进入DFU模式还是应用模式，同时它还包含image的CRC值和版本等信息。如果要求芯片复位后进入application，必须正确生成该bootloader settings hex，生成脚本见“settings_page_generate.bat”&lt;/p&gt;
&lt;p&gt;6)     烧写softdevice，app和bootloader。请双击“mass_program.bat”来完成整个烧写过程。请注意，在烧写前，请把app.hex倒数第3行和倒数第4行删除，因为bootloader.hex也包含一模一样的内容，会导致merge的时候hex定义冲突，如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005328104-428454615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者编译application的时候，把如下语句注掉：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005340070-232293091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;7)     生成新image对应的zip包。请双击“zip_generate.bat”，以生成SDK12_app_s132.zip，升级时，该zip包将会由云端下发到手机app中。&lt;/p&gt;
&lt;p&gt;8)     将“SDK12_app_s132.zip”拷贝到手机上。安卓和苹果手机都可以通过微信的‘文件传输助手’拷过去，非常方便。请注意，手机nRF Connect和nRF Toolbox都支持DFU功能，苹果手机拷贝的时候可以随便选择其中一个app。&lt;/p&gt;
&lt;p&gt;9)     使用nRF Connect或者nRF Toolbox来完成DFU过程。这里以nRF Connect为例来阐述整个升级过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DK广播为Nordic_Buttonless，如下&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005402514-733989710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接该设备，使能CCCD，并选择“DFU”&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005419488-672350036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;选择升级用的zip包。有些安卓系统自带的文件浏览器会有问题，&lt;strong&gt;建议使用&lt;/strong&gt;&lt;strong&gt;ES explorer&lt;/strong&gt;&lt;strong&gt;来选择zip&lt;/strong&gt;&lt;strong&gt;包&lt;/strong&gt;，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005436213-2077783446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005445431-481942760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开始升级&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005507261-733046404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;升级成功，设备将自动启动，此时你会看到新image已经在运行，广播名字也变成Nordic_new，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005521318-859624302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;nRF51系列 OTA&lt;/h4&gt;
&lt;p&gt;nRF51822 OTA过程与nRF52832非常相似，唯一不同的是选择pca10028目录，请下载百度云盘脚本“&lt;strong&gt;DFU/SDK12_3/ Script_SDK12_S130_nRF51.rar&lt;/strong&gt;”，然后按照上述52832的步骤来实现51822的OTA DFU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后面我们会以SDK15.0.0 ble_app_uart&lt;/strong&gt;&lt;strong&gt;为例，详细阐述如何把ble_app_buttonless_dfu&lt;/strong&gt;&lt;strong&gt;的DFU&lt;/strong&gt;&lt;strong&gt;功能移植到ble_app_uart&lt;/strong&gt;&lt;strong&gt;上，从而让ble_app_uart&lt;/strong&gt;&lt;strong&gt;也具有DFU&lt;/strong&gt;&lt;strong&gt;功能，有兴趣的的读者请参考第3&lt;/strong&gt;&lt;strong&gt;章。注意：SDK12.3.0 DFU&lt;/strong&gt;&lt;strong&gt;原理跟SDK15.0.0&lt;/strong&gt;&lt;strong&gt;非常相似，大家可以依葫芦画瓢，完成SDK12.3.0&lt;/strong&gt;&lt;strong&gt;的DFU&lt;/strong&gt;&lt;strong&gt;移植工作。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;2.4 nRF5 SDK v11.0.0 OTA&lt;/h3&gt;
&lt;p&gt;SDK11使用的是&lt;strong&gt;明文&lt;/strong&gt;&lt;strong&gt;OTA&lt;/strong&gt; DFU，其DFU是基于例程ble_app_hrs来实现的，并同时支持nRF52832和nRF51系列。下面以nRF52832为例来阐述DFU过程。&lt;/p&gt;
&lt;h4&gt;nRF52832 OTA&lt;/h4&gt;
&lt;p&gt;请大家先到百度云盘下载压缩包：&lt;strong&gt;“&lt;/strong&gt;&lt;strong&gt;DFU/SDK11_0/ Script_SDK11_S132_nRF52.rar&lt;/strong&gt;&lt;strong&gt;”并解压&lt;/strong&gt;，然后对照以下步骤进行操作：&lt;/p&gt;
&lt;p&gt;1)       编译bootloader代码，请编译目录“nRF5_SDK_11.0.0_89a8197\examples\dfu\bootloader\pca10040\&lt;strong&gt;dual_bank_ble_s132&lt;/strong&gt;\arm5_no_packs”中的工程，将hex改为bootloader.hex&lt;/p&gt;
&lt;p&gt;2)       编译app，请编译目录“nRF5_SDK_11.0.0_89a8197\examples\ble_peripheral\&lt;strong&gt;ble_app_hrs&lt;/strong&gt;\pca10040\&lt;strong&gt;s132_with_dfu&lt;/strong&gt;\arm5_no_packs”中的工程，将hex改为app.hex&lt;/p&gt;
&lt;p&gt;3)       将softdevice，bootloader和app三者同时下载到设备中，另外我们还需要在Flash中写一个app有效标志位，从而上电后程序直接跑到app执行，而不是停留在bootloader中不出来。我已经把相关烧写脚本：mass_program.bat放在百度云盘中，大家直接双击就可以完成本步操作。&lt;/p&gt;
&lt;p&gt;4)       将新image打包成一个zip包。除了包含新image，该zip包还包含一些配置信息。升级时，zip包会通过云端下发到手机端app，手机端app再把zip包传给蓝牙设备以进行固件升级。&lt;strong&gt;请使用老版本&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;&lt;strong&gt;（版本号0.3.0&lt;/strong&gt;&lt;strong&gt;）来生成该升级包&lt;/strong&gt;（注：老版本nrfutil在目录“C:\Program Files (x86)\Nordic Semiconductor\nRFgo Studio”中）。我已经把相关生成脚本zip_generate.bat放在百度云盘上，大家直接双击就可以完成本步操作，并生成SDK11_app_s132.zip。&lt;/p&gt;
&lt;p&gt;5)       把上述的‘SDK11_app_s132.zip’拷到手机中，安卓和苹果手机都可以通过微信的‘文件传输助手’拷过去，非常方便。注：手机nRF Connect和nRF Toolbox都支持DFU功能，苹果手机拷贝的时候可以随便选择其中一个app。&lt;/p&gt;
&lt;p&gt;6)       使用nRF Connect或者nRF Toolbox来完成DFU过程。这里以nRF Connect为例来阐述整个升级过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DK广播为Nordic_HRM&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005543701-1287553594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接该设备，并使能CCCD，然后选择“DFU”&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005559683-2007037440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择升级用的zip包。有些安卓系统自带的文件浏览器会有问题，&lt;strong&gt;建议使用&lt;/strong&gt;&lt;strong&gt;ES explorer&lt;/strong&gt;&lt;strong&gt;来选择zip&lt;/strong&gt;&lt;strong&gt;包&lt;/strong&gt;，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005609958-35149553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005621505-1191646815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;开始升级&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005631373-1064000797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;升级成功，设备将自动启动，此时你会看到新image已经在运行，广播名字也变成Nordic_HRM_new，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716005644418-228291014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;nRF51系列OTA&lt;/h4&gt;
&lt;p&gt;nRF51822 OTA DFU实现过程跟上述的nRF52832基本上一模一样，唯一不同的是选择pca10028目录，我已把相关脚本打包并放在百度云盘中，请直接下载“&lt;strong&gt;DFU/SDK11_0/ Script_SDK11_S130_nRF51.rar&lt;/strong&gt;”，来实现nRF51系列 OTA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你的应用是基于SDK11&lt;/strong&gt;&lt;strong&gt;开发的，并且需要集成DFU&lt;/strong&gt;&lt;strong&gt;功能，请参考上述例子ble_app_hrs&lt;/strong&gt;&lt;strong&gt;来移植DFU&lt;/strong&gt;&lt;strong&gt;功能，主要工作包括两部分：一把BLE_DFU_APP_SUPPORT&lt;/strong&gt;&lt;strong&gt;这个宏包括的所有代码拷到你的工程中，二如果你的设备支持bonding&lt;/strong&gt;&lt;strong&gt;的话，还需把Device manager&lt;/strong&gt;&lt;strong&gt;相关代码也拷到你的工程中，如此即可完成DFU&lt;/strong&gt;&lt;strong&gt;功能的移植。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3. 给ble_app_uart加上OTA功能&lt;/h2&gt;
&lt;p&gt;为了让ble_app_uart具有DFU功能，有2种做法，一是把NUS服务移植到ble_app_buttonless_dfu中，这种方法相对来说更简单，但不利于理解DFU的移植原理；二是把DFU服务移植到ble_app_uart中，我们现以第2种做法来详细阐述如何在SDK15.0.0中把DFU服务移植到ble_app_uart中。&lt;/p&gt;
&lt;h3&gt;3.1 正常连接OTA（无bonding）&lt;/h3&gt;
&lt;p&gt;1)     打开如下工程：nRF5_SDK_15.0.0_a53641a\examples\ble_peripheral\ble_app_uart\pca10040\s132\arm5_no_packs&lt;/p&gt;
&lt;p&gt;2)     添加DFU服务。代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifdef DFU_SUPPORT

    ble_dfu_buttonless_init_t dfus_init &lt;/span&gt;= {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize the async SVCI interface to bootloader.&lt;/span&gt;
&lt;span&gt;
    err_code &lt;/span&gt;=&lt;span&gt; ble_dfu_buttonless_async_svci_init();

    APP_ERROR_CHECK(err_code); 

    dfus_init.evt_handler &lt;/span&gt;=&lt;span&gt; ble_dfu_evt_handler; 

    err_code &lt;/span&gt;= ble_dfu_buttonless_init(&amp;amp;&lt;span&gt;dfus_init);

    APP_ERROR_CHECK(err_code);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;定义ble_dfu_evt_handler，大家只要按照要求来，就没问题，这里就不贴代码了。&lt;/p&gt;
&lt;p&gt;Nordic对每一个模块都有一个编译总开关，因此还需到sdk_config.h中使能DFU模块，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef BLE_DFU_ENABLED

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; BLE_DFU_ENABLED 1

&lt;span&gt;#endif&lt;/span&gt;
 

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;q&amp;gt; NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS  - Buttonless DFU supports bonds.&lt;/span&gt;
&lt;span&gt;
 
#ifndef NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS 0

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3)     修改softdevice配置。现在整个应用包括2个vs_uuid：NUS和DFU，相应地ATT table size也要变大，然后应用程序RAM起始地址也需要跟着变，如下（注：这里的attr_tab_size设置得稍稍偏大）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;o&amp;gt; NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE - Attribute Table size in bytes. The size must be a multiple of 4.&lt;/span&gt;
&lt;span&gt;
#ifndef NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; NRF_SDH_BLE_GATTS_ATTR_TAB_SIZE 1600

&lt;span&gt;#endif&lt;/span&gt;

 

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;o&amp;gt; NRF_SDH_BLE_VS_UUID_COUNT - The number of vendor-specific UUIDs.&lt;/span&gt;
&lt;span&gt;
#ifndef NRF_SDH_BLE_VS_UUID_COUNT

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; NRF_SDH_BLE_VS_UUID_COUNT 2

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改应用程序RAM起始地址，如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010009298-1983257318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;4)     添加上述函数涉及到的文件，宏定义及包含相关目录。首先添加如下DFU目录及相关文件：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010022343-1636862138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;在define中添加这些宏：DEBUG DFU_SUPPORT BL_SETTINGS_ACCESS_ONLY NRF_DFU_SVCI_ENABLED NRF_DFU_TRANSPORT_BLE=1，其中DEBUG宏只是为了调试方便而设置的，跟DFU本身无关。DFU_SUPPORT是我用来控制我添加的DFU代码的，删掉DFU_SUPPORT，将不编译所有DFU有关代码。其余的宏都是系统自带的，如果要支持DFU，也是必须要定义的。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010041972-1743414307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;然后包含如下目录：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010054259-1091851292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;5)     在main.c中添加如下头文件定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifdef DFU_SUPPORT

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ble_dfu.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6)     在跳转到bootloader之前，如果你想做一些专门的代码处理，比如完成pending的Flash操作，比如关闭某些模块，那么你可以注册一个app_shutdown_handler来做这些工作。（注：这一步不是必须的，是可选的！）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
NRF_PWR_MGMT_HANDLER_REGISTER(app_shutdown_handler, &lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7)     编译工程，将hex改为“app.hex”&lt;/p&gt;
&lt;p&gt;8)     按照2.1节“nRF5 SDK v15.0.0 OTA”步骤来执行OTA过程，你会发现ble_app_uart已经具备DFU功能了。我已把OTA过程所有步骤打成一个包：Script_SDK15_S132_NUS_NoBonding.rar，大家可以到百度云盘去下载。&lt;/p&gt;
&lt;h3&gt;3.2 bonding连接OTA&lt;/h3&gt;
&lt;p&gt;我们在3.1节基础上，再加上bonding功能，以让ble_app_uart同时支持DFU和bonding。&lt;/p&gt;
&lt;p&gt;1)     打开3.1节的工程&lt;/p&gt;
&lt;p&gt;2)     添加如下文件：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010144674-1198803050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;3)     在main函数中添加peer_manager_init，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; peer_manager_init()

{

    ble_gap_sec_params_t sec_param;

    ret_code_t           err_code;

 

    err_code &lt;/span&gt;=&lt;span&gt; pm_init();

    APP_ERROR_CHECK(err_code);

 

    memset(&lt;/span&gt;&amp;amp;sec_param, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ble_gap_sec_params_t));

 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Security parameters to be used for all security procedures.&lt;/span&gt;
&lt;span&gt;
    sec_param.bond           &lt;/span&gt;=&lt;span&gt; SEC_PARAM_BOND;

    sec_param.mitm           &lt;/span&gt;=&lt;span&gt; SEC_PARAM_MITM;

    sec_param.lesc           &lt;/span&gt;=&lt;span&gt; SEC_PARAM_LESC;

    sec_param.keypress       &lt;/span&gt;=&lt;span&gt; SEC_PARAM_KEYPRESS;

    sec_param.io_caps        &lt;/span&gt;=&lt;span&gt; SEC_PARAM_IO_CAPABILITIES;

    sec_param.oob            &lt;/span&gt;=&lt;span&gt; SEC_PARAM_OOB;

    sec_param.min_key_size   &lt;/span&gt;=&lt;span&gt; SEC_PARAM_MIN_KEY_SIZE;

    sec_param.max_key_size   &lt;/span&gt;=&lt;span&gt; SEC_PARAM_MAX_KEY_SIZE;

    sec_param.kdist_own.enc  &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    sec_param.kdist_own.id   &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    sec_param.kdist_peer.enc &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    sec_param.kdist_peer.id  &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

 

    err_code &lt;/span&gt;= pm_sec_params_set(&amp;amp;&lt;span&gt;sec_param);

    APP_ERROR_CHECK(err_code);

 

    err_code &lt;/span&gt;=&lt;span&gt; pm_register(pm_evt_handler);

    APP_ERROR_CHECK(err_code);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后将上面新出现的符号定义一一拷贝过来，这里不再赘述&lt;/p&gt;
&lt;p&gt;4)     修改advertising_start定义，增加删除bonding信息功能（如果你不需要这个功能，也可以不改）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; advertising_start(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; erase_bonds)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (erase_bonds == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    {
        delete_bonds();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Advertising is started by PM_EVT_PEERS_DELETE_SUCCEEDED event.&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        uint32_t err_code &lt;/span&gt;= ble_advertising_start(&amp;amp;&lt;span&gt;m_advertising, BLE_ADV_MODE_FAST);
        APP_ERROR_CHECK(err_code);

        NRF_LOG_DEBUG(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;advertising is started&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5)     修改allow_repairing = true，这一步也是可选的。allow_repairing = true的好处是，当手机端的bonding信息被用户误删掉了，设备会允许这台手机的第二次配对bonding请求。如果allow_repairing = false，在这种情况下，就会拒绝手机的第二次配对请求，以提高安全性。&lt;/p&gt;
&lt;p&gt;6)     在main.c文件开头，包含如下头文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;peer_manager.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7)     在ble_evt_handler中删除BLE_GAP_EVT_SEC_PARAMS_REQUEST分支，因为这个分支在peer_manager模块中已经进行处理了，这里再处理一次，会产生异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        case BLE_GAP_EVT_SEC_PARAMS_REQUEST:

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pairing not supported

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            err_code = sd_ble_gap_sec_params_reply(m_conn_handle, BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP, NULL, NULL);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            APP_ERROR_CHECK(err_code);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            break;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8)     将ble_nus.c文件从\components目录中拷出来，放在自己工程目录下，因为我们接下来需要对它进行修改，后续项目直接引用自己的ble_nus，而不要再引用components目录下的原始文件了。将TX characteristic的CCCD写属性从open改为加密，这样将自动触发手机端的bonding请求，修改代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&amp;amp;cccd_md.write_perm);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;9)     修改sdk_config.h文件，需要修改多个地方，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; PEER_MANAGER_ENABLED 1

&lt;span&gt;#define&lt;/span&gt; FDS_ENABLED 1

&lt;span&gt;#define&lt;/span&gt; NRF_SDH_BLE_SERVICE_CHANGED 1

&lt;span&gt;#define&lt;/span&gt; NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;请注意NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS&lt;/strong&gt;&lt;strong&gt;可以为0&lt;/strong&gt;&lt;strong&gt;，也可以为1&lt;/strong&gt;&lt;strong&gt;，两种情况下，DFU&lt;/strong&gt;&lt;strong&gt;成功后，bonding&lt;/strong&gt;&lt;strong&gt;信息都可以保持。两者的区别是，当NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS&lt;/strong&gt;&lt;strong&gt;为0&lt;/strong&gt;&lt;strong&gt;，进入DFU&lt;/strong&gt;&lt;strong&gt;模式后，bootloader&lt;/strong&gt;&lt;strong&gt;将用普通模式跟手机相连，这种方式兼容性好，可靠性高，但安全等级稍低；当NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS&lt;/strong&gt;&lt;strong&gt;为1&lt;/strong&gt;&lt;strong&gt;时，bootloader&lt;/strong&gt;&lt;strong&gt;将共享application&lt;/strong&gt;&lt;strong&gt;的bonding&lt;/strong&gt;&lt;strong&gt;信息，也就是说，哪怕进入bootloader&lt;/strong&gt;&lt;strong&gt;模式，设备还是跟手机处于bonding&lt;/strong&gt;&lt;strong&gt;状态，这种方式安全级别比较高，但容易产生兼容性问题，极端情况下，如果DFU&lt;/strong&gt;&lt;strong&gt;过程中用户把手机端的bonding&lt;/strong&gt;&lt;strong&gt;信息删除，系统将会变砖，而且无法恢复。推荐将NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS&lt;/strong&gt;&lt;strong&gt;设为0&lt;/strong&gt;&lt;strong&gt;，以获得最好的兼容性和可靠性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你在应用中把NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS设为1，那么还需要添加ble_dfu_bonded.c文件，如下：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010508155-372524125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而且，如果NRF_DFU_BLE_BUTTONLESS_SUPPORTS_BONDS设为1，那么bootloader代码也就不能采用默认配置，请修改bootloader工程中的sdk_config.h如下宏定义，然后重新编译生成新的bootloader hex。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; NRF_DFU_BLE_REQUIRES_BONDS 1

&lt;span&gt;#define&lt;/span&gt; NRF_SDH_BLE_SERVICE_CHANGED 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;10)  在C/C++ define里面定义“BONDING_SUPPORT”宏。&lt;/p&gt;
&lt;p&gt;11)  编译工程，将hex改为app.hex&lt;/p&gt;
&lt;p&gt;12)  按照2.1节“nRF5 SDK v15.0.0 OTA”步骤来执行OTA过程，不过如下几点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在nRF Connect中勾选“keep bond information”选项，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010532416-848946645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;当你使能CCCD的时候，手机将会自动与设备进行bonding，如下&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010604140-208224244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;DFU升级成功后，设备将会与手机自动重连，此时需点击“Refresh services”，以获得设备最新服务列表，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201807/1366713-20180716010619442-1362555296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;上述代码工程我已打包成：OTA_ble_app_uart_SDK15_0_0.rar，另外三种DFU模式对应的脚本，我也打成了包，其中没有bonding对应Script_SDK15_S132_NUS_NoBonding.rar，application单独bonding对应Script_SDK15_S132_NUS_Bonding_SUPPORTS_BONDS_0.rar，application和bootloader同时bonding对应Script_SDK15_S132_NUS_Bonding_SUPPORTS_BONDS_1.rar，请大家到百度云盘目录&lt;strong&gt;&lt;em&gt;DFU\ble_app_uart&lt;/em&gt;&lt;/strong&gt;中下载。代码工程解压缩到nRF5_SDK_15.0.0_a53641a\examples\ble_peripheral这个目录下，就可以直接编译和运行。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Jul 2018 17:20:00 +0000</pubDate>
<dc:creator>iini</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iini/p/9314246.html</dc:identifier>
</item>
<item>
<title>写了300多篇文章了，说说我为什么坚持写博客 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9315728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9315728.html</guid>
<description>&lt;p&gt;今天下午突然看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715201701581-612848392.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来，我已经写了300多篇博客了。现在想想，我收获了很多，也失去了很多。现在我想写一篇文章，感想类的文章，也是这么久以来、这么多文章中唯一的一篇非技术类文章。&lt;/p&gt;
&lt;p&gt;开写之前，先把我写的3大系列文章的目录贴出来，几乎所有文章都在这3个系列里。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot;&gt;Linux &amp;amp; shell基础系列：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot;&gt;MySQL/MariaDB系列：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot;&gt;网站架构类系列：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想必你已经看出来了，我写的都是运维类的文章。&lt;/p&gt;

&lt;p&gt;先说说我此刻的状态：拔着胡须，摸着老脸，听着Beyond的《灰色轨迹》，想着这篇文章里我要写什么内容。因为想写的东西实在太多了，完全没有以前写技术类文章的那种流畅感。所以，想到哪里就写到哪里吧。&lt;/p&gt;

&lt;p&gt;想必很多人开博客的那一刻，是想着以后要经常写文章，记录自己学习、进步、经历的方方面面。但是开了博客之后，可能写了一篇、两篇甚至0篇，然后就没有然后了。&lt;/p&gt;
&lt;p&gt;我很荣幸也入了这一群人海中，博客已经开了3年零3个月了，真正开始写博客并坚持到现在，却是从去年(2017)的6月份开始的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715204956889-1959400705.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图里面，2017年6月开始的第一篇文章是&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/6995195.html&quot;&gt;第1章 Linux文件类基础命令&lt;/a&gt;。也许从题目上已经看出了，这是&lt;strong&gt;教程类&lt;/strong&gt;文章，如果你点进去看了，可能还会发现内容冷冰冰的。重点在于教程两个字，下面这张图是我&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot;&gt;Linux &amp;amp; shell基础系列&lt;/a&gt;里的一段话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715205516044-1801677208.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我想为那些非科班、培训班出身的道友提供一个系统学习的地方，完善Linux运维类知识体系&lt;/strong&gt;。这想法很&quot;伟大&quot;，很幼稚，还不知所谓，自己就那么几斤几两，还想写教程，是要误人子弟呢，还是无人子弟呢？但是，我自己的亲身经历告诉我，只要体系够完整，知识够系统，就能让那些正在苦海中挣扎的人找到方向，找到归属感。哪怕有些地方写错了，也无关紧要，对与错，对于学习的人来说，一点都不重要。&lt;/p&gt;
&lt;h2 id=&quot;非科班的孩子学习很累&quot;&gt;2.1 非科班的孩子，学习很累&lt;/h2&gt;
&lt;p&gt;对于非科班出身的人，想转入IT入个门没多大问题。但没有计算机的底子，不懂操作系统原理，只要稍微深入一点，一定会遇到很多问题。&lt;/p&gt;
&lt;p&gt;也许有人会反驳我，觉得现在大学里的课程死板，学不到东西，和真正的工作内容脱节，科班和非科班其实没什么区别(在我印象中我已经听到、看到过好多次这种言论了)。我想说，都是站着说活不腰疼的人，这和读书无用论其实是类似的。&lt;/p&gt;
&lt;p&gt;一个非科班的人的，可能连读、写、IO的概念都不清楚，更别说没学过C语言，去看内核方面的书。正如我上面的图中描述我自己&quot;很长一段时间都不知道什么叫做服务&quot;。这些苦，只有非科班的人能体会。直到现在，我依然认为自己的基础严重欠缺，功底不深，很多该懂的基础都不懂。&lt;/p&gt;
&lt;p&gt;我的IT启蒙老师说过一句话，大概意思是&quot;&lt;strong&gt;大学里落下的课，毕业后一定会花更多时间去补回来&lt;/strong&gt;&quot;。尽管我不是计算机专业的，但对于计算机类的课程来说，我深深的认同这句话。&lt;/p&gt;
&lt;p&gt;无论是非科班出身，还是大学落下了很多知识的人，即使到后面想去补上这些理论基础，又谈何容易。IT世界的水这么深，学那些专业知识的时间尚且不够，如何能狠下心花大量时间来学这些不能立刻带来&quot;生产力&quot;的知识。比如要选择一门语言学习，现在的首选几乎是python，谁会去选C语言？短期内它真的没有什么实际生产力，但是想了解内核，必学C。&lt;/p&gt;
&lt;p&gt;我个人的学习经历比较曲折，初入IT那一两年走了很多弯路，无基础，无人指导。虽然人生的每一段经历都是有意义的，但现在回头想想，实在是浪费了太多不必要的时间。后来从网上找了视频看，不可否认这些视频对于入门来说，帮助是极大的。&lt;strong&gt;但是，但是，但是&lt;/strong&gt;，看视频学习的缺点也是很大的，知识点不深入、知识点不衔接(到处漏洞)、知识体系不完整(如果你说视频的课程目录都很完整，恕我直言，你只是看到了建筑坐落在那里，还不知道门在哪里)，这对于后续再深入学习的阻碍性超乎想象的大。这正是很多公司不收培训班出身的重要原因之一。正如我前面的截图中所说，在我看完了某哥、某男孩几乎两整期的视频后，连bash中文手册都看不懂，我承认自己比较笨，但至少不会笨到弱智的程度，我知道很多人也都和我一样。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;我要写文章，写尽量完整、能前后衔接、又稍有深入的文章，还要尽可能详细地在需要的地方加上相关的&quot;基础理论&quot;知识&lt;/strong&gt;。以便为各初入IT，或者看视频、培训班出身的道友，填充自己的知识点漏洞。这是我最初决定写系列文章的最大原因，也是我至今坚持并励志要写下去的原因。&lt;/p&gt;
&lt;p&gt;我还翻译了一些官方手册，也算是为各位做一点自己的贡献。&lt;/p&gt;
&lt;p&gt;可能有些人会觉得我虚伪，现在哪还有这样的雷锋。如果你真这样想，你错了。IT界有很多活雷锋，那些开源者们，还有众所周知的大佬&lt;a href=&quot;https://www.liaoxuefeng.com&quot;&gt;廖雪峰&lt;/a&gt;、&lt;a href=&quot;http://www.ruanyifeng.com/home.html&quot;&gt;阮一峰&lt;/a&gt;、&lt;a href=&quot;http://www.jinbuguo.com/&quot;&gt;金步国&lt;/a&gt;，等等，他们都是无私地分享知识。我不知道他们最初是为什么写文章，以及为什么坚持下来，但我自己确实是因为曲折的学习经历，而想给一些人提供帮助，我也确实坚持写了不少文章，尽管文章质量上无法和众大神相提并论，但也算是无私奉献，也花了大量心血。&lt;/p&gt;
&lt;h2 id=&quot;网络资源很多却千篇一律&quot;&gt;2.2 网络资源很多，却千篇一律&lt;/h2&gt;
&lt;p&gt;网络资源很多，大多数时候我们也能从网上找到答案，但不可否认，资源太分散，而且绝大多数文章都是浅尝则止，千篇一律，想找到一些出众的、优秀的、比较原理性的文章真的没那么容易。所以，我想写点&quot;与众不同&quot;的文章，而且知识体系还要足够完整。&lt;/p&gt;
&lt;p&gt;当然，我并非是说那些文章不好，每种类型的文章都有对应口味、对应阶段的读者，对不同的人也有不同的帮助。也并非说自己的文章真的多么&quot;与众不同&quot;，只是自我感觉的与众不同。&lt;/p&gt;
&lt;h2 id=&quot;我的文章也有一点价值&quot;&gt;2.3 我的文章也有一点价值&lt;/h2&gt;
&lt;p&gt;在不断分享文章的过程中，发现了不少忠实读者，我知道自己的文章发挥了一定的价值，每一次读者的回馈对我都是很大的鼓励。&lt;/p&gt;
&lt;p&gt;甚至有一些读者在春节前后因为打算换工作而疯狂(深夜、大清早，回复时间推断出来的)读我的文章查缺补漏，那段时间当我收到这类回复和私信时，我的心在流泪，我知道我的文章已经给一些人带去了很大的帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715225320627-1744395925.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715225344187-51064913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715225309197-1438656623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180715225628126-1036167378.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;评论对写文章的鼓励真的很大，这些良好的评价，也更坚定了我坚持写下去的想法。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;还有这些、那些原因都是促使我坚持写下去的原因。&lt;/p&gt;

&lt;p&gt;每个人做每件事都有定位，我对我的文章也有定位。我前面说了，我要写尽量完整、能前后衔接、又稍有深入的文章，还要尽可能详细地在需要的地方加上相关的&quot;基础理论&quot;知识，以便为各初入IT，或者看视频、培训班出身的道友，填充自己的知识点漏洞。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;我的文章定位从开始到现在一直都是：查缺补漏、侧重完整、侧重理论&lt;/strong&gt;。有得必有失，正因为这样，绝大多数文章都很长、很长、很长(顿号处停留时间长一点，可以感受我的无奈)，写出来的内容对初学者不友好，冷冰冰的，不适合没有耐心的人。&lt;/p&gt;
&lt;p&gt;有时候我会自己安慰自己，那些友好的文章都只是用来入门的。真正深入的文章就不可能会友好，看看那些官方手册，全都不友好，但全都是深入所必须阅读的。其实，我连大学语文都会挂科，实在写不出既满足上面几种定位，又足够友好的文章，所以我只能say sorry,sorry again and again。&lt;/p&gt;

&lt;p&gt;最大的收获，是写文章过程中给自己带来的进步。&lt;/p&gt;
&lt;p&gt;我写过一本书(感谢我的IT启蒙老师给我写书的机会)，自开始写书之后，深深地体会到写文章对自己有多大的帮助。不仅能强化理解知识点，而且写作过程中也会经常性地遇到问题、冒出新想法，同时为了文章的完整性，不可缺少地会做很多实验，查很多资料。这是一个良性循环，只要敢查、多查，各方面的知识点都会慢慢累积，增长自己的见识。&lt;/p&gt;
&lt;p&gt;相信写过书的人都知道，要认真、负责地写一本书有多累，与之相应的是有多少收获(写书是赚不了几个钱的)。所以，我的文章几乎都是按照写书的风格写的，只有这样，我自己才会从写文章中不断进步。&lt;/p&gt;

&lt;p&gt;想必各位ITer们，从来都没有停下过学习的脚步，毕竟社会和技术都变化太快了。我也一样，一直坚持学习着，但我是个强迫症患者，遇到问题总想搞清楚，所以在学习的过程中，我一次一次又一次的因为自己的折腾而闹得心情焦灼(喜欢研究的人、强迫症患者一定跟我有类似的经历)。在把遇到的问题研究清楚之前，几乎总是会花掉大量的时间，短则半天或一天，长则一个星期甚至半个月。&lt;/p&gt;
&lt;p&gt;另外，为了保证文章的准确性、完整性，很多时候会花大量时间去做实验、查大量资料并整理、总结。特别是写那些服务软件类文章，几乎每个服务软件都要看很多官方手册。&lt;/p&gt;
&lt;p&gt;很不幸，&lt;strong&gt;我买不起时间的单，现代人都买不起时间的单&lt;/strong&gt;。强迫症患者之所以是强迫症患者，就是最后还是会去买这个单。强行买单的结果，会产生很大的代价。&lt;/p&gt;
&lt;p&gt;失去的时间总是最珍贵的，我只能安慰自己，我失去的时间对自己、对别人都是有价值的。但改革总会阵痛，我的阵痛是我失去的时间。&lt;/p&gt;

&lt;p&gt;在此斗胆鼓励各位写博客，因为写博客的好处很多。它会很大程度上提升自己，很多平时想不到、想不通的东西，在写文章的时候经常会启发式地闪现。有些是灵感，有些是顿悟，更重要的是持续不断地在向前进步着。&lt;/p&gt;
&lt;p&gt;学IT技术(山东蓝翔最强)，每个人都很容易遗忘曾今学过的东西。自己亲手写下文章，写完后对自己写的内容会很熟悉，虽然一样会忘，但以后想找答案，或者面试前翻一翻，会很方便。&lt;/p&gt;
&lt;p&gt;可能有些人说自己&lt;strong&gt;不知道怎么写博客&lt;/strong&gt;。其实，只要开始写，并坚持写，迟早会找到自己的style，网络文章本来就是&quot;free style&quot;的。所以，那些想写，又没有写的道友们，请踏出第一步，&quot;向前看，齐步走&quot;，然后奔跑。&lt;/p&gt;
&lt;p&gt;当然，认真写文章，必然会花去大量时间。如何去衡量，就需要自己去决定了。&lt;/p&gt;

&lt;p&gt;写这些文章，有得有失。但我会坚持写下去，坚持到什么时候我也不知道。至少，在我目前的计划中，还有很多内容要写。&lt;/p&gt;
&lt;p&gt;最后，来个惯例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;欢迎各位光临我的博客，更希望我的文章能对各位有所帮助。这些文章花费了我极大的心血，如果觉得某文章不错，千万别吝啬，&lt;strong&gt;点一下赞或者回复&lt;/strong&gt;一下，这种激励真的很重要，想必各位写过文章的人对评论的重要性都深有体会。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;我水平有限，欠缺很多基础知识，见识也比较少，加上不少文章里的结论都是自己推理出来的(虽然经过了自我感觉比较严谨的测试)，难免会出现错误，但我不希望任何一个知识点、结论&quot;误人子弟&quot;，所以如果各位发现了错误，我怀着120分的期待，盼请指正。&lt;/li&gt;
&lt;li&gt;所有文章完全原创，欢迎转载，但绝不允许不在文章开头或结尾带上文章来源的无脑转载、复制，更不允许恶意利用、据为己有的行为。如有发现，本人享有文章的所有权利。也许我不会因此而对你做出一些法律行为，但我一定会对你狂轰滥炸，四处宣传你的恶行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没想到写了整整一个晚上，该洗洗睡了。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Jul 2018 16:42:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9315728.html</dc:identifier>
</item>
<item>
<title>机智云WebSocket实现物联网游戏 - 维轲Vitcou</title>
<link>http://www.cnblogs.com/vitcou/p/9307982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vitcou/p/9307982.html</guid>
<description>&lt;h3&gt;0、简介&lt;/h3&gt;
&lt;p&gt;　　本人在大学本科最后的一个课程设计，做的比较有趣味，同时最近的物联网逐渐大热，所以分享一下自己的作品设计过程。作品是在机智云最为简单的STM32核心板例程上开展的，使用到的通信协议是机智云写好的机智云连接固件，网页编程也是机智云的WebSocket Demo。本人做的是在原有的核心系统上添加别踩白块的物联网游戏功能。实现效果如下：&lt;/p&gt;
&lt;p&gt;                         　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714211020389-616983121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;优酷视频地址：http://player.youku.com/embed/XMzcyMzU0NjE0OA==&lt;/p&gt;
&lt;p&gt;得到的效果就是在网页上JavaScript 别踩白块游戏显示数据通过WebSocket发送到机智云控制平台，然后机智云下发到STM32，实现网页游戏显示与STM32显示同步（实际会有一点网络延迟）。&lt;/p&gt;

&lt;h3&gt;1、实现设备&lt;/h3&gt;
&lt;p&gt;　　1）SmarKit - ESP STM32核心板&lt;/p&gt;
&lt;p&gt;　　2）机智云平台&lt;/p&gt;
&lt;p&gt;　　3）0.96寸的OLED显示屏（四针，IIC通信）&lt;/p&gt;
&lt;p&gt;　　4）机智云websocket Demo 加上简单的别踩白块游戏JS&lt;/p&gt;
&lt;p&gt; 　   5）烧录好机智云固件的ESP8266&lt;/p&gt;
&lt;h3&gt;2、实现步骤&lt;/h3&gt;
&lt;h4&gt;　　2.1编写STM32硬件程序&lt;/h4&gt;
&lt;p&gt;　　　　在机智云的协议头文件修改自己的设备信息（在机智云创建设备后获取到）：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714213612023-831672810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　添加别踩白块数据的宏定义，在这我是使用两个uint8_t类型数据来传输，因为显示的白块位置共16个，原本打算用uint16_t传输的，但是需要修改整套的机智云上传包格式，所以我就直接拆分两段数据传输，宏定义是为了方便后面编程使用：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714213722324-567987899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　添加别踩白块的数据到传输包结构体：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714214524873-1980162803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　游戏调度函数实现：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714215106682-1343167776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　游戏计时显示&lt;/p&gt;
&lt;p&gt; 　　　　　      　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714215152273-1371504025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　机智云数据包获取后的事件响应函数添加：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714215301729-1023819356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.2 网页别踩白块js与机智云websocket实现&lt;/h4&gt;
&lt;p&gt;　　　　　　具体的实现就是直接使用机智云提供的websocket的Demo添加上别踩白块的JS代码，实际的代码量有点大，这里不详细解说，后续会在文末给出整套代码。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714220655715-947689815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.3 在机智云部署产品&lt;/h4&gt;
&lt;p&gt;　　首先就是在机智云创建一个自己的产品，以此来获取 Product Key，这个是机智云硬件的入网密匙。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714220940770-748179450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　添加数据节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714221018425-142780150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.4 配置网页控制信息&lt;/h4&gt;
&lt;p&gt;　用网页控制接入到机智云的设备仍需要许多步骤，因为要保证设备安全，就必须实现用户与设备绑定，绑定需要获取响应的密令。具体的用户与设备绑定参考机智云官方的资料：http://docs.gizwits.com/zh-cn/UserManual/UseWebsocket.html&lt;/p&gt;
&lt;p&gt;配置成功效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714221833605-1380067025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.5 websocke连接设备&lt;/h4&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714222255081-1414159340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt; 　　2.6 测试物联网别踩白块游戏&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/837605/201807/837605-20180714222352910-670675831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、工程整套源代码&lt;/h3&gt;
&lt;p&gt;　　由于博客园的没有很好的文件分享端口，所以我就使用隔壁CSDN的文件分享：https://download.csdn.net/download/vitcou/10541825&lt;/p&gt;

&lt;p&gt;　　如果有人想要用其他的STM32实现如此效果，就必须配置好机智云连接，我是直接使用烧录好机智云固件的ESP8266来实现的。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Jul 2018 16:33:00 +0000</pubDate>
<dc:creator>维轲Vitcou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vitcou/p/9307982.html</dc:identifier>
</item>
<item>
<title>golang基础--Interface接口 - failymao</title>
<link>http://www.cnblogs.com/failymao/p/9315718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/failymao/p/9315718.html</guid>
<description>&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接口是一个或多个方法签名名的集合，定义方式如下&lt;br/&gt;&lt;code&gt;type Interface_Name interface { method_a() string method_b() int .... }&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;只要某个类型拥有该接口的所有方法签名，就算实现该接口，无需显示声明实现了那个接口，这称为structural Typing&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

type USB interface { //定义一个接口：方法的集合
    Name() string //Name方法，返回string
    Connect()     //Connect方法
}

type PhoneConnecter struct { //定义一个结构
    name string //结构包含一个字段
}

func (pc PhoneConnecter) Name() string { //为结构定义一个方法，绑定接口
    return pc.name //该方法命名为接口内的字段
} //返回结构体字段

func (pc PhoneConnecter) Connect() { //定义结构体另一个方法，与接口另一个方法绑定
    fmt.Println(&quot;Connect:&quot;, pc.name)
}
func main() {
    var a USB                            //定义一个变量为USB接口类型
    a = PhoneConnecter{&quot;PhoneConnecter&quot;} //实例化一个结构体，并赋值给变量（接口）USB
    a.Connect()                          //接口调用其Connect方法，也是结构方法
}

/*输出
Connect: PhoneConnecter
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;接口可以作为匿名嵌入其它接口，或嵌入到结构中&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

type USB interface { //定义一个接口：方法的集合
    Name() string //Name方法，返回string
    Connecter     //嵌入Connecter接口，可以使用Connecter方法
}

type Connecter interface { //定义另一个接口 Connecter
    Connect() //包含一个接口方法：Connect
}
type PhoneConnecter struct { //定义一个结构
    name string //结构包含一个字段
}

func (pc PhoneConnecter) Name() string { //为结构定义一个方法，绑定接口
    return pc.name //该方法命名为接口内的字段
} //返回结构体字段

func (pc PhoneConnecter) Connect() { //定义结构体另一个方法，与接口另一个方法绑定
    fmt.Println(&quot;Connect:&quot;, pc.name)
}
func main() {
    var a USB                            //定义一个变量为USB接口类型
    a = PhoneConnecter{&quot;PhoneConnecter&quot;} //实例化一个结构体，并赋值给变量（接口）USB
    a.Connect()
    Disconnect(a) //接口调用其Connect方法，也是结构方法
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;接口只是方法声明，没有实现调用，没有字段，只能通过绑定的类型方法访问&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

type USB interface { //定义一个接口：方法的集合
    Name() string //Name方法，返回string
    Connecter     //嵌入Connecter接口，可以使用Connecter方法
}

type Connecter interface { //定义另一个接口 Connecter
    Connect() //包含一个接口方法：Connect
}
type PhoneConnecter struct { //定义一个结构
    name string //结构包含一个字段
}

func (pc PhoneConnecter) Name() string { //为结构定义一个方法，绑定接口
    return pc.name //该方法命名为接口内的字段
} //返回结构体字段

func (pc PhoneConnecter) Connect() { //定义结构体另一个方法，与接口另一个方法绑定
    fmt.Println(&quot;Connected:&quot;, pc.name)
}
func main() {
    var a USB                     //定义一个变量为USB接口类型
    a = PhoneConnecter{&quot;htc M10&quot;} //实例化一个结构体，并赋值给变量（接口）USB
    a.Connect()
    Disconnect(a) //接口调用其Connect方法，也是结构方法
}

func Disconnect(usb USB) {
    if pc, ok := usb.(PhoneConnecter); ok { //传入结构体，判断赋值是否成功
        fmt.Println(&quot;Disconnected:&quot;, pc.name)
        return
    }
    fmt.Println(&quot;UNknown device.&quot;)
}

/*输出
Connect: htc M10
Disconnect:htc M10
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;go没有像其他语言继承，如python中的object表示元类，所有的类都继承自object类，go通过接口也类似实现了此定义，因为只要某个类型实现了某个接口的方法，我们就说此类实现了&lt;br/&gt;这个接口。 因为&lt;code&gt;type empty interface{}&lt;/code&gt;---空接口没有任何方法，所以可以理解为所有的接口都实现了空接口的方法（继承）。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

type USB interface { //定义一个接口：方法的集合
    Name() string //Name方法，返回string
    Connecter     //嵌入Connecter接口，可以使用Connecter方法
}

type Connecter interface { //定义另一个接口 Connecter
    Connect() //包含一个接口方法：Connect
}
type PhoneConnecter struct { //定义一个结构
    name string //结构包含一个字段
}

func (pc PhoneConnecter) Name() string { //为结构定义一个方法，绑定接口
    return pc.name //该方法命名为接口内的字段
} //返回结构体字段

func (pc PhoneConnecter) Connect() { //定义结构体另一个方法，与接口另一个方法绑定
    fmt.Println(&quot;Connected:&quot;, pc.name)
}
func main() {
    var a USB                     //定义一个变量为USB接口类型
    a = PhoneConnecter{&quot;htc M10&quot;} //实例化一个结构体，并赋值给变量（接口）USB
    a.Connect()
    Disconnect(a) //接口调用其Connect方法，也是结构方法
}

# func Disconnect(usb interface{}) { //集成空接口，也可以实现
#   if pc, ok := usb.(PhoneConnecter); ok { //传入结构体，判断赋值是否成功
#       fmt.Println(&quot;Disconnected:&quot;, pc.name)
#       return
#   }
#   fmt.Println(&quot;UNknown device.&quot;)
#   }

//通过switch判断接口类型：type...switch用法
func Disconnect(usb interface{}) { //集成空接口，也可以实现
switch v := usb.(type) {
case PhoneConnecter:
    fmt.Println(&quot;Disconnected:&quot;, v.name)
default:
    fmt.Println(&quot;UNknown device.&quot;)
}
}

/*输出
Connect: htc M10
Disconnect:htc M10
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接口间的转换： 只有子类接口可以转换为父类接口，因为父类接口包含了子类接口，子类接口可以调用父类接口一部分接口方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;将对象赋值给接口是，会发生拷贝，而接口内部存储的是只想这个复制品的指针，也就意味着接口无法修改状态，也无法获取指针。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;...
func main() {
pc := PhoneConnecter{&quot;ipad book pro&quot;} //实例化一个结构
var a Connecter                       //定义a为接口变量
a = Connecter(pc)                     //接口强制转换
a.Connect()

pc.name = &quot;Iphone 7&quot;
a.Connect()
...

/*输出
pc.name= &quot;ipad book pro&quot;    Connected: ipad book pro
pc.name = &quot;Iphone 7&quot;        Connected: ipad book pro
*/
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;只有当 接口存储的类型和对象都为nil时，接口才等于nil&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    var a interface{}
    fmt.Println(a == nil)

    var p *int = nil
    a = p
    fmt.Println(a == nil)
}

/*输出
true
false
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口调用不会做Receiver的自动转换&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口同样支持匿名字段的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口也可以实现类似OOP(面向对象编程)中的多态&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;空接口可以作为任何类型数据的容器&lt;/p&gt;
&lt;/li&gt;
</description>
<pubDate>Sun, 15 Jul 2018 16:31:00 +0000</pubDate>
<dc:creator>failymao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/failymao/p/9315718.html</dc:identifier>
</item>
<item>
<title>Spark实战（一）SparkStreaming集成Kafka - FrankDeng</title>
<link>http://www.cnblogs.com/frankdeng/p/9308585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/frankdeng/p/9308585.html</guid>
<description>&lt;h2 id=&quot;spark-streaming-kafka-integration-guide&quot; class=&quot;title&quot;&gt;&lt;span&gt;Spark Streaming + Kafka集成指南&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Kafka项目在版本0.8和0.10之间引入了一个新的消费者API，因此有两个独立的相应Spark Streaming包可用。&lt;/span&gt;&lt;span&gt;请选择正确的包， &lt;/span&gt;&lt;span&gt;请注意，0.8集成与后来的0.9和0.10代理兼容，但0.10集成与早期的代理不兼容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：从Spark 2.3.0开始，不推荐使用Kafka 0.8支持。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spark Streaming从Kafka接收数据，转换为spark streaming中的数据结构Dstream。数据接收方式有&lt;/span&gt;&lt;span&gt;两种 ：1 使用Receiver接收的旧方法：2使用Direct拉取的新方法（在Spark 1.3中引入）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/docs/1.6.3/streaming-kafka-integration.html&quot; target=&quot;_blank&quot;&gt;https://spark.apache.org/docs/1.6.3/streaming-kafka-integration.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/docs/2.3.1/streaming-kafka-0-10-integration.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://spark.apache.org/docs/2.3.1/streaming-kafka-0-10-integration.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于receiver的方式&quot;&gt;Receiver方式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;     Received是使用Kafka高级Consumer API实现的。&lt;/span&gt;&lt;span&gt;与所有接收器一样，&lt;/span&gt;&lt;/span&gt;从Kafka通过Receiver接收的数据存储在Spark Executor的内存中，然后由Spark Streaming启动的job来处理数据。然而默认配置下，这种方式可能会因为底层的失败而丢失数据（请参阅&lt;a href=&quot;https://spark.apache.org/docs/1.4.0/streaming-programming-guide.html#receiver-reliability&quot;&gt;接收器可靠性&lt;/a&gt;）。如果要启用高可靠机制，确保零数据丢失，要启用Spark Streaming的预写日志机制（Write Ahead Log，（已引入）在Spark 1.2）。该机制会同步地将接收到的Kafka数据保存到分布式文件系统（比如HDFS）上的预写日志中，以便底层节点在发生故障时也可以使用预写日志中的数据进行恢复。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201807/1385722-20180715211535349-1558536234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们将讨论如何在流应用程序中使用此方法。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1 链接 &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于使用Maven项目定义的Scala / Java应用程序&lt;/span&gt;&lt;/span&gt;时，我们需要添加相应的依赖包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;&amp;lt;!-- Spark Streaming Kafka --&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spark-streaming-kafka_2.&lt;span&gt;10&lt;/span&gt;&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;1.6&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2 编程 &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在流应用程序代码中，导入&lt;/span&gt;&lt;/span&gt;&lt;code&gt;KafkaUtils&lt;/code&gt;&lt;span&gt;&lt;span&gt;并创建输入DStream，如下所示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Scala编程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import org.apache.spark.streaming.kafka._

   val kafkaStream &lt;/span&gt;=&lt;span&gt; KafkaUtils.createStream(streamingContext, 
     [ZK quorum], [consumer group id], [per&lt;/span&gt;-topic number of Kafka partitions to consume])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java编程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 import org.apache.spark.streaming.kafka.*&lt;span&gt;;

 JavaPairReceiverInputDStream&lt;/span&gt;&amp;lt;String, String&amp;gt; kafkaStream =&lt;span&gt; 
     KafkaUtils.createStream(streamingContext,
     [ZK quorum], [consumer group id], [per&lt;/span&gt;-topic number of Kafka partitions to consume]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有几个需要注意的点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka中topic的partition与Spark Streaming中生成的RDD的partition无关，因此，在KafkaUtils.createStream()中，增加某个topic的partition的数量，只会增加单个Receiver消费topic的线程数，也就是读取Kafka中topic partition的线程数量，它不会增加Spark在处理数据时的并行性。&lt;/li&gt;
&lt;li&gt;可以使用不同的consumer group和topic创建多个Kafka输入DStream，以使用多个receiver并行接收数据。&lt;/li&gt;
&lt;li&gt;如果已使用HDFS等复制文件系统启用了“预读日志”，则接收的数据已在日志中复制。因此，输入流的存储级别的存储级别&lt;code&gt;S&lt;span&gt;torageLevel.MEMORY_AND_DISK_SER&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（即，使用&lt;code&gt;KafkaUtils.createStream(..., StorageLevel.MEMORY_AND_DISK_SER)&lt;/code&gt;）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3 部署&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;与任何Spark应用程序一样，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;spark-submit&lt;/code&gt;&lt;span&gt;&lt;span&gt;用于启动应用程序。&lt;/span&gt;&lt;span&gt;但是，Scala / Java应用程序和Python应用程序的细节略有不同。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于Scala和Java应用程序，如果您使用SBT或Maven进行项目管理，则将&lt;/span&gt;&lt;code&gt;spark-streaming-kafka_2.10&lt;/code&gt;&lt;span&gt;&lt;span&gt;其及其依赖项&lt;/span&gt;&lt;span&gt;打包&lt;/span&gt;&lt;span&gt;到应用程序JAR中。&lt;/span&gt;&lt;span&gt;确保&lt;/span&gt;&lt;/span&gt;&lt;code&gt;spark-core_2.10&lt;/code&gt;&lt;span&gt;并&lt;/span&gt;&lt;code&gt;spark-streaming_2.10&lt;/code&gt;&lt;span&gt;标记为&lt;/span&gt;&lt;code&gt;provided&lt;/code&gt;&lt;span&gt;&lt;span&gt;Spark安装中已存在的依赖项。&lt;/span&gt;&lt;span&gt;然后使用&lt;/span&gt;&lt;/span&gt;&lt;code&gt;spark-submit&lt;/code&gt;&lt;span&gt;&lt;span&gt;启动应用程序&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于缺少SBT / Maven项目管理的Python应用程序，&lt;/span&gt;&lt;code&gt;spark-streaming-kafka_2.10&lt;/code&gt;&lt;span&gt;可以直接将其依赖项添加到&lt;/span&gt;&lt;code&gt;spark-submit&lt;/code&gt;&lt;span&gt;使用中&lt;/span&gt;&lt;code&gt;--packages&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;那是，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 ./bin/spark-submit --packages org.apache.spark:spark-streaming-kafka_2.&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;1.6&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，您也可以下载Maven构件的JAR &lt;/span&gt;&lt;code&gt;spark-streaming-kafka-assembly&lt;/code&gt;&lt;span&gt;从 &lt;/span&gt;&lt;a href=&quot;http://search.maven.org/#search|ga|1|a%3A%22spark-streaming-kafka-assembly_2.10%22%20AND%20v%3A%221.6.3%22&quot;&gt;Maven仓库&lt;/a&gt;&lt;span&gt;，并将其添加到&lt;/span&gt;&lt;code&gt;spark-submit&lt;/code&gt;&lt;span&gt;用&lt;/span&gt;&lt;code&gt;--jars&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;直接读取方式&quot;&gt;Direct方式&lt;/h2&gt;
&lt;p&gt;在spark1.3之后，引入了Direct方式。不同于Receiver的方式，Direct方式没有receiver这一层，其会周期性的获取Kafka中每个topic的每个partition中的最新offsets，之后根据设定的maxRatePerPartition来处理每个batch。其形式如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/524764/201612/524764-20161228154450976-162798485.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这种方法相较于Receiver方式的优势在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;简化的并行&lt;/strong&gt;：在Receiver的方式中我们提到创建多个Receiver之后利用union来合并成一个Dstream的方式提高数据传输并行度。而在Direct方式中，&lt;strong&gt;Kafka中的partition与RDD中的partition是一一对应&lt;/strong&gt;的并行读取Kafka数据，这种映射关系也更利于理解和优化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效&lt;/strong&gt;：在Receiver的方式中，为了达到0数据丢失需要将数据存入Write Ahead Log中，这样在Kafka和日志中就保存了两份数据，浪费！而第二种方式不存在这个问题，只要我们Kafka的数据保留时间足够长，我们都能够从Kafka进行数据恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;精确一次&lt;/strong&gt;：在Receiver的方式中，使用的是Kafka的高阶API接口从Zookeeper中获取offset值，这也是传统的从Kafka中读取数据的方式，但由于Spark Streaming消费的数据和Zookeeper中记录的offset不同步，这种方式偶尔会造成数据重复消费。而第二种方式，直接使用了简单的低阶Kafka API，Offsets则利用Spark Streaming的checkpoints进行记录，消除了这种不一致性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;请注意，此方法的一个缺点是它不会更新Zookeeper中的偏移量，因此基于Zookeeper的Kafka监视工具将不会显示进度。&lt;/span&gt;&lt;span&gt;但是，您可以在每个批处理中访问此方法处理的偏移量，并自行更新Zookeeper。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们将讨论如何在流应用程序中使用此方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1 链接&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spark-streaming-kafka-&lt;span&gt;0&lt;/span&gt;-10_2.&lt;span&gt;11&lt;/span&gt;&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;2.3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2 编程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;请注意，导入的命名空间包括版本org.apache.spark.streaming.kafka010&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Scala编程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import org.apache.kafka.clients.consumer.ConsumerRecord
import org.apache.kafka.common.serialization.StringDeserializer
import org.apache.spark.streaming.kafka010._
import org.apache.spark.streaming.kafka010.LocationStrategies.PreferConsistent
import org.apache.spark.streaming.kafka010.ConsumerStrategies.Subscribe

val kafkaParams &lt;/span&gt;=&lt;span&gt; Map[String, Object](
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootstrap.servers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9092,anotherhost:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key.deserializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt;&lt;span&gt; classOf[StringDeserializer],
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value.deserializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt;&lt;span&gt; classOf[StringDeserializer],
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;use_a_separate_group_id_for_each_stream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auto.offset.reset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;latest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;enable.auto.commit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; (&lt;span&gt;false&lt;/span&gt;&lt;span&gt;: java.lang.Boolean)
)

val topics &lt;/span&gt;= Array(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topicA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topicB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
val stream &lt;/span&gt;=&lt;span&gt; KafkaUtils.createDirectStream[String, String](
  streamingContext,
  PreferConsistent,
  Subscribe[String, String](topics, kafkaParams)
)

stream.map(record &lt;/span&gt;=&amp;gt; (record.key, record.value))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;codetabs tab-content&quot; readability=&quot;31.553221288515&quot;&gt;
&lt;div id=&quot;tab_scala_0&quot; class=&quot;tab-pane active&quot; data-lang=&quot;scala&quot; readability=&quot;9.7086834733894&quot;&gt;
&lt;p&gt;&lt;span&gt;流中的每个项目都是&lt;/span&gt;&lt;a href=&quot;http://kafka.apache.org/0100/javadoc/org/apache/kafka/clients/consumer/ConsumerRecord.html&quot;&gt;ConsumerRecord&lt;/a&gt;，有关可能的kafkaParams，请参阅&lt;a href=&quot;http://kafka.apache.org/documentation.html#newconsumerconfigs&quot;&gt;Kafka使用者配置文档&lt;/a&gt;。如果Spark批处理持续时间大于默认的Kafka心跳会话超时（30秒），请适当增加heartbeat.interval.ms和session.timeout.ms。对于大于5分钟的批次，这将需要在代理上更改group.max.session.timeout.ms。请注意，该示例将enable.auto.commit设置为false，有关讨论，请参阅&lt;a href=&quot;https://spark.apache.org/docs/2.3.1/streaming-kafka-0-10-integration.html#storing-offsets&quot;&gt;存储偏移&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;3 Direct方式案例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9ddfd338-b05a-40a8-875a-05dc6cf169b7')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_9ddfd338-b05a-40a8-875a-05dc6cf169b7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9ddfd338-b05a-40a8-875a-05dc6cf169b7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9ddfd338-b05a-40a8-875a-05dc6cf169b7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9ddfd338-b05a-40a8-875a-05dc6cf169b7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package bigdata.spark
 
import kafka.serializer.{StringDecoder, Decoder}
import org.apache.spark.streaming.kafka.KafkaUtils
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.{SparkContext, SparkConf}
 
import scala.reflect.ClassTag
 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
  * Created by Administrator on 2017/4/28.
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SparkStreamDemo {
  def main(args: Array[String]) {
 
    val conf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkConf()
    conf.setAppName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark_streaming&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    conf.setMaster(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[*]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
    val sc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkContext(conf)
    sc.setCheckpointDir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/checkpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sc.setLogLevel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
    val ssc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StreamingContext(sc, Seconds(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;))
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; val topics = Map(&quot;spark&quot; -&amp;gt; 2)&lt;/span&gt;
&lt;span&gt; 
    val kafkaParams &lt;/span&gt;=&lt;span&gt; Map[String, String](
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootstrap.servers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;m1:9092,m2:9092,m3:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auto.offset.reset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smallest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    )
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直连方式拉取数据，这种方式不会修改数据的偏移量，需要手动的更新&lt;/span&gt;
    val lines =  KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParams, Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).map(_._2)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; val lines = KafkaUtils.createStream(ssc, &quot;m1:2181,m2:2181,m3:2181&quot;, &quot;spark&quot;, topics).map(_._2)&lt;/span&gt;
&lt;span&gt; 
    val ds1 &lt;/span&gt;= lines.flatMap(_.split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;)).map((_, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 
    val ds2 &lt;/span&gt;= ds1.updateStateByKey[Int]((x:Seq[Int], y:Option[Int]) =&amp;gt;&lt;span&gt; {
      Some(x.sum &lt;/span&gt;+ y.getOrElse(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
    })
 
    ds2.print()
 
    ssc.start()
    ssc.awaitTermination()
 
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;spark向kafka中写入数据&quot;&gt;Spark向kafka中写入数据&lt;/h2&gt;
&lt;p&gt;上文阐述了Spark如何从Kafka中流式的读取数据，下面我整理向Kafka中写数据。与读数据不同，Spark并没有提供统一的接口用于写入Kafka，所以我们需要使用底层Kafka接口进行包装。&lt;br/&gt;最直接的做法我们可以想到如下这种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
input.foreachRDD(rdd =&amp;gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能在这里创建KafkaProducer&lt;/span&gt;
  rdd.foreachPartition(partition =&amp;gt;&lt;span&gt;
    partition.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; x:String=&amp;gt;&lt;span&gt;{
        val props &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap[String, Object]()
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, brokers)
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.apache.kafka.common.serialization.StringSerializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.apache.kafka.common.serialization.StringSerializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        println(x)
        val producer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KafkaProducer[String,String](props)
        val message&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ProducerRecord[String, String](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,x)
        producer.send(message)
      }
    }
  )
) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这种方式缺点很明显，对于每个partition的每条记录，我们都需要创建KafkaProducer，然后利用producer进行输出操作，注意这里我们并不能将KafkaProducer的新建任务放在foreachPartition外边，因为KafkaProducer是不可序列化的（not serializable）。显然这种做法是不灵活且低效的，因为每条记录都需要建立一次连接。如何解决呢？&lt;/p&gt;
&lt;p&gt;1.首先，我们需要将KafkaProducer利用lazy val的方式进行包装如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import java.util.concurrent.Future
import org.apache.kafka.clients.producer.{ KafkaProducer, ProducerRecord, RecordMetadata }
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; KafkaSink[K, V](createProducer: () =&amp;gt;&lt;span&gt; KafkaProducer[K, V]) extends Serializable {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is the key idea that allows us to work around running into
     NotSerializableExceptions. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  lazy val producer &lt;/span&gt;=&lt;span&gt; createProducer()
  def send(topic: String, key: K, value: V): Future[RecordMetadata] &lt;/span&gt;=&lt;span&gt;
    producer.send(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProducerRecord[K, V](topic, key, value))
  def send(topic: String, value: V): Future[RecordMetadata] &lt;/span&gt;=&lt;span&gt;
    producer.send(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProducerRecord[K, V](topic, value))
}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; KafkaSink {
  import scala.collection.JavaConversions._
  def apply[K, V](config: Map[String, Object]): KafkaSink[K, V] &lt;/span&gt;=&lt;span&gt; {
    val createProducerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      val producer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KafkaProducer[K, V](config)
      sys.addShutdownHook {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure that, on executor JVM shutdown, the Kafka producer sends
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any buffered messages to Kafka before shutting down.&lt;/span&gt;
&lt;span&gt;        producer.close()
      }
      producer
    }
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KafkaSink(createProducerFunc)
  }
  def apply[K, V](config: java.util.Properties): KafkaSink[K, V] &lt;/span&gt;=&lt;span&gt; apply(config.toMap)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.之后我们利用广播变量的形式，将KafkaProducer广播到每一个executor，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 广播KafkaSink&lt;/span&gt;
val kafkaProducer: Broadcast[KafkaSink[String, String]] =&lt;span&gt; {
  val kafkaProducerConfig &lt;/span&gt;=&lt;span&gt; {
    val p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties()
    p.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootstrap.servers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Conf.brokers)
    p.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key.serializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, classOf[StringSerializer].getName)
    p.setProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value.serializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, classOf[StringSerializer].getName)
    p
  }
  log.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kafka producer init done!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  ssc.sparkContext.broadcast(KafkaSink[String, String](kafkaProducerConfig))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就能在每个executor中愉快的将数据输入到kafka当中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出到kafka&lt;/span&gt;
segmentedStream.foreachRDD(rdd =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;rdd.isEmpty) {
    rdd.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(record =&amp;gt;&lt;span&gt; {
      kafkaProducer.value.send(Conf.outTopics, record._1.toString, record._2)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something else&lt;/span&gt;
&lt;span&gt;    })
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;spark-streamingkafka应用&quot;&gt;Spark streaming+Kafka应用&lt;/h2&gt;
&lt;p&gt;一般Spark Streaming进行流式处理，首先利用上文我们阐述的Direct方式从Kafka拉取batch，之后经过分词、统计等相关处理，回写到DB上（一般为Hbase或者Mysql），由此高效实时的完成每天大量数据的词频统计任务。&lt;/p&gt;
&lt;h2 id=&quot;spark-streamingkafka调优&quot;&gt;Spark streaming+Kafka调优&lt;/h2&gt;
&lt;p&gt;Spark streaming+Kafka的使用中，当数据量较小，很多时候默认配置和使用便能够满足情况，但是当数据量大的时候，就需要进行一定的调整和优化，而这种调整和优化本身也是不同的场景需要不同的配置。&lt;/p&gt;
&lt;h3 id=&quot;合理的批处理时间batchduration&quot;&gt;1 合理的批处理时间（batchDuration）&lt;/h3&gt;
&lt;p&gt;几乎所有的Spark Streaming调优文档都会提及批处理时间的调整，在StreamingContext初始化的时候，有一个参数便是批处理时间的设定。如果这个值设置的过短，即个batchDuration所产生的Job并不能在这期间完成处理，那么就会造成数据不断堆积，最终导致Spark Streaming发生阻塞。而且，一般对于batchDuration的设置不会小于500ms，因为过小会导致SparkStreaming频繁的提交作业，对整个streaming造成额外的负担。在平时的应用中，根据不同的应用场景和硬件配置，我设在1~10s之间，我们可以根据SparkStreaming的可视化监控界面，观察Total Delay来进行batchDuration的调整，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/524764/201701/524764-20170103171142066-1054088549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;合理的kafka拉取量maxrateperpartition重要&quot;&gt;2 合理的Kafka拉取量（maxRatePerPartition重要）&lt;/h3&gt;
&lt;p&gt;对于Spark Streaming消费kafka中数据的应用场景，这个配置是非常关键的，配置参数为：spark.streaming.kafka.maxRatePerPartition。这个参数默认是没有上线的，即kafka当中有多少数据它就会直接全部拉出。而根据生产者写入Kafka的速率以及消费者本身处理数据的速度，同时这个参数需要结合上面的batchDuration，使得每个partition拉取在每个batchDuration期间拉取的数据能够顺利的处理完毕，做到尽可能高的吞吐量，而这个参数的调整可以参考可视化监控界面中的Input Rate和Processing Time，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/524764/201701/524764-20170103172311159-1621531817.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/524764/201701/524764-20170103172338941-153218465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;缓存反复使用的dstreamrdd&quot;&gt;3 缓存反复使用的Dstream（RDD）&lt;/h3&gt;
&lt;p&gt;Spark中的RDD和SparkStreaming中的Dstream，如果被反复的使用，最好利用cache()，将该数据流缓存起来，防止过度的调度资源造成的网络开销。可以参考观察Scheduling Delay参数，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/524764/201701/524764-20170103185139331-147812384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置合理的gc&quot;&gt;4 设置合理的GC&lt;/h3&gt;
&lt;p&gt;长期使用Java的小伙伴都知道，JVM中的垃圾回收机制，可以让我们不过多的关注与内存的分配回收，更加专注于业务逻辑，JVM都会为我们搞定。对JVM有些了解的小伙伴应该知道，在Java虚拟机中，将内存分为了初生代（eden generation）、年轻代（young generation）、老年代（old generation）以及永久代（permanent generation），其中每次GC都是需要耗费一定时间的，尤其是老年代的GC回收，需要对内存碎片进行整理，通常采用标记-清楚的做法。同样的在Spark程序中，JVM GC的频率和时间也是影响整个Spark效率的关键因素。在通常的使用中建议：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;--conf &lt;span class=&quot;hljs-string&quot;&gt;&quot;spark.executor.extraJavaOptions=-XX:+UseConcMarkSweepGC&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置合理的cpu资源数&quot;&gt;5 设置合理的CPU资源数&lt;/h3&gt;
&lt;p&gt;CPU的core数量，每个executor可以占用一个或多个core，可以通过观察CPU的使用率变化来了解计算资源的使用情况，例如，很常见的一种浪费是一个executor占用了多个core，但是总的CPU使用率却不高（因为一个executor并不总能充分利用多核的能力），这个时候可以考虑让么个executor占用更少的core，同时worker下面增加更多的executor，或者一台host上面增加更多的worker来增加并行执行的executor的数量，从而增加CPU利用率。但是增加executor的时候需要考虑好内存消耗，因为一台机器的内存分配给越多的executor，每个executor的内存就越小，以致出现过多的数据spill over甚至out of memory的情况。&lt;/p&gt;
&lt;h3 id=&quot;设置合理的parallelism&quot;&gt;6 设置合理的parallelism&lt;/h3&gt;
&lt;p&gt;partition和parallelism，partition指的就是数据分片的数量，每一次task只能处理一个partition的数据，这个值太小了会导致每片数据量太大，导致内存压力，或者诸多executor的计算能力无法利用充分；但是如果太大了则会导致分片太多，执行效率降低。在执行action类型操作的时候（比如各种reduce操作），partition的数量会选择parent RDD中最大的那一个。而parallelism则指的是在RDD进行reduce类操作的时候，默认返回数据的paritition数量（而在进行map类操作的时候，partition数量通常取自parent RDD中较大的一个，而且也不会涉及shuffle，因此这个parallelism的参数没有影响）。所以说，这两个概念密切相关，都是涉及到数据分片的，作用方式其实是统一的。通过spark.default.parallelism可以设置默认的分片数量，而很多RDD的操作都可以指定一个partition参数来显式控制具体的分片数量。&lt;br/&gt;在SparkStreaming+kafka的使用中，我们采用了Direct连接方式，前文阐述过Spark中的partition和Kafka中的Partition是一一对应的，我们一般默认设置为Kafka中Partition的数量。&lt;/p&gt;
&lt;h3 id=&quot;使用高性能的算子&quot;&gt;7 使用高性能的算子&lt;/h3&gt;
&lt;p&gt;这里参考了美团技术团队的博文，并没有做过具体的性能测试，其建议如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用reduceByKey/aggregateByKey替代groupByKey&lt;/li&gt;
&lt;li&gt;使用mapPartitions替代普通map&lt;/li&gt;
&lt;li&gt;使用foreachPartitions替代foreach&lt;/li&gt;
&lt;li&gt;使用filter之后进行coalesce操作&lt;/li&gt;
&lt;li&gt;使用repartitionAndSortWithinPartitions替代repartition与sort类操作&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用kryo优化序列化性能&quot;&gt;8 使用Kryo优化序列化性能&lt;/h3&gt;
&lt;p&gt;这个优化原则我本身也没有经过测试，但是好多优化文档有提到，这里也记录下来。&lt;br/&gt;在Spark中，主要有三个地方涉及到了序列化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在算子函数中使用到外部变量时，该变量会被序列化后进行网络传输（见“原则七：广播大变量”中的讲解）。&lt;/li&gt;
&lt;li&gt;将自定义的类型作为RDD的泛型类型时（比如JavaRDD，Student是自定义类型），所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现Serializable接口。&lt;/li&gt;
&lt;li&gt;使用可序列化的持久化策略时（比如MEMORY_ONLY_SER），Spark会将RDD中的每个partition都序列化成一个大的字节数组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这三种出现序列化的地方，我们都可以通过使用Kryo序列化类库，来优化序列化和反序列化的性能。Spark默认使用的是Java的序列化机制，也就是ObjectOutputStream/ObjectInputStream API来进行序列化和反序列化。但是Spark同时支持使用Kryo序列化库，Kryo序列化类库的性能比Java序列化类库的性能要高很多。官方介绍，Kryo序列化机制比Java序列化机制，性能高10倍左右。Spark之所以默认没有使用Kryo作为序列化类库，是因为Kryo要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦。&lt;/p&gt;
&lt;p&gt;以下是使用Kryo的代码示例，我们只要设置序列化类，再注册要序列化的自定义类型即可（比如算子函数中使用到的外部变量类型、作为RDD泛型类型的自定义类型等）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建SparkConf对象。&lt;/span&gt;
val conf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SparkConf().setMaster(...).setAppName(...)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置序列化器为KryoSerializer。&lt;/span&gt;
conf.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark.serializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.apache.spark.serializer.KryoSerializer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册要序列化的自定义类型。&lt;/span&gt;
conf.registerKryoClasses(Array(classOf[MyClass1], classOf[MyClass2]))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;结果&quot;&gt;结果&lt;/h3&gt;
&lt;p&gt;经过种种调试优化，我们最终要达到的目的是，Spark Streaming能够实时的拉取Kafka当中的数据，并且能够保持稳定，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/524764/201701/524764-20170103174522644-1161173395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然不同的应用场景会有不同的图形，这是本文词频统计优化稳定后的监控图，我们可以看到Processing Time这一柱形图中有一Stable的虚线，而大多数Batch都能够在这一虚线下处理完毕，说明整体Spark Streaming是运行稳定的。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Jul 2018 15:49:00 +0000</pubDate>
<dc:creator>FrankDeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/frankdeng/p/9308585.html</dc:identifier>
</item>
<item>
<title>Python爬虫之用脚本登录Github并查看信息 - 张丶耀庆</title>
<link>http://www.cnblogs.com/littlesky1124/p/9315617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littlesky1124/p/9315617.html</guid>
<description>&lt;h3&gt;前言分析目标网站的登录方式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　目标地址：&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;https://github.com/login    &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　登录方式做出分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　第一，用form表单方式提交信息，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　第二，有csrf_token,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　第三 ，是以post请求发送用户名和密码时，需要第一次get请求的cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　第四，登录成功以后，请求其他页面是只需要带第一次登录成功以后返回的cookie就可以。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;以get发送的请求获取我们想要的token和cookie&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367493/201807/1367493-20180715225935275-119889209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1367493/201807/1367493-20180715225943882-1167738032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import requests   
from bs4 import BeautifulSoup

r1 = requests.get('https://github.com/login')

soup = BeautifulSoup(r1.text,features='lxml')  #生成soup 对象

s1 = soup.find(name='input',attrs={'name':'authenticity_token'}).get('value')  
#查到我们要的token

r1_cookies = r1.cookies.get_dict()  # 下次提交用户名时用的cookie


# print(r1_cookies)   

# print(s1)


#结果：：

{'logged_in': 'no', '_gh_sess': 'VDFWa2hJWjFMb1hpRUFLRDVhUmc3MXg1Tk02TDhsUnhDMERuNGpyT2Y4STlQZ2xCV1lCZEFhK21wdFR1bkpGYUV0WEJzcDEydWFzcm93&lt;br/&gt;aVc4Nk91Q2JicmtRV0NIQ0lRSWM4aFhrSVFYbCtCczBwdnhVN0YySVJJNUFpQnhyTzNuRkJwNDJZUWxUcEk2M2JkM3VSMDdXVHNOY1htQkthckJQZDJyUVR2RzBNUkU3VnltRVF2U&lt;br/&gt;m1admU3c3YzSGlyVnVZVm0ycnA1eUhET1JRVWNLN0pSbndKWjljMGttNG5URWJ1eU8rQjZXNEMxVEthcGVObDFBY2gvc2ZzWXcvWWZab29wQWJyU0l6cmZscWhBQUlzYTA3dTRtb&lt;br/&gt;3l1S0hDYytHY2V1SUhEWlZvVlZoSWZpTzBjNmlidFF2dzI2bWgtLTJON1lqbm5jWUtSYmtiVEM1clJPakE9PQ%3D%3D--897dbc36c123940c8eae5d86f276dead8318fd6c'}
pRz0wapEbu5shksGCeSN0FijWoU9ALw8EPUsXlqgcw1Ezirl0VbSKvkTYqIe8VhxhPH2H/uzGaV6XX+yjTGoVA==&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;获取这两个值就可以，进行下一步发送登录请求：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;第二步post方式提交用户名密码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367493/201807/1367493-20180715231911532-109904705.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1367493/201807/1367493-20180715231918979-1149765884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 代码：：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
这个代码接着上面的get请求，只是post请求的部分，

r2 = requests.post(
    'https://github.com/session',
    data ={
        'commit':'Sign in',
        'utf8':'✓',
        'authenticity_token':s1,
        'login':'541756569@qq.com',
        'password':'用户名密码'                  # 填上正确的用户名即可
    },
    cookies = r1.cookies.get_dict(),       # 这里需要第一次的cookie
)

print(r2.cookies.get_dict())      # 这个是成功以后的cookie
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;成功以后就返回登录页面的信息。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;基于post登录成功后查看个人详情页。&lt;/h3&gt;
&lt;p&gt;　这里只需要带着登录成功以后的cookie 就可以&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
  #完整代码


import requests
from bs4 import BeautifulSoup

r1 = requests.get('https://github.com/login')

soup = BeautifulSoup(r1.text,features='lxml')

s1 = soup.find(name='input',attrs={'name':'authenticity_token'}).get('value')
r1_cookies = r1.cookies.get_dict()
print(r1_cookies)
print(s1)


r2 = requests.post(
    'https://github.com/session',
    data ={
        'commit':'Sign in',
        'utf8':'✓',
        'authenticity_token':s1,
        'login':'541756569@qq.com',
        'password':'密码'
    },
    cookies = r1.cookies.get_dict(),
)


查看个人详情页


print(r2.cookies.get_dict())

 r3 = requests.get(
       'https://github.com/13131052183/product',   #查看个人的详情页
        cookies = r2.cookies.get_dict()

 )

 print(r3.text)
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Sun, 15 Jul 2018 15:33:00 +0000</pubDate>
<dc:creator>张丶耀庆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littlesky1124/p/9315617.html</dc:identifier>
</item>
<item>
<title>day32_Hibernate学习笔记_04 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9315610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9315610.html</guid>
<description>&lt;h2 id=&quot;hhbernate_log4j&quot;&gt;&lt;span&gt;&lt;strong&gt;一、Hbernate中的日志框架_整合log4j(了解)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Hibernate 利用 Simple Logging Facade for Java (SLF4J)&lt;br/&gt;来记录不同系统事件的日志。SLF4J 可以根据你选择的绑定把日志输出到几个日志框架（NOP、Simple、log4j version&lt;br/&gt;1.2、JDK 1.4 logging、JCL 或 logback）上。&lt;/li&gt;
&lt;li&gt;slf4j 核心jar：slf4j-api-1.6.1.jar 。slf4j 是日志框架，将其他优秀的日志第三方进行了整合。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/01.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;整合导入jar包，添加至构建路径&lt;br/&gt;  1、log4j 核心包：log4j-1.2.17.jar&lt;br/&gt;  2、过渡jar（整合jar）：slf4j-log4j12-1.7.5.jar&lt;/li&gt;
&lt;li&gt;导入配置文件，该文件在 &lt;strong&gt;\hibernate-distribution-3.6.10.Final\project\etc&lt;/strong&gt; 中，拷贝至项目的src 目录下&lt;br/&gt;  log4j.properties，此配置文件配置log4j 如何输出日志。&lt;/li&gt;
&lt;li&gt;编写配置文件内容：&lt;br/&gt;  1、记录器&lt;br/&gt;  2、输出源&lt;br/&gt;  3、布局&lt;/li&gt;
&lt;li&gt;记录器：&lt;br/&gt;  例如：log4j.rootLogger=info, stdout, file&lt;br/&gt;  格式：log4j.rootLogger=日志级别, 输出源1, 输出源2, ……&lt;br/&gt;  log4j 日志级别：fatal 致命错误、error 错误、warn 警告、info 信息、debug 调试信息、trace 堆栈信息 （&lt;strong&gt;输出信息多少：日志信息量逐渐增加&lt;/strong&gt;），&lt;span&gt;项目上线时用error&lt;/span&gt;，&lt;span&gt;项目开发中用info&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;输出源：&lt;br/&gt;  例如：log4j.appender.file=org.apache.log4j.FileAppender&lt;br/&gt;  格式：log4j.appender.输出源的名称=输出源的实现类&lt;br/&gt;    输出源的名称：自定义&lt;br/&gt;    输出源的实现类：log4j提供&lt;br/&gt;  输出源的属性，例如：log4j.appender.file.File=d:\mylog.log&lt;br/&gt;  输出源的属性格式：log4j.appender.名称.属性=值&lt;br/&gt;  每一个输出源对应一个实现类，实现类都是属性（setter），底层执行setter方法进行赋值。&lt;/li&gt;
&lt;li&gt;常见的输出源实现类：&lt;br/&gt;  org.apache.log4j.FileAppender 输出文件中&lt;br/&gt;    file，表示文件输出位置&lt;br/&gt;  org.apache.log4j.ConsoleAppender 输出到控制台&lt;br/&gt;    Target，表示使用哪种输出方式，在控制台打印内容，取值：System.out / System.err&lt;/li&gt;
&lt;li&gt;布局 =&amp;gt; 确定输出格式&lt;br/&gt;  例如：log4j.appender.stdout.layout=org.apache.log4j.PatternLayout&lt;br/&gt;  格式：log4j.appender.数据源.layout=org.apache.log4j.PatternLayout&lt;br/&gt;  布局属性：log4j.appender. 数据源.layout.ConversionPattern=值&lt;br/&gt;    例如1：log4j.appender.stdout.layout.ConversionPattern=&lt;strong&gt;&lt;code&gt;%d{ABSOLUTE} %5p %c{1}:%L - %m%n&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;    输出为：21:57:26,197 INFO SessionFactoryImpl:927 - closing&lt;br/&gt;    例如2：log4j.appender.logfile.layout.ConversionPattern=&lt;strong&gt;&lt;code&gt;%d %p [%c] - %m%n&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;    输出为：closing&lt;/li&gt;
&lt;li&gt;扩展：对指定的目录设置日志级别&lt;br/&gt;  例如：log4j.logger.org.hibernate.transaction=debug&lt;br/&gt;  格式：log4j.logger.包结构=级别&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;hhibernate&quot;&gt;&lt;span&gt;&lt;strong&gt;二、Hibernate的关联关系映射（一对一）（了解）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;情况1：主表的主键，与从表的外键（唯一），形成主外键关系。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;情况2：主表的主键，与从表的主键，形成主外键关系 （从表的主键又是外键，即主键同步）-- &lt;strong&gt;推荐使用该方式&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如下图所示：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/02_%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h211&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1、情况1示例&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Company.hbm.xml&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs xml&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &lt;br/&gt;&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;&lt;br/&gt;&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.itheima.domain&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Company&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;table&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;t_company&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cid&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cid&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;native&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;one-to-one&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;address&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;property-ref&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;company&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;one-to-one&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Address.hbm.xml&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs xml&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &lt;br/&gt;&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;&lt;br/&gt;&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.itheima.domain&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;table&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;t_address&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aid&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aid&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;native&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;many-to-one&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;company&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Company&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;company_id&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;unique&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;many-to-one&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre readability=&quot;15&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;24&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.itheima.a_one2one;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.hibernate.Session;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Test;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Address;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Company;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.utils.HibernateUtils;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Demo1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Session session = HibernateUtils.openSession();&lt;br/&gt;session.beginTransaction();&lt;/p&gt;&lt;p&gt;Company c = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Company();&lt;br/&gt;c.setCname(&lt;span class=&quot;hljs-string&quot;&gt;&quot;传智播客&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;Address a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Address();&lt;br/&gt;a.setAname(&lt;span class=&quot;hljs-string&quot;&gt;&quot;北京市朝阳区平房乡红门村28号&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;a.setCompany(c); &lt;/p&gt;&lt;p&gt;session.save(c);&lt;br/&gt;session.save(a);&lt;/p&gt;&lt;p&gt;session.getTransaction().commit();&lt;br/&gt;session.close();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Session session = HibernateUtils.openSession();&lt;br/&gt;session.beginTransaction();&lt;/p&gt;&lt;p&gt;Company c = (Company) session.get(Company.class, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(c);&lt;/p&gt;&lt;p&gt;session.getTransaction().commit();&lt;br/&gt;session.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h222&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2、情况2示例&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Company.hbm.xml&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs xml&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &lt;br/&gt;&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;&lt;br/&gt;&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.itheima.domain&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Company&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;table&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;t_company&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cid&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cid&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;native&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;cname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;one-to-one&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;address&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;one-to-one&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Address.hbm.xml&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs xml&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &lt;br/&gt;&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;&lt;br/&gt;&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.itheima.domain&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Address&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;table&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;t_address&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aid&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aid&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;foreign&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;property&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;company&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;generator&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;column&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;aname&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;string&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;one-to-one&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;company&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Company&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;constrained&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;one-to-one&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;hibernate-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码同上：&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;三、二级缓存【掌握】&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h311&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.1、缓存&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  缓存(Cache)：是计算机领域非常通用的概念。它介&lt;strong&gt;于应用程序&lt;/strong&gt;和&lt;strong&gt;永久性数据存储源&lt;/strong&gt;（如硬盘上的文件或者数据库）之间，其作用是&lt;strong&gt;&lt;code&gt;降低应用程序直接读写硬盘&lt;/code&gt;&lt;/strong&gt;（永久性数据存储源）的频率，从而提高应用的运行&lt;strong&gt;&lt;code&gt;性能&lt;/code&gt;&lt;/strong&gt;。缓存中的数据是数据存储源中数据的拷贝。缓存的物理介质通常是&lt;strong&gt;&lt;code&gt;内存&lt;/code&gt;&lt;/strong&gt;。&lt;br/&gt;  缓存：程序 &amp;lt;-- （内存） --&amp;gt; 硬盘&lt;/p&gt;
&lt;h4 id=&quot;h312&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.2、什么是二级缓存？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Hibernate 提供缓存机制：一级缓存、二级缓存。&lt;br/&gt;&lt;strong&gt;&lt;code&gt;一级缓存&lt;/code&gt;&lt;/strong&gt;：Session 级别缓存，在一次请求中共享数据。（当前有多少个线程连接到数据库，就会有多少个一级缓存。）&lt;br/&gt;&lt;strong&gt;&lt;code&gt;二级缓存&lt;/code&gt;&lt;/strong&gt;：SessionFactory 级别缓存，整个应用程序共享一个会话工厂，共享一个二级缓存。（二级缓存中存放的是经常使用的、不经常被修改的数据。）&lt;/li&gt;
&lt;li&gt;SessionFactory的缓存两部分：&lt;br/&gt;&lt;strong&gt;&lt;code&gt;内置缓存&lt;/code&gt;&lt;/strong&gt;：使用一个Map，用于存放&lt;strong&gt;&lt;code&gt;配置信息&lt;/code&gt;&lt;/strong&gt;，如预定义的HQL语句等，提供给Hibernate框架自己使用，对外只读。不能操作。&lt;br/&gt;&lt;strong&gt;&lt;code&gt;外置缓存&lt;/code&gt;&lt;/strong&gt;：使用另一个Map，用于存放&lt;strong&gt;&lt;code&gt;用户自定义数据&lt;/code&gt;&lt;/strong&gt;。默认不开启。对于外置缓存，Hibernate只提供规范（接口），需要第三方实现类，所以我们使用二级缓存，还得导入第三方的jar包。外置缓存又称为二级缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h313&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.3、二级缓存的内部结构&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;二级缓存就是由4部分构成：&lt;br/&gt;  类级别缓存&lt;br/&gt;  集合级别缓存&lt;br/&gt;  时间戳缓存&lt;br/&gt;  &lt;strong&gt;查询级别缓存(二级缓存的第2大部分:三级缓存)&lt;/strong&gt;&lt;br/&gt;内部结构如下所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/03.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h314&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.4、并发访问策略&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;访问策略：读写型（read-write）、只读型（read-only）&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/04.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h315&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.5、应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;适合放入二级缓存中的数据：&lt;br/&gt;很少被修改&lt;br/&gt;不是很重要的数据，允许出现偶尔的并发问题&lt;/li&gt;
&lt;li&gt;不适合放入二级缓存中的数据：&lt;br/&gt;经常被修改&lt;br/&gt;财务数据，绝对不允许出现并发问题&lt;br/&gt;与其他应用数据共享的数据&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h316&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1.6、二级缓存提供商（即实现了二级缓存接口的厂商）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;EHCache&lt;/strong&gt;：可作为进程（单机）范围内的缓存，存放数据的物理介质可以是内存或硬盘，对 Hibernate 的查询缓存提供了支持。且&lt;strong&gt;支持集群&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OpenSymphony：可作为进程范围内的缓存，存放数据的物理介质可以是内存或硬盘。提供了丰富的缓存数据过期策略，对 Hibernate 的查询缓存提供了支持。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SwarmCache：可作为集群范围内的缓存，但不支持 Hibernate 的查询缓存。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;JBoss Cache：可作为集群范围内的缓存，支持 Hibernate 的查询缓存。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/05.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h32&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、配置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  配置即操作：亦即使用二级缓存提供商的提供的jar。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1、导入jar包并添加至构建路径：ehcache-1.5.0.jar(核心包)、commons-logging.jar(依赖包)、backport-util-concurrent.jar(依赖包)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2、开启二级缓存（我要使用二级缓存）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3、确定二级缓存提供商（我要使用哪个二级缓存）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;4、确定需要缓存内容&lt;br/&gt;  (1)配置需要缓存的类&lt;br/&gt;  (2)配置需要缓存的集合&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5、配置ehcache的自定义配置文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h321jar&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.1、导入jar包并添加至构建路径&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/06.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h322&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.2、开启二级缓存（我要使用二级缓存）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　先在 hibernate.properties 中找到对应的键和值：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/07.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　再在 hibernate.cfg.xml 中配置开启二级缓存：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/08.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h323&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.3、确定二级缓存提供商(我要使用哪个二级缓存)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　先在 hibernate.properties 中找到对应的键和值：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/09.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　再在 hibernate.cfg.xml 中配置确定二级缓存提供商：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/10.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h324&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.4、确定缓存内容&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　在 hibernate.cfg.xml 中确定 &lt;code&gt;类级别缓存&lt;/code&gt; 和 &lt;code&gt;集合级别缓存&lt;/code&gt; 配置项：&lt;br/&gt;　　先确定这两个缓存所在配置文件中的位置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/11.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　具体配置：&lt;br/&gt;&lt;img title=&quot;、&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/12.png&quot; alt=&quot;、&quot;/&gt;&lt;br/&gt;&lt;h4 id=&quot;h325ehcache&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.5、ehcache配置文件&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;步骤1：从jar包复制 &lt;code&gt;ehcache-failsafe.xml&lt;/code&gt; 文件&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/13.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;步骤2：将 &lt;code&gt;ehcache-failsafe.xml&lt;/code&gt; 重命名 &lt;code&gt;ehcache.xml&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/14.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;步骤3：将修改后的 &lt;code&gt;ehcache.xml&lt;/code&gt;，拷贝到src下&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/15.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;步骤4：删除掉 &lt;code&gt;ehcache.xml&lt;/code&gt; 文件中无用的注释，得到清爽的 &lt;code&gt;ehcache.xml&lt;/code&gt; 文件，文件内容如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ehcache.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ehcache&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;xsi:noNamespaceSchemaLocation&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;../config/ehcache.xsd&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;diskStore&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;java.io.tmpdir&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;defaultCache&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;maxElementsInMemory&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;eternal&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;timeToIdleSeconds&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;timeToLiveSeconds&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;overflowToDisk&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;maxElementsOnDisk&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000000&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;diskPersistent&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;diskExpiryThreadIntervalSeconds&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;memoryStoreEvictionPolicy&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;LRU&quot;&lt;/span&gt;&lt;br/&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ehcache&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　一般，该文件的配置不是我们的工作，我们使用默认的配置即可，如果想配置，请看下文的 &lt;code&gt;3.4、ehcache配置文件详解&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;h33&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3、演示&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h331&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.1、证明二级缓存存在&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　示例代码如下：见类缓存中的示例代码&lt;/p&gt;
&lt;h4 id=&quot;h332&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.2、类缓存&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;类缓存：只存放数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一级缓存：存放对象本身&lt;br/&gt;如下图所示：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/16.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;hljs kotlin&quot; readability=&quot;16&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.itheima.a_one2one;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.hibernate.Session;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Test;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Customer;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.utils.HibernateUtils;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Demo1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; void fun1() {&lt;br/&gt;Session session = HibernateUtils.openSession();&lt;br/&gt;session.beginTransaction();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Customer c1 = (Customer) session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(Customer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;br/&gt;session.clear(); &lt;br/&gt;Customer c2 = (Customer) session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(Customer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;/p&gt;&lt;p&gt;&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(c1 == c2); &lt;br/&gt;&lt;/p&gt;&lt;p&gt;session.getTransaction().commit();&lt;br/&gt;session.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h333&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.3、集合缓存&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/17.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/18.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　示例代码如下：
&lt;/p&gt;&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;hljs kotlin&quot; readability=&quot;20&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.itheima.a_one2one;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.Iterator;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.hibernate.Session;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Test;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Customer;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Order;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.utils.HibernateUtils;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Demo2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; void fun1() {&lt;br/&gt;Session session = HibernateUtils.openSession();&lt;br/&gt;session.beginTransaction();&lt;/p&gt;&lt;p&gt;Customer c1 = (Customer) session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(Customer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Order o : c1.getOrders()) { &lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(o.getOname());&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;session.clear(); &lt;/p&gt;&lt;p&gt;&lt;br/&gt;Customer c2 = (Customer) session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(Customer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;br/&gt;Iterator&amp;lt;Order&amp;gt; it = c2.getOrders().iterator(); &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (it.hasNext()) {&lt;br/&gt;Order o = it.next();&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(o.getOname());&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;p&gt;session.getTransaction().commit();&lt;br/&gt;session.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h334&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.4、查询缓存&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;查询缓存又称为三级缓存（民间叫法）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查询缓存默认不使用。需要手动开启。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查询缓存：将HQL语句与查询结果进行绑定。通过HQL相同语句可以缓存内容。&lt;br/&gt;默认情况Query对象只将查询结果存放在一级和二级缓存中，不从一级或二级缓存中获取。&lt;br/&gt;查询缓存就是让Query可以从二级缓存中获得内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;步骤一：开启查询缓存&lt;br/&gt;　　先在 hibernate.properties 中找到对应的键和值：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/19.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　再在 hibernate.cfg.xml 中配置开启查询缓存：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/20.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;步骤二：在查询query对象时，需要设置缓存内容（&lt;code&gt;注意：存放和查询 都需要设置&lt;/code&gt;）&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/21.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　示例代码如下：
&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;hljs cpp&quot; readability=&quot;16&quot;&gt;package com.itheima.a_one2one;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.List;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.hibernate.Query;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.hibernate.Session;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Test;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Customer;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.utils.HibernateUtils;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Demo3&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;@SuppressWarnings({ &lt;span class=&quot;hljs-string&quot;&gt;&quot;unused&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;unchecked&quot;&lt;/span&gt; })&lt;br/&gt;@Test&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;fun1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Session session = HibernateUtils.openSession();&lt;br/&gt;session.beginTransaction();&lt;/p&gt;&lt;p&gt;Query query = session.createQuery(&lt;span class=&quot;hljs-string&quot;&gt;&quot;from Customer&quot;&lt;/span&gt;);&lt;br/&gt;query.setCacheable(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;); &lt;br/&gt;List&amp;lt;Customer&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; = query.&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(); &lt;/p&gt;&lt;p&gt;session.clear(); &lt;/p&gt;&lt;p&gt;Query query2 = session.createQuery(&lt;span class=&quot;hljs-string&quot;&gt;&quot;select c from Customer c&quot;&lt;/span&gt;);&lt;br/&gt;query2.setCacheable(&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Customer&amp;gt; list2 = query2.&lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;(); &lt;/p&gt;&lt;p&gt;session.getTransaction().commit();&lt;br/&gt;session.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h335&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.5、时间戳缓存&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;时间戳：任何操作都在时间戳中记录操作时间。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;hljs kotlin&quot; readability=&quot;17&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.itheima.a_one2one;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.hibernate.Session;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.junit.Test;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.domain.Customer;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.itheima.utils.HibernateUtils;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Demo4&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@SuppressWarnings(&lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;unused&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; void fun1() {&lt;br/&gt;Session session = HibernateUtils.openSession();&lt;br/&gt;session.beginTransaction();&lt;/p&gt;&lt;p&gt;Customer c1 = (Customer) session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(Customer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;br/&gt;session.createQuery(&lt;span class=&quot;hljs-string&quot;&gt;&quot;update Customer set cname=:cname where cid =:cid&quot;&lt;/span&gt;).setString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cname&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;rose&quot;&lt;/span&gt;).setInteger(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cid&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).executeUpdate(); &lt;br/&gt;session.clear(); &lt;br/&gt;Customer c2 = (Customer) session.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(Customer.&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;); &lt;/p&gt;&lt;p&gt;session.getTransaction().commit();&lt;br/&gt;session.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;二级缓存中类缓存、集合缓存、查询缓存、时间戳缓存的总结图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;http://pbwya9suz.bkt.clouddn.com/23.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h34ehcache&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4、ehcache配置文件详解&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;hljs lua&quot; readability=&quot;16&quot;&gt;&amp;lt;ehcache xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt; xsi:noNamespaceSchemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;../config/ehcache.xsd&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;diskStore &lt;span class=&quot;hljs-built_in&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;java.io.tmpdir&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;&amp;lt;defaultCache&lt;br/&gt;maxElementsInMemory=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000&quot;&lt;/span&gt;&lt;br/&gt;eternal=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;timeToIdleSeconds=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;&lt;br/&gt;timeToLiveSeconds=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;&lt;br/&gt;overflowToDisk=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;br/&gt;maxElementsOnDisk=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000000&quot;&lt;/span&gt;&lt;br/&gt;diskPersistent=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;diskExpiryThreadIntervalSeconds=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;&lt;br/&gt;memoryStoreEvictionPolicy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;LRU&quot;&lt;/span&gt;&lt;br/&gt;/&amp;gt;&lt;br/&gt;&amp;lt;/ehcache&amp;gt;&lt;p&gt;&amp;lt;!&lt;br/&gt;&amp;lt;diskStore &lt;span class=&quot;hljs-built_in&quot;&gt;path&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;java.io.tmpdir&quot;&lt;/span&gt;/&amp;gt;  设置临时文件存放位置。（缓存一般写入内存，一定程度时，写入硬盘。）&lt;/p&gt;&lt;p&gt;缓存详细设置&lt;br/&gt;&amp;lt;defaultCache /&amp;gt;    所有的缓存对象默认的配置&lt;br/&gt;&amp;lt;cache name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;类&quot;&lt;/span&gt;&amp;gt;    指定对象单独配置&lt;/p&gt;&lt;p&gt;参数设置&lt;br/&gt;maxElementsInMemory=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000&quot;&lt;/span&gt;     内存最大数（类内存中存储对象数据的散列的最大数）&lt;br/&gt;eternal=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;                 是否永久（内存常驻留）&lt;br/&gt;timeToIdleSeconds=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;         对象在内存中最多空闲多少秒&lt;br/&gt;timeToLiveSeconds=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;         对象在内存中最多存活多少秒&lt;br/&gt;overflowToDisk=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt;           内存满了，是否写入到硬盘&lt;br/&gt;maxElementsOnDisk=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10000000&quot;&lt;/span&gt;    硬盘最大数（硬盘中存储对象数据的散列的最大数）&lt;br/&gt;diskPersistent=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot;&lt;/span&gt;          关闭JVM，是否将内存保存硬盘中&lt;br/&gt;diskExpiryThreadIntervalSeconds=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot;&lt;/span&gt;  轮询&lt;br/&gt;memoryStoreEvictionPolicy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;LRU&quot;&lt;/span&gt;&lt;br/&gt;Least Recently Used (specified as LRU)&lt;br/&gt;First In First Out (specified as FIFO) &lt;br/&gt;Less Frequently Used (specified as LFU)&lt;/p&gt;&lt;p&gt;•maxElementsInMemory    设置基于内存的缓存中可存放的对象最大数目 &lt;br/&gt;•eternal                设置对象是否为永久的，&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;表示永不过期，此时将忽略timeToIdleSeconds 和 timeToLiveSeconds属性，默认值是&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt; &lt;br/&gt;•timeToIdleSeconds      设置对象空闲最长时间，以秒为单位，超过这个时间，对象过期。当对象过期时，EHCache会把它从缓存中清除。如果此值为&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;，表示对象可以无限期地处于空闲状态。 &lt;br/&gt;•timeToLiveSeconds      设置对象生存最长时间，超过这个时间，对象过期。&lt;br/&gt;如果此值为&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;，表示对象可以无限期地存在于缓存中。该属性值必须大于或等于 timeToIdleSeconds属性值。&lt;br/&gt;•overflowToDisk         设置基于内在的缓存中的对象数目达到上限后，是否把溢出的对象写到基于硬盘的缓存中 。&lt;br/&gt;•diskPersistent         当jvm结束时是否持久化对象，默认是&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;•diskExpiryThreadIntervalSeconds    指定专门用于清除过期对象的监听线程的轮询时间。&lt;br/&gt;•memoryStoreEvictionPolicy          当内存缓存达到最大，有新的element加入的时候，移除缓存中element的策略。&lt;br/&gt;默认是LRU（移除最近最少使用的元素），可选的有LFU（移除最不常使用的元素）和FIFO（先进先出） 。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;hhibernate-1&quot;&gt;&lt;span&gt;&lt;strong&gt;四、Hibernate小案例&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
</description>
<pubDate>Sun, 15 Jul 2018 15:30:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9315610.html</dc:identifier>
</item>
<item>
<title>Mini2440上的第一个程序——点亮Led - icuic</title>
<link>http://www.cnblogs.com/outs/p/9315162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/outs/p/9315162.html</guid>
<description>&lt;p&gt;手头的Mini2440搁置了两年半之后，我再次决定拿出它，重新尝试嵌入式Linux的学习。&lt;/p&gt;
&lt;p&gt;我使用的是友善之臂的Mini2440开发板、韦东山的《嵌入式Linux应用开发完成手册》及其视频教程。所以，本篇文章中所涉及到的各种软件均可在以下两处找到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1dEAqyy9&quot; target=&quot;_blank&quot;&gt;Mini2440开发板的配套光盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://eyun.baidu.com/s/3b1UtLc&quot; target=&quot;_blank&quot;&gt;韦东山JZ2440开发板的光盘&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;JZ2440是韦东山出品的开发板，作为《嵌入式Linux应用开发完全手册》的配套硬件，它和Mini2440相差无几，所以我这里用的是Mini2440。&lt;/p&gt;
&lt;h2 id=&quot;一目标&quot;&gt;一、目标&lt;/h2&gt;
&lt;p&gt;动手之前先确定好一个小目标——这一次，我们的目标是在Mini2440上点亮LED，怎么样，听起来很简单吧。&lt;br/&gt;但是做起来，可并不是很简单喏，主要是因为会涉及到比较多的软件，下一节会对各软件做个大致的介绍，你只要知道各个软件是用来做什么的就可以了，先不必细究。&lt;/p&gt;
&lt;h2 id=&quot;二开发环境&quot;&gt;二、开发环境&lt;/h2&gt;
&lt;p&gt;硬件平台：Mini2440 (64M Nand flash)&lt;/p&gt;&lt;p&gt;软件编译平台：Ubuntu 9.10&lt;br/&gt;以下是你接下来会依次接触到的软件或是工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;vi或是vim: Linux下的文本编辑器，你可以把它想象成Windows下的记事本。我们会使用它来编写代码和Makefile文件。&lt;/li&gt;
&lt;li&gt;Makefile: Makefile是一个文本文件，它里面的内容描述了如何根据源文件生成目标文件，即我们所需要的bin文件。在第2.2节会让你编写Makefile文件。&lt;/li&gt;
&lt;li&gt;make: make是一个工具，它以Makefile作为其输入，根据Makefile内描述的规则，生成目标文件。&lt;/li&gt;
&lt;li&gt;VMWare tools: VMWare tools是VMWare里面的一项工具，我们这里用它来实现Windows和Ubuntu虚拟机之间的文件共享，它在1.2节会提及。&lt;/li&gt;
&lt;li&gt;Terminal: 终端。类似于Windows中的命令行，在2.3节我们会使用到它。&lt;/li&gt;
&lt;li&gt;Jlink:Segger公司出品的仿真器，本文中我们仅用它来烧录Mini2440开发板上的Nor Flash。&lt;/li&gt;
&lt;li&gt;supervivi: 友善之臂开发的类似于u-boot的程序，它通常被烧录至Mini2440开发板上的Nand Flash或是Nor Flash中。&lt;/li&gt;
&lt;li&gt;dnw:与supervivi配合使用，完成向开发板下载程序的工具软件。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三操作步骤&quot;&gt;三、操作步骤&lt;/h2&gt;
&lt;h3 id=&quot;搭建编译环境&quot;&gt;1. 搭建编译环境&lt;/h3&gt;
&lt;h4 id=&quot;vmware与ubuntu9.10-的下载与安装&quot;&gt;1.1 VMWare与Ubuntu9.10 的下载与安装&lt;/h4&gt;
&lt;p&gt;下载&lt;a href=&quot;https://eyun.baidu.com/s/3b1UtLc&quot; target=&quot;_blank&quot;&gt;JZ2440的配套光盘&lt;/a&gt;，光盘里面有VMWare和已经安装好编译工具链的Ubuntu。&lt;/p&gt;&lt;p&gt;下载完成之后安装VMWare，然后用VMWare打开Ubuntu。整个过程比较简单，网上有很多教程。&lt;/p&gt;&lt;p&gt;介绍一下大致的工作流程：&lt;/p&gt;&lt;p&gt;我们将Windows作为主机，在Windows上，我们可以通过VMWare访问虚拟机Ubuntu。而Ubuntu仅仅作为编译环境，其余的大部分操作还是在Windows上完成。使用Ubuntu的最终目的是生成可供下载至Mini2440的bin文件，然后在Windows上通过相应的工具将这个bin文件烧录至2440开发板。&lt;/p&gt;&lt;p&gt;那么，你可能要问了，这两个不同的操作系统之间，可以互相访问吗，生成的bin文件要如何在两者之间传递呢？&lt;/p&gt;&lt;p&gt;不着急，我们接下来就会来解决这个问题了。&lt;/p&gt;
&lt;h4 id=&quot;在windows与ubuntu之间设置共享文件夹&quot;&gt;1.2 在Windows与Ubuntu之间设置共享文件夹&lt;/h4&gt;
&lt;p&gt;接下来在主机（通常是Windows）与虚拟机（这里是Ubunbu）之间设置共享文件夹，主要是安装VMWare tools，这里不再赘述，网络上有相应的&lt;a href=&quot;https://www.cnblogs.com/huangjianxin/p/6343881.html&quot; target=&quot;_blank&quot;&gt;教程&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;刚才一口气做了这么多事，让我们先来休息一会儿，想一想我们都已经完成了哪些事了。&lt;/p&gt;&lt;p&gt;到现在为止，我们已经在Windows上安装好了VMWare，通过VMWAre我们可以使用Ubuntu系统，接下来，我们将在Ubuntu中编写点亮Led的代码，以及描述如何生成可供下载至Mini2440的bin文件。通过在1.2节设置的共享文件夹，在Windows上，我们可以取到这个bin文件，并通过相应的工具将它烧录至Mini2440。&lt;/p&gt;
&lt;h3 id=&quot;编写led程序和makefile&quot;&gt;2. 编写led程序和Makefile&lt;/h3&gt;
&lt;h4 id=&quot;通过vi输入led_on.s&quot;&gt;2.1 通过vi输入led_on.s&lt;/h4&gt;
&lt;p&gt;你可能是头一次听说vi,还不知道如何使用。关于vim，网上也很大把的教程，同时，这里也有vi的&lt;a href=&quot;https://eyun.baidu.com/s/3b1UtLc#sharelink/path=%2F100ask%E5%88%86%E4%BA%AB%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%2F005_ARM%E8%A3%B8%E6%9C%BA1%E6%9C%9F%E5%8A%A0%E5%BC%BA%E7%89%88(%E6%96%B01%E6%9C%9F)%2F%E8%A7%86%E9%A2%91%2F%E7%AC%AC004%E8%AF%BE_vi%E&quot;&gt;视频教程&lt;/a&gt;。你只需要掌握几个简单的操作，例如如何新建文件，如何输入并保存文件即可。&lt;/p&gt;&lt;p&gt;在你学会使用vi后，请新建一个名为led_on.s的文件，它的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.text
.global _start
_start:
    LDR R0,=0x56000010
    MOV R1,#0x00015400
    STR R1,[R0]

    LDR R0,=0x56000014
    MOV R1,#0x000000C0
    STR R1,[R0]
MAIN_LOOP:
    B   MAIN_LOOP&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上汇编代码主要做了两件事：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;将位于0x56000010地址的GPBCON寄存器的内容写为0x00015400,什么意思呢？GPBCON寄存器是用来配置GPB的控制寄存器，通过它，可以分别指定GPB上每一位的功能——是作为输入引脚，或是作为输出引脚，抑或是其它的功能。&lt;p&gt;通过查看Mini2440的原理图，我们可以看到，开发板上的4个led分别连接到了CPU(S3C2440)的GPB5/GPB6/GPB7和GPB8。&lt;/p&gt;&lt;p&gt;所以，我们需要在GPBCON寄存器上，需要将GPB5/6/7/8配置为输出功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;将位于0x56000014地址的GPBDAT寄存器的内容写为0x000000C0。GPBDAT寄存器是用来控制各个引脚上的电平的，是高电平1还是低电平0.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你仍然有些疑惑，那你可以看看这个&lt;a href=&quot;https://www.bilibili.com/video/av15503339/?p=10&quot;&gt;视频教程&lt;/a&gt;的前半小时的内容。当然，对于这段代码的内容不太理解也没有关系，知道它大致做了些什么事情就可以啦！&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过vim输入makefile&quot;&gt;2.2 通过vim输入Makefile&lt;/h4&gt;
&lt;p&gt;使用vi新建一个名为Makefile的文件，它的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;led_on.bin:led_on.s
    arm-linux-gcc -g -c -o led_on.o led_on.s
    arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf
    arm-linux-objcopy -O binary -S led_on_elf led_on.bin
clean:
    rm -f led_on.bin led_on_elf *.o&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样地，前面的视频教程也有对这个Makefile文件的讲解。&lt;/p&gt;
&lt;h4 id=&quot;生成可执行文件led_on.bin&quot;&gt;2.3 生成可执行文件led_on.bin&lt;/h4&gt;
&lt;p&gt;在Ubuntu中打开终端，cd至led_on.s和Makefile所在的目录，执行以下命令，生成led_on.bin。&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们已经生成了将要下载到Mini2440开发板中的led_on.bin文件。&lt;/p&gt;
&lt;h3 id=&quot;mini2440的启动模式&quot;&gt;3 Mini2440的启动模式&lt;/h3&gt;
&lt;p&gt;Mini2440有两种启动模式，分别是从Nand Flash启动和从Nor Flash 启动，两种启动模式通过开关S2控制。&lt;/p&gt;&lt;p&gt;在 NAND Flash 启动模式下，上电之后，Nand Flash 最前面的4K 空间的内容会被拷贝至S3C2440 （Mini2440开发板上的主芯片）中的片内SRAM中，接着从SRAM的0地址处开始执行。&lt;/p&gt;&lt;p&gt;在 Nor Flash 启动模式下(非 Nand Flash 启动模式)，Nor Flash 起始处就被映射为 0地址，接着从Nor Flash的0地址处开始执行。&lt;/p&gt;&lt;p&gt;在本文中，我们将使用Nor Flash模式启动，通过烧录至Nor Flash的Supervivi，将2.3生成的led_on.bin烧录至SDRAM处执行。&lt;/p&gt;&lt;p&gt;SDRAM 地址空间： 0x30000000 ~ 0x34000000&lt;/p&gt;
&lt;h3 id=&quot;烧录supervivi至nor-flash&quot;&gt;4 烧录supervivi至Nor Flash&lt;/h3&gt;
&lt;h4 id=&quot;判断nor-flash中是否已经烧录supervivi&quot;&gt;4.1 判断Nor Flash中是否已经烧录supervivi&lt;/h4&gt;
&lt;p&gt;使用直连串口线连接Mini2440开发板的串口 0 和 PC 机的串口，在Windows上打开并设置好串口助手（115200，8N1），将Mini2440上的开关S2拨至Nor Flash启动模式，然后将开发板上电，如果串口助手上没有打印出以下内容，则需要根据4.2及其以后的步骤烧录supervivi至Nor Flash.&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220656026-875972802.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过jlink将supervivi烧录至nor-flash&quot;&gt;4.2通过JLink将supervivi烧录至Nor Flash&lt;/h4&gt;
&lt;h5 id=&quot;按照下图连接好jlink&quot;&gt;4.2.1 按照下图连接好Jlink&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220646647-581211518.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;安装jflash配合jlink使用&quot;&gt;4.2.2 安装JFlash（配合JLink使用）&lt;/h5&gt;
&lt;p&gt;在Mini2440光盘里可以找到安装文件&lt;/p&gt;
&lt;h5 id=&quot;通过jflash烧录supervivi至nor-flash&quot;&gt;4.2.3 通过JFlash烧录supervivi至Nor Flash&lt;/h5&gt;
&lt;p&gt;打开JFlash，依次打开Options-&amp;gt;Project settings…,按照下图配置。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220607147-1683079900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过File-&amp;gt;Open data file…导入supervivi-64M.bin（注意区分应该选64M还是128M的，我的Mini2440上的Nand Flash是64M的）,地址填写0，表示bin文件将烧录至Nor Flash的0地址处。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220557596-1006459622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依次选择Target-&amp;gt;Auto，等待烧录完成。&lt;/p&gt;
&lt;h5 id=&quot;在windows上安装dnw&quot;&gt;4.2.4 在Windows上安装dnw&lt;/h5&gt;
&lt;p&gt;参照&lt;a href=&quot;http://112.124.9.243/arm9net/mini2440/mini2440um-20110421.zip&quot;&gt;Mini2440用户手册&lt;/a&gt;的2.2.3节安装dnw&lt;/p&gt;
&lt;h5 id=&quot;烧录led_on.bin至sdram并执行&quot;&gt;4.2.5 烧录led_on.bin至SDRAM并执行&lt;/h5&gt;
&lt;h6 id=&quot;打开dnw依次选择configuration在download-address处填写0x32000000表示接下来的supervivi将被烧录至0x32000000即sdram处&quot;&gt;4.2.5.1 打开dnw,依次选择Configuration,在Download Address处填写0x32000000,表示接下来的supervivi将被烧录至0x32000000,即SDRAM处。&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220539367-236118888.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;开发板上电串口助手将打印以下信息输入d&quot;&gt;4.2.5.2 开发板上电，串口助手将打印以下信息，输入d&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220148782-1633869977.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;在dnw中依次选择usb-port-transmitrestore在弹出的窗口中选择led_on.bin等待下载完成&quot;&gt;4.2.5.3 在dnw中依次选择USB Port-&amp;gt;Transmit/Restore,在弹出的窗口中选择led_on.bin，等待下载完成。&lt;/h6&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715215957021-1528692313.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715220431553-1203545788.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;观察开发板上的led&quot;&gt;4.2.5.4 观察开发板上的LED。&lt;/h6&gt;
&lt;p&gt;4个Led中，Led1和Led4应该是被点亮，而Led2和Led3则是熄灭的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;至此，总算是把Led给点亮了，虽然整个过程有一些繁琐，但是并没有多大的难度，主要是涉及到比较多的工具软件，如果有哪个步骤卡住了，你可以先尝试在网络上搜索一下，如果自己无法解决，欢迎留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/508474/201807/508474-20180715231526345-1133554053.png&quot; width=&quot;205&quot; hegiht=&quot;205&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你看了这篇文章，觉得有一点点收获，那就给点打赏，给我更大的写作动力吧。&lt;/p&gt;
</description>
<pubDate>Sun, 15 Jul 2018 15:25:00 +0000</pubDate>
<dc:creator>icuic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/outs/p/9315162.html</dc:identifier>
</item>
</channel>
</rss>