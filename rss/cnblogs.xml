<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[Zephyr] 1、在linux上安装Zephyr-OS并跑DEMO - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9644346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9644346.html</guid>
<description>&lt;p&gt;星期五, 14. 九月 2018 02:18上午 - BEAUTIFULZZZZ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;0) 前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zephyr™项目是一个采用Apache 2.0协议许可，Linux基金会托管的协作项目。为所有资源受限设备，构建了针对低功耗、小型内存微处理器设备而进行优化的物联网嵌入式小型、可扩展的实时操作系统（RTOS），支持多种硬件架构及多种开发板，可以在小至8 kB内存的系统上运行。&lt;/p&gt;
&lt;p&gt;采用深入的安全开发生命周期：安全验证，模糊和渗透测试，频繁的代码审查，静态代码分析，威胁建模和审查，以防止代码中的后门 。&lt;/p&gt;
&lt;p&gt;支持Bluetooth, Bluetooth Low Energy, Wi-Fi, 802.15.4，6Lowpan, CoAP, IPv4, IPv6, 和 NFC 等标准，通过社区驱动的发展来改进和增强功能 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180914/Zephyr_BD.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里作为入门篇，将介绍在linux上安装Zephyr，并基于模拟器和实体开发板进行DEMO编译运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）下载、克隆到本地&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将zephyr克隆到本地home目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ~
git clone git@github.com:zephyrproject-rtos/zephyr.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2) Zephyr Build系统简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zephyr工程使用CMake作为管理工程开发的工具。CMake能够生成不同格式的build文件，当前Zephyr支持下面两种构建管理工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;make: UNIX-Like平台&lt;/li&gt;
&lt;li&gt;ninja: 全平台支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zephyr工程的大多数DEMO采用ninja作为build工具，但是make也是能做所有类似工作的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) 设置开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zephyr可以在Windows\MAC\Linux上开发，这里仅介绍在linux上的设置：&lt;/p&gt;
&lt;ul readability=&quot;15&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;update下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo apt-get update
  sudo apt-get upgrade&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo apt-get install --no-install-recommends git cmake ninja-build gperf \
    ccache doxygen dfu-util device-tree-compiler \
    python3-ply python3-pip python3-setuptools python3-wheel xz-utils file \
    make gcc-multilib autoconf automake libtool librsvg2-bin \
    texlive-latex-base texlive-latex-extra latexmk texlive-fonts-recommended&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装开发Zephyr所需要的附加包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  cd ~/zephyr  # or to your directory where zephyr is cloned
  pip3 install --user -r scripts/requirements.txt&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;安装3.8.2版本及以上的CMake：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  mkdir $HOME/cmake &amp;amp;&amp;amp; cd $HOME/cmake
  wget https://cmake.org/files/v3.8/cmake-3.8.2-Linux-x86_64.sh
  yes | sh cmake-3.8.2-Linux-x86_64.sh | cat
  echo &quot;export PATH=$PWD/cmake-3.8.2-Linux-x86_64/bin:\$PATH&quot; &amp;gt;&amp;gt; $HOME/.zephyrrc
  source &amp;lt;zephyr git clone location&amp;gt;/zephyr-env.sh
  cmake --version&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;安装Zephyr Software Development Kit（SDK）：&lt;/p&gt;
&lt;p&gt;Zephyr的SDK包含所有必须的工具和交叉编译器，用于支持build内核在不同的系统架构上。除此之外，它包括主机工具，如自定义QEMU二进制文件和主机编译器，如果需要的话，可以构建宿主工具。&lt;/p&gt;
&lt;p&gt;SDK支持以下架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;X86&lt;/li&gt;
&lt;li&gt;X86 IAMCU ABI&lt;/li&gt;
&lt;li&gt;ARM&lt;/li&gt;
&lt;li&gt;ARC&lt;/li&gt;
&lt;li&gt;Nios II&lt;/li&gt;
&lt;li&gt;Xtensa&lt;/li&gt;
&lt;li&gt;RISC-V&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照以下步骤在Linux主机系统上安装SDK：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  cd ~/Downloads/
  wget https://github.com/zephyrproject-rtos/meta-zephyr-sdk/releases/download/0.9.3/zephyr-sdk-0.9.3-setup.run
  sh zephyr-sdk-0.9.3-setup.run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;按照屏幕上的安装说明，工具链默认安装在&lt;code&gt;/opt/zephyr-sdk/&lt;/code&gt;，但是建议在主目录下安装，这里我安装在&lt;code&gt;~/zephyr-sdk&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置全局变量&lt;code&gt;vim ~/.zephyrrc&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  export ZEPHYR_TOOLCHAIN_VARIANT=zephyr
  export ZEPHYR_SDK_INSTALL_DIR=/home/btfz/zephyr-sdk&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4) 在QEMU中运行一个示例应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了直接在开发环境中快速测试，QEMU是一个很好的选择，通过配置其可以支持X86 and ARM Cortex-M3架构。&lt;/p&gt;
&lt;p&gt;用X86模拟板级配置(qemu_x86)运行一个程序，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd $ZEPHYR_BASE/samples/hello_world
mkdir build &amp;amp;&amp;amp; cd build

# Use cmake to configure a Ninja-based build system:
cmake -GNinja -DBOARD=qemu_x86 ..

# Now run ninja on the generated build system:
ninja
ninja run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;退出qemu模拟器：ctrl-a，然后按x&lt;br/&gt;可见QEMU并不是支持所有板子，有些时候需要拿真实板子来开发！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5) 在nRF51822-QFAA-PCA10028开发板上运行DEMOM&lt;sup&gt;(&lt;a href=&quot;https://docs.zephyrproject.org/latest/boards/arm/nrf51_pca10028/doc/nrf51_pca10028.html&quot;&gt;#2&lt;/a&gt;)&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里首先测试的是Hello World：&lt;br/&gt;第0步：设置编译环境：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd zephyr
source zephyr-env.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步：用minicom连接串口，一会用来打印数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;minicom -D &amp;lt;tty_device&amp;gt; -b 115200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：编译和烧写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd $ZEPHYR_BASE/samples/hello_world
mkdir build &amp;amp;&amp;amp; cd build

# Use cmake to configure a Ninja-based build system:
cmake -GNinja -DBOARD=nrf51_pca10028 ..

# Now run ninja on the generated build system:
ninja
ninja flash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 有的时候会报：&lt;code&gt;ERROR: ld.so: object 'libgtk3-nocsd.so.0' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.&lt;/code&gt;的错误(cmake时)，和&lt;code&gt;fatal error: 2 No such file or directory: 'nrfjprog'&lt;/code&gt;的错误(flash时)，解决办法是在~/.zephyrc中添加环境变量，并重新source下环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  hello_world git:(master) cat ~/.zephyrrc 
export PATH=/home/btfz/cmake/cmake-3.8.2-Linux-x86_64/bin:$PATH
export ZEPHYR_TOOLCHAIN_VARIANT=zephyr
export ZEPHYR_SDK_INSTALL_DIR=/home/btfz/zephyr-sdk

export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0
export PATH=$PATH:/home/btfz/Downloads/AAAA/nRF5x-Command-Line-Tools_9_7_3/nrfjprog&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用同样的方法也可以测试nrf51_pca10028板子的下面两个DEMO：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;samples/basic/blinky&lt;/li&gt;
&lt;li&gt;samples/basic/button&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;6) 分析一个简单应用层代码，带你更深入一步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和5一样的nRF51开发板，不仅支持闪灯和按键工程，还支持很多骚操作。我们就拿最简单的beacon分析下吧（毕竟作为玩蓝牙的，所有的文章都得点一下题吧，哈哈）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;samples/bluetooth/beacon&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/* main.c - Application main entry point */

/*
 * Copyright (c) 2015-2016 Intel Corporation
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include &amp;lt;zephyr/types.h&amp;gt;
#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;misc/printk.h&amp;gt;
#include &amp;lt;misc/util.h&amp;gt;

#include &amp;lt;bluetooth/bluetooth.h&amp;gt;
#include &amp;lt;bluetooth/hci.h&amp;gt;

#define DEVICE_NAME CONFIG_BT_DEVICE_NAME
#define DEVICE_NAME_LEN (sizeof(DEVICE_NAME) - 1)

/*
 * Set Advertisement data. Based on the Eddystone specification:
 * https://github.com/google/eddystone/blob/master/protocol-specification.md
 * https://github.com/google/eddystone/tree/master/eddystone-url
 */
static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_NO_BREDR),
    BT_DATA_BYTES(BT_DATA_UUID16_ALL, 0xaa, 0xfe),
    BT_DATA_BYTES(BT_DATA_SVC_DATA16,
              0xaa, 0xfe, /* Eddystone UUID */
              0x10, /* Eddystone-URL frame type */
              0x00, /* Calibrated Tx power at 0m */
              0x00, /* URL Scheme Prefix http://www. */
              'z', 'e', 'p', 'h', 'y', 'r',
              'p', 'r', 'o', 'j', 'e', 'c', 't',
              0x08) /* .org */
};

/* Set Scan Response data */
static const struct bt_data sd[] = {
    BT_DATA(BT_DATA_NAME_COMPLETE, DEVICE_NAME, DEVICE_NAME_LEN),
};

static void bt_ready(int err)
{
    if (err) {
        printk(&quot;Bluetooth init failed (err %d)\n&quot;, err);
        return;
    }

    printk(&quot;Bluetooth initialized\n&quot;);

    /* Start advertising */
    err = bt_le_adv_start(BT_LE_ADV_NCONN, ad, ARRAY_SIZE(ad),
                  sd, ARRAY_SIZE(sd));
    if (err) {
        printk(&quot;Advertising failed to start (err %d)\n&quot;, err);
        return;
    }

    printk(&quot;Beacon started\n&quot;);
}

void main(void)
{
    int err;

    printk(&quot;Starting Beacon Demo\n&quot;);

    /* Initialize the Bluetooth Subsystem */
    err = bt_enable(bt_ready);
    if (err) {
        printk(&quot;Bluetooth init failed (err %d)\n&quot;, err);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最&lt;strong&gt;核心&lt;/strong&gt;的就是bt_le_adv_start(BT_LE_ADV_NCONN, ad, ARRAY_SIZE(ad),sd, ARRAY_SIZE(sd))函数，启动一个ble广播，其&lt;strong&gt;广播数据&lt;/strong&gt;为static const struct bt_data ad[] 定义的数据。在nRF connect APP中可以搜索到该beacon信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180914/nrf_connect_beacon2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在搜索列表里会发现有个叫Eddystone的蓝牙设备，其&lt;strong&gt;广播的数据&lt;/strong&gt;为zephyr的主页网址～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间不早了&lt;/strong&gt;，其他更好玩的东西会在今后的文章中介绍～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.zephyrproject.org/latest/getting_started/getting_started.html#building-and-running-an-application&quot;&gt;[1].getting started.&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.zephyrproject.org/latest/boards/arm/nrf51_pca10028/doc/nrf51_pca10028.html&quot;&gt;[2].nrf51_pca10028 doc&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/PCMan/gtk3-nocsd/issues/13&quot;&gt;[3].ERROR: ld.so: object 'libgtk3-nocsd.so.0' from LD_PRELOAD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 13 Sep 2018 18:21:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>星期五, 14. 九月 2018 02:18上午 BEAUTIFULZZZZ ![][ bar] 0) 前言 Zephyr™项目是一个采用Apache 2.0协议许可，Linux基金会托管的协作项目。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9644346.html</dc:identifier>
</item>
<item>
<title>【译】Optaplanner开发手册本地化: (0) - 前言及概念 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/9393637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/9393637.html</guid>
<description>&lt;p&gt;　　在此之前，针对APS写了一些理论性的文章；而对于Optaplanner也写了一些介绍性质，几少量入门级的帮助初学者走近Optaplanner。在此以后，老农将会按照Optaplanner官方的用户手册的结构，按章节地对其进行翻译，并成型一系列的操作说明文章。在文章中，为了降低对原文的理解难度，有些地方我不会直接按原文档的字面翻译，而是有可能加入一些我自己的理解，或添一些解释性的内容。毕竟英语环境下的思维和语言表达方式，跟中文或多或少会有差别的，所以如果全部按字面翻译，内容就非常生硬，可读性差，解程难度较大。我认为应该在理解了作者原意的基础上，再进一步以中文方式的表达，才算是真的的本地化。记得老农还是少农时，学习开发技术，需要阅读一些外国书箱的翻译本时，印象最深的是候捷老师的书，尽管《深入浅出MFC》，砖头厚度的书，硬是被我翻散了线，MFC尽管真的晦涩难懂，但候老却能把Windows的消息机制及MFC中整个个宏体系，系统地通俗地描述出来，令读者不需要花费太多精力去理解猜测书中字面的意义，大大降低的VC++中MFC的学习门槛。但老农毕竟只是一个一线开发人员，不是专业的技术资料翻译人才，不可能有候老师的专业水平，因此，我也只可尽我所能把内容尽量描述得通俗一些，让读者尽量容易理解，花费更少的时间掌握这些知道要点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;本文以Optaplanner 7.10.0 Final版本的开发手册作为基础进行翻译。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1.1. 什么是Optaplanner?&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 　　每个组织都需要面对规划、排程问题：在有限的资源约束下提供服务与产品（例如人员，资产，时间及资本等限制）。Optaplanner可以优化这类规划、排程问题，令到使用它的组织可以用更少的资源做更多的事（尽可能的花少钱办大事）。这就是著名的的约束满足规划，它属于运筹学的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.optaplanner.org/&quot; target=&quot;_blank&quot;&gt;Optaplanner&lt;/a&gt;是一个轻量的、可嵌入的，可以对规划问题进行优化的约束满足引擎，它可以解决案例有：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;员工排班&lt;/strong&gt;：为护士、维修工等人员制定上班时间表。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方程安排&lt;/strong&gt;：安排会议、约见、维修工作、广告时间等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;教育领域的时间安排&lt;/strong&gt;：安排课程、课堂、考试、会议讲座等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规划车辆运动路线&lt;/strong&gt;：通过已知的地图工具，为货运、客运（货车、火车、轮船、航班等）规划交通工具多目标的运行路线。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装箱问题&lt;/strong&gt;：向容器、货车、轮船和仓库装载货物，同时可以规划电脑的资源加载利用，例如云计算的资源分配问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;车间生产安排&lt;/strong&gt;：规划汽车组装生产线，机器队规划，劳动任务的规则等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下料问题&lt;/strong&gt;：在下料分割的时候，实量最小的浪费，例如切割纸张、钢铁、地毯等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运动赛事安排&lt;/strong&gt;：规划比赛和训练，例如安排足球联赛、棒球联赛等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;金融优化&lt;/strong&gt;：投资组合优化、实现风险分散等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201809/148283-20180912011351656-1406952997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2. 什么是规划问题？&lt;/h2&gt;
&lt;h3 id=&quot;whatIsAPlanningProblem&quot;&gt;&lt;a class=&quot;link&quot; href=&quot;https://docs.optaplanner.org/7.10.0.Final/optaplanner-docs/html_single/index.html#whatIsAPlanningProblem&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201809/148283-20180912011536982-315588481.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;　一个规划问题，基于有限的资源和指定的约束，有一个优化目标。优化目标可以是多种事物，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利润最大化 - 优化目标得出的结果是尽可以高的利润。&lt;/li&gt;
&lt;li&gt;最小化生态足迹（即尽可能减少对生态的影响） - 优化目标是对环境产生尽可能小的影响。&lt;/li&gt;
&lt;li&gt;最大化员工或客户的满足度 - 优化目标重视员工与客户的需要。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现这些目标的能力依赖于可用资料的数量，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;人员数量&lt;/li&gt;
&lt;li&gt;时间&lt;/li&gt;
&lt;li&gt;预算&lt;/li&gt;
&lt;li&gt;特殊资产，例如机台，车辆，计算机，建筑物等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与这此资源相关的约束也必然计算在内，例如，一个人的工作小时数， 他们可使用（操作）的机台数量，设备之间的兼容性等。&lt;/p&gt;
&lt;p&gt;Optaplanner可以帮助Java程序员有效地解决约束满足问题， 在Optaplanner引擎中，对每个有效的约束分数计算中，组合了启发式和元启发式算法。 &lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt; 1.2.1 规划问题属于NP-Complete问题或NP-hard问题&lt;/h3&gt;
&lt;p&gt;　　上述所有的案例或许都属于&lt;a href=&quot;https://en.wikipedia.org/wiki/NP-completeness&quot; target=&quot;_blank&quot;&gt;NP-complete/NP-hard问题&lt;/a&gt;，（什么是NP-Complete/NP-hard问题呢？），在外行人看来，它的定义是：&lt;/p&gt;
&lt;p&gt;　　对于一个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在合理时间内可以容易地验证一个给定的解。&lt;/li&gt;
&lt;li&gt;在合理时间内，目前尚没有行之有效的解法，能找到其绝对最优解(注1)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　(注1)：至少，到目前为止，仍未有一个世界上最聪明的计算机科学家能找到此方法。可是一旦他们找到对其中一个NP-Complete问题的有效解法，那么这个方法对所有NP-Complete问题都是可行办法。事实上，如果任何人只需证明是&lt;a href=&quot;https://en.wikipedia.org/wiki/P_%3D_NP_problem&quot; target=&quot;_blank&quot;&gt;这种解法的存在与否&lt;/a&gt;，即可获得100万美元的奖励。&lt;/p&gt;
&lt;p&gt;　　其实这其含义是相当悲观的：要解决这些问题或许比你预想中更困难，因为目前针对这种问题的常见两种技术是未足够解决此类问题的。这两种方法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;暴力算法(尽管是一些优化过，相对聪明的暴力算法变种), 但获得其解所需的时间非常长(译者：主要原因是时间复杂度非常高)。&lt;/li&gt;
&lt;li&gt;快速算法，例如在Bin packing问题中，先装入最大项；但得到的解离绝对最优解仍存在相当大距离的。&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;aPlanningProblemIsNPCompleteOrNPHard&quot;&gt;通过使用一些更高级的算法，Optaplanner可以在合理的时间内，对这些规划问题找到相对较优解。&lt;/p&gt;

&lt;h3&gt; 1.2.2 规划问题存在约束（包括硬约束与软件约束)&lt;/h3&gt;
&lt;p&gt;　　通常来说，一个规划问题至少包括两个层次的约束：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(负面)硬约束，不可被违反。例如：一个教师在同节的时间内不能同时上两门课。&lt;/li&gt;
&lt;li&gt;(负面)软件约束，若可避免，它不应该被违反。例如：教师都不太喜欢在周五下午上课。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　也有些问题存在一些正面的约束：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正面分数在可能情况下应该实现。例如：教师B喜欢在周一上午上果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　一些比较基础的规划问题(例如&lt;a target=&quot;_blank&quot;&gt;8王后问题&lt;/a&gt;)，只存在硬约束；有一些规划问题则存在超3层，甚至更多层次的约束。例如：硬约束，中间约束和软约束。&lt;/p&gt;
&lt;p&gt;　　这些约束会被定义在规划问题的Score calculation里(也称为适应度函数)里。规划问题里的每一个解的优劣，都可以通过分数来评价。在Optaplanner中，分数约束是通过面向对象语文编写的，例如Java代码或通过Drools脚本实现的rules. 这些代码相当容易编写，灵活且易于扩展。&lt;/p&gt;
&lt;h3&gt; 1.2.3 规划问题存在巨大的搜索空间&lt;/h3&gt;
&lt;p&gt;　　一个规划问题存在非常多的解，这些解可以分为以下数种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可能解&lt;/strong&gt;：规划问题的任意一个解都称作可能解，无论这个解是否违反了约束，或违反了多少约束。规划问题往往存在令人难以至今的巨量可能解，这里面很多解是毫无价值的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可行解&lt;/strong&gt;：规划问题的可行解是指没有违反任何（负面）硬约束的解。一个规划问题的可行解的数量，与其可能解相关。有时也不存在可行解，一个规划问题的每一个可行解，都是该问题的一个可能解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绝对最优解&lt;/strong&gt;:绝对最优解是这个规则问题获得约束分最高的那个解。规划问题通常只有1个或少量数个绝对最优解。通常存在至少1个绝对最优解，尽管当这个规划问题不存在可行解，它也存在绝对最优解，这时候绝对最优解就是非可行解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对最优解&lt;/strong&gt;:相对最优解是指规划问题在一定的求解时间内得到评分最高的解。相对最优解通常是可行解，只要有足够的运行时间，找到的相对最优解就是绝对最优。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　此外，尽管基于一个较小的数据集描述的一个规划问题，其可能解的数量通常是非常巨大的（如果计算正确的话）。正如你从示例中可以看到，大多数情况下，一个规划问题的可能解数量，对目前已知宇宙的原子数量还要多(10的80次方)。因为目前还没有直接的办法找出规划问题的绝对最优解，一些求解实现方法是通过暴力穷举的方法，至少可以穷举所有可能解中的一个子集。&lt;/p&gt;
&lt;p&gt;　　OptaPlanner支持多种优化算法，以有效地涉足大量可能解，根据不同使用场景的情况，一些优化算法的性能比其它算法更佳，但哪个更佳是无法预先告知的（译者：需要通过Benchmark等功能测定）。在Optaplanner里，很容易能过修改几行XML内容或Java code，来更改求解器的配置，从而切换不同的优化算法。&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;【未完，待续...】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原创不易，如果觉得文章对你有帮助，欢迎点赞、评论。&lt;/strong&gt;文章有疏漏之处，欢迎批评指正。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，转载请注明原文链接：http://www.cnblogs.com/kentzhang/p/8709679.html&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果大家有何建议，欢迎大家加我企鹅一起探讨：12977379或V信：13631823503。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实 Optaplanner规划引擎不需要对Java过份精通即可使用,因为它使用到的都是Java最基本的知道，但还是需要有基本的Java知识才行，希望大家找我研究讨论时，如果Java, Maven等方面仍接触较少，请大家先行自补该方面的知识，本猿暂时只能跟大家探讨Optaplanner, Drools的应用，而Java相关的知识，恕无法提供有效的帮助，毕竟本猿也只是个Java新手。先谢了。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 13 Sep 2018 18:07:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>在此之前，针对APS写了一些理论性的文章；而对于Optaplanner也写了一些介绍性质，几少量入门级的帮助初学者走近Optaplanner。在此以后，老农将会按照Optaplanner官方的用户手册</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/9393637.html</dc:identifier>
</item>
<item>
<title>Redis源码阅读（四）集群-请求分配 - gogo一</title>
<link>http://www.cnblogs.com/gogoCome/p/9644271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoCome/p/9644271.html</guid>
<description>&lt;p&gt;    集群搭建好之后，用户发送的命令请求可以被分配到不同的节点去处理。那Redis对命令请求分配的依据是什么？如果节点数量有变动，命令又是如何重新分配的，重分配的过程是否会阻塞对外提供的服务？接下来会从这两个问题入手，分析Redis3.0的源码实现。&lt;/p&gt;
&lt;h3&gt;1. 分配依据——&lt;strong&gt;槽&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;　　Redis将每个客户端的请求命令通过哈希的方式映射到槽上，映射方法就是对该客户端请求中的键值求CRC16校验值，求得的值再和16383（0x3FFF）进行与操作，得到的结果即为槽值；Redis集群默认设置了16384个slot槽，集群的节点接管了哪些槽就会存储相对应的数据库键值对，每个节点可以接管的槽数量为[0, 16384]。客户端的命令发送到Redis集群的任意节点都会先根据该命令所要操作的key来计算其对应的槽。如果该槽是由接收命令的节点接管，则该节点可直接处理该命令并返回客户端结果，如果槽是由其他节点接管则会返回给客户端MOVED错误，并准备转向正确的节点进行处理。这就是Redis集群分配命令的基本原理。（备注：如果客户端的请求中不带有key，则该命令不会对Redis存储的数据进行操作，只是获取服务状态的命令，无需分配到其他节点）&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 槽初始分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对槽的初始分配是通过cluster addslots命令实现的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Cluster addslots &amp;lt;slot&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　各个节点是怎么知道每个槽分配给了哪个节点呢？上篇文章中介绍过每个集群节点都有一个clusterState结构体来记录集群的总体信息，可以看到在该结构体中有一个成员记录了每个槽指派给了哪个节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; clusterState {
　　...
　　clusterNode &lt;/span&gt;*&lt;span&gt;slots[REDIS_CLUSTER_SLOTS];
　　...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　槽i分配的Node节点就是slots[i]的值，查找出命令应该分配给哪个节点的时间复杂度是O(1)。我们看下cluster addslots命令的具体实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; clusterCommand(redisClient *&lt;span&gt;c) {
　　......
　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((!strcasecmp(c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ||
               !strcasecmp(c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &amp;amp;&amp;amp; c-&amp;gt;argc &amp;gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; CLUSTER ADDSLOTS &amp;lt;slot&amp;gt; [slot] ... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将一个或多个 slot 添加到当前节点     &lt;/span&gt;
         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; CLUSTER DELSLOTS &amp;lt;slot&amp;gt; [slot] ... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;      
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从当前节点中删除一个或多个 slot              &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j, slot;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个数组，记录所有要添加或者删除的槽&lt;/span&gt;
        unsigned &lt;span&gt;char&lt;/span&gt; *slots =&lt;span&gt; zmalloc(REDIS_CLUSTER_SLOTS);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查这是 delslots 还是 addslots&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; del = !strcasecmp(c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delslots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 slots 数组的所有值设置为 0&lt;/span&gt;
        memset(slots,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,REDIS_CLUSTER_SLOTS);
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理所有输入 slot 参数&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;2&lt;/span&gt;; j &amp;lt; c-&amp;gt;argc; j++&lt;span&gt;) {

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 slot 数字&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((slot = getSlotOrReply(c,c-&amp;gt;argv[j])) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                zfree(slots);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果这是 delslots 命令，并且指定槽为未指定，那么返回一个错误&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (del &amp;amp;&amp;amp; server.cluster-&amp;gt;slots[slot] ==&lt;span&gt; NULL) {
                addReplyErrorFormat(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Slot %d is already unassigned&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, slot);
                zfree(slots);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果这是 addslots 命令，并且槽已经有节点在负责，那么返回一个错误&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!del &amp;amp;&amp;amp; server.cluster-&amp;gt;&lt;span&gt;slots[slot]) {
                addReplyErrorFormat(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Slot %d is already busy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, slot);
                zfree(slots);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果某个槽指定了一次以上，那么返回一个错误&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (slots[slot]++ == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                addReplyErrorFormat(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Slot %d specified multiple times&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)slot);
                zfree(slots);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理所有输入 slot&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; REDIS_CLUSTER_SLOTS; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (slots[j]) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; retval;

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If this slot was set as importing we can clear this 
                 * state as now we are the real owner of the slot. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果指定 slot 之前的状态为载入状态，那么现在可以清除这一状态          
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为当前节点现在已经是 slot 的负责人了&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;&lt;span&gt;importing_slots_from[j])
                    server.cluster&lt;/span&gt;-&amp;gt;importing_slots_from[j] =&lt;span&gt; NULL;

                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加或者删除指定 slot&lt;/span&gt;
                retval = del ?&lt;span&gt; clusterDelSlot(j) :
                               clusterAddSlot(myself,j);
                redisAssertWithInfo(c,NULL,retval &lt;/span&gt;==&lt;span&gt; REDIS_OK);
            }
        }
        zfree(slots);
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE&lt;/span&gt;|&lt;span&gt;CLUSTER_TODO_SAVE_CONFIG);
        addReply(c,shared.ok);

    }
　　......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码中可以看到在槽初始化的最后阶段还执行了clusterAddSlot函数（如果是删除槽分配信息的命令cluster delslots, 则会执行clusterDelSlot函数），clusterAddSlot函数除了修改clusterState里的slots数组之外，还对clusterNode中的一个slots位图变量进行了修改。clusterNode中的slots位图记录的是该节点负责处理的槽有哪些。如果clusterNode-&amp;gt;slots位图的第i位为1，则表示第i个槽是该节点接管的，为0则表示第i个槽不属于该节点处理范围。注意下两个slots成员的区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　ClusterState中的slots成员是指针数组，记录槽由哪个节点托管&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　ClusterNode中的slots成员是位图，记录各个clusterNode托管了哪些槽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用多个数据结构来记录槽的托管信息，最终目的就是为了让操作更快捷，比如判断命令需要转发到哪个节点时，可直接使用ClusterState.slots查询，时间复杂度是O(1)，当需要判断某个特定的槽是否属于某节点处理则只需到该节点的slots位图中查看即可，时间也是O(1)。当然多个数据结构的弊端是&lt;span&gt;牺牲了一定的空间和初始化效率，但初始化的频率远小于查找槽托管情况的频率，牺牲初始化效率换来高效率的查找是值得的。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 和一致哈希的比较&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    这里简单介绍下一致性哈希，参考并摘录了网上相关博文的内容（&lt;a href=&quot;https://www.cnblogs.com/lpfuture/p/5796398.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lpfuture/p/5796398.html&lt;/a&gt;）。早期的时候，为解决负载均衡分配问题，引入哈希算法来做分配。系统中如果存在N个节点，将节点从0到N-1编号，对请求数据的某个特征做哈希运算后将结果对N取模，取模的值即该请求数据可以被分配的节点号。这种方法可以做到负载均衡，但当节点数发生变化时，请求数据的哈希值需要对新的节点数量取模，这样几乎所有数据被分配的节点号都可能发生变化，也就是所有的请求数据都要面对重新分配节点的问题。&lt;/p&gt;
&lt;p&gt;    针对这一问题，一致性哈希算法诞生了。一致性哈希将整个哈希值空间组织成一个虚拟的圆环，哈希函数H的值空间为0-2^&lt;sup&gt;32&lt;/sup&gt;-1（即哈希值是一个32位无符号整形），整个哈希空间环如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914004415326-1172307547.png&quot; alt=&quot;&quot; width=&quot;235&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　算法的关键是将Node节点本身也做哈希，可以用IP或服务器名称来计算哈希值，将Node映射到哈希环上；环空间是固定的，节点的哈希值通常也是固定的也就是说节点在哈希环上的位置是固定的。数据也会计算哈希后映射到环空间上。数据应该交个哪个节点来处理呢？从数据对应位置开始，顺时针寻找第一个遇到的Node哈希值所对应的节点，该节点就是数据要分配的节点。可以看到如果新增或者删除了节点也不会影响其他节点在环空间的位置，这是保证大多数节点能在节点数量变更的情况下不受影响的关键。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914004542892-350735416.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;296&quot;/&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914004559567-910335835.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 　　这里有两个需要注意的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;要尽量选择不会变化的指标来计算哈希值，避免节点哈希值有变化&lt;/li&gt;
&lt;li&gt;不同节点不能映射到同一个位置上，避免数据无法决定分配到哪个节点上（虽然概率比较小，但还是有节点映射的哈希值相同的可能）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　此外一致性哈希还可能遇到的问题就是几个节点的哈希值分布不均匀，会有大部分的数据被映射的某个或某几个节点上，造成负载偏重问题。一致性哈希的处理方式是给每个节点分配多个虚拟节点，人为增加节点数量，可以让节点的位置更加分散；分配到虚拟节点的数据还需要再多加一步，判断该虚拟节点隶属于哪个实际节点，才能决定该数据是由哪个节点处理。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;　　一致性哈希的优点比较明显，可以比较好的做到负载均衡，而且动态变更节点时对其他节点的影响比较小。数据的分配完全由算法决定，需要配置的内容比较少。但也带来一个问题，就是很难做到手动将特定数据分配给指定机器。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Redis的槽分配方式是可以任意指定的，可以将部分键值对手动的分配到指定的节点，便于根据业务来分配键值，配置方式灵活；而且可以随时对键值对的分配进行调整。同时也可以做到节点数据量变化时，只有局部的节点负责的键值对会受到影响。和一致性哈希比较，缺点则是初始化配置比较麻烦，如果完全通过人工分配槽的归属，工作量比较大且容易出错。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2. 重新分片&lt;/strong&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;Redis集群的重新分片是指可以将原来指派给某个节点的任意数量槽重新指派给新的节点（可以是新加入的节点也可以是集群中其他的节点）。除了槽重新指派外，这些槽原来接管的键值对也会从原来的节点（源节点）转发到新的节点（目标节点）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;重新分片由于要将槽所管理的键值对也同步迁移，耗时是比较长的；在重新分片的过程中，Redis服务并没有中断服务。这是怎么做到的呢？在Redis集群中需要在实际执行迁移前，事先标记好待迁移的槽是要从哪个节点迁移到哪个节点，这样在迁移过程中如果发现键值对已经不再属于原节点，则通过ASK错误可以给出应该去哪个节点找到该键值对。这里要求所有键值对的迁移是原子的，避免用户取到未迁移完全的键值对。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;2.1 重新分片流程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　重新分片是由几个命令共同实现的，简述下单个槽的迁移步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;向目标节点发送Cluster setslot &amp;lt;slot&amp;gt; importing &amp;lt;source_id&amp;gt;，让目标节点准备好从source_id节点接管槽slot [&lt;span&gt;只有目标节点知道键需要迁移&lt;/span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向源节点发送Cluster setslot &amp;lt;slot&amp;gt; migrating &amp;lt;target_id&amp;gt;，让源节点准备向目标节点迁移槽slot  [&lt;span&gt;只有目标节点和源节点都知道键需要迁移&lt;/span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向源节点发送Cluster getkeysinslot &amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;，获取slot槽中最多count个键值对的键名称  [&lt;span&gt;迁移中，会出现Ask错误&lt;/span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将第3步中获取到的所有键值对转发到目的节点上，实现这一目标的话需要在转发每个键值对时向源节点发送Migrate &amp;lt;target_ip&amp;gt; &amp;lt;target_port&amp;gt; &amp;lt;key_name&amp;gt; 0 &amp;lt;timeout&amp;gt;命令[&lt;span&gt;迁移中，会出现Ask错误，每个key的迁移都需要为原子的&lt;/span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;重复3、4两步直到槽下所有键值对都已转移 [&lt;span&gt;迁移中，会出现Ask错误&lt;/span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向源节点发送cluster setslot &amp;lt;slot&amp;gt; stable，取消槽的迁移标记&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向集群中任意节点发送Cluster setslot &amp;lt;slot&amp;gt; node &amp;lt;target_id&amp;gt;，该节点获知槽slot已经转移给target_id对应的节点之后会将该消息通过gossip扩散给集群中所有节点[&lt;span&gt;迁移完成，所有节点更新了槽的托管关系结构体&lt;/span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　我们来看下源码中这几个和槽迁移有关的命令的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; clusterCommand(redisClient *&lt;span&gt;c) {
　　......
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将本节点的槽 slot 迁移至 node id 所指定的节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!strcasecmp(c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;migrating&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; c-&amp;gt;argc == &lt;span&gt;5&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被迁移的槽必须属于本节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;slots[slot] !=&lt;span&gt; myself) {
                addReplyErrorFormat(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm not the owner of hash slot %u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,slot);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迁移的目标节点必须是本节点已知的&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; ((n = clusterLookupNode(c-&amp;gt;argv[&lt;span&gt;4&lt;/span&gt;]-&amp;gt;ptr)) ==&lt;span&gt; NULL) {
                addReplyErrorFormat(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I don't know about node %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*)c-&amp;gt;argv[&lt;span&gt;4&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为槽设置迁移目标节点&lt;/span&gt;
            server.cluster-&amp;gt;migrating_slots_to[slot] =&lt;span&gt; n;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;node id&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从节点 node id 中导入槽 slot 到本节点&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;importing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; c-&amp;gt;argc == &lt;span&gt;5&lt;/span&gt;&lt;span&gt;) {

             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 slot 槽本身已经由本节点处理，那么无须进行导入&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;slots[slot] ==&lt;span&gt; myself) {
                addReplyErrorFormat(c,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I'm already the owner of hash slot %u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,slot);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node id 指定的节点必须是本节点已知的，这样才能从目标节点导入槽&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((n = clusterLookupNode(c-&amp;gt;argv[&lt;span&gt;4&lt;/span&gt;]-&amp;gt;ptr)) ==&lt;span&gt; NULL) {
                addReplyErrorFormat(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I don't know about node %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    (&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*)c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为槽设置导入目标节点&lt;/span&gt;
            server.cluster-&amp;gt;importing_slots_from[slot] =&lt;span&gt; n;

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; c-&amp;gt;argc == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; CLUSTER SETSLOT &amp;lt;SLOT&amp;gt; STABLE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消对槽 slot 的迁移或者导入
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意:在迁移源节点中的某个槽位到目的集群完毕后(包括数据迁移完毕)，需要向源节点发送cluster setslot &amp;lt;slot&amp;gt; stable，通知
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;源redis节点槽位迁移完毕，如果不清理在cluster nodes中会出现迁移过程状态，例如6f4e14557ff3ea0111ef802438bb612043f18480 10.2.4.5:7001 myself,master - 0 0 5 connected 4-5461 [2-&amp;gt;-4f3012ab3fcaf52d21d453219f6575cdf06d2ca6] [3-&amp;gt;-4f3012ab3fcaf52d21d453219f6575cdf06d2ca6]&lt;/span&gt;
            server.cluster-&amp;gt;importing_slots_from[slot] =&lt;span&gt; NULL;
            server.cluster&lt;/span&gt;-&amp;gt;migrating_slots_to[slot] =&lt;span&gt; NULL;

        }
　　......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1）Cluster setslot &amp;lt;slot&amp;gt; importing &amp;lt;source_id&amp;gt; 命令主要就是将importing_slots_from[slot]的值设置为source_id所对应的clusterNode的指针。在clusterState结构体中定义了该成员变量：clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS]; 该数组记录了每个槽要从哪个节点导入进来；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）Cluster setslot &amp;lt;slot&amp;gt; migrating &amp;lt;target_id&amp;gt; 命令主要就是将migrating_slots_to[slot]的值设置为target_id所对应的clusterNode的指针。在clusterState结构体中定义了该成员变量：clusterNode *migrating_slots_from[REDIS_CLUSTER_SLOTS]; 该数组记录了每个槽要迁移到哪个目标节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取slot所包含的key是通过Cluster getkeysinslot &amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;命令实现的，看下代码是如何处理该命令的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; clusterCommand(redisClient *&lt;span&gt;c) {
......

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getkeysinslot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; c-&amp;gt;argc == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; CLUSTER GETKEYSINSLOT &amp;lt;slot&amp;gt; &amp;lt;count&amp;gt; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印 count 个属于 slot 槽的键     &lt;/span&gt;
         &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxkeys, slot;       
         unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numkeys, j;     
         robj &lt;/span&gt;**&lt;span&gt;keys;       
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出 slot 参数     &lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (getLongLongFromObjectOrReply(c,c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;],&amp;amp;slot,NULL) !=&lt;span&gt; REDIS_OK)        
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;       

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出 count 参数     &lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (getLongLongFromObjectOrReply(c,c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;],&amp;amp;&lt;span&gt;maxkeys,NULL)         
            &lt;/span&gt;!=&lt;span&gt; REDIS_OK)           
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;        

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查参数的合法性&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (slot &amp;lt; &lt;span&gt;0&lt;/span&gt; || slot &amp;gt;= REDIS_CLUSTER_SLOTS || maxkeys &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            addReplyError(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid slot or number of keys&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配一个保存键的数组      &lt;/span&gt;
         keys = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(robj*)*&lt;span&gt;maxkeys);     
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将键记录到 keys 数组    &lt;/span&gt;
         numkeys =&lt;span&gt; getKeysInSlot(slot, keys, maxkeys);    

         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印获得的键&lt;/span&gt;
&lt;span&gt;        addReplyMultiBulkLen(c,numkeys);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; numkeys; j++&lt;span&gt;) addReplyBulk(c,keys[j]);
        zfree(keys);

}
......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录 count 个属于 hashslot 槽的键到 keys 数组
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并返回被记录键的数量&lt;/span&gt;
unsigned &lt;span&gt;int&lt;/span&gt; getKeysInSlot(unsigned &lt;span&gt;int&lt;/span&gt; hashslot, robj **keys, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
    zskiplistNode &lt;/span&gt;*&lt;span&gt;n;
    zrangespec range;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    range.min &lt;/span&gt;= range.max =&lt;span&gt; hashslot;
    range.minex &lt;/span&gt;= range.maxex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定位到第一个属于指定 slot 的键上面&lt;/span&gt;
    n = zslFirstInRange(server.cluster-&amp;gt;slots_to_keys, &amp;amp;&lt;span&gt;range);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历跳跃表，并保存属于指定 slot 的键
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; n &amp;amp;&amp;amp; n-&amp;gt;score 检查当前键是否属于指定 slot
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;amp;&amp;amp; count-- 用来计数&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(n &amp;amp;&amp;amp; n-&amp;gt;score == hashslot &amp;amp;&amp;amp; count--&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录键&lt;/span&gt;
        keys[j++] = n-&amp;gt;&lt;span&gt;obj;
        n &lt;/span&gt;= n-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; j;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;代码中&lt;/span&gt;&lt;/span&gt;&lt;span&gt;server.cluster-&amp;gt;slots_to_keys就是存储key和槽对应关系的数据结构，该数据结构是通常比较少见的跳跃表，该数据结构是一个多层链表，可以加速有序数据的查找，期望时间可以达到O(log n)。跳跃表实现起来要比平衡二叉树简单的多，且查找节点、插入/删除节点的操作也不需要做过多调整。这里简单介绍下跳跃表这个数据结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;跳跃表：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;跳跃表简单来说就是多层的链表，用来存储有序的数据。对于普通的有序单链表来讲，查找一个节点的时间复杂度是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;O(n)，这是由于每次查找都要遍历整个链表空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914005832020-56930294.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将部分元素从单链表中抽取出来，组成新的链表，在该层链表中再做查找，查找到某个范围后在到下层去查找。在上层遍历的只是这些抽取出的元素，假设抽取元素的方式是每隔一个元素就抽取出来，那么上层查找的时间复杂度就变为O(n/2)，而下层最多查找2次（两个上层元素之间的距离为2），总的复杂度为O(n/2) + O(1), 也就是O(n/2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914005906582-367618042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们还可以将第二层再进行抽取，抽取出第三层的链表，和上面的标准相同，也是以每隔一个节点抽取出来的方式，此时查找的时间复杂度就为O(n/2²) + O(1) + O(1)，也就是O(n/4)。当层数足够高时，可以看到查找的时间复杂度为O(log n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914005944985-1482938198.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　这就是跳跃表的基本思想，其实最终的形态和树类似。但注意一点，如果严格按照上面提到的规则来抽取元素，插入和删除元素有可能要调整所有元素来保持这个结构，而跳跃表本身是希望能向链表一样插入和删除元素只对有限几个元素产生影响，所以不能采用上述那种严谨的方式来实现跳跃表（如果严格定义了抽取规则，则和二叉树等数据结构差别不大）&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　在实际实现上，跳跃表每个元素的层数是随机生成的，而为了保证跳跃表类似树的这种层次结构，要求层数越低的元素出现的概率越高，且概率呈幂次定律。&lt;span&gt;元素层数的生成代码其实非常简单，我们看下Redis中生成元素层高的代码：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; zslRandomLevel(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; level = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((random()&amp;amp;&lt;span&gt;0xFFFF&lt;/span&gt;) &amp;lt; (ZSKIPLIST_P * &lt;span&gt;0xFFFF&lt;/span&gt;&lt;span&gt;))
        level &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (level&amp;lt;ZSKIPLIST_MAXLEVEL) ?&lt;span&gt; level : ZSKIPLIST_MAXLEVEL;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　没错只有这几行，不得不再说一次，确实非常简单；ZSKIPLIST_P默认值为0.25；我们注意到while循环的判断条件如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
(random()&amp;amp;&lt;span&gt;0xFFFF&lt;/span&gt;) &amp;lt; (ZSKIPLIST_P * &lt;span&gt;0xFFFF&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个判断条件为真的概率其实就是ZSKIPLIST_P，那么层数不高于1的概率就是1-0.25=0.75，层数2的概率0.25*(1-0.25)，层数为3的概率为0.25*0.25*(1-0.25) ......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里有个疑问，虽然层数level越高，概率越低，但特别极端情况下还是有可能出现level不停加下去的情况（当然按概率论来看，出现这种情况可能性微乎其微）；所以还是觉得在while判断条件中加上层数限制会保险一些，像这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; zslRandomLevel(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; level = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((random()&amp;amp;&lt;span&gt;0xFFFF&lt;/span&gt;) &amp;lt; (ZSKIPLIST_P * &lt;span&gt;0xFFFF&lt;/span&gt;) &amp;amp;&amp;amp; level &amp;lt;&lt;span&gt;ZSKIPLIST_MAXLEVEL)
        level &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  level;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　当然这种随机生成元素的层数也会带来弊端，&lt;/span&gt;&lt;span&gt;每个节点的层数是随机的，虽然可以在概率上保证层数越高的元素数量越少，整个跳跃表呈现树状的层次，但是无法控制相同层次的元素之间的距离。最差情况下查找的时间复杂度可能会降到O(n)。下图为最差的跳跃表形态：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201809/1438066-20180914010445240-1025781111.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　以上是对跳跃表做了简单的介绍，能够了解到什么是跳跃表就足够了&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;Redis中跳跃表的实现，后续会详细剖析下Redis中跳跃表的插入，删除，以及特殊的一些设计，想放到Redis数据结构源码分析中展开，真心觉着跳跃表是个很容易工程化的数据结构，实现起来很方便。这里回到我们根据槽值获取所有key的实现上；我们知道槽和key的关系是存储在跳跃表中的，每个跳跃表中的元素都记录了一个key值，而元素在跳跃表中排序用的值就是key对应的槽值。所有的key都按槽值大小排序好存入跳跃表中了，查找指定槽值下的所有key也就是查找槽值第一次出现在跳跃表中的位置，然后依次向后遍历，取出所有与指定槽值相等的元素所记录的key。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 &lt;span&gt;重新分片如何实现不对服务造成阻塞&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　重新分片过程中，Redis服务还是可以继续接收客户端的请求，当客户端请求的key刚好属于迁移过程中的slot，就轮到ask错误登场了。可能有些朋友会有疑问，之前不是有过一个Moved错误吗？什么情况下返回Moved错误，又是什么情况下返回ask错误呢？其实也很好区分，当命令所操作的key对应的槽不是属于接收命令的服务器处理时，会返回Moved错误；而当key对应的槽属于接收命令的服务器处理时（也就是槽隶属于该服务器），如果该槽正在被迁移，且key已经被转发出去，则这种情况下返回的是ask错误。假设key属于槽i，此时会从接收命令的服务器的server.cluster-&amp;gt;migrating_slots_to[i]中取出槽i迁移的目的服务器，并在ask错误中返回给客户端，客户端可以向新的目的服务发送命令请求。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;考虑这样一个场景，槽i属于节点A，重新分片将槽i分配给了节点B。在重新分片完成之前，槽i还是归属于A节点的。&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;此时客户端向服务器B发送命令请求（该命令操作的key计算哈希后落在槽i），由于此时槽i还不属于节点B处理，所以节点B会返回给客户端Moved错误，并告知客户端应该访问节点A。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端再次向节点A发送该命令请求时，A发现命令请求的key已经转移到节点B了，此时就会给客户端发送ask错误。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这次客户端还是要向节点B发送请求。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;　　发现了一个问题，第3步和第1步是一样的，都是向B发送命令请求，这样不是就陷入一个死循环中了吗？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　Redis是这样处理这种情况的，客户端在接收到ask错误之后，先向目的服务器发送一个Asking命令，让目的服务器给该客户端置一个Redis-asking标志，之后客户端再向目的服务器发送命令。也就是说在步骤3之前还需要向节点B发送一个Asking命令，然后B会将客户端结构体中的Redis-asking标志置为true，当节点B再收到该客户端发来的命令请求时发现该客户端处于Redis-asking状态且server.cluster-&amp;gt;importing_slots_from[i]不为空时就会处理客户端的命令。&lt;/span&gt;&lt;span&gt;要注意的是这个Redis-asking标志只是单次有效，在处理完之后就会恢复该标志位，如果下次再向节点B发送请求之前没有发送Asking命令，B节点就会返回客户端Moved错误，重新走一遍上述的流程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;引用：对跳跃表的介绍引用了&lt;a target=&quot;_blank&quot;&gt; &lt;span&gt;https://blog.csdn.net/u014427196/article/details/52454462&lt;/span&gt; &lt;/a&gt;博文中的内容和图片&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 17:13:00 +0000</pubDate>
<dc:creator>gogo一</dc:creator>
<og:description>结合源码，介绍了Redis集群对命令请求分配的依据，以及命令是如何重新分配的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gogoCome/p/9644271.html</dc:identifier>
</item>
<item>
<title>对Netflix Ribbon的Loadbalancer类源码设计合理性的一点质疑 - 羊飞</title>
<link>http://www.cnblogs.com/yangfeiORfeiyang/p/9644254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangfeiORfeiyang/p/9644254.html</guid>
<description>&lt;p&gt; 首先,这只是我个人的一点质疑,可能是因为我自己菜没有领悟到作者的意思,也正因此,想发出来给大家一起探讨.&lt;/p&gt;
&lt;p&gt;在昨晚,我因为在编写自己的开源项目的负载均衡模块(这是我开源项目的介绍:https://www.cnblogs.com/yangfeiORfeiyang/p/9621909.html),所以去看了下Netflix的RibbonLoadbalancer的源码,然后它是这样做的&lt;/p&gt;
&lt;p&gt;首先定义一个ILoadBalancer接口,这个接口是干嘛的呢?大家可以想象为一个自动饮料机,我们想要饮料的时候,按一个按键(chooseServer(Object key)),投一个硬币(当然它的几个源码实现类里,这个key其实没有多少意义),就能获得我们想要的饮料,由此来看,大家可以将它抽象为一个对我们隐藏了内部细节的容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914000544756-1275858492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面再来看一个接口,这个接口是干什么的呢?将注释里的英文翻译下,就是这个接口是定义负载均衡的规则的,最典型的负载均衡规则就是轮询啊,根据响应时间进行自动权重啊(根据响应时间这个,它的源码里是有实现类的ResponseTimeWeightedRule不过被标记为了过时类,也就是不推荐我们使用)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914001313338-844934828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了,接下来就是我认为它不合理的地方了,请看下面这个实现了IRule的抽象类,请注意它的成员变量,它封装了ILoadbalancer类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914001744570-2073509547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请大家想象一个场景,现在你想去一个超市买水果,你有可能走路去,有可能骑车去,也有可能做公交车,不管怎样,去超市买水果这是一个没有细节的概念,为什么没有细节呢?因为我们不知道你会以什么样的方式去,此时你会以什么样的方式去就是一个可能会发生变化的变量.&lt;/p&gt;
&lt;p&gt;那么对比到我们的代码里,ILoadBalancer就是你要去超市买水果,这是一个没有变化的,封闭了细节的概念,试问你在自动饮料机买饮料的时候知道饮料机内部经历了什么样的变化吗?而IRule就是我们是以什么样的方式去超市了,此时它是可能会发生变化的,因为我们可能用轮询算法,有可能用权重算法,但不管用什么,它们最终都会取出一个Server.,这个结果是不会改变的,也就代表&lt;/p&gt;
&lt;p&gt;我们的ILoadBalancer是不会改变的,那么你将ILoadBalancer封装到IRule里是什么意思呢?我&quot;个人&quot;认为,正确的做法应该是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914002848179-1263985272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 好吧,我继续看了一会又发现一个问题,这个问题也在验证了我的想法是对的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914003032247-798786110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 很明显,作者自己也知道,IRule应该是ILoadbalancer的细节&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914003124561-1242715464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;what???敢情您饶了一大圈最后又绕回去了呀.我们再看看rule.choose(key)里的具体内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914003259577-1472296820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;额额额,你调来调去最后又调回来了...&lt;/p&gt;
&lt;p&gt;不过,有一行代码让我感觉到了作者的高并发编程水平真的不错...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914003531939-695618734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先这个nextServerCyclicCounter是个AtomticInteger类.&lt;/p&gt;
&lt;p&gt;我们先说说为什么作者不直接nextServerCyclicCounter.getAndIncrement(),然后取模呢?因为如果要getAndIncrement的话,那么会导致一个问题,那么就是我就要写出这样的代码&lt;/p&gt;
&lt;p&gt;if(nextServerCyclicCounter.get()==服务数量){&lt;/p&gt;
&lt;p&gt;nextServerCyclicCounter.set(0)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;但是这样就有一个问题,那就是虽然AtomticInteger类的每个操作都是原子性的,但是加起来就不是了,也就是说,假设有两个线程,一个A,一个B.&lt;/p&gt;
&lt;p&gt;第一步:线程A刚刚进入了判断,还没来得及设置为0,CPU时间片就被抢了&lt;/p&gt;
&lt;p&gt;第二步:线程B也进来了,那么他们拿到的将是同样的数据.连续两次设置为0.当然可能会有N个线程进来N次设置为0&lt;/p&gt;
&lt;p&gt;而用这个方法呢?就不会有这个问题了,它等于是拿到当前值,然后再拿预期值,之后,看看当前值是否是预期值,不是的话就从新获取,是的话就返回预期值,没错,这里最妙的就是这个死循环包含的代码,它等于是每次重新拿最新的值去试(因为AtomticInteger类里的value字段上了volatile关键字),完美的避开了我们上述的问题.&lt;/p&gt;
&lt;p&gt;正当我感叹这个作者实在是高的时候...我看了下译文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313797/201809/1313797-20180914005533658-2061582415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;额,好吧,我也算是受到了您的启发,学到了一手,哈哈哈&lt;/p&gt;
&lt;p&gt; 完毕~欢迎大家说出我不对的地方...&lt;/p&gt;

</description>
<pubDate>Thu, 13 Sep 2018 17:00:00 +0000</pubDate>
<dc:creator>羊飞</dc:creator>
<og:description>首先,这只是我个人的一点质疑,可能是因为我自己菜没有领悟到作者的意思,也正因此,想发出来给大家一起探讨. 在昨晚,我因为在编写自己的开源项目的负载均衡模块(这是我开源项目的介绍:https://www</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangfeiORfeiyang/p/9644254.html</dc:identifier>
</item>
<item>
<title>Java设计模式-建造者(Builder)模式 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9644182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9644182.html</guid>
<description>&lt;p&gt;最近在看&lt;code&gt;Mybatis&lt;/code&gt;的源码， 在阅读解析 &lt;code&gt;XML&lt;/code&gt; 配置文件的过程中， 发现使用到了建造者(Builder)模式。 因此， 打算重温一下该设计模式。&lt;/p&gt;
&lt;h2 id=&quot;由来&quot;&gt;由来&lt;/h2&gt;
&lt;p&gt;假设我们需要画一个小人， 我们可能会有以下的构造函数定义:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Person(HeadType headType, HairType hairType, HairColor hairColor, FaceType faceType, BodyType bodyType, ArmType amrType, LegType legTyype) {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这么一个构造函数， 估计我们自己以后回来看的时候都懵了， 这么多参数， 导致我们后续的维护也很麻烦。&lt;/p&gt;
&lt;p&gt;而构造模式就可以解决此类的问题。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;目标是画一个小人&lt;/p&gt;
&lt;h3 id=&quot;定义抽象-builder&quot;&gt;1. 定义抽象 &lt;code&gt;Builder&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;先定义抽象的&lt;code&gt;PersonBuilder&lt;/code&gt;。 该类定义了画小人需要的步骤， 这样每个通过&lt;code&gt;PersonBuilder&lt;/code&gt;产生的对象本质上就都是一样的了， 只不过个性上可以不一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class PersonBuilder {
    protected Graphics graphics;

    public PersonBuilder(Graphics graphics) {
        this.graphics = graphics;
    }

    public abstract void buildHead();
    public abstract void buildBody();
    public abstract void buildArmLeft();
    public abstract void buildArmRight();
    public abstract void buildLegLeft();
    public abstract void buildLegRight();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义具体-builder类&quot;&gt;2. 定义具体 &lt;code&gt;Builder&lt;/code&gt;类&lt;/h3&gt;
&lt;p&gt;在定义一个具体的实现类&lt;code&gt;PersonFatBuilder&lt;/code&gt;。 该类继承&lt;code&gt;PersonBuilder&lt;/code&gt;， 并实现了抽象方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PersonFatBuilder extends PersonBuilder {
    public PersonFatBuilder(Graphics graphics) {
        super(graphics);
    }
    @Override
    public void buildHead() {
        graphics.drawOval(50, 20, 30, 30);
        graphics.drawArc(50, 30, 10, 5, 45, 135);
        graphics.drawArc(70, 30, 10, 5, 45, 135);
        graphics.drawArc(60, 35, 10, 5, 200, 135);
    }

    @Override
    public void buildBody() {
        graphics.drawRect(55, 50, 20, 50);
    }

    @Override
    public void buildArmLeft() {
        graphics.drawLine(55, 50, 40, 100);
    }

    @Override
    public void buildArmRight() {
        graphics.drawLine(75, 50, 90, 100);
    }

    @Override
    public void buildLegLeft() {
        graphics.drawLine(55, 100, 45, 150);
    }

    @Override
    public void buildLegRight() {
        graphics.drawLine(75, 100, 85, 150);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义具体-director类&quot;&gt;3. 定义具体 &lt;code&gt;Director&lt;/code&gt;类&lt;/h3&gt;
&lt;p&gt;该类负责具体的建造过程， 对建成什么样不关心。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PersonDirector {
    private PersonBuilder personBuilder;

    public PersonDirector(PersonBuilder personBuilder) {
        this.personBuilder = personBuilder;
    }

    public void drawPerson() {
        personBuilder.buildHead();
        personBuilder.buildBody();
        personBuilder.buildArmLeft();
        personBuilder.buildArmRight();
        personBuilder.buildLegLeft();
        personBuilder.buildLegRight();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;4. 测试&lt;/h3&gt;
&lt;p&gt;建立一个窗口，将小人画出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) {
    EventQueue.invokeLater(new Runnable() {
        @Override
        public void run() {
            // 创建窗口对象
            JFrame frame = new JFrame();
            frame.setVisible(true);
            frame.setTitle(&quot;画人&quot;);
            frame.setSize(250, 300);

            // 设置窗口关闭按钮的默认操作(点击关闭时退出进程)
            frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

            // 把窗口位置设置到屏幕的中心
            frame.setLocationRelativeTo(null);
            frame.setContentPane(new JPanel(){
                @Override
                protected void paintComponent(Graphics g) {
                    super.paintComponent(g);
                    PersonThinBuilder thinBuilder = new PersonThinBuilder(g);
                    PersonDirector director = new PersonDirector(thinBuilder);
                    director.drawPerson();


                }
            });
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180914002444937?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;瘦小人&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;h3 id=&quot;文字定义&quot;&gt;文字定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;将复杂对象的构建与它的表示分离， 使得同样的构建过程可以创建不同的表示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话解释， 允许你创建不同种类的对象， 同时又能避免对构造函数的污染。当对象有多种类型时， 该模式非常有用。 或者在创建对象时涉及到很多的步骤。&lt;/p&gt;
&lt;h3 id=&quot;结构图&quot;&gt;结构图&lt;/h3&gt;
&lt;p&gt;引用《大话设计模式》的一个图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180914002507199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象类&lt;code&gt;Builder&lt;/code&gt;:为创建&lt;code&gt;Product&lt;/code&gt;对象而抽象的接口。&lt;/p&gt;
&lt;p&gt;继承类&lt;code&gt;ConcreateBuilder&lt;/code&gt;：具体的建造者， 构造和装配各个部件。&lt;/p&gt;
&lt;p&gt;具体产品类&lt;code&gt;Product&lt;/code&gt;：我们需要建造的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Director&lt;/code&gt;: 用来创建产品的， 其内部有&lt;code&gt;Builder&lt;/code&gt;类型的成员变量。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Director&lt;/code&gt; 不需要知道 &lt;code&gt;Product&lt;/code&gt; 的内部细节， 它只提供需要的信息给建设者， 由具体的建造者&lt;code&gt;ConcreateBuilder&lt;/code&gt;处理从而完成产品的构造。&lt;/li&gt;
&lt;li&gt;建造者模式将复杂的产品创建过程分散到了不同的对象中， 从而实现对产品创建过程更精确的控制， 创建过程更加清晰。&lt;/li&gt;
&lt;li&gt;每个具体的建造者都可以创建出完整的产品对象， 而且是相互独立的。 因此， 调用端可以通过不同的具体建造者就可以得到不同的对象。当有新的产品出现时， 不需要改变原有代码， 只需要添加一个建造者即可。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;举例&quot;&gt;举例&lt;/h3&gt;
&lt;p&gt;现在如果我们想建造一个胖小人，有五官的。那我们只需要添加一个&lt;code&gt;PersonFatBuilder&lt;/code&gt;类就可以了， 不需要改原有代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PersonFatBuilder extends PersonBuilder {
    public PersonFatBuilder(Graphics graphics) {
        super(graphics);
    }
    @Override
    public void buildHead() {
        graphics.drawOval(50, 20, 30, 30);
        graphics.drawArc(50, 30, 10, 5, 45, 135);
        graphics.drawArc(70, 30, 10, 5, 45, 135);
        graphics.drawArc(60, 35, 10, 5, 200, 135);
    }

    @Override
    public void buildBody() {
        graphics.drawRect(55, 50, 20, 50);
    }

    @Override
    public void buildArmLeft() {
        graphics.drawLine(55, 50, 40, 100);
    }

    @Override
    public void buildArmRight() {
        graphics.drawLine(75, 50, 90, 100);
    }

    @Override
    public void buildLegLeft() {
        graphics.drawLine(55, 100, 45, 150);
    }

    @Override
    public void buildLegRight() {
        graphics.drawLine(75, 100, 85, 150);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018091400254089?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;胖小人&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 16:27:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>最近在看Mybatis的源码， 在阅读解析 XML 配置文件的过程中， 发现使用到了建造者(Builder)模式。 因此， 打算重温一下该设计模式。 由来 假设我们需要画一个小人， 我们可能会有以下的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9644182.html</dc:identifier>
</item>
<item>
<title>单台MongoDB实例开启Oplog - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9643128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9643128.html</guid>
<description>&lt;h2&gt; &lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;随着数据的积累，MongoDB中的数据量越来越大，数据分析团队从数据库中抽取变化数据（假如依据栏位createdatetime,transdatetime），越来越困难。我们知道MongoDB的副本集有一个数据结构Oplog，里面存储了Primary节点的所有写操作（此处的写操作是指查询以外的操作，包含 更新、异常等）。其实，数据的抽取完全可以从Oplog中抓取这些操作，然后去重放。&lt;/p&gt;
&lt;p&gt;但是在实际的生产环境中，我们很多MongoDB 数据库是单实例的，那么我们能否在单实例数据库上开启Oplog？&lt;/p&gt;
&lt;p&gt;答案是&lt;span&gt;&lt;strong&gt;肯定&lt;/strong&gt;&lt;/span&gt;的。&lt;/p&gt;
&lt;p&gt; 其原理就是，&lt;strong&gt;&lt;span&gt;在单实例上配置副本集&lt;/span&gt;&lt;/strong&gt;，如果配置成功了，&lt;span&gt;&lt;strong&gt;自然就有了Oplog&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;配置过程&lt;/h2&gt;
&lt;p&gt;其实配置的过程比较简单。&lt;/p&gt;
&lt;p&gt;step 1 ： 在配置文件中 添加副本集参数（replSet）；&lt;/p&gt;
&lt;p&gt;step 2 ：重启服务；&lt;/p&gt;
&lt;p&gt;step 3：在local数据库或admin数据库执行初始化副本集的脚本，rs.initiate()。&lt;/p&gt;

&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;pre readability=&quot;8&quot;&gt;
1. 在配置文件中增加副本集参数（replSet=？？），MongoDB实例重启，第一次登入，执行其他命令时（例如：show dbs），会提示错误，错误信息如下，&lt;br/&gt;{&lt;br/&gt;&quot;ok&quot; : 0,&lt;br/&gt;&quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,&lt;br/&gt;&quot;code&quot; : 13435,&lt;br/&gt;&quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;&lt;br/&gt;}&lt;p&gt;此时一定要执行初始化的命令：&lt;br/&gt;rs.initiate({ _id: &quot;副本集名称&quot;, members: [{_id:0,host:&quot;ServerIP:MongoDBPort&quot;}]})
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180913202920463-607699137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2 . 初始化时，请指明 Server信息和端口信息，否则初始化时&lt;strong&gt;&lt;span&gt;可能&lt;/span&gt;&lt;/strong&gt;报错，报错信息如下&lt;/p&gt;
&lt;p&gt; &quot;errmsg&quot; : &quot;No host described in new configuration 1 for replica set replwms maps to this node&quot;,&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180913234510628-243800160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 指定IP 和 端口，副本集名称，例如执行以下命令，OK&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180913234602848-1116104563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3 .  副本集初始化可以在admin中执行，不仅仅可以在local数据库中执行【真正的副本集建立多是在admin库中执行】。&lt;/p&gt;
&lt;p&gt;   而不像有些文章中要求的那样 ：You just need to issue rs.initiate() on the local database:&lt;/p&gt;

&lt;p&gt;4.  初始完，副本集中唯一的节点，可能短时间显示为SECONDARY或OTHER。一般而言，稍等一会，就会自然恢复为primary，无需人工干预。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180913205059370-226769175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180913235208743-1359350906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果数据库的数据量不大，并且长时间初始这种过渡状态（SECONDARY或OTHER），去看实例的日志，也显示无进展，此时可以考虑重启服务。&lt;/p&gt;
&lt;p&gt;下面案例是我们实际遇到的一个场景，我们是通过重启服务解决此问题，角色由other重启转换为Primary &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201809/780228-20180914000226684-480837126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 13 Sep 2018 16:15:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>背景 随着数据的积累，MongoDB中的数据量越来越大，数据分析团队从数据库中抽取变化数据（假如依据栏位createdatetime,transdatetime），越来越困难。我们知道MongoDB的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9643128.html</dc:identifier>
</item>
<item>
<title>大数据分析中使用关系型数据库的关键点 - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/DbForBigData.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/DbForBigData.html</guid>
<description>&lt;p&gt;相当一部分大数据分析处理的原始数据来自关系型数据库，处理结果也存放在关系型数据库中。原因在于超过99%的软件系统采用传统的关系型数据库，大家对它们很熟悉，用起来得心应手。&lt;/p&gt;
&lt;p&gt;在我们正式的大数据团队，数仓（数据仓库Hive+HBase）的数据收集同样来自Oracle或MySql，处理后的统计结果和明细，尽管保存在Hive中，但也会定时推送到Oracle/MySql，供前台系统读取展示，生成各种报表。&lt;/p&gt;
&lt;p&gt;在这种场景下，数据库的读写性能就显得尤为重要！&lt;/p&gt;


&lt;p&gt;有大神说，给我足够强的数据库硬件，一个GroupBy就可以满足各种统计分析场景。&lt;/p&gt;
&lt;p&gt;这话不假，我们一台数百万的金融级别Oracle一体机证明了GroupBy可以做得很强大，同时也证明了它有天花板，就是当数据更大的时候，它依然得趴下！&lt;/p&gt;
&lt;p&gt;于是，我们需要有设计原则，有优化技巧。&lt;/p&gt;

&lt;p&gt;核心原则：&lt;span&gt;&lt;strong&gt;数据库只是数据存储的载体，在大数据中难以利用它的计算能力！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有了这个原则，就意味着数据库将会用得“纯粹”：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据表独立性很强，大表间很少join（这让我想起有同学在Hive里对两张大表做笛卡尔乘积产生270T数据）&lt;/li&gt;
&lt;li&gt;数据表很大，单表几十亿行很常见&lt;/li&gt;
&lt;li&gt;索引很少，一般按主键查单行或者按时间查一段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 在这里，数据库就是存储数据的仓库，海量数据需要拆分存储，不可能全都挤一块。&lt;/p&gt;
&lt;p&gt;根据业务不同，一般有两种拆分方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单表分区。常见于Oracle，每月做一个分区，数据连续方便业务处理，但要求单机性能强劲。&lt;/li&gt;
&lt;li&gt;分表分库。常见于MySql，分个128张表乃至4096张表也都是很平常的事情，可以用很多性能较差的机器组建集群，但因数据不连续不便于业务处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体采用哪一种拆分方式，由使用场景决定。&lt;/p&gt;
&lt;p&gt;如果以后还要整体抽出来去做统计分析，比如原始数据和中间数据，那么优先考虑做分区。既方便连续抽取，又方便按月删除历史数据，对海量数据Delete很痛苦。分区内还可以建立子分区和分区内索引。&lt;/p&gt;
&lt;p&gt;如果用于业务数据或者最终统计结果，那么考虑分库后分表，按照业务维度把数据“均匀”存在不同表上。比如对单号取CRC，然后对数据表数取模。&lt;/p&gt;

&lt;p&gt;有很多数据，属于时序数据性质，或者日志型，都是只有插入，只有少量或者完全没有Update，几乎没有Delete。&lt;/p&gt;
&lt;p&gt;这种数据有个很关键的时间字段，确定数据什么时候到来，比如InputDate/CreateTime/UpdateTime，可以借助触发器给这个字段填充当前时间。&lt;/p&gt;
&lt;p&gt;基于时间维度抽取时序数据进行分析时，必须确保时间字段升序能够查到所有数据，不会漏过也不会重复查某些行。&lt;/p&gt;

&lt;p&gt; 海量数据查询，必须100%确定命中索引。要么是code=xxx，要么是 updatetime&amp;gt;=:start and updatetime&amp;lt;:end。&lt;/p&gt;
&lt;p&gt;根据主键查询，命中单行或少量数据；&lt;/p&gt;
&lt;p&gt;根据时间查询，必须合理选择时间区间(start, end)，让查询结果控制在10000~20000行左右较好。&lt;/p&gt;
&lt;p&gt;比如考虑到高峰时段，我们一般取5秒的区间进行查询，一般得到10000~40000行。&lt;/p&gt;

&lt;p&gt;使用数据时，可能有很多查询条件，但其中最重要的一般是时间区间。&lt;/p&gt;
&lt;p&gt;因为数据很大，DBMS本身的统计信息收集工作可能很不及时，导致执行计划选择错误的索引方案，这种情况下需要手工收集信息，甚至在查询语句里面强制指定索引。&lt;/p&gt;

&lt;p&gt;借助内存计算，我们往往可以在很短的时间内计算得到数十万乃至数百万数据，需要写入数据库。&lt;/p&gt;
&lt;p&gt;一般数据库的Insert/Update性能只有3000~5000tps，带着索引的负担，难以快速把数据写入其中。&lt;/p&gt;
&lt;p&gt;这里以Oracle为例，它的OracleCommand有一个超强功能ArrayBindCount，可以对一次参数化写入操作绑定多组（例如5000组/行）。&lt;/p&gt;
&lt;p&gt;该方法能够让它得到最高写入性能，实际业务使用得到30000tps左右。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; 1_000_000;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connectStr = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User Id=scott;Password=tiger;Data Source=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OracleConnection(connectStr);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; command = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OracleCommand
{
    Connection &lt;/span&gt;=&lt;span&gt; conn,
    ArrayBindCount &lt;/span&gt;=&lt;span&gt; count,
    CommandText &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert into dept values(:deptno, :deptname, :loc)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
conn.Open();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deptNo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Int32[count];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dname = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[count];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[count];

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deptNoParam = &lt;span&gt;new&lt;/span&gt; OracleParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deptno&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, OracleDbType.Int32)
{
    Direction &lt;/span&gt;=&lt;span&gt; ParameterDirection.Input,
    Value &lt;/span&gt;=&lt;span&gt; deptNo
};
command.Parameters.Add(deptNoParam);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deptNameParam = &lt;span&gt;new&lt;/span&gt; OracleParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deptname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, OracleDbType.Varchar2)
{
    Direction &lt;/span&gt;=&lt;span&gt; ParameterDirection.Input,
    Value &lt;/span&gt;=&lt;span&gt; dname
};
command.Parameters.Add(deptNameParam);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deptLocParam = &lt;span&gt;new&lt;/span&gt; OracleParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, OracleDbType.Varchar2)
{
    Direction &lt;/span&gt;=&lt;span&gt; ParameterDirection.Input,
    Value &lt;/span&gt;=&lt;span&gt; loc
};
command.Parameters.Add(deptLocParam);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sw =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
{
    deptNo[i] &lt;/span&gt;=&lt;span&gt; i;
    dname[i] &lt;/span&gt;=&lt;span&gt; i.ToString();
    loc[i] &lt;/span&gt;=&lt;span&gt; i.ToString();
}

command.ExecuteNonQuery();

sw.Stop();

Debug.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;批量插入:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + count + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;所占时间:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sw.ElapsedMilliseconds);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MySql和SQLite都有它独特的批量写入功能，并且支持netcore。&lt;/p&gt;
&lt;p&gt;SqlServer也有批量写入功能，但是目前还不支持netcore。&lt;/p&gt;
&lt;p&gt;MySql方案另起一篇文章专门写。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;关系型数据库存储大数据，要点就是：简单存储、分区分表、高效索引、批量写入！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/Data.html&quot; target=&quot;_blank&quot;&gt;100亿小数据实时计算平台&lt;/a&gt;（大数据系列目录）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/DbForBigData.html&quot; target=&quot;_blank&quot;&gt;大数据分析中使用关系型数据库的关键点&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，MySql如何做到600000tps的极速批量写入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，大数据分析中Redis经验分享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，如何分批处理大数据（调度系统）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/redis.html&quot; target=&quot;_blank&quot;&gt;新生命Redis组件（日均80亿次调用）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/Seckill.html&quot;&gt;借助Redis做秒杀和限流的思考&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/Redis220.html&quot;&gt;大数据分析中Redis怎么做到220万ops&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/BigData.html&quot;&gt;每天4亿行SQLite订单大数据测试（源码）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 15:49:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>相当一部分大数据分析处理的原始数据来自关系型数据库，处理结果也存放在关系型数据库中。原因在于超过99%的软件系统采用传统的关系型数据库，大家对它们很熟悉，用起来得心应手。 在我们正式的大数据团队，数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/DbForBigData.html</dc:identifier>
</item>
<item>
<title>学习 JavaScript （四）核心概念：操作符 - kurryluo</title>
<link>http://www.cnblogs.com/kurryluo/p/9644058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kurryluo/p/9644058.html</guid>
<description>&lt;p&gt;JavaScript 的核心概念主要由语法、变量、数据类型、&lt;strong&gt;操作符&lt;/strong&gt;、语句、函数组成，前面三个&lt;a href=&quot;https://www.cnblogs.com/kurryluo/p/9572781.html&quot;&gt;上一篇文章&lt;/a&gt;已经讲解完了。后面三个内容超级多，这篇文章主要讲解的是操作符。&lt;/p&gt;

&lt;p&gt;什么叫做操作符？&lt;/p&gt;
&lt;p&gt;这是一种工具，帮助我们操作字符串、数字值、布尔值，乃至对象，运用一些操作符能够让代码更简洁、计算更高效。它包括以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;赋值操作符&lt;/li&gt;
&lt;li&gt;一元操作符（加、减）&lt;/li&gt;
&lt;li&gt;位操作符&lt;/li&gt;
&lt;li&gt;关系操作符&lt;/li&gt;
&lt;li&gt;相等操作符&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;赋值操作符&quot;&gt;01 赋值操作符&lt;/h2&gt;
&lt;p&gt;赋值操作符就是我们常见的 “=”，作用就是把右边的值赋给左边的变量。比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果复杂一些（性能上不会有提升，看起来牛*一点而已），就是结合后面要碰到的操作符，变成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*= ; // 乘/赋值

// 举例
let num = 10;
num = num * 10; // 和下面的用法效果一样
num *= 10；

下面的复杂赋值操作符如下：

/= ; // 除/赋值
%= ; // 模/赋值
+= ; // 加/赋值
-= ; // 减赋值
&amp;lt;&amp;lt;= ; // 左移赋值；
&amp;gt;&amp;gt;=; // 有符号右移；
&amp;gt;&amp;gt;&amp;gt;= ; // 无符号右移；&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一元操作符&quot;&gt;02 一元操作符&lt;/h2&gt;
&lt;p&gt;记住：&lt;strong&gt;只对一个数值进行操作的符号叫做一元操作符&lt;/strong&gt;，而不是指操作符自身的数量。&lt;/p&gt;
&lt;h3 id=&quot;递增操作两个加号&quot;&gt;递增操作：两个加号 ++&lt;/h3&gt;
&lt;p&gt;前置操作 ++i ，i 先自己加上 1 ，然后拿着计算后的 i 值进行下一步计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let i = 1;
let result = ++i + 20 
console.log(i) // 2
console.log(result) // 22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后置操作 i++，先进行下一步计算，然后再自己加上1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let i = 1;
let result = i++ + 20 
console.log(i) // 2
console.log(result) // 21&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;递减操作两个加号---&quot;&gt;递减操作：两个加号 --&lt;/h3&gt;
&lt;p&gt;递减操作和递增操作的规则一样，-- 符号在前面就先进行递减操作，否则就等接下来的计算进行完再递减。&lt;/p&gt;
&lt;p&gt;前置操作 --i ，i 先自己减去 1 ，然后拿着计算后的 i 值进行下一步计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let i = 1;
let result = --i + 20 
console.log(i) // 0
console.log(result) // 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后置操作 i--，先进行下一步计算，然后再自己减去1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let i = 1;
let result = --i + 20 
console.log(i) // 0
console.log(result) // 21&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;统一记忆成：符号在前，马上加减&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;加和减操作符&quot;&gt;加和减操作符&lt;/h3&gt;
&lt;p&gt;前面讲的是两个相同的符号联合起来操作一个数值，而家下来介绍的这个操作符只有一个。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt;，对于数值来说，&lt;code&gt;+&lt;/code&gt; 没有任何作用，对于 &lt;code&gt;-&lt;/code&gt; 来说，把正数变成负数而已。&lt;/p&gt;
&lt;p&gt;如果我们把操作符用在其他数据类型上，会发生怎样的情况呢？直接看例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = &quot;01&quot;;
a = +a; // 1

let b = &quot;1.1&quot;;
b = +b; // 1.1

let c = &quot;z&quot;;
c = &quot;z&quot;; // NaN

let d = &quot;true&quot;;
d = &quot;true&quot;; // 1

let e = 1.1;
e = 1.1; // 1.1

let o = {
    valueOf: function(){
        return -1;
    }
} // 如果没有看懂这个对象的写法，不用着急，后面会针对对象做进一步的解释。
o = +o ; -1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 &lt;code&gt;-&lt;/code&gt;操作则是在&lt;code&gt;+&lt;/code&gt;操作的结果前面加上负号（-）而已。其他类型的数据的转换规则依然不变。&lt;/p&gt;
&lt;h2 id=&quot;位操作符&quot;&gt;03 位操作符&lt;/h2&gt;
&lt;p&gt;位操作符是在最基本的、最底层的水平上对数值进行操作，也就是在内存中直接对二进制进行操作。&lt;/p&gt;
&lt;p&gt;JavaScript 中的所有数据都是按照 64 位存储的，但是位操作符并不能直接对 64 位的数据进行操作，而是将其转换成 32 位的，操作完成后，再转换成 64 位的，所以我们真正关心的是计算机如何操作 32 位的数值。&lt;/p&gt;
&lt;p&gt;对于有符号的整数，二进制从右往左数，32 位中的前 31 位表示整数的值，第 32 位是符号位，表示数值的符号，0 表示正数，1 表示负数。比如 数值 18 表示成二进制为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0     0000000000000000000000000010010
符号位
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写成简洁版的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10010&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;31 位中每一位都表示 2 的幂，所以从二进制转换成数值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(2^4 x 1) + (2^3 x 0) + (2^2 x 0) + (2^1 x 1) + (2^0 x 0) = 18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是正数的二进制表达方式，负数的二进制需要用到二进制补码。步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;求这个数值的绝对值的二进制；&lt;/li&gt;
&lt;li&gt;求二进制反码，将 0 替换成 1，将 1 替换成 0 ；&lt;/li&gt;
&lt;li&gt;得到的二进制反码加 1 ；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举一个例子（-18）：&lt;/p&gt;
&lt;p&gt;-18 的绝对值等于 18：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0     0000000000000000000000000010010&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;求二进制反码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1     1111111111111111111111111101101&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反码加 1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1     1111111111111111111111111101110&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到的结果就是 11111111111111111111111111101110 。但是计算机给我们看的结果却不是这样，把 -18 转换成字符串会发现得到的结果是“-10010”，计算机隐藏了计算过程，直接展示友好的结果而已，别被骗了。&lt;/p&gt;
&lt;p&gt;因为是底层操作，所以应用位操作的计算方式会比普通计算方式要快：&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;按位非（NOT）
&lt;ul&gt;&lt;li&gt;符号：~ ；&lt;/li&gt;
&lt;li&gt;作用对象：一个数值（数字、字符串、布尔值、对象）；&lt;/li&gt;
&lt;li&gt;操作：把操作数变成相反数再减去一 ；&lt;/li&gt;
&lt;li&gt;例子: &lt;code&gt;~2 == -3&lt;/code&gt;、&lt;code&gt;~-2 == 1&lt;/code&gt;、&lt;code&gt;~true == -2&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;按位与（AND）
&lt;ul&gt;&lt;li&gt;符号：&amp;amp; ；&lt;/li&gt;
&lt;li&gt;作用对象：两个数值；&lt;/li&gt;
&lt;li&gt;操作：将两个数值的二进制形式中的每一位对齐，然后依据普通的与操作进行合并，把 1 看成 true，把 0 看成 false ， 即 1 和 1 组合是 1 ，1 和 0 组合是 0 ， 0 和 0 组合是 0 。得到的二进制再转换成 十进制就可以了；&lt;/li&gt;
&lt;li&gt;例子: &lt;code&gt;25 &amp;amp; 3 == 1&lt;/code&gt; ；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;按位或（OR）
&lt;ul&gt;&lt;li&gt;符号：| ；&lt;/li&gt;
&lt;li&gt;作用对象：两个数值；&lt;/li&gt;
&lt;li&gt;操作：和按位与的操作类似，与之不同的是，按位或操作时，只要碰到 1 就返回 1 ，只有两个对应的位全部为 0 时才返回 0 ；&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;25 | 3 == 27&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;按位异或（XOR）
&lt;ul&gt;&lt;li&gt;符号：^ ；&lt;/li&gt;
&lt;li&gt;作用对象：两个数值；&lt;/li&gt;
&lt;li&gt;操作：有且仅有一个位是 1 ，另一个位是 0 ，才返回 1 ，否则都返回 0，即 1 和 1 也返回 0；&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;25 ^ 3 == 26&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;左移
&lt;ul&gt;&lt;li&gt;符号：&amp;lt;&amp;lt; ；&lt;/li&gt;
&lt;li&gt;作用对象：一个数值；&lt;/li&gt;
&lt;li&gt;操作：将数值的所有位向左移动指定的位数，右侧多出来的空位由 0 进行填充；&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;2 &amp;lt;&amp;lt; 5 == 64&lt;/code&gt;，2 向左移动 5 位，左移不会影响操作数的符号位，即 -2 ； ，左移后的结果将会是 -64。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;右移
&lt;ul&gt;&lt;li&gt;符号：&amp;gt;&amp;gt; ；&lt;/li&gt;
&lt;li&gt;作用对象：一个数值；&lt;/li&gt;
&lt;li&gt;操作：将数值的所有位向右移动指定的位数，符号位不动，左侧多出来的空位由 0 进行填充；&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;64 &amp;gt;&amp;gt; 5 == 2&lt;/code&gt;，64 向右移动 5 位，右移不会影响操作数的符号位，即 -64 ，右移后的结果将会是 -2。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;无符号右移
&lt;ul&gt;&lt;li&gt;符号：&amp;gt;&amp;gt;&amp;gt;；&lt;/li&gt;
&lt;li&gt;作用对象：一个数值；&lt;/li&gt;
&lt;li&gt;操作：将数值的所有位向右移动指定的位数，左侧多出来的空位由 0 进行填充，这个时候符号位也要向右移动。可以知道，对于正数而言，这个操作和右移是一样的结果，但是对于负数来说，因为符号位是 1 ，移动后要计入最终结果；&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;-64 &amp;gt;&amp;gt;&amp;gt; 5 == 134217726&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;布尔操作符&quot;&gt;04 布尔操作符&lt;/h2&gt;
&lt;p&gt;在上述位操作符中的按位非、按位与、按位或，我们已经简单介绍了一些跟布尔操作类似的用法。&lt;/p&gt;
&lt;p&gt;总的来说，布尔操作的地位跟相等操作符（==、===）的地位是一样的，一共右三种：非（NOT）、与（AND）、或（OR）。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;要点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这里的 true 和 false，可以替换成别的数值类型，比如对象、null等&lt;/li&gt;
&lt;li&gt;逻辑与是&lt;strong&gt;短路操作&lt;/strong&gt;，只要第一个操作数或者操作数的转换值是 false ，计算终止，直接返回 false 。如果是 true 的话再返回后面的值。&lt;/li&gt;
&lt;li&gt;在写判断语句的时候经常会用到。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;要点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;逻辑或也是短路操作，只要第一个操作数或者操作数的转换值是 true ，计算终止，直接返回第一个操作数。如果是 false 的话，返回第二个操作数。&lt;/li&gt;
&lt;li&gt;利用逻辑或的性质，我们在定义变量的时候可以给它找个备胎，降低 Bug 发生率。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;乘性操作符&quot;&gt;04 乘性操作符&lt;/h2&gt;
&lt;p&gt;乘性操作符包括三种：乘法、除法、求模。在 JavaScript 中，操作数为非数值的情况下也能计算。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;10&quot; * 2 ; // 计算结果为 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看得出来，计算机自动执行了类型转换，如果参与的操作数不是数值，会先用 Number() 函数转换。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;乘法：
&lt;ul&gt;&lt;li&gt;符号： *&lt;/li&gt;
&lt;li&gt;举例：&lt;code&gt;4 * 5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有三点需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;乘积超过 JavaScript 范围，用 Infinity表示无穷大 或者 -Infinity 表示负无穷大；&lt;/li&gt;
&lt;li&gt;Infinity 和 0 相乘是 NaN；&lt;/li&gt;
&lt;li&gt;
&lt;h2 id=&quot;其中一个操作数是-nan则结果是-nan因为-number-转换非数值型字符串是-nan所以非数值型字符串和数字相乘就是-nan-其他的规则与乘法操作符类似&quot;&gt;其中一个操作数是 NaN，则结果是 NaN。因为 Number() 转换非数值型字符串是 NaN，所以非数值型字符串和数字相乘就是 NaN 。其他的规则与乘法操作符类似。&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;除法：
&lt;ul&gt;&lt;li&gt;符号： /&lt;/li&gt;
&lt;li&gt;举例：&lt;code&gt;44 / 11 ；等于 4&lt;/code&gt;&lt;br/&gt;有一点需要注意：如果 Infinity 被 -Infinity 除，那么结果是 NaN。&lt;br/&gt;---&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;求模：
&lt;ul&gt;&lt;li&gt;符号： %&lt;/li&gt;
&lt;li&gt;举例：&lt;code&gt;26 % 5 ；等于 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;求模就是取余数。&lt;/p&gt;
&lt;h2 id=&quot;加性操作符&quot;&gt;05 加性操作符&lt;/h2&gt;
&lt;p&gt;加法和减法都被称作是加法操作符。在这里说明一下，加性操作符也会强制转换数据类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加法：
&lt;ul&gt;&lt;li&gt;符号： +&lt;/li&gt;
&lt;li&gt;举例：&lt;code&gt;1 + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两个操作数都是字符串，那么直接拼接起来返回结果；如果其中一个操作数是字符串，那么就把另一个操作数转换乘字符串再拼接起来。&lt;/li&gt;
&lt;li&gt;利用 Chrome 的 console 命令窗口，实验得到如下的规则：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;{} + 11; // 11
11 + {}; // &quot;11[object,object]&quot;

false + 1; // 1 ; 操作数可以调换位置，结果不变
true + 1; // 2 ； 同上
null + 1；// 1 ；同上
undefined + 1 ; // NaN；同上
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;减法：
&lt;ul&gt;&lt;li&gt;符号： -&lt;/li&gt;
&lt;li&gt;举例：&lt;code&gt;2 - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;减法两边的操作数和加法的区别是，无论是字符串还是对象，都应该转换成数值，再进行计算。不存在字符串相减的情况。&lt;/p&gt;
&lt;h2 id=&quot;关系操作符&quot;&gt;06 关系操作符&lt;/h2&gt;
&lt;p&gt;关系操作符就是小学的时候学过的小于(&amp;lt;)、大于(&amp;gt;)、小于或等于(&amp;lt;=)、大于或等于(&amp;gt;=)。&lt;/p&gt;
&lt;p&gt;JavaScript 中，使用关系操作符比较两个操作数后，返回的结果是布尔值（true、false）。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当比较的两个数都是数值时，直接比数字大小；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果都是字符串则比较对应位置的字符编码值。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Brick&quot; &amp;lt; &quot;apple&quot;; //返回的是 true，因为 B 的字符编码是 66 ，而 a 的字符编码是 97

&quot;23&quot; &amp;lt; &quot;3&quot;; // 返回 true，因为 2 的字符编码是 50 ，3 的字符编码是 51 。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;如果其中一个是数字，则把另一个操作数变为数值以后再比较；&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;任何数据类型和 NaN 比较都是返回 false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里有个小思考：如果 A、B 表示两个数据，有 A &amp;gt; B 不成立（false），则 A &amp;lt;= B 是否成立？&lt;/p&gt;
&lt;h2 id=&quot;相等操作符&quot;&gt;07 相等操作符&lt;/h2&gt;
&lt;p&gt;JavaScript 提供两种比较方案：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;相等（&lt;code&gt;==&lt;/code&gt;）和不相等（&lt;code&gt;!=&lt;/code&gt;），会把操作数转换成相似的类型再比较。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;5&quot; == 5; //true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;null 和 undefined 是相等的；&lt;/li&gt;
&lt;li&gt;如果有一个操作数是 NaN 则返回 false ；&lt;/li&gt;
&lt;li&gt;NaN 和 NaN 不相等，NaN 返回 true ；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;严格相等（&lt;code&gt;===&lt;/code&gt;）和严格不相等（&lt;code&gt;!==&lt;/code&gt;），直接比较，不转换数据类型，使用严格相等操作符，有一丁点不相等就返回 false。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;5&quot; === 5; //false&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;null 和 undefined 是不严格相等的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，在实际使用过程种，建议是使用严格相等和严格不相等。&lt;/p&gt;
&lt;h2 id=&quot;条件操作符&quot;&gt;08 条件操作符&lt;/h2&gt;
&lt;p&gt;条件操作符也被称作是三目运算符，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = 条件语句 ? 1 ：2

如果条件语句返回的是 true ，则把 1 赋值给 a，如果是 false， 则把 2 赋值给 a。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回一个较大值，我们就可以不用谢一个 if 语句，直接按照下面这种写法就可以实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = (number1 &amp;gt; number2) ? number1 : number2&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/28/16580e5417d2716a?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27042&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家关注微信公众号：&lt;strong&gt;可视化技术（ visteacher ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不仅有前端和可视化，还有算法、源码分析、书籍相送&lt;/p&gt;
&lt;p&gt;个人网站：&lt;a href=&quot;http://blog.kurryluo.com/&quot; class=&quot;uri&quot;&gt;http://blog.kurryluo.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各个分享平台的 KurryLuo 都是在下。&lt;/p&gt;
&lt;p&gt;用心学习，认真生活，努力工作！&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 15:46:00 +0000</pubDate>
<dc:creator>kurryluo</dc:creator>
<og:description>JavaScript 的核心概念主要由语法、变量、数据类型、 操作符 、语句、函数组成，前面三个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kurryluo/p/9644058.html</dc:identifier>
</item>
<item>
<title>关于GANs原论文里的数学证明 - 子君学编程</title>
<link>http://www.cnblogs.com/zijunlearningclanguage/p/9644034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zijunlearningclanguage/p/9644034.html</guid>
<description>&lt;p&gt;&lt;span&gt;GANs的核心理念很简单，其实就是回答了最大似然估计没有办法解决的问题提出另一条解决路径。所以在全面认识GANs之前首先需要掌握一点点最大似然相关的知识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个文章主要是根据最近做的一个PPT进行相关的讲解注释。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913213758256-1664936664.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们讲下什么是GANs，从最简单的流程图从上往下看就是，首先定义一些噪音数据（这里我更偏向于称作种子数据。anyway），将他们喂(feed)给生成器，经由生成器后最初的一些噪音数据会得到相应的，具有一定分布形式的数据，之后分别将生成的数据和真实数据交给判别器，判别器的主要作用就是根据这些数据的相关特性来分辨这些数据中哪些是来源于真实数据，哪些是来源于生成器构造的数据。这个可以看作是GNAs的单次运算过程。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913214733096-1124572882.png&quot; alt=&quot;&quot; width=&quot;757&quot; height=&quot;602&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体来说GANs是怎么工作的呢？其实在原论文中作者就有过相关的详细描述。这里做个简单的翻译。为了让p&lt;sub&gt;g&lt;/sub&gt;(构建的数据)最终能符合真实数据的分布，我们首先将一些毫无规律的噪音数据输入到生成器中，生成器根据喂进的数据生成具有一定分布形式的数据G(z,Θ)，同时我们还定义了一个判别器D(x)，其输出为单个标量。判别器D的主要功能就是判别输入其中的数据是否来自于真实的数据集中而不是来自构建的数据集中。训练判别器D使其对两个来源的数据能最准确的判别，例如来源于真实数据集的数据经过判别器的判断其概率接近于1，而来源于构建数据集中的数据经过判别器的判断，其概率更接近于0。从而将两种来源的数据划分开来。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913220408954-773931051.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这几个图从真实数据集的分布，构建的数据分布以及判别器的判别线这三个元素动态的展示了GANs运算优化过程，并且可以在最后一张图中看出最终达到最优解时判别器对两种来源的数据判断的概率均为0.5，且构建的数据已经和真实数据的分布重合，表示此时，判别器已经无法二者的差别。本文后面部分将主要从数学角度依据原论文中的相关公式计算验证这一最优解的情况是否具有严格的数据验证。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913221011301-1202902250.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;512&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文中给出的算法示例，其大致过程与上述描述的一致，只是在其中补充了更新判别器D和生成器G的策略，分别是应用随机梯度上升优化D，用随机梯度下降来优化更新生成器。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913221438322-218894116.png&quot; alt=&quot;&quot; width=&quot;689&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是一堆数学相关的验证时刻了，这个公式是原文中的第一个公式，有江湖传言，如果一眼就能看懂这个公式在讲些什么，就说明你的GANs已经达到大成的级别了～首先我们来说说开头部分的那个minmax，它是源自博弈论中的极小极大博弈来的，简单的说就是在函数V(D, G)中D和G两者之间形成了一种此消彼长的关系。所谓的极小极大就是指，D和G两者的作用（G和D更准确点）。就是说D的主要作用是要将函数值拖向极大那边，而G的作用就是要将函数值怒力拖向极小的那边。其中E&lt;sub&gt;x~pdata&lt;/sub&gt;(x)[log D(x)]公式中的这种形式，很大程度上是来源于对数似然函数（个人猜测，但也挺合理的）。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913224407427-189158348.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;570&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一页就是最大似然函数的相关知识，主要参考了李宏毅18年讲解的GANs课程PPT，只是将其中的英文部分翻译成了中文而已，后面还有几张片子也是来源于他的课程PPT之中的。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913224821166-705384504.png&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;564&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个片子也是参照李宏毅的课程PPT，与他不同的是我在这里并没有关注他原版PPT中将似然函数与KL散度统一的那块知识，主要是觉得目前还不太会干扰到我后续对GANs论文数理部分的理解，首先这上面取log的主要原因是将连乘转化成加法运算，并且在取完log之后对本来的函数也没有什么本质上的性质改变（这一点很重要！），所以可行。最后一步的约等于是大数定理已经证明的结论，即，当M接近无限大时，可以用期望乘以log(…)代替将log(…)求和。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913230342648-281131688.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;538&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么要求证图中的式子，因为这个等式成立对我很重要（其实是，这个等式成立是后面几步运算的基础）。这里依然采用李宏毅PPT中的解释，（目前来说看到的大部分相关博客对这一部分要不就是没有解释，要不就是采用了我下张片子会讲到的验证方法，但也很少有涉及的博客）这里主要是一个理解的过程，第一个等式成立代表了G(z) = x；同时E&lt;sub&gt;z&lt;/sub&gt; = E&lt;sub&gt;x&lt;/sub&gt;也是成立的。这一步的基础是在给定的G 的基础上求解D的最优解（这是大前提）。具体按图中的意思就是经过一段优化之后（论文以及后续的很多实验都说最好预先训练G一小会）生成器G可以将吃掉的噪音数据大致的规划成一个新的分布，就是P&lt;sub&gt;G&lt;/sub&gt;(x), G吃掉的z生成的就是x(这个x不是来源于真实数据集的x而是生成器生成的x)，GANs做到后面就是要让两种来源的x达到几乎一样分布的地步，是判别器无法区分。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913231819259-1810858894.png&quot; alt=&quot;&quot; width=&quot;705&quot; height=&quot;529&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里是另一种常用来证明等式成立的数学理论，主要是运用到了测度论中的随机变量换元定理进行证明，其中要是使等式成立则必须假设G(x) = G&lt;sup&gt;-1&lt;/sup&gt;(x)，即G(x)首先得是可逆的，其次它的逆函数要等于本身，这一点的证明还不太明了。实在没找到相关的数学证明部分，有知道的同学可以告知一下。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232300797-800207619.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;506&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分加上后面的片子主要就是对文中几乎没怎么写详细证明的部分详细的展开证明了下（个人觉得这部分的证明具有简明性，一步步的看下去就能理解，所以在后面的片子中，一般不会进行评论解释)&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232549776-1097361930.png&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;470&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是一个简单的求凸函数的最大值的问题，转化成倒数等于0即可求解。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232738921-383100422.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;520&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232815266-1890336576.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;515&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232845689-397391098.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232913819-931099671.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913232941613-1251763549.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;544&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913233014088-1909786675.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;497&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1196548/201809/1196548-20180913233111457-1015057757.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一块的收敛性的证明论文中讲解的很详细，其主要讨论的部分即D的最优解在不在V(G; D)的最优解的范围中。&lt;/p&gt;
&lt;p&gt;后面是一些常被提及的最新的GANs家族里的各个文章地址，感兴趣的可以自行下载阅读。&lt;/p&gt;
&lt;p&gt;1. InfoGANs &lt;a href=&quot;https://arxiv.org/abs/1606.03657&quot;&gt;https://arxiv.org/abs/1606.03657&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. Relativistic GANs &lt;a href=&quot;https://arxiv.org/abs/1807.00734&quot;&gt;https://arxiv.org/abs/1807.00734&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. CycleGANs &lt;a href=&quot;https://arxiv.org/abs/1703.10593&quot;&gt;https://arxiv.org/abs/1703.10593&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. SAGANs &lt;a href=&quot;https://arxiv.org/abs/1805.08318&quot;&gt;https://arxiv.org/abs/1805.08318&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. Progressive GANs &lt;a href=&quot;https://arxiv.org/abs/1710.10196&quot;&gt;https://arxiv.org/abs/1710.10196&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6. DCGANs &lt;a href=&quot;https://arxiv.org/abs/1511.06434&quot;&gt;https://arxiv.org/abs/1511.06434&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7. WGANs &lt;a href=&quot;https://arxiv.org/abs/1701.07875&quot;&gt;https://arxiv.org/abs/1701.07875&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8. BEGANs &lt;a href=&quot;https://arxiv.org/abs/1703.10717&quot;&gt;https://arxiv.org/abs/1703.10717&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9. VAEGANs &lt;a href=&quot;https://arxiv.org/abs/1512.09300&quot;&gt;https://arxiv.org/abs/1512.09300&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10. Seq GANs &lt;a href=&quot;https://arxiv.org/abs/1609.05473&quot;&gt;https://arxiv.org/abs/1609.05473&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11. cGANs &lt;a href=&quot;https://arxiv.org/abs/1411.1784&quot;&gt;https://arxiv.org/abs/1411.1784&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总的来说文中最模糊的部分就是第一个等式的证明，那块总觉得要想通了什么，但是就是有个隔阂，突破不了(- -! 污~)&lt;/p&gt;
&lt;p&gt;本文中的图片来自于自己制作的PPT，其中部分页标注了引用。如对文中内容有相关问题可以进行讨论，未经许可，严禁转载！&lt;/p&gt;

</description>
<pubDate>Thu, 13 Sep 2018 15:41:00 +0000</pubDate>
<dc:creator>子君学编程</dc:creator>
<og:description>GANs的核心理念很简单，其实就是回答了最大似然估计没有办法解决的问题提出另一条解决路径。所以在全面认识GANs之前首先需要掌握一点点最大似然相关的知识。 这个文章主要是根据最近做的一个PPT进行相关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zijunlearningclanguage/p/9644034.html</dc:identifier>
</item>
<item>
<title>一统江湖的大前端（4）shell.js——穿上马甲我照样认识你 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9632493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9632493.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/10/50d7774414c83ca1793cd6c22d9b05e9.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，前端能做的事情已经太多了, &lt;code&gt;手机app开发&lt;/code&gt; , &lt;code&gt;桌面应用开发&lt;/code&gt; , &lt;code&gt;用于神经网络人工智能的库&lt;/code&gt; , &lt;code&gt;页面游戏&lt;/code&gt; , &lt;code&gt;数据可视化&lt;/code&gt; , 甚至 &lt;code&gt;嵌入式开发&lt;/code&gt; ，什么火就搞什么,活脱脱一个&lt;strong&gt;蹭热点小能手&lt;/strong&gt;。如果你也觉得前端的日常开发有些枯燥，不妨一起来看看前端的另一番模样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;前端开发人员的工作内容几乎很少会涉及脚本的编写，建议将shell.js和git的命令行指令综合在一起作为专题学习，集中学习一下常用指令。更详细的参数请参考专门的shell脚本语言资料进行学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一.shell-shelljs&quot;&gt;一.Shell &amp;amp;&amp;amp; Shelljs&lt;/h4&gt;
&lt;p&gt;码农界存在着无数条鄙视链，&lt;code&gt;linux&lt;/code&gt;使用者对&lt;code&gt;windows&lt;/code&gt;的鄙视便是其中之一，&lt;code&gt;cli&lt;/code&gt;使用者对&lt;code&gt;GUI&lt;/code&gt;用户的嘲讽也是如此，在这样一个讲究&lt;strong&gt;逼格&lt;/strong&gt;的时代，如果你的桌面上没有一个小黑窗时不时地从下往上翻滚并抛出一些亮绿色的字符串，你真不好意思跟人打招呼。而&lt;code&gt;前端&lt;/code&gt;这种天生几乎不用和命令行打交道的物种，自然再一次莫名其妙地处在了鄙视链的末端，没错，是再一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201809/10/cf38b636eeacb47702b30eb886a93351.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Shell&lt;/code&gt;是&lt;code&gt;linux&lt;/code&gt;下的脚本语言解析器，拥有丰富且强大的底层操作权限。&lt;code&gt;Shelljs&lt;/code&gt;就是基于&lt;code&gt;node&lt;/code&gt;的一层命令封装插件，让前端开发者可以不依赖&lt;code&gt;linux&lt;/code&gt;也不依赖类似于&lt;code&gt;cmder&lt;/code&gt;的转换工具，而是直接在我们最熟悉不过的&lt;code&gt;javascript&lt;/code&gt;代码中编写&lt;code&gt;shell&lt;/code&gt;命令实现功能。&lt;/p&gt;
&lt;h4 id=&quot;二.前端开发人员学shelljs干嘛&quot;&gt;二.前端开发人员学Shelljs干嘛&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;跟&lt;code&gt;自动化&lt;/code&gt;是强相关的，个人理解其用途主要是两方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.从业务逻辑的需求来看，&lt;code&gt;shelljs&lt;/code&gt;并不是什么具有非凡意义的插件，它只是对&lt;code&gt;node&lt;/code&gt;的底层API进行了一些封装，方便我们以类似&lt;code&gt;shell&lt;/code&gt;的语法去编写代码梳理逻辑，实现一些业务逻辑需求，如果你所在的项目组恰好需要这样的能力，用它会很方便;&lt;/li&gt;
&lt;li&gt;2.&lt;code&gt;cli&lt;/code&gt;相对于&lt;code&gt;GUI&lt;/code&gt;或许是更快，但它依然是一种重复劳作，有了shelljs和全栈能力，开发者可以将团队中&lt;strong&gt;耗时的重复性常规动作&lt;/strong&gt;编写为自动化脚本，并利用前端的天然优势为其配备&lt;code&gt;GUI&lt;/code&gt;，用页面上的一键点击来替代重复劳作，在紧张的开发节奏中，平均每天为你节约个&lt;strong&gt;30-40&lt;/strong&gt;分钟起来走走喝杯水难道不好吗？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;想要一统江湖，大前端的深度和广度是缺一不可的，你可以说你不精通shell，但不要说自己不懂shell，更不要一脸天真地反问面试官“前端还能搞shell？这么神奇？”他不会觉得你对知识有好奇心，只会觉得你很low，哦不对，是大写的LOW.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;三.官方示例包含注释&quot;&gt;三.官方示例（包含注释）&lt;/h4&gt;
&lt;p&gt;废话说完了，开始学习，拿好小本子，我要开车了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//引入shelljs
var shell = require('shelljs')

//检查控制台是否以运行`git `开头的命令
if (!shell.which('git')) {
  //在控制台输出内容
  shell.echo('Sorry, this script requires git');
  shell.exit(1);
}

shell.rm('-rf','out/Release');//强制递归删除`out/Release目录`
shell.cp('-R','stuff/','out/Release');//将`stuff/`中所有内容拷贝至`out/Release`目录

shell.cd('lib');//进入`lib`目录
//找出所有的扩展名为js的文件，并遍历进行操作
shell.ls('*.js').forEach(function (file) {
  /* 这是第一个难点：sed流编辑器,建议专题学习，-i表示直接作用源文件 */
  //将build_version字段替换为'v0.1.2'
  shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file);
  //将包含`REMOVE_THIS_LINE`字符串的行删除
  shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file);
  //将包含`REPLACE_LINE_WITH_MACRO`字符串的行替换为`macro.js`中的内容
  shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat('macro.js'), file);
});

//返回上一级目录
shell.cd('..');

//run external tool synchronously
//即同步运行外部工具
if (shell.exec('git commit -am &quot;Auto-commit&quot;').code !== 0){
    shell.echo('Error: Git commit failed');
    shell.exit(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三.官方示例中涉及的命令解释&quot;&gt;三.官方示例中涉及的命令解释：&lt;/h4&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;shell.which(command)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在环境变量&lt;code&gt;PATH&lt;/code&gt;中寻找指定命令的地址，判断该命令是否可执行，返回该命令的绝对地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;echo&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在控制台输出指定内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;exit(code)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以退出码为&lt;code&gt;code&lt;/code&gt;退出当前进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;rm&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;删除一个目录中一个或多个&lt;em&gt;文件&lt;/em&gt;或&lt;em&gt;目录&lt;/em&gt;，一旦删除，无法恢复。 &lt;code&gt;常用参数&lt;/code&gt;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-f:强制删除文件;&lt;/li&gt;
&lt;li&gt;-i:删除之前先询问用户;&lt;/li&gt;
&lt;li&gt;-r:递归处理目录;&lt;/li&gt;
&lt;li&gt;-v:显示处理过程;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;cp([options,] source_array, dest)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用来将一个或多个源文件或目录复制到指定的文件或目录。 &lt;code&gt;常用参数&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-f:强制删除文件;&lt;/li&gt;
&lt;li&gt;-i:删除之前先询问用户;&lt;/li&gt;
&lt;li&gt;-r:递归处理目录;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;cd&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;切换工作目录至指定的相对路径或绝对路径。&lt;code&gt;cd..&lt;/code&gt;为返回上一级，&lt;code&gt;cd-&lt;/code&gt;回到前一目录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;ls&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用来显示目标列表。 &lt;code&gt;常用参数&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-a:显示所有文件;&lt;/li&gt;
&lt;li&gt;-C:多列显示查询结果;&lt;/li&gt;
&lt;li&gt;-l:单列长格式显示查询结果(与-C相反);&lt;/li&gt;
&lt;li&gt;-R:递归处理目录;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;sed([options,] search_regex, replacement, file_array&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将&lt;code&gt;file_array&lt;/code&gt;中符合&lt;code&gt;search_regex&lt;/code&gt;的内容替换为&lt;code&gt;replacement&lt;/code&gt;，支持正则的捕获组自引用。一次处理一行内容，处理完成后把缓冲区内容送往屏幕，然后处理下一行，循环直至结束。功能丰富且用法较复杂，建议自行百度进行专题学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-i:直接作用源文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;cat&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将一个或多个文件内容读入，指定一个文件时读入该文件，指定多个文件时将内容连接在一起读入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;exec(command,[, options][, callback])&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;执行所传入的命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;async:是否异步执行,默认&lt;code&gt;false&lt;/code&gt;，传入callback时自动开启&lt;/li&gt;
&lt;li&gt;slient:不输出信息到console,默认&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;encoding:默认&lt;code&gt;utf8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;四.文档中其他api概览&quot;&gt;四.文档中其他API概览&lt;/h4&gt;
&lt;ul readability=&quot;0.97697368421053&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;chmod&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置文件调用权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基本语法&lt;/strong&gt; ：chmod [-cfvR] [--help] [--version] mode file...&lt;/li&gt;
&lt;li&gt;-c：若文件权限确实被更改，才显示更改动作&lt;/li&gt;
&lt;li&gt;-f: 权限无法被更改时不显示错误信息&lt;/li&gt;
&lt;li&gt;-v: 显示权限变更的详细资料&lt;/li&gt;
&lt;li&gt;-R: 递归，对其目录下所有文件和子文件执行相同操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mode字段格式&lt;/strong&gt; : [ugoa...][[+-=][rwxX]...][,...]&lt;/li&gt;
&lt;li&gt;u表示该文件拥有者，g表示同一群体者，o表示其他，a表示所有&lt;/li&gt;
&lt;li&gt;+表示增加权限，-表示取消权限，=表示唯一设定权限&lt;/li&gt;
&lt;li&gt;r表示可读，w表示可写，x表示可执行，X表示当该文件是个子目录？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;find(path[,path...])&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;寻找路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;grep([options,] regex_filter,file)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;从指定文件中抓取符合正则的行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-v:翻转正则匹配&lt;/li&gt;
&lt;li&gt;-l:仅打印符合条件的文件名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;head([{'-n':,}] file)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;显示指定文件中的前N行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-n:显示前&lt;code&gt;&amp;lt;num&amp;gt;&lt;/code&gt;行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mv&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;移动文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;pwd&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回当前目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;rm&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;见上文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置全局变量的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;sort&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;将文件的内容逐行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-r:反转结果&lt;/li&gt;
&lt;li&gt;-n:依据数值对比&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;tail&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;读取指定文件的末尾n行，对比&lt;code&gt;head&lt;/code&gt;命令进行理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;test（）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;评估一个表达式是否为真(以下仅为最常见的参数用例)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-d,path:如果path是一个路径则返回&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-e,path:如果path存在则返回&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ShellString()&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;构造器，将一个字符串转化为Shell字符串,转化后的字符串支持链式调用特殊的shell命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;ShellString.Prototype.to()&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将&lt;code&gt;shellString&lt;/code&gt;输出至指定文件,相当于脚本语言中的&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;ShellString.Prototype.toEnd()&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将&lt;code&gt;shellString&lt;/code&gt;追加至指定文件,相当于脚本语言中的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;touch([options,]file)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;生成文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;env['VAR_NAME']&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;指向&lt;code&gt;process.env&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Pipes链式调用支持&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;sed&lt;/code&gt;,&lt;code&gt;grep&lt;/code&gt;,&lt;code&gt;cat&lt;/code&gt;,&lt;code&gt;exec&lt;/code&gt;,&lt;code&gt;to&lt;/code&gt;,&lt;code&gt;toEnd&lt;/code&gt;均支持链式调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我的博客即将入驻“云栖社区”，诚邀技术同仁一同入驻。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 15:05:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>《一统江湖的大前端》系列是自己的前端学习笔记，旨在介绍javascript在非网页开发领域的应用案例和发现各类好玩的js库，不定期更新。如果你对前端的理解还是写写页面绑绑事件，那你真的是有点OUT了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9632493.html</dc:identifier>
</item>
</channel>
</rss>