<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM总括三-字节码、字节码指令、JIT编译执行 - 程序员自我修养张振力</title>
<link>http://www.cnblogs.com/java-zzl/p/9862329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-zzl/p/9862329.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;JVM总括三-字节码、字节码指令、JIT编译执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;　　java文件编译后的class文件，java跨平台的中间层，JVM通过对字节码的&lt;strong&gt;解释执行&lt;/strong&gt;（执行模式，还有&lt;strong&gt;JIT编译执行&lt;/strong&gt;，下面讲解），屏蔽对操作系统的依赖。&lt;strong&gt;一个字节&lt;/strong&gt;（8位）可以储存&lt;strong&gt;256中不同的指令&lt;/strong&gt;，这样的指令就是字节码，java所有指令有200个左右，这些指令组成了字节码文件（.class）。&lt;/p&gt;
&lt;h3&gt;一、字节码的主要指令：&lt;/h3&gt;
&lt;p&gt;　　.class文件里面的十六进制文件（如：图一），其中&lt;strong&gt;CAFE BABE&lt;/strong&gt;是标志这个文件为java的编译后的文件，00000034代表版本号，01670700一个字节（8位）就是一个字节指令，由于数值指令太难看懂，我们可以用&lt;strong&gt;javap&lt;/strong&gt;将指令翻译为助记指令（如：图二）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463936/201810/1463936-20181027165538463-312222058.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;209&quot;/&gt;  图一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463936/201810/1463936-20181027170246425-1473453970.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;190&quot;/&gt;  图二&lt;/p&gt;
&lt;h4&gt;1、加载或储存指令&lt;/h4&gt;
&lt;p&gt;　　在栈帧中，通过指令操作数据在局部变量表与操作栈间传递。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ILOAD、ALOAD&lt;/strong&gt;：将int、对象引用类型从局部变量表压入操作栈顶；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISTORE、ASTORE&lt;/strong&gt;：将int、对象引用类型从操作栈顶储存到局部变量表里；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICONST、BIPUSH、SIPUSH、LDC&lt;/strong&gt;：将常亮加载到操作栈顶。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2、运算指令&lt;/h4&gt;
&lt;p&gt;　　对操作栈上的值进行运算，并把结果写入操作栈顶，如&lt;strong&gt;IADD、IMUL&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;3、类型转换指令&lt;/h4&gt;
&lt;p&gt;　&lt;strong&gt;　I2L、D2F&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;4、对象创建与访问指令&lt;/h4&gt;
&lt;p&gt; 　　&lt;strong&gt;NEW&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;除了字节码指令外，还包括像LINENUMBER储存字节码与源码对应，方便调试定位；LOCALVARIABLE储存当前方法使用到的局部表量表。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;二、java源码文件转化为字节码（.class）文件的过程&lt;/h3&gt;
&lt;p&gt; 　　&lt;strong&gt;JAVA源文件&lt;/strong&gt;----------&amp;gt;&lt;strong&gt;词法解析&lt;/strong&gt;----------&amp;gt;&lt;strong&gt;语法解析&lt;/strong&gt;----------&amp;gt;&lt;strong&gt;语义分析&lt;/strong&gt;---------&amp;gt;&lt;strong&gt;生成字节码&lt;/strong&gt;---------&amp;gt;&lt;strong&gt;字节码文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;词法分析&lt;/strong&gt;：根据空格分割出单词、操作符等，形成token信息流；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;语法分析&lt;/strong&gt;：根据token流和java语法规范生成语法树；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;语义分析&lt;/strong&gt;：检查关键字、类型匹配是否正确；&lt;/p&gt;
&lt;h3&gt;三、执行模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、解释执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;JVM通过加载到的字节码进行执行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、JIT编译执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;将热点代码（例如：高频方法体、循环体、公共模块）直接翻译成机器码，提高以后的执行效率；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、JIT编译执行与解释执行混合执行（主流JVM执行模式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;每次方法调用的时候，方法调用计数器加1，如果计数达到阈值，请求编译成机器码，将机器码放在Code cache里面，下次执行查看是否已编译成机器码，已编译的直接执行机器码，没有编译的通过解释执行（也就是执行字节码）；&lt;/p&gt;

</description>
<pubDate>Wed, 31 Oct 2018 15:36:00 +0000</pubDate>
<dc:creator>程序员自我修养张振力</dc:creator>
<og:description>字节码、字节码指令、JIT编译执行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-zzl/p/9862329.html</dc:identifier>
</item>
<item>
<title>程序学习之路: 前端取经秘笈集结（持续更新） - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9886590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9886590.html</guid>
<description>&lt;p&gt;🎃捣蛋万圣节福利！&lt;/p&gt;
&lt;div class=&quot;oneLevelTitle&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031165327210-1683989743.png&quot;/&gt;&lt;h4&gt;一、Halloween Happy！&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;今天万圣节, 是否已经按耐不住自己内心的小恶魔, 想早点下班狂欢！别着急, 咱们的上班摸鱼好朋友&lt;strong&gt;Google Doodles&lt;/strong&gt;今天又给我们推了几款'上班摸鱼'的万圣节游戏.玩起来, 时间简直不要过得飞快, 但是要注意身后的老板。&lt;/p&gt;
&lt;p&gt;google 纪念小游戏: &lt;a href=&quot;https://www.google.com/doodles/halloween-2018&quot; target=&quot;_blank&quot;&gt;《doodles》&lt;/a&gt; 或者google新建首页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031172437263-1011824901.png&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;oneLevelTitle&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031172551647-1121110137.png&quot;/&gt;&lt;h4&gt;二、前端资源汇总&lt;/h4&gt;
&lt;/div&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;玩够了就该回来学习啦！下面整理一下所有可能接触到的前端的知识以及好的参考文献链接地址供大家参考。方便大家、也方便自己查找资料&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;前端IDE/编辑器&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;VSCode&lt;/a&gt;： 个人觉得前端最好用的编辑器，而且免费。推荐使用&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.sublimetext.com/&quot; target=&quot;_blank&quot;&gt;sublime text 3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://notepad-plus-plus.org/download/v7.5.9.html&quot; target=&quot;_blank&quot;&gt;notepad++&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;个人比较不喜欢比较庞大的编辑器: HBuild、Webstorm.而且公司使用收费编辑器需要版权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;CSS&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;http://www.w3school.com.cn/css/index.asp&quot; target=&quot;_blank&quot;&gt;.css&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://lesscss.cn/&quot; target=&quot;_blank&quot;&gt;.less&lt;/a&gt;：个人(公司)用得比较多, 和sass没多大区别.能加快css开发效率(谁用谁知道)&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://sass.bootcss.com/&quot; target=&quot;_blank&quot;&gt;.sass&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;JavaScript&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://study.163.com/course/introduction/224014.htm&quot; target=&quot;_blank&quot;&gt;👍《智能社:JavaScript教程-从入门到精通》&lt;/a&gt;：石川老师讲得非常好, 我当初入门就是看的这网课&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.w3school.com.cn/js/index.asp&quot; target=&quot;_blank&quot;&gt;《W3C JavaScript 教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000&quot; target=&quot;_blank&quot;&gt;《廖雪峰JavaScript教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://javascript.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;《JavaScript 标准参考教程（alpha） -阮一峰》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://www.pansoso.com/zh/%E9%94%8B%E5%88%A9%E7%9A%84jquery&quot; target=&quot;_blank&quot;&gt;《锋利的JQuery》&lt;/a&gt;： jquery入门神器&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://blog.thankbabe.com/front/?hmsr=toutiao.io&amp;amp;source=toutiao&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot; target=&quot;_blank&quot;&gt;《JavaScript 秘密花园》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;ES2015(ES6)&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/ruanyf/es6tutorial&quot; target=&quot;_blank&quot;&gt;👍《ECMAScript 6入门第三版》 -阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://scq000.github.io/2016/11/05/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8BPromise%E5%92%8CAwait-Async/&quot; target=&quot;_blank&quot;&gt;《前端的异步解决方案之Promise和Await Async》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://segmentfault.com/a/1190000004365693&quot; target=&quot;_blank&quot;&gt;《30分钟掌握ES6/ES2015核心内容（上）》 -思否&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://segmentfault.com/a/1190000004368132&quot; target=&quot;_blank&quot;&gt;《30分钟掌握ES6/ES2015核心内容（下）》 -思否&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;前端基础面试&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers&quot; target=&quot;_blank&quot;&gt;赞《前端开发面试题》&lt;/a&gt;： 知识面非常广的前端面试题&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;NodeJs&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;http://nodeclass.com/&quot; target=&quot;_blank&quot;&gt;《Nodejs学习社区》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot;&gt;《NPM官网》&lt;/a&gt;： 经常在上面找一些好的开源包&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://nqdeng.github.io/7-days-nodejs&quot; target=&quot;_blank&quot;&gt;《七天学会NodeJS -Nanqiao Deng》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://koa.bootcss.com/&quot; target=&quot;_blank&quot;&gt;《koa2 官网》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;Webpack&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://www.jianshu.com/p/42e11515c10f&quot; target=&quot;_blank&quot;&gt;👍《入门Webpack，看这篇就够了》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9489444.html&quot; target=&quot;_blank&quot;&gt;《soyChat》&lt;/a&gt;：个人React+Webpack+Express实战项目&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://zhaoda.gitbooks.io/webpack/content/&quot; target=&quot;_blank&quot;&gt;《Webpack 中文指南》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;React&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://study.163.com/course/introduction/1003594007.htm&quot; target=&quot;_blank&quot;&gt;《智能社 React系列教学》&lt;/a&gt;： 入门基础&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://react.docschina.org/docs/hello-world.html&quot; target=&quot;_blank&quot;&gt;《React 中文文档》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ant.design/&quot; target=&quot;_blank&quot;&gt;👍《Zent UI》&lt;/a&gt;： 公司的开源项目，当然要大力推荐啦！&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ant.design/&quot; target=&quot;_blank&quot;&gt;《Ant-design》&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;微信小程序&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/&quot; target=&quot;_blank&quot;&gt;《微信小程序官方文档》&lt;/a&gt;： 你想要的这里都有&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://ant.design/&quot; target=&quot;_blank&quot;&gt;《wepy》&lt;/a&gt;： 微信官方框架&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/youzan/vant-weapp&quot; target=&quot;_blank&quot;&gt;👍《ZanUI-WeApp》&lt;/a&gt;： 公司的开源项目，当然要大力推荐啦！&lt;/p&gt;
&lt;div class=&quot;marginTop&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181031173129399-1828102113.png&quot;/&gt;&lt;h4&gt;其他&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/youzan/zan-proxy&quot; target=&quot;_blank&quot;&gt;👍《Zan-Proxy》&lt;/a&gt;： 公司的开源项目，当然要大力推荐啦！一款非常好用的调试线上代码的开源项目, 有了它再也不用担心发布线上了！&lt;/p&gt;
&lt;p&gt;-----未完待续------&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 15:27:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>🎃捣蛋万圣节福利！ 一、Halloween Happy！ 今天万圣节, 是否已经按耐不住自己内心的小恶魔, 想早点下班狂欢！别着急, 咱们的上班摸鱼好朋友Google Doodles今天又给我们推了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9886590.html</dc:identifier>
</item>
<item>
<title>#muduo学习笔记(二)Reactor关键结构 - 艾露米婭娜</title>
<link>http://www.cnblogs.com/ailumiyana/p/9886358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ailumiyana/p/9886358.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;reactor简述&quot;&gt;Reactor简述&lt;/h2&gt;
&lt;h3 id=&quot;什么是reactor&quot;&gt;什么是Reactor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reactor&lt;/code&gt;是一种基于事件驱动的设计模式，即通过回调机制,我们将事件的接口注册到Reactor上,当事件发生之后,就会回调注册的接口。&lt;br/&gt;&lt;code&gt;Reactor必要的几个组件&lt;/code&gt;：&lt;br/&gt;&lt;code&gt;Event Multiplexer事件分发器&lt;/code&gt;:即一些I/O复用机制select、poll、epoll等.程序将事件源注册到分发器上,等待事件的触发，做相应处理.&lt;br/&gt;&lt;code&gt;Handle事件源&lt;/code&gt;：用于标识一个事件，Linux上是文件描述符.&lt;br/&gt;&lt;code&gt;Reactor反应器&lt;/code&gt;：用于管理事件的调度及注册删除.当有激活的事件时,则调用回调函数处理，没有则继续事件循环.&lt;br/&gt;&lt;code&gt;event handler事件处理器&lt;/code&gt;：管理已注册事件和的调度，分成不同类型的事件(读/写,定时)当事件发生,调用对应的回调函数处理.&lt;/p&gt;
&lt;h3 id=&quot;reactor模型的优缺点&quot;&gt;Reactor模型的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;&lt;br/&gt;1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；&lt;br/&gt;2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；&lt;br/&gt;3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；&lt;br/&gt;4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;&lt;br/&gt;Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。&lt;/p&gt;
&lt;h2 id=&quot;poll简述&quot;&gt;poll简述&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;poll的使用方法与select相似，轮询多个文件描述符，有读写时设置相应的状态位，poll相比select优在没有最大文件描述符数量的限制.&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;# include &amp;lt;poll.h&amp;gt;
int poll ( struct pollfd * fds, unsigned int nfds, int timeout);

struct pollfd {
int fd;         /* 文件描述符 */
short events;         /* 等待的事件 */
short revents;       /* 实际发生了的事件 */
} ; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　每一个pollfd结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示poll()监视多个文件描述符。每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回。合法的事件如下：&lt;/p&gt;
&lt;p&gt;　　POLLIN 　　　　　　　　有数据可读。&lt;br/&gt;　　POLLRDNORM 　　　　 有普通数据可读。&lt;br/&gt;　　POLLRDBAND　　　　　 有优先数据可读。&lt;br/&gt;　　POLLPRI　　　　　　　　 有紧迫数据可读。&lt;br/&gt;　　POLLOUT　　　　　　 写数据不会导致阻塞。&lt;br/&gt;　　POLLWRNORM　　　　　 写普通数据不会导致阻塞。&lt;br/&gt;　　POLLWRBAND　　　　　 写优先数据不会导致阻塞。&lt;br/&gt;　　POLLMSGSIGPOLL 　　　　消息可用。&lt;/p&gt;
&lt;h3 id=&quot;poll使用样例&quot;&gt;poll使用样例&lt;/h3&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;

#define MAX_BUFFER_SIZE 1024
#define IN_FILES 1
#define MAX(a,b) ((a&amp;gt;b)?(a):(b))

int main(int argc ,char **argv)
{
  struct pollfd fds[3];
  char buf[1024];
  int i,res,real_read, maxfd;

  if((fds[0].fd=open(&quot;/dev/stdin&quot;,O_RDONLY|O_NONBLOCK)) &amp;lt; 0)
  {
    fprintf(stderr,&quot;open data1 error:%s&quot;,strerror(errno));
    return 1;
  }

  for (i = 0; i &amp;lt; IN_FILES; i++)
  {
    fds[i].events = POLLIN | POLLPRI;
  }

  while(1) //|| fds[1].events || fds[2].events)
  {
    int ret = poll(fds, 1, 1000);
    if (ret &amp;lt; 0)
    {
      printf(&quot;Poll error : %s\n&quot;,strerror(errno));
      return 1;
    }

    if(ret == 0){
      printf(&quot;Poll timeout\n&quot;);
      continue;
    }

    for (i = 0; i&amp;lt; 1; i++)
    {
      if (fds[i].revents)
      {
        memset(buf, 0, MAX_BUFFER_SIZE);
        real_read = read(fds[i].fd, buf, MAX_BUFFER_SIZE);
        if (real_read &amp;lt; 0)
        {
          if (errno != EAGAIN)
          {
            printf(&quot;read eror : %s\n&quot;,strerror(errno));
            continue;
          }
        }
        else if (!real_read)
        {
          close(fds[i].fd);
          fds[i].events = 0;
        }
        else
        {
          if (i == 0)
          {
            buf[real_read] = '\0';
            printf(&quot;%s&quot;, buf);
            if ((buf[0] == 'q') || (buf[0] == 'Q'))
            {
              printf(&quot;quit\n&quot;);
              return 1;
            }
          }
          else
          {
            buf[real_read] = '\0';
            printf(&quot;%s&quot;, buf);
          }
        }
      }
    }
  }

  exit(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;muduo-reactor关键结构&quot;&gt;muduo Reactor关键结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;muduo Reactor最核心的事件分发机制， 即将IO multiplexing拿到的IO事件分发给各个文件描述符（fd）的事件处理函数。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;channel&quot;&gt;Channel&lt;/h3&gt;
&lt;p&gt;Chanel目前我对它的理解是，它负责&lt;code&gt;管理一个文件描述符(file descript)IO事件.&lt;/code&gt;&lt;br/&gt;Channel会封装C的poll，把不同的IO事件分发到不同的回调：ReadCallBack、WriteCallBack等&lt;br/&gt;每个Channel对象自始至终只属于一个EventLoop，因此每个Channel对象都只属于某一个IO线程。 每个Channel对象自始至终只负责一个文件描述符（fd） 的IO事件分发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201810/1384555-20181031223231533-483231737.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef NET_CHANNEL_H
#define NET_CHANNEL_H

#include &amp;lt;functional&amp;gt;

#include &quot;EventLoop.hh&quot;

class Channel {
public:
  typedef std::function&amp;lt;void()&amp;gt; EventCallBack;
  Channel(EventLoop* loop, int fd);
  ~Channel();

  void handleEvent();
  void setReadCallBack(const EventCallBack&amp;amp; cb) { m_readCallBack = cb; }
  void setWriteCallBack(const EventCallBack&amp;amp; cb) { m_writeCallBack = cb; }
  void setErrorCallBack(const EventCallBack&amp;amp; cb) { m_errorCallBack = cb; }

  int fd() const { return m_fd; }
  int events() const { return m_events; }
  void set_revents(int revt) { m_revents = revt; }
  bool isNoneEvent() const { return m_events == kNoneEvent; }

  void eableReading() { m_events |=  kReadEvent; update(); }

  int index() { return m_index; }
  void set_index(int idx) { m_index =idx; }

  EventLoop* ownerLoop() { return m_pLoop; }

private:
  Channel&amp;amp; operator=(const Channel&amp;amp;);
  Channel(const Channel&amp;amp;);

  void update();

  static const int kNoneEvent;
  static const int kReadEvent;
  static const int kWriteEvent;

  EventLoop* m_pLoop;
  const int m_fd;
  int m_events;    // 等待的事件
  int m_revents;   // 实际发生了的事件
  int m_index;

  EventCallBack m_readCallBack;
  EventCallBack m_writeCallBack;
  EventCallBack m_errorCallBack;
};

#endif

//Channel.cpp

#include &amp;lt;poll.h&amp;gt;
#include &quot;Channel.hh&quot;
#include &quot;Logger.hh&quot;

const int Channel::kNoneEvent = 0;
const int Channel::kReadEvent = POLLIN | POLLPRI;
const int Channel::kWriteEvent = POLLOUT;

Channel::Channel(EventLoop* loop, int fd)
  : m_pLoop(loop),
    m_fd(fd),
    m_events(0),
    m_revents(0),
    m_index(-1)
{

}

Channel::~Channel()
{

}

void Channel::update()
{
  m_pLoop-&amp;gt;updateChannel(this);
}


void Channel::handleEvent()
{
  if(m_revents &amp;amp; POLLNVAL)
  {
    LOG_WARN &amp;lt;&amp;lt; &quot;Channel::handleEvent() POLLNVAL&quot;;
  }

  if(m_revents &amp;amp; (POLLERR | POLLNVAL)){
    if(m_errorCallBack) m_errorCallBack();
  }

  if(m_revents &amp;amp; (POLLIN | POLLPRI | POLLRDHUP)){
    if(m_readCallBack) m_readCallBack();
  }

  if(m_revents &amp;amp; POLLOUT){
    if(m_writeCallBack) m_writeCallBack();
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;值得一提的就是 Channel::update()它会调用EventLoop::updateChannel()， 后者会转而调&lt;br/&gt;用Poller::updateChannel()。Poller对象下面会讲，通过Poller::updateChannel()注册IO事件(即file descript).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Channel::handleEvent()是Channel的核心， 它由EventLoop::loop()调&lt;br/&gt;用， 它的功能是根据revents发生事件的的值分别调用不同的用户回调。 这个函数以后还会扩充。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;poller&quot;&gt;Poller&lt;/h3&gt;
&lt;p&gt;Poller class是IO multiplexing的封装。 它现在是个具体类，而在muduo中是个抽象基类，因为muduo同时支持poll(2)和epoll(4)两种IOmultiplexing机制。&lt;br/&gt;Poller是EventLoop的间接成员，只供其自己在EventLoop的IO线程中调用，因此无须加锁。其生命期与EventLoop相等。&lt;br/&gt;Poller并不拥有管理文件描述符事件的Channel， Channel在析构之前必须自己&lt;br/&gt;unregister（EventLoop::removeChannel()） ， 避免空悬指针&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#ifndef _NET_POLLER_HH
#define _NET_POLLER_HH

#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;

#include &quot;TimeStamp.hh&quot;
#include &quot;EventLoop.hh&quot;
#include &quot;Channel.hh&quot;

struct pollfd;

class Poller{
public:
  typedef std::vector&amp;lt;Channel*&amp;gt; ChannelList;

  Poller(EventLoop* loop);
  ~Poller();

  TimeStamp poll(int timeoutMs, ChannelList* activeChannels);

  void updateChannel(Channel* channel);

  void assertInLoopThread() { m_pOwerLoop-&amp;gt;assertInLoopThread(); }

private:
  Poller&amp;amp; operator=(const Poller&amp;amp;);
  Poller(const Poller&amp;amp;);

  void fillActiveChannels(int numEvents, ChannelList* activeChannels) const;

  typedef std::vector&amp;lt;struct pollfd&amp;gt; PollFdList;
  typedef std::map&amp;lt;int, Channel*&amp;gt; ChannelMap;

  EventLoop* m_pOwerLoop;
  PollFdList m_pollfds;
  ChannelMap m_channels;

};

#endif

//Poller.cpp
#include &quot;Poller.hh&quot;
#include &quot;Logger.hh&quot;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;

Poller::Poller(EventLoop* loop)
  : m_pOwerLoop(loop)
{

}

Poller::~Poller()
{

}

TimeStamp Poller::poll(int timeoutMs, ChannelList* activeChannels)
{
  LOG_TRACE &amp;lt;&amp;lt; &quot;Poller::poll()&quot;;
  int numEvents = ::poll(/*&amp;amp;*m_pollfds.begin()*/m_pollfds.data(), m_pollfds.size(), timeoutMs);
  TimeStamp now(TimeStamp::now());
  if(numEvents &amp;gt; 0){
    LOG_TRACE &amp;lt;&amp;lt; numEvents &amp;lt;&amp;lt; &quot; events happended&quot;;
    fillActiveChannels(numEvents, activeChannels);
  }
  else if(numEvents == 0){
    LOG_TRACE &amp;lt;&amp;lt; &quot; nothing happended&quot;;
  }
  else{
    LOG_SYSERR &amp;lt;&amp;lt; &quot;Poller::poll()&quot;;
  }

  return now;
}

/*
 *fillActiveChannels()遍历m_pollfds， 找出有活动事件的fd， 把它对应
 *的Channel填入activeChannels。
 */

void Poller::fillActiveChannels(int numEvents, ChannelList* activeChannels) const
{
  for(PollFdList::const_iterator pfd = m_pollfds.begin();
      pfd != m_pollfds.end() &amp;amp;&amp;amp; numEvents &amp;gt; 0; ++pfd)
  {
    if(pfd-&amp;gt;revents &amp;gt; 0)
    {
      --numEvents;
      ChannelMap::const_iterator ch = m_channels.find(pfd-&amp;gt;fd);
      assert(ch != m_channels.end());
      Channel* channel = ch-&amp;gt;second;
      assert(channel-&amp;gt;fd() == pfd-&amp;gt;fd);
      channel-&amp;gt;set_revents(pfd-&amp;gt;revents);
      activeChannels-&amp;gt;push_back(channel);
    }
  }
}

void Poller::updateChannel(Channel* channel)
{
  assertInLoopThread();
  LOG_TRACE &amp;lt;&amp;lt; &quot;fd= &quot; &amp;lt;&amp;lt; channel-&amp;gt;fd() &amp;lt;&amp;lt; &quot; events&quot; &amp;lt;&amp;lt; channel-&amp;gt;events();
  if(channel-&amp;gt;index() &amp;lt; 0){
    //a new one , add to pollfds
    assert(m_channels.find(channel-&amp;gt;fd()) == m_channels.end());
    struct pollfd pfd;
    pfd.fd = channel-&amp;gt;fd();
    pfd.events = static_cast&amp;lt;short&amp;gt;(channel-&amp;gt;events());
    pfd.revents = 0;
    m_pollfds.push_back(pfd);
    int idx = static_cast&amp;lt;int&amp;gt;(m_pollfds.size()) - 1;
    channel-&amp;gt;set_index(idx);
    m_channels[pfd.fd] = channel;

  }
  else{
    //update existing one
    assert(m_channels.find(channel-&amp;gt;fd()) != m_channels.end());
    assert(m_channels[channel-&amp;gt;fd()] == channel);
    int idx = channel-&amp;gt;index();
    assert(0 &amp;lt;= idx &amp;amp;&amp;amp; idx &amp;lt; static_cast&amp;lt;int&amp;gt;(m_pollfds.size()));
    struct pollfd&amp;amp; pfd = m_pollfds[idx];
    assert(pfd.fd == channel-&amp;gt;fd() || pfd.fd == -1);
    pfd.events = static_cast&amp;lt;short&amp;gt;(channel-&amp;gt;events());
    pfd.revents = 0;
    if(channel-&amp;gt;isNoneEvent()){
      //ignore this pollfd
      pfd.fd = -1;
    }
  }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;eventloop&quot;&gt;EventLoop&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;EventLopp在上一篇文章写过,这里给出改动.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;EventLoop 新增了quit()成员函数， 还加了几个数据成员，并在构造函数里初始化它们。注意EventLoop通过智能指针来间接持有poller.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+class Poller;
+class Channel;

class EventLoop
------------
    bool isInloopThread() const {return m_threadId == CurrentThread::tid(); }

    +void quit();
    +void updateChannel(Channel* channel);

    static EventLoop* getEventLoopOfCurrentThread();

private:
    EventLoop&amp;amp; operator=(const EventLoop&amp;amp;);
    EventLoop(const EventLoop&amp;amp;);

    void abortNotInLoopThread();

    +typedef std::vector&amp;lt;Channel*&amp;gt; ChannelList;

    bool m_looping;
    +bool m_quit;
    const pid_t m_threadId;
    +std::unique_ptr&amp;lt;Poller&amp;gt; m_poller;
    +ChannelList m_activeChannels;
};

//EventLoop.cpp
  m_threadId(CurrentThread::tid()),
 + m_poller(new Poller(this))
{
------
+void EventLoop::quit()
+{
+  m_quit = true;
+  //wakeup();
+}
+
+void EventLoop::updateChannel(Channel* channel)
+{
+  assert(channel-&amp;gt;ownerLoop() == this);
+  assertInLoopThread();
+  m_poller-&amp;gt;updateChannel(channel);
+}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一篇文章的EventLoop-&amp;gt;loop()什么也没做,现在它有了实实在在的使命，&lt;code&gt;它调用Poller::poll()获得当前活动事件的Chanel列表， 然后依次调用每个Channel的handleEvent()函数&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void EventLoop::loop()
{
  assert(!m_looping);
  assertInLoopThread();
  m_looping = true;
  m_quit = false;

  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop &quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &quot; start loopig&quot;;

  while(!m_quit)
  {
    m_activeChannels.clear();
    m_poller-&amp;gt;poll(1000, &amp;amp;m_activeChannels);
    for(ChannelList::iterator it = m_activeChannels.begin();
      it != m_activeChannels.end(); ++it)
    {
      (*it)-&amp;gt;handleEvent();
    }

  }

  LOG_TRACE &amp;lt;&amp;lt; &quot;EventLoop &quot; &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &quot; stop loopig&quot;;
  m_looping = false;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reactor时序图&quot;&gt;Reactor时序图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1384555/201810/1384555-20181031223138159-1743991001.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试程序-单次触发的定时器&quot;&gt;测试程序-单次触发的定时器&lt;/h3&gt;
&lt;p&gt;程序利用timerfd_create 把时间变成了一个文件描述符，该“文件”在定时器超时的那一刻变得可读，这样就能很方便地融入到 select/poll 框架中，用统一的方式来处理 IO 事件和超时事件，这也正是 Reactor 模式的长处。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;strings.h&amp;gt;

#include &quot;EventLoop.hh&quot;
#include &quot;Channel.hh&quot;
#include &quot;Poller.hh&quot;

//Reactor Test
//单次触发定时器
#include &amp;lt;sys/timerfd.h&amp;gt;

EventLoop* g_loop;

void timeout()
{
  printf(&quot;timeout!\n&quot;);
  g_loop-&amp;gt;quit();
}

int main()
{

  EventLoop loop;
  g_loop = &amp;amp;loop;

  int timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK |TFD_CLOEXEC);

  Channel channel(&amp;amp;loop, timerfd);
  channel.setReadCallBack(timeout);
  channel.eableReading();

  struct itimerspec howlong;
  bzero(&amp;amp;howlong, sizeof howlong);
  howlong.it_value.tv_sec = 3;
  timerfd_settime(timerfd, 0, &amp;amp;howlong, NULL);

  loop.loop();

  close(timerfd);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt; ./test.out 
2018-10-31 22:25:54.532487 [TRACE] [EventLoop.cpp:16] [EventLoop] EventLoop Create 0x7FFEB9567CC0 in thread 3075
2018-10-31 22:25:54.533563 [TRACE] [Poller.cpp:64] [updateChannel] fd= 3 events3
2018-10-31 22:25:54.534000 [TRACE] [EventLoop.cpp:41] [loop] EventLoop 0x7FFEB9567CC0 start loopig
2018-10-31 22:25:54.534334 [TRACE] [Poller.cpp:20] [poll] Poller::poll()
2018-10-31 22:25:55.535827 [TRACE] [Poller.cpp:28] [poll]  nothing happended
2018-10-31 22:25:55.536287 [TRACE] [Poller.cpp:20] [poll] Poller::poll()
2018-10-31 22:25:56.538334 [TRACE] [Poller.cpp:28] [poll]  nothing happended
2018-10-31 22:25:56.538802 [TRACE] [Poller.cpp:20] [poll] Poller::poll()
2018-10-31 22:25:57.534175 [TRACE] [Poller.cpp:24] [poll] 1 events happended
timeout!
2018-10-31 22:25:57.534766 [TRACE] [EventLoop.cpp:55] [loop] EventLoop 0x7FFEB9567CC0 stop loopig
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 31 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>艾露米婭娜</dc:creator>
<og:description>muduo学习笔记(二)Reactor关键结构 [TOC] Reactor简述 什么是Reactor 是一种基于事件驱动的设计模式，即通过回调机制,我们将事件的接口注册到Reactor上,当事件发生之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ailumiyana/p/9886358.html</dc:identifier>
</item>
<item>
<title>前端入门5-CSS弹性布局flex - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9886038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9886038.html</guid>
<description>&lt;p&gt;本系列文章内容全部梳理自以下四个来源：&lt;/p&gt;
&lt;p&gt;作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。&lt;/p&gt;

&lt;p&gt;弹性布局的作用有点儿类似 Android 中 LinearLayout 和 RelativeLayout 两者的合成版，即：支持横向布局，纵向布局，start，end，center 布局，宽高按比例瓜分等等，当然它还有很多其他功能，比如自动换行，按指定 order 排列等。总之有了 Android 基础，理解弹性布局 flex 蛮容易的。&lt;/p&gt;
&lt;p&gt;可以这么的理解，传统的网页布局方式是通过 display 和 position 以及 float 三者完成的，借助块级元素，行内元素特性，结合 position 指定的相对布局、绝对布局、固定布局方式来实现各种排版效果。如果需要浮动，则借助 float。&lt;/p&gt;
&lt;p&gt;但这种传统的方式，一来使用较复杂，二来某些排版效果不好实现，如列表、居中、响应式布局等效果。&lt;/p&gt;
&lt;p&gt;而 flex 则能够很好的完成传统的布局工作，而且，它还可以支持响应式布局。&lt;/p&gt;
&lt;h3 id=&quot;基础概念&quot;&gt;1.基础概念&lt;/h3&gt;
&lt;h4 id=&quot;两根轴线&quot;&gt;两根轴线&lt;/h4&gt;
&lt;p&gt;当使用 flex 布局时，首先想到的是两根轴线：主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关, 所以有必要在一开始首先理解它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-08cdf2e794ab15ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；因为 flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。&lt;/p&gt;
&lt;h4 id=&quot;布局空白&quot;&gt;布局空白&lt;/h4&gt;
&lt;p&gt;布局空白：available space，大概来说，flex 容器大小扣掉 items 的 flex-basis 指定的占据的空间大小之外剩余的区域，flex-basis 通常是指 item 本身的大小，当然也可以手动设置。&lt;/p&gt;
&lt;p&gt;flex 的一些属性就是通过改变 flex 容器中的布局空白分配来达到对齐等效果的。&lt;/p&gt;
&lt;p&gt;比如 items 的 flex-grow 拉伸或者 flex 容器的 justify-content 主轴对齐等，其实就是将这些布局空白按照不同算法分配给各个 item，分给 item 时，是要直接填充进 item 的内容里达到拉伸效果，还是就简单的将空白围绕在 item 周围达到类似 margin 效果来实现 item 的居中、靠左、靠右、均分等对齐方式。&lt;/p&gt;
&lt;p&gt;具体属性不了解没关系，下面的章节会讲，知道概念即可。&lt;/p&gt;
&lt;h3 id=&quot;flex相关属性&quot;&gt;2.flex相关属性&lt;/h3&gt;
&lt;p&gt;对任意块级元素标签设置 display: flex 即可让这个元素作为 flex 容器存在，也就可以使用 flex 的相关属性了。&lt;/p&gt;
&lt;p&gt;flex 的属性并不多，目前只有 13 个，其中有 7 个是 flex 弹性盒子容器本身所使用的属性，6 个是 flex-item 弹性盒子的子项使用的属性。其中，有些属性只是将其他属性的集中简化使用，因此，真正具有布局用途的属性并不多，很好掌握。&lt;/p&gt;
&lt;p&gt;作用于 flex 弹性盒子容器身上的属性：&lt;/p&gt;
&lt;h4 id=&quot;flex-direction&quot;&gt;flex-direction&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-direction: row(default) | row-reverse | column | column-reverse&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置主轴的方向，flex 分主轴和交叉轴两个概念，items 布局时，默认延主轴方向进行，因此通过设置主轴是水平方向还是垂直方向就可以实现 items 的水平或垂直布局。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;row：默认值，设置主轴为水平方向&lt;/li&gt;
&lt;li&gt;column：设置主轴为垂直方向&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他属性就不介绍了，因为主轴方向就两个，要么水平，要么垂直，其他的区别仅在于水平时是从左到右，还是从右到左，所以这个属性的影响因素之一的 LTR 和 RTL，但没必要考虑这么多，这些场景应该不多，知道这个是用来设置主轴方向就够了，我觉得。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-fc89a44d228d398d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-direction&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-wrap&quot;&gt;flex-wrap&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-wrap: nowrap(default) | wrap | wrap-reverse&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置是否允许换行，默认值 nowrap。&lt;/p&gt;
&lt;p&gt;当设置了 wrap 时，允许 items 在主轴方向溢出时自动进行换行布局，这点可以很好的用来实现响应式布局，比如当空间逐渐缩小时，原本水平排列的控件换成垂直方向排版。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9a74643008a31410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-wrap&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-flow&quot;&gt;flex-flow&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-flow: &amp;lt;'flex-direction'&amp;gt; || &amp;lt;'flex-wrap'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个属性并没有另外的含义，它只是 flex-direction 和 flex-wrap 的简写用法而已。&lt;/p&gt;
&lt;p&gt;如果你不想单独使用上述两个属性，可以将它们一起在 flex-flow 使用，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-flow: row wrap
//等效于
flex-direction: row;
flex-wrap: wrap;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;justify-content&quot;&gt;justify-content&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;justify-content: normal(default) | &amp;lt;content-distribution&amp;gt; | &amp;lt;overflow-position&amp;gt;? [ &amp;lt;content-position&amp;gt; | left | right ]
where 
&amp;lt;content-distribution&amp;gt; = space-between | space-around | space-evenly | stretch
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;content-position&amp;gt; = center | start | end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 items 在主轴方向上的对齐方式，可以靠左，靠右，居中或者按比例均分等效果。&lt;/p&gt;
&lt;p&gt;需要先明确一点概念，对齐是指 items 在 flex 容器中的排版对齐方式，那么要想 flex 容器可以控制 items 的对齐方式，那主轴方向上自然就还需要有布局空白，如果都没有布局空白了，不就表明 items 已充满 flex 容器了，那谈何对齐。&lt;/p&gt;
&lt;p&gt;那么，如果存在至少一个 item，它的 flex-grow 属性不等于 0，justify-content 这个属性就失效了，因为 flex-grow 表示允许 item 按照比例瓜分布局空白，这样一来布局空白被瓜分完了，flex 容器在主轴方向上已被 items 充满， 也就没有对齐一说了。&lt;/p&gt;
&lt;p&gt;所以要能够正确的使用该属性来控制 items 在主轴方向的对齐方式，那么就需要注意 item 中会影响布局空白的属性，如 flex-grow，flex-basis 这些的使用。&lt;/p&gt;
&lt;p&gt;下面看看各属性值介绍（下面的介绍不考虑 RTL 的情况，默认都以 LTR 为主）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;start：主轴是水平方向的话，左对齐方式排版；主轴是垂直方向的话，上对齐方式排版；&lt;/li&gt;
&lt;li&gt;end：主轴是水平方向的话，右对齐方式排版；主轴是垂直方向的话，下对齐方式排版；&lt;/li&gt;
&lt;li&gt;center：居中方式排版；&lt;/li&gt;
&lt;li&gt;space-between：等比例瓜分布局空白，每行首元素对齐，末元素对齐，每行各元素间距一致；&lt;/li&gt;
&lt;li&gt;space-around：与上述的类似效果，区别仅在于，每行首元素并不是在 flex 容器内容区域左边就开始布局，它距离 flex 容器左边的距离等于各个元素之间间距的一半。说白点，就是行首元素和末尾元素的周边有类型 margin 值存在。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;剩余的属性值不介绍了，因为我也还没有搞懂它们的含义和应用场景。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-196cce807ce5f660.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;justify-content&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )&lt;/p&gt;
&lt;h4 id=&quot;align-items&quot;&gt;align-items&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;align-items: normal | stretch | &amp;lt;baseline-position&amp;gt; | [ &amp;lt;overflow-position&amp;gt;? &amp;lt;self-position&amp;gt; ]
where 
&amp;lt;baseline-position&amp;gt; = [ first | last ]? baseline
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;self-position&amp;gt; = center | start | end | self-start | self-end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于控制 items 在交叉轴方向上的排版布局方式，justify-content 是能控制主轴上的排版，而这个属性则是用于控制交叉轴，通常两个都会一起使用，相互结合，可以达到一些类似页面居中效果。&lt;/p&gt;
&lt;p&gt;看看属性值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flex-start：交叉轴方向，从起点开始布局排版&lt;/li&gt;
&lt;li&gt;flex-end：交叉轴方向，从末尾开始布局排版&lt;/li&gt;
&lt;li&gt;center：交叉轴方向，从中间开始布局排版&lt;/li&gt;
&lt;li&gt;stretch：交叉轴方向，如果 items 在交叉轴方向没有设置大小，那么让 items 在交叉轴的方向充满 flex 容器的高度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他属性不介绍了，不熟悉。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-6ce0c20a2721cd63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-items&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )&lt;/p&gt;
&lt;p&gt;stretch 要能够生效，需要在 items 在交叉轴方向的不设置大小，如上图中主轴是水平方向，那么 items 需要不设置 height，此时 stretch 才能够让 items 拉伸占据交叉轴的高度。&lt;/p&gt;
&lt;p&gt;有一点需要注意，当 flex 容器的 items 在主轴方向上只有一行时，可以很明确的使用这个属性来控制在交叉轴的排版方式。但，如果 items 在主轴上超过一行，那么最终的效果可能就不是想要的了，比如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-bac610aee3b3dddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-items2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是想实现多行的 items 都作为一个整体居中，那么用 align-items 就无法实现了，针对这种有多行的情况，需要用另外一个属性来控制：align-content。&lt;/p&gt;
&lt;h4 id=&quot;align-content&quot;&gt;align-content&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;align-content: normal | &amp;lt;baseline-position&amp;gt; | &amp;lt;content-distribution&amp;gt; | &amp;lt;overflow-position&amp;gt;? &amp;lt;content-position&amp;gt;
where 
&amp;lt;baseline-position&amp;gt; = [ first | last ]? baseline
&amp;lt;content-distribution&amp;gt; = space-between | space-around | space-evenly | stretch
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;content-position&amp;gt; = center | start | end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 flex 容器的 items 设置了溢出换行属性，且当前在交叉轴方向上存在多行 item 的情况下，该属性才会生效。&lt;/p&gt;
&lt;p&gt;网上有种翻译，说这个属性是用于轴对齐，我不是很理解，我自己粗俗的分两种情况理解：&lt;/p&gt;
&lt;p&gt;当需要进行 start, center, end 这些排版时，是将这些多行的 items 都看成一个整体，然后进行交叉轴方向上的排版控制。此时，将多行 item 看成一行之后，那么这个 align-content 之后的排版布局就跟 align-items 一样的效果了。&lt;/p&gt;
&lt;p&gt;其他的 space-around，space-between 究竟是如何计算排版的，不熟悉。&lt;/p&gt;
&lt;p&gt;属性值含义不看了，跟 align-items 一样的效果，直接看示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a4b4b11bb9799c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-content&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )&lt;/p&gt;
&lt;h4 id=&quot;place-content&quot;&gt;place-content&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;place-content: &amp;lt;'align-content'&amp;gt; &amp;lt;'justify-content'&amp;gt;?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个属性并没有另外的含义，它只是 align-content 和 justify-content 的简写用法而已。&lt;/p&gt;
&lt;p&gt;如果你不想单独使用上述两个属性，可以将它们一起在 place-content 使用，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;place-content: center center
//等效于
align-content: center;
justify-content: center;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作用于 flex-item 弹性盒子的子项身上的属性：&lt;/p&gt;
&lt;h4 id=&quot;flex-basis&quot;&gt;flex-basis&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-basis: content | &amp;lt;'width'&amp;gt;

where 
&amp;lt;'width'&amp;gt; = [ &amp;lt;length&amp;gt; | &amp;lt;percentage&amp;gt; ] &amp;amp;&amp;amp; [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 items 在主轴方向的大小，如果主轴是水平方向，相当于设置 width，此时，该属性值会覆盖掉 width 设置的大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-abb7feeb207f305d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ps&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尝试了下，在 chorme 浏览器上 content 属性不生效，不清楚，可能不同浏览器行为还不一样，既然这样，就先暂时不深入了解这个属性了，大概知道用于设置主轴方向上的 item 大小即可。&lt;/p&gt;
&lt;p&gt;就算要使用，先直接用指定数值大小的方式好了。&lt;/p&gt;
&lt;h4 id=&quot;flex-grow&quot;&gt;flex-grow&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-grow: &amp;lt;number&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 item 在主轴方向上的拉伸因子，即如果 flex 容器还有剩余空间，会按照各 item 设置的拉伸因子比例关系分配。默认值为 0，即不拉伸。&lt;/p&gt;
&lt;p&gt;作用很像 Andorid 中的 LinearLayout 的 child 里设置了 layout_weight 用途一样。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-28701dfa2bfefc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-grow&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-shrink&quot;&gt;flex-shrink&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-shrink: &amp;lt;number&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于设置 item 在主轴方向上的收缩因子，跟 flex-grow 刚好反着来。当 flex 容器空间不够，item 要溢出时，设置次属性可控制 item 按比例进行相应收缩，以便不让 item 溢出，默认 1，值越大收缩倍数越大，最后 item 就越小，0 表示不收缩，负值无效。&lt;/p&gt;
&lt;p&gt;另外，如果设置了换行属性，那么这个就无效了。换行和收缩都是用于解决 item 在主轴方向上溢出的问题，既然是互斥，且换行优先级高，那么设置了换行，就不会再对 item 进行收缩了。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-456ce486db29b432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;flex-shrink&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex&quot;&gt;flex&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex: none | auto | initial | [ &amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt;? || &amp;lt;'flex-basis'&amp;gt; ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这属性是 flex-grow，flex-shrink，flex-basis 三个属性的简化使用，有三种属性值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;none：元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应flex容器。相当于将属性设置为 &lt;code&gt;flex: 0 0 auto&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;auto：元素会根据自身的宽度与高度来确定尺寸，但是会自行伸长以吸收flex容器中额外的自由空间，也会缩短至自身最小尺寸以适应容器。这相当于将属性设置为 &lt;code&gt;flex: 1 1 auto&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;initial：属性默认值， 元素会根据自身宽高设置尺寸。它会缩短自身以适应容器，但不会伸长并吸收flex容器中的额外自由空间来适应容器 。相当于将属性设置为&quot;&lt;code&gt;flex: 0 1 auto&lt;/code&gt;&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;flex 属性可以指定 1 个，2 个或 3 个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单值语法&lt;/strong&gt;: 值必须为以下其中之一:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个无单位&lt;strong&gt;数(&amp;lt;number&amp;gt;)&lt;/strong&gt;: 它会被当作 &lt;code&gt;&amp;lt;flex-grow&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个有效的&lt;strong&gt;宽度(width)&lt;/strong&gt;值: 它会被当作 &lt;code&gt;&amp;lt;flex-basis&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关键字 &lt;code&gt;none, auto&lt;/code&gt;,或&lt;code&gt;initial&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;双值语法&lt;/strong&gt;: 第一个值必须为一个无单位数，并且它会被当作&lt;code&gt;&amp;lt;flex-grow&amp;gt;的值。第二个值必须为以下之一：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个无单位数：它会被当作&lt;code&gt;&amp;lt;flex-shrink&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个有效的宽度值: 它会被当作&lt;code&gt;&amp;lt;flex-basis&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三值语法:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个值必须为一个无单位数，并且它会被当作&lt;code&gt;&amp;lt;flex-grow&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二个值必须为一个无单位数，并且它会被当作 &lt;code&gt;&amp;lt;flex-shrink&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三个值必须为一个有效的宽度值， 并且它会被当作&lt;code&gt;&amp;lt;flex-basis&amp;gt;的值。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;align-self&quot;&gt;align-self&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;align-self: auto | normal | stretch | &amp;lt;baseline-position&amp;gt; | &amp;lt;overflow-position&amp;gt;? &amp;lt;self-position&amp;gt;
where 
&amp;lt;baseline-position&amp;gt; = [ first | last ]? baseline
&amp;lt;overflow-position&amp;gt; = unsafe | safe
&amp;lt;self-position&amp;gt; = center | start | end | self-start | self-end | flex-start | flex-end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于给单个 item 设置交叉轴方向上的排版布局方式，属性值和作用跟 align-items 一样，区别仅在于 align-items 是 flex 容器的属性，它会作用于所有的 items 上；而 align-self 允许对单个 item 设置，该值会覆盖 align-items 设置的属性值。&lt;/p&gt;
&lt;p&gt;这样就可以实现控制交叉轴上的每个 item 的不同布局方式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-5ee64d58ee132497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;align-items&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;order&quot;&gt;order&lt;/h4&gt;
&lt;p&gt;语法格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;order: &amp;lt;integer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用于控制 items 的排版顺序，item 将按照 order 属性值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局。默认值为 0，可设置负值，排序将在默认不设置的 item 前面。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-326dd86eb0d1ee85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;order&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;我觉得，这些属性大体记得每个属性的主要用途即可，至于每个属性值如何设置，如何相互结合使用可以达到什么样的效果，写代码的时候再调就是了。&lt;/p&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;3.应用场景&lt;/h3&gt;
&lt;p&gt;以下场景中，如没有特别指明，flex 容器基本样式和 item 基本样式如下：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.flex
{
    width: 200px;
    height: 200px;
    border-radius: 20px;
    background-color: #FFFFFF;
}

.dot {
    width: 50px;
    font-size: 28px;
    line-height: 50px;
    text-align: center;
    color: #FFFFFF;
    height: 50px;
    border-radius: 25px;
    background-color: black;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;长这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9f2db5850a9a9d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;基本样式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;白色区域是 flex 容器，黑色圆圈是 item。&lt;/p&gt;
&lt;h4 id=&quot;场景1&quot;&gt;场景1:&lt;/h4&gt;
&lt;p&gt;在页面中把一个元素居中：item 水平、垂直方向都居中&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
    justify-content: center;/*水平居中*/
    align-items: center;/*垂直居中*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-a51d6aced1b8644f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景1&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;场景2&quot;&gt;场景2：&lt;/h4&gt;
&lt;p&gt;前后有固定大小 item，中间区域自动拉伸占据可用空间。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style &amp;gt;
.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;flex&quot;&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; style=&quot;flex-grow: 1&quot;&amp;gt;2&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;3&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-bbf735fb6e50cfbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景2&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;场景3&quot;&gt;场景3：&lt;/h4&gt;
&lt;p&gt;响应式布局，在屏幕尺寸允许的情况下呈水平布局，但是在屏幕不允许的情况下可以水平折叠。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
    flex-wrap: wrap;/*溢出时换行*/
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-2624d00b8b06428e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景3&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;场景4&quot;&gt;场景4：&lt;/h4&gt;
&lt;p&gt;水平排列的一组 item 中，前几个左对齐，后几个右对齐。&lt;/p&gt;
&lt;p&gt;这个需要结合块级元素的 margin 属性使用，当设置 margin: auto 时表示，将尽可能占据足够多的空间。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;style &amp;gt;
.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&quot;flex&quot;&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; &amp;gt;2&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;dot&quot; margin-left=&quot;auto&quot;&amp;gt;3&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-43f4d7ec238e1ad8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;场景4&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 13:28:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>声明 本系列文章内容全部梳理自以下四个来源： 《HTML5权威指南》 《JavaScript权威指南》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9886038.html</dc:identifier>
</item>
<item>
<title>Vue.js-03：第三章 - 事件修饰符的使用 - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/9846097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/9846097.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; 一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　熟悉了 Vue 的指令系统后，在实际开发中，不可避免的会使用到对于事件的操作，如何处理 DOM 事件流，成为我们必须要掌握的技能。不同于传统的前端开发，在 Vue 中给我们提供了事件修饰符这一利器，使我们可以便捷的处理 DOM 事件，本章，一起来学习如何使用事件修饰符来实现对于 DOM 事件流的操作。&lt;/p&gt;
&lt;p&gt;　　学习系列目录地址：&lt;a href=&quot;https://www.cnblogs.com/danvic712/p/9549100.html&quot; target=&quot;_black&quot;&gt;https://www.cnblogs.com/danvic712/p/9549100.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　仓储地址：&lt;a href=&quot;https://github.com/Lanesra712/VueTrial/tree/master/Chapter01-Rookie/directives&quot; target=&quot;_blcak&quot;&gt;https://github.com/Lanesra712/VueTrial/tree/master/Chapter01-Rookie/directives&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 二、干货合集&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;　　&lt;strong&gt;1、 DOM 事件流&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　有时，当我们需要完成页面中的某些功能时，我们要在需要实现功能的页面元素上使用 v-on 指令去监听 DOM 事件，在 html4 时代浏览器如何确定页面的哪一部分会拥有特定的事件时，IE 和 Netscape 的开发团队提出了两个截然相反的概念。这一差异，也使我们在写代码中需要考虑如何去处理 DOM 的事件细节。为了解决这一问题，vue 给我们提供了事件修饰符这一利器，它使我们的方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。&lt;/p&gt;
&lt;p&gt;　　一些涉及到概念：&lt;/p&gt;
&lt;p&gt;　　a）事件：用户设定或者是浏览器自身执行的某种动作。例如click(点击)、load(加载)、mouseover(鼠标悬停)、change(改变)等等&lt;/p&gt;
&lt;p&gt;　　b）事件处理程序：为了实现某个事件的功能而构建的函数方法，也可称为事件监听器&lt;/p&gt;
&lt;p&gt;　　c）DOM 事件流：描述的是从页面中接收事件的顺序,也可理解为事件在页面中传播的顺序&lt;/p&gt;
&lt;p&gt;　　在 DOM 事件流中存在着三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。&lt;/p&gt;
&lt;p&gt;　　a）事件捕获（event capture）:当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始&lt;strong&gt;由外到内&lt;/strong&gt;进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件&lt;/p&gt;
&lt;p&gt;　　b）事件冒泡（event bubbing）:当鼠标点击或者触发 DOM 事件时，浏览器会从根节点开始&lt;strong&gt;由内到外&lt;/strong&gt;进行事件传播，即点击了子元素，则先触发子元素绑定的事件，逐步扩散到父元素绑定的事件&lt;/p&gt;
&lt;p&gt;　　之前我们提到的 IE 和 Netscape 的开发团队提出了两个截然相反的事件流概念，IE 采取的是事件冒泡流，而标准的浏览器的事件流则是事件捕获流。所以，为了兼容 IE 我们需要改变某些的写法。&lt;/p&gt;
&lt;h4&gt;　　&lt;strong&gt;2、 事件修饰符&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　a）.stop：阻止事件冒泡&lt;br/&gt;　　在下面的示例中，我们分别创建了一个 button 的点击事件和外侧的 div 的点击事件，根据事件的冒泡机制我们可以得知，当我们点击了按钮之后，会扩散到父元素，从而触发父元素的点击事件，具体的结果也如下图所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;divDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;divHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        data: {},
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        methods: {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            divHandlerClick() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是div的点击事件！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            btnHandlerClick() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是button的点击事件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这时候，如果我们不希望出现事件冒泡，则可以使用 Vue 内置的修饰符便捷的阻止事件冒泡的产生。因为我们是点击 button 后产生的事件冒泡，我们只需要在 button 的点击事件上加上 stop 修饰符即可，示例代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click.stop&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031205629743-566164568.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b）.prevent：阻止默认事件&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　阻止默认事件这个也很好理解，有些标签本身会存在事件，例如，a 标签的跳转，form 表单中 submit 按钮的提交事件等等，在某些时候我们只想执行我们自己设置的事件，这时，就需要阻止标签的默认事件的执行，原生的 js 我们可以使用 preventDefault 方法来实现，而在 Vue 中，我们只需要使用 prevent 关键字就可以了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，我们为 a 标签添加了一个点击事件，由于 a 标签本身具有默认的跳转事件，此时，当我们点击后，最终还是会执行 a 标签的默认事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;aHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;链接跳转&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        data: {},
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        methods: {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            aHandlerClick() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是a标签的点击事件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031205911818-1528152223.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在 Vue 中，当我们想要阻止元素的默认事件，只需要在绑定的事件后使用 prevent 修饰符即可，示例代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span&gt; @click.prevent&lt;/span&gt;&lt;span&gt;=&quot;aHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;链接跳转&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031210003419-765210357.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　c）.capture：添加事件监听器时使用事件捕获模式&lt;br/&gt;　　在上面的学习中我们了解到，事件捕获模式与事件冒泡模式是一对相反的事件处理流程，当我们想要将页面元素的事件流改为事件捕获模式时，只需要在父级元素的事件上使用 capture 修饰符即可，还是上面的例子的代码，当我们在 div 绑定的点击事件上使用 capture 修饰符后，我们点击按钮首先触发的就是最外侧的 div 的事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;divDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; @click.capure&lt;/span&gt;&lt;span&gt;=&quot;divHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031210137465-1953154662.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　d）.self：只当在 event.target 是当前元素自身时触发处理函数（比如不是子元素冒泡引起的事件触发）&lt;br/&gt;　　在上面的例子中，我们为 div 绑定了一个点击事件，而我们的本意可能是只有当我们点击 div 后触发这个事件，而实际情况是事件冒泡还是事件捕获都会触发这个事件，这与我们的本意是不符的。在 Vue 中，我们就可以使用 self 修饰符去修饰事件，让这个事件只在我们想要触发时触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;divDefault&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; @click.self&lt;/span&gt;&lt;span&gt;=&quot;divHandlerClick&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201810/1310859-20181031210229720-594257869.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　e）.once：事件只触发一次&lt;br/&gt;　　当我们仅仅想对绑定的事件只在第一次的时候触发，这时我们就可以使用 once 修饰符去修饰绑定的事件。例如在下面的代码中，只有第一次点击时才会触发绑定的事件，之后点击都不会触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;点击&quot;&lt;/span&gt;&lt;span&gt; @click.once&lt;/span&gt;&lt;span&gt;=&quot;btnHandlerClick&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　f）.passive：滚动事件的默认行为 (即滚动行为) 将会立即触发&lt;br/&gt;　　在页面滚动的时候，浏览器会在整个事件处理完毕之后再触发滚动，因为浏览器并不知道这个事件是否在其处理函数中被调用了 event.preventDefault()，而 passive 修饰符用来进一步告诉浏览器这个事件的默认行为不会被取消，即 使用 passive 修饰符后表示绑定的事件永远不会调用 event.preventDefault()。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 三、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;　　1、事件修饰符的使用顺序很重要&lt;/h4&gt;
&lt;p&gt;　　使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。&lt;/p&gt;
&lt;h4&gt;　　2、.passive 和 .prevent不能一起使用&lt;/h4&gt;
&lt;p&gt;　　不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 四、参考&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;a title=&quot;JavaScript事件流&quot; href=&quot;http://www.cnblogs.com/xianyulaodi/p/5544312.html&quot; target=&quot;_blank&quot;&gt;1、JavaScript事件流&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;JavaScript:深入理解事件流&quot; href=&quot;https://segmentfault.com/a/1190000003497939&quot; target=&quot;_blank&quot;&gt;2、JavaScript:深入理解事件流&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;理解DOM事件流的三个阶段&quot; href=&quot;https://segmentfault.com/a/1190000004463384&quot; target=&quot;_blank&quot;&gt;3、理解DOM事件流的三个阶段&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;JavaScript 详说事件机制之冒泡、捕获、传播、委托&quot; href=&quot;https://segmentfault.com/a/1190000004463384&quot; target=&quot;_blank&quot;&gt;4、JavaScript 详说事件机制之冒泡、捕获、传播、委托&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;vue从入门到进阶：指令与事件（二）&quot; href=&quot;https://segmentfault.com/a/1190000012819221#articleHeader29&quot; target=&quot;_blank&quot;&gt;5、vue从入门到进阶：指令与事件（二）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 13:14:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>一、前言 熟悉了 Vue 的指令系统后，在实际开发中，不可避免的会使用到对于事件的操作，如何处理 DOM 事件流，成为我们必须要掌握的技能。不同于传统的前端开发，在 Vue 中给我们提供了事件修饰符这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/9846097.html</dc:identifier>
</item>
<item>
<title>人生的意义 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/9885688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/9885688.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202404764-212460375.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近在 YouTube 看了个演讲分享，关于人生的意义，深有感触，所以简单翻译并分享记录在这里。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;让我们一劳永逸地找出生命的意义，在20分钟之内，好吗？&lt;/p&gt;
&lt;h2 id=&quot;life-is______&quot;&gt;LIFE IS______&lt;/h2&gt;
&lt;p&gt;你觉得这个空格里该是什么词？人生是什么？有什么想法吗？让我们先来看看哲学家和聪明人说过的一些不同选择。&lt;/p&gt;
&lt;h2 id=&quot;life-is-time人生是时间&quot;&gt;LIFE IS TIME（人生是时间）&lt;/h2&gt;
&lt;p&gt;有人说生命就是时间，生活就是时间，人生的定义是你从出生到死亡之间的时间。因此，人生的字面意义就是时间。如果人生就是时间，那么拥有美好生活的方法就是明智地利用时间。&lt;/p&gt;
&lt;p&gt;你如何能明智地利用时间呢？有下面五种方法：&lt;/p&gt;
&lt;h3 id=&quot;记住生命有限&quot;&gt;1. 记住，生命有限&lt;/h3&gt;
&lt;p&gt;如果今晚你发现只剩下一年的生命，你将会充分利用接下来这一年。如果人生是无限的，你就不会如此。&lt;/p&gt;
&lt;p&gt;要实现伟大的事情，需要两件事：一个计划，加上不充足的时间。给自己一个紧迫的截止日期，记住你随时都可能死，不要拖延。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;大部分时候活在未来&quot;&gt;2. 大部分时候，活在未来&lt;/h3&gt;
&lt;p&gt;让你当前的大部分行动为你的未来服务。学习，练习，锻炼，延迟满足，节省和投资，建设你的理想未来。这样做的人会更成功，甚至更快乐。&lt;/p&gt;
&lt;p&gt;但是，太过于关注未来，会让你成为一个进入第四次婚姻的成功人士，却没有真正的朋友。太过于关注未来，会让你忽略了当下的重要事情。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;有时活在当下&quot;&gt;3. 有时，活在当下&lt;/h3&gt;
&lt;p&gt;把你的头从未来中拉出来，把你的全部注意力放在当下，人际关系、沟通和两性情感都需要你这样做。&lt;/p&gt;
&lt;p&gt;但过于专注当下就成了享乐主义：仅仅为了当下的满足感，而尽可能兴奋和新奇地生活。&lt;/p&gt;
&lt;p&gt;过于专注当下，会导致你银行账户空空如也，无法控制（买买买）的冲动。过于专注当下会剥夺你更深层次的快乐，比如延迟的满足感、实现长期目标，以及开发有价值的专业知识和技能。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;有时活在过去&quot;&gt;4. 有时，活在过去&lt;/h3&gt;
&lt;p&gt;记住你的过往就相当于活过了两次。&lt;/p&gt;
&lt;p&gt;把你的生活放在过去的背景中，看看你已经走了多远。留出时间重新解释你经历过的事情，作为一个强有力的提醒，你也可以重新解读你的现在和未来。&lt;/p&gt;
&lt;p&gt;你该如何明智地利用时间呢？&lt;/p&gt;
&lt;h3 id=&quot;进入生活的状态&quot;&gt;5. 进入生活的状态&lt;/h3&gt;
&lt;p&gt;你知道心流的感觉 —— 在心流中，你专注于不太容易、也不太难的工作——工作本身就有明确的目标，也是工作自带的奖励。&lt;/p&gt;
&lt;p&gt;在生命的最后阶段，那些声称一生最幸福的人也是花了最多时间在心流状态中的人。为了更好地过好这一生，去追求那些让你处于这种状态的工作，避免那些把你从这种状态中拉出来的事情。&lt;/p&gt;
&lt;p&gt;那么，此时我们再说人生就是时间，你认为如何？似乎是个不错的观点？接下来我们再看看另外的视角。&lt;/p&gt;
&lt;h2 id=&quot;life-is-choice人生是选择&quot;&gt;LIFE IS CHOICE（人生是选择）&lt;/h2&gt;
&lt;p&gt;有人说生活就是选择，生活几乎都是关乎选择。你每天做一百个小小的选择，而一生会做一百个重大的选择，这些选择改变了你的一生。你的生活是由你的选择创造的，因此，人生即选择。&lt;/p&gt;
&lt;p&gt;所以，如果人生就是选择，那么拥有美好人生的方法就是做出正确的选择，你怎么能做出好的选择呢？有四种方法：&lt;/p&gt;
&lt;h3 id=&quot;依赖本能而非逻辑&quot;&gt;1. 依赖本能而非逻辑&lt;/h3&gt;
&lt;p&gt;你大脑的不同部分在进化的不同阶段开始发展。你大脑中最古老的部分，从我们还是鱼的时候就一直在进化，处理本能、恐惧和直觉。你大脑的最新部分，专属于人类的部分，处理逻辑、语言和预测。&lt;/p&gt;
&lt;p&gt;这个最新的部分还处在 Beta 测试中，一个 5 美元的计算器就能在数学上胜过它。但大脑最古老的部分是在 10 亿年前就启动了，从那以后一直处于运作和发展中。&lt;/p&gt;
&lt;p&gt;你观察和学习的每一件事都首先由你的逻辑大脑处理，但结果却被永久地储存为本能、恐惧和直觉。你的直觉和情感是你通过观察和学习一切达到的顶点。所以，如果你倾听自己的直觉，而不是过于依赖你 5 美元的计算器 Beta 测试版大脑，你会做出更好的选择。&lt;/p&gt;
&lt;p&gt;你该如何做出好的选择呢？&lt;/p&gt;
&lt;h3 id=&quot;在足够好的时候停止&quot;&gt;2. 在足够好的时候停止&lt;/h3&gt;
&lt;p&gt;现在相比以往任何时候，你都有更多的选项。你试着选择最好的选项，最好的职业，最好的学校，最好的男朋友/女朋友/伴侣/配偶。&lt;/p&gt;
&lt;p&gt;但是这样做会让你对自己所做的选择感到更糟，你比以往任何时候都更清楚地意识到那些你未选择的所有选项，以及每一个选项的好处。&lt;/p&gt;
&lt;p&gt;所以，不要追求绝对最好的选择。当你找到一个足够好的选项时，就停下来，你会做出同样好的选择，但更重要的是，你会感觉更好，更幸福。&lt;/p&gt;
&lt;p&gt;你该如何做出好的选择呢？&lt;/p&gt;
&lt;h3 id=&quot;设定限制&quot;&gt;3. 设定限制&lt;/h3&gt;
&lt;p&gt;每一个你不得不做出的选择都会造成一点痛苦，生活中有选择是好的，但有更多的选择并不总是更好。&lt;/p&gt;
&lt;p&gt;有时，当你让别人为你做一些选择时，你会更快乐。如果你病得很重，你希望你的医生选择最好的，而不是说：“这有几十个好的选择，你想要什么？” 这就是为什么宗教有吸引力，它给了你规则，它为你做了很多选择。&lt;/p&gt;
&lt;p&gt;所以，在生活中限制你的选择，砍掉一些选项，给自己制定规则。&lt;/p&gt;
&lt;p&gt;你该如何做出好的选择呢？&lt;/p&gt;
&lt;h3 id=&quot;选择重要而非紧急&quot;&gt;4. 选择重要，而非紧急&lt;/h3&gt;
&lt;p&gt;你知道什么是长期的重要与短期的紧急。&lt;/p&gt;
&lt;p&gt;紧急的是电子邮件、短信、推特、电话和新闻；重要的是花一千小时学习一项新的技能，这将对你的生活或工作有真正的帮助；重要的是把你的注意力完全集中在你生活中重要的人身上；重要的是花些时间去锻炼，或收集和分享你学到的东西。&lt;/p&gt;
&lt;p&gt;但这些事情都不会是紧急的，因而你必须忽略那些急迫诱人的哭喊声，刻意选择你知道的重要的东西。&lt;/p&gt;
&lt;p&gt;所以，人生是选择？你认为呢？似乎是不错的论断？我们再看看其他的。&lt;/p&gt;
&lt;h2 id=&quot;life-is-memory人生是记忆&quot;&gt;LIFE IS MEMORY（人生是记忆）&lt;/h2&gt;
&lt;p&gt;有人说人生就是记忆，未来并不存在，都是我们想象的。当下，一毫秒过去了，所以我们经历的一切都是一种记忆。你可以活得很长，但若没有太多的记忆，那你就只能算是经历了短暂的生命。如果你都不记得你的生活，它就像从来没有发生过一样。所以人生就是记忆。&lt;/p&gt;
&lt;p&gt;如果人生是记忆，那么拥有美好生活的方法就是创造更多的记忆。&lt;/p&gt;
&lt;p&gt;你怎么能创造记忆呢？&lt;/p&gt;
&lt;p&gt;改变常规，突破单调。搬家，只要有可能就做一些重大的改变，这些变化是你的编年史标记，这些变化将成为挂在你记忆力的钩子。&lt;/p&gt;
&lt;p&gt;记录它们，写成博客吧。不是记录在一家公司的 “围墙花园” 之中，而是一种格式，你可以存档并且 50 年后再查看，或者你的孙在可以在 100 年后再查看。为未来的你维护一个私人博客，讲述你去过的地方，你做了什么，以及你在路上遇到的奇奇怪怪的人们。如果你不把它记录下来，你将会惊讶于你忘记了多少。&lt;/p&gt;
&lt;p&gt;苏格拉底说：“未经检视的人生不值得活”。那被遗忘的人生呢？&lt;/p&gt;
&lt;p&gt;所以，人生是记忆？你认为呢？还想再试试其他的吗？&lt;/p&gt;
&lt;h2 id=&quot;life-is-learning人生是学习&quot;&gt;LIFE IS LEARNING（人生是学习）&lt;/h2&gt;
&lt;p&gt;我聪明的朋友和精神上的朋友都坚持生命的意义就是学习 —— 这就是你来到这个世界学习的原因。不仅仅是为了你自己，而且为了每个活着的人，为了子孙后代，你生命的意义就是学习。&lt;/p&gt;
&lt;p&gt;所以，如果人生就是学习，那么有美好生活的方法就是学到很多。&lt;/p&gt;
&lt;p&gt;你怎么能学到很多呢？&lt;/p&gt;
&lt;p&gt;与其谈论学习技巧，不如让我们谈谈正确的思维模式，这样你就能学到比你能意识到的更多东西。&lt;/p&gt;
&lt;p&gt;你可能听说过固定思维（Fixed mindset）和成长思维（Growth mindset）。&lt;/p&gt;
&lt;p&gt;固定思维说：“我很擅长这个” 或者 “我不擅长这个”。从童年开始，当你的父母说：“你很擅长数学！”你会想，“我很擅长数学！”但是，当你在一次测试中表现不佳时，你会想：“他们搞错了，我其实不太擅长数学”。大多数人都是这么想的，你能够经常听到类似的说法：“她是一位出色的歌手” 或者 “我只是不擅长跳舞”。&lt;/p&gt;
&lt;p&gt;成长思维说：“任何人都可以擅长任何事情，技能仅来自于实践。”&lt;/p&gt;
&lt;p&gt;曾经对数百名儿童进行了两次近乎不可能的艰难测试。第一次测试后，所有学生都受到了表扬，但有一半的学生私下里被告知：“你一定很擅长这个。” 另一半学生被告知：“你一定很努力”。&lt;/p&gt;
&lt;p&gt;当他们被给予第二次测试时，那些被告知 “你一定很擅长这个” 的学生在第二次测试中表现要差 20%。这些字眼鼓励一种固定的思维模式，让他们觉得没必要去努力尝试。你要么擅长，要么就不擅长。&lt;/p&gt;
&lt;p&gt;那些被告知 “你一定很努力” 的学生，在第二次考试中表现要好 30%。这些字眼鼓励一种成长思维模式，让他们觉得更努力会有所不同。&lt;/p&gt;
&lt;p&gt;因此，仅仅因为老师用了几个不同的字眼，学生的表现就产生了 +-50% 的差异。&lt;/p&gt;
&lt;p&gt;考虑你生活中的所有人，所有那些你收到反馈的日子，你告诉自己的所有事情，所有这一切累计起来的乘数效应，你就能看到这种简单的思维模式差异是如何决定或破坏我们这一生的学习的。&lt;/p&gt;
&lt;p&gt;家长们，请注意这一点。当你告诉孩子们擅长某些事情时，你可能会伤害他们。&lt;/p&gt;
&lt;p&gt;成功的人，要注意这一点。如果你相信别人对你的赞美，你可能会伤害你自己。人们告诉你很擅长你所做的事情，而不是说你必须很努力的工作。&lt;/p&gt;
&lt;p&gt;所以...人生是学习？你认为呢？&lt;/p&gt;
&lt;h2 id=&quot;life-is-suffering人生是痛苦&quot;&gt;LIFE IS SUFFERING（人生是痛苦）&lt;/h2&gt;
&lt;p&gt;我们应该看看佛教的观念，人生就是痛苦吗？不，这可没什么意思。&lt;/p&gt;
&lt;h2 id=&quot;life-is-love人生是爱&quot;&gt;LIFE IS LOVE（人生是爱）&lt;/h2&gt;
&lt;p&gt;这太模糊了。&lt;/p&gt;
&lt;h2 id=&quot;life-is-dna人生是基因&quot;&gt;LIFE IS DNA（人生是基因）&lt;/h2&gt;
&lt;p&gt;生命不过是在复制 DNA？这又太过精确了。&lt;/p&gt;
&lt;p&gt;那么人生到底是什么？让我们先换个话题。&lt;/p&gt;
&lt;h2 id=&quot;中文&quot;&gt;中文&lt;/h2&gt;
&lt;p&gt;几年前，我开始学中文，我对写作很着迷，我开始试着记住这些汉字。&lt;/p&gt;
&lt;p&gt;汉字看上去很复杂，但它们大多是由较小的、更简单的字组成的，而英语单词是由拉丁语的词根等组成的。所以你可以通过知道每个字符成分的含义来记住它的意义。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202432244-2065709306.png&quot;/&gt;&lt;br/&gt;语 language = words 讠+ five 五+ mouth 口&lt;/p&gt;
&lt;p&gt;所以，“语言” 就是至少五个人都会说的词吗？太棒了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202457345-567511529.png&quot;/&gt;&lt;br/&gt;谢 thank you = words 讠+ body 身+ inch 寸&lt;/p&gt;
&lt;p&gt;嗯...这个不太明显。也许它想表达的是，当你说谢谢时，身体需要让出一英寸的尊重空间？这很有趣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202522833-564289543.png&quot;/&gt;&lt;br/&gt;名 name = evening 夕 + mouth 口&lt;/p&gt;
&lt;p&gt;所以，这是在夕阳下的傍晚有人呼喊你的名字？这是一种浪漫。&lt;/p&gt;
&lt;p&gt;我对每个字背后的历史或文化意义都很好奇。我对这些汉字的历史意义很好奇，直到我得到了一本汉语词源词典，它讲述了每一个汉字背后的全部历史。&lt;/p&gt;
&lt;p&gt;我查阅了这里给出的例子，发现这些字都是基于语音学的！那些组合字符根本不是因为它们的意义而被选择的，而是因为它们的发音。&lt;/p&gt;
&lt;p&gt;所以，看来我只是在把自己想象的意义加进去，它们根本没有任何意义！&lt;/p&gt;
&lt;p&gt;这让我大受震动。几个月来，我已经背了几百个字，把每一个字的组成部分的各种意义都强加了进去。&lt;/p&gt;
&lt;p&gt;从这里面恢复过来后，我想：生活中还有多少东西其实真的没有意义？还有一些其他什么东西是把我自己理解的意义放进去的？想想，这是真的吗？&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;没有什么东西是存在固有内在的意义的。所有的一切就是它们本来那样，就是这样。&lt;/p&gt;
&lt;p&gt;所以，让我们回到最初的问题，总结一下：人生的意义有什么？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间 Time?&lt;/li&gt;
&lt;li&gt;选择 Choice？&lt;/li&gt;
&lt;li&gt;记忆 Memory？&lt;/li&gt;
&lt;li&gt;学习 Learning？&lt;/li&gt;
&lt;li&gt;痛苦 Suffering？&lt;/li&gt;
&lt;li&gt;基因 DNA？&lt;/li&gt;
&lt;li&gt;爱 Love？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以从各种各样的答案中看出，它们只是投射出来的意义。&lt;/p&gt;
&lt;p&gt;你可以选择将这些意义中的一种投射到你的生活中，如果它让你感觉良好，或者能改善你当前的行为。&lt;/p&gt;
&lt;p&gt;但你知道，真正的答案现在是清晰而明显的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201810/815275-20181031202550455-2130266001.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;人生就（只是）人生，这并不意味着有什么。&lt;/p&gt;
&lt;p&gt;抹去你对过去事件赋予的任何意义；抹去任何阻碍你的意义；抹去那些人们说这有某种意味的时候；所有这些都不是真实的。&lt;/p&gt;
&lt;p&gt;人生没有内在的意义，没有什么有内在固有的意义。&lt;/p&gt;
&lt;p&gt;人生就是一片白板。&lt;/p&gt;
&lt;p&gt;你可以自由地投射任何为你服务的意义，伴随这份意义去自由地做任何你想做的事。&lt;/p&gt;
&lt;p&gt;谢谢。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：Derek Sivers&lt;br/&gt;日期：2014-05-05&lt;br/&gt;原文：&lt;a href=&quot;https://sivers.org/ml&quot;&gt;The Meaning of Life&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 12:29:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<og:description>最近在 YouTube 看了个演讲分享，关于人生的意义，深有感触，所以简单翻译并分享记录在这里。 让我们一劳永逸地找出生命的意义，在20分钟之内，好吗？ LIFE IS______ 你觉得这个空格里该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/9885688.html</dc:identifier>
</item>
<item>
<title>Java -- 基于JDK1.8的LinkedList源码分析 - 阿呆哥哥</title>
<link>http://www.cnblogs.com/wjtaigwh/p/9883828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wjtaigwh/p/9883828.html</guid>
<description>&lt;p&gt;&lt;span&gt;1，&lt;/span&gt;上周末我们一起分析了ArrayList的源码并进行了一些总结，因为最近在看Collection这一块的东西，下面的图也是大致的总结了Collection里面重要的接口和类，如果没有意外的话后面基本上每一个都会和大家一起学习学习，所以今天也就和大家一起来看看LinkedList吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824232/201810/824232-20181031202744786-1806050107.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哦，不对，放错图了，是下面的图，嘿嘿嘿。。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/824232/201810/824232-20181031153236363-524771887.png&quot; alt=&quot;&quot; width=&quot;653&quot; height=&quot;347&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2，&lt;/span&gt;记得首次接触LinkedList还是在大学Java的时候，当时说起LinkedList的特性和应用场景：LinkedList基于双向链表适用于增删频繁且查询不频繁的场景，线程不安全的且适用于单线程（这点和ArrayList很像）。然后还记得一个很深刻的是可以用LinkedList来实现栈和队列，那让我们一起看一看源码到底是怎么来实现这些特点的&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2.1 构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class LinkedList&amp;lt;E&amp;gt;
    extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable
{
    transient int size = 0;
    transient Node&amp;lt;E&amp;gt; first;
    transient Node&amp;lt;E&amp;gt; last;
    
    public LinkedList() {
    }

    public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {
        this();
        addAll(c);
    }
    
    public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return addAll(size, c);
    }
    
    public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
        checkPositionIndex(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;

        Node&amp;lt;E&amp;gt; pred, succ;
        if (index == size) {
            succ = null;
            pred = last;
        } else {
            succ = node(index);
            pred = succ.prev;
        }

        for (Object o : a) {
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
            Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, null);
            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        }

        if (succ == null) {
            last = pred;
        } else {
            pred.next = succ;
            succ.prev = pred;
        }

        size += numNew;
        modCount++;
        return true;
    }
    
    private static class Node&amp;lt;E&amp;gt; {
        E item;
        Node&amp;lt;E&amp;gt; next;
        Node&amp;lt;E&amp;gt; prev;

        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    
    Node&amp;lt;E&amp;gt; node(int index) {
        // assert isElementIndex(index);

        if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {
            Node&amp;lt;E&amp;gt; x = first;
            for (int i = 0; i &amp;lt; index; i++)
                x = x.next;
            return x;
        } else {
            Node&amp;lt;E&amp;gt; x = last;
            for (int i = size - 1; i &amp;gt; index; i--)
                x = x.prev;
            return x;
        }
    }    
    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先我们知道常见的构造是LinkedList()和LinkedList(Collection&amp;lt;? extends E&amp;gt; c)两种，然后再来看看我们继承的类和实现的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
LinkedList 集成AbstractSequentialList抽象类，内部使用listIterator迭代器来实现重要的方法
LinkedList 实现 List 接口，能对它进行队列操作。
LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。
LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。
LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，相对于ArrayList，LinkedList多实现了Deque接口而少实现了RandomAccess接口，且LinkedList继承的是AbstractSequentialList类，而ArrayList继承的是AbstractList类。那么我们现在有一个疑问，这些多实现或少实现的接口和类会对我们LinkedList的特点产生影响吗？这里我们先将这个疑问放在心里，我们先走正常的流程，先把LinkedList的源码看完（主要是要解释这些东西看Deque的源码，还要去看Collections里面的逻辑，我怕扯远了）&lt;/p&gt;
&lt;p&gt;　　第5-7行：定义记录元素数量size，因为我们之前说过LinkedList是个双向链表，所以这里定义了链表链表头节点first和链表尾节点last&lt;/p&gt;
&lt;p&gt;　　第60-70行：定义一个节点Node类，next表示此节点的后置节点，prev表示侧节点的前置节点，element表示元素值&lt;/p&gt;
&lt;p&gt;　　第22行：检查当前的下标是否越界，因为是在构造函数中所以我们这边的index为0，且size也为0&lt;/p&gt;
&lt;p&gt;　　第24-29行：将集合c转化为数组a，并获取集合的长度；定义节点pred、succ，pred用来记录前置节点，succ用来记录后置节点&lt;/p&gt;
&lt;p&gt;　   第70-89行：node()方法是获取LinkedList中第index个元素，且根据index处于前半段还是后半段 进行一个折半，以提升查询效率&lt;/p&gt;
&lt;p&gt;　　第30-36行：如果index==size，则将元素追加到集合的尾部，pred = last将前置节点pred指向之前结合的尾节点，如果index！=size表明是插入集合，通过node(index)获取当前要插入index位置的节点，且pred = succ.prev表示将前置节点指向于当前要插入节点位置的前置节点&lt;/p&gt;
&lt;p&gt;　　第38-46行：链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作，第40行以前置节点 和 元素值e，构建new一个新节点；第41行如果前置节点是空，说明是头结点，且将成员变量first指向当前节点，如果不是头节点，则将上一个节点的尾节点指向当前新建的节点；第45行将当前的节点为前置节点了，为下次添加节点做准备。这些走完基本上我们的新节点也都创建出来了，可能这块代码有点绕，大家多看看&lt;/p&gt;
&lt;p&gt;　　第48-53行：循环结束后，判断如果后置节点是null， 说明此时是在队尾添加的，设置一下队列尾节点last，如果不是在队尾，则更新之前插入位置节点的前节点和当前要插入节点的尾节点&lt;/p&gt;
&lt;p&gt;　　第55-56行：修改当前集合数量、修改modCount记录值&lt;/p&gt;
&lt;p&gt;　　ok,虽然说是分析的构造函数的源码，但是把node(int index)、addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)方法也都看了，所以来小结一下：链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作；通过下标index来获取节点Node是采用的折半法来提升效率的&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.2 增加元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　常见的方法有以下三种&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
linkedList.add(E e)
linkedList.add(int index, E element)
linkedList.addAll(Collection&amp;lt;? extends E&amp;gt; c)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　来看看具体的源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public boolean add(E e) {
        linkLast(e);
        return true;
    }

 void linkLast(E e) {
        final Node&amp;lt;E&amp;gt; l = last;
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
}

public void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    }

 void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
        // assert succ != null;
        final Node&amp;lt;E&amp;gt; pred = succ.prev;
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }

public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return addAll(size, c);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第2、6-16行：创建一个newNode它的prev指向之前队尾节点last，并记录元素值e，之前的队尾节点last的next指向当前节点，size自增，modcount自增&lt;/p&gt;
&lt;p&gt;　　第18-20，27-38行：首先去检查下标是否越界，然后判断如果加入的位置刚好位于队尾就和我们add（E element）的逻辑一样了，如果不是则需要通过 node(index)函数定位出当前位于index下标的node，再通过linkBefore()函数创建出newNode将其插入到原先index位置&lt;/p&gt;
&lt;p&gt;　　第40-42行：就是我们在构造函数中看过的批量加入元素的方法&lt;/p&gt;
&lt;p&gt;　　OK，添加元素也很简单，如果是在队尾进行添加的话只需要创建一个新Node将其前置节点指向之前的last，如果是在队中添加节点，首选拆散原先的index-1、index、index+1之间的联系，新建节点插入进去即可。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.3 删除元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　常见方法有以下这几个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
linkedList.remove(int index)
linkedList.remove(Object o)
linkedList.remove(Collection&amp;lt;?&amp;gt; c)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public E remove(int index) {
        checkElementIndex(index);
        return unlink(node(index));
    }

unlink(Node&amp;lt;E&amp;gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&amp;lt;E&amp;gt; next = x.next;
        final Node&amp;lt;E&amp;gt; prev = x.prev;

        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }

        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }

        x.item = null;
        size--;
        modCount++;
        return element;
    }

public boolean remove(Object o) {
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

 public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
        Objects.requireNonNull(c);
        boolean modified = false;
        Iterator&amp;lt;?&amp;gt; it = iterator();
        while (it.hasNext()) {
            if (c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第1-4，6-30行：首先根据index通过方法值node(index)来确定出集合中的下标是index的node，咋们主要看unlink()方法，代码感觉很多，其实只是将当前要删除的节点node的头结点的尾节点指向node的尾节点、将node的尾结点的头节点指向node的头节点，可能有点绕（哈哈），看一下代码基本上就可以理解了，然后将下标为index的node置空，供GC回收&lt;/p&gt;
&lt;p&gt;　　第32-49行：首先判断一下当前要删除的元素o是否为空，然后进行for循环定位出当前元素值等于o的节点node，然后再走的逻辑就是上面我们看到过的unlink()方法，也很简单，比remove(int index) 多了一步&lt;/p&gt;
&lt;p&gt;　　第51-62行：这一块因为涉及到迭代器Iterator，而我们LinkedList使用的是ListItr，这个后面我们将迭代器的时候一起讲，不过大致的逻辑是都可以看懂的，和我们的ArrayList的迭代器方法的含义一样的，可以先那样理解&lt;/p&gt;
&lt;p&gt;　　ok，小结一下， 按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 按元素删，会先去遍历链表寻找是否有该Node，考虑到允许null值，所以会遍历两遍，然后再去unlink它。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.5 修改元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public E set(int index, E element) {
        checkElementIndex(index);
        Node&amp;lt;E&amp;gt; x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只有这一种方法，首先检查下标是否越界，然后根据下标获取当前Node，然后修改节点中元素值item，超级简单&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　2.6 查找元素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public E get(int index) {
    checkElementIndex(index);//判断是否越界 [0,size)
    return node(index).item; //调用node()方法 取出 Node节点，
}


 public int indexOf(Object o) {
        int index = 0;
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (x.item == null)
                    return index;
                index++;
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = first; x != null; x = x.next) {
                if (o.equals(x.item))
                    return index;
                index++;
            }
        }
        return -1;
    }

 public int lastIndexOf(Object o) {
        int index = size;
        if (o == null) {
            for (Node&amp;lt;E&amp;gt; x = last; x != null; x = x.prev) {
                index--;
                if (x.item == null)
                    return index;
            }
        } else {
            for (Node&amp;lt;E&amp;gt; x = last; x != null; x = x.prev) {
                index--;
                if (o.equals(x.item))
                    return index;
            }
        }
        return -1;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取元素的源码也很简单，主要是通过node(index)方法获取节点，然后获取元素值，indexOf和lastIndexOf方法的区别在于一个是从头向尾开始遍历，一个是从尾向头开始遍历&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.7 迭代器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public Iterator&amp;lt;E&amp;gt; iterator() {
        return listIterator();
    }

public ListIterator&amp;lt;E&amp;gt; listIterator() {
        return listIterator(0);
    }

public ListIterator&amp;lt;E&amp;gt; listIterator(final int index) {
        rangeCheckForAdd(index);

        return new ListItr(index);
    }

private class ListItr extends Itr implements ListIterator&amp;lt;E&amp;gt; {
        ListItr(int index) {
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public E previous() {
            checkForComodification();
            try {
                int i = cursor - 1;
                E previous = get(i);
                lastRet = cursor = i;
                return previous;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor-1;
        }

        public void set(E e) {
            if (lastRet &amp;lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.set(lastRet, e);
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                AbstractList.this.add(i, e);
                lastRet = -1;
                cursor = i + 1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，其实最后使用的迭代器是使用的ListIterator类，且集成自Itr，而Itr类就是我们昨天ArrayList内部使用的类，hasNext()方法和我们之前的一样，判断不等于size大小，然后next()获取元素主要也是E next = get(i);这行代码，这样就又走到我们之前的获取元素的源码当中，获得元素值。&lt;/p&gt;
&lt;p&gt;　　OK，这样我们上面的基本方法都看完了，再来看看我们上面遗留的问题，首先来看Deque接口有什么作用，我们来一起看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Deque 是 Double ended queue (双端队列) 的缩写,读音和 deck 一样，蛋壳。
Deque 继承自 Queue,直接实现了它的有 LinkedList, ArayDeque, ConcurrentLinkedDeque 等。
Deque 支持容量受限的双端队列，也支持大小不固定的。一般双端队列大小不确定。
Deque 接口定义了一些从头部和尾部访问元素的方法。比如分别在头部、尾部进行插入、删除、获取元素。
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public interface Deque&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt; {
    void addFirst(E e);//插入头部，异常会报错
    boolean offerFirst(E e);//插入头部，异常不报错
    E getFirst();//获取头部，异常会报错
    E peekFirst();//获取头部，异常不报错
    E removeFirst();//移除头部，异常会报错
    E pollFirst();//移除头部，异常不报错

    void addLast(E e);//插入尾部，异常会报错
    boolean offerLast(E e);//插入尾部，异常不报错
    E getLast();//获取尾部，异常会报错
    E peekLast();//获取尾部，异常不报错
    E removeLast();//移除尾部，异常会报错
    E pollLast();//移除尾部，异常不报错
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Deque也就是一个接口，上面是接口里面的方法，然后了解Deque就必须了解Queue&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public interface Queue&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; {
    //往队列插入元素，如果出现异常会抛出异常
    boolean add(E e);
    //往队列插入元素，如果出现异常则返回false
    boolean offer(E e);
    //移除队列元素，如果出现异常会抛出异常
    E remove();
    //移除队列元素，如果出现异常则返回null
    E poll();
    //获取队列头部元素，如果出现异常会抛出异常
    E element();
    //获取队列头部元素，如果出现异常则返回null
    E peek();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们知道LinkedList实现了Deque接口，也就是说可以使用LinkedList实现栈和队列的功能，让写写看&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.ysten.leakcanarytest;

import java.util.Collection;
import java.util.LinkedList;

/**
 * desc    : 实现栈
 * time    : 2018/10/31 0031 19:07
 *
 * @author : wangjitao
 */
public class Stack&amp;lt;T&amp;gt;
{
    private LinkedList&amp;lt;T&amp;gt; stack;

    //无参构造函数
    public Stack()
    {
        stack=new LinkedList&amp;lt;T&amp;gt;();
    }
    //构造一个包含指定collection中所有元素的栈
    public Stack(Collection&amp;lt;? extends T&amp;gt; c)
    {
        stack=new LinkedList&amp;lt;T&amp;gt;(c);
    }
    //入栈
    public void push(T t)
    {
        stack.addFirst(t);
    }
    //出栈
    public T pull()
    {
        return stack.remove();
    }
    //栈是否为空
    boolean isEmpty()
    {
        return stack.isEmpty();
    }

    //打印栈元素
    public void show()
    {
        for(Object o:stack)
            System.out.println(o);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static void main(String[] args){
        Stack&amp;lt;String&amp;gt; stringStack = new Stack&amp;lt;&amp;gt;();
        stringStack.push(&quot;1&quot;);
        stringStack.push(&quot;2&quot;);
        stringStack.push(&quot;3&quot;);
        stringStack.push(&quot;4&quot;);
        stringStack. show();
    }


打印结果如下：
4
3
2
1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　队列的实现类似的，大家可以下来自己写一下，然后继续我们的问题，实现Deque接口和实现RandomAccess接口有什么区别，我们上面看了Deque接口，实现Deque接口可以拥有双向链表功能，那我们再来看看RandomAccess接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RandomAccess {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发现什么都没有，原来RandomAccess接口是一个标志接口（Marker），然而实现这个接口有什么作用呢？&lt;/p&gt;
&lt;p&gt;　　答案是只要List集合实现这个接口，就能支持快速随机访问，然而又有人问，快速随机访问是什么东西？有什么作用？&lt;/p&gt;
&lt;p&gt;　　google是这样定义的：给可以提供随机访问的List实现去标识一下，这样使用这个List的程序在遍历这种类型的List的时候可以有更高效率。仅此而已。&lt;/p&gt;
&lt;p&gt;　　这时候看一下我们Collections类中的binarySearch方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int binarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key) {
        if (list instanceof RandomAccess || list.size()&amp;lt;BINARYSEARCH_THRESHOLD)
            return Collections.indexedBinarySearch(list, key);
        else
            return Collections.iteratorBinarySearch(list, key);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到这时候去判断了如果当前集合实现了RandomAccess接口就会走Collections.indexedBinarySearch方法，那么我们来看一下Collections.indexedBinarySearch()方法和Collections.iteratorBinarySearch()的区别是什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int indexedBinarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key) {
        int low = 0;
        int high = list.size()-1;

        while (low &amp;lt;= high) {
            int mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1;
            Comparable&amp;lt;? super T&amp;gt; midVal = list.get(mid);
            int cmp = midVal.compareTo(key);

            if (cmp &amp;lt; 0)
                low = mid + 1;
            else if (cmp &amp;gt; 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found
    }



int iteratorBinarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key)
    {
        int low = 0;
        int high = list.size()-1;
        ListIterator&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; i = list.listIterator();

        while (low &amp;lt;= high) {
            int mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1;
            Comparable&amp;lt;? super T&amp;gt; midVal = get(i, mid);
            int cmp = midVal.compareTo(key);

            if (cmp &amp;lt; 0)
                low = mid + 1;
            else if (cmp &amp;gt; 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过查看源代码，发现实现RandomAccess接口的List集合采用一般的for循环遍历，而未实现这接口则采用迭代器&lt;/p&gt;
&lt;p&gt;，那现在让我们以LinkedList为例子看一下，通过for循环、迭代器、removeFirst和removeLast来遍历的效率（之前忘记写这一块了，顺便一块先写了对于LinkedList那种访问效率要高一些）&lt;/p&gt;
&lt;p&gt;　　迭代器遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
LinkedList linkedList = new LinkedList();
for(int i = 0; i &amp;lt; 100000; i++){
          linkedList.add(i);
}
// 迭代器遍历
 long start = System.currentTimeMillis();
 Iterator iterator = linkedList.iterator();
 while(iterator.hasNext()){
        iterator.next();
 }
 long end = System.currentTimeMillis();
  System.out.println(&quot;Iterator：&quot;+ (end - start) +&quot;ms&quot;);

打印结果：Iterator：28ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　for循环get遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 顺序遍历(随机遍历)
 long start = System.currentTimeMillis();
 for(int i = 0; i &amp;lt; linkedList.size(); i++){
            linkedList.get(i);
}
long end = System.currentTimeMillis();
System.out.println(&quot;for ：&quot;+ (end - start) +&quot;ms&quot;);

打印结果   for ：6295ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用增强for循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
long start = System.currentTimeMillis();
for(Object  i : linkedList);
long end = System.currentTimeMillis();
System.out.println(&quot;增强for ：&quot;+ (end - start) +&quot;ms&quot;);

输出结果 增强for ：6ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　removeFirst来遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
long start = System.currentTimeMillis();
while(linkedList.size() != 0){
            linkedList.removeFirst();
}
long end = System.currentTimeMillis();
System.out.println(&quot;removeFirst ：&quot;+ (end - start) +&quot;ms&quot;);

输出结果 removeFirst ：3ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　综上结果可以看到，遍历LinkedList时，使用removeFirst()或removeLast()效率最高，而for循环get()效率最低，应避免使用这种方式进行。应当注意的是，使用removeFirst()或removeLast()遍历时，会删除原始数据，若只单纯的读取，应当选用迭代器方式或增强for循环方式。&lt;/p&gt;
&lt;p&gt;　　ok，上述的都是只针对LinkedList而言测试的，然后我们接着上面的RandomAccess接口来讲，看看通过对比ArrayList的for循环和迭代器遍历看看访问效率&lt;/p&gt;
&lt;p&gt;　　ArrayList的for循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
long start = System.currentTimeMillis();
for (int i = 0; i &amp;lt; arrayList.size(); i++) {
         arrayList.get(i);
}
 long end = System.currentTimeMillis();
 System.out.println(&quot;for  ：&quot;+ (end - start) +&quot;ms&quot;);

输出结果  for  ：3ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ArrayList的迭代遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 long start = System.currentTimeMillis();
Iterator iterable = arrayList.iterator() ;
while (iterable.hasNext()){
         iterable.next();
}
 long end = System.currentTimeMillis();
 System.out.println(&quot;for  ：&quot;+ (end - start) +&quot;ms&quot;);

输出结果 for  ：6ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以让我们来综上对比一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ArrayList
    普通for循环：3ms
    迭代器：6ms
LinkedList
    普通for循环：6295ms    
    迭代器：28ms
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从上面数据可以看出，ArrayList用for循环遍历比iterator迭代器遍历快，LinkedList用iterator迭代器遍历比for循环遍历快,所以对于不同的List实现类，遍历的方式有所不用，RandomAccess接口这个空架子的存在，是为了能够更好地判断集合是否ArrayList或者LinkedList，从而能够更好选择更优的遍历方式，提高性能！&lt;/p&gt;
&lt;p&gt;　　（在这里突然想起在去年跳槽的时候，有家公司的面试官问我，list集合的哪一种遍历方式要快一些，然后我说我没有每个去试过，结果那位大佬说的是for循环遍历最快，还叫我下去试试，现在想想，只有在集合是ArrayList的时候for循环才最快，对于LinkedList来说for循环反而是最慢的，那位大佬，你欠我一声对不起（手动斜眼微笑））&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3，&lt;/span&gt;上面把我们该看的点都看了，那么我们再来总结总结：&lt;/p&gt;
&lt;p&gt;　　LinkedList 是双向列表，链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。&lt;/p&gt;
&lt;p&gt;　　ArrayList基于数组， LinkedList基于双向链表，对于随机访问， ArrayList比较占优势，但LinkedList插入、删除元素比较快，因为只要调整指针的指向。针对特定位置需要遍历时，所以LinkedList在随机访问元素的话比较慢。&lt;/p&gt;
&lt;p&gt;　　LinkedList没有实现自己的 Iterator，使用的是 ListIterator。&lt;/p&gt;
&lt;p&gt;　　LinkedList需要更多的内存，因为 ArrayList的每个索引的位置是实际的数据，而 LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。&lt;/p&gt;
&lt;p&gt;　　LinkedList也是非线程安全的，只有在单线程下才可以使用。为了防止非同步访问，Collections类里面提供了synchronizedList()方法。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/824232/201810/824232-20181031202257964-585293961.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好了，也不早了，大家早点休息，下次再见。。。&lt;/p&gt;

</description>
<pubDate>Wed, 31 Oct 2018 12:29:00 +0000</pubDate>
<dc:creator>阿呆哥哥</dc:creator>
<og:description>1，上周末我们一起分析了ArrayList的源码并进行了一些总结，因为最近在看Collection这一块的东西，下面的图也是大致的总结了Collection里面重要的接口和类，如果没有意外的话后面基本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wjtaigwh/p/9883828.html</dc:identifier>
</item>
<item>
<title>Java入门系列-22-IO流 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9885564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9885564.html</guid>
<description>&lt;h2 id=&quot;file类的使用&quot;&gt;File类的使用&lt;/h2&gt;
&lt;p&gt;Java程序如何访问文件？通过 java.io.File 类&lt;/p&gt;
&lt;p&gt;使用File类需要先创建文件对象 &lt;code&gt;File file=new File(String pathname);&lt;/code&gt;，创建时在构造函数中指定物理文件或目录，然后通过文件对象的方法操作文件或目录的属性。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;\ 是特殊字符，要使用需要转义 \\&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;File 类常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean exists()&lt;/td&gt;
&lt;td&gt;判断文件或目录是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;boolean isFile()&lt;/td&gt;
&lt;td&gt;判断是否是文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;boolean isDirectory()&lt;/td&gt;
&lt;td&gt;判断是否是目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;String getPath()&lt;/td&gt;
&lt;td&gt;返回此对象表示的文件的相对路径名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;String getAbsolutePath()&lt;/td&gt;
&lt;td&gt;返回此对象表示的文件的绝对路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;String getName()&lt;/td&gt;
&lt;td&gt;返回此对象指定的文件或目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean createNewFile()&lt;/td&gt;
&lt;td&gt;创建名称的空文件，不创建文件夹&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;long length()&lt;/td&gt;
&lt;td&gt;返回文件的长度，单位为字节，文件不存在则返回0L&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;File[] listFiles()&lt;/td&gt;
&lt;td&gt;返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;static File[] listRoots()&lt;/td&gt;
&lt;td&gt;列出可用文件系统根&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean mkdirs()&lt;/td&gt;
&lt;td&gt;创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.File;
import java.io.IOException;

public class TestFile {

    public static void main(String[] args) {
        //创建File对象 传入文件的路径
        File file=new File(&quot;D:\\a.txt&quot;);
        //创建File对象 传入文件夹的路径
        File dir=new File(&quot;D:/word&quot;);
        //判断是否存在
        if(file.exists()) {
            if(file.isFile()) {
                //getName()获取名字
                System.out.println(file.getName()+&quot; 是文件&quot;);
            }else if(file.isDirectory()){
                System.out.println(file.getName()+&quot; 是目录&quot;);
            }           
        }else {
            System.out.println(file.getName()+&quot; 不存在！&quot;);
            try {
                //创建文件
                file.createNewFile();
                System.out.println(&quot;文件大小：&quot;+file.length()+&quot; 字节&quot;);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        if(dir.exists()) {
            if(dir.isFile()) {
                System.out.println(dir.getName()+&quot; 是文件&quot;);
            }else if(dir.isDirectory()) {
                System.out.println(dir.getName()+&quot; 是文件夹&quot;);
                //绝对路径
                System.out.println(dir.getAbsolutePath());
            }           
        }else {
            System.out.println(dir.getName()+&quot; 不存在！&quot;);
            //创建目录
            dir.mkdirs();
        }
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;流&quot;&gt;流&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;流&lt;/strong&gt;：指一连串流动的字符，是以先进先出方式发送信息的通道&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入流&lt;/strong&gt;：源数据流向程序(读)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入流&lt;/strong&gt;：程序中的数据流向目标数据源(写)&lt;/p&gt;
&lt;h3 id=&quot;java流的分类&quot;&gt;Java流的分类&lt;/h3&gt;
&lt;p&gt;按流向&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出流(OutputStream和Writer作为基类)&lt;/li&gt;
&lt;li&gt;输入流(InputStream和Reader作为基类)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入输出流是相对于计算机内存来说的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照处理数据单元划分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字节流
&lt;ul&gt;&lt;li&gt;字节输入流(InputStream基类)&lt;/li&gt;
&lt;li&gt;字节输出流(OutputStream基类)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;字符流
&lt;ul&gt;&lt;li&gt;字符输入流(Reader基类)&lt;/li&gt;
&lt;li&gt;字符输出流(Writer基类)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;字节流是8位(1B)通用字节流，字符流是16位(2B)Unicode字符流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字节流&quot;&gt;字节流&lt;/h2&gt;
&lt;p&gt;FileInputStream 是 InputStream 的子类&lt;/p&gt;
&lt;p&gt;InputStream 类常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;int read()&lt;/td&gt;
&lt;td&gt;从输入流中读取数据的下一个字节。返回0到255的int值，如果到达流的末尾，则返回-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;int read(byte[] b)&lt;/td&gt;
&lt;td&gt;从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。返回读入缓冲区的总字节数，如果达到末尾则返回-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;int read(byte[] b,int off,int len)&lt;/td&gt;
&lt;td&gt;将输入流中最多 len 个数据字节读入 byte数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;关闭此输入流并释放与该流关联的所有系统资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int available()&lt;/td&gt;
&lt;td&gt;返回此输入流下一个方法调用可以不受阻塞地从此输入流读取的估计字节数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;FileInputStream 类常用构造方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;FileInputStream(File file)&lt;/td&gt;
&lt;td&gt;通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;FileInputStream(String name)&lt;/td&gt;
&lt;td&gt;通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 FileInputStream 读取文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class TestFileInputStream {

    public static void main(String[] args) {
        FileInputStream fis=null;
        try {
            fis=new FileInputStream(&quot;D:\\a.txt&quot;);
            //读取结果存入StringBuffer
            StringBuffer sb=new StringBuffer();
            System.out.println(&quot;预计读取：&quot;+fis.available()+&quot;字节&quot;);
            //记录每次读取的长度
            int len=0;
            //缓冲区字节数组
            byte[] buff=new byte[1024];
            while((len=fis.read(buff))!=-1) {
                System.out.println(&quot;还剩余：&quot;+fis.available()+&quot;字节&quot;);
                sb.append(new String(buff,0,len));
            }
            System.out.println(&quot;结果：&quot;);
            System.out.println(sb);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (fis!=null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileOutputStream 是 OutputStream 的子类&lt;/p&gt;
&lt;p&gt;OutputStream 类常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void write(int c)&lt;/td&gt;
&lt;td&gt;将制定的字节写入此输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void write(byte[] buf)&lt;/td&gt;
&lt;td&gt;将 b.length 个字节从指定的 byte 数组写入此输入流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;void write(byte[] b,int off,int len)&lt;/td&gt;
&lt;td&gt;将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;关闭此输出流并释放与此流有关的所有系统资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;FileOutputStream的构造方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;FileOutputStream(File file)&lt;/td&gt;
&lt;td&gt;创建一个向指定 File 对象表示的文件中写入数据的文件输出流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;FileOutputStream(String name)&lt;/td&gt;
&lt;td&gt;创建一个向具有指定名称的文件中写入数据的输出文件流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;FileOutputStream(String name,boolean append)&lt;/td&gt;
&lt;td&gt;第二个参数为 true，则将字节写入文件末尾处，而不是写入文件开始处&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 FileOutputStream 写文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class TestFileOutputStream {

    public static void main(String[] args) {
        FileOutputStream fos=null;
        try {
            //创建输出流对象
            fos=new FileOutputStream(&quot;D:\\c.txt&quot;);
            //要输出的字符
            String str=&quot;hello world 你好&quot;;
            //将字符串转成字节数组并写入到流中
            fos.write(str.getBytes());
            //刷新流
            fos.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (fos!=null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;字符流&quot;&gt;字符流&lt;/h2&gt;
&lt;p&gt;上面的内容我们看到，字节流不能直接操作字符，所以操作字符用字符流。&lt;/p&gt;
&lt;p&gt;FileReader 是 Reader 的子类&lt;/p&gt;
&lt;p&gt;Reader 类常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int read()&lt;/td&gt;
&lt;td&gt;读取单个字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;int read(char[] c)&lt;/td&gt;
&lt;td&gt;将字符读入数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;read(char[] c,int off,int len)&lt;/td&gt;
&lt;td&gt;将字符读入数组的某一部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;关闭该流并释放与之关联的所有资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 FileReader 读取文本文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

public class TestReader {

    public static void main(String[] args) {
        Reader r=null;
        try {
            //创建FileReader对象
            r=new FileReader(&quot;D:\\a.txt&quot;);
            //字符缓冲数组
            char[] chrs=new char[512];
            //记录每次读取的个数
            int len=0;
            //循环读取
            while((len=r.read(chrs))!=-1) {
                String str=new String(chrs, 0, len);
                System.out.println(str);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (r!=null) {
                try {
                    r.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileWriter 是 Writer 的子类&lt;/p&gt;
&lt;p&gt;Writer 类常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;write(String str)&lt;/td&gt;
&lt;td&gt;写入字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;write(String str,int off,int len)&lt;/td&gt;
&lt;td&gt;写入字符串的某一部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;关闭此流，但要先刷新它&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;void flush&lt;/td&gt;
&lt;td&gt;刷新该流的缓冲&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 FileWriter 写入文本文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

public class TestWriter {

    public static void main(String[] args) {
        Writer w=null;
        try {
            //创建字符输出流
            w=new FileWriter(&quot;D:\\msg.txt&quot;);
            String msg=&quot;hello every bady 兄嘚&quot;;
            //将字符串写入到流中
            w.write(msg);
            w.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (w!=null) {
                try {
                    w.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缓冲字符流&quot;&gt;缓冲字符流&lt;/h2&gt;
&lt;p&gt;如果频繁的对字符进行读写操作，墙裂建议使用缓冲！&lt;/p&gt;
&lt;p&gt;BufferedReader 类带有缓冲区，可以先把一批数据读到缓冲区，接下来的读操作都是从缓冲区内获取数据，避免每次都从数据源读取数据进行字符编码转换，从而提高读取操作的效率。&lt;/p&gt;
&lt;p&gt;使用BufferedReader读取文本文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class TestBufferedReader {

    public static void main(String[] args) {
        FileReader reader=null;
        BufferedReader br=null;
        try {
            //创建字符读入流
            reader=new FileReader(&quot;D:\\a.txt&quot;);
            //将字符读入流包装成字符缓冲流
            br=new BufferedReader(reader);
            //记录每行读入的内容
            String line=null;
            //用于拼接保存每行读入的内容
            StringBuffer content=new StringBuffer();
            while ((line=br.readLine())!=null) {
                content.append(line+&quot;\n&quot;);
            }
            System.out.println(&quot;所有内容：&quot;);
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (reader!=null) {
                    reader.close();
                }
                if (br!=null) {
                    br.close();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;BufferedReader 是 Reader 的子类，带有缓冲区，特有方法 readLine() 按行读取内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BufferedWriter 类带有缓冲区，与BufferedReader的方向正好相反，BufferedWriter 是把一批数据写到缓冲区，当缓冲区满的时候，再把缓冲区的数据写到字符输出流中。避免每次都执行物理写操作，提高写操作的效率。&lt;/p&gt;
&lt;p&gt;使用 BufferedWriter 写文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class TestBufferedWriter {

    public static void main(String[] args) {
        FileWriter writer=null;
        BufferedWriter bw=null;
        try {
            writer=new FileWriter(&quot;D:\\out.txt&quot;);
            bw=new BufferedWriter(writer);
            bw.write(&quot;hello&quot;);
            //内容换行
            bw.newLine();
            bw.write(&quot;world&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (bw!=null) {
                    bw.close();
                }
                if (writer!=null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关闭流的顺序与创建流的顺序相反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据流&quot;&gt;数据流&lt;/h2&gt;
&lt;p&gt;DataInputStream 类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileInputStream 的子类&lt;/li&gt;
&lt;li&gt;与 FileInputStream 类结合使用读取二进制文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DataOutputStream 类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileOutputStream 的子类&lt;/li&gt;
&lt;li&gt;与 FileOutputStream 类结合使用写二进制文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用数据流复制图片&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class TestCopy {

    public static void main(String[] args) {
        //文件输入流
        FileInputStream fis=null;
        //数据输入流(包装fis得到)
        DataInputStream dis=null;
        //文件输出流
        FileOutputStream fos=null;
        //数据输出流(包装fos得到)
        DataOutputStream dos=null;
        
        try {
            fis=new FileInputStream(&quot;D:\\a.jpg&quot;);
            dis=new DataInputStream(fis);
            fos=new FileOutputStream(&quot;F:\\b.jpg&quot;);
            dos=new DataOutputStream(fos);
            //缓冲数组
            byte[] buff=new byte[1024];
            //记录每次读取的字节个数
            int len=0;
            //循环读入
            while((len=dis.read(buff))!=-1) {
                //循环写入len个字节
                dos.write(buff,0,len);
            }
            System.out.println(&quot;完成&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (dis!=null) {
                    dis.close();
                }
                if (dos!=null) {
                    dos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 31 Oct 2018 12:09:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>File类的使用 Java程序如何访问文件？通过 java.io.File 类 使用File类需要先创建文件对象 ，创建时在构造函数中指定物理文件或目录，然后通过文件对象的方法操作文件或目录的属性。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9885564.html</dc:identifier>
</item>
<item>
<title>linux每日命令(9)：cp命令 - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/9885476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/9885476.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;cp [参数] source dest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp [参数] source... directory&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;将源文件复制至目标文件，或将多个源文件复制至目标目录。&lt;/p&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;-b&lt;/td&gt;
&lt;td&gt;--backup,删除、覆盖目的文件先备份，备份的文件或目录亦建立为符号链接，并指向源文件或目录链接的源文件或目录。假如没有加上这个参数，在复制过程中若遇到符号链接，则会直接复制源文件或目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;覆盖已经存在的目标文件而不给出提示。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;--no-clobber,不要覆盖已存在的文件(使前面的 -i 选项失效)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;--preserve ,除复制文件的内容外，还保留源文件或目录的属性，包括所有者、所属组、权限与修改时间也复制到新文件中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-P&lt;/td&gt;
&lt;td&gt;--parents ,保留源文件或目录的路径，此路径可以是绝对路径或相对路径，且目的目录必须已经存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-R&lt;/td&gt;
&lt;td&gt;--recursive , 递归处理，将指定目录下的文件及子目录一并处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;--symbolic-link， 对源文件建立符号链接，而非复制文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;对源文件生成硬链接文件。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;复制单个文件到目标目录文件在目标目录中不存在&quot;&gt;1. 复制单个文件到目标目录，文件在目标目录中不存在&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp log1 dir2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/test$ tree ../test/
../test/
├── dir2
├── dir3
│   ├── dir1
│   ├── file2.txt
│   ├── log2
│   └── log2~
└── log1
hc@hc-virtual-machine:~/test$ ll log1 
-rw-r--r-- 1 hc hc 0 10月 31 19:18 log1
hc@hc-virtual-machine:~/test$ cp log1 dir2
hc@hc-virtual-machine:~/test$ tree ../test/
../test/
├── dir2
│   └── log1
├── dir3
│   ├── dir1
│   ├── file2.txt
│   ├── log2
│   └── log2~
└── log1
hc@hc-virtual-machine:~/test$ cd dir2
hc@hc-virtual-machine:~/test/dir2$ ll log1 
-rw-r--r-- 1 hc hc 0 10月 31 19:19 log1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目标文件存在时，会覆盖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/test$ ll
总用量 16
drwxr-xr-x  4 hc hc 4096 10月 31 19:18 ./
drwxr-xr-x 25 hc hc 4096 10月 31 19:13 ../
drwxr-xr-x  2 hc hc 4096 10月 31 19:19 dir2/
drwxr-xr-x  3 hc hc 4096 10月 30 10:08 dir3/
-rw-r--r--  1 hc hc    0 10月 31 19:18 log1
hc@hc-virtual-machine:~/test$ cp -a log1 dir2
hc@hc-virtual-machine:~/test$ cd dir2
hc@hc-virtual-machine:~/test/dir2$ ll
总用量 8
drwxr-xr-x 2 hc hc 4096 10月 31 19:19 ./
drwxr-xr-x 4 hc hc 4096 10月 31 19:18 ../
-rw-r--r-- 1 hc hc    0 10月 31 19:18 log1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上参数 -i会询问是否覆盖，-f强制覆盖&lt;br/&gt;说明：&lt;/p&gt;
&lt;p&gt;在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。&lt;/p&gt;
&lt;h2 id=&quot;复制整个目录&quot;&gt;2. 复制整个目录&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;p&gt;复制dir3目录到dir2目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -a dir3 dir2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制dir2目录到dir3目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -t dir2 dir3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;目标目录存在时：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/test$ tree ../test/
../test/
├── dir2
│   └── log1
├── dir3
│   ├── dir1
│   ├── file2.txt
│   ├── log2
│   └── log2~
└── log1

3 directories, 5 files
hc@hc-virtual-machine:~/test$ cp -a dir3 dir2
hc@hc-virtual-machine:~/test$ tree ../test/
../test/
├── dir2
│   ├── dir3
│   │   ├── dir1
│   │   ├── file2.txt
│   │   ├── log2
│   │   └── log2~
│   └── log1
├── dir3
│   ├── dir1
│   ├── file2.txt
│   ├── log2
│   └── log2~
└── log1

5 directories, 8 files
hc@hc-virtual-machine:~/test$ cp -r dir2 dir3
hc@hc-virtual-machine:~/test$ tree ../test/
../test/
├── dir2
│   ├── dir3
│   │   ├── dir1
│   │   ├── file2.txt
│   │   ├── log2
│   │   └── log2~
│   └── log1
├── dir3
│   ├── dir1
│   ├── dir2
│   │   ├── dir3
│   │   │   ├── dir1
│   │   │   ├── file2.txt
│   │   │   ├── log2
│   │   │   └── log2~
│   │   └── log1
│   ├── file2.txt
│   ├── log2
│   └── log2~
└── log1

8 directories, 12 files&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目标目录不存在时：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/test$ ls
dir2  dir3  log1
hc@hc-virtual-machine:~/test$ cp -r dir2 dir4
hc@hc-virtual-machine:~/test$ cp -a dir3 dir5
hc@hc-virtual-machine:~/test$ ll
总用量 24
drwxr-xr-x  6 hc hc 4096 10月 31 19:36 ./
drwxr-xr-x 25 hc hc 4096 10月 31 19:13 ../
drwxr-xr-x  3 hc hc 4096 10月 31 19:30 dir2/
drwxr-xr-x  4 hc hc 4096 10月 31 19:32 dir3/
drwxr-xr-x  3 hc hc 4096 10月 31 19:36 dir4/
drwxr-xr-x  4 hc hc 4096 10月 31 19:32 dir5/
-rw-r--r--  1 hc hc    0 10月 31 19:18 log1
hc@hc-virtual-machine:~/test$ tree ../test/
../test/
├── dir2
│   ├── dir3
│   │   ├── dir1
│   │   ├── file2.txt
│   │   ├── log2
│   │   └── log2~
│   └── log1
├── dir3
│   ├── dir1
│   ├── dir2
│   │   ├── dir3
│   │   │   ├── dir1
│   │   │   ├── file2.txt
│   │   │   ├── log2
│   │   │   └── log2~
│   │   └── log1
│   ├── file2.txt
│   ├── log2
│   └── log2~
├── dir4
│   ├── dir3
│   │   ├── dir1
│   │   ├── file2.txt
│   │   ├── log2
│   │   └── log2~
│   └── log1
├── dir5
│   ├── dir1
│   ├── dir2
│   │   ├── dir3
│   │   │   ├── dir1
│   │   │   ├── file2.txt
│   │   │   ├── log2
│   │   │   └── log2~
│   │   └── log1
│   ├── file2.txt
│   ├── log2
│   └── log2~
└── log1

16 directories, 23 files&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。&lt;/p&gt;
&lt;h2 id=&quot;复制的-log.log-建立一个连结档-log_link.log&quot;&gt;3.复制的 log.log 建立一个连结档 log_link.log&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -s log1 log1_link&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/test$ ls
dir2  dir3  dir4  dir5  log1
hc@hc-virtual-machine:~/test$ cp -s log1 log1_link
hc@hc-virtual-machine:~/test$ ls
dir2  dir3  dir4  dir5  log1  log1_link
hc@hc-virtual-machine:~/test$ ll
总用量 24
drwxr-xr-x  6 hc hc 4096 10月 31 19:47 ./
drwxr-xr-x 25 hc hc 4096 10月 31 19:13 ../
drwxr-xr-x  3 hc hc 4096 10月 31 19:30 dir2/
drwxr-xr-x  4 hc hc 4096 10月 31 19:32 dir3/
drwxr-xr-x  3 hc hc 4096 10月 31 19:36 dir4/
drwxr-xr-x  4 hc hc 4096 10月 31 19:32 dir5/
-rw-r--r--  1 hc hc    0 10月 31 19:18 log1
lrwxrwxrwx  1 hc hc    4 10月 31 19:47 log1_link -&amp;gt; log1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;那个 log1_link 是由 -s 的参数造成的，建立的是一个『快捷方式』，所以会看到在文件的最右边，会显示这个文件是『连结』到哪里去的！&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 11:54:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<og:description>一．命令格式： cp [参数] source dest 或 cp [参数] source... directory 二．命令功能： 将源文件复制至目标文件，或将多个源文件复制至目标目录。 三. 命令参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/9885476.html</dc:identifier>
</item>
<item>
<title>Tigase 发送消息的流程源码分析 - jianfulove</title>
<link>http://www.cnblogs.com/eyecool/p/9885062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eyecool/p/9885062.html</guid>
<description>&lt;p&gt;XMPP 的&amp;lt;message/&amp;gt;节是使用基本的”push”方法来从一个地方到另一个地方得到消息。因为消息通常是不告知的，它们是一种”fire-and-forget”(发射后自寻目的)的机制来从一个地方到另一个地方快速获取信息&lt;br/&gt;消息节有五种不同的类型，通过 type 属性来进行区分：例如 chat 类型为 chat 的消息在两个实体间的实时对话中交换，例如两个朋友之间的即时通讯聊天。除了 type 属性外，消息节还包括一个 to 和 from 地址，并且也可以包含一个用于跟踪目的的 id  属性（我们在使用更为广泛的 IQ  节中详细的讨论 IDs）。to  地址是预期接收人的&lt;br/&gt;JabberID，from 地址是发送者的JabberID。from 地址不由发送客户端提供，而是由发送者的服务器添加邮戳，以避免地址欺骗。&lt;/p&gt;
&lt;p&gt;在Tigase中，有两个重要的组成,一个组件,二是插件,可以去官方网去看下他的架构介绍 https://docs.tigase.net/tigase-server/7.1.4/Development_Guide/html/#writePluginCode&lt;/p&gt;
&lt;p&gt;例如最著名的组件的一个例子是MUC或PubSub。在Tigase中，几乎所有东西实际上都是一个组件:会话管理器、s2s连接管理器、消息路由器等等,组件是根据服务器配置加载的，新的组件可以在运行时加载和激活。您可以轻松地替换组件实现，唯一要做的更改是配置条目中的类名。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Tigase 中定义一个最简单的消息组件,需要实现MessageReceiver或继承 extends AbstractMessageReceiver 类, MessageReceiver 的抽象类: AbstractMessageReceiver 子类 :&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;p&gt;一、ClientConnectionManager&lt;/p&gt;
&lt;p&gt;二、SessionManager&lt;/p&gt;
&lt;p&gt;三、 MessageRouter&lt;/p&gt;
&lt;div readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setProperties(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; props){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : msgrcv_names) {
        mr &lt;/span&gt;=&lt;span&gt; conf.getMsgRcvInstance(name);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mr &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MessageReceiver) {
            ((MessageReceiver) mr).setParent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            ((MessageReceiver) mr).start();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、当客户端发送的message消息到tigase服务端，每个一SOCKET连接都会被包装成IOService对象，IOService包含一系列操作socket的方法（接收发送数据等），processSocketData()接收网络数据，由tigase.net处理解析成xml对象，并将packet放到接收队列receivedPackets中再调用serviceListener.packetsReady(this)。由于ConnectionManager实现IOServiceListener接口，实现上调用的的是ConnectionManager中的packetsReady()来开始处理数据&lt;/p&gt;
&lt;p&gt;此时的packet ：packetFrom=null，packetTo=null。&lt;/p&gt;

&lt;p&gt;ClientConnectionManager.processSocketData方法中设置packet的一些属性：&lt;br/&gt;此时: packetFrom=c2s@llooper/192.168.0.33_5222_192.168.0.33_38624, packetTo=sess-man@llooper&lt;/p&gt;
&lt;div readability=&quot;46.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
ClientConnectionManager.processSocketData(XMPPIOService&amp;lt;Object&amp;gt;&lt;span&gt;serv)
    JID id &lt;/span&gt;= serv.getConnectionId(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c2s@llooper/192.168.0.33_5222_192.168.0.33_38624&lt;/span&gt;
    p.setPacketFrom(id); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;packetFrom 设置为onnectionId&lt;/span&gt;
    p.setPacketTo(serv.getDataReceiver()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;packetTo 设置为sess-man --&amp;gt; SessionManager &lt;/span&gt;
    addOutPacket(p);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将会委托给父 MessageRouter 路由&lt;/span&gt;
&lt;span&gt;    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;//packet 被设置上一些源信息，和目的地信息，接下来，这个数据包将会委托给父 MessageRouter 帮忙路由到 SessionManager组件中进行处理&lt;br/&gt;packet = (tigase.server.Message) from=c2s@llooper/192.168.0.33_5222_192.168.0.33_38624, to=sess-man@llooper, DATA=&amp;lt;message xmlns=&quot;jabber:client&quot; id=&quot;44grM-176&quot; type=&quot;chat&quot; to=&quot;llooper@llooper&quot;&amp;gt;&amp;lt;thread&amp;gt;SWjZv5&amp;lt;/thread&amp;gt;&amp;lt;composing xmlns=&quot;http://jabber.org/protocol/chatstates&quot;/&amp;gt;&amp;lt;/message&amp;gt;, SIZE=170, XMLNS=jabber:client, PRIORITY=NORMAL, PERMISSION=NONE, TYPE=chat&lt;/p&gt;

&lt;p&gt;packet = from=c2s@llooper/192.168.0.33_5222_192.168.0.33_38624, to=sess-man@llooper, DATA=&amp;lt;message to=&quot;admin@llooper&quot; type=&quot;chat&quot; id=&quot;2jePE-253&quot; xmlns=&quot;jabber:client&quot;&amp;gt;&amp;lt;thread&amp;gt;7VKMRq&amp;lt;/thread&amp;gt;&amp;lt;composing xmlns=&quot;http://jabber.org/protocol/chatstates&quot;/&amp;gt;&amp;lt;/message&amp;gt;, SIZE=168, XMLNS=jabber:client, PRIORITY=NORMAL, PERMISSION=NONE, TYPE=chat&lt;/p&gt;

&lt;p&gt;2、MessageRouter.processPacket(Packet packet)部分代码如下：&lt;/p&gt;

&lt;div readability=&quot;47.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们不会处理没有目标地址的数据包,只是丢弃它们并写一个日志消息&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (packet.getTo() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    log.log(Level.WARNING, &lt;/span&gt;&quot;Packet with TO attribute set to NULL: {0}&quot;&lt;span&gt;, packet);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}   


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;它不是一个服务发现包，我们必须找到一个处理组件
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的代码块是“快速”找到一个组件if

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个包TO 组件ID,格式在以下一项:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1。组件名+“@”+默认域名
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2。组件名+“@”+任何虚拟主机名
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3。组件名+ &quot;.&quot;+默认域名
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4。组件名+ &quot;.&quot;+任何虚拟主机名&lt;/span&gt;
&lt;span&gt;
ServerComponent comp &lt;/span&gt;= getLocalComponent(packet.getTo()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SessionManager&lt;/span&gt;
comp.processPacket(packet, results);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3、SessionManager.processPacket(final Packet packet)处理，有要代码如下。 例如A-&amp;gt;B,这样做的目的是为了首先确定用户A有权限发送packet，然后是确定用户B有权限接收数据。如果用户B不在线，那么离线消息处理器会把packet保存到数据库当中。&lt;/p&gt;
&lt;div readability=&quot;33.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XMPPResourceConnection session——用户会话保存所有用户会话数据，并提供对用户数据存储库的访问。它只允许在会话的生命周期内将信息存储在永久存储或内存中。如果在分组处理时没有联机用户会话，则此参数可以为空。&lt;/span&gt;
XMPPResourceConnection conn =&lt;span&gt; getXMPPResourceConnection(packet);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在要走SessionManager的处理函数,主要是走插件流程,插件在Tigase中也是一个重要的组成,入口就是在这里,SM plugin&lt;/span&gt;
processPacket(packet, conn);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   &lt;strong&gt;插入下SM plugin 流程说明 :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个设计有一个惊人的结果。如果你看下面的图片，显示了两个用户之间的通信，你可以看到数据包被复制了两次才送到最终目的地: &lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1207931/201810/1207931-20181031184636289-1050337104.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;会话管理器(SessionManager)必须对数据包进行两次处理。第一次以用户A的名义将其作为传出包进行处理，第二次以用户B的名义将其作为传入包进行处理。&lt;br/&gt;这是为了确保用户A有权限发送一个包，所有的processor都应用到packet上，也为了确保用户B有权限接收packet，所有的processor都应用到packet了。例如，如果用户B是脱机的，那么有一个脱机消息processor应该将包发送到数据库，而不是用户B。&lt;/div&gt;

&lt;div readability=&quot;42.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; XMPPResourceConnection getXMPPResourceConnection(Packet p) {
        XMPPResourceConnection conn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先根据这个包的发起者,来查找他的连接资源类,找不到则找接收者的资源类&lt;/span&gt;
        JID    from =&lt;span&gt; p.getPacketFrom();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (from != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            conn &lt;/span&gt;=&lt;span&gt; connectionsByFrom.get(from);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (conn != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个接收者它可能是这个服务器上某个用户的消息,让我们为这个用户查找已建立的会话&lt;/span&gt;
        JID to =&lt;span&gt; p.getStanzaTo();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (to != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isLoggable(Level.FINEST)) {
                log.finest(&lt;/span&gt;&quot;Searching for resource connection for: &quot; +&lt;span&gt; to);
            }
            conn &lt;/span&gt;=&lt;span&gt; getResourceConnection(to);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hm, not sure what should I do now....
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Maybe I should treat it as message to admin....&lt;/span&gt;
&lt;span&gt;            log.log(Level.INFO,
                    &lt;/span&gt;&quot;Message without TO attribute set, don''t know what to do wih this: {0}&quot;&lt;span&gt;, p);
        }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of else&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
    }
    
    
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processPacket(Packet packet, XMPPResourceConnection conn) {

    ...
    packet.setPacketTo(getComponentId()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sess-man@llooper&lt;/span&gt;
&lt;span&gt;    ...

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;stop) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;授权匹配的processor处理packet&lt;/span&gt;
&lt;span&gt;        walk(packet, conn);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((conn != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt; conn.getConnectionId().equals(packet.getPacketFrom())) {
                handleLocalPacket(packet, conn);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoConnectionIdException ex) {
            ...
        }
    }
    
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;packetTo被设置为组件ID（sess-man@llooper），其值原先也是这个。&lt;br/&gt;其中walk(packet, conn)方法，匹配处理器（授权）。对于message，此处匹配到的processor是amp和message-carbons，message-carbons没有怎么处理，主要是amp在处理,packet被塞amp的队列中等待处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; walk(&lt;span&gt;final&lt;/span&gt; Packet packet, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; XMPPResourceConnection connection) {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (XMPPProcessorIfc proc_t : processors.values()) {
            XMPPProcessorIfc processor &lt;/span&gt;=&lt;span&gt; proc_t;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据element和xmlns，授权匹配成功的processor&lt;/span&gt;
            Authorization    result    =&lt;span&gt; processor.canHandle(packet, connection);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result ==&lt;span&gt; Authorization.AUTHORIZED) {
                ....
            
                ProcessingThreads pt &lt;/span&gt;=&lt;span&gt; workerThreads.get(processor.id());

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pt == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    pt &lt;/span&gt;=&lt;span&gt; workerThreads.get(defPluginsThreadsPool);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packet 放到(addItem)授权了的processor的队列&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pt.addItem(processor, packet, connection)) {
                    packet.processedBy(processor.id());
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                    ...
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ...
            }
        }   
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WorkerThread.run() 从队列中取出packet，由SessionManager.process(QueueItem item)给amp处理。&lt;/p&gt;
&lt;p&gt;SessionManager.pocess(QueueItem item) 如下：&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(QueueItem item) {
    
    XMPPProcessorIfc processor &lt;/span&gt;=&lt;span&gt; item.getProcessor();

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由授权的 processor 处理 packet&lt;/span&gt;
&lt;span&gt;        processor.process(item.getPacket(), item.getConn(), naUserRepository,local_results, plugin_config.get(processor.id()));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.getConn() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            setPermissions(item.getConn(), local_results);
        }
        addOutPackets(item.getPacket(), item.getConn(), local_results);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (PacketErrorTypeException e) {
        ...
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (XMPPException e) {
        ...
    }
}


&lt;span&gt;//其中processor.process（）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;------&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; MessageAmp.process()，如下：&lt;/span&gt;

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(Packet packet, XMPPResourceConnection session,
        NonAuthUserRepository repo, Queue results, Map settings) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; XMPPException {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (packet.getElemName() == &quot;presence&quot;&lt;span&gt;) {
        ...
        
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        Element amp &lt;/span&gt;= packet.getElement().getChild(&quot;amp&quot;&lt;span&gt;, XMLNS);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((amp == &lt;span&gt;null&lt;/span&gt;) || (amp.getAttributeStaticStr(&quot;status&quot;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
            messageProcessor.process(packet, session, repo, results, settings);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            ...
    }
}

&lt;span&gt;// 其中messageProcessor.process（） &lt;/span&gt;&lt;/span&gt;&lt;span&gt;--------&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; Message.process()，如下
&lt;/span&gt;

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(Packet packet, XMPPResourceConnection session,
        NonAuthUserRepository repo, Queue results, Map settings) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; XMPPException {

    ...
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在比较JIDs之前，记住要去除资源部分&lt;/span&gt;
        id = (packet.getStanzaFrom() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;?&lt;span&gt; packet.getStanzaFrom().getBareJID()
                : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查这是否是来自客户端的数据包&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (session.isUserId(id)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是来自这个客户端的数据包，最简单的操作是转发到它的目的地:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Simple clone the XML element and....
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... putting it to results queue is enough&lt;/span&gt;
&lt;span&gt;            results.offer(packet.copyElementOnly());

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NotAuthorizedException e) {
        ...
    }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of try-catch&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;检查stanzaFfrom与session匹配通过后，将packet.copyElementOnly()放到results中，作后续投递，原来的packet 就丢弃了。&lt;br/&gt;此时投递的packet ：packetFrom=null，packetTo=null。&lt;/p&gt;
&lt;p&gt;packet在SessionManager.addOutPacket(Packet packet)中判断packetFrom是否为空，为空则将其设置为ComponentId（此处为sess-man@llooper），然后调用父类（AbstractMessageReceiver.java) 的addOutPacket(packet)方法塞到out_queue 队列中。&lt;br/&gt;此时packet:：packetFrom=sess-man@llooper，packetTo=null。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;4、上层组件MessageRouter处理,把packet塞到in_queues. 又回到了MessageRouter.processPacket(Packet packet)处理:&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;不同的是 PacketTo为空，packet.getTo()的返回值是stanzaTo。&lt;br/&gt;getLocalComponent(packet.getTo());方法根据stanzaTo与compId、comp name、Component都匹配不到。&lt;br/&gt;此时packet会给组件SessionManager处理，Packet will be processed by: sess-man@llooper，由AbstractMessageReceiver的非阻塞性方法addPacketNB(Packet packet)加入到in_queues。&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt; 5、第二次来到SessionManager.processPacket(final Packet packet)处理。不同的是在getXMPPResourceConnection(packet)方法中，&lt;br/&gt;conn = connectionsByFrom.get(from)返回值是null，所以是根据stanzaTo取获取接收方的session，返回接收方连接的Connection。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; XMPPResourceConnection getXMPPResourceConnection(Packet p) {
    XMPPResourceConnection conn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    JID                    from &lt;/span&gt;=&lt;span&gt; p.getPacketFrom();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (from != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        conn &lt;/span&gt;=&lt;span&gt; connectionsByFrom.get(from);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (conn != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It might be a message _to_ some user on this server
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; so let's look for established session for this user...&lt;/span&gt;
    JID to =&lt;span&gt; p.getStanzaTo();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (to != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        ...
        conn &lt;/span&gt;=&lt;span&gt; getResourceConnection(to);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

        ...
    }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of else&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 6、如同步骤3,此时packet作为一个以用户B的名义将其作为传入包进行处理。&lt;/p&gt;
&lt;p&gt;然后packetTo被设置为组件ID（sess-man@llooper)&lt;/p&gt;
&lt;p&gt;此时packet: packetFrom = sess-man@llooper，packetTo =sess-man@llooper。&lt;/p&gt;
&lt;p&gt;之后packet又经walk(packet, conn)方法，匹配处理器（授权），扔给amp处理。&lt;/p&gt;
&lt;p&gt; 如同前面: 直到Message.process()，如下：&lt;/p&gt;
&lt;div readability=&quot;29&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; process(Packet packet, XMPPResourceConnection session,
        NonAuthUserRepository repo, Queue&lt;/span&gt;&amp;lt;Packet&amp;gt; results, Map&amp;lt;String, Object&amp;gt; settings) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; XMPPException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For performance reasons it is better to do the check
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; before calling logging method.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isLoggable(Level.FINEST)) {
        log.log(Level.FINEST, &lt;/span&gt;&quot;Processing packet: {0}, for session: {1}&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] {
                packet,
                session });
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; You may want to skip processing completely if the user is offline.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (session == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        processOfflineUser( packet, results );
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of if (session == null)&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remember to cut the resource part off before comparing JIDs&lt;/span&gt;
        BareJID id = (packet.getStanzaTo() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;?&lt;span&gt; packet.getStanzaTo().getBareJID()
                : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Checking if this is a packet TO the owner of the session&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (session.isUserId(id)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isLoggable(Level.FINEST)) {
                log.log(Level.FINEST, &lt;/span&gt;&quot;Message 'to' this user, packet: {0}, for session: {1}&quot;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] { packet,
                        session });
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (packet.getStanzaFrom() != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; session.isUserId(packet.getStanzaFrom().getBareJID())) {
                JID connectionId &lt;/span&gt;=&lt;span&gt; session.getConnectionId();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (connectionId.equals(packet.getPacketFrom())) {
                    results.offer(packet.copyElementOnly());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this would cause message packet to be stored in offline storage and will not
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; send recipient-unavailable error but it will behave the same as a message to
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; unavailable resources from other sessions or servers&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Yes this is message to 'this' client&lt;/span&gt;
            List&amp;lt;XMPPResourceConnection&amp;gt; conns = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;XMPPResourceConnection&amp;gt;(5&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is where and how we set the address of the component
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; which should rceive the result packet for the final delivery
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to the end-user. In most cases this is a c2s or Bosh component
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; which keep the user connection.&lt;/span&gt;
            String resource =&lt;span&gt; packet.getStanzaTo().getResource();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (resource == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the message is sent to BareJID then the message is delivered to
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; all resources&lt;/span&gt;
&lt;span&gt;                conns.addAll(getConnectionsForMessageDelivery(session));
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise only to the given resource or sent back as error.&lt;/span&gt;
                XMPPResourceConnection con =&lt;span&gt; session.getParentSession().getResourceForResource(
                        resource);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (con != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    conns.add(con);
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MessageCarbons: message cloned to all resources? why? it should be copied only
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to resources with non negative priority!!&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (conns.size() &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (XMPPResourceConnection con : conns) {
                    Packet result &lt;/span&gt;=&lt;span&gt; packet.copyElementOnly();

                    result.setPacketTo(con.getConnectionId());

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; In most cases this might be skept, however if there is a
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; problem during packet delivery an error might be sent back&lt;/span&gt;
&lt;span&gt;                    result.setPacketFrom(packet.getTo());

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't forget to add the packet to the results queue or it
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; will be lost.&lt;/span&gt;
&lt;span&gt;                    results.offer(result);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isLoggable(Level.FINEST)) {
                        log.log(Level.FINEST, &lt;/span&gt;&quot;Delivering message, packet: {0}, to session: {1}&quot;&lt;span&gt;,
                                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] { packet,
                                con });
                    }
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if there are no user connections we should process packet
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the same as with missing session (i.e. should be stored if
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; has type 'chat'&lt;/span&gt;
&lt;span&gt;                processOfflineUser( packet, results );
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of else

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remember to cut the resource part off before comparing JIDs&lt;/span&gt;
        id = (packet.getStanzaFrom() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;?&lt;span&gt; packet.getStanzaFrom().getBareJID()
                : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Checking if this is maybe packet FROM the client&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (session.isUserId(id)) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is a packet FROM this client, the simplest action is
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to forward it to is't destination:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Simple clone the XML element and....
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... putting it to results queue is enough&lt;/span&gt;
&lt;span&gt;            results.offer(packet.copyElementOnly());

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Can we really reach this place here?
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Yes, some packets don't even have from or to address.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The best example is IQ packet which is usually a request to
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the server for some data. Such packets may not have any addresses
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; And they usually require more complex processing
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is how you check whether this is a packet FROM the user
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; who is owner of the session:&lt;/span&gt;
        JID jid =&lt;span&gt; packet.getFrom();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This test is in most cases equal to checking getElemFrom()&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (session.getConnectionId().equals(jid)) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do some packet specific processing here, but we are dealing
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; with messages here which normally need just forwarding&lt;/span&gt;
            Element el_result =&lt;span&gt; packet.getElement().clone();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we are here it means FROM address was missing from the
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; packet, it is a place to set it here:&lt;/span&gt;
            el_result.setAttribute(&quot;from&quot;&lt;span&gt;, session.getJID().toString());

            Packet result &lt;/span&gt;=&lt;span&gt; Packet.packetInstance(el_result, session.getJID(), packet
                    .getStanzaTo());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... putting it to results queue is enough&lt;/span&gt;
&lt;span&gt;            results.offer(result);
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NotAuthorizedException e) {
        log.log(Level.FINE, &lt;/span&gt;&quot;NotAuthorizedException for packet: &quot; + packet + &quot; for session: &quot; +&lt;span&gt; session, e);
        results.offer(Authorization.NOT_AUTHORIZED.getResponseMessage(packet,
                &lt;/span&gt;&quot;You must authorize session first.&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
    }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of try-catch&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查stanzaTo与session匹配通过后，根据session拿到接收方所有的连接（可能多端登陆），然后Packet result = packet.copyElementOnly()生成新的packet（原packet丢弃了），并将packetTo设置为接收方连接的ConnectionId（例如：c2s@llooper/192.168.0.33_5222_192.168.0.33_38624），通过addOutPacket()方法塞到out_queue队列。&lt;br/&gt;此时packet：packetFrom = sess-man@llooper，packetTo =c2s@llooper/192.168.0.33_5222_192.168.0.33_38624。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;7、 如同前面步骤2,不同的是根据packetTo匹配到组件 c2s@llooper&lt;/p&gt;
&lt;p&gt;8、 组件 c2s@llooper 从queue中取出packet，分发到目的地&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processPacket(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Packet packet) {
    ...
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (packet.isCommand() &amp;amp;&amp;amp; (packet.getCommand() !=&lt;span&gt; Command.OTHER)) {
        ...
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把packet 发送给客户端&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;writePacketToSocket(packet)) {

            ...
            
        }
    }    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end of else&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后续有时间会不断更新,欢迎加入QQ群 310790965 更多的交流&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 31 Oct 2018 11:15:00 +0000</pubDate>
<dc:creator>jianfulove</dc:creator>
<og:description>XMPP 的&lt;message/&gt;节是使用基本的”push”方法来从一个地方到另一个地方得到消息。因为消息通常是不告知的，它们是一种”fire-and-forget”(发射后自寻目的)的机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eyecool/p/9885062.html</dc:identifier>
</item>
</channel>
</rss>