<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>网易游戏——两年测试工作体会 - Xander-Hang</title>
<link>http://www.cnblogs.com/Blaxon/p/9294534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Blaxon/p/9294534.html</guid>
<description>&lt;p&gt;个人感想&lt;/p&gt;
&lt;p&gt;     总的来说，2年的时间收获了很多，不仅是知识上的，还有人际关系，视野等，很感谢网易带给我了这么多新内容。谈谈自己喜欢在这里工作的点吧，首先，作为一个游戏公司不得不说公司非常开明，而且这里有很多喜爱游戏的玩家，而且大多数技术不俗，能在这个环境里面工作是非常幸福的（不过工作内容就另说2333），公司也会定期组织电竞比赛，奖品就是送游戏机，简单粗暴。公司的km上也会及时的分享游戏市场的最新动态，能够了解国内外游戏市场的最新新闻，这对于游戏爱好者来说是非常棒的一件事情；其次，猪场这个名字不是白叫的，递交了辞职信才发现公司给我提供的三餐服务其实算做工资每个月也有1、2k了，这确实是个实实在在的福利，味道确实也比外面好不少，虽说最近品质有所下降；另外就是工资，确实给得比较高，和腾讯爸爸比可能差点，但同行业甚至是互联网行业，能给QA开这么高工资的确实很少见的。&lt;/p&gt;
&lt;p&gt;     当然好的说在前面，后面就是要吐槽一下在公司不好的地方了。首当其冲的就是加班。。不过这事得看部门，有些部门还是ok的，不过像是在项目研发期的部门，加班真是加死个人，早上九点半上班，晚上10点往后才能下班，一周6天，还不知道哪天周日会被喊去加班。我待的部门因为今年马上要上线，已经疯狂加班了大半年，长期以往人的精神和身体确实都会吃不消；另外，公司的用人制度，来到网易才发现公司是没有老员工的，40不到基本就是公司元老级别的人物了，又由于公司为扁平化管理，管理岗一共就一点人，对于我们底层的员工来看，升迁难度大。一方面是同僚的竞争，一方面是上级不往上爬也没坑没机会；最后一点就是工作内容，网易的游戏怎么说呢？就像知乎上说的，什么都好，就是不好玩。。。我个人是非常赞同的，公司是大话梦幻发家，回合制便是基因，做什么都强调数值的重要性，往回合类型上靠。又因为公司个工作室独立性强，竞争激烈，从而导致了各个大佬导都不敢走创新的路子，大家都在前人的道路上做稍微修改，求稳有余，但真不好玩。。。不过话说回来，我感觉杭州方面的游戏项目创新力度还是很强的。&lt;/p&gt;

&lt;p&gt;好的地方&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;公司学习氛围浓厚，重视分享和影响力，知识平台还有最新的行业资讯，对个人能力的提升很有帮助&lt;/li&gt;
&lt;li&gt;同事间关系平等，交流轻松愉快，以“同学”相称很有爱，而且同事技术水平都很高&lt;/li&gt;
&lt;li&gt;猪场的伙食非常棒，但也容易发胖，一个月免去上千的吃饭费用吧，但一年下来胖了10斤。。&lt;/li&gt;
&lt;li&gt;职级评审较为透明，各个等级的晋升都有明确的指标，升级打怪目标明确&lt;/li&gt;
&lt;li&gt;网易游戏光环，在信息港算是最好的了吧，在广州出门说自己是网易的还是很有自豪感的&lt;/li&gt;
&lt;li&gt;公司美术水平非常高，能够接触到大神，作为一个互联网公司，有一半的美术工作人员，公司颜值担当&lt;/li&gt;
&lt;li&gt;待遇有竞争力，我进去的时候试用期还要算成80%，不过听说下一届就全额了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不好的地方&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;扁平管理，一个萝卜一个坑，晋升空间有限，特别现在网易游戏的势头有点危险的时候，更是竞争激烈&lt;/li&gt;
&lt;li&gt;技术封闭，网易使用自研引擎，技术壁垒高，外面人不容易进来，里面的人也不好出去。从某个角度讲，你进去的时间越长，你对公司的议价能力就越低&lt;/li&gt;
&lt;li&gt;加班严重，游戏行业普遍现状，对个人身体健康是一个挑战，仁者见仁&lt;/li&gt;
&lt;li&gt;机会都是给赚钱项目的，项目赚钱鸡犬升天，项目不行技术再好也难有机会出头&lt;/li&gt;
&lt;li&gt;行政抠门，公司福利捉急，20周年庆发usb小风扇什么的就不说了。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对QA职业的发展影响&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;作为校招入职者来说，公司的入职培训是非常给力的，能够给到一个非常全面的职业技能指导和培养，对个人职业水平提升很大，我觉得这是一个非常宝贵的财富&lt;/li&gt;
&lt;li&gt;手游项目周期短，能够短时间内接触到游戏研发测试的多个方面，能够快速的了解游戏的测试流程；但是又因为游戏的特性，项目九死一生对于测试工作的沉淀非常有限&lt;/li&gt;
&lt;li&gt;网易游戏也算是国内游戏行业的元老了，对于研发流程上的配套工具或测试工具都比较完善，当前作为测试要做开荒性质的工具开发对于个人能力的要求就非常高了，大多时候是在前人的基础上进行改良开发，成果有限&lt;/li&gt;
&lt;li&gt;对于跳槽来说，如果还是继续呆在游戏行业，可能好的选择并不多了，大概就是腾讯那边了吧，去其他公司做游戏待遇大多是给不到网易这么丰厚的（ps 育碧很穷）；如果是跳去其它行业，就我的了解来说，基本是从0开始（这里展开来说可以说很多，简单讲就是游戏是一个非常特殊的产品，使用方法也非常特殊，相比于传统的软件测试方法和理论较难覆盖，当然这也是我个人感觉），测试技术和流程和游戏相去甚远&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上就是我这2年工作下来的一个心得体会，虽然离职了，但这也是我的第一份工作，还是非常衷心祝愿网易游戏能在游戏行业越做越好，能够走出国门，并多做一些玩家真正喜爱的游戏。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Jul 2018 07:03:00 +0000</pubDate>
<dc:creator>Xander-Hang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Blaxon/p/9294534.html</dc:identifier>
</item>
<item>
<title>设计模式（十九）—— 备忘录模式 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9292773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9292773.html</guid>
<description>&lt;h2 id=&quot;模式简介&quot;&gt;模式简介&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很多时候我们要记录一个对象的内部状态，为了允许用户撤销不确定的操作或从错误中恢复过来。同时，为了不违反封装的原则，而不能暴露其内部状态和实现。想象一下日常生活中我们经常会遇到重置密码的问题，假设账号密码在初始化后，保留一份备忘录以便今后重置时使用，同样的，我们不能将密码暴露给其它对象。这时，可以使用备忘录模式解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;结构分析&quot;&gt;结构分析&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;uml类图&quot;&gt;UML类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180710203157184-375156139.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色说明&quot;&gt;角色说明&lt;/h3&gt;
&lt;p&gt;备忘录。存储原发器对象的内部状态，防止原发器以外的对象访问备忘录。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Originator&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;原发器。提供一个方法创建备忘录，用以记录当前时刻它的内部状态，并提供一个使用备忘录恢复内部状态的方法。&lt;/p&gt;
&lt;p&gt;负责人。负责保存备忘录，不能对备忘录的内容进行操作或检查。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;管理器向原发器请求一个备忘录，保留一段时间，将其送回原发器。&lt;/p&gt;
&lt;h3 id=&quot;结构代码&quot;&gt;结构代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//备忘录
public class Memento
{
    private string _state;
    public Memento(string state)
    {
        _state = state;
    }

    public string GetState()
    {
        return _state;
    }
}

//原发器
public class Originator
{
    public string State { get; set; }
    public Memento CreateMemento()
    {
        return new Memento(State);
    }
    public void SetMemento(Memento memento)
    {
        Console.WriteLine(&quot;Restoring state...&quot;);
        State = memento.GetState();
    }
}

//负责人
public class Caretaker
{
    public Memento Memento { get; set; }
}

//客户端调用
class Program
{
    static void Main(string[] args)
    {
        Originator originator = new Originator();
        originator.State = &quot;Off&quot;;
        Caretaker caretaker = new Caretaker();
        caretaker.Memento = originator.CreateMemento();
        originator.State = &quot;On&quot;;
        originator.SetMemento(caretaker.Memento);
        Console.WriteLine(originator.State);
        Console.ReadLine();
    }
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180710204207308-1931721855.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例分析&quot;&gt;示例分析&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;本节通过一个重置密码的示例来讲述备忘录模式，首先声明备忘录Memento。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Memento
{
    public string UserName { get; private set; }
    public string Password { get; private set; }
    public Memento(string userName,string password)
    {
        UserName = userName;
        Password = password;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明原发器User，包含UserName和Password属性，提供CreateMemento方法创建备忘录，以及SetMemento方法提供重置功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class User
{
    public string UserName { get; set; }
    public string Password { get; set; }
    public User(string username,string password)
    {
        this.UserName = username;
        this.Password = password;
    }
    public Memento CreateMemento()
    {
        return new Memento(UserName, Password);
    }

    public void SetMemento(Memento memento)
    {
        this.UserName = memento.UserName;
        this.Password = memento.Password;
    }
}

public class UserMemory
{
    public Memento Memento { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用，创建jack账号并创建备忘录，随后修改了两次密码，最后使用备忘录进行重置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        User jack = new User(&quot;jack&quot;, &quot;12345&quot;);
        UserMemory memory = new UserMemory();
        memory.Memento = jack.CreateMemento();
        jack.Password = &quot;23456&quot;;
        jack.Password = &quot;qwert&quot;;
        jack.SetMemento(memory.Memento);
        Console.WriteLine(jack.Password);
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180710213815845-685794399.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;hr/&gt;</description>
<pubDate>Wed, 11 Jul 2018 06:36:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9292773.html</dc:identifier>
</item>
<item>
<title>学习ASP.NET Core Razor 编程系列十五——文件上传功能（三） - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/9294202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/9294202.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列目录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8579777.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列一&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8622439.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列二——添加一个实体&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8651973.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列三——创建数据表及创建项目基本页面&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8717199.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列四——Asp.Net Core Razor列表模板页面&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8778379.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列五——Asp.Net Core Razor新建模板页面&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8872303.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列六——数据库初始化&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8968398.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列七——修改列表页面&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/8986512.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列八——并发处理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/9025896.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列九——增加查询功能&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/9077466.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列十——添加新字段&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/9111862.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列十一——把新字段更新到数据库&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/9178291.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列十二——在页面中增加校验&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/9243055.html&quot;&gt;学习ASP.NET Core Razor 编程系列十三——文件上传功能（一）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/9273635.html&quot;&gt;&lt;span&gt;学习ASP.NET Core Razor 编程系列十四——文件上传功能（二）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;八、添加文件 Razor 页面的链接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       我们通过前面的二篇文章的学习，已经实现了文件上传的主要功能，这一篇文章我们来学习如何把上传文件的功能页面添加到首面上面，以及删除功能的实现 。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在Visual Studio 2017中按F5运行书籍管理应用程序，在浏览器浏览，如下图。但是没有发现上传页面的菜单。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711135747274-1062647381.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;        2.&lt;/span&gt;&lt;span&gt;在Visual Studio 2017中打开“_Layout.cshtml”，然后向导航栏添加一个链接以访问文件上传页面，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711135808949-1505535037.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        3.在Visual Studio 2017中按F5运行书籍管理应用程序，在浏览器浏览，如下图。此时你会发现上传页面的菜单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711135828986-1964790846.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;九、添加文件删除确认页面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      1.  为了更好的用户体验，当用户单击删除上传文件时，要提供一个删除确认的操作。 在Visual Studio 2017的解决方案资源管理器中找到“Descri”文件夹，并添加删除确认页面 (Delete.cshtml),html代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@page &quot;{id:int}&quot;
@model RazorMvcBooks.Pages.Descri.DeleteModel
@{
    ViewData[&quot;Title&quot;] = &quot;删除上传文件&quot;;
}

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;删除上传文件&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;你是否确认要删除此文件?&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;上传文件&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dl &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dl-horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayNameFor(model =&amp;gt; model.Describe.Name)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayFor(model =&amp;gt; model.Describe.Name)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayNameFor(model =&amp;gt; model.Describe.PublicScheduleSize)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayFor(model =&amp;gt; model.Describe.PublicScheduleSize)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayNameFor(model =&amp;gt; model.Describe.PrivateScheduleSize)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayFor(model =&amp;gt; model.Describe.PrivateScheduleSize)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayNameFor(model =&amp;gt; model.Describe.UploadDateTime)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dt&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            @Html.DisplayFor(model =&amp;gt; model.Describe.UploadDateTime)

        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dl&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; asp-for&lt;/span&gt;&lt;span&gt;=&quot;Describe.ID&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Delete&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-default&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt; |
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;asp-page&lt;/span&gt;&lt;span&gt;=&quot;./Index&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Back to List&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;        2. 在Visual Studio 2017的解决方案资源管理器中，打开Delete.cshtml.cs文件，修改Delete.cshtml.cs中的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc.RazorPages;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RazorMvcBooks.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore; 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RazorMvcBooks.Pages.Descri
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeleteModel : PageModel
    { 

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RazorMvcBooks.Models.BookContext _context;
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DeleteModel(RazorMvcBooks.Models.BookContext context)

        {
            _context &lt;/span&gt;=&lt;span&gt; context;
        }


        [BindProperty]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Describe Describe { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; OnGetAsync(&lt;span&gt;int&lt;/span&gt;?&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();

            } 

            Describe &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; _context.Describe.SingleOrDefaultAsync(m =&amp;gt; m.ID ==&lt;span&gt; id); 

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Describe == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();

            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Page();
        } 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OnPostAsync 方法按 id 处理计划删除：&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; OnPostAsync(&lt;span&gt;int&lt;/span&gt;?&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            }
            Describe &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _context.Describe.FindAsync(id); 

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Describe != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                _context.Describe.Remove(Describe);

                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _context.SaveChangesAsync();

            } 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RedirectToPage(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

    }
}

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      3. 在Visual Studio 2017中按F5运行书籍管理应用程序，然后在浏览器中点击“上传文件”菜单，浏览上传文件页面，并上传文件。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140520124-762577187.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     4.  在已上传文件列表中，点击要删除的上传文件记录，按下图操作。用户可单击该表中的“删除”链接以访问删除确认视图，并在其中选择确认或取消删除操作。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140351900-368636339.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     5.  成功删除上传文件后，RedirectToPage 将返回到计划的上传文件（“Index.cshtml”）页面。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140608503-1117192715.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;十、上传文件页面的说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     按初始加载所示计划 Razor 页面，其中不含验证错误和空字段&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;     在不填充任何字段的情况下选择“上传”按钮会违反此模型上的 [Required] 特性。 ModelState 无效。 会向用户显示验证错误消息:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140720704-261521361.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      验证错误消息显示在每个输入控件旁边&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140731359-1653284556.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      在“文件名”字段中键入两个字母。 校验提示信息会提示文件名长度必须介于 3-60 个字符之间:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140811083-573173458.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      文件名文本框中输入“image1”，则校验信息自动会消失,如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140818930-1324033428.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;      上传一个或多个文本文件时，“已上传文件列表”部分会显示已经上传的文件信息，&lt;span&gt;显示每个上传文件的文件名称、UTC 格式的上传时间、公共描述文件的大小和后台描述文件的大小&lt;/span&gt;。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201807/10343-20180711140835160-811337830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Jul 2018 06:09:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/9294202.html</dc:identifier>
</item>
<item>
<title>Java定时任务 - 丰极</title>
<link>http://www.cnblogs.com/zhangbin1989/p/9294114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangbin1989/p/9294114.html</guid>
<description>&lt;p&gt;Java开发过程中经常会遇到使用定时任务的情况，我总结了一下有如下四种方式：Timer、ScheduledExecutorService、SpringTask、Quartz。&lt;/p&gt;

&lt;h2 id=&quot;timer&quot;&gt;1、Timer&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;new Timer(&quot;testTimer&quot;).schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println(&quot;TimerTask&quot;);
            }
        }, 1000,2000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：1000ms是延迟启动时间，2000ms是定时任务周期，每2s执行一次&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
try {
    Date date = dateFormat.parse(&quot;2018-07-11 12:00:00.000&quot;);
    new Timer(&quot;testTimer1&quot;).scheduleAtFixedRate(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;TimerTask&quot;);
        }
    }, date,2000);
} catch (ParseException e) {
    e.printStackTrace();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：date是开始时间，2000ms是定时任务周期，每2s执行一次&lt;br/&gt;timer有2中方法schedule和scheduleAtFixedRate，前者会等任务结束在开始计算时间间隔，后者是在任务开始就计算时间，有并发的情况&lt;/p&gt;

&lt;h2 id=&quot;scheduledexecutorservice&quot;&gt;1、ScheduledExecutorService&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;scheduledExecutorService.schedule(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;ScheduledTask&quot;);
            }
        },1, TimeUnit.SECONDS);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：延迟1s启动，执行一次&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);
        scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;ScheduledTask&quot;);
            }
        }, 1, 1, TimeUnit.SECONDS);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：延迟1s启动，每隔1s执行一次，是前一个任务开始时就开始计算时间间隔，但是会等上一个任务结束在开始下一个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);
        scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;ScheduledTask&quot;);
            }
        }, 1, 1, TimeUnit.SECONDS);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：延迟1s启动，在前一个任务执行完成之后，延迟1s在执行&lt;/p&gt;

&lt;h2 id=&quot;写任务类&quot;&gt;1、写任务类&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package com.zb.timedtask;
import com.zb.controller.StudentController;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

@Service
public class SpringTask {
    private static final Logger log = LoggerFactory.getLogger(SpringTask.class);

    @Scheduled(cron = &quot;1/5 * * * * *&quot;)
    public void task1(){
        log.info(&quot;springtask 定时任务！&quot;);
    }
    
    @Scheduled(initialDelay = 1000,fixedRate = 1*1000)
    public void task2(){
        log.info(&quot;springtask 定时任务！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：&lt;br/&gt;task1是每隔5s执行一次，{秒} {分} {时} {日期} {月} {星期}&lt;br/&gt;task2是延迟1s,每隔1S执行一次&lt;/p&gt;
&lt;h2 id=&quot;配置文件修改&quot;&gt;2、配置文件修改&lt;/h2&gt;
&lt;h3 id=&quot;简单版&quot;&gt;（1）简单版&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;task:annotation-driven/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;任务池版&quot;&gt;（2）任务池版&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;task:executor id=&quot;executor&quot; pool-size=&quot;10&quot; /&amp;gt;
&amp;lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;10&quot; /&amp;gt;
&amp;lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解释&quot;&gt;（3）解释&lt;/h3&gt;
&lt;p&gt;假如只有一个定时任务，可以用简单版；如果有多个定时任务，则要用任务池，不然它会顺序执行。&lt;/p&gt;
&lt;p&gt;两个任务的时间间隔为：执行时间+设定的定时间隔&lt;/p&gt;
&lt;p&gt;例子：(这个任务8s执行一次)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Scheduled(cron = &quot;1/4 * * * * *&quot;)
public void task2(){
    log.info(&quot;springtask 定时任务2！&quot;);
    try {
        TimeUnit.SECONDS.sleep(4);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;加依赖&quot;&gt;1、加依赖&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- quartz --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.3.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--调度器核心包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.3.4.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;job实现&quot;&gt;2、Job实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package com.zb.quartz;

import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class HelloWorldJob implements Job {
    @Override
    public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        String strTime = new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(new Date());
        System.out.println( strTime + &quot;:Hello World！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调度器可以用listener在项目启动时执行&quot;&gt;3、调度器(可以用listener在项目启动时执行)&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;import org.quartz.*;
import org.quartz.impl.StdSchedulerFactory;

public class MyScheduler {
    public static void main(String[] args) throws SchedulerException {
        //创建调度器Schedule
        SchedulerFactory schedulerFactory = new StdSchedulerFactory();
        Scheduler scheduler = schedulerFactory.getScheduler();
        //创建JobDetail实例，并与HelloWordlJob类绑定
        JobDetail jobDetail = JobBuilder.newJob(HelloWorldJob.class).withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;)
                .build();
        //创建触发器Trigger实例(立即执行，每隔1S执行一次)
        Trigger trigger = TriggerBuilder.newTrigger()
                .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;)
                .startNow()
                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever())
                .build();
        //开始执行
        scheduler.scheduleJob(jobDetail, trigger);
        scheduler.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：上面用的是简单触发器，也可以用Con触发器，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Trigger cronTrigger = TriggerBuilder.newTrigger()
                .withIdentity(&quot;trigger2&quot;, &quot;triggerGroup2&quot;)
                .startNow()
                .withSchedule(cronSchedule(&quot;0 42 10 * * ?&quot;))
                .build();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;整合spring&quot;&gt;4、整合spring&lt;/h2&gt;
&lt;p&gt;也可以直接把上面的调度器写成配置文件，整合spring&lt;/p&gt;
&lt;h3 id=&quot;job&quot;&gt;（1）job&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.zb.quartz;
import java.text.SimpleDateFormat;
import java.util.Date;

public class QuarFirstJob {
    public void first() {
        String strTime = new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(new Date());
        System.out.println( strTime + &quot;:Hello World！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;（2）配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;QuarFirstJob&quot; class=&quot;com.zb.quartz.QuarFirstJob&quot; /&amp;gt;

&amp;lt;bean id=&quot;jobDetail&quot;
      class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;group&quot; value=&quot;quartzGroup1&quot; /&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;quartzJob1&quot; /&amp;gt;
    &amp;lt;!--false表示等上一个任务执行完后再开启新的任务 --&amp;gt;
    &amp;lt;property name=&quot;concurrent&quot; value=&quot;false&quot; /&amp;gt;
    &amp;lt;property name=&quot;targetObject&quot;&amp;gt;
        &amp;lt;ref bean=&quot;QuarFirstJob&quot; /&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;targetMethod&quot;&amp;gt;
        &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 调度触发器 --&amp;gt;
&amp;lt;bean id=&quot;myTrigger&quot;
      class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;trigger1&quot; /&amp;gt;
    &amp;lt;property name=&quot;group&quot; value=&quot;group1&quot; /&amp;gt;
    &amp;lt;property name=&quot;jobDetail&quot;&amp;gt;
        &amp;lt;ref bean=&quot;jobDetail&quot; /&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;cronExpression&quot;&amp;gt;
        &amp;lt;value&amp;gt;0/5 * * * * ?&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- 调度工厂 --&amp;gt;
&amp;lt;bean id=&quot;scheduler&quot;
      class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;triggers&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;ref bean=&quot;myTrigger&quot; /&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;时间&quot;&gt;5、时间&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class QuarFirstJob {
    public void first() {
        try {
            TimeUnit.SECONDS.sleep(6);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String strTime = new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(new Date());
        System.out.println( strTime + &quot;:Hello World！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的配置里面写是5s间隔，把上面的sleep时间分别改成4和6，发现两次任务间隔是执行时间和间隔时间的最大值，分别是5,6&lt;/p&gt;

&lt;p&gt;Quartz是执行时间和间隔时间的最大值(比如；执行时间是3s,间隔是2s,则每3s执行一次；执行时间是3s,间隔是5s,则每5s执行一次。)&lt;br/&gt;Spring task是执行时间+间隔时间(比如；执行时间是3s,间隔是2s,则每5s执行一次；执行时间是3s,间隔是5s,则每8s执行一次。)&lt;br/&gt;timer有2中方法schedule和scheduleAtFixedRate，前者会等任务结束在开始计算时间间隔，后者是在任务开始就计算时间，有并发的情况&lt;br/&gt;ScheduledExecutorService的scheduleAtFixedRate类似Quartz，scheduleWithFixedDelay类似SpringTask&lt;/p&gt;
</description>
<pubDate>Wed, 11 Jul 2018 06:03:00 +0000</pubDate>
<dc:creator>丰极</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangbin1989/p/9294114.html</dc:identifier>
</item>
<item>
<title>【从零开始搭建自己的.NET Core Api框架】（五）由浅入深详解CORS跨域机制并快速实现 - 在7楼</title>
<link>http://www.cnblogs.com/RayWang/p/9274913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RayWang/p/9274913.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;系列目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一&lt;span&gt;.  创建项目并集成swagger&lt;a class=&quot;feed_link&quot; href=&quot;https://www.cnblogs.com/RayWang/p/9216820.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9216820.html&quot;&gt;1.1 创建&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9218258.html&quot;&gt;1.2 完善&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9221484.html&quot;&gt;二. 搭建项目整体架构&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;三. 集成轻量级ORM框架——SqlSugar&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9226790.html&quot;&gt;3.1 搭建环境&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9227006.html&quot;&gt;3.2 实战篇：利用SqlSugar快速实现CRUD&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9235704.html&quot;&gt;3.3 生成实体类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/RayWang/p/9255093.html&quot;&gt;四. 集成JWT授权验证&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;五. 实现CORS跨域&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 源码下载：&lt;a href=&quot;https://github.com/WangRui321/RayPI_V2.0&quot;&gt;https://github.com/WangRui321/RayPI_V2.0&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（新增的跨域部分的代码还没有更新上去，但一共就只有15行代码，需要的完全可以自己编写。等晚上有时间再去git更新下，地址不变~）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;  1. 根&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;先从一个最最根本的问题开始，我们为什么要“跨域”？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案很简单，用一句话就可以概括：跨域的唯一目的，就是要绕过“&lt;strong&gt;同源策略&lt;/strong&gt;”的限制。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 1.1 同源策略&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;根据百度百科：
同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说整个Web都是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。
同源策略是由Netscape提出的一个著名的安全策略，所谓同源是指协议、域名、端口相同。现在所有支持JavaScript的浏览器都会使用这个策略。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出，同源策略是一种Web安全策略，它限制了一个域内发起的请求只能访问它所处当前域内的资源，而不能访问其他域内的资源。比如，有两个网站，A和B，在同源策略下，网站A的js就不可以访问网站B的资源（比如接口）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与其说我们“运用”同源策略，不如说是我们“遵守”同源策略。就像交通规则一样，它虽然限制了每个人的自由，但同时也保证了每个人的相对安全。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; 1.1.1 怎么判断两个资源是否同源？&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;判断是否同源有三个要素，我们暂且称它们为“&lt;strong&gt;同源三要素&lt;/strong&gt;”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）协议&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如http（超文本传输协议）或https（安全套接字层超文本传输协议）。如果协议不同，则一定不同源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）域名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如www.cnblogs.com。如果域名不同，则一定不同源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）端口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如www.raywang.com:8080和www.raywang:8081，它们一个为8080端口，一个为8081端口，所以它们不同源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果两个资源时同源的，那么它们必须同时满足这个条件都相同。举几个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.raywang.com与http://www.raywang.com不同源，因为它们协议不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.raywang.com与http://www.baidu.com不同源，因为它们域名不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.raywang.com:8080与https://www.raywang.com:8081不同源，因为它们端口不同。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; 1.1.2 我们为什么要跨域？&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;以api设计模式开发的系统，前端页面和后端接口一般都是分离了。在开发初期，后端接口可能被发布到某台服务器上，而前端页面可能被搭建在开发人员本地的iis中，就算是项目上线后，页可能是前端页面和后台服务发布到两台不同的服务器上。当然，这些情况都是不符合同源策略的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拿我们正在搭建的web api为例，我这里写了一个测试用的小网页，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_857e0dcf-33d0-47fc-ad5b-b68142e578f4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_857e0dcf-33d0-47fc-ad5b-b68142e578f4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_857e0dcf-33d0-47fc-ad5b-b68142e578f4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;js/jquery-2.1.4.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;&lt;span&gt;
        function GetToken() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenModel =&lt;span&gt; {
                id: $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#tid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
                name: $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#tname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(),
                sub: $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#tsub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val()
            };
            $.ajax({
                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:3607/api/System/Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                dataType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: tokenModel,
                &lt;/span&gt;&lt;span&gt;async&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                success: function (d) {
                    alert(JSON.stringify(d));
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#jwt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(d);
                },
                error: function (d) {
                    alert(JSON.stringify(d));
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#jwt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(JSON.stringify(d));
                }
            });
        }
        function GetStudent() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s = { name: $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#sname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val() };
            $.ajax({
                url: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:3607/api/Client/Student/GetByName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                dataType: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: s,
                &lt;/span&gt;&lt;span&gt;async&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                headers: { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#jwt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val().trim() },
                success: function (d) {
                    alert(JSON.stringify(d));
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(JSON.stringify(d));
                },
                error: function (d) {
                    alert(JSON.stringify(d));
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(JSON.stringify(d));
                }
            });
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width:350px; margin:100px auto 0;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        I  D:&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;br /&amp;gt;&lt;span&gt;
        Name:&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;br /&amp;gt;&lt;span&gt;
        Sub :&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tsub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetToken()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;br /&amp;gt;
        &amp;lt;p&amp;gt;token:&amp;lt;/p&amp;gt;
        &amp;lt;textarea id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jwt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width:300px; height:200px; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/textarea&amp;gt;
        &amp;lt;br /&amp;gt;&lt;span&gt;
        学生姓名：&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt; &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点击查询&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onclick=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetStudent()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
        &amp;lt;br /&amp;gt;
        &amp;lt;textarea id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width:300px;height:200px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/textarea&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我把它放到RayPI下的wwwroot下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180709162128702-1042142775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;运行之后，浏览器访问是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180709162323633-631280311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中“获取Token”按钮会调用接口http://localhost:3607/api/System/Token，“点击查询”按钮会调用接口http://localhost:3607/api/Client/Student/GetByName，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180709162646669-1269894441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此时，页面http://localhost:3607/index.html和接口http://localhost:3607/api/System/Token，http://localhost:3607/api/Client/Student/GetByName是同源的（因为同在一个项目中），所以它们之间可以互相访问传递资源（json），没有任何问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们将这个网页单独拿出来发布到我本地的iis中，域名取为http://localhost:8083/index.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180709164657426-1440726619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180709163354292-133207088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;点击按钮，结果如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180709164205740-947068437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然，此时这个前端页面与后端接口是非同源的，所以它不能访问接口资源。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 1.2 跨域的解决方案&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;解决跨域的方法很多，比如运用代理跨域，window.name+iframe跨域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是最常用的跨域方式应该是两种：&lt;strong&gt;JSONP&lt;/strong&gt;和&lt;strong&gt;CORS&lt;/strong&gt;跨域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RayPI选择的跨域方式是后者。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 1.3 CORS跨域&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;CORS，即Cross-Origin Resource Sharing，跨源资源共享。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; 3.3.1 跨域请求的类型&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;CORS将跨域请求分成以下两种：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;简单请求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;复杂请求&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;一个简单的请求大致满足如下条件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;HTTP方法是下列之一&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HTTP头包含&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Last-Event-ID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Content-Type&lt;/code&gt;，但仅能是下列之一
&lt;ul&gt;&lt;li&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text/plain&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;任何一个不满足上述要求的请求，即被认为是复杂请求。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt; 3.3.2 一次CORS跨域的完整流程&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;一个完整的CORS跨域请求的流程是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180710171304026-276000034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;先别慌，图片看着多，其实是三块内容，我们把它分为左、中、右三部分，从最左边开始看起。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1）左：基础&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个http请求被发起之后，浏览器会根据是否是跨域请求（判断标准就是上面说的&lt;strong&gt;同源策略三要素&lt;/strong&gt;），决定是否在http请求的头部添加“Origin”字段，并将发起请求的域名附加在该字段后面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务器接收到客服端的http请求后，会先尝试读取“Origin”字段，如果不存在，说明该请求不是跨域请求，直接将该请求放行，把结果返回给客户端；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果头部存在“Origin”字段，说明该请求来自和当前服务器不同源的一个客户端，是一个跨域请求。这时先判断该“Origin”字段后的域名和请求方式（request method）是否合法，如果不合法，就直接返回403错误码。如果是合法的，再根据上面说的原则判断该请求是&lt;strong&gt;简单请求&lt;/strong&gt;还是&lt;strong&gt;复杂请求&lt;/strong&gt;。如果是&lt;strong&gt;简单请求&lt;/strong&gt;，就进入图片中间简单请求流程，如果是&lt;strong&gt;复杂请求&lt;/strong&gt;，就进入图片最右边复杂请求流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2）中：简单请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务器端根据自己设置的CORS跨域规则，配置相应的Access-Control-Allow-Origin和Access-Control-Allow-Methods等响应头信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当收到客户端的请求后，服务端将验证客户端请求头中的信息是否符合设置的CORS规则，如果符合，则将请求的资源连同跨域响应头（Access-Control-Allow-Origin等）返回给客户端。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;客服端（浏览器）收到Response Headers后，会验证这些响应头信息，判断是否通过了跨域请求，如果通过，则返回状态码200，并成功获取到跨域资源：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711102835870-1928462842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果服务端收到客户端的请求后，发现客户端请求头中的信息不符合设置的CORS规则，这时则不会讲配置的跨域响应头（Access-Control-Allow-Origin等）返回给客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端收到Response Headers后，验证跨域响应头信息，没有发现相应的跨域响应头，说明跨域请求不通过，将不会返回资源。（这里理论上应该返回错误码403的，但是Chrome显示的是200状态码，我也不知道是为啥。。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711105100112-1607414516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以通过浏览器的Console查看具体的验证失败原因：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711105239689-1792706121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3）右：复杂请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个复杂请求不仅有包含通信内容的请求，同时也包含&lt;strong&gt;预请求&lt;/strong&gt;（preflight request）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器发现是&lt;strong&gt;复杂请求&lt;/strong&gt;的时候，并不会直接发起原请求，而是先发送Preflight requests（预先验证请求），Preflight requests是一个OPTION请求，用于询问服务器是否允许当前域名下的页面发起跨域请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下例，点击“点击查询”后，需要向接口传递token验证（接口的授权验证是前一章讲的内容），所该请求是一个复杂跨域请求。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711105856502-992316512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;OPTIONS请求头部中一般会包含以下头部：Origin、Access-Control-Request-Method、Access-Control-Request-Headers。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;服务器收到OPTIONS请求后，设置Access-Control-Allow-Origin、Access-Control-Allow-Method、Access-Control-Allow-Headers头部与浏览器沟通来判断是否允许这个请求。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果Preflight requests验证通过，浏览器才会发送真正的跨域请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711110000552-1553765648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果Preflight requests验证失败，浏览器则不会发送真正的跨域请求。（理论上应该返回403错误码，但是这里还是返了200。。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711110157888-456028125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;可以通过浏览器的Console查看具体的验证失败原因：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711110322354-2060035974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;  2. 道&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;原理了然，下面就开始实现了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法有两个，程序实现和服务器实现。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 2.1 程序实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;打开主项目下的Startup.cs文件，编辑ConfigureServices函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711112941351-782249144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;#region&lt;/span&gt; CORS&lt;span&gt;
            services.AddCors(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                c.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowAnyOrigin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt;&lt;span&gt;
                 {
                     policy.AllowAnyOrigin()&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许任何源&lt;/span&gt;
                     .AllowAnyMethod()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许任何方式&lt;/span&gt;
                     .AllowAnyHeader()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许任何头&lt;/span&gt;
                     .AllowCredentials();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许cookie&lt;/span&gt;
&lt;span&gt;                 });
                c.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowSpecificOrigin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt;&lt;span&gt;
                 {
                     policy.WithOrigins(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8083&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                     .WithMethods(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DELETE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                     .WithHeaders(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                 });
            });
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里添加了两个策略，AllowAnyOrigin策略几乎直接完全无视了“同源策略”的限制，所以个人建议尽量不要这么写。AllowSpecificOrigin策略我暂时只放了一个测试用的源，如有需要可根据情况更改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 下面只需要在控制器头上（或某个函数头上）添加标识：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[EnableCors(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowSpecificOrigin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711112957248-897465541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.2 服务器实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里我用的IIS作为例子，方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在iis新建网站，添加RayPI，点击IIS下的“HTTP响应标头”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711123847822-1112270456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;右侧店家添加，依次添加如下表头信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711123926173-1805799598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Access-Control-Allow-Origin : *&lt;span&gt; 

Access&lt;/span&gt;-Control-Allow-&lt;span&gt;Methods : GET,POST,PUT,DELETE,HEAD,OPTIONS

Access&lt;/span&gt;-Control-Allow-Headers : authorization
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;  3. 果&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;F5运行程序，从http://localhost:8083/进行测试，结果如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327955/201807/1327955-20180711130631733-35670072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;跨域访问成功~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u014344668/article/details/54948546&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/badboyer/article/details/51261083&lt;/p&gt;
</description>
<pubDate>Wed, 11 Jul 2018 05:33:00 +0000</pubDate>
<dc:creator>在7楼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RayWang/p/9274913.html</dc:identifier>
</item>
<item>
<title>python描述符学习 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9293966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9293966.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一对象属性的访问控制&quot;&gt;一、对象属性的访问控制&lt;/h2&gt;
&lt;p&gt;看一下这个例子，我们创建一个学生类，提供名字和年龄的属性，然后实例化一个对象，并显示他的信息。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age


stu = Student('zlw', 26)
print(stu.name)  # 名字是'zlw'
print(stu.age)  # 年龄是26

# 对象的名字和年龄被正常打印，good&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 但是，Student类没办法控制用户在实例化时的行为

stu = Student(26, 'zlw')
print(stu.name)  # 名字是26
print(stu.age)  # 年龄是'zlw'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以这样做：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
class Student:

    def __init__(self, name, age):
        # 检测每一次实例化时的参数类型
        if not isinstance(name, str):
            raise TypeError('name必须是str类型')
        if not isinstance(age, int):
            raise TypeError('age必须是int类型')

        self.name = name
        self.age = age&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以在init函数中控制实例化时的输入类型，不过这有2个问题：&lt;br/&gt;1、只能控制实例化时的类型，对于已经实例化完成的对象，可以直接通过stu.name = 23的形式来重新赋值&lt;br/&gt;2、实例化传递的参数越多，那么类型检测的代码也越多，而且类型检测代码和初始化代码写在一起，两者干的事情不一样，逻辑不是一个层面的，都写在init函数里并不合适&lt;br/&gt;我们可以这样写：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 省略了age的处理，方式是一样的

class Student:

    def __init__(self, name):
        if not isinstance(name, str):
            raise TypeError('name属性值类型必须是str类型')

        self.__name = name


    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('name属性值类型必须是str类型')
        self.__name = value

# 这样写就可保证在实例化和已经完成实例化的对象赋值时的类型检查问题了。
# 不过还是有一个问题，就是属性越多，这个类型检查的代码就会不断增加，并且堆积在Student类中
# 我们应该将类型检查的代码单独隔离开，但同时又可以和Student类进行交互&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用python的描述符来处理。&lt;/p&gt;
&lt;h2 id=&quot;二描述符基本理解&quot;&gt;二、描述符基本理解&lt;/h2&gt;
&lt;p&gt;python的描述符，有几个理解：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、描述符是一个类&lt;br/&gt;2、描述符的目的是对属性的访问控制&lt;br/&gt;3、描述符将访问控制和业务类分离开，业务类处理业务逻辑，描述符处理属性访问控制&lt;br/&gt;4、描述符是一个特殊类型的类，所谓特殊，就是自定义了&lt;code&gt;__get__&lt;/code&gt;、&lt;code&gt;__set__&lt;/code&gt;、&lt;code&gt;__delete__&lt;/code&gt;方法的类，这种类就叫描述符&lt;br/&gt;5、单独一个描述符没有啥意义，描述符要作用于某一个具体的业务类，为这个业务类提供属性访问控制的功能&lt;br/&gt;6、属性访问可不仅仅是指数据属性的访问，对于函数属性的访问也可以控制。&lt;br/&gt;7、使用类的&lt;code&gt;__setattr__&lt;/code&gt;、&lt;code&gt;__getattr__&lt;/code&gt;、&lt;code&gt;__delattr__&lt;/code&gt;只能全局控制所有属性，而描述符可以有针对的控制部分属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三基本使用&quot;&gt;三、基本使用&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
class DescName:
    dic = {}

    def __init__(self, value_type):
        self.value_type = value_type

    def __get__(self, instance, owner):
        print('get running...')
        return self.dic.get(instance, None)

    def __set__(self, instance, value):
        print('set running...')
        if not isinstance(value, self.value_type):
            raise TypeError('名字必须是str类型')

        self.dic[instance] = value

class Student:
    name = DescName(str)

    def __init__(self, name, age):
        self.name = name
        self.age = age

stu1 = Student('小明', 26)
print(stu1.name, stu1.age)  # 小明，26
stu2 = Student('小红', 25)
print(stu2.name, stu2.age)  # 小红，25&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，我定义了一个&lt;code&gt;Student&lt;/code&gt;类用于表示一个学生。学生有两个属性&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;，对于&lt;code&gt;age&lt;/code&gt;我并没有设置任何的控制，对于&lt;code&gt;name&lt;/code&gt;我要求属性值必须是&lt;code&gt;str&lt;/code&gt;类型。我们可以定义一个&lt;code&gt;DescName&lt;/code&gt;描述符类来单独针对&lt;code&gt;name&lt;/code&gt;这个属性提供控制功能。&lt;code&gt;DescName&lt;/code&gt;描述符会对&lt;code&gt;name&lt;/code&gt;的值进行类型判定，如果是非&lt;code&gt;str&lt;/code&gt;类型就会报错。&lt;br/&gt;请注意&lt;code&gt;DesnName&lt;/code&gt;的&lt;code&gt;__set__&lt;/code&gt;方法中的：&lt;code&gt;self.dic[instance] = value&lt;/code&gt;这句代码。&lt;br/&gt;考虑到&lt;code&gt;Student&lt;/code&gt;类会实例化出很多不同的学生对象，这些学生对象是共享同一个描述符对象&lt;code&gt;Student.name&lt;/code&gt;的，因为这是一个类属性，我们要在&lt;code&gt;DescName&lt;/code&gt;描述符中保存不同对象的&lt;code&gt;name&lt;/code&gt;值，就需要区分不同的对象，我这里使用字典，将每一个实例作为字典的&lt;code&gt;key&lt;/code&gt;来保存对应实例的&lt;code&gt;name&lt;/code&gt;值。&lt;br/&gt;不过这里也会有一个问题，就是字典的&lt;code&gt;key&lt;/code&gt;必须是可&lt;code&gt;hash&lt;/code&gt;对象，如果实例是可变对象比如&lt;code&gt;list&lt;/code&gt;，则无法使用这种方法保存属性值，可以考虑转换成一个不可变对象后处理，比如使用字符串表示不同的实例对象。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基本使用的代码中，每个实例对象的属性值实际是保存在共享描述符对象中的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四使用描述符完成propertyclassmethodstaticmethod自定义实现&quot;&gt;四、使用描述符完成property、classmethod、staticmethod自定义实现&lt;/h2&gt;
&lt;h3 id=&quot;property的自定义实现&quot;&gt;1、property的自定义实现&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# property是一个装饰器，所以底层原理就是把描述符当做一个装饰器并作为类属性存在

class DescName:  # 描述符，后续当做装饰器使用，是一个类装饰器，返回的对象是描述符对象
    def __init__(self, func):  # 首次装饰必须返回一个描述符对象，func是装饰的函数name
        self.get_func = func
        self.set_func = None
        self.delete_func = None  # 以上3个属性用于保存用户定义的属性访问逻辑代码

    def __get__(self, instance, owner):
        return self.get_func(instance)  # 访问get的时候返回用户定义的函数输出

    def setter(self, func):
        self.set_func = func
        return self  # 提供一个setter用于处理set逻辑，setter是一个函数装饰器

    def __set__(self, instance, value):
        return self.set_func(instance, value)  # 访问set的时候调用用户定义函数

    def deleter(self, func):  # 提供deleter函数装饰器处理delete逻辑
        self.delete_func = func
        return self

    def __delete__(self, instance):
        return self.delete_func(instance)  # 访问del的时候调用用户定义函数


class Student:  # 业务类
    def __init__(self, name, age):
        self.__name = name  # 在业务类中隐藏属性
        self.age = age

    @DescName  # 和propery是一样的,返回对象就是一个描述符对象，被name引用,且是类属性
    def name(self):
        return self.__name

    @name.setter  # set设置
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('必须是str')
        self.__name = value

    @name.deleter  # 删除设置
    def name(self):
        print('你不能删除名字属性')

stu1 = Student('zlw', 26)  # 实例化的时候会自动调用描述符的set
print(stu1.name, stu1.age)  # 打印的时候会调用描述符的get

stu1.name = 'wj'
print(stu1.name, stu1.age)

del stu1.name  # 删除的时候调用描述符的delete&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;classmethod的自定义实现&quot;&gt;2、classmethod的自定义实现&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
class DescClassMethod:  # 描述符，用于作为装饰器，提供类方法功能
    def __init__(self, func):
        self.get_func = func
        self.cls = None  # 保存当前类对象

    def __get__(self, instance, owner):  # 被装饰的时候，保存当前类对象，返回描述符对象
        self.cls = owner
        return self

    def __call__(self, *args, **kwargs):  # 类方法一般直接运行，也就是描述符对象被运行
        return self.get_func(self.cls, *args, **kwargs)  # 传入当前类对象，用户就觉得是自动传入


class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def learn(self):
        print(f'{self.name} is learning...')

    @DescClassMethod  # 类方法描述符，让被装饰的函数变成类绑定方法，自动传入类对象
    def show_class(cls, school_name):
        print(f'this is class --&amp;gt; {cls.__name__}')
        print('输入的参数是:', school_name)

stu = Student('zlw', 26)
stu.learn()  # 实例方法
Student.show_class('北京大学')  # 类方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于实例方法的思考&quot;&gt;3、关于实例方法的思考&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这里是普通的类和一个实例方法定义，不同对象在调用的时候会将自己传入self

class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def learn(self):
        print(f'{self.name} is learning...')

stu1 = Student('小明', 26)
stu2 = Student('小红', 25)

stu1.learn()  # '小明' is learning...
stu2.learn()  # '小红' is learning...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过描述符，我们可以实现一个类似&lt;code&gt;classmethod&lt;/code&gt;类方法的功能，这功能可以实现当我们调用类方法的时候，&lt;code&gt;python&lt;/code&gt;会自动将类对象传入&lt;code&gt;cls&lt;/code&gt;中。那这就引发另一个问题，对于实例方法，我们在通过实例对象调用的时候，也会将实例对象自己传入&lt;code&gt;self&lt;/code&gt;中，那这个实现和类方法的实现，是不是一样的思路？&lt;br/&gt;仔细查看描述符的&lt;code&gt;__get__&lt;/code&gt;函数可以发现，此函数的参数有&lt;code&gt;instance&lt;/code&gt;和&lt;code&gt;owner&lt;/code&gt;，这个&lt;code&gt;owner&lt;/code&gt;被我们用作&lt;code&gt;cls&lt;/code&gt;，那么，&lt;code&gt;instance&lt;/code&gt;不就代表实例对象吗？如果我们把&lt;code&gt;istance&lt;/code&gt;传入&lt;code&gt;call&lt;/code&gt;，不就可以实现类似实例方法的功能了吗？试试看：&lt;/p&gt;
&lt;h3 id=&quot;实例方法的自定义实现&quot;&gt;4、实例方法的自定义实现&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class SelfMethod:  # 描述符，用于处理实例方法功能
    def __init__(self, func):
        self.get_func = func
        self.instance = None  # 保存实例对象

    def __get__(self, instance, owner):
        self.instance = instance  # 保存实例对象
        return self

    def __call__(self, *args, **kwargs):
        return self.get_func(self.instance, *args, **kwargs)  # 将实例对象传入


class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @SelfMethod  # 使用描述符作为装饰器，让learn函数变成实例绑定方法
    def learn(self):
        print(f'{self.name} is learning...')

stu1 = Student('小明', 26)
stu2 = Student('小红', 25)

stu1.learn()  # '小明' is learning...  # 调用的时候，会传入stu1实例 
stu2.learn()  # '小红' is learning...  # 调用的时候，会传入stu2实例

print(stu1.__dict__)
print(Student.__dict__)  # 类中显示learn是一个描述符对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上通过描述符可以自定义类似实例方法的效果，自动传入实例给&lt;code&gt;self&lt;/code&gt;。不过这种实现方式和真正的实例方法实现（暂时还不知道如何实现的）还是有些不同：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;a、自定义实现需要@SelfMethod装饰器，而真正实现是不需要装饰器的，不知道是不是底层做了默认省略的操作&lt;br/&gt;b、&lt;code&gt;Student.__dict__&lt;/code&gt;的输出中，自定义的实现表示&lt;code&gt;learn&lt;/code&gt;是一个描述符对象，而真正实现的表示是一个&lt;code&gt;function&lt;/code&gt;对象&lt;br/&gt;c、打印&lt;code&gt;stu1.learn&lt;/code&gt;的时候，自定义实现显示是描述符对象，真正实现表示的是绑定方法对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯。。暂时还没深入研究绑定方法的具体实现，不过可以通过描述符来大概判断出，绑定方法也应该是一个类似封装了实例对象和函数的对象，在被调用的时候也是以&lt;code&gt;func(self, *args, **kw)&lt;/code&gt;的方式来调用的。&lt;/p&gt;
&lt;h3 id=&quot;静态方法的自定义实现&quot;&gt;5、静态方法的自定义实现&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class StaticMethod:  # 描述符，用于处理静态方法的类装饰器
    def __init__(self, func):
        self.get_func = func

    def __get__(self, instance, owner):
        return self

    def __call__(self, *args, **kwargs):
        return self.get_func(*args, **kwargs)  # 静态方法就是不提供instance和owner参数传入


class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @StaticMethod  # 描述函数为静态方法
    def show():
        print('这里是静态方法show')

stu1 = Student('小明', 26)
stu2 = Student('小红', 25)

stu1.show()  # 这里是静态方法show
stu2.show()  # 这里是静态方法show&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1.描述符可以用于处理类级别的属性的访问控制&lt;br/&gt;2.如果描述符处理的是数据属性，那么核心关注点如下&lt;br/&gt;&amp;gt;1、描述符的&lt;code&gt;__get__&lt;/code&gt;,&lt;code&gt;__set__&lt;/code&gt;,&lt;code&gt;__delete__&lt;/code&gt;函数处理数据读取、删除&lt;br/&gt;&amp;gt;2、处理数据属性的描述符对象，可以保存不同实例对象的属性值，使用字典，&lt;code&gt;key&lt;/code&gt;是实例对象自身，不过要注意是否可&lt;code&gt;hash&lt;/code&gt;&lt;br/&gt;&amp;gt;3、将描述符作为类装饰器对函数进行装饰，可以自定义类似&lt;code&gt;property&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;实现效果，不过注意描述符类中要提供&lt;code&gt;setter&lt;/code&gt;和&lt;code&gt;deleter&lt;/code&gt;用于处理&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;del&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;描述符还可以用于处理函数属性，核心关注点有如下&lt;br/&gt;&amp;gt;1、描述符类作为类装饰器对指定函数进行装饰并返回描述符对象&lt;br/&gt;&amp;gt;2、返回的描述符对象除了处理描述符三大函数之外，还要提供&lt;code&gt;__call__&lt;/code&gt;函数以便调用&lt;br/&gt;&amp;gt;3、使用&lt;code&gt;__call__&lt;/code&gt;函数的时候，传入的是&lt;code&gt;instance&lt;/code&gt;，就类似实例方法，传入的是&lt;code&gt;owner&lt;/code&gt;，就类似类方法&lt;code&gt;classmethod&lt;/code&gt;，什么都不传入，就类似静态方法&lt;code&gt;staticmethod&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对象属性的解析顺序，比如打印&lt;code&gt;stu.name&lt;/code&gt;&lt;br/&gt;0、无条件优先被&lt;code&gt;__getattribute__&lt;/code&gt;处理&lt;br/&gt;1、获取对象所属类及&lt;code&gt;MRO&lt;/code&gt;列表，自下而上获取&lt;code&gt;name&lt;/code&gt;的第一个定义&lt;br/&gt;2、判断此定义的类型&lt;br/&gt;3、如果类型是数据描述符，直接调用数据描述符的&lt;code&gt;__get__&lt;/code&gt;，否则下一步&lt;br/&gt;4、如果不是数据描述符，判断是否为：实例属性，即&lt;code&gt;stu.__dict__&lt;/code&gt;中是否存在，是的话返回，否则下一步&lt;br/&gt;5、判断类型是否为非数据描述符（也是描述符），如果是，则返回非数据描述符的&lt;code&gt;__get__&lt;/code&gt;返回值，否则下一步&lt;br/&gt;6、判断类型是否是普通属性，比如单纯的一个类属性，如果是，则返回此属性值，否则下一步&lt;br/&gt;7、执行&lt;code&gt;__getattr__&lt;/code&gt;，期望解析顺序最后给出返回值，没定义就报错&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 11 Jul 2018 05:21:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9293966.html</dc:identifier>
</item>
<item>
<title>究竟什么是技术——对上一篇的回复 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/9293862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/9293862.html</guid>
<description>&lt;p&gt;不久之前我写了一篇《&lt;a href=&quot;https://www.cnblogs.com/flashsun/p/9266343.html#!comments&quot; target=&quot;_blank&quot;&gt;究竟什么是技术——非科班程序员两年的内心挣扎&lt;/a&gt;》，我没有想到，我闲着无聊写的一篇随笔，居然立刻有高达&lt;span&gt;&lt;strong&gt;&lt;span&gt;53人反对&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，将近&lt;span&gt;&lt;strong&gt;&lt;span&gt;100条评论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。于是乎，评论区大家的回复，使这篇本来很随意的文章热闹不少。&lt;/p&gt;
&lt;p&gt;有像这样认真回复的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在博主眼里貌似只有底层才叫技术，事实并非如此。原始时代人是裸着的，后来下体围上树叶遮羞，再后来穿兽皮御寒，再后来的后来针织啊、丝绸啊，花花哨哨，请问，穿了丝绸的人，就不是人了吗？ 同理，基于计算机原理的之上的技术，就不是技术了吗？我说的人类从没有衣物到衣物的升级，何不似计算机一门的发展？刚开始是机器语言，然后是汇编语言，最后是高级语言，怎么能说机器语言写的代码才叫技术，高级语言写的就不是呢？博主对技术的认识太狭隘了，另一方面，社会就是这样，你身边有很多你所不喜欢的人，他们可能上班不怎么写代码，划水摸鱼，可是这和你有什么关系呢，做自己感兴趣的事，写有意义的代码么关系呢，做自己感兴趣的事，写有意义的代码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然也有更多像这样撅我的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这篇文章体现了 非科班 与科班 差距离……，我在招聘中，非科班学生在优秀也不考虑……。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无病呻吟，废柴&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;看到这么多反对，我就放心了&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也有好多互相dis互相骂的。。。&lt;/p&gt;
&lt;p&gt;在这里我想给大家分享一下认真回答的几条评论，我觉得对我的困惑是有启发的，也顺便借此机会&lt;span&gt;&lt;strong&gt;&lt;span&gt;感谢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;帮我答疑的各位前辈。&lt;/p&gt;
&lt;p&gt;另外，欢迎大家继续讨论&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;在博主眼里貌似只有底层才叫技术，事实并非如此。原始时代人是裸着的，后来下体围上树叶遮羞，再后来穿兽皮御寒，再后来的后来针织啊、丝绸啊，花花哨哨，请问，穿了丝绸的人，就不是人了吗？ 同理，基于计算机原理的之上的技术，就不是技术了吗？我说的人类从没有衣物到衣物的升级，何不似计算机一门的发展？刚开始是机器语言，然后是汇编语言，最后是高级语言，怎么能说机器语言写的代码才叫技术，高级语言写的就不是呢？ 博主对技术的认识太狭隘了，另一方面，社会就是这样，你身边有很多你所不喜欢的人，他们可能上班不怎么写代码，划水摸鱼，可是这和你有什么关系呢，做自己感兴趣的事，写有意义的代码&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;楼主也太极端了吧，现在都讲究互联网+，物联网，没有软件和网络协议，没有0101的信号传输，要这些光杆电脑有什么用，系统都没有，不就是一个samsung显示器吧（哈哈），我们学数学，学的基本不都是思想和理论，如果不应用到物理上，那只能算是一对草稿纸吧，但没人可以否定数学的作用。同样软件也是学的思想，软件对硬件就像数学对于其它科一样。再比如爱迪生发明电灯的例子，够不够low，总结一句，对人类有进步的就是技术。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;首先，翻翻字典，确认一下“技术”这个词的权威解释。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你所说的技术一词，我理解更多是指本质的意思。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;感觉你已经进入一个牛角尖了，什么都看不上，这种思想太危险。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们正是站在巨人的肩膀上，才能不断发展，而不用每个人都从头来一遍。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;将底层基础应用好，一点也不比基础理论研究差，而且还包含了方法论、工程学，更是和高大上的科学技术哲学以及世界观结合起来了，你还觉得low吗？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt; 技术本来就是一层一层叠起来的如果你愿意往底层追问，可以一直追问下去，穷尽一生也搞不完，技术本质是什么不是那么重要，那些已经被人发明了，你只是知道人家已经知道东西而已，只是很勤奋罢了。我觉的技术做什么才是真正重要的，用技术去发明创造新的技术才是真正伟大的人，古往今来无不如此。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt; 我觉得技术就是提供一种方案解决某个问题。比如发明一种药可以治愈癌症，这肯定是技术了，当然普通技术人员不会面对这么复杂的工程。但平时工作中还是有很多要解决的问题：比如如何在1小时内实现一个简单业务的增删改查，每次版本升级都会引入一些之前解决过的BUG，在线系统用户量也不是太大但数据库服务器的CPU就100%了，流媒体服务器又莫名其妙的挂了，我一个不相干的小网站居然有人对我DDOS图啥啊，总之我经常碰到这些烦恼，如果你有好办法帮我解决，我一定认为你很有技术。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;整个计算机世界都是从丑陋、复杂的底层硬件开始，最后慢慢抽象出各种便于操作理解的文件、api等概念。底层为上层服务，每一层次都有自己的难点去解决。硬件玩的6的不见得软件开发、管理也精通，算法玩的好不见得能够开发出一流品质的应用产品，还是那句话每一个领域都有自己的复杂性和痛点需要解决。归根到底还是分工导致，术业有专攻&lt;br/&gt;就我个人理解，技术终究只是工具和手段。怎么点技能点和你的目标有关——创业、做成某某产品、或者干脆想在某公司工作等，然后根据目标规划不同的技术方向。想什么都学，什么都懂的最终会成为一事无成的沙比&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;楼主的想法，有这些困惑其实是好的。&lt;br/&gt;对于什么是技术，我的理解是，需要知识累积，非科班的人要去做这项工作，会面临很大的学习成本。&lt;br/&gt;现在的软件开发，其实严格意义，在我眼里并不算真正的技术。无论分布式、还是各种组件的使用，亦或是架构设计，其实壁垒都不是很高。&lt;br/&gt;人工智能，如需掌握，需要数学底蕴，壁垒较高。&lt;br/&gt;底层的开发，嵌入式等等，需要的虽然不是数学，但是跟系统打交道，跟SOC打交道，需要庞大的知识体系。如果需要精通，还有模电数电，这些也需要数学。&lt;br/&gt;而我们很多搞软件的人，为了增加壁垒也好，为了逼格也罢，总是把很多技术实现搞了一大堆名词，其实你了解了会发现，其实不过这样。这点就没有英语好，英文的技术词语，很多总是能一看就明白意义。&lt;br/&gt;总之，我的观点就是，技术非技术 看壁垒。一旦壁垒没有，人人经过短期培训都能做，在我眼里，便不是真正的技术。技术一定要长期的知识积累，才能做到的东西。&lt;br/&gt;只是本人的一点粗鄙看法。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;不管怎么样，赞一个，有想法，挺好的。技术，我的理解就是，物以稀为贵的方法，你掌握了，别人不会，不知道，你就是有技术的人。技术，归根到底，就是解决当前所遇到的问题，或者满足某种需求。。当历史的发展到一定程度，现在所谓的技术，就不能称为技术。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;我是一个技术新手，不过我是转行过来的经历比较丰富，看完之后有一点感触，说几点我的想法。思想是分层次的，有三个层次用来概况很多东西挺合适的，看山是山看水是水、看山不是山看水不是水、看山还是山看水还是水，当然有可能还有更进一步的层次，螺旋上升的样子。当你在怀疑和思考的时候说明你已经到了量变引起质变的时候了，可是又不是所有人都能在思索之后突破原有思维的屏障，想上升一个思维高度很难，有很多人终其一生都在一个阶段生活而且很快乐，大家并没有高低贵贱之分，可是我就和作者一样，更喜欢思考为什么，始终在寻找着什么。《未来简史》中说人的左右脑是有两个自我，两个思维，右脑负责真是的感受，左脑负责权衡感受和思维来编故事指挥我们，人的很多事情都是先有固定思维才去做，比如穿衣服，我们的左脑会告诉你你是什么样的人，你才会去买什么样的衣服，穿着这衣服才不会别扭，不然一直会很难受，你现在就到了一个左脑没办法编一个完整的故事骗自己的地步，而且看你的思维想的已经不是技术的问题了，而是社会、人类、意义的问题，我建议你去看看哲学书，从中找到你思考的东西。说了这么多，总之一句话，思维逻辑先于行动，行动也是数量的积累，大量的行动之后我们大脑会根据结果等各种因素修正之前的思维偏差。可能有错别字，就不回头查看了，还在上班。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;想在最底层做出突破，类似牛顿，爱因斯坦等物理学或者数学，又或者孟德斯鸠，达尔文等的遗传学进化论。这种在黑暗中振聋发聩的声音，不仅需要个人的努力，还要有历史推动和大环境的恰到好处。现代科学的主要枝干早已经被大师们占据，即使是基础科学走在前沿的科学家，可能也没有机会有这样大的成就了，所有人都站在了巨人的肩膀上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;而且如果你真的了解基础科学现在的研究，估计你就会直接放弃这个想法了，最简单的你买本时间简史，如果书的后三分之一都看不懂，就别提做基础科学，做“凌驾万物之上”的东西。&lt;/p&gt;&lt;p&gt;我觉得你很大可能已经错过了做基础研究的机会，并且也不具备做基础科学的能力，那你还迷惑什么呢，你为了一个自己不可能做出来的东西或者不可能达到的目标而遗憾吗。&lt;br/&gt;世界上只有一种英雄，你知道是什么吗&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;能为生活带来便利，为社会带来发展，都是技术，若真要细究，计算机诞生又是为了什么？电话，汽车，一切的诞生是为了什么？为什么一直要研究数学？说到底不都是为了人类自己的发展？不要纠结，很多时候，自己所做的并不能改变世界，但你能改变自己就行，古人早已说过，穷则独善其身，达则兼济天下。你现在所用的一切都是前人的基础发展而来，你能说袁隆平的成果不是技术么？他解决了问题。同样的，你肯定解决不了那么大的问题，但你也要去解决问题不是么，至于问题是什么，这就看你的实际情况了，东拉西扯一大堆，说到底，可以是规则，可以是方法，可以是知识，可以是创作，可以是很多东西，但都要去实际解决某些问题，当然有些知识并不能实际解决一些问题，但它是构建之后的基础，这是我个人的看&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Wed, 11 Jul 2018 04:56:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashsun/p/9293862.html</dc:identifier>
</item>
<item>
<title>Android中Fragment的使用 - votzone</title>
<link>http://www.cnblogs.com/fog2012/p/fragment.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fog2012/p/fragment.html</guid>
<description>&lt;blockquote class=&quot;black-blockquote&quot; data-anchor-id=&quot;9dm5&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;Fragment可能是我心中一直以来的执念，由于Android开发并没有像一般流程一样系统的学习，而是直接在公司项目中改bug开始的。当时正是Fragment被提出来的时候，那时把全部精力放到了梳理代码业务逻辑上，错过了Fragment首班车，而这一等就到现在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-anchor-id=&quot;fggq&quot;&gt;Android发布的前两个版本只适配小尺寸的手机。开发适配小尺寸手机app只需要考虑怎么将控件布局到Activity中，怎样打开一个新的Activity等就可以了。然而Android3.0开始支持平板，屏幕尺寸增大到10寸。这在很大程度上提升了Android开发的难度，因为支持的屏幕尺寸变大导致了更多不同尺寸手机的产生，一个简单的Activity很难同时适配这么多不同的尺寸。以邮件应用为例，在小尺寸的手机上我们可以使用一个Activity来显示邮件标题，另一个Activity显示邮件详情。但是在大屏幕的平板上有更合理的方式：同一个Activity的左侧显示标题，右侧显示详情。&lt;/p&gt;
&lt;p data-anchor-id=&quot;ktk2&quot;&gt;Android 3.0引入了一个核心的类Fragment，这个类能够优雅的实现上述邮件例子中的屏幕适配问题。同时Android也发布了一个官方的支持库 support-v4，使用该库能够使用Fragment的接口适配之前的Android版本。有了这个库，我们能够容易的为手机，平板甚至电视来开发应用程序。&lt;/p&gt;
&lt;h2 id=&quot;1fragment是什么&quot; data-anchor-id=&quot;x2cc&quot;&gt;1、Fragment是什么？&lt;/h2&gt;
&lt;p data-anchor-id=&quot;nuzi&quot;&gt;以上面提到的邮件app为例，我们希望邮件App在小屏幕的手机上一个Activity显示标题，一个Activity显示详情。而在大屏幕平板上左边显示标题右边显示详情。&lt;/p&gt;
&lt;p data-anchor-id=&quot;3h33&quot;&gt;假如我们仅使用Activity来实现这个需求，我们需要根据设备类型创建两个不同的Activity显示流程。针对手机，需要两个Activity来协作，一个包含ListView的Activity来显示标题，另一个包含其他控件组合来显示详情；而针对平板，需要重新创建一个包含ListView和其他控件的Activity。在使用如上的方案时，我们可以通过标签重用layout布局文件。但是编码部分呢？没有一个很好的方式来重用代码。Fragment就是为了解决这个重用的问题。&lt;/p&gt;
&lt;p data-anchor-id=&quot;ktcw&quot;&gt;Fragment的主要功能是将布局和其对应的代码组合到一起统一管理和重用。针对邮件App，可以将显示标题的ListView部分组合为一个Fragment，显示详情的部分组合为一个Fragment，这样在针对手机和平板适配时，Activity只需要根据不同情况显示不同的Fragment即可，优雅的解决了代码和布局重用的问题。如下所示：&lt;/p&gt;
&lt;p data-anchor-id=&quot;ktcw&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937054/201807/937054-20180711115811535-2022429776.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2fragment的构成&quot; data-anchor-id=&quot;yqnf&quot;&gt;2、Fragment的构成&lt;/h2&gt;
&lt;p data-anchor-id=&quot;0ne8&quot;&gt;Fragment用于管理UI，因此其内部肯定有视图层级，为了在Fragment销毁后重建一致，需要传入一个bundle来重新配置视图。&lt;/p&gt;
&lt;p data-anchor-id=&quot;vz41&quot;&gt;当Fragment被销毁后重建时，Android会调用Fragment的空参构造方法来生成一个新的对象，并通过一个传入bundle参数的方法设置其状态。因此我们在继承以Fragment时必须保留其空构造方法。&lt;/p&gt;
&lt;p data-anchor-id=&quot;88lj&quot;&gt;因为每个Fragment都有自己的视图，很有可能的一种设计是：在某个操作后，将Activity中原来的Fragment替换为一个新的Fragment，而同时又想要在按返回键时返回到原来的Fragment，因此Fragment又有一个返回栈的设计。&lt;/p&gt;
&lt;h2 id=&quot;3fragment的生命周期&quot; data-anchor-id=&quot;zhlj&quot;&gt;3、Fragment的生命周期&lt;/h2&gt;
&lt;p data-anchor-id=&quot;pc88&quot;&gt;Fragment的生命周期与Activity有很多相同，但更复杂，具体流程如下图：&lt;/p&gt;
&lt;p data-anchor-id=&quot;jnwd&quot;&gt;&lt;img src=&quot;http://blog.votzone.com/2018/07/10/figure_2_fragment_lifecycle.png&quot; alt=&quot;FragmentLifecycle&quot; width=&quot;660&quot; height=&quot;552&quot;/&gt; &lt;/p&gt;
&lt;p data-anchor-id=&quot;jnwd&quot;&gt;Fragment是一个继承至Object的类，与Activity不同，Android并不为我们事先创建好该对象，因此在将Fragment附加给一个Activity时必须自己创建一个Fragment对象。 &lt;br/&gt;在之前也提到过，Android虽然不创建Fragment，但是当Fragment附加到Activity时，Android会管理其销毁和重建，重建过程类似于如下代码：&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyFragment newInstance(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    MyFragment f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyFragment();
    Bundle args &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bundle();
    args.putInt(&lt;/span&gt;&quot;index&quot;&lt;span&gt;, index);
    f.setArguments(args);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;vtxh&quot;&gt;因此我们在创建一个Fragment时有必要按照如上代码的方式来创建Fragment实例。&lt;/p&gt;
&lt;p data-anchor-id=&quot;bwkm&quot;&gt;当我们将创建的Fragment实例附加给Activity时，其生命周期的回调方法即开始起作用了。&lt;/p&gt;
&lt;h3 id=&quot;oninflate-回调&quot; data-anchor-id=&quot;x6vr&quot;&gt;onInflate( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;s59v&quot;&gt;通过在layout中添加标签的方式使用Fragment时，onInflate()会执行。其主要目的是为了提供标签中的属性，可以从该回调中读取属性并保留以后使用。&lt;/p&gt;
&lt;h3 id=&quot;onattach-回调&quot; data-anchor-id=&quot;khww&quot;&gt;onAttach( )回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;tdat&quot;&gt;当Fragment附加到Activity后立即进行onAttach()，回调会传入所附加的Activity作为Context上下文。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAttach(Context context) {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onAttach(context);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; OnFragmentInteractionListener) {
        mListener &lt;/span&gt;=&lt;span&gt; (OnFragmentInteractionListener) context;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(context.toString() + &quot; must implement OnFragmentInteractionListener&quot;&lt;span&gt;);
    }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote class=&quot;black-blockquote&quot; data-anchor-id=&quot;6skd&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;上述代码使用onAttach()回调优雅的实现了listener的赋值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;注意&quot; data-anchor-id=&quot;0udo&quot;&gt;注意：&lt;/h5&gt;
&lt;p data-anchor-id=&quot;3oad&quot;&gt;1、你可以保存Context对象作为Activity的引用也可以不这么做，因为Fragment有一个getActivity()会返回你所需要的Activity。&lt;/p&gt;
&lt;p data-anchor-id=&quot;ungc&quot;&gt;2、在onAttach()之后就不能再进行setArgument()调用了，因为onAttach()时已经附加到Activity，应该在之前确定Fragment的各个参数。因此setArgument()应该尽早调用。&lt;/p&gt;
&lt;h3 id=&quot;oncreate回调&quot; data-anchor-id=&quot;mjgq&quot;&gt;onCreate()回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;ntr8&quot;&gt;onCreate是下一个要执行的方法，回调方法执行时，整个Fragment的参数设置已经齐全了，包括Bundle传入的参数和所属Activity对象，但并不意味着视图层级已经构造完成了。同时回调方法不一定在Activity实例的onCreate之后。该回调的存在目的：&lt;/p&gt;
&lt;ol data-anchor-id=&quot;5n94&quot;&gt;&lt;li&gt;获取传入的bundle；&lt;/li&gt;
&lt;li&gt;为Fragment提供一个尽早执行的入口，用于获取所需数据；&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote class=&quot;black-blockquote&quot; data-anchor-id=&quot;ed2a&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;注： 回调方法都在主线程，因此是不能执行耗时较长的方法例如网络请求或者读取本地较大文件等。可以在onCreate中创建线程来获取数据，再通过handle 或者Loader的方式返回结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;oncreateview-回调&quot; data-anchor-id=&quot;y7qu&quot;&gt;onCreateView( )回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;w9vr&quot;&gt;onCreateView()试下一个要执行的回调方法，该方法中创建了一个视图层级（view 对象）并返回。参数包括一个LayoutInflater，一个ViewGroup和一个Bundle。需要注意的是尽管有parent（ViewGroup），我们并不能将创建的view 附加给parent。此处的parent仅仅在创建view时提供一些参考，之后会自动附加。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; View onCreateView(LayoutInflater inflater,
ViewGroup container, Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(container == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
View v &lt;/span&gt;= inflater.inflate(R.layout.details, container, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
TextView text1 &lt;/span&gt;=&lt;span&gt; (TextView) v.findViewById(R.id.text1);
text1.setText(myDataSet[ getPosition() ] );
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;vfwz&quot;&gt;注:container 为null，说明没有Fragment没有视图层级上。&lt;/p&gt;
&lt;h3 id=&quot;onviewcreated-回调&quot; data-anchor-id=&quot;i7qx&quot;&gt;onViewCreated( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;eg6n&quot;&gt;onCreateView之后并且在UI布局之前，其参数是一个view，即刚刚在onCreateView中返回的view。&lt;/p&gt;
&lt;h3 id=&quot;onactivitycreated-回调&quot; data-anchor-id=&quot;oyin&quot;&gt;onActivityCreated( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;acz9&quot;&gt;在onActivityCreated()回调方法之后，Fragment就可以与用户进行交互了。onActivityCreated()在Activity的onCreate()之后，并且Activity所有用到的Fragment都已准备完成。&lt;/p&gt;
&lt;h3 id=&quot;onviewstaterestored-回调&quot; data-anchor-id=&quot;ctib&quot;&gt;onViewStateRestored( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;2raf&quot;&gt;该回调在Android 4.2之后引入，在Fragment重建时调用，之前重建时必须将重建逻辑放在在onActivityCreated()，现在可以放到这里。&lt;/p&gt;
&lt;h3 id=&quot;onstart-回调&quot; data-anchor-id=&quot;5umd&quot;&gt;onStart( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;s79n&quot;&gt;此时，Fragment已经可见，该回调与Activity的onStart()一致，之前在Activity中onStart回调的代码可以直接放到这里。&lt;/p&gt;
&lt;h3 id=&quot;onresume-回调&quot; data-anchor-id=&quot;io17&quot;&gt;onResume( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;r0wb&quot;&gt;与Activity的onResume()回调一致。&lt;/p&gt;
&lt;h3 id=&quot;onpause-回调&quot; data-anchor-id=&quot;cjo1&quot;&gt;onPause( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;vwm9&quot;&gt;与Activity的onPause()一致。&lt;/p&gt;
&lt;h3 id=&quot;onsaveinstancestate-回调&quot; data-anchor-id=&quot;esnc&quot;&gt;onSaveInstanceState( )回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;nugm&quot;&gt;与Activity相同，Fragment也提供一个能够保存状态的回调。通过该回调方法，可以将Fragment中的状态值以bundle的形式保存起来，在onViewStateRestored()的时候重建。需要注意的是，Fragment之所以被回收就是因为内存问题，因此应该只保留需要保留的数据。&lt;/p&gt;
&lt;p data-anchor-id=&quot;m2p4&quot;&gt;如果该Fragment依赖于另一个Fragment，不要试图保存其直接的引用，而应该使用id或者tag。&lt;/p&gt;
&lt;p data-anchor-id=&quot;k3d2&quot;&gt;注：尽管该回调通常发生在onPause()之后，但这并不意味着就在onPause之后立即执行。&lt;/p&gt;
&lt;h3 id=&quot;onstop-回调&quot; data-anchor-id=&quot;dm00&quot;&gt;onStop( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;brya&quot;&gt;与Activity的onStop()一致。&lt;/p&gt;
&lt;h3 id=&quot;ondestroyview-回调&quot; data-anchor-id=&quot;hf2o&quot;&gt;onDestroyView( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;bugp&quot;&gt;在创建的view视图从Activity脱离（detach)之前的回调。&lt;/p&gt;
&lt;h3 id=&quot;ondestroy-回调&quot; data-anchor-id=&quot;qfp4&quot;&gt;onDestroy( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;mgjc&quot;&gt;在View销毁之后，Fragment真正开始销毁了，此时已然能够找到该Fragment但是该Fragment已经不能进行任何操作。&lt;/p&gt;
&lt;h3 id=&quot;ondetach-回调&quot; data-anchor-id=&quot;f90v&quot;&gt;onDetach( ) 回调&lt;/h3&gt;
&lt;p data-anchor-id=&quot;gb0p&quot;&gt;从Activity脱离，Fragment不在拥有view视图层级。&lt;/p&gt;
&lt;h2 id=&quot;使用-setretaininstance&quot; data-anchor-id=&quot;qq7f&quot;&gt;使用 setRetainInstance( )&lt;/h2&gt;
&lt;p data-anchor-id=&quot;gl3v&quot;&gt;Fragment与Activity是分开存在的两个对象，因此在Activity销毁并重建时有两种选择：1、完全重建Fragment；2、在销毁时保留Fragment对象并在Activity重建时使用，正如上图8-2中虚线路径。&lt;/p&gt;
&lt;p data-anchor-id=&quot;zpvc&quot;&gt;Fragment将这种选择交给了开发者，通过提供的 setRetainInstance()方法来决定使用哪种办法。如果方法传入false则使用第一种，否则使用第二种方式。 &lt;br/&gt;该方法设置的时机可以在onCreate()、onCreateView()以及onActivityCreate()，越早越好。&lt;/p&gt;
&lt;h2 id=&quot;fragment-简单案例&quot; data-anchor-id=&quot;ilic&quot;&gt;Fragment 简单案例&lt;/h2&gt;
&lt;p data-anchor-id=&quot;46ti&quot;&gt;&lt;a href=&quot;https://github.com/votzone/DroidCode/tree/master/Fragments&quot; target=&quot;_blank&quot;&gt;案例代码&lt;/a&gt; &lt;br/&gt;案例是一个类似于邮件的布局的小说展示应用，分为横屏和竖屏不同布局，横屏时显示左右结构，竖屏时先后显示。为了简化实现过程，所有数据为内存中的数据。&lt;/p&gt;
&lt;p data-anchor-id=&quot;juxx&quot;&gt;首先是main.xml的实现，对于横屏和竖屏分别实现两个不同的main.xml布局（分别对应res/layout 文件目录和res/layout-land目录）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; This file is res/layout/main.xml &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
　　android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fragment &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.androidbook.fragments.bard.TitlesFragment&quot;&lt;/span&gt;&lt;span&gt;
　　android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/titles&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; This file is res/layout-land/main.xml &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
　　android:orientation&lt;/span&gt;&lt;span&gt;=&quot;horizontal&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
　　android:background&lt;/span&gt;&lt;span&gt;=&quot;#fff&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fragment &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.androidbook.fragments.bard.TitlesFragment&quot;&lt;/span&gt;&lt;span&gt;
　　android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/titles&quot;&lt;/span&gt;&lt;span&gt; android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;0px&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
　　android:background&lt;/span&gt;&lt;span&gt;=&quot;#00550033&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FrameLayout
　　&lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/details&quot;&lt;/span&gt;&lt;span&gt; android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;0px&quot;&lt;/span&gt;&lt;span&gt;
　　android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;9k00&quot;&gt;当手机竖屏是，创建的MainActivity中只包含一个TitleFragment，当为横屏时包含两部分，因此我们实现一个方法来确定是否为多面板应用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isMultiPane() {
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getResources().getConfiguration().orientation ==&lt;span&gt; Configuration.ORIENTATION_LANDSCAPE;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;q24l&quot;&gt;我们在加载TitlesFragment完成之后做这么一件事：加载一篇文章。对于横屏的显示到右边对于竖屏显示到新的Activity。因此该实现逻辑需要放到MainActivity，TitlesFragment在适合的事件调用MainActivity即可。&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onAttach(Activity myActivity) {
    Log.v(MainActivity.TAG, &lt;/span&gt;&quot;in TitlesFragment onAttach; activity is: &quot; +&lt;span&gt; myActivity);
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onAttach(myActivity);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myActivity =&lt;span&gt; (MainActivity)myActivity;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onActivityCreated(Bundle icicle) {
　　&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityCreated(icicle);
　　......
　　myActivity.showDetails(mCurCheckPosition);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;1hbm&quot;&gt;showDetails的实现&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; showDetails(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
　　Log.v(TAG, &lt;/span&gt;&quot;in MainActivity showDetails(&quot; + index + &quot;)&quot;&lt;span&gt;);
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMultiPane()) {
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check what fragment is shown, replace if needed.&lt;/span&gt;
　　　　DetailsFragment details =&lt;span&gt; (DetailsFragment)
　　　　getFragmentManager().findFragmentById(R.id.details);
　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (details == &lt;span&gt;null&lt;/span&gt; || details.getShownIndex() !=&lt;span&gt; index) {
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make new fragment to show this selection.&lt;/span&gt;
　　　　　　details =&lt;span&gt; DetailsFragment.newInstance(index);
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute a transaction, replacing any existing
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fragment inside the frame with the new one.&lt;/span&gt;
　　　　　　Log.v(TAG, &quot;about to run FragmentTransaction...&quot;&lt;span&gt;);
　　　　　　FragmentTransaction ft &lt;/span&gt;=&lt;span&gt; getFragmentManager().beginTransaction();
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ft.setCustomAnimations(R.animator.fragment_open_enter,
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; R.animator.fragment_open_exit);&lt;/span&gt;
　　　　　　&lt;span&gt;ft.setCustomAnimations(R.animator.bounce_in_down,
　　　　　　R.animator.slide_out_right);
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ft.setCustomAnimations(R.animator.fade_in,
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; R.animator.fade_out);
　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE);&lt;/span&gt;
　　　　　　&lt;span&gt;ft.replace(R.id.details, details);
　　　　　　ft.addToBackStack(TAG);
　　　　　　ft.commit();
　　　　}
　　} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise we need to launch a new activity to display
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the dialog fragment with selected text.&lt;/span&gt;
　　　　Intent intent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Intent();
　　　　intent.setClass(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, DetailsActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
　　　　intent.putExtra(&lt;/span&gt;&quot;index&quot;&lt;span&gt;, index);
　　　　startActivity(intent);
　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;qd7w&quot;&gt;根据横竖屏的不同，分别显示到右边或者新的Activity。 &lt;br/&gt;整体实现完毕，详见代码 &lt;a href=&quot;https://github.com/votzone/DroidCode/tree/master/Fragments&quot; target=&quot;_blank&quot;&gt;https://github.com/votzone/DroidCode/tree/master/Fragments&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;注意-1&quot; data-anchor-id=&quot;f4y7&quot;&gt;注意：&lt;/h3&gt;
&lt;h4 id=&quot;1在案例中fragment的添加和替换有两种方式&quot; data-anchor-id=&quot;gsat&quot;&gt;1、在案例中Fragment的添加和替换有两种方式&lt;/h4&gt;
&lt;p data-anchor-id=&quot;tz80&quot;&gt;1) 通过xml直接添加fragmet标签，指定其实现类即可。&lt;/p&gt;
&lt;p data-anchor-id=&quot;sb02&quot;&gt;2) 通过FragmentManager来动态添加，就像DetailsFragment中一样，或者拿到父view添加：&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
DetailsFragment details =&lt;span&gt; DetailsFragment.newInstance(getIntent().getExtras());
getFragmentManager().beginTransaction()
.add(android.R.id.content, details)
.commit();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;2使用fragment的引用时可以通过fragmentmanager的findfragmentbyid-或findfragmentbytag-的方式获取&quot; data-anchor-id=&quot;ihd6&quot;&gt;2、使用Fragment的引用时，可以通过FragmentManager的&lt;code class=&quot;code-black&quot;&gt;findFragmentById&lt;/code&gt; 或&lt;code class=&quot;code-black&quot;&gt;findFragmentByTag&lt;/code&gt; 的方式获取。&lt;/h4&gt;
&lt;h4 id=&quot;3在onsaveinstancestate的参数bundle实例中保存状态&quot; data-anchor-id=&quot;akn8&quot;&gt;3、在onSaveInstanceState的参数bundle实例中保存状态&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onSaveInstanceState(Bundle icicle) {
　　Log.v(MainActivity.TAG, &lt;/span&gt;&quot;in TitlesFragment onSaveInstanceState&quot;&lt;span&gt;);
　　&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onSaveInstanceState(icicle);
　　icicle.putInt(&lt;/span&gt;&quot;curChoice&quot;&lt;span&gt;, mCurCheckPosition);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;4与fragment之间的交互获取引用的方法&quot; data-anchor-id=&quot;jl4z&quot;&gt;4、与Fragment之间的交互（获取引用）的方法&lt;/h4&gt;
&lt;p data-anchor-id=&quot;ld9d&quot;&gt;1）通过&lt;code class=&quot;code-black&quot;&gt;FragmentManager&lt;/code&gt;的&lt;code class=&quot;code-black&quot;&gt;findFragmentByTag&lt;/code&gt;或者&lt;code class=&quot;code-black&quot;&gt;findFragmentById&lt;/code&gt;来找到该Fragment，然后调用方法&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FragmentOther fragOther = (FragmentOther)getFragmentManager().findFragmentByTag(&quot;other&quot;&lt;span&gt;);
fragOther.callCustomMethod( arg1, arg2 );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p data-anchor-id=&quot;m6zf&quot;&gt;2）通过&lt;code class=&quot;code-black&quot;&gt;getTargetFragment()&lt;/code&gt;找到当前Fragment的TargetFragment来获取引用;&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
TextView tv =&lt;span&gt; (TextView)getTargetFragment().getView().findViewById(R.id.text1);
tv.setText(&lt;/span&gt;&quot;Set from the called fragment&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p data-anchor-id=&quot;ut2g&quot;&gt;对一个Fragment设置TargetFragment需要使用FragmentManager，如下：&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mCalledFragment = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalledFragment();
mCalledFragment.setTargetFragment(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, 0&lt;span&gt;);
fm.beginTransaction().add(mCalledFragment, &lt;/span&gt;&quot;work&quot;).commit();
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Wed, 11 Jul 2018 04:09:00 +0000</pubDate>
<dc:creator>votzone</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fog2012/p/fragment.html</dc:identifier>
</item>
<item>
<title>React中嵌套组件与被嵌套组件的通信 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/9293741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/9293741.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在React项目的开发中经常会遇到这样一个场景：嵌套组件与被嵌套组件的通信。&lt;/p&gt;
&lt;p&gt;比如Tab组件啊，或者下拉框组件。&lt;/p&gt;
&lt;h2 id=&quot;场景&quot;&gt;场景&lt;/h2&gt;
&lt;p&gt;这里应用一个最简单的Tab组件来呈现这个场景。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React, { Component, PropTypes } from 'react'

class Tab extends Component {
  static propTypes = {
    children: PropTypes.node
  }

  render() {
    return (
      &amp;lt;ul&amp;gt;
        {this.props.children}
      &amp;lt;/ul&amp;gt;
    )
  }
}

class TabItem extends Component {
  static propTypes = {
    name: PropTypes.string,
    active: PropTypes.bool,
    onClick: PropTypes.func
  }

  handleClick = () =&amp;gt; {
    this.props.onClick(this.props.name)
  }

  render() {
    return (
      &amp;lt;li onClick={this.handleClick} className={this.props.active ? 'active' : 'noActive'}&amp;gt;
        {this.props.name}
      &amp;lt;/li&amp;gt;
    )
  }
}

export default class Area extends Component {
  state = {
    activeName: ''
  }

  handleClick = (name) =&amp;gt; {
    this.setState({
      activeName: name
    })
  }

  render() {
    return (
      &amp;lt;Tab&amp;gt;
        {['武汉', '上海', '北京'].map((item) =&amp;gt; &amp;lt;TabItem onClick={this.handleClick} active={this.state.activeName === item} name={item} /&amp;gt;)}
      &amp;lt;/Tab&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有Tab，TabItem和Area三个组件，其中Tab为嵌套组件，TabItem为被嵌套组件，Area为使用它们的组件。&lt;/p&gt;
&lt;p&gt;在上述场景中，点击哪个TabItem项时，就将这个TabItem项激活。&lt;/p&gt;
&lt;p&gt;以上方案算是嵌套组件最常用的方案了。&lt;/p&gt;
&lt;h2 id=&quot;需求的变更与缺陷的暴露&quot;&gt;需求的变更与缺陷的暴露&lt;/h2&gt;
&lt;p&gt;在上述场景下应用上述方案是没有问题的，但是我们通常用的Tab没有这么简单，比如当点击武汉这个TabItem时，武汉地区的美食也要展示出来。&lt;/p&gt;
&lt;p&gt;这种场景下就需要修改TabItem组件为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TabItem extends Component {
  static propTypes = {
    name: PropTypes.string,
    active: PropTypes.bool,
    onClick: PropTypes.func,
    children: PropTypes.node
  }

  handleClick = () =&amp;gt; {
    this.props.onClick(this.props.name)
  }

  render() {
    return (
      &amp;lt;li onClick={this.handleClick} className={this.props.active ? 'active' : 'noActive'}&amp;gt;
        &amp;lt;span className='switchBtn'&amp;gt;{this.props.name}&amp;lt;/span&amp;gt;
        &amp;lt;div className={this.props.active ? 'show' : 'hide'}&amp;gt;
          {this.props.children}
        &amp;lt;/div&amp;gt;
      &amp;lt;/li&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后沿用上述方案，那么就需要改变Area组件为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default class Area extends Component {
  state = {
    activeName: ''
  }

  handleClick = (name) =&amp;gt; {
    this.setState({
      activeName: name
    })
  }

  render() {
    return (
      &amp;lt;Tab&amp;gt;
        &amp;lt;TabItem onClick={this.handleClick} active={this.state.activeName === '武汉'} name={'武汉'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
        &amp;lt;TabItem onClick={this.handleClick} active={this.state.activeName === '上海'} name={'上海'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
        &amp;lt;TabItem onClick={this.handleClick} active={this.state.activeName === '北京'} name={'北京'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
      &amp;lt;/Tab&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的Area使用TabItem的时候已经没办法用 数组+map 的形式去写了。&lt;/p&gt;
&lt;p&gt;因为这里有大量的jsx在这里，如果那样去写，代码的可读性将会非常糟糕。&lt;/p&gt;
&lt;p&gt;那么用上面的写法写的时候，就会出现一个问题，就是onClick在不断重复，active的判断也在不断重复。&lt;/p&gt;
&lt;h2 id=&quot;尝试掩盖active判断重复的问题&quot;&gt;尝试掩盖active判断重复的问题&lt;/h2&gt;
&lt;p&gt;这个比较容易，修改代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TabItem extends Component {
  static propTypes = {
    name: PropTypes.string,
    activeName: PropTypes.string,
    onClick: PropTypes.func,
    children: PropTypes.node
  }

  handleClick = () =&amp;gt; {
    this.props.onClick(this.props.name)
  }

  render() {
    return (
      &amp;lt;li onClick={this.handleClick} className={this.props.activeName === this.props.name ? 'active' : 'noActive'}&amp;gt;
        &amp;lt;span className='switchBtn'&amp;gt;{this.props.name}&amp;lt;/span&amp;gt;
        &amp;lt;div className={this.props.active ? 'show' : 'hide'}&amp;gt;
          {this.props.children}
        &amp;lt;/div&amp;gt;
      &amp;lt;/li&amp;gt;
    )
  }
}

export default class Area extends Component {
  state = {
    activeName: ''
  }

  handleClick = (name) =&amp;gt; {
    this.setState({
      activeName: name
    })
  }

  render() {
    return (
      &amp;lt;Tab&amp;gt;
        &amp;lt;TabItem onClick={this.handleClick} activeName={this.state.activeName} name={'武汉'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
        &amp;lt;TabItem onClick={this.handleClick} activeName={this.state.activeName} name={'上海'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
        &amp;lt;TabItem onClick={this.handleClick} activeName={this.state.activeName} name={'北京'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
      &amp;lt;/Tab&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;尝试掩盖onclick不断重复的问题&quot;&gt;尝试掩盖onClick不断重复的问题&lt;/h2&gt;
&lt;p&gt;想要onClick不重复，那么就不能将其写在TabItem上，而是应该写在Tab上。&lt;/p&gt;
&lt;p&gt;那么这个地方就得用到事件冒泡的机制。&lt;/p&gt;
&lt;p&gt;将onClick写在Tab上，然后根据捕获的事件消息，获取target的class是否为switchBtn，然后得到target的text。&lt;/p&gt;
&lt;p&gt;再将这个text赋值为activeName。&lt;/p&gt;
&lt;p&gt;并且你还得期望点击的switchBtn的内的结构不那么复杂，最好是就只有一个文本。&lt;/p&gt;
&lt;p&gt;如果需求还要给Tab项的切换按钮每个都加上图标，那么你还得看这个事件的target是不是这个图标。那么又需要做更多的处理了。&lt;/p&gt;
&lt;p&gt;想一想就觉得麻烦。&lt;/p&gt;
&lt;p&gt;一般在这种情况下，脑子里唯一的想法就是，就这样吧，这个onClick重复就重复吧，没什么大不了的。&lt;/p&gt;
&lt;p&gt;连我自己都懒得写这部分代码了。&lt;/p&gt;
&lt;h2 id=&quot;嵌套组件与被嵌套组件的通信react.children与react.cloneelement&quot;&gt;嵌套组件与被嵌套组件的通信：React.Children与React.cloneElement&lt;/h2&gt;
&lt;p&gt;实际上要解决上面的问题，只需要一个东西就好了，那就是嵌套组件能传递值给被嵌套组件的props，比如onClick。&lt;/p&gt;
&lt;p&gt;那么先上一份代码吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TabItem extends Component {
  static propTypes = {
    name: PropTypes.string,
    activeName: PropTypes.string,
    onClick: PropTypes.func,
    children: PropTypes.node
  }

  handleClick = () =&amp;gt; {
    this.props.onClick(this.props.name)
  }

  render() {
    return (
      &amp;lt;li onClick={this.handleClick} className={this.props.activeName === this.props.name ? 'active' : 'noActive'}&amp;gt;
        &amp;lt;span className='switchBtn'&amp;gt;{this.props.name}&amp;lt;/span&amp;gt;
        &amp;lt;div className={this.props.active ? 'show' : 'hide'}&amp;gt;
          {this.props.children}
        &amp;lt;/div&amp;gt;
      &amp;lt;/li&amp;gt;
    )
  }
}

class Tab extends Component {
  static propTypes = {
    children: PropTypes.node,
    onClickItem: PropTypes.func,
    activeName: PropTypes.string
  }

  render() {
    return (
      &amp;lt;ul&amp;gt;
        {
          React.Children.map(this.props.children,(child)=&amp;gt;{
            if (child.type === TabItem) {
              return React.cloneElement(child, {
                // 把父组件的props.name赋值给每个子组件（父组件传值给子组件）
                activeName: this.props.activeName,
                // 父组件的方法挂载到props.onClick上，以便子组件内部通过props调用
                onClick: this.props.onClickItem
              })
            } else {
              return child
            }
          })
        }
      &amp;lt;/ul&amp;gt;
    )
  }
}

export default class Area extends Component {
  state = {
    activeName: ''
  }

  handleClick = (name) =&amp;gt; {
    this.setState({
      activeName: name
    })
  }

  render() {
    return (
      &amp;lt;Tab activeName={this.state.activeName}  onClick={this.handleClick} &amp;gt;
        &amp;lt;TabItem name={'武汉'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
        &amp;lt;TabItem name={'上海'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
        &amp;lt;TabItem name={'北京'} &amp;gt;
          武汉的美食，这里有一大堆jsx代码
        &amp;lt;/TabItem&amp;gt;
      &amp;lt;/Tab&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式，我们发现在使用Tab和TabItem时会变得非常简单。&lt;/p&gt;
&lt;p&gt;那么接下来让我们介绍一下解决嵌套组件通信这个问题的关键：React.Children.map和React.cloneElement。&lt;/p&gt;
&lt;h2 id=&quot;react.children&quot;&gt;React.Children&lt;/h2&gt;
&lt;p&gt;React.Children是专门用来处理this.props.children这个东西的工具。&lt;/p&gt;
&lt;p&gt;通常props.children可以是任何变量类型：数组、对象、文本或者其他的一些类型，但是我们这里使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;React.Children.map(this.props.children,(child)=&amp;gt;{
  // ***
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论this.props.children的类型是什么都不会报错。&lt;/p&gt;
&lt;p&gt;这里只是用了React.children的map函数，实际上它还有foreach，count以及only的玩法。&lt;/p&gt;
&lt;p&gt;foreach就不解释了，很容易理解是干嘛的。&lt;/p&gt;
&lt;p&gt;count就是得到被嵌套组件的数量。&lt;/p&gt;
&lt;p&gt;only就是返回被嵌套的组件，并且只能有一个被嵌套的组件，否则会抛异常。&lt;/p&gt;
&lt;h2 id=&quot;react.cloneelement&quot;&gt;React.cloneElement&lt;/h2&gt;
&lt;p&gt;先看下面这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const child= &amp;lt;Child value={1} /&amp;gt;
const newChild=React.cloneElement(child,{
  name:'额外的props'
},'123')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;newChild的值为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Child value={1} name='额外的props' &amp;gt;
  123
&amp;lt;/Child&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以很明显看到，React.cloneElement的就相当克隆一个组件，然后可以传给它额外的props和children。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对于简单的嵌套组件用最开始的方法其实已经够了。&lt;/p&gt;
&lt;p&gt;但是对于复杂的嵌套组件为了更好更方便的使用，往往需要与被嵌套的组件进行通信。&lt;/p&gt;
&lt;p&gt;而我们可以使用React.Children和React.cloneElement来解决这个问题。&lt;/p&gt;
</description>
<pubDate>Wed, 11 Jul 2018 04:03:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vvjiang/p/9293741.html</dc:identifier>
</item>
<item>
<title>vue-awesome-swiper - 基于vue实现h5滑动翻页效果 - 郭菊锋</title>
<link>http://www.cnblogs.com/padding1015/p/9293762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/9293762.html</guid>
<description>&lt;p&gt;说到h5的翻页，很定第一时间想到的是swiper。但是我当时想到的却是，vue里边怎么用swiper？！&lt;/p&gt;

&lt;p&gt;中国有句古话叫：天塌下来有个高的顶着。&lt;/p&gt;
&lt;p&gt;在前端圈里，总有前仆后继的仁人志士相继挥洒着热汗（这里没有血），在我们小白需要用到两个技术结合的时候，他们早已冲向前为我们杀出了一条路，准备好了实现用的技术和方案。有时候我就在想，我的理想大概就是站在自己现在仰望的代码塔的顶峰，像他们一样，不断输出自己的热情和力量，产出一个可以为人所用的东西，以能够为后来人发光发热吧。&lt;/p&gt;

&lt;p&gt;vue-awesome-swiper就是其中一个前辈们产出的结晶。就看首尾两个单词，就知道他是vue和swiper的爱情之子了。&lt;/p&gt;
&lt;p&gt;先来仰望一波——&amp;gt;九点钟方向。&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/surmon-china/vue-awesome-swiper&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;vue-awesome-swiper&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/surmon-china/vue-awesome-swiper&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;官网&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;是中文文档，妈妈再也不用担心我读api啦。“基于 Swiper4、适用于 Vue 的轮播组件”。在产品催着进度的紧张环境下，在四处搜寻解决方案的情况下，这句话简直发着光啊。&lt;/p&gt;
&lt;p&gt;具体怎么用，官方文档写的很清楚，但我还是想记录下来，好再普及一波。&lt;/p&gt;

&lt;p&gt;一、天才&lt;span&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;/span&gt;，这里没有纸尿裤（(⊙﹏⊙) 好像暴露了年龄...）&lt;/p&gt;
&lt;p&gt;准备一个基于&lt;span&gt;vue-cli&lt;/span&gt;的项目(或者你自己的脚手架，whatever),没有准备的请移驾&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/9092998.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;vue-cli教程&lt;/strong&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/9092998.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/padding1015/p/9092998.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115202932-359145038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、在项目目录下，往node_modules里&lt;span&gt;&lt;strong&gt;安装插件vue-awesome-swiper&lt;/strong&gt;&lt;/span&gt;（可以在项目目录内，shift+鼠标右键，选择&quot;在此处打开命令窗口&quot;），&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115214102-1674704796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注释：我这里window电脑安装了，所有右键出现的可能和没安装的不一样，实在找不到的看这一篇教程：&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/7162024.html&quot; target=&quot;_blank&quot;&gt;gulp安装流程、使用方法及CMD常用命令导览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后输入下边的&lt;span&gt;&lt;strong&gt;安装插件&lt;/strong&gt;&lt;/span&gt;命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i --s vue-awesome-swiper
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115322311-388117242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、第三步我们依旧没有天才牌裤子，所以还是自己一步一步稳稳走。&lt;/p&gt;
&lt;p&gt;1．插件安装后就是&lt;span&gt;&lt;strong&gt;引用插件&lt;/strong&gt;&lt;/span&gt;了，main.js内部分三步走：&lt;/p&gt;
&lt;p&gt;(1) &lt;span&gt;&lt;strong&gt;引用插件&lt;/strong&gt;&lt;/span&gt;：mainjs注册vas&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115436018-144513828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;(2)&lt;span&gt;&lt;strong&gt; 注册插件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注册后未use控制台就警告了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115439554-1104178582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过全局方法 Vue.use() 使用插件后可以了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115452964-1411405822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用后控制台无错了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115500184-662040799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;(3) &lt;span&gt;&lt;strong&gt;插件样式&lt;/strong&gt;&lt;/span&gt;（也可以自己写，不用人家的）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115514786-1745281889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;2．&lt;span&gt;&lt;strong&gt;vue项目中使用&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1) 准备-template&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;new a project&lt;/strong&gt;&lt;/span&gt;准备一个空项目&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115532430-368767689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始化html-空结构&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115539723-1797231024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(2) &lt;span&gt;&lt;strong&gt;引入-import&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115549432-982278872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(3) &lt;span&gt;&lt;strong&gt;注册组件-components&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115604341-169481699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(4) &lt;span&gt;&lt;strong&gt;配置-js&lt;/strong&gt;&lt;/span&gt;（具体配置和swiper的一摸一样，看swiper官网即可。我这里只说下我本次使用的配置的含义）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115615405-407534903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.swiper.com.cn/api/parameters/21.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;swiper官网参数&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115624070-89884442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）&lt;span&gt;美化- css&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115633602-1293737730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;wan~&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115644096-1838145094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115656525-462223818.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115649693-1501690670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1439274/201807/1439274-20180711115702592-2136205537.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;main.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import VueAwesomeSwiper from 'vue-awesome-swiper'
import 'swiper/dist/css/swiper.css'
Vue.use(VueAwesomeSwiper)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zujian.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello-world&quot;&amp;gt;
    &amp;lt;!-- &amp;lt;h3&amp;gt;https://github.com/surmon-china/vue-awesome-swiper&amp;lt;/h3&amp;gt; --&amp;gt;
    &amp;lt;!-- &amp;lt;h3&amp;gt;http://www.swiper.com.cn/api/index2.html&amp;lt;/h3&amp;gt; --&amp;gt;
    &amp;lt;!-- http://www.swiper.com.cn/api/parameters/21.html --&amp;gt;
    &amp;lt;transition name=&quot;fade&quot;&amp;gt;
      &amp;lt;swiper id=&quot;swiperBox&quot; v-bind:options=&quot;swiperOption&quot; ref=&quot;mySwiper&quot;&amp;gt;
          &amp;lt;!-- 第一页 --&amp;gt;
          &amp;lt;swiper-slide class=&quot;swiper-slide1&quot;&amp;gt;
            &amp;lt;div class=&quot;page&quot;&amp;gt;
              &amp;lt;h3&amp;gt;第一页&amp;lt;/h3&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/swiper-slide&amp;gt;
          &amp;lt;!-- 第二页 --&amp;gt;
          &amp;lt;swiper-slide class=&quot;swiper-slide2&quot;&amp;gt;
            &amp;lt;div class=&quot;page&quot;&amp;gt;
              &amp;lt;h3&amp;gt;第二页&amp;lt;/h3&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/swiper-slide&amp;gt;
          &amp;lt;!-- 第三页 --&amp;gt;
          &amp;lt;swiper-slide class=&quot;swiper-slide3&quot;&amp;gt;
            &amp;lt;div class=&quot;page&quot;&amp;gt;
              &amp;lt;h3&amp;gt;第三页&amp;lt;/h3&amp;gt;
            &amp;lt;/div&amp;gt;
          &amp;lt;/swiper-slide&amp;gt;
      &amp;lt;/swiper&amp;gt;
    &amp;lt;/transition&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import { swiper, swiperSlide } from 'vue-awesome-swiper'
export default {
  name: 'HelloWorld',
  components: {
    swiper,
    swiperSlide
  },
  data () {
    return {
      swiperOption: {
        // swiper configs 所有的配置同swiper官方api配置
        
        notNextTick: true,//notNextTick是一个组件自有属性，如果notNextTick设置为true，组件则不会通过NextTick来实例化swiper，也就意味着你可以在第一时间获取到swiper对象，假如你需要刚加载遍使用获取swiper对象来做什么事，那么这个属性一定要是true
        direction: 'vertical',//水平方向移动
        grabCursor: true,//鼠标覆盖Swiper时指针会变成手掌形状，拖动时指针会变成抓手形状
        setWrapperSize: true,//Swiper使用flexbox布局(display: flex)，开启这个设定会在Wrapper上添加等于slides相加的宽或高，在对flexbox布局的支持不是很好的浏览器中可能需要用到。
        autoHeight: true,//自动高度。设置为true时，wrapper和container会随着当前slide的高度而发生变化
        slidesPerView: 1,//设置slider容器能够同时显示的slides数量(carousel模式)。可以设置为数字（可为小数，小数不可loop），或者 'auto'则自动根据slides的宽度来设定数量。loop模式下如果设置为'auto'还需要设置另外一个参数loopedSlides。
        mousewheel: false,//开启鼠标滚轮控制Swiper切换。可设置鼠标选项，默认值false
        mousewheelControl: false,//同上
        height: window.innerHeight, // 高度设置，占满设备高度
        resistanceRatio: 0,//抵抗率。边缘抵抗力的大小比例。值越小抵抗越大越难将slide拖离边缘，0时完全无法拖离。本业务需要
        observeParents: true,//将observe应用于Swiper的父元素。当Swiper的父元素变化时，例如window.resize，Swiper更新

        // 如果自行设计了插件，那么插件的一些配置相关参数，也应该出现在这个对象中，如下debugger
        debugger: true,

        // swiper的各种回调函数也可以出现在这个对象中，和swiper官方一样
        onTransitionStart(swiper){
          console.log(swiper)
      }
    }
  },
  computed: {
    swiper() {
      return this.$refs.mySwiper.swiper
    }
  },
  mounted() {
    // current swiper instance
    // 然后你就可以使用当前上下文内的swiper对象去做你想做的事了
    console.log('this is current swiper instance object', this.swiper)
    this.swiper.slideTo(3, 1000, false)
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
  .fade-enter-active, .fade-leave-active {
    transition: opacity .5s
  }
  .fade-enter, .fade-leave-to{
    opacity: 0
  }
  .swiper-wrapper{
    height: 100px;
  }
  .swiper-slide1{
    background: skyblue;
  }
  .swiper-slide2{
    background: yellowgreen;
  }
  .swiper-slide3{
    background: blanchedalmond;
  }
&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2018-07-11  12:59:47　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人学习理解和总结，很多不足还请指正~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请尊重博客园原创精神，转载或使用图片请注明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　博主：xing.org1^&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出处：http://www.cnblogs.com/padding1015/&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 11 Jul 2018 04:03:00 +0000</pubDate>
<dc:creator>郭菊锋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/padding1015/p/9293762.html</dc:identifier>
</item>
</channel>
</rss>