<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开源API测试工具 Hitchhiker v0.4更新 - 没有做不到，只有想不到 - 布鲁克石</title>
<link>http://www.cnblogs.com/brookshi/p/7829274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brookshi/p/7829274.html</guid>
<description>&lt;p&gt;Hitchhiker 是一款开源的 Restful Api 测试工具，支持Schedule, 数据对比，压力测试，支持上传脚本定制请求，可以轻松部署到本地，和你的team成员一起管理Api。&lt;/p&gt;
&lt;p&gt;详细介绍请看： &lt;a href=&quot;http://www.cnblogs.com/brookshi/p/7440663.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/brookshi/p/7440663.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在线体验： &lt;a href=&quot;http://www.hitchhiker-api.com/&quot; class=&quot;uri&quot;&gt;http://www.hitchhiker-api.com/&lt;/a&gt;， 可以用 &lt;code&gt;try without login&lt;/code&gt; 来免登录使用 （在线演示不支持压力测试和上传js，虚拟机单核的，撑不住）。&lt;/p&gt;
&lt;h2 id=&quot;下面来看看这次的更新&quot;&gt;下面来看看这次的更新：&lt;/h2&gt;

&lt;p&gt;这个算是之前就想实现的，拖了会，不过也是有朋友在github里的issue里提出，正好促使我完成这个功能。&lt;br/&gt;在Pre Request Script里写的脚本会在请求发送前执行，这就使得可以在请求发送前处理一些事情，比如生成一个md5给请求使用，或者读取文件内容，再或者在请求前先请求一个数据，把这个数据做为变量给现在的请求使用，可以做的事有很多，发挥的余地很大。&lt;/p&gt;
&lt;p&gt;现在在脚本里可以使用的方法有：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;require             &lt;span class=&quot;co&quot;&gt;// 这个做js的都懂，有了这个就有无限可能，内置了'lodash', 'request', 'cypro-js'等库，重要的是支持上传js库&lt;/span&gt;
readFile            &lt;span class=&quot;co&quot;&gt;// 读取文件&lt;/span&gt;
readFileByReader    &lt;span class=&quot;co&quot;&gt;// 使用自定义的方法读取文件，比如读取excel&lt;/span&gt;
saveFile            &lt;span class=&quot;co&quot;&gt;// 保存文件&lt;/span&gt;
removeFile          &lt;span class=&quot;co&quot;&gt;// 删除文件&lt;/span&gt;
setEnvVariable      &lt;span class=&quot;co&quot;&gt;// 设置环境变量&lt;/span&gt;
getEnvVariable      &lt;span class=&quot;co&quot;&gt;// 获取环境变量&lt;/span&gt;
removeEnvVariable   &lt;span class=&quot;co&quot;&gt;// 删除环境变量&lt;/span&gt;
environment         &lt;span class=&quot;co&quot;&gt;// 获取当前环境的名字&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然上面的函数同样可以在Test中使用，下面这些只在Test里支持：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;responseBody
responseObj
responseHeaders
responseTime
&lt;span class=&quot;va&quot;&gt;responseCode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;code&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;responseCode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/brookshi/images/master/Hitchhiker/pre_request_script.PNG&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对每个项目来说都有一个&lt;code&gt;data&lt;/code&gt;文件夹和一个&lt;code&gt;lib&lt;/code&gt;文件夹。&lt;br/&gt;&lt;code&gt;data&lt;/code&gt;文件夹用于上传一些测试所需要的数据，可以是任何格式，只要你能读取。&lt;br/&gt;&lt;code&gt;lib&lt;/code&gt;文件夹则用于上传一些js库，需要先压缩成zip格式，上传后会自动解压。&lt;br/&gt;然后在脚本里就可以通过 &lt;code&gt;readFile&lt;/code&gt; 读取 &lt;code&gt;data&lt;/code&gt;文件夹下的文件，或者通过 &lt;code&gt;saveFile&lt;/code&gt;保存文件到这个文件夹。&lt;br/&gt;同样可以在脚本通过&lt;code&gt;require&lt;/code&gt;来引用上传的js库，然后使用它。&lt;/p&gt;
&lt;p&gt;除了项目文件夹外其实还有一个全局的文件夹，这个文件夹可以放一些全局的js库或数据，比如已经内置了一些常用的js库：&lt;code&gt;uuid&lt;/code&gt;，&lt;code&gt;lodash&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;这个算是呼声比较高的，之前只是做到按天来跑schedule，后来收到不少这方面的需求，所以增加了以小时或分钟为单位的schedule。&lt;/p&gt;

&lt;p&gt;这个也算是刚需了，因为很多公司会过滤一些来源不明的邮件，所以 Hitchhiker发出的邮件很可能会收不到，现在增加了一个自定义的邮件接口，Hitchhiker会把数据post到这个接口上，就可以使用公司的邮箱来接发邮箱了。&lt;/p&gt;

&lt;p&gt;有朋友表示想在Jenkins里调用Schedule的Run接口，这是个好方法，所以开放了这个接口出来，方便其他程序调用。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;schedule的顺序执行无效&lt;/li&gt;
&lt;li&gt;sync有时会覆盖用户已经更改的数据&lt;/li&gt;
&lt;li&gt;sync时环境变量编辑对应框里的内容会被清掉&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在的Pre Request Script和文件夹系统在压力测试下是不支持的，这个得想个办法支持起来，另外一个是文档，现在文档有点乱，得整理下。&lt;/p&gt;
&lt;p&gt;Github: &lt;strong&gt;&lt;a href=&quot;https://github.com/brookshi/Hitchhiker&quot; class=&quot;uri&quot;&gt;https://github.com/brookshi/Hitchhiker&lt;/a&gt;&lt;/strong&gt;， 觉得不错的话麻烦 &lt;strong&gt;Star&lt;/strong&gt; 支持下，谢谢。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 23:18:00 +0000</pubDate>
<dc:creator>布鲁克石</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brookshi/p/7829274.html</dc:identifier>
</item>
<item>
<title>逆向知识第八讲,if语句在汇编中表达的方式 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7830266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7830266.html</guid>
<description>&lt;h2&gt;一丶if else的最简单情况还原(无分支情况)&lt;/h2&gt;
&lt;p&gt;高级代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nNumber = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%ud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;nNumber);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        nNumber &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种情况下无分支&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        nNumber &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nNumber;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总共两种情况,我们看下Release中怎么优化的把(注意,优化方式选择O2,速度优先)&lt;/p&gt;
&lt;p&gt;汇编代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171114011550999-1572197174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到我们熟悉的代码了.也就是昨天的三目运算.&lt;/p&gt;
&lt;p&gt;总共三行汇编代码.&lt;/p&gt;
&lt;p&gt;还原套路一样,还是 代入大于0 小于0 还有==0,看看最终结果是什么.&lt;/p&gt;
&lt;p&gt;鉴于昨天还原过代码了,这里这届代入,还原出高级代码.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
argc &amp;gt;&lt;span&gt; 0的情况下
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc &amp;gt; &lt;span&gt;0&lt;/span&gt;) eax = -&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
argc &amp;lt;&lt;span&gt; 0的情况下
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc &amp;lt; &lt;span&gt;0&lt;/span&gt;) eax =-&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
argc ==&lt;span&gt; 0的情况下
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;0&lt;/span&gt;) eax = &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综合三种情况,可以得出具体的条件了.  其中 &amp;gt;&amp;lt;这样写是在高级语言中不能这样写的,&lt;/p&gt;
&lt;p&gt;所以得出的还原代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;0&lt;/span&gt;) eax =&lt;span&gt;0&lt;/span&gt; 
&lt;span&gt;else&lt;/span&gt; eax == -&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 二丶if else 的第二种情况(减少分支)&lt;/h2&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MyCode.cpp : Defines the entry point for the console application.
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nNumber = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%ud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;nNumber);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc ==&lt;span&gt; nNumber)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,nNumber / &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,nNumber / &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nNumber;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应汇编代码:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171114012901734-1302005094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个主要涉及找上下界问题&lt;/p&gt;
&lt;p&gt;1.地址:  1018 101C 分别保存了局部变量的值&lt;/p&gt;
&lt;p&gt;2.地址:  1023  比较了argc和局部变量Var4的值&lt;/p&gt;
&lt;p&gt;3.地址:  1025  jnz跳转,因为1023地址的比较会影响标志位 由此判定, argc和var4比较,jnz(不相等)但因为汇编中是反条件,所以是相等的情况下&lt;/p&gt;
&lt;p&gt;4.因为jnz是一个地址,所以这个地址是一个下界,那么jnz上面的比较代码则是上界,在其内部,我们还原为if语句块(先不用管里面具体干啥)&lt;/p&gt;
&lt;p&gt;还原if语句块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(argc == var4) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,var4 / &lt;span&gt;8&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还原else语句块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt;  printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,var4 / &lt;span&gt;5&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在下方我们发现了相同的汇编代码,也就是把retn放到上面去了,这个主要是为了减少分支.&lt;/p&gt;
&lt;h2&gt;三丶if else 第第三种形式,代码外提的情况&lt;/h2&gt;
&lt;p&gt;代码外提的情况下,主要在优化方式的选择上,我们知道 o2(优化方式是速度优先)  现在我们改成o1(也就是体积优先了)&lt;/p&gt;
&lt;p&gt;这个时候就会出现代码外提.&lt;/p&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MyCode.cpp : Defines the entry point for the console application.
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nNumber = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%ud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;nNumber);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(argc ==&lt;span&gt; nNumber)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nNumber;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切换为o1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171114020132484-1821948469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;protect -&amp;gt; setting即可.&lt;/p&gt;
&lt;p&gt;对应汇编代码:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171114020304265-633167330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先,找if else的时候,先确定上下界&lt;/p&gt;
&lt;p&gt;地址: 101A位置   寻得了 if的上界&lt;/p&gt;
&lt;p&gt;地址: 101E位置  寻得了 if的下界&lt;/p&gt;
&lt;p&gt;注意: 中间划掉了两个指令,这两个指令是流水线优化,平栈的指令.所以没有帮助,划掉&lt;/p&gt;
&lt;p&gt;地址: 1025位置,其指令跳转的地址是一个增量,那么则确定是else的下界&lt;/p&gt;
&lt;p&gt;地址:  1027位置 寻得了else的上界&lt;/p&gt;
&lt;p&gt;其实简单来说,第一个跳转位置,跳转到哪里的一块区域,是一个if的语句块而跳转的位置则是else语句块的上界,其上面固定一个jmp(注意其地址跳转是一个增量)那么跳转的地址是else的下界&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重点代码外提:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到 我们的if语句块中 push了一个 hello,我们的else语句块中,push了一个 word&lt;/p&gt;
&lt;p&gt;那么除了if else 直接调用的printf,这样也是可以的.因为参数是一样的.平栈都是相等的.所以可以提到外面来打印输出.&lt;/p&gt;
&lt;h2&gt; 四丶多分支if elseif  .... else的还原&lt;/h2&gt;
&lt;p&gt;这个其实很简单了.如果是多分支,则寻找上界下界即可.&lt;/p&gt;
&lt;p&gt;因为编译器做的东西很多了.&lt;/p&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Test.cpp : Defines the entry point for the console application.
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
  unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nVar_4 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
  scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;nVar_4);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; argc == 0 ? 0 : -1&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (argc == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argc == 0\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
  {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argc == 1\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
  {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argc == 2\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(argc == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
  {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argc == 3\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
  {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;else\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  
  printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;haha\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nVar_4;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应汇编代码:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201711/1197364-20171114021430890-402604803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这种,直接判断为 if else if else if else这种语句,然后寻找上下界即可.&lt;/p&gt;

</description>
<pubDate>Mon, 13 Nov 2017 18:16:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7830266.html</dc:identifier>
</item>
<item>
<title>最近参与招聘面试的工作总结 - 冲杀</title>
<link>http://www.cnblogs.com/chongsha/p/7829518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chongsha/p/7829518.html</guid>
<description>&lt;p&gt;　　在转java后，就找了份外包到平安科技的java开发工作，由于以前的工作也负责带过几个项目也负责过招聘，所以这边项目组负责人在招聘外包人员的时候，也让我参与协助面试工作。在这两个月面试了大概20人左右，对面试过程中被面试者的表现做下总结，主要有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基础知识不扎实，很多博客文章反复发表的关于java、数据库的开发知识，都回答不上来！&lt;/li&gt;
&lt;li&gt;基础知识面试的问题回答不上来后，问到看过的书籍，回答大数据、框架、其他语言的书籍看过，然后根据看过的书问相关问题，仍然是博客满天飞的，照样回答不上来！&lt;/li&gt;
&lt;li&gt;在面试基础和其他的框架知识点的时候，答不上来的时候，就会回答说我会运用。&lt;/li&gt;
&lt;li&gt;问是否有系统阅读过相关书籍没有，老实回答没看过的很少；有的说看过，然后就根据这些书的内容面试，回答不上来；有回答说没看过书籍，但是经常看博客，于是和1中貌似有点冲突？？？&lt;/li&gt;
&lt;li&gt; 问一些简单的业务的实现方案，回答不起来的居多，如：购物车实现方案（这个问题不是想考察具体知识点，只是想考察观察力和临时发挥能力，毕竟我们面对客户的时候，没做过的业务也很多，不可能因为没做过，就不做了）。提问也是根据其简历上书写的项目让其回答一些简单的业务实现方案。&lt;/li&gt;
&lt;li&gt;根据其简历面试相关问题，被面试者情绪激动，说我们的面试很Low，刁难他，然后项目组负责人就说面试到此为止，结果拿手上的东西扔面试官，情绪激动面目狰狞（就今天）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　&lt;span&gt;&lt;strong&gt;注：我们在面试的时候，均会给被面试者说，可以用你理解的语言来描述回答这些问题，不必局限于专业术语，其实就是在暗示对方，除了一些硬性考察的技能点，很多问题回答不上来，均不影响面试结果，主要考察下态度和知识综合运用（但不影响录用）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　以上几点的详细总结如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;基础知识的问题，不扎实的居多。而这些基础知识，是烂大街的面试题上的或者很多博客入门文章笔写的，如String相关，包装类的知识，数据库的事务等。&lt;/p&gt;
&lt;p&gt;　　其实这个方面的面试除了考察基础知识外，还有就是被面试者的信息接受渠道和信息收集学习能力，但是结果令人沮丧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不是说不能看那些书籍，在基础知识考察的时候，很多常用的基础知识都不能回答清楚，也不能根据提示快速反应过来继续回答的，看这些书真能看懂？我个人的经历是，刚做开发的头两年，《代码大全》和《CLR via C#》我看着很吃力啊，看了几章，我直接就放弃了，然后再等了一年多，工作踩坑和相关积累多了后才能看下去，但是仍然有吃不透的地方。&lt;/p&gt;
&lt;p&gt;　　基础和经验是阅读进阶书籍的基石，如果积累不够，真心不知道看这些书籍是为了什么？追赶技术的潮流？反正我是看不懂他们是为了什么！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第三点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;会用的人很多，但是用的好不好，就这么面几句我们能确定？那也就只能问你对这些知识的理解程度了，毕竟思考过的东西一般在回答的时候是做不了假的。&lt;/p&gt;
&lt;p&gt;　　再打个比方，我家装修请的贴砖工人，和我邻居请的，贴出来效果不一样，邻居家的缝隙对得整齐均匀，我家的就只能勉强忍着自己接受了！如果按照被面试者回答的我会用啊，那我是不是该觉得我自己的审美有问题？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第四点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;回答看过的，面其看过的书籍的一些内容答不起来；回答只看博客的不看书的，结果博客基本上每天都会有的入门系列的问题也几乎回答不上来，这样的，还不如直接回答没看过，好歹有个诚实的态度。&lt;/p&gt;
&lt;p&gt;　　其实是想看个人的学习能力怎样，在面试回答不起来的情况下，就问遇到问题了怎么办，就回答说问度娘copy下，然后再继续，就没有稍微深入研究下的继续了。。。。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第五点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;问的简单业务实现基本上也是其简历所写项目中会有的，或者是我们在网上经常使用频率很高的，如购物车，我们购物不天天用吗？某东和某宝的我们不是购物就要用么？仍然是考察观察力和综合运用能力，还有临场反应能力，只要能条理清晰的回答，就算错了也没什么，谁没有不熟悉的东西？都是反复琢磨修改才能实现出需求的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第六点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这就比较意外了，第一次遇到，就是今天遇到的，这位左腿有残疾，具体原因不明。在看到他的时候，我心里就想，面试的时候，要注意语气，要平和。&lt;/p&gt;
&lt;p&gt;　　面试过程，组长面试他的时候，他反复说给我们看作品，而看作品是在面试他问题回答不上来的时候，他就说看下我写的。我们俩均说先不急，先面了，然后再看。而扔东西打人呢（已经面试了一段时间，回答不行），是在组长问了他SVN用过吗，他回答说用过。然后问分支，回答没用过。&lt;/p&gt;
&lt;p&gt;　　然后我就提问了（其简历最近的项目写的是项目小组负责人），内容如下：在已发布版本有bug的情况下，且修复了bug，但是又有在开发中的功能，且未开发完成，这个时候修复过的Bug该怎么发布？&lt;/p&gt;
&lt;p&gt;　　然后这位就说我们问的问题很low，组长看到他语气激动，就说那面试就到此为止了，然后这位就说叫你们看作品不看，非要问你们自以为是很NB的知识点来刁难我？然后就把他自己带的鼠标垫扔到了组长脸上，面目狰狞的说，没见过我这种人吧，这下见过了吧！&lt;/p&gt;
&lt;p&gt;　　对这位面试的问题主要是集中在我们项目开发中要用到知识点，如spring，数据库的索引，另外还有是他简历上写的，如果要算超标问，估计就是我问的那个版本管理的问题了，但这也是根据他的工作项目经历问的，也不算超标，而且作为一个项目小组负责人，那版本管理应该是需要考虑的问题了，话又说回来，就算回答不上也没什么，不是所有的面试问题都要一定能回答上来的。&lt;/p&gt;


&lt;p&gt;　　个人对很多这样的开发同仁们的建议就是，有空还是多阅读下书籍，多加强下自己，真的花不了多少时间，基础知识仔细过一遍不清楚的，要不了一个月吧？其他的自己慢慢啃，每天也花不了多少时间，稍微花点心思琢磨一下我们常常用到功能的实现。&lt;/p&gt;
&lt;p&gt;　　真心不是面试官为难你们，自己有货，别人能为难你多少？我转java的时候，来这里面试也有答不上来的，就那个spring的事务管理我就回答错了，仍然要了我！&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;个人文笔不怎样，写文章的逻辑思维什么的有点乱，大家将就看下，有什么不足之处还请多指教！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 16:13:00 +0000</pubDate>
<dc:creator>冲杀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chongsha/p/7829518.html</dc:identifier>
</item>
<item>
<title>[深度学习]实现一个博弈型的AI，从五子棋开始（1） - xerwin</title>
<link>http://www.cnblogs.com/erwin/p/7828956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erwin/p/7828956.html</guid>
<description>&lt;p&gt;好久没有写过博客了，多久，大概8年？？？最近重新把写作这事儿捡起来……最近在折腾AI，写个AI相关的给团队的小伙伴们看吧。&lt;/p&gt;

&lt;p&gt;搞了这么多年的机器学习，从分类到聚类，从朴素贝叶斯到SVM，从神经网络到深度学习，各种神秘的项目里用了无数次，但是感觉干的各种事情离我们生活还是太远了。最近AlphaGo Zero的发布，深度学习又火了一把，小伙伴们按捺不住内心的躁动，要搞一个游戏AI，好吧，那就从规则简单、老少皆宜的五子棋开始讲起。&lt;/p&gt;

&lt;p&gt;好了，废话就说这么多，下面进入第一讲，实现一个五子棋。&lt;/p&gt;

&lt;p&gt;小伙伴：此处省去吐槽一万字，说好的讲深度学习，怎么开始扯实现一个五子棋程序了，大哥你不按套路出牌啊……&lt;/p&gt;
&lt;p&gt;我：工欲善其事必先利其器，要实现五子棋的AI，连棋都没有，AI个锤子！&lt;/p&gt;
&lt;p&gt;老罗：什么事？&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;五子棋分为有禁手和无禁手，我们先实现一个普通版本的无禁手版本作为例子，因为这个不影响我们实现一个AI。补充说明一下，无禁手黑棋必胜，经过比赛和各种研究，人们逐渐知道了这个事实就开始想办法来限制黑棋先手优势。于是出现了有禁手规则，规定黑棋不能下三三，四四和长连。但随着比赛的结果的研究的继续进行，发现其实即使是对黑棋有禁手限制，还是不能阻止黑棋开局必胜的事实，像直指开局中花月，山月，云月，溪月，寒星等，斜指开局中的名月，浦月，恒星，峡月，岚月都是黑棋必胜。于是日本人继续提出了交换和换打的思想，到了后来发展成了国际比赛中三手交换和五手二打规则，防止执黑者下出必胜开局或者在第五手下出必胜打。所以结论是，在不正规的比赛规则或者无禁手情况下，黑棋必胜是存在的。&lt;/p&gt;

&lt;p&gt;（1）五子棋下棋逻辑实现&lt;/p&gt;
&lt;p&gt;这里用Python来实现，因为之后的机器学习库也是Python的，方便一点。&lt;/p&gt;
&lt;p&gt;界面和逻辑要分开，解耦合，这个是毋庸置疑的，并且之后还要训练AI，分离这是必须的。所以我们先来实现一个五子棋的逻辑。&lt;/p&gt;
&lt;p&gt;我们先来考虑五子棋是一个15*15的棋盘，棋盘上的每一个交叉点（或格子）上一共会有3种状态：空白、黑棋、白棋，所以先建个文件 consts.py&lt;/p&gt;
&lt;p&gt;做如下定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum

N &lt;/span&gt;= 15

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChessboardState(Enum):
    EMPTY &lt;/span&gt;=&lt;span&gt; 0
    BLACK &lt;/span&gt;= 1&lt;span&gt;
    WHITE &lt;/span&gt;= 2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;棋盘的状态，我们先用一个15*15的二维数组chessMap来表示，建一个类 gobang.py&lt;/p&gt;
&lt;p&gt;currentI、currentJ、currentState 分别表示当前这步着棋的坐标和颜色，再定义一个get和set函数，最基本的框架就出来了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; consts &lt;span&gt;import&lt;/span&gt; *

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoBang(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt; = [[ChessboardState.EMPTY &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(N)] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(N)]
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; =&lt;span&gt; ChessboardState.EMPTY

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessMap(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessboard_state(self, i, j):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_chessboard_state(self, i, j, state):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt;[i][j] =&lt;span&gt; state
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; =&lt;span&gt; i
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; =&lt;span&gt; j
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; = state
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样界面端可以调用get函数来获取各个格子的状态来决定是否绘制棋子，以及绘制什么样的棋子；每次下棋的时候呢，在对应的格子上，通过坐标来设置棋盘Map的状态。&lt;/p&gt;
&lt;p&gt;所以最基本的展示和下棋，上面的逻辑就够了，接下来干什么呢，得考虑每次下棋之后，set了对应格子的状态，是不是需要判断当前有没有获胜。所以还需要再加两个函数来干这个事情，思路就是从当前位置从东、南、西、北、东南、西南、西北、东北8个方向，4根轴，看是否有连续的大于5颗相同颜色的棋子出现。假设我们目前落子在棋盘正中，需要判断的位置如下图所示的米字形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17518/201711/17518-20171113225927046-1792416204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;那代码怎么写呢，最最笨的办法，按照字面意思来翻译咯，比如横轴，先看当前位置左边有多少颗连续同色的，再看右边有多少颗连续同色的，左边加右边，就是当前横轴上的连续数，如果大于5，则胜利。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, current_i, current_j):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        hcount = 1&lt;span&gt;

        temp &lt;/span&gt;=&lt;span&gt; ChessboardState.EMPTY

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-左&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j - 1, -1, -1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往左 from (current_j - 1) to 0&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-右&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j + 1, N):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往右 from (current_j + 1) to N&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; hcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以此类推，再看竖轴、再看左斜、再看又斜，于是，have_five函数变成这样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, current_i, current_j):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        hcount = 1&lt;span&gt;
        vcount &lt;/span&gt;= 1&lt;span&gt;
        lbhcount &lt;/span&gt;= 1&lt;span&gt;
        rbhcount &lt;/span&gt;= 1&lt;span&gt;

        temp &lt;/span&gt;=&lt;span&gt; ChessboardState.EMPTY

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-左&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j - 1, -1, -1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往左 from (current_j - 1) to 0&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-右&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(current_j + 1, N):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;横向往右 from (current_j + 1) to N&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[current_i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            hcount &lt;/span&gt;= hcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;H-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; hcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;V-上&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(current_i - 1, -1, -1):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from (current_i - 1) to 0&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][current_j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            vcount &lt;/span&gt;= vcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;V-下&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(current_i + 1, N):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from (current_i + 1) to N&lt;/span&gt;
            temp = self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][current_j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            vcount &lt;/span&gt;= vcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;V-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; vcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-上&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i - 1, -1, -1), range(current_j - 1, -1, -1&lt;span&gt;)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            lbhcount &lt;/span&gt;= lbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-下&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i + 1, N), range(current_j + 1&lt;span&gt;, N)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            lbhcount &lt;/span&gt;= lbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; lbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;RB-上&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i - 1, -1, -1), range(current_j + 1&lt;span&gt;, N)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            rbhcount &lt;/span&gt;= rbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;RB-下&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; zip(range(current_i + 1, N), range(current_j - 1, -1, -1&lt;span&gt;)):  
            temp &lt;/span&gt;= self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp == ChessboardState.EMPTY &lt;span&gt;or&lt;/span&gt; temp != self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            rbhcount &lt;/span&gt;= rbhcount + 1
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;LB-结果&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; rbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样是不是就写完了，五子棋的逻辑全部实现~ &lt;/p&gt;
&lt;p&gt;NO，别高兴得太早，我想说，我好恶心，上面那个代码，简直丑爆了，再看一眼，重复的写了这么多for，这么多if，这么多重复的代码块，让我先去吐会儿……&lt;/p&gt;
&lt;p&gt;好了，想想办法怎么改，至少分了4根轴，是重复的对不对，然后每根轴分别从正负两个方向去统计，最后加起来，两个方向，也是重复的对不对。&lt;/p&gt;
&lt;p&gt;于是我们能不能只写一个方向的代码，分别调2次，然后4根轴，分别再调4次，2*4=8，一共8行代码搞定试试。&lt;/p&gt;
&lt;p&gt;因为有45°和135°这两根斜轴的存在，所以方向上应该分别从x和y两个轴来控制正负，于是可以这样，先写一个函数，按照方向来统计：&lt;/p&gt;
&lt;p&gt;xdirection=0,ydirection=1       表示从y轴正向数；&lt;/p&gt;
&lt;p&gt;xdirection=0,ydirection=-1     表示从y轴负向数；&lt;/p&gt;
&lt;p&gt;xdirection=1,ydirection=1       表示从45°斜轴正向数；&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;不一一列举了，再加上边界条件的判断，于是有了以下函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; count_on_direction(self, i, j, xdirection, ydirection, color):
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; step &lt;span&gt;in&lt;/span&gt; range(1, 5): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;除当前位置外,朝对应方向再看4步&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; xdirection != 0 &lt;span&gt;and&lt;/span&gt; (j + xdirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; j + xdirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ydirection != 0 &lt;span&gt;and&lt;/span&gt; (i + ydirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; i + ydirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;[i + ydirection * step][j + xdirection * step] ==&lt;span&gt; color:
                count &lt;/span&gt;+= 1
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; count
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是乎，前面的have_five稍微长的好看了一点，可以变成这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, i, j, color):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        hcount = 1&lt;span&gt;
        vcount &lt;/span&gt;= 1&lt;span&gt;
        lbhcount &lt;/span&gt;= 1&lt;span&gt;
        rbhcount &lt;/span&gt;= 1&lt;span&gt;

        hcount &lt;/span&gt;+= self.count_on_direction(i, j, -1&lt;span&gt;, 0, color)
        hcount &lt;/span&gt;+= self.count_on_direction(i, j, 1&lt;span&gt;, 0, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        vcount &lt;/span&gt;+= self.count_on_direction(i, j, 0, -1&lt;span&gt;, color)
        vcount &lt;/span&gt;+= self.count_on_direction(i, j, 0, 1&lt;span&gt;, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; vcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        lbhcount &lt;/span&gt;+= self.count_on_direction(i, j, -1, 1&lt;span&gt;, color)
        lbhcount &lt;/span&gt;+= self.count_on_direction(i, j, 1, -1&lt;span&gt;, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; lbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        rbhcount &lt;/span&gt;+= self.count_on_direction(i, j, -1, -1&lt;span&gt;, color)
        rbhcount &lt;/span&gt;+= self.count_on_direction(i, j, 1, 1&lt;span&gt;, color)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rbhcount &amp;gt;= 5&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还是一大排重复的代码呀，我还是觉得它丑啊，我真的不是处女座，但是这个函数是真丑啊，能不能让它再帅一点，当然可以，4个重复块再收成一个函数，循环调4次，是不是可以，好，就这么干，于是have_five就又漂亮了一点点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, i, j, color):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        directions = [[(-1, 0), (1&lt;span&gt;, 0)], \
                      [(0, &lt;/span&gt;-1), (0, 1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, 1), (1, -1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, -1), (1, 1&lt;span&gt;)]]

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; axis &lt;span&gt;in&lt;/span&gt;&lt;span&gt; directions:
            axis_count &lt;/span&gt;= 1
            &lt;span&gt;for&lt;/span&gt; (xdirection, ydirection) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; axis:
                axis_count &lt;/span&gt;+=&lt;span&gt; self.count_on_direction(i, j, xdirection, ydirection, color)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; axis_count &amp;gt;= 5&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;嗯，感觉好多了，这下判断是否有5颗相同颜色棋子的逻辑也有了，再加一个函数来给界面层返回结果，逻辑部分的代码就差不多了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chess_result(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.have_five(self.&lt;span&gt;__currentI&lt;/span&gt;, self.&lt;span&gt;__currentJ&lt;/span&gt;, self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__currentState&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ChessboardState.EMPTY
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是，五子棋逻辑代码就写完了，完整代码 gobang.py 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; consts &lt;span&gt;import&lt;/span&gt; *

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoBang(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt; = [[ChessboardState.EMPTY &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(N)] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(N)]
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; = -1&lt;span&gt;
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; =&lt;span&gt; ChessboardState.EMPTY

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessMap(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chessboard_state(self, i, j):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;&lt;span&gt;[i][j]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_chessboard_state(self, i, j, state):
        self.&lt;/span&gt;&lt;span&gt;__chessMap&lt;/span&gt;[i][j] =&lt;span&gt; state
        self.&lt;/span&gt;&lt;span&gt;__currentI&lt;/span&gt; =&lt;span&gt; i
        self.&lt;/span&gt;&lt;span&gt;__currentJ&lt;/span&gt; =&lt;span&gt; j
        self.&lt;/span&gt;&lt;span&gt;__currentState&lt;/span&gt; =&lt;span&gt; state

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_chess_result(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.have_five(self.&lt;span&gt;__currentI&lt;/span&gt;, self.&lt;span&gt;__currentJ&lt;/span&gt;, self.&lt;span&gt;__currentState&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__currentState&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ChessboardState.EMPTY

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; count_on_direction(self, i, j, xdirection, ydirection, color):
        count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; step &lt;span&gt;in&lt;/span&gt; range(1, 5): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;除当前位置外,朝对应方向再看4步&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; xdirection != 0 &lt;span&gt;and&lt;/span&gt; (j + xdirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; j + xdirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ydirection != 0 &lt;span&gt;and&lt;/span&gt; (i + ydirection * step &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; i + ydirection * step &amp;gt;=&lt;span&gt; N):
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self.&lt;span&gt;__chessMap&lt;/span&gt;[i + ydirection * step][j + xdirection * step] ==&lt;span&gt; color:
                count &lt;/span&gt;+= 1
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_five(self, i, j, color):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四个方向计数 竖 横 左斜 右斜&lt;/span&gt;
        directions = [[(-1, 0), (1&lt;span&gt;, 0)], \
                      [(0, &lt;/span&gt;-1), (0, 1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, 1), (1, -1&lt;span&gt;)], \
                      [(&lt;/span&gt;-1, -1), (1, 1&lt;span&gt;)]]

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; axis &lt;span&gt;in&lt;/span&gt;&lt;span&gt; directions:
            axis_count &lt;/span&gt;= 1
            &lt;span&gt;for&lt;/span&gt; (xdirection, ydirection) &lt;span&gt;in&lt;/span&gt;&lt;span&gt; axis:
                axis_count &lt;/span&gt;+=&lt;span&gt; self.count_on_direction(i, j, xdirection, ydirection, color)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; axis_count &amp;gt;= 5&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;背景音：大哥，憋了半天，就憋出这么不到60行代码？&lt;/p&gt;
&lt;p&gt;我：代码不再多，实现则灵……&lt;/p&gt;

&lt;p&gt;明天来给它加个render，前端界面就有了，就是一个简单的完整游戏了，至于AI，别急嘛。&lt;/p&gt;
&lt;p&gt;好吧，就这样…&lt;/p&gt;

</description>
<pubDate>Mon, 13 Nov 2017 15:41:00 +0000</pubDate>
<dc:creator>xerwin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erwin/p/7828956.html</dc:identifier>
</item>
<item>
<title>【深度学习笔记】（一）TensorFlow安装及环境搭建 - 狼.wrz</title>
<link>http://www.cnblogs.com/wolfray/p/7828903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wolfray/p/7828903.html</guid>
<description>&lt;p&gt;在学习了一段时间台大李宏毅关于deep learning的课程，以及一些其他机器学习的书之后，终于打算开始动手进行一些实践了。&lt;/p&gt;
&lt;p&gt;感觉保完研之后散养状态下，学习效率太低了，于是便想白天学习，晚上对白天学习的知识做一些总结和记录，如果有不妥的地方，欢迎大家批评指教，共同进步。&lt;/p&gt;
&lt;h2 id=&quot;一深度学习框架的选择&quot;&gt;一、深度学习框架的选择&lt;/h2&gt;
&lt;p&gt;随着深度学习日趋火热，技术的逐渐兴起，各种深度学习框架也层出不穷。&lt;/p&gt;
&lt;p&gt;目前使用普遍的框架有Tensorflow、Caffe、PyTorch、Theano、CNTK等，那么在这么多框架中该如何选择呢？&lt;/p&gt;
&lt;p&gt;笔者作为一个初学者，架不住Tensorflow的名气之大，所以最开始便选择了Tensorflow。当然不仅仅只是因为名气大，Tensorflow作为谷歌主持的开源项目，它的社区热度目前看来是旺盛的，而且现在也最为流行。听说，它是在谷歌总结了DistBelief的经验教训上形成的；它运行高效、可扩展性强，可以运行在手机、普通电脑、计算机群上。&lt;/p&gt;
&lt;p&gt;下面再简单介绍一下其他深度学习框架的特点：&lt;/p&gt;
&lt;p&gt;（1） Caffe：卷积神经网络框架，专注于卷积神经网络和图像处理，因为是基于C++语言，所以执行速度非常的快。&lt;/p&gt;
&lt;p&gt;（2） PyTorch：动态computation graph！！！（笔者学习Tensorflow一段后，便会转学PyTorch试试看）&lt;/p&gt;
&lt;p&gt;（3） Theano：因其定义复杂模型很容易，在研究中比较流行。&lt;/p&gt;
&lt;p&gt;（4） CNTK：微软开发的，微软称其在语音和图像识别方面比其他框架更有优势。不过代码只支持C++.&lt;/p&gt;
&lt;p&gt;Tensorflow的一些特性就不再说了，网络上相关资料也有很多。&lt;/p&gt;
&lt;p&gt;下面就介绍一下Tensorflow的安装，笔者的安装顺序是首先安装Anaconda、然后安装Tensorflow、再安装Pycharm。&lt;/p&gt;
&lt;h2 id=&quot;二安装anaconda&quot;&gt;二、安装Anaconda&lt;/h2&gt;
&lt;p&gt;安装环境：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110000041876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;机器配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然笔者用的是mac，自带了Python，但是还是先安装了Anaconda（&lt;a href=&quot;https://www.anaconda.com&quot; target=&quot;_blank&quot;&gt;点击进入官网&lt;/a&gt;）。因为它集成了很多Python的第三方库，而且可以方便的管理不同版本的Python，在不同版本的Python之间切换。而且Anaconda是一个科学计算环境，在电脑上安装完Anaconda之后，除了相当于安装了Python，也安装好了一些常用的库。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110000649978?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;安装好Anaconda&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者安装的是Python 2.7版的Anaconda，在安装好Anaconda之后，就已经安装好了Python和一些常用的库了。此外，还自动安装了Spyder。&lt;/p&gt;
&lt;p&gt;Spyder是Python一个简单的集成开发环境，和其他的Python开发环境相比，它最大的优点就是模仿MATLAB的“工作空间”的功能，可以很方便地观察和修改数组的值。&lt;/p&gt;
&lt;p&gt;在终端中输入Spyder就可以打开它了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110125532906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110125541910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是笔者更喜欢使用Pycharm作为开发环境&lt;/p&gt;
&lt;h2 id=&quot;三建立激活安装tensorflow&quot;&gt;三、建立、激活、安装Tensorflow&lt;/h2&gt;
&lt;p&gt;打开终端，在上面输入：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs fix&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;conda create -n tensorflow python&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;2.7&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110000845300?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;建立Tensorflow运行环境&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后等执行完毕之后，再执行：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt; activate tensorflow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此就激活了运行环境。&lt;/p&gt;
&lt;p&gt;然后再执行&lt;code&gt;pip install tensorflow&lt;/code&gt;以进行Tensorflow的安装。&lt;/p&gt;
&lt;p&gt;然后再执行以下Hello Tensorflow代码测试Tensorflow是否安装成&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs livecodeserver&quot;&gt;import tensorflow &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; tf
hello = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'Hello Tensorflow!'&lt;/span&gt;)
sess = tf.Session()
print(sess.run(hello))

&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt; = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
b = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;)
printf(sess.run(&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt;+b))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果正常的话会提示：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs erlang-repl&quot;&gt;    &lt;span class=&quot;hljs-variable&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;Tensorflow&lt;/span&gt;&lt;span class=&quot;hljs-exclamation_mark&quot;&gt;!&lt;/span&gt;
    &lt;span class=&quot;hljs-number&quot;&gt;42&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四pycharm-ide&quot;&gt;四、PyCharm IDE&lt;/h2&gt;
&lt;p&gt;一直使用终端开发的话，实在是太过难用了。笔者选择了PyCharm作为开发环境，&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot; target=&quot;_blank&quot;&gt;官网链接&lt;/a&gt;。这里笔者用的是社区版（free）。&lt;/p&gt;
&lt;p&gt;（1）首先新建一个Pycharm的工程&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110125912459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;Pycharm新建工程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是做Tensorflow的开发，所以这里我们只需要选择图中所示的interpreter即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~/anaconda2/envs/tensorflow/bin/python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就把Tensorflow环境包括了进来，超级方便。&lt;/p&gt;
&lt;p&gt;如果平时开发，想用一些轻量级的环境，就选择其他Python解释器就可以了。&lt;/p&gt;
&lt;p&gt;（2）运行一个demo进行测试&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs livecodeserver&quot;&gt;import tensorflow &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; tf
hello = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'Hello, Tensorflow!'&lt;/span&gt;)
sess = tf.Session()
print(sess.run(hello))

&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt; = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;66&lt;/span&gt;)
b = tf.&lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;88&lt;/span&gt;)
print(sess.run(&lt;span class=&quot;hljs-operator&quot;&gt;a&lt;/span&gt; + b))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20171110130742447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3oyMjg4MTkxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现以下提示，就说明成功了，可以开始接下来的学习了~&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot; hljs erlang-repl&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;Hello&lt;/span&gt;, &lt;span class=&quot;hljs-variable&quot;&gt;Tensorflow&lt;/span&gt;&lt;span class=&quot;hljs-exclamation_mark&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;154&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;至此，我们便在机器上安装好了Tensorflow以及其开发环境。&lt;/p&gt;
&lt;p&gt;总的来说，只需要以下几步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装Anaconda&lt;/li&gt;
&lt;li&gt;通过conda建立Tensorflow运行环境&lt;/li&gt;
&lt;li&gt;激活Tensorflow运行环境&lt;/li&gt;
&lt;li&gt;安装Pycharm IDE&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 13 Nov 2017 15:38:00 +0000</pubDate>
<dc:creator>狼.wrz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wolfray/p/7828903.html</dc:identifier>
</item>
<item>
<title>python爬虫(一)_爬虫原理和数据抓取 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/7828889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/7828889.html</guid>
<description>&lt;blockquote readability=&quot;3.8461538461538&quot;&gt;
&lt;p&gt;本篇将开始介绍Python原理，更多内容请参考：&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/7828889.html&quot;&gt;Python学习指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要做爬虫&quot;&gt;为什么要做爬虫&lt;/h3&gt;
&lt;p&gt;著名的革命家、思想家、政治家、战略家、社会改革的主要领导人物马云曾经在2015年提到由IT转到DT，何谓DT，DT即数据技术，由数据在推倒人们的衣食住行，当今时代是一个&lt;code&gt;大数据时代&lt;/code&gt;，数据从何而来？&lt;/p&gt;
&lt;h3 id=&quot;爬虫是什么&quot;&gt;爬虫是什么？&lt;/h3&gt;
&lt;p&gt;百度百科：&lt;a href=&quot;http://baike.baidu.com/link?url=3SeA6RcStie6o9T5XGMTBoHK-BGiO_0IqtnI4IkVjDBsoKrJL0aotjA4cjqbx8wF&quot;&gt;网络爬虫&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Python爬虫，我们需要学习的有：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Python基础语法学习(基础知识)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;HTML页面的内容抓取(数据抓取)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;HTML页面的数据提取(数据清洗)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Scrapy框架以及scrapy-redis分布式策略(第三方框架)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;爬虫(Spider)、反爬虫(Anti-Spider)、反反爬虫(Anti-Anti-Spider)之间的斗争。。。。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;通用爬虫和聚焦爬虫&quot;&gt;通用爬虫和聚焦爬虫&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;网络爬虫可分为&lt;strong&gt;通用爬虫&lt;/strong&gt;和&lt;strong&gt;聚焦爬虫&lt;/strong&gt;两种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;通用搜索引擎(Search Enging)工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用网络爬虫&lt;/strong&gt; 从互联网中搜集网页，采集信息，这些网页信息用于为搜索引擎建立索引从而提供支持，它决定着整个引擎系统的内容是否丰富，信息是否及时，因此其性能的优劣直接影响着搜索引擎的效果。&lt;/p&gt;
&lt;h4 id=&quot;第一步抓取网页&quot;&gt;第一步：抓取网页&lt;/h4&gt;
&lt;p&gt;搜索引擎网络爬虫的基本工作流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先选取一部分的种子URL，将这些URL放入待抓取URL队列；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;取出待抓取URL，解析DNS得到主机的IP，并将URL对应的网页下载下来，存储进已下载网页库中，并且将这些URL放进已抓取URL队列。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;分析已抓取URL队列中的URL，分析其中的其它URL，并且将URL放入待抓取URL队列，从而进入下一个循环。。。&lt;br/&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com/image/python%E7%88%AC%E8%99%AB_%E9%80%9A%E7%94%A8%E7%88%AC%E8%99%AB%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;通用爬虫流程&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;搜索引擎如何获取一个新网站的URL：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新网站向搜索引擎主动提交网址：(百度：&lt;a href=&quot;http://zhanzhang.baidu.com/linksubmit/url&quot; class=&quot;uri&quot;&gt;http://zhanzhang.baidu.com/linksubmit/url&lt;/a&gt;)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在其他网站上设置一个新网站链接(尽可能处于搜索引擎爬虫爬取范围)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;搜索引擎和DNS解析服务商(如DNSPod等)合作，新网站域名将被迅速抓取&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是搜索引擎蜘蛛的爬行是被输入了一定的规则的，它需要遵从一些命令或文件的内容，如标注为&lt;code&gt;nofollow&lt;/code&gt;的链接，或者是Robots协议。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6529968454259&quot;&gt;
&lt;p&gt;Robots协议(也叫爬虫协议、机器人协议等)，全称是“网络爬虫排除标准”(Robots Exclusion Protocol)，网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;淘宝网：&lt;a href=&quot;https://www.taobao.com/robots.txt&quot; class=&quot;uri&quot;&gt;https://www.taobao.com/robots.txt&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;腾讯网：&lt;a href=&quot;http://www.qq.com/robots.txt&quot; class=&quot;uri&quot;&gt;http://www.qq.com/robots.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;第二步数据存储&quot;&gt;第二步：数据存储&lt;/h4&gt;
&lt;p&gt;搜索引擎通过爬虫爬取到网页，将数据存入原始页面数据库。其中的页面数据与用户浏览器得到的HTML是完全一样的。&lt;/p&gt;
&lt;p&gt;搜索引擎蜘蛛在抓取页面时，也做一定的重复内容检测，一旦遇到访问权重很低的网站上有大量抄袭、采集或者复制的内容，很可能就不再爬行。&lt;/p&gt;
&lt;h4 id=&quot;第三步预处理&quot;&gt;第三步：预处理&lt;/h4&gt;
&lt;p&gt;搜索引擎将爬虫抓取回来的页面，进行各种步骤的预处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提取文字&lt;/li&gt;
&lt;li&gt;中文分词&lt;/li&gt;
&lt;li&gt;消除噪音(比如版权申明文字、导航条、广告等...)&lt;/li&gt;
&lt;li&gt;索引处理&lt;/li&gt;
&lt;li&gt;链接关系计算&lt;/li&gt;
&lt;li&gt;特殊文件处理&lt;/li&gt;
&lt;li&gt;....&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了HTML文件外，搜索引擎还能抓取和索引以文字为基础的多种文件类型，如PDF、WORD、WPS、PPT、TXT等。我们在搜索结果中也经常会看到这种文件类型。&lt;/p&gt;
&lt;p&gt;但搜索引擎还不能处理图片、视频、Flash这类非文字内容，也不能执行脚本和程序。&lt;/p&gt;
&lt;h4 id=&quot;第四步提供检索服务网站排名&quot;&gt;第四步：提供检索服务，网站排名&lt;/h4&gt;
&lt;p&gt;搜索引擎在对信息进行组织和处理后，为用户提供关键字检索服务，将用户检索相关的信息展示给用户。&lt;/p&gt;
&lt;p&gt;同时会根据页面的PageRank值（链接的访问量排名）来进行网站排名，这样Rank值高的网站在搜索结果中会排名较前，当然也可以直接使用 Money 购买搜索引擎网站排名，简单粗暴。&lt;br/&gt;&lt;img src=&quot;http://oyl9rg5dr.bkt.clouddn.com/image/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png&quot; alt=&quot;搜索引擎工作原理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;但是，这些通用搜索引擎也存在着一定的局限性&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通用搜索引擎所返回的结果都是网页，而大多情况下，网页里90%的内容对用户来说都是无用的。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不同领域、不同背景的用户往往具有不同的检索目的和需求，搜索引擎无法提供针对具体某个用户的搜索结果。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;万维网数据形式的丰富和网络技术的不断发展，图片、数据库、音频、视频多媒体等不同数据大量出现，通用搜索引擎对这些文件无能为力，不能很好地发现和获取。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;通用搜索引擎大多提供基于关键字的检索，难以支持根据语义信息提出的查询，无法准确理解用户的具体需求。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;针对这些情况，聚焦爬虫技术得以广泛使用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;聚焦爬虫&quot;&gt;聚焦爬虫&lt;/h3&gt;
&lt;p&gt;聚焦爬虫，是&quot;面向特定主题需求&quot;的一种网络爬虫程序，它与通用搜索引擎爬虫的区别在于： &lt;em&gt;聚焦爬虫在实施网页抓取时会对内容进行处理筛选，尽量保证只抓取与需求相关的网页信息。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 15:34:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/7828889.html</dc:identifier>
</item>
<item>
<title>android 人脸检测你一定会遇到的坑 - 喝着啤酒敲代码</title>
<link>http://www.cnblogs.com/cq-jiang/p/7823462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cq-jiang/p/7823462.html</guid>
<description>&lt;p&gt;      笔者今年做了一个和人脸有关的android产品，主要是获取摄像头返回的预览数据流，判断该数据流是否包含了人脸，有人脸时显示摄像头预览框，无人脸时摄像头预览框隐藏，看上去这个功能并不复杂，其实在开发过程中，遇到的问题也不多，全部都处理了，在正式推出前，这个产品在公司内部也测试了几个月，也没发现bug，但最近实施人员，在客户公司做实施时，反馈回来各种问题，这些问题有部分是程序bug,也有一部分是和硬件有关，因为测试环境有限，笔者无法对各种型号，各个厂家的硬件进行测试，这篇文章主要是记录，摄像头给我们带来的一些坑，分享给涉及到人脸开发的朋友，让大家少走弯路。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;android有原生的api做人脸检测，通过android.media.FaceDetector来检测bitmap是否包含人脸，android.media.FaceDetector.Face来检测人脸位置信息，我们需要在activity中实现Carema.PreviewCallBack接口，该接口有一个&lt;span&gt;onPreviewFrame方法，这个方法返回摄像头实时图像的数据流，由于这个方法返回的数据流时nv21格式，我们需要转换bitmap才能进行人脸检测，转换过程如下：byte[] --&amp;gt; YuvImage --&amp;gt; ByteArrayOutputStream --&amp;gt; byte[] --&amp;gt;  bitmap ，具体转换的代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
Camera.Size size =&lt;span&gt; mtCamera.getParameters().getPreviewSize();
YuvImage yuvImage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; YuvImage(mData, ImageFormat.NV21, size.width, size.height, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
yuvImage.compressToJpeg(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Rect(0, 0, size.width, size.height), 100&lt;span&gt;, mBitmapOutput);
options.inPreferredConfig &lt;/span&gt;=&lt;span&gt; Bitmap.Config.RGB_565;
bitmap &lt;/span&gt;= BitmapFactory.decodeByteArray(mBitmapOutput.toByteArray(), 0&lt;span&gt;, mBitmapOutput.toByteArray().length, options);
mBitmapOutput.reset();
bitmap &lt;/span&gt;= Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), mMatrix, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的转换，我们已经得到了人脸检测的bitmap,此时只需要进行人脸检测就ok了，代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
detector = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FaceDetector(source.getWidth(),source.getHeight(), maxFaceNum);
Face[] faces &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Face[maxFaceNum];&lt;br/&gt;detector.findFaces(source, faces);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码基本上就哪么多，由于受到硬件的影响，上面的代码有很多地雷。&lt;/p&gt;

&lt;p&gt;　　产品上线后，主要问题有，人站在摄像头面前，app无法识别人脸，软件运行性能也会下降，出现严重卡顿等问题，当前我比较郁闷，明明在测试环境都运行几个月了，都没有出现这些问题，正式实施的时候，问题不断，通过近两个月的整理，主要问题有以下几个。&lt;/p&gt;
&lt;h2&gt;　　2.1   无法识别人脸&lt;/h2&gt;
&lt;h3&gt;　　1）：相机角度问题&lt;/h3&gt;
&lt;p&gt;　　由于我在测试的时候，摄像头图像是垂直的，没有任何问题，但正式使用时，摄像头来自不同商家，导致摄像头图像是水平的了，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171112231108231-854272111.png&quot; alt=&quot;&quot; width=&quot;263&quot; height=&quot;336&quot;/&gt;                               &lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171112231129325-271491698.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图像角度都不对了，当然无法识别人脸了，此时我们需要得到摄像头的默认旋转的角度，再作处理，特别声明：&lt;span&gt;&lt;strong&gt;setDisplayOrientation() 这个方法是逆时针旋转&lt;/strong&gt;&lt;/span&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCameraDisplayOrientation (Activity activity, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; cameraId, android.hardware.Camera camera) {
        android.hardware.Camera.CameraInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; android.hardware.Camera.CameraInfo();
        android.hardware.Camera.getCameraInfo (cameraId , info);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rotation =&lt;span&gt; activity.getWindowManager ().getDefaultDisplay ().getRotation ();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; degrees = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (rotation) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_0:
                degrees &lt;/span&gt;= 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_90:
                degrees &lt;/span&gt;= 90&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_180:
                degrees &lt;/span&gt;= 180&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Surface.ROTATION_270:
                degrees &lt;/span&gt;= 270&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (info.facing ==&lt;span&gt; Camera.CameraInfo.CAMERA_FACING_FRONT) {
            result &lt;/span&gt;= (info.orientation + degrees) % 360&lt;span&gt;;
            result &lt;/span&gt;= (360 - result) % 360;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; compensate the mirror&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; back-facing&lt;/span&gt;
            result = ( info.orientation - degrees + 360) % 360&lt;span&gt;;
        }
        mOrienta &lt;/span&gt;=&lt;span&gt; result;//该值有其它用途
        camera.setDisplayOrientation (result);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　2）：相机设置旋转后，预览图片和相机返回实时流角度问题&lt;/h3&gt;
&lt;p&gt;　　这个坑太恶心了，当我把相机角度旋转后，把app打包发一个给同事，结果同事告诉我，还是不行，还好在公司借到一个锐士达1080p的摄像头，然后我把&lt;strong&gt;onPreviewFrame返回的流画到imageView&lt;/strong&gt;，&lt;strong&gt;发现返回的图像，和预览的图像，根本不一样，我勒个去，虽然预览图像旋转了，我们还需要对onPreviewFrame返回的流进行处理&lt;/strong&gt;，这个坑也让我比较无语，害我找了好久。虽然说解决的代码只有简短的几句，但找出原因过程只有自己能体会，然后我使用Matrix来旋转onPreviewFrame返回的流，关于Matrix，完全是参考&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/flash129/article/details/8234599&quot; target=&quot;_blank&quot;&gt;android Matrix详细&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，这篇文章写得非常好，然而&lt;strong&gt;&lt;span&gt;matrix的postRotate是顺时针旋转，和camera.setDisplayOrientation()刚好相反&lt;/span&gt;，&lt;/strong&gt;我勒个去，这两个难兄难弟太不让人省心，一个顺时针，一个逆时针，超级无语,修改后的代码如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113214240718-1518249012.png&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
//mOrienta来源于setCameraDisplayOrientation
&lt;/pre&gt;
&lt;pre&gt;
mMatrix = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Matrix();
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (mOrienta){
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;  90&lt;span&gt;:
                        mMatrix.postRotate(&lt;/span&gt;270&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 270&lt;span&gt;:
                        mMatrix.postRotate(&lt;/span&gt;90&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                        mMatrix.postRotate(mOrienta);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　2.2   720p摄像头和1080p摄像头涉及到的问题&lt;/h2&gt;
&lt;h3&gt;　　1）：获取摄像头支持预览尺寸遇到的问题&lt;/h3&gt;
&lt;p&gt;　　　　　初始化相机时，我们需要设置摄像头支持的预览尺寸，如果不是相机支持的尺寸，会出现异常，根据项目需要，本地环境我直接指定一个下标，然后硬件变化后，这个值也跟着变了，如下图：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113214853406-1298168028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处根据实际情况获取，可以计算每一个尺寸的面积，通过一个基础面积获取适应的预览尺寸。具体代码就不帖了，只需要清楚有这一个坑就ok了。&lt;/p&gt;
&lt;h3&gt;　　2）：获取预览侦宽高大小带来的问题&lt;/h3&gt;
&lt;p&gt;　　如果程序的lock，和线程问题没处理好，性能问题显而易见。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113215339999-877905015.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　如果只是简单的识别人脸，我们可以通过压缩图片的方法来解决这个问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
BitmapFactory.Options options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapFactory.Options();
options.inSampleSize &lt;/span&gt;=2&lt;span&gt;;
options.inPreferredConfig &lt;/span&gt;=&lt;span&gt; Bitmap.Config.RGB_565;
bitmap &lt;/span&gt;= BitmapFactory.decodeByteArray(mBitmapOutput.toByteArray(), 0, mBitmapOutput.toByteArray().length, options);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3)：摄像头返回的流频率过快，导致人脸识别处理速度根不上的解决办法&lt;/h3&gt;
&lt;p&gt;　　最初软件运行的时候，运行一段时间，app直接崩溃了，最后发现是，onPreviewFrame返回的流太快，网上说可以在启动相机时，设置流的频率,常见设置的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Camera.Parameters parameters =&lt;span&gt; mCamera.getParameters();
parameters.setPreviewFrameRate(&lt;/span&gt;3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置每秒3帧,没有效果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而这样设置后，完全没有用，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1128579/201711/1128579-20171113220550827-928002324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理这个问题并不是很复杂，只是判断一个两次处理流的时候，大于300毫秒（具体时间，根据需求变动）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onPreviewFrame(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data, Camera camera) {
        Logger.i(TAG&lt;/span&gt;+&quot;收到相机回调：onpreviewframe()&quot;+&lt;span&gt;index);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;data.length&amp;gt;0&amp;amp;&amp;amp;System.currentTimeMillis()-time&amp;gt;200&lt;span&gt;){
            time&lt;/span&gt;=&lt;span&gt;System.currentTimeMillis();
            mFaceHandle.post(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FaceThread(data,camera,(++&lt;span&gt;index)));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　2.3 刷脸的人员走开后，屏幕仍然显示和人脸相关信息 &lt;/h2&gt;
&lt;p&gt; 　　通过以上描述我们知道，相机预览图尺寸过大，导致刷脸人员走开几秒钟内，android设备屏，仍然显示和人脸有关的信息，因为onPreviewFrame频率较快，而处理人脸的时间过长，导致人脸对列越来越大，所以人走开后，屏才会显示相关信息，这里需要控制，onPreviewFrame处理人脸的频率大于，以及提升人脸识别的时间.&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;a href=&quot;https://github.com/jlq023/democamera&quot; target=&quot;_blank&quot;&gt; 完整demo 下载地址:https://github.com/jlq023/democamera&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 13 Nov 2017 15:26:00 +0000</pubDate>
<dc:creator>喝着啤酒敲代码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cq-jiang/p/7823462.html</dc:identifier>
</item>
<item>
<title>作为初级管理者必会的方法论和分析法 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/7764665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/7764665.html</guid>
<description>&lt;p&gt;　　最近都不怎么写些接地气的东西，因为拿捏不准哪些地方会涉及到信息安全。另外，如果我决定哪个地方的代码要自己写，那么可以肯定凌晨3点多，我还在公司。作为一个其实技术还不怎么精通的初级管理者，目前更大局的视角来看一些东西要比编程这些务实的东西更急迫。&lt;/p&gt;
&lt;p&gt;      我现在的领导是清华才子。经常发现人家看事情确实明白。虽然我当年高考的分数是可以考上北大医学部的，当然只是那年比较特殊，非典时期，北京的学校比较不吃香。但是从看事情的维度方面，确实看到了自己的差距。觉得凭自己的实际能力，考不上清华北大是应该的。现在得到高人指点，我家小鲜肉麻省理工还是有希望的。&lt;/p&gt;
&lt;p&gt;　　5w1h&lt;/p&gt;
&lt;p&gt;　　5w1h分析法也叫六何分析法，是一种思考方法。是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。&lt;/p&gt;
&lt;p&gt;　　四象限理论&lt;/p&gt;
&lt;p&gt;　　四象限法则是时间管理理论的一个重要观念是应有重点地把主要的精力和时间集中地放在处理那些重要但不紧急的工作上，这样可以做到未雨绸缪，防患于未然。在人们的日常工作中，很多时候往往有机会去很好地计划和完成一件事。但常常却又没有及时地去做，随着时间的推移，造成工作质量的下降。因此，应把主要的精力有重点地放在重要但不紧急这个“象限”的事务上是必要的。要把精力主要放在重要但不紧急的事务处理上，需要很好地安排时间。一个好的方法是建立预约。建立了预约，自己的时间才不会被别人所占据，从而有效地开展工作。&lt;/p&gt;
&lt;p&gt;     通俗一点说吧，四象限就是：象限1：紧急重要、象限2：重要不紧急、象限3：紧急不重要、象限4：不重要不紧急。如果在总体事情比较多的情况下，总是将象限3的事情优先于象限2，则事情会越来越多，重要的事情反而没做。&lt;/p&gt;
&lt;p&gt;　　漏斗分析法&lt;/p&gt;
&lt;p&gt;　　漏斗分析通俗的说：我要将事情按照一个维度统一的记录下来，再看转化率。比如说：我记录日志，比如一个请求其实需要经过多个部门的处理。在请求的每一步，我都需要记录下来请求、响应。由于网络等原因。每一步得到结果的响应率都不是百分之百。那么最后得到实际结果的响应率究竟是多少。&lt;/p&gt;
&lt;p&gt;      STAR法则&lt;/p&gt;
&lt;p&gt;      这是一个面试官常使用的工具。&lt;/p&gt;
&lt;p&gt;　　STAR法则,即为Situation Task Action Result的缩写，具体含义是:&lt;/p&gt;
&lt;p&gt;　　Situation: 事情是在什么情况下发生&lt;/p&gt;
&lt;p&gt;　　Task: 你是如何明确你的任务的&lt;/p&gt;
&lt;p&gt;　　Action: 针对这样的情况分析，你采用了什么行动方式&lt;/p&gt;
&lt;p&gt;　　Result: 结果怎样，在这样的情况下你学习到了什么&lt;/p&gt;
&lt;p&gt;　　简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。&lt;/p&gt;

&lt;p&gt;跑题时间：&lt;/p&gt;
&lt;p&gt;　　11月的天，阴冷。男神说：“开空调呗”。就像10点多下班我宁愿坐地铁不打车一样，我不喜欢开空调。不管是加氟的还是无氟的。就像不含铅的爆米花一样，只不过是用其他大家不太怎么听说的毒性更大的东西来代替。而保护环境节约资源这些，对我来说，就好像是在减缓发生的一些物理化学反应。比如呼吸生成二氧化氮、比如水烧开沸腾。其实在我们看不到的维度，别人在等着水更快的烧开。只是物理化学变化的完成，也是人类使命的完成，意味着人类的消亡。所以我自己不愿意做一些事情，但我不反对别人做一些事情。也许他们才是推动这个世界发展的动力，推动了下一个文明的到来。或者是长久的寂静的到来，就像是篝火化成了灰。&lt;/p&gt;
&lt;p&gt;　　年初的时候有一次我在面试，面试官让我写代码，我是第一次有人当场让我写代码。听着隔壁面试间的女孩子在那里侃着那些虚无的东西，我竟然一边写代码一边朝自己笑笑。我明明可以像其他女孩子一样，做些自己擅长的事情，却要让自己一次次的受煎熬，然后再走出来。&lt;/p&gt;
&lt;p&gt;      自从来了这边，见不到我家微微一笑很倾城的男神老大之后，越来越不会笑了。在公司天天面对一群管我叫姐的小鲜肉，生无可恋。最难忍受的是还有走路不长眼睛，见了我叫阿姨的。我只能怒视她们，姐姐们，你们长得比我还显老好不好。实在觉得活不下去了，就发给微信给我家微微一笑很倾城的男神老大，看到老大的消息，立刻觉得可以活下去了。&lt;/p&gt;
&lt;p&gt;      但是自从我家男神要换个离我近的工作，一想到天天可以回家睡，一睁眼左边一个帅哥右边一个帅哥，脸上又可以孩子般天真的笑了。但是在家睡觉我会经常失眠。失眠的原因是：我睡着睡着一睁眼看到我家小鲜肉，越看越觉得这小家伙太可爱了，实在是太可爱了。想着想着就激动的睡不着了。&lt;/p&gt;


</description>
<pubDate>Mon, 13 Nov 2017 15:25:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/7764665.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET Identity与授权 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/7828326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/7828326.html</guid>
<description>&lt;p&gt;　　一个完整的ASP.NET的请求中会存在身份验证（Authentication）阶段以及授权（Authorization）阶段，英文单词Authentication和Authorization非常相似，所以很多时候会混淆这两个概念。身份验证（Authentication）的目的是知道“你”是谁，而授权（Authorization）则是当“你”访问一个资源时是否符合访问条件，符合就将访问权限授权给你进行访问，否则拒绝访问。&lt;/p&gt;
&lt;p&gt;　　本文将从以下几点介绍ASP.NET MVC如何使用Identity完成资源访问的限制：&lt;br/&gt;　　● 资源访问的限制方式&lt;br/&gt;　　● ASP.NET中的访问限制&lt;br/&gt;　　● ASP.NET MVC中基的访问限制&lt;br/&gt;　　● ASP.NET MVC中的用户信息&lt;br/&gt;　　● ASP.NET Identity用户身份信息填充&lt;br/&gt;　　● ASP.NET MVC访问限制的实现&lt;br/&gt;　　● ASP.NET MVC基于用户声明的访问限制及自定义限制&lt;/p&gt;
&lt;h2&gt;资源访问的限制方式&lt;/h2&gt;
&lt;p&gt;　　什么是资源？在Web中通过URI(Uniform Resource Identifier，统一资源标识符)来对HTML文档、图片、图像等内容定位，反过来说在Web中HTML文档、图片、图像等内容就是资源，而资源访问的限制就是对在用户通过URI访问Web资源时，判断该用户是否有权限访问该资源，如果有则继续访问，否则拒绝访问。&lt;br/&gt;　　资源访问有以下几种限制方式：&lt;br/&gt;　　● 匿名访问限制：所有人都可以访问资源。&lt;br/&gt;　　● 根据用户名访问限制：指定特定的用户，让其能够或者不能访问资源。&lt;br/&gt;　　● 根据用户角色访问限制：指定特定角色，让拥有该角色的用户能够访问资源。&lt;br/&gt;　　● 根据用户声明(Claim)访问限制：指定特定的声明(Claim)，让身份信息中含有该声明的用户能够访问资源。&lt;br/&gt;　　● 使用其它用户信息进行访问限制：根据用户身份的其它信息来判断用户是否能够访问资源。&lt;br/&gt;　　从上面几点可以看出资源访问的限制或者说授权，实际上就是通过用户信息来判断用户是否有访问资源的权限，而常用的信息是用户名、用户角色以及用户声明。&lt;br/&gt;　　注：对于授权来说，它处于身份验证的后续阶段，所以可以认为在授权阶段时已经存在用户信息，所以可以直接使用用户信息来完成访问限制。&lt;/p&gt;
&lt;h2&gt;ASP.NET中的访问限制&lt;/h2&gt;
&lt;p&gt;　　ASP.NET中通过HTTPModule的方式实现了FileAuthorizationModule以及UrlAuthorizationModule来对用户访问文件以及其它资源进行权限控制，其中UrlAuthorizationModule可以通过在web.config中添加如下配置来通过用户名或者用户角色限制访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113201937390-2141855427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在ASP.NET中可以通过Forms验证+UrlAuthorizationModule来实现用户身份验证和访问授权，更多信息可参考文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/user-based-authorization-cs&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/user-based-authorization-cs&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC中的访问限制&lt;/h2&gt;
&lt;p&gt;　　Forms验证+UrlAuthorizationModule的方式是用于基于ASP.NET Web Form的应用程序，而ASP.NET MVC虽然也可以使用Forms验证，但是ASP.NET MVC的授权方式是不一样的，它是通过过滤器的方式实现，下面代码为之前文章中用于限制后台管理页面需要登录的代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203241937-125088632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过在Controller上使用了一个名为Authorize的特性来实现的，这个特性的定义如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203330390-1281206943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　它用于当用户访问Controller或Action方法时可以通过用户信息对其访问进行限制。&lt;/p&gt;
&lt;p&gt;　　在Authorize特性的定义中可以看到名为Roles以及Users的属性，其作用就是设置可以访问该资源的用户或者角色：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203414781-783221026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用方法如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113203446406-1413577341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC中的用户信息&lt;/h2&gt;
&lt;p&gt;　　通过前面的介绍可以知道用户的授权是根据用户信息来的，无论是基于角色的、用户的、声明的甚至是自定义的，都需要依赖用户信息进行权限判断，那么ASP.NET MVC中到底包含什么用户信息？&lt;br/&gt;　　1. HttpContextBase与IPrincipal：&lt;br/&gt;　　首先可以知道的是在ASP.NET中有一个最核心的HTTP上下文对象HttpContextBase，它保存了整个Http请求到响应过程的所有相关数据，其定义如下:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210021874-1935222769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中就包含了一个名为User的IPrincipal类型：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210105281-946742438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该类型中的Identity属性就包含了用户的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210134093-1598482920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从接口中可以看到它仅仅包含了用户名、身份验证反射以及是否验证通过三个属性。&lt;/p&gt;
&lt;p&gt;　　注：IPrincipal的实现有多种而本例中使用的是ClaimPrincipal。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210742374-389874688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. ClaimsIdentity与AuthenticationTicket：&lt;br/&gt;　　通过前面的文章分析得知Identity基于Cookie的身份验证方式实际上是对一个AuthenticationTicket对象序列化加密、反序列化解密的过程，而这个AuthenticationTicket就携带了所有用户的信息，在AuthenticationTicket的定义中可以看到两个重要的对象，其中AuthenticationProperties保存了身份验证的会话信息，如过期时间、是否允许刷新等。而另一个ClaimsIdentity属性就是以声明(Claim)的方式实现的用户信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210835952-1012054741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ClaimsIdentity的部分定义如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113210907859-1432140731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中除了实现IIdentity接口的属性外，还有一个重要的属性是Claims，它用于以声明的方式来保存用户信息，那么Identity是如何完成用户数据填充的？&lt;/p&gt;
&lt;h2&gt;ASP.NET Identity用户身份信息填充&lt;/h2&gt;
&lt;p&gt;　　用户的获取填充主要是在&lt;span&gt;用户登录&lt;/span&gt;(注册用户后会自动登录)的时候完成的，因为在后续的请求中Identity仅需通过解析加密后的用户信息字符串即可获得用户信息(注：会存在重新生成刷新该信息的情况，如身份信息的滑动过期等)。&lt;/p&gt;
&lt;p&gt;　　通过前面文章的分析知道了在Identity中用户的登录是通过SignInManager对象完成的以下是用户登录的代码及注册代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211047562-1935415140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以下是注册代码，实际上是创建完成用户后执行了登录操作：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211112421-1074508610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：通过对源码分析，SignInManager.PasswordSignInAsync方法实际上最后也是调用SignInAsync方法完成的登录。&lt;/p&gt;
&lt;p&gt;　　那么SignInAsync到底做了什么？&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211314312-1832097033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从代码中可以看到，该方法调用了一个名为CreateUserIdentityAsync的方法，根据其方法名、参数以及返回值类型来看就已经可以确定该方法就是通过用户对象生成上面提到的用于以声明的方式保存用户信息的方法。从它的实现中可以看出它实际上是通过UserManager生成的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211350874-191777440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而UserManager又是通过ClaimsIdentityFactory完成的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211638249-1702392986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ClaimsIdentityFactory.CreateAsync方法的实现：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211713968-981992321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：实际上身份信息的刷新也是通过UserManager完成的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113230104671-1890811288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方法的实现仍然是UserManager的CreateIdentityAsync方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113230142843-1343788056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从实现中可以看出如果UserManager支持角色、声明等功能，它会从数据库中加载对应的信息以声明(Claim)的形式保存在ClaimsIdentity对象中。&lt;br/&gt;　　在数据库中添加以下数据(为了演示功能直接在数据库中添加角色、声明信息并与用户数据进行关联，如果要开发此功能可基于UserManager完成)：&lt;br/&gt;　　角色信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211845452-877358865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用户声明(Claim)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211917109-495552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　角色与用户信息关联：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113211947421-871904732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：由于此处Identity EF与MySQL，对象与表映射存在问题，所以多了一些ID列，暂时不管这个问题，关于Identity与MySQL用法可以参考这篇文档：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/aspnet-identity-using-mysql-storage-with-an-entityframework-mysql-provider&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/aspnet-identity-using-mysql-storage-with-an-entityframework-mysql-provider&lt;/a&gt;&lt;br/&gt;　　运行程序并登录后，在用户信息(ClaimsIdentity)中可找到添加的角色和声明信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212047781-1103509072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC访问限制的实现&lt;/h2&gt;
&lt;p&gt;　　上面介绍了用户信息的填充，那么访问的限制实际上就是对用户信息比较而已，下面是Authorize特性的核心方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212223109-742291940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中核心的三个判断为：&lt;br/&gt;　　● user.Identity.IsAuthenticated：必须通过身份验证。&lt;br/&gt;　　● (this._usersSplit.Length &amp;lt;= 0 || this._usersSplit.Contains(user.Identity.Name, StringComparer.OrdinalIgnoreCase))：特性没有指定用户或者当前用户存在于指定的用户列表中。&lt;br/&gt;　　● (this._rolesSplit.Length &amp;lt;= 0 || this._rolesSplit.Any(new Func&amp;lt;string, bool&amp;gt;(user.IsInRole))：特性没有指定角色或者当前用户拥有指定的角色。&lt;br/&gt;　　以上三个条件必须全部符合才能够访问。&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC基于用户声明的访问限制及自定义访问限制&lt;/h2&gt;
&lt;p&gt;　　ASP.NET MVC中虽然用户信息是基于声明的方式保存的，但是却没有实际的实现，所以需要自己动手实现一个(注：也可以参考ASP.NET Core中的实现&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/security/authorization/claims&lt;/a&gt;)。&lt;br/&gt;　　实现一个自定义的授权特性(注：之前分析过HttpContext中的User是一个IPrincipal类型，实际上MVC使用的是与ClaimsIdentity对应的ClaimsPrincipal)代码如下，该过滤器只是在原有的授权方式基础上添加了声明的检查：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212346281-1814198935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用方式如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212407702-1411132765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　登录后访问上面action得到下面结果，验证通过：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201711/640251-20171113212446577-913717187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：需要注意的是以上介绍的授权方式，无论是通过角色、用户名还是声明，它都需要以硬编码的形式写在代码中，换句话说就是在开发时必须确定该功能或者Controller/Action访问需求。但是一些时候也会出现访问需求不确定的情况，访问权限的配置会在运行时通过配置文件或者数据库来动态配置，这样的话自定义的授权过滤器就需要依赖一些业务组件来实现自定义的授权流程。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本章介绍了授权与身份验证的关系以及在ASP.NET中的实现，并详细介绍了ASP.NET MVC中的Identity是如何使用身份验证数据来完成授权的。常见的授权方式一般是基于用户名、角色以及声明，但是它们使用的场景边界是不那么明确的，就是说用什么都行实际情况需要根据需求来看，一般权限控制较简单的使用基于角色的授权即可。但无论基于什么来对用户授权，这些信息都属于用户信息，所以在拓展用户的授权时首先要考虑的是用户的特征信息，其次是用户身份验证时如何获取填充这些信息，最后才是考虑如何使用这些信息来进行授权。&lt;/p&gt;
&lt;p&gt;参考：　　&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wce3kxhd.aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/wce3kxhd.aspx&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://stackoverflow.com/questions/21645323/what-is-the-claims-in-asp-net-identity&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/21645323/what-is-the-claims-in-asp-net-identity&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.codeproject.com/Articles/98950/ASP-NET-authentication-and-authorization&quot; target=&quot;_blank&quot;&gt;https://www.codeproject.com/Articles/98950/ASP-NET-authentication-and-authorization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET Identity与授权&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7828326.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/7828326.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Nov 2017 15:09:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/7828326.html</dc:identifier>
</item>
<item>
<title>css伪类的说明以及使用(css事件) - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/7670959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/7670959.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;CSS伪类的使用(css事件)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;转载请注明源地址:&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: css伪类的说明以及使用(css事件)&quot; href=&quot;http://www.cnblogs.com/funnyzpc/p/7670959.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/funnyzpc/p/7670959.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　之前有开发开发App的时候，有同事问我那个列表的条目按下去背景会变成淡黄色的效果是怎么做的，然后我若无其事的说了句：用CSS事件啊。。。╮(￣▽￣)╭，然后同事不解的回到座位后在代码中狂找...🤔，嗯~最终效果实现与否就不得而知啦~；最近稍仔细的翻翻相关文章才知道类似于JavaScript中的事件的东西叫做“伪类”，是CSS中特有的一种东西ヽ(^o^)丿，大多时候很少很少用到，这个叫做“&lt;span&gt;&lt;strong&gt;伪类&lt;/strong&gt;&lt;/span&gt;”的东东一般只有html的标签用到，很简单，。。。但，因为简单，所以要实现稍微复杂的功能还是依靠JavaScript哈~，嗯哼，先放张图把，到底什么是“伪类”，看过之后瞬间秒懂~ (｡♥‿♥｡)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113202242577-1926503806.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;584&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看完，我来先小小地总结下，CSS伪类在每一代CSS标准中都会扩充一些，由于暂时用得最多的大致有以下五个(只是对于我来说哈~（￣。。￣）)：&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;dataintable&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;伪类&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;伪类描述&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:active&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;点按，向被激活的元素添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:focus&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;焦点输入，向拥有键盘输入焦点的元素添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:hover&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;当鼠标悬浮在元素上方时，向元素添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:link&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;链接未访问，向未被访问的链接添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;:visited&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;链接已访问，向已被访问的链接添加样式。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　要使用这些伪类的话，样式该怎么写呢，。。。以下举个🌰例子，比如说&lt;span&gt;&lt;strong&gt;:focus&lt;/strong&gt;&lt;/span&gt; --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; 这是一个输入框：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;999&quot;&lt;/span&gt;&lt;span&gt; nameo&lt;/span&gt;&lt;span&gt;=&quot;textInput&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;这是对输入框定义的默认CSS：
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;.body .input{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    width:100px;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    height:40px;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    border-radius: 13px;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;这是对输入框“获取焦点”后应用的CSS:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;.body .input:focus{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    background-color:mediumpurple;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;真实的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（默认样式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215515937-43987149.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;126&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（获取焦点后的样式）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img alt=&quot;&quot;/&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215538437-57992333.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;124&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看完是不是超级简单，有木有~；这几需要说明几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;&lt;strong&gt;A&amp;gt;&lt;/strong&gt;以上可以只对输入框定义一个获取焦点后的(:focus)样式，就可以看出效果啦，遂，在开发的时候如果不是特别复杂的样式效果，切勿轻易动用JavaScript来控制dom的样式　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;B&amp;gt;&lt;/strong&gt;大多浏览器对于直接调试带有伪类的样式较为麻烦，比如Chrome的不同版本可以不会显示dom的伪类样式,建议大家先写成普通样式调试成功后再改回dom的伪类样式,这样较为nice&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;C&amp;gt;&lt;/strong&gt;dom(标签)的所有样式只能定义在样式文件或单独的&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;区域中，不可定义在dom中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些懂了吧~。。。&amp;lt;(￣︶￣)&amp;gt;；以上只是定义了所列举的部分伪类的样式效果，下面把剩余的几种伪类效果也展示下，方便读者参考👇。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==&amp;gt;　&lt;span&gt;&lt;strong&gt;　:active&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　(点按之前）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　    　&lt;img alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215326796-571552935.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;77&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（点按之后）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215426421-1011349755.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;123&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==》　&lt;span&gt;&lt;strong&gt;&lt;span&gt;　:hover&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（鼠标位于dom之上前）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215635843-2001950246.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;40&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（鼠标未于dom之上后）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215705843-563940130.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;56&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==》　&lt;span&gt;&lt;strong&gt;&lt;span&gt;　:link&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（链接未访问）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215757312-2017142436.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;44&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　==》&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　:visited&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　(链接未访问前)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215855062-1613750432.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;49&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　(链接已访问)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1161789/201711/1161789-20171113215927843-1958472188.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　OK👌，既已明白，我也该睡觉觉~\(≧▽≦)/~啦啦啦，现在是：2017-11-13 22:10:15&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;梦游中：&lt;/span&gt;啊~哈~~，明天又是工作日，真美好的一天😊 ( &lt;span&gt;明天迟到，看我怎么收拾你😡&lt;/span&gt; )&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 Nov 2017 14:19:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/7670959.html</dc:identifier>
</item>
</channel>
</rss>