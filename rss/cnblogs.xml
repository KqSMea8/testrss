<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python web（Django）连接Sql server - 朱~</title>
<link>http://www.cnblogs.com/zhuPython/p/9056543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuPython/p/9056543.html</guid>
<description>[unable to retrieve full-text content]（开开心心每一天~ 虫瘾师） Python Web（Django） 与SQL SERVRE的连接————Come QQ群：607021567（里面有很多开源代码和资料，并且python的游戏也有） （一）、SQL SERVER的基本介绍（简单）————SQL 是用于访问和处理数据库的标准的计算机语言</description>
<pubDate>Fri, 18 May 2018 07:49:00 +0000</pubDate>
<dc:creator>朱~</dc:creator>
<dc:identifier>http://www.cnblogs.com/zhuPython/p/9056543.html</dc:identifier>
</item>
<item>
<title>golang自定义路由控制实现（二）-流式注册接口以及支持RESTFUL - 请叫我红领巾!</title>
<link>http://www.cnblogs.com/xxzhuang/p/9056358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxzhuang/p/9056358.html</guid>
<description>&lt;p&gt;    先简单回顾一下在上一篇的文章中，上一篇我主要是结合了数组和Map完成路由映射，数组的大小为8，下标为0的代表Get方法，以此类推，而数组的值则是Map，键为URL，值则是我们编写对应的接口。但是上篇的设计仍存在着不足，主要是无法很好的面向RESTFUL设计，同时，我希望还能够希望一个功能，类似于SpringMVC中，可以将&lt;code&gt;@Controller&lt;/code&gt;作用于类上，代表着&lt;strong&gt;该类下所有接口的一个起始路径&lt;/strong&gt;。因此，本篇文章主要是讲解如何实现以上提到的两个功能。&lt;strong&gt;即面向RESTFUL以及流式注册接口。&lt;/strong&gt;下面先看效果代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    o := odserver.Default()
    o.Start(&quot;/main&quot;).
    Target(&quot;/test/&quot;).Get(HelloServer).Post(HelloServer).Delete(HelloServer).And().
        Target(&quot;/test2&quot;).Get(HelloServer2)
    o.Start(&quot;/{test}/main/&quot;).Target(&quot;/number/{number}&quot;).
        Get(HelloServer3).Post(HelloServer4)

    http.ListenAndServe(&quot;:8080&quot;,o)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;func HelloServer3(c *odserver.Context) {

    fmt.Fprint(c.Rw, c.Params)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    首先第一点的是，我们要如何将客户端访问的URL，准确的映射到含有占位符的接口。原理其实也不难，这里也主要简化了一下：即利用正则表达式，将接口路径中的参数转换成&lt;code&gt;\w*&lt;/code&gt;。以&lt;code&gt;/{test}/main/number/{number}&lt;/code&gt;为例子，转换结果为&lt;code&gt;/\w*/main/number/\w*&lt;/code&gt;，&lt;strong&gt;通过正则表达式匹配则可以匹配到相对应的接口函数。&lt;/strong&gt;&lt;br/&gt;    第二点，如何实现流式注册接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;o.Start(&quot;/main&quot;).
Target(&quot;/test/&quot;).Get(HelloServer).Post(HelloServer).Delete(HelloServer).And().
Target(&quot;/test2&quot;).Get(HelloServer2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    这里的设计主要是考虑到RESTFUL的知识，即&lt;strong&gt;URL描述的是资源，而Http Method描述的才是动作，所以大多数情况下，按照RESTFUL的规范是会出现URL相同但是Http Method不同。&lt;/strong&gt;因此，这里的设计比起上一篇中的设计要做进一步重构：&lt;strong&gt;先匹配路径，再匹配方法&lt;/strong&gt;（上一篇的设计是先匹配方法，再匹配路径）&lt;br/&gt;    第一步我们自然想到要设计一个map，键是URL，但是值该如何设计，而值的主要目标是匹配方法，以及拥有其他属性能够进行额外的功能开发，即下面的&lt;code&gt;HandlerObject&lt;/code&gt;。我的设计如下，详情看注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type FuncObject struct {
    params []string
//对应编写的接口，IHandlerFunc只是个空接口
    f      IHandlerFunc
    exist  bool
    *httpConfig
}
//方法函数映射，0代表GET方法下的接口
type methodFuncs []FuncObject
/**
    关键struct，代表每个实体的请求
 */
type HandlerObject struct {
    *Router
    //对应占位符的参数
    params    []string
    //对该请求的http配置
    *httpConfig
    //请求路径 即start+target的路径
    path        string
    startPath   string
//方法函数映射
    methodFuncs methodFuncs
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    上面&lt;code&gt;HandlerObject&lt;/code&gt;出现了对&lt;code&gt;Router&lt;/code&gt;的引用，&lt;code&gt;Router&lt;/code&gt;相当于路由控制中心，他持有&lt;code&gt;map[string]*HandlerObject&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func NewRouter() *Router {
    return &amp;amp;Router{
        handler:   make(map[string]*HandlerObject),
        regexpMap: make(map[*regexp.Regexp]*HandlerObject),
    }
}

type Router struct {
    handler
    regexpMap
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    这里有个问题，&lt;code&gt;regexpMap&lt;/code&gt;作用是什么，相信仔细看的读者内心应该有答案了，没错，这里对应的是匹配正则路径的Map。但是还有一个问题是，&lt;strong&gt;我怎么知道当前请求的路径，是精准匹配还是模糊匹配。&lt;/strong&gt;这里就要利用到Go中的协程和通道了，设置一个无缓冲的通道，对精准匹配和模糊匹配分别开启一条协程，哪个协程先匹配到，则往通道中传送对应的值，这样就能保证到无论是精准匹配和模糊匹配，我们最终都会且仅获取到一个值。同时对通道设置超时处理，如若超时，则认为是404情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (r *Router) doUrlMapping(url string, method int) (*HandlerObject,bool) {
    ch := make(chan *HandlerObject)
    //精准匹配
    go func() {
        if ho, ok := r.handler[url]; ok {
            ch &amp;lt;- ho
        }
    }()
    //正则匹配
    go func() {
        for k, v := range r.regexpMap {
            if k.MatchString(url) {
                pathArray := strings.Split(url, &quot;/&quot;)[1:]
                regexpArray := strings.Split(k.String(), &quot;/&quot;)[1:]
                if len(pathArray) == len(regexpArray) {
                  //设置参数
                    paramsNum := 0
                    for i := 0; i &amp;lt; len(pathArray); i++ {
                        if matcher.IsPattern(regexpArray[i]) {
                            v.params[paramsNum] = pathArray[i]
                            paramsNum++
                        }
                    }
                    v.params = v.params[:paramsNum]
                }
                ch &amp;lt;- v
            }
        }
    }()
    select {
    case ho := &amp;lt;-ch:
        {
            return ho,true
        }
    case &amp;lt;-time.After(2e6):
        {
            return &amp;amp;HandlerObject{},false
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册接口的代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func (r *Router) Start(url string) *HandlerObject {
    return NewHandlerObject(r, AddSlash(url))
}

func (ho *HandlerObject) And() *HandlerObject {
    if ho.Router == nil || ho.startPath == &quot;&quot; {
        panic(&quot;ho.Router is nil or startPath is unknown，maybe u should use Start()&quot;)
    }
    return NewHandlerObject(ho.Router, ho.startPath)
}

func (ho *HandlerObject) Target(url string) *HandlerObject {
    //设置完整的路径
    if ho.startPath == &quot;/&quot; {
        ho.path = ho.startPath + DeleteSlash(url)
    } else {
        if strings.HasSuffix(ho.startPath, &quot;/&quot;) {
            url = DeleteSlash(url)
        } else {
            url = AddSlash(url)
        }
        ho.path = ho.startPath + url
    }
    //尝试将url转换成正则表达式，如果没有占位符，则转换不成功
    pattern, ok := matcher.ToPattern(ho.path)
    if ok {
        ho.path = pattern
        re, err := regexp.Compile(pattern)
        if err != nil {
            panic(&quot;error compile pattern:&quot; + pattern)
        }
        ho.Router.regexpMap[re] = ho
    } else {
        ho.handler[ho.path] = ho
    }
    return ho
}
func AddSlash(s string) string {
    if !strings.HasPrefix(s, &quot;/&quot;) {
        s = &quot;/&quot; + s
    }
    return s
}

func DeleteSlash(s string) string {
    if strings.HasPrefix(s, &quot;/&quot;) {
        array := strings.SplitN(s, &quot;/&quot;, 2)
        s = array[1]
    }
    return s
}

func (ho *HandlerObject) Get(f IHandlerFunc) *HandlerObject {
    if ho.methodFuncs[GET].exist {
        panic(&quot;GetFunc has existed&quot;)
    }

    ho.methodFuncs[GET] = NewFuncObject(f)
    return ho
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    最后还有一个struct需要介绍，即&lt;code&gt;Context&lt;/code&gt;，在Tomcat的设计中，是不直接使用Java提供的request和response，这里也参考来对应的设计，Context下包含了两个属性，&lt;code&gt;Request&lt;/code&gt;和&lt;code&gt;responseWriter&lt;/code&gt;，但这里两个属性是我自己建立，里面封装了go团队提供的&lt;code&gt;Request&lt;/code&gt;和&lt;code&gt;responseWriter&lt;/code&gt;，这样子才方便扩展我们想要的功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Context struct {
    Req    Request
    Rw     responseWriter
    //对应restful的参数值
    Params []string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    路漫漫其修远兮，客官点个赞呗&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 07:19:00 +0000</pubDate>
<dc:creator>请叫我红领巾!</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxzhuang/p/9056358.html</dc:identifier>
</item>
<item>
<title>PiggyMetrics windows 部署 - kenchen20050821</title>
<link>http://www.cnblogs.com/ken-hust/p/9055812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ken-hust/p/9055812.html</guid>
<description>&lt;p&gt;PiggyMetrics 是springcloud的demo，其特性就不细说了，主要描述在win10下部署的坑。&lt;/p&gt;
&lt;p&gt;官网是：https://github.com/sqshq/PiggyMetrics&lt;/p&gt;
&lt;p&gt;官网的部署过程很简单，如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162625/201805/162625-20180518131817399-1119311125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于windows用户且linux和docker小白而言还是比较困难的。&lt;/p&gt;
&lt;p&gt;1.首先安装&lt;a href=&quot;https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe&quot; target=&quot;_blank&quot;&gt;docker for Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　坑1：docker在win平台下还有一个版本是dockertoolbox，这两个不兼容，当时以为toolbox装了个virtualbox，感觉有个界面比较好管理，但实际上这两个不兼容。采用的虚拟技术不一样，docker for windows 采用Hyper-V，toolbox采用virtualbox，docker的阿里镜像里面推荐win10以上采用docker for windows。所以不要同时装两个，如果不慎装了两个，卸载彻底后，把C:\Users\XXX\.docker删掉，&lt;span&gt;用户环境变量关于docker的都删掉&lt;span&gt;，之后再重新安装docker for windows。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　坑2：安装完后一定要设置内存，默认内存是2G，但项目要求是4G，这个看漏眼了就会导致硬盘疯狂读写，程序假死的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162625/201805/162625-20180518132743477-1452757587.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162625/201805/162625-20180518132813810-351713069.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;393&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2.这是设置环境变量，export是linux设置环境变量的语法。&lt;/p&gt;
&lt;p&gt;　　坑1：但是我在windows里面设置了貌似没有效果，只能把docker-compose.yml里面涉及到的环境变量都使用固定值，如“root”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162625/201805/162625-20180518133200945-964582594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.打包，一般要注意的就是设置maven的镜像和仓库地址，没什么了。&lt;/p&gt;
&lt;p&gt;4.【先别忙着执行，看坑2】利用docker-compose来把项目编排到docker容器里面，这涉及到docker image的生成，container的加载，时间比较长。&lt;/p&gt;
&lt;p&gt;　　坑1：docker需要更换回国内进行，参考这个https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/162625/201805/162625-20180518133804104-1146197579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　坑2：\PiggyMetrics\mongodb\init.sh格式需要改为unix，使用notepad++修改。这个坑最隐秘，因为尽管不修改，image还是可以生成成功的，只是加载container的时候报错“no such file...”。&lt;/p&gt;
&lt;p&gt;　　坑3：里面项目比较多，端口有可能被占用，要么调整win下的进程，要么修改项目中的端口。每个项目中的dockerfile中有个EXPOSE XXXX端口号，还有docker-compose.dev.yml和docker-compose.yml文件的端口定义。&lt;/p&gt;
&lt;p&gt;　　坑4：如果不慎已经生成了image和加载了container，更改完坑2后，需要重新在\PiggyMetrics\mongodb\目录下build image如下，注意最后的&lt;span&gt;&quot; .&quot;&lt;/span&gt;，生成成功后重新“docker-compose -f docker-compose.yml -f docker-compose.dev.yml up”即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build -t sqshq/piggymetrics-mongodb:latest .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.最后根据官网的链接点击测试，一般都没问题了，再有别的坑只能自己去踩一下了。&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 06:24:00 +0000</pubDate>
<dc:creator>kenchen20050821</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ken-hust/p/9055812.html</dc:identifier>
</item>
<item>
<title>.Net Core微服务系列--理论篇 - RstarYan</title>
<link>http://www.cnblogs.com/rstar/p/9055993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rstar/p/9055993.html</guid>
<description>&lt;p&gt;微服务最早由Martin Fowler与James Lewis于2014年共同提出来的，但是微服务也不是一个全新的概念，它是由一系列在实践中获得成功并流行起来的概念中总结出来的一种模式，一种概念。而这一系列的概念大体上有这些:&lt;br/&gt;&lt;strong&gt;领域驱动设计(DDD),持续交付，按需虚拟化，基础设施自动化，小型的自治团队，大型集群系统。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;领域驱动设计ddd&quot;&gt;领域驱动设计(DDD)&lt;/h3&gt;
&lt;p&gt;DDD中我们关心了三个概念：领域建模，限界上下文，职责。这三个概念能很好的帮我们在微服务中按照业务分割出足够小且高内聚低耦合的服务， 这也是Evans 在《领域驱动设计》一书中的比喻 “细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜”，我们每个服务都应该是有自己的职责或者可以说要满足单一原则，要尽量保证内聚，并且要定义好与外部的交互。&lt;/p&gt;
&lt;h3 id=&quot;持续交付&quot;&gt;持续交付&lt;/h3&gt;
&lt;p&gt;以往也包括现在的很多公司，生产环境的发布几乎总是痛苦的事情，凌晨或者周末加班加点进行发布而且很可能一出问题就是全部回滚到上一个版本。但是现在， 因为实行了持续交付，团队在一天内都可能在生产环境发布很多次。&lt;br/&gt;持续集成，持续交付已经是现代软件很重要的一个特性，对软件产业产生了深远的影响，当然这一特性也跟微服务紧密的结合在一起了。 当然单体架构在持续交付方面的问题太显著了，但是微服务在这一方面确实优势明显。 微服务系统设计开始就是拆分为独立自治的一些服务的集合，每次的持续交付我们只需要关注某个或者某些微服务的交付，从而在很大程度上减少了持续交付的工作量和风险。当然这就要保证各个服务之间的低耦合，在一个服务更改的时候不会带消费方带来影响。&lt;/p&gt;
&lt;h3 id=&quot;按需虚拟化&quot;&gt;按需虚拟化&lt;/h3&gt;
&lt;p&gt;系统在高并发的时候总是会遇到性能瓶颈，但是瓶颈一般不是存在在整个系统而是在某几个特有的模块比如说订单，也不是说会一直存在瓶颈比如双11。所以按需进行扩展是必要解决的问题。而对于微服务，我们借助虚拟化平台，可以单独的为某个服务按需创造机器并调整大小。&lt;/p&gt;
&lt;h3 id=&quot;基础设施自动化&quot;&gt;基础设施自动化&lt;/h3&gt;
&lt;p&gt;这个其实跟按需虚拟化可以一起的，当我们需要水平扩展的时候，不可能为每次创造的机器进行一番部署，所以我们需要基础设施的自动化来帮组我们完成方便快捷的扩展&lt;/p&gt;
&lt;h3 id=&quot;小型的自治团队&quot;&gt;小型的自治团队&lt;/h3&gt;
&lt;p&gt;自治团队，可以对应到自治服务。一个独立的服务，可以语言自由，架构自由，集成自由，部署自由，我们只需要保证团队做出来的东西满足一定的条件就可以完全作为一个独立的单元来进行开发管理维护。&lt;/p&gt;

&lt;p&gt;微服务就是一些协同工作的小而自治的服务。&lt;/p&gt;
&lt;h3 id=&quot;小专注于一件事&quot;&gt;小，专注于一件事&lt;/h3&gt;
&lt;p&gt;这个就是我们常常说的职责单一。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在我的职业生涯中，不乏会接手其他人的项目，每每总是会抱怨这个项目代码量太多了，业务逻辑太分散，常常有牵一发而动全身的时候。而微服务则是把职责单一原则应用到服务上，根据业务来划分限界上下文，进而划分出不同的服务，这样每个服务都只用关注到某个限界上下文中，从而很大程度上避免了代码库过大而难以维护的问题。&lt;/p&gt;
&lt;h3 id=&quot;自治&quot;&gt;自治&lt;/h3&gt;
&lt;p&gt;这是微服务的优点，也一定程度上导致了微服务的复杂性。 自治，代表每个服务是独立个体，所以我们可以自由的进行技术选型，服务之间通信用语言无关的api进行网络通信。也是因为自治，所以我们要保证每个服务能够独立的升级部署而不会对消费者产生影响，避免一个问题出现导致整个系统功能不可用的情况。&lt;/p&gt;
&lt;h3 id=&quot;协同&quot;&gt;协同&lt;/h3&gt;
&lt;p&gt;虽然我们是一系列不同的个体，但是我们还是一个整体，所以就需要我们各个服务之间有交互有通信，并且需要用某些技术来解决分布式带来的新的问题。&lt;/p&gt;

&lt;p&gt;微服务是分布式的，所以具有分布式的所有好处，而且明确定义了界限上下文，也带来了更多的好处。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;技术异构&lt;/li&gt;
&lt;li&gt;弹性好（处理服务不可用和功能降级）&lt;/li&gt;
&lt;li&gt;扩展方便，成本低&lt;/li&gt;
&lt;li&gt;简化部署&lt;/li&gt;
&lt;li&gt;与组织结构相匹配&lt;/li&gt;
&lt;li&gt;可组合 易于重用完整的功能&lt;/li&gt;
&lt;li&gt;对技术替代性的优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然微服务不是银弹，不是整个软件行业的终极解决方案，总是会存在不可忽视的缺点。同样大部分的缺点也是分布式带来的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能（内存处理转化为远程调用）&lt;/li&gt;
&lt;li&gt;可靠性 （远程调用失败的可能性）&lt;/li&gt;
&lt;li&gt;最终一致性&lt;/li&gt;
&lt;li&gt;操作的复杂性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为还没有在实际中使用过微服务，但是对分布式还是有不少实践，所以结合一些书籍，写下了这篇文章做了一下总结。&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 06:18:00 +0000</pubDate>
<dc:creator>RstarYan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rstar/p/9055993.html</dc:identifier>
</item>
<item>
<title>深入出不来nodejs源码-编译启动(1) - 书生小龙</title>
<link>http://www.cnblogs.com/QH-Jimmy/p/9055637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QH-Jimmy/p/9055637.html</guid>
<description>&lt;p&gt;　　整整弄了两天，踩了无数的坑，各种奇怪的error，最后终于编译成功了。&lt;/p&gt;
&lt;p&gt;　　网上的教程基本上都过时了，或者是版本不对，都会报一些奇怪的错误，这里总结一下目前可行的流程。&lt;/p&gt;
&lt;p&gt;　　node版本：v10.1.0。&lt;/p&gt;
&lt;p&gt;　　首先需要一些准备工作：&lt;/p&gt;
&lt;p&gt;1、Visual Studio 2017 传送门：https://www.visualstudio.com/zh-hans/downloads/&lt;/p&gt;
&lt;p&gt;2、python2.7 传送门：https://www.python.org/downloads/release/python-2715/&lt;/p&gt;
&lt;p&gt;3、NASM 传送门：https://www.nasm.us/pub/nasm/releasebuilds/2.13.03/win64/&lt;/p&gt;
&lt;p&gt;4、Git bash 传送门：https://git-scm.com/downloads&lt;/p&gt;
&lt;p&gt;　　全部安装完，然后记得给python与NASM添加环境变量。&lt;/p&gt;

&lt;p&gt;　　接下来就是把node的源码给down下来，传送门：https://nodejs.org/en/download/current/&lt;/p&gt;
&lt;p&gt;　　这个LTS还是current自己选，反正点那个下载源码的按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518121716775-438265136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　把东西弄下来解压到一个地方，然后双击文件夹里面的vcbuild.bat：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518121828899-862177714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以在这个批处理文件打个断点，可以发现输出信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518121911630-236305902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　脚本的开始都是在检测是否有预装对应的工具，然后调用其余的批处理文件进行编译。&lt;/p&gt;
&lt;p&gt;　　这个时间会比较长，可以先去吃个饭。你会发现文件夹在逐渐变大，最后大概有个20G……&lt;/p&gt;

&lt;p&gt;　　编译完成后，文件夹会有一个node.sln，在VS2017中选择文件-打开-项目/解决方案，双击这个文件，会把node项目给引到IDE中去。&lt;/p&gt;
&lt;p&gt;　　这时如果直接点击开始调试，可能会出现以下问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518122501766-1664824736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是因为项目的默认启动项设成了目录的第一个，右键解决方案，点击设置自动项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518122644393-710305293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择单启动项目，把那个cares改成node：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518122851391-1565486308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样就可以开始启动node项目，时间非常的长……&lt;/p&gt;
&lt;p&gt;　　这时候再次点击开始调试，可能又会出现以下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518123249568-153131747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　弹窗其实是个幌子，真正的错误是控制台报错，这个Debug是一个类似于webpack打包的环境变量，有Debug和Release两种，简单全局搜索一下，可以发现用法都是类似这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518132910478-1375112866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我估计啊，OutDir就跟process.env一样。&lt;/p&gt;
&lt;p&gt;　　环境变量设置地点在IDE的菜单下面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518123644152-293981232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而这个文件确实找不到，但是我在Release里面发现了node.exe与那个失踪的openssl.def。&lt;/p&gt;
&lt;p&gt;　　解决办法就是把Release文件夹里的opendssl.def复制到Debug文件夹中去，然后再次尝试，node.exe文件会自动生成。这下应该就成了，当然，如果把环境变量换成Release也是OK的。&lt;/p&gt;
&lt;p&gt;　　再再次点击开始调试，又是一段非常长的时间，最后成功的话，理论上是会弹出一个node的REPL窗口，就是平时在cmd里面输入node指令的样子，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518124156139-795292107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　检测一下是否读取的是本地的代码，打开node_main.cc，添加一个log代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518124314370-1851783465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这次不点调试，太久了，点那个开始执行(不调试)，可以看到输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/858904/201805/858904-20180518130430308-340606186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，已经可以对nodejs的源码打log了，源码之路的基石已经铺好。&lt;/p&gt;
&lt;p&gt;　　不知道有没有类似于热重载的功能，这C++启动一次实在是太久了。&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 05:12:00 +0000</pubDate>
<dc:creator>书生小龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QH-Jimmy/p/9055637.html</dc:identifier>
</item>
<item>
<title>设计模式（五）—— 原型模式 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9053390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9053390.html</guid>
<description>&lt;h2 id=&quot;原型模式&quot;&gt;原型模式&lt;/h2&gt;
&lt;h3 id=&quot;模式简介&quot;&gt;模式简介&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗来说，原型模式就是从一个对象，通过复制的手段去创建另外一个对象，而且不需要知道任何创建的细节。&lt;/p&gt;
&lt;h4 id=&quot;思考这么做有什么好处&quot;&gt;思考：这么做有什么好处？&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;省略创建者类&lt;/strong&gt;。例如在工厂方法中，客户端创建一个产品，必须调用相应工厂类中的方法获取产品实例。在原型模式中，原型本身提供Clone方法，因此原型的实例扮演了创建者和产品双重角色。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少创建实例带来的成本&lt;/strong&gt;。这里所说的“成本”包括两个层面：&lt;strong&gt;系统性能的消耗&lt;/strong&gt;及&lt;strong&gt;创建实例的代码量&lt;/strong&gt;。当初始化一个对象带来大量的性能消耗，需要创建多个实例且各个实例之间差别不大时，原型模式通过复制原型的方式减小系统性能的消耗。另一方面，当初始化对象需要大量繁杂的代码，使用原型模式避免了代码的重复。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结构说明&quot;&gt;结构说明&lt;/h3&gt;
&lt;h4 id=&quot;uml类图&quot;&gt;UML类图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201805/971601-20180517205358037-1397329956.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;角色及职责&quot;&gt;角色及职责&lt;/h4&gt;
&lt;p&gt;抽象原型类。声明一个克隆自身的接口(抽象方法)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConcretePrototype&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体原型类。实现一个克隆自身的方法&lt;/p&gt;
&lt;p&gt;让一个原型克隆自身从而创建一个新的对象&lt;/p&gt;
&lt;h3 id=&quot;示例分析&quot;&gt;示例分析&lt;/h3&gt;
&lt;p&gt;下面我们来看一个创建颜色Color对象的示例：&lt;/p&gt;
&lt;h4 id=&quot;创建原型类color本示例省略了抽象原型类改用icloneable接口代替&quot;&gt;创建原型类Color(本示例省略了抽象原型类，改用ICloneable接口代替)&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class Color : ICloneable
{
    private int red;
    private int green;
    private int yellow;
    public Color(int red,int green,int yellow)
    {
        this.red = red;
        this.green = green;
        this.yellow = yellow;
    }
    public object Clone()
    {
        Console.WriteLine($&quot;Cloning color RGB: {red},{green},{yellow}&quot;);
        return this.MemberwiseClone() as Color;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建原型管理器colormanager&quot;&gt;创建原型管理器ColorManager&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class ColorManager
{
    Dictionary&amp;lt;string, Color&amp;gt; colors = new Dictionary&amp;lt;string, Color&amp;gt;();
    public Color this[string key]
    {
        get { return colors[key]; }
        set { colors.Add(key, value); }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;客户端向原型管理器注册获取color对象以及动态注册原型&quot;&gt;客户端向原型管理器注册，获取Color对象，以及动态注册原型&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;static void Main(string[] args)
{
    ColorManager colorManager = new ColorManager();

    //向原型管理器注册原型
    colorManager[&quot;red&quot;] = new Color(255, 0, 0);
    colorManager[&quot;green&quot;] = new Color(0, 255, 0);
    colorManager[&quot;yellow&quot;] = new Color(0, 0, 255);

    //创建实例
    Color red = colorManager[&quot;red&quot;].Clone() as Color;

    //动态注册原型
    Console.WriteLine(&quot;Start to register prototype : &quot;);
    Console.WriteLine(&quot;Key : &quot;);
    string key = Console.ReadLine();
    Console.WriteLine(&quot;RGB[example:255,54,0]:&quot;);
    string[] input = Console.ReadLine().Split(',');
    int[] rgb = Array.ConvertAll&amp;lt;string, int&amp;gt;(input, p =&amp;gt; int.Parse(p));
    colorManager[key] = new Color(rgb[0], rgb[1], rgb[2]);
    Color myColor = colorManager[key].Clone() as Color;

    Console.ReadLine();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出结果&quot;&gt;输出结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201805/971601-20180518112800508-1546396082.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;优缺点&quot;&gt;优缺点&lt;/h3&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;对客户隐藏了具体的产品类，减少了客户知道的产品的数目&lt;/li&gt;
&lt;li&gt;客户可以在运行时刻增加和删除产品&lt;/li&gt;
&lt;li&gt;改变值以指定新对象，例如通过为一个对象变量指定不同的值并注册为对象的原型&lt;/li&gt;
&lt;li&gt;改变结构以指定新对象&lt;/li&gt;
&lt;li&gt;减少子类的构造&lt;/li&gt;
&lt;li&gt;用类动态配置应用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;每个Prototype子类都必须实现Clone操作，有时会比较困难&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;浅拷贝与深拷贝&quot;&gt;浅拷贝与深拷贝&lt;/h3&gt;
&lt;h4 id=&quot;浅拷贝&quot;&gt;浅拷贝&lt;/h4&gt;
&lt;p&gt;拷贝一个对象时，仅拷贝对象的引用，拷贝的对象和源对象&lt;strong&gt;引用同一份实体&lt;/strong&gt;。也就是说，改变其中一个对象会影响到另一个对象的状态。&lt;/p&gt;
&lt;h4 id=&quot;深拷贝&quot;&gt;深拷贝&lt;/h4&gt;
&lt;p&gt;拷贝一个对象时，不仅拷贝对象的引用，还将对象引用的值一同拷贝。这样拷贝的对象和源对象&lt;strong&gt;相互独立&lt;/strong&gt;，其中一个改变不会影响另外一个对象。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模式；以及&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当要实例化的类是在运行时刻指定时；或者&lt;/li&gt;
&lt;li&gt;为了避免创建一个与产品类层次平行的工厂类层次时；或者&lt;/li&gt;
&lt;li&gt;当一个类的实例只能有几个不同状态组合中的一种时&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Answer-Geng/dotnet-design-pattern/tree/master/prototype&quot;&gt;dotnet-design-pattern_prototype&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 05:09:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9053390.html</dc:identifier>
</item>
<item>
<title>九大数据可视化利器，你有在使用吗？ - cherry0327</title>
<link>http://www.cnblogs.com/cherry0327/p/9055712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cherry0327/p/9055712.html</guid>
<description>&lt;p&gt;可视化信息以易于阅读的视觉化内容正在被越来越多的人所青睐。可视化形式呈现信息的需求也随之增加，因此近年来涌现出了许多数据可视化工具。对于不熟悉数据可视化领域的人来说，最好的方法是尝试一些现成的解决方案来快速制作标准化的图表。对于拥有更多技术专长、经验丰富的用户，最好的办法是使用更灵活的库。 &lt;span class=&quot;Apple-converted-space&quot;&gt;下面与大家分享九大数据可视化库，希望你可以找到最适合的一款。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;1. D3&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当下谈论数据可视化时，我们是绕不开&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://d3js.org/&quot;&gt;D3&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的，这是由 Mike Bostock 创建的库，它已成为在浏览器中处理 SVG 矢量图形的主要工具。使用 SVG 时，无论放大多少倍，图像看起来都不会出现明显的像素点。D3 允许创建各种高级图形，如网状图、树状图、地图或气泡图，以及常用图形（如条形图或散布图）。D3 是如此的受欢迎，以至于有许多其它的库在 D3 的基础上被创造出来，为人们提供更多“开箱即用”的解决方案，如 NVD3。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;D3 是一个将信息加载到浏览器并基于数据元素生成报告的框架，它本身不提供特定类型的图像，而是一种数据可视化方法。由于 D3 十分灵活，掌握这个库需要花很多时间，但这一切都是值得的。在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://liveedu.tv/&quot;&gt;LiveEdu&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 上，您可以通过学习&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://www.liveedu.tv/dev_zero/RrYjq-python-data-analytics-and-visualization/6pQqV-data-analytics-and-visualization-with-python-10/&quot;&gt;Python 数据分析与可视化&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 这一课程来迅速掌握包括 D3、NVD3、Charts.js 等在内的数据可视化工具。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518124651538-438121749.png&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;476&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2. PROCESSING&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://processingjs.org/&quot;&gt;Processing&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 已经存在好几年了。它是一款可以下载并安装在任何平台上的工具。Processing 使用一个相当简单的语言，它可以让你在写代码的同时直接将其可视化并进行分析（所见即所得）。你不需要掌握 Javascript 就可以开始使用 Processing，因为它有它自己的语言和开发环境，对于某些人来说这可能是一个优势，而对其他人来说则是一个缺点。作为用户，您只需写几行代码并将其放在自己的网站上就可以生成可视化图表了。此外，Processing 有一个庞大的用户社区，这意味着你可以随时得到帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518124836112-1421246279.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;3. RAPHAEL&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://raphaeljs.com/&quot;&gt;Raphael&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是一个着重于与不同浏览器兼容的库。它也使用 SVG 元素，这些元素是可以任意缩放的，不存在像素点问题。它具有创建动画和插入各种组件的功能。事实上，就像 D3 一样，有许多其它的库在 Raphael 的基础上被创造出来，其中最受欢迎的是 morris.js。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518124919103-1675138283.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;4. GOOGLE CHARTS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;Google 拥有自己的 HTML5 / SVG 交互式数据可视化库，被称为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;https://developers.google.com/chart/?hl=en&quot;&gt;Google Charts&lt;/a&gt;。它支持多种设备和浏览器，提供的功能范围从最基本的饼图和条形图到更复杂的图表（如气泡图、树状图、时间轴甚至是甘特图）。其主要特点之一是创建动画图形的简单性，这些动画图形随时间推移而变化。您可以在这里查看更多现有的不同可视化示例：&lt;a href=&quot;https://developers.google.com/chart/interactive/docs/gallery&quot;&gt;https://developers.google.com/chart/interactive/docs/gallery&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518125207068-154688998.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;356&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;5. HIGHCHARTS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.highcharts.com/&quot;&gt;Highcharts&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是最流行的工具之一，它提供各种类型的可视化图形，包括地图。它还提供用于特定用途的其他可视化工具，譬如显示财务数据的 Highstock 等。您可以导出各种格式的图形，比如 PNG、JPG、SVG 和 PDF。&lt;/span&gt;Highcharts 可免费供个人和非商业目的使用，如用于商业目的，您需要购买许可。您可以在&lt;a href=&quot;http://www.highcharts.com/demo/line-basic&quot;&gt;这里&lt;/a&gt;看到各种类型的图表示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518125332923-801667922.png&quot; alt=&quot;&quot; width=&quot;690&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;6. FUSION CHARTS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://rm-blog.s3.amazonaws.com/2015-01-27-las-mejores-librerias-de-visualizacion-de-datos/www.fusioncharts.com&quot;&gt;FusionCharts&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是另一种商业数据可视化解决方案，实际上是最昂贵的解决方案之一。然而，它也是最具灵活性和开箱即用的。它具有用于不同商业用途的大量&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://www.fusioncharts.com/dashboards/&quot;&gt;dashboards&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 可供选择，并且还可以进行高度细化的定制。它支持最新版本的浏览器、JSON 和 XML 数据格式，并提供以 PNG、JPEG、SVG 或 PDF 等格式导出图形的功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518125422774-307838605.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;7. CHARTS.JS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.chartjs.org/docs/&quot;&gt;Chart.js&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是一个开源的库，支持一些简单的图表类型：折线图、条形图、雷达图、极坐标图和饼状图。这些图表类型通常能满足大多数沟通的需要。所有的图形都以 HTML5 的形式呈现，默认情况下是响应式的，可进行交互。它是一个非常轻量化的库，其压缩版本大小只有 11kb。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518125550888-568507878.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;335&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;8. VIS.JS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://visjs.org/&quot;&gt;Vis.js&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是一个支持所有现代浏览器的开源库。它可以让你创建一些基本图形，比如条形图和折线图；以及一些更复杂的图形，比如网状图，或是一些在其它的库中不太常见且更为有趣的图形（比如时间轴和 3D 图形）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518125630722-419725177.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;318&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;9. DYGRAPHS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://dygraphs.com/&quot;&gt;Dygraphs&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是一个用 Javascript 进行数据可视化的开源库。它有一个特定使用场景，即那些会随着时间变化的数据，特别是金融数据。它允许您处理密集、紧凑和高容量的数据，并会自动调整缩放比例和时间戳。它还提供互动性（包括移动设备），即在无需额外设置的情况下就可以拖动、缩放图形。Dygraphs 是一个非常快速和高度可定制的库。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/907691/201805/907691-20180518125734779-933498804.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=3fxr89w39kow0&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 05:01:00 +0000</pubDate>
<dc:creator>cherry0327</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cherry0327/p/9055712.html</dc:identifier>
</item>
<item>
<title>（七）SpringBoot2.0基础篇- application.properties属性文件的解析及获取 - lfalex</title>
<link>http://www.cnblogs.com/lfalex0831/p/9055664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lfalex0831/p/9055664.html</guid>
<description>&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;由于测试代码较多，影响查看效果，所以只放了核心代码，如需查看，请点&lt;a href=&quot;https://gitee.com/lfalex/spring-boot-example/tree/dev/spring-boot-properties&quot; target=&quot;_blank&quot;&gt;示例代码&lt;/a&gt;&lt;/p&gt;
&lt;ol readability=&quot;9.3510436432638&quot;&gt;&lt;li readability=&quot;3.3163265306122&quot;&gt;
&lt;p&gt;默认访问的属性文件为application.properties文件，可在启动项目参数中指定spring.config.location的参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
java -jar myproject.jar --spring.config.location=classpath:/&lt;span&gt;default&lt;/span&gt;.properties,classpath:/override.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考官方文档：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files&quot;&gt;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config-application-property-files&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.9298561151079&quot;&gt;
&lt;p&gt;使用@PropertySource来获取配置文件的中属性值（注意：在使用该注解时，属性文件必须为properties文件，yaml文件不可用）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@PropertySource(&lt;/span&gt;&quot;classpath:/app.properties&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AppConfig {

    @Autowired
    Environment env;

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestBean testBean() {
        TestBean testBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestBean();
        testBean.setName(env.getProperty(&lt;/span&gt;&quot;testbean.name&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; testBean;
    }   
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考官方文档：&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html&quot;&gt;https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5067567567568&quot;&gt;
&lt;p&gt;使用@Value注解直接将属性值注入进修饰对对象中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.beans.factory.annotation.*&lt;span&gt;;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyBean {

    @Value(&lt;/span&gt;&quot;${name}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考官方文档：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config&quot;&gt;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.2405582922824&quot;&gt;
&lt;p&gt;使用@ConfigurationProperties(prefix=&quot;my&quot;)将属性值注入进对象，可以注入对象的属性key的对象，也可以注入进List或Set中，但是属性的书写需要有规范：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
my.servers0=&lt;span&gt;dev.example.com
my.servers1&lt;/span&gt;=another.example.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(prefix=&quot;my&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Config {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set,list不需要Setter方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; servers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getServers() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.servers;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考官方文档：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config-loading-yaml&quot;&gt;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config-loading-yaml&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以使用yaml文件格式来替换properties，属性获取方式不变（注：yaml文件后缀名为.yml）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用POJO方式直接将属性注入进实体对象中：&lt;/p&gt;
&lt;p&gt;application.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;acme:
    remote&lt;/span&gt;-address: 192.168.1.1&lt;span&gt;
    security:
        username: admin
        password: admincss
        roles:
            &lt;/span&gt;-&lt;span&gt; USER
            &lt;/span&gt;- ADMIN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AcmeProperties.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(&lt;/span&gt;&quot;acme&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AcmeProperties {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InetAddress remoteAddress;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Security security = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Security();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InetAddress getRemoteAddress() { ... }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRemoteAddress(InetAddress remoteAddress) { ... }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Security getSecurity() { ... }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Security {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; roles = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(Collections.singleton(&quot;USER&quot;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() { ... }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) { ... }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() { ... }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) { ... }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getRoles() { ... }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setRoles(List&amp;lt;String&amp;gt;&lt;span&gt; roles) { ... }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties&quot;&gt;https://docs.spring.io/spring-boot/docs/2.0.2.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码示例：&lt;a href=&quot;https://gitee.com/lfalex/spring-boot-example/tree/dev/spring-boot-properties&quot; target=&quot;_blank&quot;&gt;https://gitee.com/lfalex/spring-boot-example/tree/dev/spring-boot-properties&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 04:37:00 +0000</pubDate>
<dc:creator>lfalex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lfalex0831/p/9055664.html</dc:identifier>
</item>
<item>
<title>nexus私服搭建及maven生命周期 - 大白虾</title>
<link>http://www.cnblogs.com/gamehiboy/p/9055661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gamehiboy/p/9055661.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、maven找库流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/341524/201805/341524-20180518115034414-1167164131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从流程上看创建nexus私服，能够优化流程，而且更加快速&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、nexus下载、安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、nexus下载地址　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.5-02-bundle.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　2、nexus解压并安装环境　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
#解压
tar -zxif nexus-2.14.5-02-bundle.tar.gz
#在环境变量中设置启动用户
vim /etc/profile
#安全起见不建议使用root用户，如果使用其它用户需要加相应权限
RUN_AS_USER=root
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　3、配置启动参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
#${nexusBase}为nexus的安装路径
vim ${nexusBase}/conf/nexus.properties
#端口号
applicatiom-port=8081
#仓库地址
nexus-work=${bundleBasedir}/../sonatype-work/nexus
#启动nexus
${nexusBase}/bin/nexus start
#停止nexus
${nexusBase}/bin/nexus stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4、登录nexus界面&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
地址：http://{ip}:8081/nexus/&lt;br/&gt;默认用户名:admin&lt;br/&gt;默认密码：admin123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　5、手动更新索引&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;前往maven中央仓库下载&lt;/em&gt;&lt;a href=&quot;http://search.maven.org/#search%7Cgav%7C1%7Cg%3A&quot;&gt;indexer-cli-5.1.1.jar&lt;/a&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.maven.indexer%22%20AND%20a%3A%22indexer-cli%22
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　6、下载索引文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
http://repo.maven.apache.org/maven2/.index/
nexus-maven-repository-index.gz
nexus-maven-repository-index.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　7、解压索引文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
java -jar indexer-cli-5.1.1.jar -u nexus-maven-repository-index.gz -d indexer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        8、拷贝索引文件至目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
{nexus-home}/sonatype-work/nexus/indexer/central-ctx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　9、重启nexus&lt;/p&gt;
&lt;p&gt;　　注意：&lt;span&gt;觉得麻烦可以直接下载：https://pan.baidu.com/s/1qzllVcr5nqiX2EKVlof5Wg，里面包含所有需要的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、maven配置优化及设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、优化maven里的setting配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
#设置maven本地仓库地址
&amp;lt;localRepository&amp;gt;F:\maven&amp;lt;/localRepository&amp;gt;
#设置快照版本服务
&amp;lt;servers&amp;gt;
      #对应exclipe/idea项目中parent，pom.xml里的distributionManagement
      &amp;lt;id&amp;gt;nexusSnapshot&amp;lt;/id&amp;gt;
      &amp;lt;username&amp;gt;deployment&amp;lt;/username&amp;gt;
      &amp;lt;password&amp;gt;deployment123&amp;lt;/password&amp;gt;
    &amp;lt;/server&amp;gt;
&amp;lt;/servers&amp;gt;
#设置镜像
&amp;lt;mirrors&amp;gt;
        &amp;lt;mirror&amp;gt;
                &amp;lt;id&amp;gt;nexusSnapshot&amp;lt;/id&amp;gt;
                #全部走nexus私服
                &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt;
                &amp;lt;name&amp;gt;nexus&amp;lt;/name&amp;gt;
                &amp;lt;url&amp;gt;http://192.168.1.32:8082/nexus/content/groups/public/&amp;lt;/url&amp;gt;
     &amp;lt;/mirror&amp;gt;
 &amp;lt;/mirrors&amp;gt;
#配置仓库地址
&amp;lt;profiles&amp;gt;
        &amp;lt;profile&amp;gt;
          &amp;lt;id&amp;gt;common&amp;lt;/id&amp;gt;
      &amp;lt;repositories&amp;gt;
        &amp;lt;repository&amp;gt;
          &amp;lt;id&amp;gt;nexusSnapshot&amp;lt;/id&amp;gt;
          &amp;lt;name&amp;gt;snapshots&amp;lt;/name&amp;gt;
          &amp;lt;url&amp;gt;http://*&amp;lt;/url&amp;gt;
        &amp;lt;/repository&amp;gt;
                &amp;lt;repository&amp;gt;
          &amp;lt;id&amp;gt;nexusCentral&amp;lt;/id&amp;gt;
          &amp;lt;name&amp;gt;nexusCentral&amp;lt;/name&amp;gt;
          &amp;lt;url&amp;gt;http://*&amp;lt;/url&amp;gt;
        &amp;lt;/repository&amp;gt;
                &amp;lt;repository&amp;gt;
          &amp;lt;id&amp;gt;nexusReleases&amp;lt;/id&amp;gt;
          &amp;lt;name&amp;gt;nexusReleases&amp;lt;/name&amp;gt;
          &amp;lt;url&amp;gt;http://*&amp;lt;/url&amp;gt;
        &amp;lt;/repository&amp;gt;
      &amp;lt;/repositories&amp;gt;
        #配置编译的jdk
          &amp;lt;properties&amp;gt; 
                  &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; 
                  &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; 
                      &amp;lt;maven.compiler.compilerVersion&amp;gt;1.8&amp;lt;/maven.compiler.compilerVersion&amp;gt; 
          &amp;lt;/properties&amp;gt; 
        &amp;lt;/profile&amp;gt;
  &amp;lt;/profiles&amp;gt;

&amp;lt;activeProfiles&amp;gt;
    &amp;lt;activeProfile&amp;gt;common&amp;lt;/activeProfile&amp;gt;
  &amp;lt;/activeProfiles&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　2、修改pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;distributionManagement&amp;gt;
                &amp;lt;repository&amp;gt;
                        &amp;lt;id&amp;gt;nexusSnapshot&amp;lt;/id&amp;gt;
                        &amp;lt;name&amp;gt;nexusSnapshot&amp;lt;/name&amp;gt;
                        &amp;lt;url&amp;gt;http://192.168.1.32:8082/nexus/content/repositories/snapshots/&amp;lt;/url&amp;gt;
                &amp;lt;/repository&amp;gt;
        &amp;lt;/distributionManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 四、nexus仓库与仓库组&lt;/p&gt;
&lt;p&gt;　　1、nexus内置仓库&lt;/p&gt;
&lt;p&gt;　　登陆用户，单击Nexus界面左边导航栏中的Repositories链接，就可以看到内置的仓库&lt;img src=&quot;https://images2018.cnblogs.com/blog/341524/201805/341524-20180518122913918-1969644861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2、从中可以看到仓库有四种类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
- group（仓库组）
- hosted（宿主）
- proxy（代理）
- virtual（虚拟）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　3、每个仓库的格式为maven2或者maven1。此外，仓库还有一个属性为Policy（策略），表示该仓库为发布（Release）版本仓库还是快照（Snapshot）版本仓库。最后两列的值为仓库的状态和路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    Maven Central：该仓库代理Maven中央仓库，其策略为Release，因此只会下载和缓存中央仓库中的发布版本构件。
    Releases：这是一个策略为Release的宿主类型仓库，用来部署组织内部的发布版本构件。
    Snapshots：这是一个策略为Snapshot的宿主类型仓库，用来部署组织内部的快照版本构件。
    3rd party：这是一个策略为Release的宿主类型仓库，用来部署无法从公共仓库获得的第三方发布版本构件。
    Apache Snapshots：这是一个策略为Snapshot的代理仓库，用来代理Apache Maven仓库的快照版本构件。
    Codehaus Snapshots：这是一个策略为Snapshot的代理仓库，用来代理Codehaus Maven仓库的快照版本构件。
    Google Code：这是一个策略为Release的代理仓库，用来代理Google Code Maven仓库的发布版本构件。
    java.net-Maven 2：这是一个策略为Release的代理仓库，用来代理java.net Maven仓库的发布版本构件。
    Public Repositories：该仓库组将上述所有策略为Release的仓库聚合并通过一致的地址提供服务。
    Public Snapshot Repositories：该仓库组将上述所有策略为Snapshot的仓库聚合并通过一致的地址提供服务。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4、Nexus仓库分类的概念&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/341524/201805/341524-20180518123208858-682505292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、maven生命周期&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
clean lifecycle : 构建前的清理工作
•       pre-clean 执行一些需要在clean之前完成的工作
•       clean 移除所有上一次构建生成的文件
•       post-clean 执行一些需要在clean之后立刻完成的工作
Default lifecycle： 构建的核心部分，编译、打包、部署、上传
•       validate 项目及所必须的环境验证
•       initialize 初始化构建状态，例如设置属性或创建目录。
•       generate-sources 生成次源包
•       process-sources
•       generate-resources
•       process-resources 复制并处理资源文件，至目标目录，准备打包。
•       compile 编译项目的源代码。
•       process-classes
•       generate-test-sources 
•       process-test-sources 
•       generate-test-resources
•       process-test-resources 复制并处理资源文件，至目标测试目录。
•       test-compile 编译测试源代码。
•       process-test-classes
•       test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。
•       prepare-package
•       package 接受编译好的代码，打包成可发布的格式，如 JAR 。
•       pre-integration-test
•       integration-test
•       post-integration-test
•       verify
•       install 将包安装至本地仓库，以让其它项目依赖。
•       deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享。
site lifecycle：项目报告生成，站点文档生成
•       pre-site 执行一些需要在生成站点文档之前完成的工作
•       site 生成项目的站点文档
•       post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
•       site-deploy 将生成的站点文档部署到特定的服务器上
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 18 May 2018 04:35:00 +0000</pubDate>
<dc:creator>大白虾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gamehiboy/p/9055661.html</dc:identifier>
</item>
<item>
<title>WPF MVVM  UI分离之《交互与数据分离》 - 唐宋元明清2188</title>
<link>http://www.cnblogs.com/kybs0/p/9053683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kybs0/p/9053683.html</guid>
<description>&lt;p&gt;在我们使用WPF过程中，不可避免并且超级喜欢使用MVVM框架。&lt;/p&gt;
&lt;p&gt;那么，使用MVVM的出发点是&lt;span&gt;视觉与业务逻辑分离，即UI与数据分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;诸如下面的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;删除操作&lt;/strong&gt;，假如需要先执行一部分数据的处理，然后删除界面列表中的子项，之后再执行其它数据的处理。&lt;span&gt;请问此业务该放置于Xaml.cs文件，还是ViewModel中呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再如弹窗，提示框，设置列表的滚动等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此上一些操作，我们不应该把业务代码直接挪到cs文件中，因为删除操作绝大部分的代码都是数据的处理。所以，数据的部分放置在ViewModel中，一些交互放在cs文件中，就是很合理及有必要了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单元测试，&lt;/strong&gt;UI与交互的那部分是mock模拟有点难度，也没必要去模拟。那么，我们是应该把数据与交互拆开，减少之间的耦合性。这样添加单元测试则更容易。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;交互与数据分离 - 描述&lt;/h2&gt;
&lt;p&gt;首先MVVM，通过View与ViewModel的绑定，我们实现了UI与业务逻辑的分离。通俗一点，我们熟悉的Xaml与ViewModel文件中，代码之间的隔离。在此不详述~&lt;/p&gt;
&lt;p&gt;而MVVM，不只是界面与逻辑，其实逻辑还可以拆分成交互与数据&lt;/p&gt;
&lt;p&gt;即：Xaml 》Xaml.cs 》ViewModel&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/685541/201805/685541-20180517220110684-506256561.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是的，按照上面的结构图，我们分成三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;界面&lt;/strong&gt; 用于界面呈现 ---- 如页面/控件/样式/模板等其它资源的初始化，动画的触发等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交互&lt;/strong&gt; 用于与用户确认的交互或者界面复杂逻辑的处理 ---- 如弹窗/提示框/复杂动画的处理/设置列表的滚动等其它界面元素的视觉处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt; 只是数据的处理 ---- 增删改查导入导出保存等只针对数据的操作，界面状态属性的保存与触发更改（绑定）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;交互与数据分离是怎样的？比如删除：&lt;/p&gt;
&lt;p&gt;1. 界面删除按钮，绑定ViewModel中的DeleteCommand，当我们点击删除时，触发DeleteCommand.Execute&lt;/p&gt;
&lt;p&gt;2. ViewModel中，先执行数据状态的判断，然后执行&lt;span&gt;交互通知&lt;/span&gt;ShowDeleteWaringAction，调用xaml.cs文件中的确认提示框&lt;/p&gt;
&lt;p&gt;3. 在Xaml.cs中添加依赖属性ShowDeleteWaring，绑定ViewModel中的ShowDeleteWaringAction.Progress。在属性更改中，处理提示框确认逻辑。&lt;/p&gt;
&lt;p&gt;4. ViewModel中，等待ShowDeleteWaring弹框完成后，继续执行下面的业务。&lt;/p&gt;
&lt;p&gt;5. 还有类似上面步骤的删除动画。。。&lt;/p&gt;

&lt;h2&gt;交互与数据分离 - 实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;在WPF框架下开发时，一种基于MVVM的UI分离方案&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;在业务逻辑处理过程中，新建一个交互处理线程，通知界面完成交互处理，同时后台逻辑保持同步等待。界面完成交互处理后，回调并执行后续的业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;View中的依赖属性DependencyProperty，绑定ViewModel中属性“UIDelegateOperation”中的交互处理进度“UIDelegateProress”&lt;/li&gt;
&lt;li&gt;每次在ViewModel执行业务逻辑需要调用交互处理时，由UIDelegateOperation创建一个新的交互进度“UIDelegateProress”，触发属性变更，并设置“UIDelegateOperation”同步等待。&lt;/li&gt;
&lt;li&gt;当View中的属性变更事件执行完成后，回调并唤醒”UIDelegateOperation“，继续完成后面的业务逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1. 界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Xaml中添加附加属性，删除动画DeleteCoursewaresAnimation，删除确认框ShowDeleteWaring。并绑定ViewModel中对应的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UserControl.Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;editing:CloudListView&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;DeleteCoursewaresAnimation&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding DeleteCoursewaresAnimation.DelegateProgress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ShowDeleteWaringShow&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ShowDeleteWaring.DelegateProgress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;UserControl.Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;界面ListBox，列表子项ListBoxItemr的DataTemplate模板中，删除按钮绑定ViewModel中的DeleteCommand&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;DeleteButton&quot;&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        Command&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding ElementName=TheCloudDocsList,Path=DataContext.DeleteCommand}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        CommandParameter&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding RelativeSource={RelativeSource TemplatedParent},Path=DataContext }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        Content&lt;/span&gt;&lt;span&gt;=&quot;删除&quot;&lt;/span&gt;&lt;span&gt; Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource Style.Button}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 2. ViewModel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ViewModel调用UIDelegateOperation交互处理时，根据是否需要同步等待，调用不同的函数 Start()，StartAsync()，StartWithResult()，StartWithResultAsync();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除业务中，除了数据处理，还有俩个交互(删除确认框，删除元素动画)。&lt;/p&gt;
&lt;p&gt;通过在同步调用删除确认框/删除元素动画后，再继续往下执行业务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性和字段字义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义命令&lt;/p&gt;
&lt;p&gt;自定义命令，可以详细之前写的博客：&lt;a href=&quot;http://www.cnblogs.com/kybs0/p/7523654.html&quot; target=&quot;_blank&quot;&gt;自定义Command&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; DelegateCommand&amp;lt;CoursewareListItem&amp;gt; _deleteCommand = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; DelegateCommand&amp;lt;CoursewareListItem&amp;gt;&lt;span&gt; DeleteCommand
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;get&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (_deleteCommand == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             _deleteCommand = &lt;span&gt;new&lt;/span&gt; DelegateCommand&amp;lt;CoursewareListItem&amp;gt;&lt;span&gt;(DeleteCourseware_OnExecute);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _deleteCommand;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提示框确认交互/删除动画交互&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出删除确认窗口 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; IUIDelegateOperation&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt; ShowDeleteWaring { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; IUIDelegateOperation&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除动画 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; IUIDelegateOperation&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt; DeleteCoursewaresAnimation { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; IUIDelegateOperation&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;item&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DeleteCourseware_OnExecute(CoursewareListItem item)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt; DeleteCoursewares(&lt;span&gt;new&lt;/span&gt; List&amp;lt;CoursewareListItem&amp;gt;&lt;span&gt;() { item });
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task DeleteCoursewares(List&amp;lt;CoursewareListItem&amp;gt;&lt;span&gt; items)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (items.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出删除确认窗口&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; messageResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ShowDeleteWaringShow.ExecuteWithResultAsync(items);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (messageResult ==&lt;span&gt; MessageResult.Positive)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除服务器数据 &lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         Response deleteResponse = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; WebService.DeleteItemAsync(items);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除失败&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;deleteResponse.Success)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            Notification.ShowInfo(deleteResponse.Message);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除动画&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;await&lt;/span&gt;&lt;span&gt; DeleteCoursewaresAnimation.ExecuteAsync(items);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;界面删除子项&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         items.ForEach(item =&amp;gt;&lt;span&gt; ItemsSource.Remove(item));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出编辑模式&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (DocListState ==&lt;span&gt; EditStatus.Editing)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             DocListState =&lt;span&gt; EditStatus.Normal;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3. Xaml.cs后台&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加依赖属性后，通过属性变更触发，来完成弹出提示框/删除动画等交互。&lt;/li&gt;
&lt;li&gt;执行交互时，需要同步等待时，应将动画执行等转化为同步逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;添加依赖属性 - 删除窗口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;属性变更触发方法，应该是一个异步方法，里面的逻辑应该为同步执行。这样ViewModel中才能同步等待交互的完成，并执行之后的逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除窗口
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty ShowDeleteWaringShowProperty =&lt;span&gt; DependencyProperty.Register(
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShowDeleteWaringShow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(CloudListView), &lt;span&gt;new&lt;/span&gt; PropertyMetadata(&lt;span&gt;default&lt;/span&gt;(UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         (d, e) =&amp;gt; ((UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;)e.NewValue)?&lt;span&gt;.StartAsync(((CloudListView)d).ShowDeleteWaringShow)));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;MessageResult&amp;gt; ShowDeleteWaringShow(List&amp;lt;CoursewareListItem&amp;gt;&lt;span&gt; items)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; cmd = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; DeleteWaringShow(items);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cmd.Result;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetShowDeleteWaringShow(DependencyObject element, UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    element.SetValue(ShowDeleteWaringShowProperty, value);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;&lt;span&gt; GetShowDeleteWaringShow(DependencyObject element)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;, MessageResult&amp;gt;&lt;span&gt;)element.GetValue(ShowDeleteWaringShowProperty);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;添加依赖属性 - 删除动画&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DependencyProperty DeleteCoursewaresAnimationProperty =&lt;span&gt; DependencyProperty.Register(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DeleteCoursewaresAnimation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(CloudListView), &lt;span&gt;new&lt;/span&gt; PropertyMetadata(&lt;span&gt;default&lt;/span&gt;(UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         (d, e) =&amp;gt; ((UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;)e.NewValue)?&lt;span&gt;.StartAsync(((CloudListView)d).ExecuteDeleteCoursewaresAnimation)));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task ExecuteDeleteCoursewaresAnimation(List&amp;lt;CoursewareListItem&amp;gt;&lt;span&gt; coursewares)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;Storyboard&amp;gt; storyboards = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Storyboard&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; courseware &lt;span&gt;in&lt;/span&gt;&lt;span&gt; coursewares)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; listBoxItem = DocumentsControl.ItemContainerGenerator.ContainerFromItem(courseware) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ListBoxItem;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; border = listBoxItem?.VisualDescendant&amp;lt;Border&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; storyboard = (Storyboard)border?.Resources[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ItemRemovedStoryboard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (storyboard == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找不到storyBoard，则中断动画的执行。因为删除多个Item，只执行一半的动画，界面会闪现俩次。&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        storyboards.Add(storyboard);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除界面课件&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; AsynchronousTransferHelper.ExecuteStoryboradAsync(storyboards);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetDeleteCoursewaresAnimation(DependencyObject element, UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;&lt;span&gt; value)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    element.SetValue(DeleteCoursewaresAnimationProperty, value);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;&lt;span&gt; GetDeleteCoursewaresAnimation(DependencyObject element)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (UIDelegateProgress&amp;lt;List&amp;lt;CoursewareListItem&amp;gt;&amp;gt;&lt;span&gt;)element.GetValue(DeleteCoursewaresAnimationProperty);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;动画的执行，怎么转为有同步等待呢？动画完成只有通过触发事件Completed才能确定。&lt;/p&gt;
&lt;p&gt;如何将动画转化为同步，可参考之前写的博客：&lt;a href=&quot;http://www.cnblogs.com/kybs0/p/8468464.html&quot; target=&quot;_blank&quot;&gt;C# 异步转同步&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行动画
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;storyboard&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ExecuteStoryboradAsync([NotNull] Storyboard storyboard)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (storyboard == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(storyboard));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     AutoResetEvent autoResetEvent = &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     storyboard.Completed +=&lt;span&gt; OnStoryboardCompleted;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    storyboard.Begin();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; OnStoryboardCompleted(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         storyboard.Completed -=&lt;span&gt; OnStoryboardCompleted;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        autoResetEvent.Set();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt; { autoResetEvent.WaitOne(); });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4. 交互处理辅助类 UIDelegateOperation &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在UIDelegateOperation内部，每次调用时，都会新建一个UIDelegateProgress(委托进度)。委托进度，是界面交互的处理~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UIDelegateOperation:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_a5f117db-0fc0-41f9-bb95-e54882884784&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5f117db-0fc0-41f9-bb95-e54882884784&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5f117db-0fc0-41f9-bb95-e54882884784&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI交互处理-提供可调用UI交互的操作
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UIDelegateOperation : BindableObject, IUIDelegateAction
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UIDelegateProgress _delegateProgress;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UIDelegateProgress DelegateProgress
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _delegateProgress;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 _delegateProgress =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;                OnPropertyChanged();
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute()
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UIDelegateProgress();
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 交互处理完成并回调
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ExecuteAsync()
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             AutoResetEvent autoResetEvent = &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UIDelegateProgress();
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                autoResetEvent.Set();
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt; { autoResetEvent.WaitOne(); });
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI交互处理-提供可同步调用UI交互的操作
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输入/输出类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UIDelegateAction&amp;lt;T&amp;gt; : BindableObject, IUIDelegateAction&amp;lt;T&amp;gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; UIDelegateProgress&amp;lt;T&amp;gt;&lt;span&gt; _delegateProgress;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; UIDelegateProgress&amp;lt;T&amp;gt;&lt;span&gt; DelegateProgress
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _delegateProgress;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 _delegateProgress =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                OnPropertyChanged();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute(T parameter)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt; UIDelegateProgress&amp;lt;T&amp;gt;&lt;span&gt;(parameter);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 交互处理完成并回调
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ExecuteAsync(T parameter)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             AutoResetEvent autoResetEvent = &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt; UIDelegateProgress&amp;lt;T&amp;gt;&lt;span&gt;(parameter);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                autoResetEvent.Set();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt; { autoResetEvent.WaitOne(); });
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行并返回结果
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;T&amp;gt;&lt;span&gt; ExecuteWithResultAsync()
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             AutoResetEvent autoResetEvent = &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt; UIDelegateProgress&amp;lt;T&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                autoResetEvent.Set();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt; { autoResetEvent.WaitOne(); });
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegateProgress.Result;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI交互处理-提供可同步调用UI交互的操作
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TInput&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输入类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TOut&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输出类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UIDelegateAction&amp;lt;TInput, TOut&amp;gt; : BindableObject, IUIDelegateAction&amp;lt;TInput, TOut&amp;gt;
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;&lt;span&gt; _delegateProgress;
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;&lt;span&gt; DelegateProgress
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _delegateProgress;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 _delegateProgress =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                OnPropertyChanged();
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute(TInput parameter)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt; UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;&lt;span&gt;(parameter);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行并返回结果
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TOut ExecuteWithResult(TInput parameter)
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt; UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;&lt;span&gt;(parameter);
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegateProgress.Result;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行并返回结果
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;TOut&amp;gt;&lt;span&gt; ExecuteWithResultAsync(TInput parameter)
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; delegateProgress = &lt;span&gt;new&lt;/span&gt; UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;&lt;span&gt;(parameter);
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; SetDelegateProgress(delegateProgress);
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegateProgress.Result;
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task SetDelegateProgress(UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;&lt;span&gt; delegateProgress)
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;             AutoResetEvent autoResetEvent = &lt;span&gt;new&lt;/span&gt; AutoResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt;             delegateProgress.ProgressCompleted += () =&amp;gt;
&lt;span&gt;181&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                 _delegateProgress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;                autoResetEvent.Set();
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             DelegateProgress =&lt;span&gt; delegateProgress;
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;&lt;span&gt; { autoResetEvent.WaitOne(); });
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;191&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI交互处理接口
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUIDelegateAction
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; 
&lt;span&gt;196&lt;/span&gt;         UIDelegateProgress DelegateProgress { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute();
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; 
&lt;span&gt;203&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;        Task ExecuteAsync();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; 
&lt;span&gt;209&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI交互处理接口
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;212&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输入/输出类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IUIDelegateAction&amp;lt;T&amp;gt;
&lt;span&gt;214&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;         UIDelegateProgress&amp;lt;T&amp;gt; DelegateProgress { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;220&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute(T parameter);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; 
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;223&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        Task ExecuteAsync(T parameter);
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; 
&lt;span&gt;227&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行并返回结果
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;230&lt;/span&gt;         Task&amp;lt;T&amp;gt;&lt;span&gt; ExecuteWithResultAsync();
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;234&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI交互处理接口
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;236&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TInput&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输入类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;237&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TOut&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;输出类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;238&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IUIDelegateAction&amp;lt;TInput, TOut&amp;gt;
&lt;span&gt;239&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;         UIDelegateProgress&amp;lt;TInput, TOut&amp;gt; DelegateProgress { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; 
&lt;span&gt;242&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;243&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute(TInput parameter);
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; 
&lt;span&gt;247&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;248&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行并返回结果
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;250&lt;/span&gt; &lt;span&gt;        TOut ExecuteWithResult(TInput parameter);
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; 
&lt;span&gt;252&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;253&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 异步执行并返回结果
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt;         Task&amp;lt;TOut&amp;gt;&lt;span&gt; ExecuteWithResultAsync(TInput parameter);
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;UIDelegateProgress:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_aaa7c8ec-e31f-4f49-a084-020b9dc03086&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aaa7c8ec-e31f-4f49-a084-020b9dc03086&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aaa7c8ec-e31f-4f49-a084-020b9dc03086&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 委托进度
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UIDelegateProgress
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action ProgressCompleted;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartAsync(Func&amp;lt;Task&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;await&lt;/span&gt;&lt;span&gt; uiTask.Invoke();
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start(Action uiTask)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;                uiTask.Invoke();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 委托进度
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UIDelegateProgress&amp;lt;T&amp;gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action ProgressCompleted;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 输入参数
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; T Parameter { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 输出参数
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; T Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UIDelegateProgress()
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UIDelegateProgress(T parameter)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             Parameter =&lt;span&gt; parameter;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Start(Action&amp;lt;T&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                uiTask.Invoke(Parameter);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartAsync(Func&amp;lt;T, Task&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 &lt;span&gt;await&lt;/span&gt;&lt;span&gt; uiTask.Invoke(Parameter);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Start(Func&amp;lt;T&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 Result =&lt;span&gt; uiTask.Invoke();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartAsync(Func&amp;lt;Task&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                 Result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; uiTask.Invoke();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; 
&lt;span&gt;156&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 委托进度
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UIDelegateProgress&amp;lt;TInput, TOut&amp;gt;
&lt;span&gt;160&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action ProgressCompleted;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 输入参数
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; TInput Parameter { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; 
&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 输出参数
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;171&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; TOut Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UIDelegateProgress(TInput parameter)
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;             Parameter =&lt;span&gt; parameter;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;181&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartAsync(Func&amp;lt;TInput, Task&amp;lt;TOut&amp;gt;&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                 Result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; uiTask.Invoke(Parameter);
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Start(Func&amp;lt;TOut&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;                uiTask.Invoke();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; UI委托处理
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;uiTask&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Start(Func&amp;lt;TInput, TOut&amp;gt;&lt;span&gt; uiTask)
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt;225&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;                 Result =&lt;span&gt; uiTask.Invoke(Parameter);
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvalidOperationException e)
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;                 Log.Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UI交互处理，产生异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;                 ProgressCompleted?&lt;span&gt;.Invoke();
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;关键字：&lt;/strong&gt;UI分离，交互与数据分离，动画同步，单元测试&lt;/p&gt;
</description>
<pubDate>Fri, 18 May 2018 04:24:00 +0000</pubDate>
<dc:creator>唐宋元明清2188</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kybs0/p/9053683.html</dc:identifier>
</item>
</channel>
</rss>