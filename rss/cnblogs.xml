<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mysql-高级操作 - wyao</title>
<link>http://www.cnblogs.com/nordon-wang/p/9022406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nordon-wang/p/9022406.html</guid>
<description>&lt;ul&gt;&lt;li&gt;主键冲突的时候，可以选择更新或者替换进行处理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;更新&quot;&gt;更新&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;主键冲突，更新操作、&lt;/li&gt;
&lt;li&gt;Insert into 表名[(字段列表:包含主键)] values(值列表) on duplicate key update 字段 = 新值;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 主键冲突: 更新&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_class &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'0810'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'B205'&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;-- 冲突处理&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; duplicate &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- 更新教室&lt;/span&gt;
room = &lt;span class=&quot;st&quot;&gt;'B205'&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;替换&quot;&gt;替换&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;主键冲突: 替换&lt;/li&gt;
&lt;li&gt;Replace into 表名 [(字段列表:包含主键)] values(值列表);&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 主键冲突:替换&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_class &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'0710'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'A203'&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;replace&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_class &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'0910'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'B207'&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;蠕虫复制: 从已有的数据中去获取数据,然后将数据又进行新增操作: 数据成倍的增加&lt;/li&gt;
&lt;li&gt;表创建高级操作: 从已有表创建新表(复制表结构)&lt;/li&gt;
&lt;li&gt;Create table 表名 like 数据库.表名;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
&lt;span class=&quot;co&quot;&gt;-- 复制创建表&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_copy &lt;span class=&quot;kw&quot;&gt;like&lt;/span&gt; my_gbk;

&lt;span class=&quot;co&quot;&gt;-- 蠕虫复制&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_copy &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_collate_bin;
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_copy &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_copy;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;蠕虫复制的意义&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;从已有表拷贝数据到新表中&lt;/li&gt;
&lt;li&gt;可以迅速的让表中的数据膨胀到一定的数量级: 测试表的压力以及效率&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;&lt;li&gt;基本语法&lt;/li&gt;
&lt;li&gt;Update 表名 set 字段 = 值 [where条件];&lt;/li&gt;
&lt;li&gt;高级新增语法&lt;/li&gt;
&lt;li&gt;Update 表名 set 字段 = 值 [where条件][limit 更新数量];&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 更新部分a变成c&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt; my_copy &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; name = &lt;span class=&quot;st&quot;&gt;'c'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; name = &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;与更新类似: 可以通过limit来限制数量&lt;/li&gt;
&lt;li&gt;Delete from 表名 [where条件][limit 数量];&lt;/li&gt;
&lt;li&gt;如果表中存在主键自增长,那么当删除之后, 自增长不会还原r&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 删除数据:限制记录数为10&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_copy &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; name = &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;基本语法&lt;/li&gt;
&lt;li&gt;Select 字段列表/* from 表名 [where条件]&lt;/li&gt;
&lt;li&gt;完整语法&lt;/li&gt;
&lt;li&gt;Select [select选项] 字段列表[字段别名]/* from 数据源 [where条件子句][group by子句] [having子句][order by子句] [limit 子句];&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;select选项&quot;&gt;select选项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;select选项是select对查出来的结果的处理方式&lt;/li&gt;
&lt;li&gt;all：默认的，保留所有的结果&lt;/li&gt;
&lt;li&gt;distinct：去重，查出来的结果，将重复的给去除，是所有字段都相同的才会被去除&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- select选项&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_copy;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;all&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_copy;

&lt;span class=&quot;co&quot;&gt;-- 去重&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;distinct&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_copy;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;字段别名&quot;&gt;字段别名&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;字段别名: 当数据进行查询出来的时候, 有时候名字并一定就满足需求(多表查询的时候, 会有同名字段). 需要对字段名进行重命名: 别名&lt;/li&gt;
&lt;li&gt;语法：字段名 [as] 别名;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 字段别名&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;,
&lt;span class=&quot;dt&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; 学号,
name &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; 姓名,
sex 性别 &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;数据源&quot;&gt;数据源&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据源: 数据的来源, 关系型数据库的来源都是数据表: 本质上只要保证数据类似二维表,最终都可以作为数据源&lt;/li&gt;
&lt;li&gt;数据源分为多种: 单表数据源, 多表数据源, 查询语句&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单表数据源&quot;&gt;单表数据源&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;单表数据源: select * from 表名;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_copy;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;多表数据源&quot;&gt;多表数据源&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;多表数据源: select* from 表名1,表名2...;&lt;/li&gt;
&lt;li&gt;从一张表中取出一条记录,去另外一张表中匹配所有记录,而且全部保留:(记录数和字段数),将这种结果成为: 笛卡尔积(交叉连接): 笛卡尔积没什么卵用, 所以应该尽量避免.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 多表数据源&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student,my_class;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;子查询&quot;&gt;子查询&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;子查询: 数据的来源是一条查询语句(查询语句的结果是二维表)&lt;/li&gt;
&lt;li&gt;Select * from (select 语句) as 表名;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 子查询&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student) &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; s;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;where子句&quot;&gt;where子句&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Where子句: 用来判断数据,筛选数据.&lt;/li&gt;
&lt;li&gt;Where子句返回结果: 0或者1, 0代表false,1代表true&lt;/li&gt;
&lt;li&gt;判断条件:&lt;/li&gt;
&lt;li&gt;比较运算符: &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;= ,!= ,&amp;lt;&amp;gt;, =, like, between and, in/not in&lt;/li&gt;
&lt;li&gt;逻辑运算符: &amp;amp;&amp;amp;(and), ||(or), !(not)&lt;/li&gt;
&lt;li&gt;Where原理: where是唯一一个直接从磁盘获取数据的时候就开始判断的条件: 从磁盘取出一条记录, 开始进行where判断: 判断的结果如果成立保存到内存;如果失败直接放弃&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 增加age和height字段&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; age tinyint unsigned;
&lt;span class=&quot;kw&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; height tinyint unsigned;

&lt;span class=&quot;co&quot;&gt;-- 增加值: rand取得一个0到1之间的随机数, floor向下取整&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; age=floor(rand() * &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;),height = &lt;span class=&quot;fu&quot;&gt;floor&lt;/span&gt;(rand()*&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;170&lt;/span&gt;);

&lt;span class=&quot;co&quot;&gt;-- 找id为1,3,5的&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; || &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; || &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;-- 逻辑判断&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;-- 落在集合中&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- 找身高在180到190之间的&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; height &amp;gt;= &lt;span class=&quot;dv&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; height &amp;lt;= &lt;span class=&quot;dv&quot;&gt;190&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; height &lt;span class=&quot;kw&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;180&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;190&lt;/span&gt;;

&lt;span class=&quot;co&quot;&gt;--Between本身是闭区间; between左边的值必须小于或者等于右边的值,不然就会查找失败&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; height &lt;span class=&quot;kw&quot;&gt;between&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;190&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;180&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;group-by-子句&quot;&gt;group by 子句&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Group by:分组的意思, 根据某个字段进行分组(相同的放一组,不同的分到不同的组)&lt;/li&gt;
&lt;li&gt;基本语法: group by 字段名;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sq&quot;&gt;
&lt;code&gt;-- 根据性别分组
select * from my_student group by sex;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分组的意思: 是为了统计数据(按组统计: 按分组字段进行数据统计)&lt;/li&gt;
&lt;li&gt;SQL提供了一系列统计函数&lt;/li&gt;
&lt;li&gt;Count(): 统计分组后的记录数: 每一组有多少记录&lt;br/&gt;Max(): 统计每组中最大的值&lt;/li&gt;
&lt;li&gt;Min(): 统计最小值&lt;/li&gt;
&lt;li&gt;Avg(): 统计平均值&lt;/li&gt;
&lt;li&gt;Sum(): 统计和&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 分组统计: 身高高矮,年龄平均和总年龄&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; sex,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*),&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(height),&lt;span class=&quot;fu&quot;&gt;min&lt;/span&gt;(height),&lt;span class=&quot;fu&quot;&gt;avg&lt;/span&gt;(age),&lt;span class=&quot;fu&quot;&gt;sum&lt;/span&gt;(age) &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; sex;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Count函数: 里面可以使用两种参数: *代表统计记录,字段名代表统计对应的字段(NULL不统计)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; sex,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*),&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(age),&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(height),&lt;span class=&quot;fu&quot;&gt;min&lt;/span&gt;(height),&lt;span class=&quot;fu&quot;&gt;avg&lt;/span&gt;(age),&lt;span class=&quot;fu&quot;&gt;sum&lt;/span&gt;(age) &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; sex;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;分组会自动排序: 根据分组字段:默认升序(asc)&lt;br/&gt;Group by 字段 [asc|desc]; -- 对分组的结果然后合并之后的整个结果进行排序&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; sex,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*),&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(age),&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(height),&lt;span class=&quot;fu&quot;&gt;min&lt;/span&gt;(height),&lt;span class=&quot;fu&quot;&gt;avg&lt;/span&gt;(age),&lt;span class=&quot;fu&quot;&gt;sum&lt;/span&gt;(age) &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; sex &lt;span class=&quot;kw&quot;&gt;desc&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;多字段分组: 先根据一个字段进行分组,然后对分组后的结果再次按照其他字段进行分组&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode q&quot;&gt;
&lt;code class=&quot;sourceCode r&quot;&gt;--&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;多字段分组:&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;先班级,后男女
select c_id,sex,&lt;span class=&quot;kw&quot;&gt;count&lt;/span&gt;(*),&lt;span class=&quot;kw&quot;&gt;group_concat&lt;/span&gt;(name) from my_student group by c_id,sex; --&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;多字段排序&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;扩展--回溯统计&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;having-子句&quot;&gt;having 子句&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Having子句: 与where子句一样: 进行条件判断的.&lt;/li&gt;
&lt;li&gt;Where是针对磁盘数据进行判断: 进入到内存之后,会进行分组操作: 分组结果就需要having来处理.&lt;/li&gt;
&lt;li&gt;Having能做where能做的几乎所有事情, 但是where却不能做having能做的很多事情.&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;分组统计的结果或者说统计函数都只有having能够使用.&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 求出所有班级人数大于等于2的学生人数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; c_id,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id &lt;span class=&quot;kw&quot;&gt;having&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*) &amp;gt;= &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; c_id,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*) &amp;gt;= &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id ; &lt;span class=&quot;co&quot;&gt;--失败，where不能使用函数count等&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;Having能够使用字段别名: where不能: where是从磁盘取数据,而名字只可能是字段名: 别名是在字段进入到内存后才会产生&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; c_id,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; total &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id &lt;span class=&quot;kw&quot;&gt;having&lt;/span&gt; total &amp;gt;= &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; c_id,&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;(*) &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; total &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; total &amp;gt;= &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id ; &lt;span class=&quot;co&quot;&gt;-- 失败 where不能使用别名&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;order-by子句&quot;&gt;order by子句&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Order by: 排序, 根据某个字段进行升序或者降序排序, 依赖校对集.&lt;/li&gt;
&lt;li&gt;使用基本语法&lt;/li&gt;
&lt;li&gt;Order by 字段名 [asc|desc]; -- asc是升序(默认的),desc是降序&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- group by 排序&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id;
&lt;span class=&quot;co&quot;&gt;-- order by 排序&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;排序可以进行多字段排序: 先根据某个字段进行排序, 然后排序好的内部,再按照某个数据进行再次排序&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 多字段排序: 先班级排序,后性别排序&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_student &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; c_id, sex &lt;span class=&quot;kw&quot;&gt;desc&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;limit子句&quot;&gt;limit子句&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Limit子句是一种限制结果的语句: 限制数量.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Limit有两种使用方式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;只用来限制长度(数据量): limit 数据量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;sql -- 查询学生: 前两个 select * from my_student limit 2;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;限制起始位置,限制数量: limit 起始位置,长度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;sql -- 查询学生: 前两个 select * from my_student limit 0,2; -- 记录数是从0开始编号 select * from my_student limit 2,2; select * from my_student limit 4,2;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;# 连接查询&lt;/p&gt;
&lt;h2 id=&quot;交叉连接&quot;&gt;交叉连接&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;cross join：从一张表中循环取出每一条记录，每条记录都会去另外一张表进行匹配，因为没有匹配条件，所以匹配结果一定会保留，最终连接本身字段就会增加(保留)，结果就是笛卡尔积，得到的数据没有什么意义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;左表 cross join 右表&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;from 左表，右表 --就是多表查询&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;```sql&lt;br/&gt;select * from my_pri1 cross join t2;&lt;/p&gt;
&lt;p&gt;select * from my_pri1,t2;&lt;br/&gt;```&lt;/p&gt;
&lt;h2 id=&quot;内连接&quot;&gt;内连接&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;inner join：从左表中取出每一条记录，去右表中与所有的记录进行匹配，匹配必须是某个条件，在左表中与右表中相同时，最终才会保留结果，否则不保留&lt;/li&gt;
&lt;li&gt;基本语法&lt;/li&gt;
&lt;li&gt;左表 [inner] join 右表 on 左表.字段 = 右表.字段&lt;/li&gt;
&lt;li&gt;on表示连接条件，条件子弹就是代表相同的业务含义，就是当 左表.字段 = 右表.字段时才会保留结果&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_pri1 &lt;span class=&quot;kw&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; t2 &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; my_pri1.pri_id = t2.id;

&lt;span class=&quot;co&quot;&gt;--简写，就是使用join，省略inner&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_pri1  &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; t2 &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; my_pri1.pri_id = t2.id;

&lt;span class=&quot;co&quot;&gt;-- 使用别名&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_pri1 &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; p &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; t2 &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; t &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; p.pri_id = t.id;

&lt;span class=&quot;co&quot;&gt;-- 省略 as&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_pri1  p &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; t2  t &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; p.pri_id = t.id;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;若是内连接不使用on之后的条件进行查询，就相当于交叉连接，得到的结果也是一个笛卡尔积&lt;/li&gt;
&lt;li&gt;内连接可以使用where代替on关键字，但是where没有on效率高&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; my_pri1 p &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; t2 t &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; p.pri_id = t.id;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;外连接&quot;&gt;外连接&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;outer join：以某张表为主(主表)，取出主表中的每一条数据，然后每条记录与另外一张表(副表)进行连接，不管能不能匹配上条件，最终都会保留，能匹配，正确保留，不能正确匹配的，将副表的字段全部置空&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外连接分类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;left join：左外连接(左连接)，以左表为主表&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;right join：右外连接(右连接)，以右表为主表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;```sql&lt;br/&gt;-- 左连接&lt;br/&gt;select * from my_pri1 p left join t2 t on p.pri_id = t.id;&lt;/p&gt;
&lt;p&gt;-- 右连接&lt;br/&gt;select * from my_pri1 p right join t2 t on p.pri_id = t.id;&lt;br/&gt;```&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虽然左连接和右连接有主表差异, 但是显示的结果: 左表的数据在左边,右表数据在右边.&lt;/li&gt;
&lt;li&gt;左连接和右连接可以互转.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;自然连接&quot;&gt;自然连接&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;natural join：自然连接就是自动匹配连接条件，系统以字段名字作为匹配模式，同名字段就作为条件，多个同名字段都作为条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自然连接分类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;自然内连接：左表 natural join 右表&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自然连接自动使用同名字段作为连接条件，连接之后合并同名字段&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;sql select * from my_pri1 natural join t2;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自然外连接: 左表 natural left/right join 右表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;sql select * from my_pri1 natural left join t2;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;# 外键&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外键：foreign key，外面的键，键不在自己表中&lt;/li&gt;
&lt;li&gt;如果一张表中有一个字段(非主键)指向另外一张表的主键，那么将该字段称之为外键&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;增加外键&quot;&gt;增加外键&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;外键可以在创建表的时候或者创建表之后增加，但是要考虑数据的问题&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一张表可以有多个外键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建表的时候增加外键，在所有的表字段之后增加外键， foreign key(外键字段) references 外部表(主键字段)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_foreign1(
    &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt; auto_increment,
    name &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'学生姓名'&lt;/span&gt;,
    c_id &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'班级id'&lt;/span&gt;,    &lt;span class=&quot;co&quot;&gt;-- 普通字段&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- 增加外键&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;(c_id) &lt;span class=&quot;kw&quot;&gt;references&lt;/span&gt; my_class(&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;)
)charset utf8;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在新增表之后增加外键：修改表结构&lt;/li&gt;
&lt;li&gt;alter table 表名 add [constraint 外键名字] foreign key(外键字段) references 父表(主键字段)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 创建表&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_foreign2(
&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt; auto_increment,
name &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'学生姓名'&lt;/span&gt;,
c_id &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;comment&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'班级id'&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- 普通字段&lt;/span&gt;
)charset utf8;

&lt;span class=&quot;co&quot;&gt;-- 增加外键&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_foreign2 &lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- 指定外键名&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;constraint&lt;/span&gt; student_class_1
&lt;span class=&quot;co&quot;&gt;-- 指定外键字段&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;(c_id)
&lt;span class=&quot;co&quot;&gt;-- 引用父表主键&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;references&lt;/span&gt; my_class(&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;更新删除外键&quot;&gt;更新、删除外键&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;外键不能修改，只能先删除后新增&lt;/li&gt;
&lt;li&gt;alter table 表名 drop foreign key 外键名&lt;/li&gt;
&lt;li&gt;一张表中可以有多个外键，但是名字不能重复，删除的时候必须指定外键的名字&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 删除外键&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; my_foreign1 &lt;span class=&quot;kw&quot;&gt;drop&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;foreign&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt; my_foreign1_ibfk_1;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;外键作用&quot;&gt;外键作用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;外键默认的作用有两种，一个是对父表，一个对字表(外键字段所在的表)&lt;/li&gt;
&lt;li&gt;对子表约束，字表数据进行操作(增和改)的时候，如果对应的外键字段在父表找不到对应的匹配，则操作会失败(约束字表数据操作)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
&lt;span class=&quot;co&quot;&gt;-- 插入数据：外键字段在父表中不存在&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_foreign2 &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'张自忠'&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;-- 没有4班级&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_foreign2 &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'项羽'&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;); 
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_foreign2 &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'刘邦'&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;); 
&lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; my_foreign2 &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'韩信'&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;); &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;对父表约束：父表数据进行操作(删、改都必须涉及到主键本身)，如果对应的主键在子表中已经被数据引用，那么就不允许操作&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- 更新父表记录&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt; my_class &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;-- 失败: id=1记录已经被学生引用&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;update&lt;/span&gt; my_class &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;-- 可以: 没有引用&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;外键条件&quot;&gt;外键条件&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;外键要存在：首先必须保证表的存储引擎是innodb(默认的存储引擎，如果不是innodb存储引擎，那么外键可以创建成功，但是没有约束效果&lt;/li&gt;
&lt;li&gt;外键字段的字段类型(列类型)必须与父表的主键类型完全一致&lt;/li&gt;
&lt;li&gt;一张表中的外键名字不能重复&lt;/li&gt;
&lt;li&gt;增加外键的字段(数据已经存在)，必须保证数据与父表主键要求对应&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;外键约束&quot;&gt;外键约束&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;外键约束就是外键的作用&lt;/li&gt;
&lt;li&gt;外键约束有三种约束模式，都是针对父表的约束&lt;/li&gt;
&lt;li&gt;District: 严格模式(默认的), 父表不能删除或者更新一个已经被子表数据引用的记录&lt;/li&gt;
&lt;li&gt;Cascade: 级联模式: 父表的操作, 对应子表关联的数据也跟着被删除&lt;/li&gt;
&lt;li&gt;Set null: 置空模式: 父表的操作之后,子表对应的数据(外键字段)被置空&lt;/li&gt;
&lt;li&gt;通常的一个合理的做法(约束模式): 删除的时候子表置空, 更新的时候子表级联操作指定模式的语法&lt;/li&gt;
&lt;li&gt;Foreign key(外键字段) references 父表(主键字段) on delete set null on update cascade&lt;/li&gt;
&lt;li&gt;更新操作: 级联更新&lt;/li&gt;
&lt;li&gt;删除操作: 置空&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 10 May 2018 15:36:00 +0000</pubDate>
<dc:creator>wyao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nordon-wang/p/9022406.html</dc:identifier>
</item>
<item>
<title>Linux(Redhat)安装Redis - lfalex</title>
<link>http://www.cnblogs.com/lfalex0831/p/9022400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lfalex0831/p/9022400.html</guid>
<description>&lt;p&gt;Redis是一个开源的使用ANSI &lt;a href=&quot;https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80&quot; target=&quot;_blank&quot;&gt;C语言&lt;/a&gt;编写、支持网络、可基于内存亦可持久化的日志型、Key-Value&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93&quot; target=&quot;_blank&quot;&gt;数据库&lt;/a&gt;，并提供多种语言的API。（百度百科 0.0）&lt;/p&gt;
&lt;p&gt;下载：&lt;a href=&quot;http://www.redis.cn/&quot; target=&quot;_blank&quot;&gt;http://www.redis.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、将下载的redis-4.0.9.tar.gz放置/usr/local目录下，并解压:&lt;/p&gt;
&lt;p&gt;　　tar xzf redis-4.0.9.tar.gz&lt;/p&gt;
&lt;p&gt;2、进入redis-4.0.9目录下，编译并安装：&lt;/p&gt;
&lt;p&gt;　　①、make&lt;/p&gt;
&lt;p&gt;　　②、make install&lt;/p&gt;
&lt;p&gt;　　当我执行编译时，报错：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1244002/201805/1244002-20180510231630011-537574372.png&quot; alt=&quot;&quot; width=&quot;1313&quot; height=&quot;560&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　排查错误，发现未安装gcc，安装gcc及相关依赖包(XXXX为相关版本号，视自己情况而定)，可以使用linux光驱挂载，直接使用linux的系统盘内置rpm包：&lt;/p&gt;
&lt;p&gt;　　　　rpm -ivh glibc-devel-XXXX.rpm&lt;/p&gt;
&lt;p&gt;　　　　rpm -ivh cpp-XXXX.rpm&lt;br/&gt;　　　　rpm -ivh binutils-XXXX.rpm&lt;br/&gt;　　　　rpm -ivh gcc-XXXX.rpm&lt;/p&gt;
&lt;p&gt;　　　　rpm -ivh mpfr-XXXX.rpm&lt;/p&gt;
&lt;p&gt;　　　　rpm -ivh jemalloc-XXXX.rpm&lt;/p&gt;

&lt;p&gt;3、在/usr/下创建redis目录，并将编译安装后的src目录下的redis-server、redis-cli、redis-benchmark复制到/usr/redis下：&lt;/p&gt;
&lt;p&gt;　　mkdir /usr/redis&lt;/p&gt;
&lt;p&gt;　　cd src&lt;/p&gt;
&lt;p&gt;　　cp redis-server /usr/redis&lt;/p&gt;
&lt;p&gt;　　cp redis-cli /usr/redis&lt;/p&gt;
&lt;p&gt;　　cp redis-benchmark /usr/redis&lt;/p&gt;
&lt;p&gt;4、将redis-4.0.9目录下的redis.conf复制到/usr/redis目录下，并作以下修改：&lt;/p&gt;
&lt;p&gt;　　①、将bind的127.0.0.1改为linux系统的本地ip，例：bind 127.0.0.1  ==&amp;gt;  bind 192.168.1.121 （&lt;span&gt;注意：bind的意思不是绑定外部服务器的IP，而是绑定本机可以接受访问的IP&lt;/span&gt;）；&lt;/p&gt;
&lt;p&gt;　　②、将daemonize的no改为yes ;&lt;/p&gt;
&lt;p&gt;5、启动redis:&lt;/p&gt;
&lt;p&gt;　　redis-server redis.conf&lt;/p&gt;
&lt;p&gt;　　启动完成（注意将防火墙关闭或者改iptables对外提供端口）&lt;/p&gt;

&lt;div&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1244002/201805/1244002-20180510233315137-883754468.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 10 May 2018 15:34:00 +0000</pubDate>
<dc:creator>lfalex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lfalex0831/p/9022400.html</dc:identifier>
</item>
<item>
<title>Dynamic CRM  中修改实体中主字段的长度 - hongsedigua</title>
<link>http://www.cnblogs.com/hongsedigua/p/9022391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongsedigua/p/9022391.html</guid>
<description>&lt;p&gt;select EntityId,* from MetadataSchema.Entity where Name='dji_incidentaddress'&lt;/p&gt;
&lt;p&gt;SELECT TOP 100 [AttributeId]&lt;br/&gt;,[AttributeTypeId]&lt;br/&gt;FROM [MetadataSchema].[Attribute]&lt;br/&gt;WHERE PhysicalName = 'dji_name' AND EntityId='78B02832-6167-47E0-A966-AB425A61091C'&lt;/p&gt;
&lt;p&gt;Update Attribute&lt;br/&gt;SET MaxLength = 2000,&lt;br/&gt;length=1000&lt;br/&gt;WHERE PhysicalName = 'dji_name' AND AttributeId='66B7E34C-4F2F-4592-85CC-3E3F0794F5EB'&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 15:32:00 +0000</pubDate>
<dc:creator>hongsedigua</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongsedigua/p/9022391.html</dc:identifier>
</item>
<item>
<title>SpringCloud实战-Ribbon客户端负载均衡 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/9022055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9022055.html</guid>
<description>&lt;p&gt;前面我们已经完成了注册中心和服务提供者两个基础组件。接着介绍使用Spring Cloud Ribbon在客户端负载均衡的调用服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ribbon 是一个客户端负载均衡器，可以简单的理解成类似于 nginx的负载均衡模块的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主流的LB方案可分成两类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;一种是集中式LB, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；&lt;/p&gt;
&lt;p&gt;　　另一种是进程内LB，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。&lt;/p&gt;

&lt;p&gt;　　Ribbon的架构图：如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510210043269-156245862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.首先我们先在原来的基础上新建一个Ribbon模块，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510205719787-1067413754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们单独使用ribbon，在Ribbon模块下添加依赖，如下图所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt;
       &amp;lt;version&amp;gt;1.4.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改application.yml文件，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8082&lt;span&gt;
spring:
  application:
    name: Ribbon&lt;/span&gt;-&lt;span&gt;Consumer
#providers这个是自己命名的，ribbon,listOfServer这两个是规定的
providers:
  ribbon:
    listOfServers: localhost:&lt;/span&gt;8080,localhost:8081
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Ribbon模块下新建一个测试类如下代码&lt;span&gt; * Created by cong on 2018/5/8.&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {
&lt;br/&gt;　　//注入负载均衡客户端
&lt;/span&gt;&lt;span&gt;  　@Autowired&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    private LoadBalancerClient loadBalancerClient;&lt;/span&gt;&lt;span&gt;

    @RequestMapping(&lt;/span&gt;&quot;/consumer&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String helloConsumer() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {&lt;br/&gt;　　　　　//这里是根据配置文件的那个providers属性取的
&lt;/span&gt;&lt;span&gt;        ServiceInstance serviceInstance = loadBalancerClient.choose(&quot;providers&quot;);&lt;br/&gt;　　　　　　//负载均衡算法默认是轮询，轮询取得服务
&lt;/span&gt;&lt;span&gt;        URI uri = URI.create(String.format(&quot;http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;%s:%s&quot;, serviceInstance.getHost(), serviceInstance.getPort()));
&lt;/span&gt;&lt;span&gt;        return uri.toString();&lt;br/&gt;　　}&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;　　会轮询的获取到两个服务的URL 访问第一次，浏览器出现http://localhost:8080  访问第二次就会出现http://localhost:8081&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510211424387-1482257611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在这里给普及一下有哪些负载均衡算法：&lt;/p&gt;

&lt;p&gt;　　1:简单轮询负载均衡（RoundRobin）&lt;/p&gt;
&lt;p&gt;    　　 以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。&lt;/p&gt;

&lt;p&gt;   2:随机负载均衡 （Random）&lt;/p&gt;
&lt;p&gt;    　　 随机选择状态为UP的Server&lt;/p&gt;

&lt;p&gt;   3:加权响应时间负载均衡 （WeightedResponseTime）&lt;/p&gt;
&lt;p&gt;     根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。&lt;/p&gt;

&lt;p&gt;   4:区域感知轮询负载均衡（ZoneAvoidanceRule）&lt;/p&gt;
&lt;p&gt;    　　 复合判断server所在区域的性能和server的可用性选择server&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510211644468-795865311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510211703313-723677962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有兴趣的还可以看一下我在Ngnix的随笔文章中列出的负载均衡算法实现&lt;/strong&gt;：http://www.cnblogs.com/huangjuncong/p/8319182.html&lt;/p&gt;
&lt;p&gt;如果想配置其他轮询算法在yml配置文件中配置，如下配置一个随机算法所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;8082&lt;span&gt;
spring:
  application:
    name: Ribbon&lt;/span&gt;-&lt;span&gt;Consumer
#providers这个是自己命名的，ribbon,listOfServer这两个是规定的
providers:
  ribbon:
    listOfServers: localhost:&lt;/span&gt;8080,localhost:8081&lt;span&gt;

##如果不想选用默认的轮询的负载均衡算法，在这里做如下配置
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着在启动类动一下手脚让我们配置的随机算法的负载均衡生效，只需要实现一个实现了IRule接口的Bean即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; hjc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.IRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.RandomRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.discovery.EnableDiscoveryClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(RibbonApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule ribbonRule(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RandomRule();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此重新启动Ribbon启动类，得到的结果是随机的，如下所示：&lt;/p&gt;
&lt;p&gt;　　浏览器随机出现http://localhost:8080 或者http://localhost:8081&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么问题来了，服务的地址是写死在配置文件中，如果某个服务挂了，那么还会把请求转发到挂掉的服务中，因此，解决的办法是，跟Eureka对接，结合一起用。就可以依靠Eureka动态的获取一个可用的服务列表，隔一段时间我就更新一次，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者Eureka设置一个监听端口，某一个服务挂了，Eureka通知我，我会知道，变更服务列表，这样不久形成一个闭环了吗？这样就不存在高可用性问题了。跟Eureka配合一起用同时解决了的Ribbon的单点故障问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第一步，毫无疑问就是修改Ribbon模块的pom.xml文件，加入如下依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.3.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步，修改yml配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;8082&lt;/span&gt;&lt;span&gt;
spring:
  application:
    name: Ribbon&lt;/span&gt;-&lt;span&gt;Consumer

eureka:
#客户端
  client:
#注册中心地址
    service&lt;/span&gt;-&lt;span&gt;url:
      defaultZone: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8888/eureka/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8889/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以跟Eureka结合，这样Ribbon就可以通过Eureka动态的获取服务列表&lt;/p&gt;

&lt;p&gt;接着在启动类加上服务发现注解，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
@EnableDiscoveryClient
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动类接着声明一个负载均衡的请求器@LoadBalanced，还有请求发起的工具RestTemplate&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(RibbonApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
&lt;/span&gt;&lt;span&gt;

    @Bean
    @LoadBalanced
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着我们在上一节文章中的两个provider1，provider2模块添加一下测试代码：如下：&lt;/p&gt;
&lt;p&gt;provider1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.hello;


import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;provider2代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.hello;


import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着我们用RestTemplate进行面向服务调用，不再面向IP调用。&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {



    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  RestTemplate restTemplate;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/consumer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String helloConsumer() throws ExecutionException, InterruptedException {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; restTemplate.getForEntity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://HELLO-SERVICE/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,String.&lt;span&gt;class&lt;/span&gt;).getBody();&lt;p&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着启动Ribbon模块，我们看一下Eureka仪表盘，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180510214829108-682598453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到多了RIBBON-CONSUMER服务&lt;/p&gt;

&lt;p&gt;接着我们继续在已经运行的Ribbon模块上，在浏览器输入localhost:8082,运行结果如下：&lt;/p&gt;
&lt;p&gt;　　hello1或者hello2，&lt;/p&gt;
&lt;p&gt;可以看到hello1 ，hello2轮询方式出现，因为默认就是轮询方式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;到这里我们还发现Ribbon还是单点故障的，这里我来解释一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为这里我是单独建立一个SpringBoot的Ribbon模块，实际使用并不是这样用的，Ribbon是客户端的负载均衡，是跟客户端绑定在一起的，我们实际运用的时候往往会在服务里面引入一个客户端负载均衡去连接到Eureka客户中心，&lt;/p&gt;
&lt;p&gt;这样我们还存在Ribbon单点故障吗？不存在了，因为我们服务提供者就是高可用的，这样还是个单点吗？这里读者的思考必须转过弯来，这一篇随笔我只是为了演示Ribbon,实际使用并不是这样用的。&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 15:06:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9022055.html</dc:identifier>
</item>
<item>
<title>QUIC协议的分析，性能测试以及在QQ会员实践 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9022214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9022214.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;WeTest 导读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你听过HTTPS、HTTP2.0、SPDY，但是这些应用层协议都是基于可靠的传输层协议TCP来实现的。那么，基于高效的UDP协议有没有一种相对可靠的应用层协议呢？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Why QUIC?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你听过HTTPS、HTTP2.0、SPDY，但是这些应用层协议都是基于可靠的传输层协议TCP来实现的。那么，基于高效的UDP协议有没有一种相对可靠的应用层协议呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223709979-217992775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图1 why quic?&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;What is QUIC?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Quick UDP Internet Connection(QUIC)协议是Google公司提出的基于UDP的高效可靠协议。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;说它高效，是因为使用了无连接的UDP而不是迭代周期更长的需要修改系统内核网络栈的TCP协议。&lt;br/&gt;说它可靠，是因为将改进了的可靠TCP的协议特征用到了QUIC上。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;同时，也复用和改进了HTTP2的典型特征，譬如二进制分帧，多路复用，header压缩等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223718848-443035167.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 what's quic?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;How QUIC works?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;建立连接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、基于TCP+TLS的HTTP2建连&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;出于HTTP的明文和无法验证服务器的真实性，在TCP的基础上引入了TLS协议，目前广泛使用的HTTPS是基于TCP+TLS协议，HTTP2也被主流浏览器默认支持TLS。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;但对于建立连接的耗时而言，TCP本身就需要握手时延，而TLS协议为了使得客户端和服务器端在不安全的网络通信中协商出后续安全通信所需的加密私钥，更是要经过额外2次RTT(RoundTrip Time往返时间)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223726806-2103569862.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3 TCP+TLS建连过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了TCP建立连接过程，TLS握手过程要经过如下步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、客户端提供加密套件（算法）列表，版本等信息&lt;/p&gt;
&lt;p&gt;2、服务器端提供自己的证书，选择的加密套件，非对称加密公钥（自己保留私钥）等&lt;/p&gt;
&lt;p&gt;3、客户端提供自己的证书，用服务器公钥和加密套件加密的自己的私钥&lt;/p&gt;
&lt;p&gt;4、服务端用保留的私钥解密客户端传来的加密私钥，得到的私钥即为后续加密传输使用的对称密钥，最后完成握手&lt;/p&gt;

&lt;p&gt;此时，双方协商出了对称密钥。基于TCP+TLS的HTTP2建连过程结束，大约需要耗时200-300ms。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、 QUIC建连&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了保证安全，QUIC也是加密传输数据的，所以在QUIC的建连过程中也需要双方协商出一个加密私钥。但与TLS不同，QUIC采用的加密算法仅需要一个RTT就能实现密钥交换，并且该算法也被用于目前正在草案阶段的TLS1.3协议。该就是Diffie-Hellman密钥交换算法。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223803894-1488820547.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4 Diffie-Hellman算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，客户端和服务端各自保留了自己的私钥a和b，通过交换各自的公钥B和A，以及基底G和很大的质数P，双方就能计算出相等的私钥S，这个S就是加密传输的对称密钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;另外，根据离散对数的不可逆，即使拿到G,P,和质数B，也很难推导出私钥b（同理私钥a），也就保证了计算密钥的安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;该过程对应到QUIC建连的过程中如下图&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223810759-505023789.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5 1RTT建连&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、客户端发起Inchoate client hello&lt;/p&gt;
&lt;p&gt;2、服务器返回Rejection，包括密钥交换算法的公钥信息，算法信息，证书信息等被放到server config中传给客户端&lt;/p&gt;
&lt;p&gt;3、客户端发起client hello，包括客户端公钥信息&lt;/p&gt;

&lt;p&gt;此时，双方各自计算出了对称密钥。QUIC的1RTT建连过程结束，平均只耗时100ms以内。&lt;/p&gt;

&lt;p&gt;后续发起连接的过程中，一旦客户端缓存或持久化了server config，就可以复用并结合本地生成的私钥进行加密数据传输了，不需要再次握手，从而实现0RTT建立连接。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;协商升级&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般情况下，Chrome浏览器和服务器端协商使用QUIC协议要经过如下步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、客户端发出tcp请求&lt;/p&gt;
&lt;p&gt;2、服务端如果支持quic可以通过响应头alt-svc告知客户端&lt;/p&gt;
&lt;p&gt;3、客户端同时发起tcp连接和quic连接竞赛&lt;/p&gt;
&lt;p&gt;4、一旦quic建立连接获胜则采用quic协议发送请求&lt;/p&gt;
&lt;p&gt;5、如遇网络或服务器不支持quic/udp，客户端标记quic为broken&lt;/p&gt;
&lt;p&gt;6、传输中的请求通过tcp重发&lt;/p&gt;
&lt;p&gt;7、5min后尝试重试quic，下一次尝试增大到10min&lt;/p&gt;
&lt;p&gt;8、一旦再次成功采用quic并把broken标记取消&lt;/p&gt;

&lt;p&gt;其中，支持quic的alt-svc头部信息如下图示，ma为有效时间（单位秒），v为支持的quic版本信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223826102-674298838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6 alt-svc头信息&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;研究过程中发现，除了alt-svc header，http2.0下服务端还可以通过支持alt-svc frame来让客户端在第一次请求的时候就走新协议，比通过header让浏览器第二次才能请求新协议更高效，这个留给后续研究。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;连接迁移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP使用四元组（源IP，源端口，目的IP，目的端口）来标识一条连接，当四元组中的IP或端口任一个发生变化了连接就需要重新建立，从而不具备连接迁移的能力。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;而QUIC使用了connection id对连接进行唯一标识。即使网络从4G变成了wifi，只要两次连接中的connection id不变，并且客户端或者服务器能通过校验，就不需要重新建立连接，连接迁移就能成功。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;改进的多路复用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在SPDY协议出现以前，每个HTTP请求都需要建立一条TCP连接，那么如果希望请求并行，就需要同时开启多条TCP连接（都是有建连代价的）。而大多数浏览器对于同一个域名可以建立的最大TCP连接数是有限制的，所以，如果超出限制，更多的请求资源是无法并行的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;SPDY协议以来提出的多路复用，是让所有请求基于一条TCP连接，解决了上述的问题但同时引入了新的问题——队头阻塞，如果某个资源的某个包丢失了，因为TCP是保证时序的，就会在接收端形成队头阻塞，TCP此时无法区分各个资源的包是否关联，因此会停止处理所有资源直到丢包恢复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223837035-275432930.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7 基于TCP的多路复用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;QUIC也有多路复用，但是QUIC是基于UDP的，UDP不需要保证包的时序，只会在接收包的时候对包进行重组，因而不存在等待丢包恢复的队头阻塞问题，这样某个资源的包丢失只会影响自身不会影响到其他资源的继续传输，所以是改进的多路复用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223843400-304488573.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8 基于QUIC的多路复用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;双级别流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;QUIC是多路复用的，多条stream可以建立在一条connection上，所以QUIC的流量控制不仅基于单个stream，还基于connection。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;stream级别的流控能够控制单stream的数据发送情况。另外，接收窗口的收缩取决于最大接收字节的偏移而不是所有已接受字节的总和，它不像tcp流控，不会受到丢失数据的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223853057-1761717946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9 stream流控&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果满足(flow control receive offset - consumed bytes) &amp;lt; (max receive window / 2)&lt;br/&gt;会触发WINDOW_UPDATE frame的发送来增大发送窗口大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223906067-1901737156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10 WINDOW_UPDATE触发前&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223913141-685255609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图11 WINDOW_UPDATE触发后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;connection级别流控算法和stream一致，各项数值是所有stream的总和。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;connection级别的流控存在的必要是，即使做好了stream流控，但如果stream过多也会导致connection过度消耗带宽和系统资源；而且即使某一条stream过慢，其他stream依然能触发&lt;/p&gt;

&lt;p&gt;connection级别的WINDOW_UPDATE，从而不会被影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223920279-278118793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图12 connection流控&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥塞控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道TCP有多种拥塞控制算法，当遇到网络拥塞会通过减包等方式来避免网络环境恶化。但是，UDP本身是没有拥塞控制的，一旦不加约束的使用会导致侵占其他“守规矩”的网络协议的带宽。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;所以，为了避免上述情况，基于UDP的QUIC协议借鉴了TCP的一些优秀的拥塞控制算法，如默认使用Cubic，同时，为了避免AIMD机制带来的带宽利用率低，采用了packet pacing来探测网络带宽。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;思路是，QUIC会通过追踪包的到达时间来预测当前带宽的使用情况，以决定是否提高，保持或者减少发送包的速率来避免网络拥塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223928905-536245805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图13 packet pacing&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;丢包恢复&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似拥塞控制，除了基于TCP的一些丢包恢复机制，如：TLP，FACK。QUIC的丢包恢复也在一些方面做了改进。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;比如：通过引入严格递增的sequence number使得计算RTT更加精确。更精确的RTT也意味更精确的RTO和超时重传机制。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;还比如我们知道TCP中有个SACK选项，该选项打开时用于记录传输过程中一些没有被确认的数据的范围，便于后续定向重传多组丢失数据，而不是全部重传，所以更多的范围便于更多的选择重传，也意味着更少的重传包频率。但TCP最多支持3个SACK范围，而QUIC能支持255个。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;除了上述基于TCP的改进的丢包恢复特性以外，早期的QUIC版本还有一个丢包恢复机制，就是FEC（Forward Error Correction），这个特性虽然目前处于正在改造阶段（可能会浪费带宽并且作用不是很明显），但是依然是一个有意思的解决方案。FEC的思路是通过在一组包（一般是10个）中，通过增加一个FEC包，并用FEC和每个包进行XOR，如果一旦有丢包，那么将FEC包和其余包XOR，得到的FEC包就是那个丢包，所以一组包最多只能恢复一个丢包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223936526-1918221228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;更多特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了上述的主要特性，QUIC还有一些其他特性，如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 通过header stream保证流顺序&lt;/p&gt;
&lt;p&gt;● 底层保证连接持久&lt;/p&gt;
&lt;p&gt;● 源地址令牌防止地址欺骗&lt;/p&gt;
&lt;p&gt;● 握手时压缩证书避免放大攻击&lt;/p&gt;

&lt;p&gt;在此不深入研究，大家有兴趣可以翻阅Google相关的文档查阅。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;业界应用情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;● Google超过50%的请求来自QUIC&lt;/p&gt;
&lt;p&gt;● 目前Youtube有20%的流量来自QUIC&lt;/p&gt;
&lt;p&gt;● 微博移动端全面支持QUIC协议&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;测试demo&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;● 客户端&lt;/strong&gt;&lt;br/&gt;最新版本PC Chrome（控制开启/关闭quic）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 服务器&lt;/strong&gt;&lt;br/&gt;经stgw改造支持quic的nginx&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 页面地址（机器被回收，后续会更换机器供测试）&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://stgwquic.kof.qq.com/club/platform/act/gift/test1.html&quot;&gt;https://stgwquic.kof.qq.com/club/platform/act/gift/test1.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stgwquic.kof.qq.com/club/platform/act/gift/test2.html&quot;&gt;https://stgwquic.kof.qq.com/club/platform/act/gift/test2.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stgwquic.kof.qq.com/club/platform/act/gift/test3.html&quot;&gt;https://stgwquic.kof.qq.com/club/platform/act/gift/test3.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 网络&lt;/strong&gt;&lt;br/&gt;公司staffwifi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 抓包工具&lt;/strong&gt;&lt;br/&gt;wireshark&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 效果对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223946843-173400727.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图15 HTTP1.1协议的页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510223956465-65746837.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图16 HTTP2协议的页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224003808-623024835.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图17 QUIC协议的页面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224018186-222890630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图18页面请求20个，大小2MB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224025750-73203067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图 19 页面请求15个，大小465KB&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公司业务接入步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;● 客户端支持&lt;/strong&gt;&lt;br/&gt;X5内核团队（移动端）&lt;/p&gt;
&lt;p&gt;依赖用户浏览器支持QUIC情况（PC端）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 服务端支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;STGW团队&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 业务自身&lt;/strong&gt;&lt;br/&gt;按照路径灰度，控制灰度策略&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ会员页面接入效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上测试demo数据是基于公司良好的网络情况下测试得到的，在实际运用过程中，大家可能更关心在复杂的网络环境下QUIC的表现。于是QQ会员团队通过灰度现网的一个页面来考察QUIC在现网的性能情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 页面情况&lt;/strong&gt;&lt;br/&gt;Android日PV100w，页面大小95KB&lt;br/&gt;总请求30个，其中主资源请求1个，CDN请求24个，其他请求5个&lt;br/&gt;展示部分依赖php直出和js渲染&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 灰度情况&lt;/strong&gt;&lt;br/&gt;QUIC请求1个（php页面主资源），HTTP2请求29个&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 灰度策略&lt;/strong&gt;&lt;br/&gt;客户端每天放量，对比灰度过程中页面主资源的HTTP2和QUIC的性能数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 灰度效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201805/992994-20180510224034766-834086325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图20 QQ会员页面QUIC灰度情况&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 效果说明&lt;/strong&gt;&lt;br/&gt;因为建连依赖于1RTT和0RTT机制，使得QUIC建连平均耗时仅需46ms，比HTTP2的225ms减少180ms左右。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;由于目前灰度量只占到总请求量的10%，因此更严谨的性能对比数据有待进一步提高灰度范围，以上仅作现阶段参考。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;但依然可以看到QUIC在现网环境总体表现忧于HTTP2。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实践QUIC的过程中，我们也遇到了一些需要注意的问题。&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;QUIC支持头部alt-svc的缓存机制面向整个域名&lt;/strong&gt;&lt;br/&gt;业务即使只在一个页面路径下加了支持头部（STGW可以是路径级别支持，X5只能是域名级别支持），浏览器也会根据头部的缓存时长作用于用户访问该域名下的其他页面，但STGW可能只支持了路径级别。所以灰度过程中，尽量使用有独立域名的页面。从而保证尽量不影响其他页面的请求情况（虽然QUIC请求失败会降级H2），尽量减少ma缓存时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 客户端对于QUIC的协商机制有待改善&lt;/strong&gt;&lt;br/&gt;在X5目前的实现机制中，无论如何首次请求都会基于HTTP2，后续才会尝试QUIC，但如果缓存时间设置的不够长（譬如1天），会使得用户一般1天内很难通过再次请求走到QUIC。所以，目前我们做的是推动X5在请求时候让白名单链接直接尝试QUIC。同时，避免缓存时间随着用户退出手Q而失效，推动让其落地。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 目前客户端基于X5的QUIC与一些基于缓存和预加载的页面秒开方案冲突&lt;/strong&gt;&lt;br/&gt;如果你们的页面是基于X5内核，但是使用了上述类似的技术，那么存在一个问题是原本直接通过X5走QUIC协议的页面不直接走X5了，而是基于你当前方案的缓存或者自定义的webview请求方式。于是通过统计数据会发现QUIC的请求量很少，因为上述技术目前还不支持QUIC协议。当前的做法是在QUIC和该方案中二选一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● CDN请求灰度需要自支持&lt;/strong&gt;&lt;br/&gt;由于CDN请求不基于STGW代理，因而需要CDN团队针对业务方域名灰度支持，目前CDN整体处于运营商灰度QUIC阶段。在此之前如果需要灰度CDN请求就需要业务方自己处理转发。&lt;/p&gt;

&lt;p&gt;● &lt;strong&gt;运营商的Qos影响需要更完善的上报数据进行评估&lt;/strong&gt;&lt;br/&gt;使用QUIC协议比较担心的一个问题就是在网络质量差的情况下运行商Qos会对其产生怎样的影响。从目前整体的统计数据，包括慢速用户占比等情况来看，影响不是很大。后续需要推动各方完善上报监控该情况下耗时。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;未来工作List&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;● 和X5团队一起解决首次请求必走HTTP2请求问题&lt;/p&gt;
&lt;p&gt;● 和X5团队一起解决alt-svc缓存有效期落地问题&lt;/p&gt;
&lt;p&gt;● 和终端团队一起解决秒开方案下Webview对QUIC的支持，争取既能使用QUIC协议又能使用秒开方案&lt;/p&gt;
&lt;p&gt;● 配合CDN团队验证QUIC扩大灰度的支持效果&lt;/p&gt;
&lt;p&gt;● 推动各方更细粒度的数据统计完善&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.chromium.org/quic&quot;&gt;http://www.chromium.org/quic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit&quot;&gt;https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;QUIC Crypto Adam Langley Wan-Teh Chang&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007060218&quot;&gt;https://segmentfault.com/a/1190000007060218&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007075961&quot;&gt;https://segmentfault.com/a/1190000007075961&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaofei0859/article/details/77512746&quot;&gt;https://blog.csdn.net/xiaofei0859/article/details/77512746&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://fasterdata.es.net/host-tuning/packet-pacing/&quot;&gt;http://fasterdata.es.net/host-tuning/packet-pacing/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imququ.com/post/http-alt-svc.html&quot;&gt;https://imququ.com/post/http-alt-svc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP over UDP: an Experimental Investigation of QUIC&lt;/p&gt;
&lt;p&gt;QUIC FEC v1 Author: ianswett@google.com Last Updated: 2016-02-19&lt;/p&gt;
&lt;p&gt;Understanding QUIC wire protocol&lt;/p&gt;
&lt;p&gt;IETF93 QUIC BarBoF: Congestion Control and Loss Recovery&lt;/p&gt;
&lt;p&gt;QUIC: Performance and Security at the Transport Layer&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;WeTest压测大师&lt;/span&gt;——&lt;/strong&gt;为了帮助开发者发现服务器端的性能瓶颈，腾讯WeTest开放了压力测试功能，通过基于真实业务场景和用户行为进行压力测试，实现针对性的性能调优，降低服务器采购和维护成本。&lt;/p&gt;

&lt;p&gt;目前压测大师服务了包括王者荣耀、QQ飞车手游、QQ炫舞手游等多款高星级手游， 也服务了QQ、NOW直播、摩拜单车、企鹅FM等明星产品。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目前&lt;/span&gt;WeTest&lt;span&gt;压测大师对外开放中，点击链接：&lt;/span&gt;&lt;a href=&quot;http://wetest.qq.com/gaps/?from=content_cnblogs&quot;&gt;&lt;span&gt;http://wetest.qq.com/gaps&lt;/span&gt;&lt;/a&gt; &lt;span&gt;即可使用。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;如果对使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;腾讯WeTest有奖征文活动进行中，欢迎投稿！了解详情： http://wetest.qq.com/lab/view/379.html&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 10 May 2018 14:47:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9022214.html</dc:identifier>
</item>
<item>
<title>在Web中获取MAC地址 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9022187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9022187.html</guid>
<description>&lt;p&gt;　　很多时候都很难琢磨客户在想什么，也许是自己业务经验不足，也许是客户要显示出他在软件方面也非常的专业。记得以前听过一个故事，说一个富人想娶个媳妇，然后他比较钟意的有三个女人，然后就想从三个女人中选一个，他分别给了三个女人各一千块钱，并对她们说，“我这里有一个房间，请你们用自己的一千块钱尽可能的将房间填满”。第一个女人，将1000块钱都买了棉花，但是这些棉花只填满了整个房间的三分之一；第二个女人，将1000块钱都买了气球，但是这些气球也只填满了整个房间的三分之二；第三个女人，花了1块钱买了一支蜡烛，让蜡烛的光照亮了整个房间。然后……这个富人愉快的娶了其中胸部最大的那个女人。这个故事告诉我们，有时你根本不知道客户到底要的是什么！&lt;/p&gt;

&lt;p&gt;解决安全登录的问题&lt;/p&gt;
&lt;p&gt;　　去给客户演示系统，演示完刚开发完的系统以后客户就将我们的系统批的遍体鳞伤，这时才知道自己的系统比想象中的更不堪。在如此不堪的系统面前，客户又提出了一个需求，要限制用户的登录机器。补充一下，演示的系统是一个ERP系统，是BS结构的，用Java写的。客户要求，要限制能够登录系统的电脑，需要绑定MAC地址。因为系统里的数据比较重要，不能让员工回家登录系统，因此必须要进行限制。&lt;/p&gt;

&lt;p&gt;解决思路&lt;/p&gt;
&lt;p&gt;　　这样的问题，能想到的解决思路只有两个：&lt;/p&gt;
&lt;p&gt;　　1、在EXE文件中嵌入一个浏览器控件，浏览器中显示ERP的页面，EXE获取MAC地址后提交到服务器。感觉这样先是要处理EXE提交的MAC地址，然后还要和页面交互，想想貌似比较复杂，就否掉了。&lt;/p&gt;
&lt;p&gt;　　2、写一个OCX，让页面中的JS与OCX进行交互，OCX获取到MAC地址后，将MAC返回给JS，JS通过DOM操作写入到对应的表单中，然后和用户名、密码一起提交给服务器。感觉这个好像实现起来还比较简单。就这个吧！&lt;/p&gt;

&lt;p&gt;OCX中获取MAC地址的关键代码&lt;/p&gt;
&lt;p&gt;　　OCX中可以直接调用Windows操作系统的API函数，写起来也比较简单，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; BSTR CGetMacCtrl::GetMacAddress(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    AFX_MANAGE_STATE(AfxGetStaticModuleState());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    CString strResult;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: 在此添加调度处理程序代码&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     ULONG outBufLen = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(IP_ADAPTER_ADDRESSES);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     PIP_ADAPTER_ADDRESSES pAddresses = (IP_ADAPTER_ADDRESSES*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(outBufLen);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (pAddresses ==&lt;span&gt; NULL) 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make an initial call to GetAdaptersAddresses to get the necessary size into the ulOutBufLen variable&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(GetAdaptersAddresses(AF_UNSPEC, &lt;span&gt;0&lt;/span&gt;, NULL, pAddresses, &amp;amp;outBufLen) ==&lt;span&gt; ERROR_BUFFER_OVERFLOW)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pAddresses);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         pAddresses = (IP_ADAPTER_ADDRESSES*)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(outBufLen);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pAddresses ==&lt;span&gt; NULL) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     wchar_t acMAC[&lt;span&gt;32&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(GetAdaptersAddresses(AF_UNSPEC, &lt;span&gt;0&lt;/span&gt;, NULL, pAddresses, &amp;amp;outBufLen) ==&lt;span&gt; NO_ERROR)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If successful, output some information from the data we received&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(PIP_ADAPTER_ADDRESSES pCurrAddresses = pAddresses; pCurrAddresses != NULL; pCurrAddresses = pCurrAddresses-&amp;gt;&lt;span&gt;Next)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确保MAC地址的长度为 00-00-00-00-00-00&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(pCurrAddresses-&amp;gt;PhysicalAddressLength != &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             wsprintf((LPWSTR)acMAC, _T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%02X-%02X-%02X-%02X-%02X-%02X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]),
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; (pCurrAddresses-&amp;gt;PhysicalAddress[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pAddresses);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     strResult =&lt;span&gt; acMAC;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; strResult.AllocSysString();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码差不多就这样吧，我用的VS2012写的ActiveX，编译生成OCX。&lt;/p&gt;

&lt;p&gt;在Web中进行测试&lt;/p&gt;
&lt;p&gt;　　在Web中测试也比较简单，通过clsid引入OCX文件，然后JS调用OCX文件中的函数，函数返回MAC地址给JS，JS进行DOM操作，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&quot;utf8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;获取Mac地址Demo&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;object id=&quot;getmac&quot; classid=&quot;clsid:52931A6A-93B4-4750-8FE6-B666E90B1D54&quot; 
&lt;span&gt; 9&lt;/span&gt;         codebase=&quot;'getmac.ocx'&quot; style=&quot;display:none&quot;&amp;gt;&amp;lt;/object&amp;gt;
&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         &amp;lt;h1&amp;gt;MAC:&amp;lt;/h1&amp;gt;
&lt;span&gt;12&lt;/span&gt;         &amp;lt;span id=&quot;mac&quot;&amp;gt;&amp;lt;/span&amp;gt;
&lt;span&gt;13&lt;/span&gt;         &amp;lt;input type=&quot;text&quot; id=&quot;macAddress&quot; name=&quot;macAddress&quot; value=&quot;&quot; /&amp;gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;15&lt;/span&gt;         &amp;lt;script&amp;gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mac =&lt;span&gt; getmac.GetMacAddress();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             document.getElementById(&quot;mac&quot;).innerHTML =&lt;span&gt; mac;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             document.getElementById(&quot;macAddress&quot;).value =&lt;span&gt; mac;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             document.getElementById(&quot;macAddress&quot;).style.display = ''&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;21&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过object标签引入了OCX文件，定义了id为getmac，然后通过getmac来调用OCX中的函数GetMacAddress()获取MAC地址。&lt;/p&gt;

&lt;p&gt;　　经过简单的测试还是可以的，然后我整合进入了JeeSite系统中（我其他文章说过，我们的项目是在JeeSite上做二次开发），测试以后发现ERP的页面对IE浏览器支持不好。因为OCX只能在IE浏览器中使用，结果这个方案就放弃了。后来，找到一个开源的Chrome的插件，也完成MAC地址的获取，该Chrome插件分为两部分，一部分是Chrome的插件，另外一个是EXE文件，该EXE文件也是与插件进行通信的，由于该插件不是我写的，我就不往这里放了。总之，最好还是把客户端这个需求解决了。OCX的方法就留在这里吧！也许，我以后会用到也说不定呢。&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 14:41:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9022187.html</dc:identifier>
</item>
<item>
<title>springboot~为Money类型添加最大值和最小值的注解校验 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/9021681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/9021681.html</guid>
<description>&lt;p&gt;&lt;span&gt;在spring框架里，为我们集成了很多校验注解，直接在字段上添加对应的注解即可，这些注解基本都是简单保留类型的，即int,long,float,double,String等，而如果你自己封装了新的类，那么如果要校验它，注解这块需要自己写一下，像money这个类型，如果希望对它进行校验，注解这块需要自己去写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;普通类型的注解校验&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; /**&lt;/span&gt;&lt;span&gt;
   * 编号.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @NotBlank(message &lt;/span&gt;= &quot;部门编号不能为空。&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String code;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 名称.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @NotBlank(message &lt;/span&gt;= &quot;部门名称不能为空。&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;自定义的注解校验&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一 注解类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.validation.Constraint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.validation.Payload;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 最小值约束.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy &lt;/span&gt;= MinMoneyHandle.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MinMoney {
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * message.
   *
   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
   &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  String message() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;{minMoney.message.error}&quot;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * min value.
   *
   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
   &lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;double&lt;/span&gt; value() &lt;span&gt;default&lt;/span&gt; 0&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * group.
   *
   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
   &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  Class&lt;/span&gt;&amp;lt;?&amp;gt;[] groups() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * payload.
   *
   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
   &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Payload&amp;gt;[] payload() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二 处理类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.validation.ConstraintValidator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.validation.ConstraintValidatorContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.javamoney.moneta.Money;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * min handle.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MinMoneyHandle &lt;span&gt;implements&lt;/span&gt; ConstraintValidator&amp;lt;MinMoney, Money&amp;gt;&lt;span&gt; {
  MinMoney constraint;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize(MinMoney constraint) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.constraint =&lt;span&gt; constraint;
  }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * valid.
   *
   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value   .
   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context .
   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
   &lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isValid(Money value, ConstraintValidatorContext context) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value.getNumber().doubleValue() &amp;gt;=&lt;span&gt; constraint.value();
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三 使用，直接在实体上添加对应的注解即可，注解里的字段有自己的默认值，程序员也可以显示为他们赋值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Builder
@Getter
@ToString
@NoArgsConstructor
@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;
  @MinMoney(value &lt;/span&gt;= 0, message = &quot;金额不能小于0.&quot;&lt;span&gt;)
  @MaxMoney(value &lt;/span&gt;= 10, message = &quot;金额不能大于10.&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Money price;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后通过WebClientTest进行测试即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest(webEnvironment &lt;/span&gt;=&lt;span&gt; SpringBootTest.WebEnvironment.RANDOM_PORT)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValidateTest {
  @Autowired
  WebTestClient webTestClient;

  @Test
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
    UserInfo entity &lt;/span&gt;=&lt;span&gt; UserInfo.builder()
        .price(Money.of(&lt;/span&gt;100, &quot;CNY&quot;&lt;span&gt;))
        .build();
    val obj &lt;/span&gt;=&lt;span&gt; webTestClient.post()
        .uri(&lt;/span&gt;&quot;/add&quot;&lt;span&gt;)
        .body(BodyInserters.fromObject(entity))
        .exchange()
        .expectStatus().isEqualTo(&lt;/span&gt;400&lt;span&gt;)
        .expectBody();

  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感谢各位的阅读！&lt;/p&gt;
&lt;p&gt;今天自己写出了这个注解，感谢很有成就，哈哈！&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;http://dolszewski.com/spring/custom-validation-annotation-in-spring/&quot; target=&quot;_blank&quot;&gt;http://dolszewski.com/spring/custom-validation-annotation-in-spring/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 12:54:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/9021681.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构—目录 - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/9016600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/9016600.html</guid>
<description>&lt;p&gt;　　首先，有一点要声明，下面所有文章的所有内容的代码，都不是我一个人独立完成的，它们来自于一本叫做《学习JavaScript数据结构和算法》（第二版），人民邮电出版社出版的这本书。github代码地址是&lt;a href=&quot;https://github.com/loiane/javascript-datastructures-algorithms&quot; target=&quot;_blank&quot;&gt;https://github.com/loiane/javascript-datastructures-algorithms&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　先说下我个人对这本书的看法吧。对于数据结构的介绍不够深入和详细，对于那些计算机专业的前端从业者来说，十分的鸡肋。而对于那些非计算机专业，又完全没接触过数据结构是什么东西的前端coder来说。其中的讲解又十分的不具体，对于思路的讲解并不明了。&lt;/p&gt;
&lt;p&gt;　　当然，我也在网上找到了很多类似于本系列的文章，大多数都是基于此书的代码，但是要么就是完全复制的代码，解释十分的少或者几乎没有，要么就是整体不清不楚，让人不知所以然。&lt;/p&gt;
&lt;p&gt;　　所以，我就想在学习的过程中把自己的理解，自己对于这个数据结构的思路和每一行代码在上下文中所起到的作用等等写出来。希望大家在学习数据结构的时候可以走的更容易一点。&lt;/p&gt;
&lt;p&gt;　　在学习的过程中，有不理解的地方，书中讲的不易理解的地方，都是自己画图，自己去找资料，然后再回来结合代码，给出一个“自认为”还不错的解释。&lt;/p&gt;
&lt;p&gt;　　终于，完成了有关用js来实现数据结构的所有内容，前后大概花了一个多月的时间，一共16篇文章。有最基本的js数组的详细讲解。也有非线性的散列表、树和图。其实对于用js来实现数据结构，个人感觉更多要学习的是那种数据结构的思想。一旦你理解了这个数据结构的思想，那么自然，实现代码也不过就是时间的问题了。&lt;/p&gt;
&lt;p&gt;　　本系列所有的内容，都是我一个字一个字打出来的，包括书中的代码和自己加上的注释，当然，其中概念性的问题一部分来自于此书，书中解释不清楚的我都在文中附上了资料的链接。&lt;/p&gt;
&lt;p&gt;　　那么，如果各位老爷在阅读的时候有不理解或者觉得不清楚的地方，还希望可以留言提出。互相学习。&lt;/p&gt;
&lt;p&gt;　　噢，对，还是要说一下我觉得这个系列的重点吧。重点在后6篇，也就是从散列表开始的非线性数据结构。而对于前面的栈，队列等。是你学习后面的基础，因为在树，图等数据结构的实现中，都用到了前面的代码。&lt;/p&gt;
&lt;p&gt;　　所以，大家如果想要学习数据结构。那么个人觉得这系列文章是个不错的开始。或许你会问，我看完这系列文章会学到什么？我真的就懂了数据结构么？当然没有。就单单拿一个图来说，足够写一本厚厚的书了。所以，你学完这个系列，最多只是打开了数据结构的大门，迈出了你的右脚（或者左脚）向门里面的世界探了探，连走进这个大门都不算。&lt;/p&gt;
&lt;p&gt;　　我完成这16篇文章，大概花了四十个小时的时间。如果你想要真的弄懂下面目录内的所有内容，每天一个小时，大概需要花上一个月。当然，不仅仅是读一遍，而是跟着文章中的代码和注释完整的过了一遍自己的脑子。&lt;/p&gt;
&lt;p&gt;　　最后说一下本系列的使用方法吧，首先，你把代码复制到本地，去掉所有的注释，然后就着文章，看一遍代码。然后自己打一遍代码，有不明白的地方再去看注释。这是本系列的服用说明。&lt;/p&gt;
&lt;p&gt;　　好了，不罗嗦了。就到这里吧。也算是给自己的交上了一份6分的答卷。&lt;/p&gt;

&lt;p&gt;　　下面是目录：&lt;/p&gt;
&lt;p&gt;　　　　1、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8686676.html&quot;&gt;用js来实现那些数据结构01（数组篇01-数组的增删）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 　　　　2、 &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8711731.html&quot;&gt;用js来实现那些数据结构02（数组篇02-数组方法）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　3、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8784575.html&quot;&gt;用js来实现那些数据结构03（数组篇03-排序及多维数组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　4、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8799326.html&quot;&gt;用js来实现那些数据结构04（栈01-栈的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　5、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8837056.html&quot;&gt;用js来实现那些数据结构05（栈02-栈的应用）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　6、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8863434.html&quot;&gt;用js来实现那些数据结构06（队列）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　7、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl07_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8870705.html&quot;&gt;用js来实现那些数据结构07（链表01-链表的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　8、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8886941.html&quot;&gt;用js来实现那些数据结构08（链表02-双向链表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　9、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8902219.html&quot;&gt;用js来实现那些数据结构09（集合01-集合的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　10、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8905884.html&quot;&gt;用js来实现那些数据结构10（集合02-集合的操作）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　11、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8909401.html&quot;&gt;用js来实现那些数据结构11（字典）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　12、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8950607.html&quot;&gt;用js来实现那些数据结构12（散列表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　13、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8964937.html&quot;&gt;用js来实现那些数据结构13（树01-二叉搜索树的实现）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　14、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8976362.html&quot;&gt;用js来实现那些数据结构14（树02-AVL树）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　15、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8992910.html&quot;&gt;用js来实现那些数据结构15（图01）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　16、&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/9004976.html&quot;&gt;用js来实现那些数据结构16（图02-图的遍历）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 12:37:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/9016600.html</dc:identifier>
</item>
<item>
<title>Java数组的复制全解 - 奇客艺术</title>
<link>http://www.cnblogs.com/qikeyishu/p/9021595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qikeyishu/p/9021595.html</guid>
<description>&lt;h3&gt;1、将一个基本数据类型数组的引用赋值给另一个数组&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Array_copy {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] array1=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1,2,3,4,5,6&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] array2=array1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将array1的引用赋值给array2，两数组指向同一个内存空间&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Array_copy ac = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array_copy();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ac.array1.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             System.out.print(ac.array1[i]+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ac.array1.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             System.out.print(ac.array2[i]+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.println(&quot;\n&quot;+&quot;修改数组array1的值，查看array2是否改变&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         ac.array1[0]=10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改数组第一元素&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ac.array1.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             System.out.print(ac.array1[i]+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ac.array1.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             System.out.print(ac.array2[i]+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1186474/201805/1186474-20180510202600935-996054213.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;这里只是复制了数组的引用，一个数组的改变会影响到另一个数组。&lt;/h4&gt;
&lt;h3&gt;2、使用arraycopy方法复制基本数据类型数组&lt;/h3&gt;
&lt;h4&gt;2.1. arraycopy方法声明&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; arraycopy(Object src,&lt;span&gt;int&lt;/span&gt; srcPos,Object dest,&lt;span&gt;int&lt;/span&gt; destPos,&lt;span&gt;int&lt;/span&gt; lenhgth);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2. arraycopy方法参数简介&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;src：源数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;srcPos：开始复制的位置，从源数组哪个位置开始复制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;dest：目的数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;descPos：将源数组复制到目标数组的起始位置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span&gt;length：复制多少个源数组中的元素个数&lt;/span&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span class=&quot;token lf&quot;&gt;&lt;span class=&quot;token li&quot;&gt;&lt;span class=&quot;token md md-li&quot;&gt;&lt;span class=&quot;token strong&quot;&gt;&lt;span class=&quot;token md md-strong&quot;&gt;&lt;span&gt;2.2. arraycopy方法演示&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Arraycopy {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] ary1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1, 2, 3, 4, 5, 6&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] ary2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[6&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : array)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             System.out.print(i+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * 使用arraycopy方法将数组ary1复制给ary2
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Arraycopy ac = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Arraycopy();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;---两数组初始---&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        ac.print(ac.ary1);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        ac.print(ac.ary2);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;---将ary1复制给ary2---&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.arraycopy(ac.ary1,0,ac.ary2,0&lt;span&gt;,ac.ary1.length);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        ac.print(ac.ary1);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        ac.print(ac.ary2);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;---修改ary1(ary2)查看ary2(ary1)是否变化---&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         ac.ary1[0]=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        ac.print(ac.ary1);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        ac.print(ac.ary2);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1186474/201805/1186474-20180510203139875-2060975588.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用arraycopy方法进行数组复制，就不存在数组的引用，即：一个数组的内容的改变不会影响另一个数组的内容。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3、对象类型(引用类型)数组的复制&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.awt.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Arraycopy2 {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 定义对象数组
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     Label lb1[] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label[]{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; Label(&quot;Label1&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; Label(&quot;Label2&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; Label(&quot;Label3&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     Label lb2[] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Label[lb1.length];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Arraycopy2 ac = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Arraycopy2();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;--将对象数组lb1复制给lb2--&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         System.out.print(&quot;lb1数组：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        ac.print(ac.lb1);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ac.lb2 = ac.lb1;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         System.arraycopy(ac.lb1,0,ac.lb2,0&lt;span&gt;,ac.lb1.length);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         System.out.print(&quot;lb2数组：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        ac.print(ac.lb2);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;\n--修改lb1(lb2)查看lb2(lb1)是否变化--&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         ac.lb1[0].setText(&quot;Label0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         System.out.print(&quot;lb1数组：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        ac.print(ac.lb1);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         System.out.print(&quot;lb2数组：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         ac.print(ac.lb2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改lb1数组内容后发现lb2数组也发生改变，说明lb1和lb2指向同一内存空间。
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然修改lb2内容lb1内容也会改变，这里不赘述了&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(Label[] lb) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Label i : lb) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             System.out.print(i.getText() + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        System.out.println();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1186474/201805/1186474-20180510203129120-1456367165.jpg&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;h4&gt;和基本类型数组是不同的，当数组类型为对象类型时，用arraycopy方法复制数组复制的也只是引用，不是对象本身。&lt;/h4&gt;
&lt;p&gt;关联博客(CSDN)：&lt;a href=&quot;https://blog.csdn.net/m0_38022608/article/details/80262416&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/m0_38022608/article/details/80262416&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 May 2018 12:34:00 +0000</pubDate>
<dc:creator>奇客艺术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qikeyishu/p/9021595.html</dc:identifier>
</item>
<item>
<title>Java 面试知识点解析(二)——高并发编程篇 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/9021597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/9021597.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-958b6a30c60032e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;amp;mid=2650692240&amp;amp;idx=1&amp;amp;sn=dc39f07097656042344e7fee8a17259e&amp;amp;chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=1225zdAW9iFdJ86OiBQSr8mP#rd&quot;&gt;知名互联网公司校招 Java 开发岗面试知识点解析&lt;/a&gt; ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。&lt;/p&gt;
&lt;p&gt;前序文章链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/883260941da8&quot;&gt;Java 面试知识点解析(一)——基础知识篇&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一高并发编程基础知识&quot;&gt;（一）高并发编程基础知识&lt;/h2&gt;
&lt;blockquote readability=&quot;6.9652996845426&quot;&gt;
&lt;p&gt;这里涉及到一些基础的概念，我重新捧起了一下《实战 Java 高并发程序设计》这一本书，感觉到心潮澎湃，这或许就是笔者叙述功底扎实的魅力吧，喜欢。对于并发的基础可以参照一下我之前写过的一篇博文：&lt;a href=&quot;https://www.jianshu.com/p/cd9d0927be35&quot;&gt;Java学习笔记（4）——并发基础&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;多线程和单线程的区别和联系&quot;&gt;1）多线程和单线程的区别和联系？&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：那使用多线程有什么优势？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析：尽管面临很多挑战，多线程有一些优点仍然使得它一直被使用，而这些优点我们应该了解。&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;（1）资源利用率更好&lt;/p&gt;
&lt;p&gt;想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1| 5秒读取文件A
2| 2秒处理文件A
3| 5秒读取文件B
4| 2秒处理文件B
5| ---------------------
6| 总共需要14秒&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从磁盘中读取文件的时候，大部分的CPU时间用于等待磁盘去读取数据。在这段时间里，CPU非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1| 5秒读取文件A
2| 5秒读取文件B + 2秒处理文件A
3| 2秒处理文件B
4| ---------------------
5| 总共需要12秒&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。&lt;/p&gt;
&lt;p&gt;总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。&lt;/p&gt;
&lt;p&gt;（2）程序设计在某些情况下更简单&lt;/p&gt;
&lt;p&gt;在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。&lt;/p&gt;
&lt;p&gt;（3）程序响应更快&lt;/p&gt;
&lt;p&gt;有时我们会编写一些较为复杂的代码（这里的复杂不是说复杂的算法，而是复杂的业务逻辑），例如，一笔订单的创建，它包括插入订单数据、生成订单赶快找、发送邮件通知卖家和记录货品销售数量等。用户从单击“订购”按钮开始，就要等待这些操作全部完成才能看到订购成功的结果。但是这么多业务操作，如何能够让其更快地完成呢？&lt;/p&gt;
&lt;p&gt;在上面的场景中，可以使用多线程技术，即将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列），如生成订单快照、发送邮件等。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间，提升了用户体验。&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;多线程还有一些优势也显而易见：&lt;/strong&gt;&lt;br/&gt;① 进程之前不能共享内存，而线程之间共享内存(堆内存)则很简单。&lt;br/&gt;② 系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.&lt;br/&gt;③ Java语言本身内置多线程功能的支持,而不是单纯第作为底层系统的调度方式,从而简化了多线程编程.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;多线程一定快吗&quot;&gt;2）多线程一定快吗？&lt;/h4&gt;
&lt;p&gt;答：不一定。&lt;/p&gt;
&lt;p&gt;比如，我们尝试使用并行和串行来分别执行累加的操作观察是否并行执行一定比串行执行更快：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a698017d4c0dbf79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是我测试的结果，可以看出，当不超过1百万的时候，并行是明显比串行要慢的，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-e515dc406651240b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是同步什么又是异步&quot;&gt;3）什么是同步？什么又是异步？&lt;/h4&gt;
&lt;p&gt;解析：这是对多线程基础知识的考察&lt;/p&gt;
&lt;p&gt;答：同步和异步通常用来形容一次方法调用。&lt;/p&gt;
&lt;p&gt;同步方法调用一旦开始，调用者必须等到方法返回后，才能继续后续的行为。这就好像是我们去商城买一台空调，你看中了一台空调，于是就跟售货员下了单，然后售货员就去仓库帮你调配物品，这天你热的实在不行，就催着商家赶紧发货，于是你就在商店里等着，知道商家把你和空调都送回家，一次愉快的购物才结束，这就是同步调用。&lt;/p&gt;
&lt;p&gt;而异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。回到刚才买空调的例子，我们可以坐在里打开电脑，在网上订购一台空调。当你完成网上支付的时候，对你来说购物过程已经结束了。虽然空调还没有送到家，但是你的任务都已经完成了。商家接到你的订单后，就会加紧安排送货，当然这一切已经跟你无关了，你已经支付完成，想什么就能去干什么了，出去溜达几圈都不成问题。等送货上门的时候，接到商家电话，回家一趟签收即可。这就是异步调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a8d7703b4874703a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：那并发（Concurrency）和并行（Parallelism）的区别呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析：并行性和并发性是既相似又有区别的两个概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：并行性是指两个或多个事件在同一时刻发生。而并发性是指连个或多个事件在同一时间间隔内发生。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-672dfca5db6de845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机环境下（一个处理器），每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。例如，在1秒钟时间内，0-15ms程序A运行；15-30ms程序B运行；30-45ms程序C运行；45-60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。&lt;/p&gt;
&lt;p&gt;如果在计算机系统中有多个处理机，这些可以并发执行的程序就可以被分配到多个处理机上，实现并发执行，即利用每个处理机处理一个可并发执行的程序。这样，多个程序便可以同时执行。以此就能提高系统中的资源利用率，增加系统的吞吐量。&lt;/p&gt;
&lt;h4 id=&quot;线程和进程的区别必考&quot;&gt;4）线程和进程的区别：（必考）&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进程是一个 “执行中的程序”，是系统进行资源分配和调度的一个独立单位；&lt;/li&gt;
&lt;li&gt;线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）；&lt;/li&gt;
&lt;li&gt;线程上下文的切换比进程上下文切换要快很多。
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;（1）进程切换时，涉及到当前进程的 CPU 环境的保存和新被调度运行进程的 CPU 环境的设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;（2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;面试官：进程间如何通讯？线程间如何通讯？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：进程间通讯依靠 IPC 资源，例如管道（pipes）、套接字（sockets）等；&lt;/p&gt;
&lt;p&gt;线程间通讯依靠 JVM 提供的 API，例如 wait()、notify()、notifyAll() 等方法，线程间还可以通过共享的主内存来进行值的传递。&lt;/p&gt;
&lt;blockquote readability=&quot;5.7462686567164&quot;&gt;
&lt;p&gt;关于线程和进程有一篇写得非常不错的文章，不过是英文的，我进行了翻译，相信阅读之后会对进程和线程有不一样的理解：&lt;a href=&quot;https://www.jianshu.com/p/11e6cb1c3d38&quot;&gt;线程和进程基础——翻译文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;什么是阻塞blocking和非阻塞non-blocking&quot;&gt;5）什么是阻塞（Blocking）和非阻塞（Non-Blocking）？&lt;/h4&gt;
&lt;p&gt;答：阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个而资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。&lt;/p&gt;
&lt;p&gt;非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前向执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：临界区是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：临界区用来表示一种公共资源或者说是共享资源，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。&lt;/p&gt;
&lt;p&gt;比如，在一个办公室里有一台打印机，打印机一次只能执行一个任务。如果小王和小明同时需要打印文件，很显然，如果小王先下发了打印任务，打印机就开始打印小王的文件了，小明的任务就只能等待小王打印结束后才能打印，这里的打印机就是一个临界区的例子。&lt;/p&gt;
&lt;p&gt;在并行程序中，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务，那么最可能的结果就是打印出来的文件就会是损坏的文件，它既不是小王想要的，也不是小明想要的。&lt;/p&gt;
&lt;h4 id=&quot;什么是死锁deadlock饥饿starvation和活锁livelock&quot;&gt;6）什么是死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）？&lt;/h4&gt;
&lt;p&gt;答：死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现上述几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a6041256aed650a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;死锁应该是最糟糕的一种情况了，它表示两个或者两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：&lt;br/&gt;1）它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。在自然界中，母鸡喂食雏鸟时，很容易出现这种情况，由于雏鸟很多，食物有限，雏鸟之间的食物竞争可能非常厉害，小雏鸟因为经常抢不到食物，有可能会被饿死。线程的饥饿也非常类似这种情况。&lt;br/&gt;2）另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。&lt;br/&gt;与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;活锁是一种非常有趣的情况。不知道大家是不是有遇到过这样一种情况，当你要坐电梯下楼，电梯到了，门开了，这时你正准备出去，但不巧的是，门外一个人挡着你的去路，他想进来。于是你很绅士的靠左走，避让对方，但同时对方也很绅士，但他靠右走希望避让你。结果，你们又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右走，他也立即向左走，结果又撞上了！不过介于人类的只能，我相信这个动作重复 2、 3 次后，你应该可以顺利解决这个问题，因为这个时候，大家都会本能的对视，进行交流，保证这种情况不再发生。&lt;br/&gt;但如果这种情况发生在两个线程间可能就不会那么幸运了，如果线程的智力不够，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有的资源而正常执行。这种情况就是活锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;多线程产生死锁的-4-个必要条件&quot;&gt;7）多线程产生死锁的 4 个必要条件？&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;互斥条件：一个资源每次只能被一个线程使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;面试官：如何避免死锁？（经常接着问这个问题哦~）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：指定获取锁的顺序，举例如下：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;比如某个线程只有获得 A 锁和 B 锁才能对某资源进行操作，在多线程条件下，如何避免死锁？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;获得锁的顺序是一定的，比如规定，只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁！！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;如何指定多个线程的执行顺序&quot;&gt;8）如何指定多个线程的执行顺序？&lt;/h4&gt;
&lt;p&gt;解析：面试官会给你举个例子，如何让 10 个线程按照顺序打印 0123456789？（写代码实现）&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设定一个 orderNum，每个线程执行结束之后，更新 orderNum，指明下一个要执行的线程。并且唤醒所有的等待线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在每一个线程的开始，要 while 判断 orderNum 是否等于自己的要求值！！不是，则 wait，是则执行本线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;java-中线程有几种状态&quot;&gt;9）Java 中线程有几种状态？&lt;/h4&gt;
&lt;p&gt;答：六种（查看 Java 源码也可以看到是 6 种），并且某个时刻 Java 线程只能处于其中的一个状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7b69db5925631d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;新建（NEW）状态：表示新创建了一个线程对象，而此时线程并没有开始执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可运行（RUNNABLE）状态：线程对象创建后，其它线程（比如 main 线程）调用了该对象的 start() 方法，才表示线程开始执行。当线程执行时，处于 RUNNBALE 状态，表示线程所需的一切资源都已经准备好了。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;阻塞（BLOCKED）状态：如果线程在执行过程终于到了 synchronized 同步块，就会进入 BLOCKED 阻塞状态，这时线程就会暂停执行，直到获得请求的锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;等待（WAITING）状态：当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;计时等待（TIMED_WAITING）状态：Object.wait、Thread.join、Lock.tryLock和Condition.await 等方法有超时参数，还有 Thread.sleep 方法、LockSupport.parkNanos 方法和 LockSupport.parkUntil 方法，这些方法会导致线程进入计时等待状态，如果超时或者出现通知，都会切换会可运行状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;终止（TERMINATED）状态：当线程执行完毕，则进入该状态，表示结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：从 NEW 状态出发后，线程不能再回到 NEW 状态，同理，处于 TERMINATED 状态的线程也不能再回到 RUNNABLE 状态。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二高并发编程-juc-包&quot;&gt;（二）高并发编程-JUC 包&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 Java 5.0 提供了 java.util.concurrent（简称 JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;sleep-和-wait-nwait-的区别&quot;&gt;1）sleep( ) 和 wait( n)、wait( ) 的区别：&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;sleep 方法：是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;wait 方法：是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;synchronized-关键字&quot;&gt;2）synchronized 关键字：&lt;/h4&gt;
&lt;p&gt;答：底层实现：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;含义：（monitor 机制）&lt;/p&gt;
&lt;p&gt;Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。&lt;/p&gt;
&lt;p&gt;该关键字是一个几种锁的封装。&lt;/p&gt;
&lt;h4 id=&quot;volatile-关键字&quot;&gt;3）volatile 关键字：&lt;/h4&gt;
&lt;p&gt;答：该关键字可以保证可见性不保证原子性。&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;禁止 JVM 进行的指令重排序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。&lt;/p&gt;
&lt;h4 id=&quot;volatile-能使得一个非原子操作变成原子操作吗&quot;&gt;4）volatile 能使得一个非原子操作变成原子操作吗？&lt;/h4&gt;
&lt;p&gt;答：能。&lt;/p&gt;
&lt;p&gt;一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：volatile 修饰符的有过什么实践？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;threadlocal线程局部变量关键字&quot;&gt;5）ThreadLocal（线程局部变量）关键字：&lt;/h4&gt;
&lt;p&gt;答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。&lt;/p&gt;
&lt;p&gt;ThreadLocal 内部实现机制：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-219b164cba63247a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;线程池有了解吗必考&quot;&gt;6）线程池有了解吗？（必考）&lt;/h4&gt;
&lt;p&gt;答：java.util.concurrent.ThreadPoolExecutor 类就是一个线程池。客户端调用 ThreadPoolExecutor.submit(Runnable task) 提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有 3 种形态：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;当前线程池大小 ：表示线程池中实际工作者线程的数量；&lt;/li&gt;
&lt;li&gt;最大线程池大小 （maxinumPoolSize）：表示线程池中允许存在的工作者线程的数量上限；&lt;/li&gt;
&lt;li&gt;核心线程大小 （corePoolSize ）：表示一个不大于最大线程池大小的工作者线程数量上限。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果运行的线程等于或者多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不是添加新线程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出 maxinumPoolSize， 在这种情况下，任务将被拒绝。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;面试官：我们为什么要使用线程池？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;面试官：核心线程池内部实现了解吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。&lt;/p&gt;
&lt;p&gt;为何 ThreadPoolExecutor 有如此强大的功能呢？我们可以来看一下 ThreadPoolExecutor 最重要的构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数的参数含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize：指定了线程池中的线程数量&lt;/li&gt;
&lt;li&gt;maximumPoolSize：指定了线程池中的最大线程数量&lt;/li&gt;
&lt;li&gt;keepAliveTime：当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过了 corePoolSize 的空闲线程，在多长时间内，会被销毁。&lt;/li&gt;
&lt;li&gt;unit: keepAliveTime 的单位。&lt;/li&gt;
&lt;li&gt;workQueue：任务队列，被提交但尚未被执行的任务。&lt;/li&gt;
&lt;li&gt;threadFactory：线程工厂，用于创建线程，一般用默认的即可。&lt;/li&gt;
&lt;li&gt;handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;atomic关键字&quot;&gt;7）Atomic关键字：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;答：可以使基本数据类型以原子的方式实现自增自减等操作。参考博客：&lt;a href=&quot;http://blog.csdn.net/qq_25827845/article/details/70225658&quot;&gt;concurrent.atomic包下的类AtomicInteger的使用&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建线程有哪几种方式&quot;&gt;8）创建线程有哪几种方式？&lt;/h4&gt;
&lt;p&gt;答：有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象;二是直接继承Thread类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：两种方式有什么区别呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承方式:
&lt;ul&gt;&lt;li&gt;（1）Java中类是单继承的,如果继承了Thread了,该类就不能再有其他的直接父类了.&lt;/li&gt;
&lt;li&gt;（2）从操作上分析,继承方式更简单,获取线程名字也简单.(操作上,更简单)&lt;/li&gt;
&lt;li&gt;（3）从多线程共享同一个资源上分析,继承方式不能做到.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现方式:&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;（1）Java中类可以多实现接口,此时该类还可以继承其他类,并且还可以实现其他接口(设计上,更优雅).
&lt;ul&gt;&lt;li&gt;（2）从操作上分析,实现方式稍微复杂点,获取线程名字也比较复杂,得使用Thread.currentThread()来获取当前线程的引用.&lt;/li&gt;
&lt;li&gt;（3）从多线程共享同一个资源上分析,实现方式可以做到(是否共享同一个资源).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;run-方法和-start-方法有什么区别&quot;&gt;9）run() 方法和 start() 方法有什么区别？&lt;/h4&gt;
&lt;p&gt;答：start() 方法会新建一个线程并让这个线程执行 run() 方法；而直接调用 run() 方法知识作为一个普通的方法调用而已，它只会在当前线程中，串行执行 run() 中的代码。&lt;/p&gt;
&lt;h4 id=&quot;你怎么理解线程优先级&quot;&gt;10）你怎么理解线程优先级？&lt;/h4&gt;
&lt;p&gt;答：Java 中的线程可以有自己的优先级。优先极高的线程在竞争资源时会更有优势，更可能抢占资源，当然，这只是一个概率问题。如果运行不好，高优先级线程可能也会抢占失败。&lt;/p&gt;
&lt;p&gt;由于线程的优先级调度和底层操作系统有密切的关系，在各个平台上表现不一，并且这种优先级产生的后果也可能不容易预测，无法精准控制，比如一个低优先级的线程可能一直抢占不到资源，从而始终无法运行，而产生饥饿（虽然优先级低，但是也不能饿死它啊）。因此，在要求严格的场合，还是需要自己在应用层解决线程调度的问题。&lt;/p&gt;
&lt;p&gt;在 Java 中，使用 1 到 10 表示线程优先级，一般可以使用内置的三个静态标量表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数字越大则优先级越高，但有效范围在 1 到 10 之间，默认的优先级为 5 。&lt;/p&gt;
&lt;h4 id=&quot;在-java-中如何停止一个线程&quot;&gt;11）在 Java 中如何停止一个线程？&lt;/h4&gt;
&lt;p&gt;答：Java 提供了很丰富的 API 但没有为停止线程提供 API 。&lt;/p&gt;
&lt;p&gt;JDK 1.0 本来有一些像 stop()，suspend() 和 resume() 的控制方法但是由于潜在的死锁威胁因此在后续的 JDK 版本中他们被弃用了，之后 Java API 的设计者就没有提供一个兼容且线程安全的方法来停止任何一个线程。&lt;/p&gt;
&lt;p&gt;当 run() 或者 call() 方法执行完的时候线程会自动结束，如果要手动结束一个线程，你可以用 volatile 布尔变量来退出 run() 方法的循环或者是取消任务来中断线程。&lt;/p&gt;
&lt;h4 id=&quot;多线程中的忙循环是什么&quot;&gt;12）多线程中的忙循环是什么？&lt;/h4&gt;
&lt;p&gt;答：忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(),sleep() 或yield() 它们都放弃了 CPU 控制权，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。&lt;/p&gt;
&lt;p&gt;在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存，为了避免重建缓存和减少等待重建的时间就可以使用它了。&lt;/p&gt;
&lt;h4 id=&quot;个线程和-2-个线程的同步代码哪个更容易写&quot;&gt;13）10 个线程和 2 个线程的同步代码，哪个更容易写？&lt;/h4&gt;
&lt;p&gt;答：从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。&lt;/p&gt;
&lt;h4 id=&quot;你是如何调用-wait方法的使用-if-块还是循环为什么&quot;&gt;14）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？&lt;/h4&gt;
&lt;p&gt;答：wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// The standard idiom for using the wait method
synchronized (obj) {
while (condition does not hold)
obj.wait(); // (Releases lock, and reacquires on wakeup)
... // Perform action appropriate to condition
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。&lt;/p&gt;
&lt;h4 id=&quot;什么是多线程环境下的伪共享false-sharing&quot;&gt;15）什么是多线程环境下的伪共享（false sharing）？&lt;/h4&gt;
&lt;p&gt;答：伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-3cbee585a5f68f02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。&lt;/p&gt;
&lt;h4 id=&quot;用-wait-notify-写一段代码来解决生产者-消费者问题&quot;&gt;16）用 wait-notify 写一段代码来解决生产者-消费者问题？&lt;/h4&gt;
&lt;p&gt;解析：这是常考的基础类型的题，只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Java program to solve Producer Consumer problem using wait and notify
 * method in Java. Producer Consumer is also a popular concurrency design pattern.
 *
 * @author Javin Paul
 */
public class ProducerConsumerSolution {

    public static void main(String args[]) {
        Vector sharedQueue = new Vector();
        int size = 4;
        Thread prodThread = new Thread(new Producer(sharedQueue, size), &quot;Producer&quot;);
        Thread consThread = new Thread(new Consumer(sharedQueue, size), &quot;Consumer&quot;);
        prodThread.start();
        consThread.start();
    }
}

class Producer implements Runnable {

    private final Vector sharedQueue;
    private final int SIZE;

    public Producer(Vector sharedQueue, int size) {
        this.sharedQueue = sharedQueue;
        this.SIZE = size;
    }

    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 7; i++) {
            System.out.println(&quot;Produced: &quot; + i);
            try {
                produce(i);
            } catch (InterruptedException ex) {
                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
    }

    private void produce(int i) throws InterruptedException {

        // wait if queue is full
        while (sharedQueue.size() == SIZE) {
            synchronized (sharedQueue) {
                System.out.println(&quot;Queue is full &quot; + Thread.currentThread().getName()
                                    + &quot; is waiting , size: &quot; + sharedQueue.size());

                sharedQueue.wait();
            }
        }

        // producing element and notify consumers
        synchronized (sharedQueue) {
            sharedQueue.add(i);
            sharedQueue.notifyAll();
        }
    }
}

class Consumer implements Runnable {

    private final Vector sharedQueue;
    private final int SIZE;

    public Consumer(Vector sharedQueue, int size) {
        this.sharedQueue = sharedQueue;
        this.SIZE = size;
    }

    @Override
    public void run() {
        while (true) {
            try {
                System.out.println(&quot;Consumed: &quot; + consume());
                Thread.sleep(50);
            } catch (InterruptedException ex) {
                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
    }

    private int consume() throws InterruptedException {
        // wait if queue is empty
        while (sharedQueue.isEmpty()) {
            synchronized (sharedQueue) {
                System.out.println(&quot;Queue is empty &quot; + Thread.currentThread().getName()
                                    + &quot; is waiting , size: &quot; + sharedQueue.size());

                sharedQueue.wait();
            }
        }

        // Otherwise consume element and notify waiting producer
        synchronized (sharedQueue) {
            sharedQueue.notifyAll();
            return (Integer) sharedQueue.remove(0);
        }
    }
}

Output:
Produced: 0
Queue is empty Consumer is waiting , size: 0
Produced: 1
Consumed: 0
Produced: 2
Produced: 3
Produced: 4
Produced: 5
Queue is full Producer is waiting , size: 4
Consumed: 1
Produced: 6
Queue is full Producer is waiting , size: 4
Consumed: 2
Consumed: 3
Consumed: 4
Consumed: 5
Consumed: 6
Queue is empty Consumer is waiting , size: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用-java-写一个线程安全的单例模式singleton&quot;&gt;17）用 Java 写一个线程安全的单例模式（Singleton）？&lt;/h4&gt;
&lt;p&gt;解析：有多种方法，但重点掌握的是双重校验锁。&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;1.饿汉式单例&lt;/p&gt;
&lt;p&gt;饿汉式单例是指在方法调用前，实例就已经创建好了。下面是实现代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private static Singleton instance = new Singleton();

    private Singleton (){}

    public static Singleton getInstance() {
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.加入 synchronized 的懒汉式单例&lt;/p&gt;
&lt;p&gt;所谓懒汉式单例模式就是在调用的时候才去创建这个实例，我们在对外的创建实例方法上加如 synchronized 关键字保证其在多线程中很好的工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {    

    private static Singleton instance;    

    private Singleton (){}    

    public static synchronized Singleton getInstance() {    
        if (instance == null) {    
            instance = new Singleton();    
    }    
    return instance;    
    }    
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.使用静态内部类的方式创建单例&lt;/p&gt;
&lt;p&gt;这种方式利用了 classloder 的机制来保证初始化 instance 时只有一个线程，它跟饿汉式的区别是：饿汉式只要 Singleton 类被加载了，那么 instance 就会被实例化（没有达到 lazy loading 的效果），而这种方式是 Singleton 类被加载了，instance 不一定被初始化。只有显式通过调用 getInstance() 方法时才会显式装载 SingletonHoder 类，从而实例化 singleton&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {// 静态内部类  
        private static Singleton singleton = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.singleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.双重校验锁&lt;/p&gt;
&lt;p&gt;为了达到线程安全，又能提高代码执行效率，我们这里可以采用DCL的双检查锁机制来完成，代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {  
  
    private static Singleton singleton;  

    private Singleton() {  
    }  

    public static Singleton getInstance(){  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种是用双重判断来创建一个单例的方法，那么我们为什么要使用两个if判断这个对象当前是不是空的呢 ？因为当有多个线程同时要创建对象的时候，多个线程有可能都停止在第一个if判断的地方，等待锁的释放，然后多个线程就都创建了对象，这样就不是单例模式了，所以我们要用两个if来进行这个对象是否存在的判断。&lt;/p&gt;
&lt;p&gt;5.使用 static 代码块实现单例&lt;/p&gt;
&lt;p&gt;静态代码块中的代码在使用类的时候就已经执行了，所以可以应用静态代码块的这个特性的实现单例设计模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton{  
       
    private static Singleton instance = null;  
       
    private Singleton(){}  
  
    static{  
        instance = new Singleton();  
    }  
      
    public static Singleton getInstance() {   
        return instance;  
    }   
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.使用枚举数据类型实现单例模式&lt;/p&gt;
&lt;p&gt;枚举enum和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ClassFactory{   
      
    private enum MyEnumSingleton{  
        singletonFactory;  
          
        private MySingleton instance;  
          
        private MyEnumSingleton(){//枚举类的构造方法在类加载是被实例化  
            instance = new MySingleton();  
        }  
   
        public MySingleton getInstance(){  
            return instance;  
        }  
    }   
   
    public static MySingleton getInstance(){  
        return MyEnumSingleton.singletonFactory.getInstance();  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小结：关于 Java 中多线程编程，线程安全等知识一直都是面试中的重点和难点，还需要熟练掌握。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h4 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;amp;mid=2650692240&amp;amp;idx=1&amp;amp;sn=dc39f07097656042344e7fee8a17259e&amp;amp;chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=1225zdAW9iFdJ86OiBQSr8mP#rd&quot;&gt;① 知名互联网公司校招 Java 开发岗面试知识点解析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/23533393&quot;&gt;② 最近5年133个Java面试问题列表&lt;/a&gt;&lt;br/&gt;③ 《实战 Java 高并发程序设计 —— 葛一鸣 郭超 编著》&lt;/p&gt;
&lt;blockquote readability=&quot;3.3290322580645&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq939419061&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq939419061&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 10 May 2018 12:33:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/9021597.html</dc:identifier>
</item>
</channel>
</rss>