<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>NFS服务器详解 - yuanbangchen</title>
<link>http://www.cnblogs.com/Yuanbangchen/p/9560586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yuanbangchen/p/9560586.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、NFS服务简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NFS 就是 &lt;strong&gt;N&lt;/strong&gt;etwork &lt;strong&gt;F&lt;/strong&gt;ile&lt;strong&gt;S&lt;/strong&gt;ystem 的缩写，最早之前是由sun 这家公司所发展出来的。 它最大的功能就是&lt;span class=&quot;text_import2&quot;&gt;可以透过网络，让不同的机器、不同的操作系统、可以彼此分享个别的档案 (share files)。所以，你也可以简单的将他看做是一个文件服务器 (file server). &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为 NFS 支持的功能相当的多，而不同的功能都会使用不同的程序来启动， 每启动一个功能就会启用一些端口来传输数据，因此， NFS 的功能所对应的端口才没有固定住， 而是随机取用一些未被使用的小于 1024 的端口来作为传输之用。&lt;/p&gt;
&lt;p&gt;此时我们就得需要远程过程调用 (RPC) 的服务啦！&lt;span class=&quot;text_import2&quot;&gt;RPC 最主要的功能就是在指定每个 NFS 功能所对应的 port number ，并且回报给客户端，让客户端可以连结到正确的端口上去。 &lt;span&gt;那 RPC 又是如何知道每个 NFS 的端口呢？这是因为&lt;/span&gt;&lt;span class=&quot;text_import2&quot;&gt;&lt;span&gt;当服务器在启动 NFS 时会随机取用数个端口，并主动的向 RPC 注册，因此 RPC 可以知道每个端口对应的 NFS 功能，然后 RPC 又是固定使用 port 111 来监听客户端的需求并回报客户端正确的端口&lt;/span&gt;， 所以当然可以让 NFS 的启动更为快捷了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;text_import2&quot;&gt;所以你要&lt;span&gt;注意，要启动 NFS 之前，RPC 就要先启动了，否则 NFS 会无法向 RPC 注册&lt;/span&gt;。 另外，RPC 若重新启动时，原本注册的数据会不见，因此 RPC 重新启动后，它管理的所有服务都需要重新启动来重新向 RPC 注册。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当客户端有 NFS 档案存取需求时，他会如何向服务器端要求数据呢？&lt;/p&gt;
&lt;ol class=&quot;text_import2&quot;&gt;&lt;li&gt;客户端会向服务器端的 RPC (port 111) 发出 NFS 档案存取功能的询问要求；&lt;/li&gt;
&lt;li&gt;服务器端找到对应的已注册的 NFS daemon 端口后，会回报给客户端；&lt;/li&gt;
&lt;li&gt;客户端了解正确的端口后，就可以直接与 NFS daemon 来联机。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 NFS 的各项功能都必须要向 RPC 来注册，如此一来 RPC 才能了解 NFS 这个服务的各项功能之 port number, PID, NFS 在服务器所监听的 IP 等等，而客户端才能够透过 RPC 的询问找到正确对应的端口。 也就是说，NFS 必须要有 RPC 存在时才能成功的提供服务，因此我们称 NFS 为 RPC server 的一种。事实上，有很多这样的服务器都是向 RPC 注册的，举例来说，NIS (Network Information Service) 也是 RPC server 的一种。&lt;/p&gt;
&lt;p&gt;我们现在知道 NFS 服务器在启动的时候就得要向 RPC 注册，所以 NFS 服务器也 被称为 RPC server 之一。 &lt;span&gt;那么 NFS 服务器主要的任务是进行文件系统的分享，文件系统的分享则与权限有关。 所以 NFS 服务器启动时至少需要两个 daemons ，一个管 理客户端是否能够登入的问题， 一个管理客户端能够取得的权限。如果你还想要管理 quota 的话&lt;/span&gt;，那么 NFS 还得要再加载其他的 RPC 程序就是了。我们以较单纯的 NFS 服 务器来说：需要启动以下daemon.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rpc.nfsd：&lt;/span&gt;最主要的 NFS 服务器服务提供程序。这个 daemon 主要的功能就是在管理客户端是否能够使用服务器文件系统挂载信息等， 其中还包含判断这个登录用户的 ID 。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rpc.mountd：&lt;/span&gt;这个 daemon 主要的功能，则是在管理 NFS 的文件系统哩！当客户端顺利的通过 rpc.nfsd 而登入服务器之后，在他可以使用 NFS 服务器提供的档案之前， 还会经过档案权限 (就是那个 -rwxrwxrwx 与 owner, group 那几个权限啦) &lt;/p&gt;
&lt;p&gt;的认证程序！他会去读 NFS 的配置文件 /etc/exports 来比对客户端的权限， 当通过这一关之后客户端就可以取得使用 NFS 档案的权限啦！(注：这个也是我 们用来管理 NFS 分享之目录的权限与安全设定的地方哩！)&lt;/p&gt;
&lt;p&gt;&lt;span&gt; rpc.lockd&lt;/span&gt; ：(非必要)：这个玩意儿可以用在管理档案的锁定 (lock) 用途。为何档案需要『锁定』呢？&lt;/p&gt;
&lt;p&gt;因为既然分享的 NFS 档案可以让客户端使用，那么当多个客户端同时尝试写入 某个档案时， 就可能对于该档案造成一些问题啦！这个 rpc.lockd 则可以用来&lt;/p&gt;
&lt;p&gt;克服这个问题。 但 rpc.lockd 必须要同时在客户端与服务器端都开启才行喔！ 此外， rpc.lockd 也常与 rpc.statd 同时启用。&lt;br/&gt;&lt;span&gt;rpc.statd&lt;/span&gt; ：(非必要)可以用来检查档案的一致性，与 rpc.lockd 有关！若发生因为客户端同时使用同一档案造成档案可能有所损毁时， rpc.statd 可以用来检测并尝试回复该档 案。与 rpc.lockd 同样的，这个功能必须要在服务器端与客户端都启动才会生 效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、所需要的软件及软件结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要设定好 NFS 服务器我们必须要有两个软件才行，分别是：&lt;/p&gt;
&lt;p&gt;RPC 主程序：rpcbind&lt;/p&gt;
&lt;p&gt;就如同刚刚提的到，我们的 NFS 其实可以被视为一个 RPC 服务，而要启动任何 一个 RPC 服务之前，我们都需要做好 port 的对应 (mapping) 的工作才行，这 个工作其实就是『 rpcbind 』这个服务所负责的！也就是说， 在启动任何一个 RPC 服务之前，我们都需要启动 rpcbind 才行！ &lt;span&gt;(在 CentOS 5.x 以前这个软 件称为 portmap，在 CentOS 6.x 之后才称为 rpcbind 的！)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NFS 主程序：nfs-utils&lt;/p&gt;
&lt;p&gt;就是提供 rpc.nfsd 及 rpc.mountd 这两个 NFS daemons 与其他相关 documents 与说明文件、执行文件等的软件！这个就是 NFS 服务所需要的主要 软件啦！一定要有喔！&lt;/p&gt;
&lt;p&gt;NFS 软件结构：&lt;/p&gt;
&lt;p&gt;/etc/exports：(主要配置文件)：这个档案就是 NFS 的主要配置文件了！不过，系统并没有默认值，所以这个档案『 不一定会存在』，你可能必须要使用 vim 主动的建立起这个文件(/&lt;span&gt;var/lib/nfs/etab 默认的权限设置&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt; /usr/sbin/exportfs （NFS 文件系统维护指令）：这个是维护 NFS 分享资源的指令，我们可以利用这个指令重新分享/etc/exports 变更的目录资源、将 NFS Server 分享的目录卸除或重新分享等 等，这个指令是 NFS 系统里面相当重要的一个&lt;/p&gt;
&lt;p&gt; /var/lib/nfs/*tab(分享资源的登录档)：在 NFS 服务器的登录文件都放置到 /var/lib/nfs/ 目录里面，在该目录下有两个比较重要的登录档， 一个是 etab ，主要记录了 NFS 所分享出来的目录的完 整权限设定值；另一个 xtab 则记录曾经链接到此 NFS 服务器的相关客户端数 据。&lt;/p&gt;
&lt;p&gt;/usr/sbin/showmount （客户端查询服务器分享资源的指令）：这是另一个重要的 NFS 指令。exportfs 是用在 NFS Server 端，而 showmount则主要用在 Client 端。这个 showmount 可以用来察看 NFS 分享出来的目录资 源&lt;/p&gt;
&lt;p&gt;/etc/sysconfig/nfs: 主要设置端口   &lt;span&gt;（ “ NFS 随便选取数个端口向 RPC 注册”时 产生的daemon的端口，rpc.nfsd：rpc.mountd： rpc.lockd rpc.statd  rpc.rquotad 等等。）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 30 Aug 2018 07:44:00 +0000</pubDate>
<dc:creator>yuanbangchen</dc:creator>
<og:description>一、NFS服务简介 NFS 就是 Network FileSystem 的缩写，最早之前是由sun 这家公司所发展出来的。 它最大的功能就是可以透过网络，让不同的机器、不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yuanbangchen/p/9560586.html</dc:identifier>
</item>
<item>
<title>Python学习笔记（12）-文件操作、应用小练习 - 立鼕</title>
<link>http://www.cnblogs.com/lidongaistudy/p/9560562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lidongaistudy/p/9560562.html</guid>
<description>&lt;h2&gt;文件操作&lt;/h2&gt;
&lt;p&gt;使用文件的目的：把执行代码时产生的数据存储起来，下一次执行代码时直接使用，不必重新在制作一份&lt;/p&gt;
&lt;p&gt;文件操作方式：打开文件、读/写文件数据、关闭文件&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;打开文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;表现形式1：f = open(&quot;test.txt&quot;,&quot;r&quot;)&lt;/p&gt;
&lt;p&gt;以读的方式打开已存在的名为test.txt的文件，使用变量f指向打开的test.txt文件&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;1、文件test.txt若不存在代码将报错并退出&lt;/p&gt;
&lt;p&gt;2、以读的方式打开的文件无法向文件中写入数据&lt;/p&gt;
&lt;p&gt;3、文件名与操作方式（读/写）都要加成对引号&lt;/p&gt;
&lt;p&gt;4、如果是以读的方式打开文件&quot;r&quot;可省略不行，默认为以读的方式打开，也可以写成f = open(&quot;test.txt&quot;)&lt;/p&gt;
&lt;p&gt;表现形式2：f = open(&quot;test.txt&quot;,&quot;w&quot;)&lt;/p&gt;
&lt;p&gt;以写的方式打开文件test.txt，test.txt文件若存在，则覆盖，test.txt文件若不存在，则创建文件test.txt，使用变量f指向打开的test.txt文件&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;以写的方式打开的文件无法读取文件内容&lt;/p&gt;
&lt;p&gt;表现形式3：f = open(&quot;test.txt&quot;,&quot;a&quot;)&lt;/p&gt;
&lt;p&gt;以写的方式打开文件test.txt，test.txt文件若存在，写入的内容会追加在原文件内容末尾，test.txt文件若不存在，则创建文件test.txt，使用变量f指向打开的test.txt文件&lt;/p&gt;
&lt;h3&gt;关闭文件&lt;/h3&gt;
&lt;p&gt;表现形式：close()&lt;/p&gt;
&lt;p&gt;例如：关闭文件test.txt&lt;/p&gt;
&lt;p&gt;f = open(&quot;test.txt&quot;,&quot;w&quot;)&lt;/p&gt;
&lt;p&gt;f.close()&lt;/p&gt;
&lt;p&gt;注意事项：关闭文件与打开文件成对使用，不可以打开文件操作后不关闭文件&lt;/p&gt;
&lt;h3&gt;文件的读写&lt;/h3&gt;
&lt;p&gt;向文件中写入数据（write）：&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830140715622-1247882037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、如果文件不存在则创建，如果存在就先将文件清空，然后写入数据&lt;/p&gt;
&lt;p&gt;2、写入文件操作是从文件开头开始&lt;/p&gt;
&lt;p&gt;3、图中的11表示向文件中写入了多少字节内容&lt;/p&gt;
&lt;p&gt;从文件中读取数据（read）:&lt;/p&gt;
&lt;p&gt;1、按文件内容中长度读取read(num)，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830141419134-953259697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;num的单位是字节，表示每次读取的字节数&lt;/p&gt;
&lt;p&gt;多次读取时下一次读取的内容是从上一次读取完内容的位置开始的&lt;/p&gt;
&lt;p&gt; 2、将文件中内容全部读取read(),如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830141928823-1154128289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：一般不建议使用这种读取方式，因为如果文件过大（比如5G），内存很小（比如4G）的情况下，一次全部读取文件内容会令程序死掉&lt;/p&gt;
&lt;p&gt;3、将文件中内容全部读取，但按照行的方式显示readlines(),如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830142509689-1604022562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：readlines读取方式得到的是一个列表，每行的内容为一个元素&lt;/p&gt;
&lt;p&gt;4、按文件内容中行内容读取readline()，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830142820192-667454042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;文件的定位读写&lt;/h3&gt;
&lt;p&gt;文件的定位读写就是从文件的某一位置开始进行读写&lt;/p&gt;
&lt;p&gt;表现形式：seek(offset,from)&lt;/p&gt;
&lt;p&gt;offset：偏移量（单位：字节）&lt;/p&gt;
&lt;p&gt;from：从哪个位置开始便宜，共有三个参数（0：表示文件开头 1：表示当前位置 2：表示文件末尾）&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;从文件开头并且偏移3个字节开始读取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830144506204-541769504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;文件的重命名、删除&lt;/h3&gt;
&lt;p&gt;说明：文件重命名、删除操作需要python的os模块支持&lt;/p&gt;
&lt;p&gt;重命名：os.rename(需要修改的原文件名, 新的文件名)&lt;/p&gt;
&lt;p&gt;删除：os.remove(需要删除的文件名)&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;import os&lt;/p&gt;
&lt;p&gt;os.rename(&quot;test.txt&quot;,&quot;新test.txt&quot;)&lt;/p&gt;
&lt;p&gt;os.remove(&quot;test.txt&quot;)&lt;/p&gt;
&lt;h3&gt;文件夹的相关操作&lt;/h3&gt;
&lt;p&gt;说明：文件夹的相关操作需要python的os模块支持&lt;/p&gt;
&lt;p&gt;获取当前所在目录：os.getcwd()&lt;/p&gt;
&lt;p&gt;创建文件夹：os.mkdir(&quot;test&quot;)&lt;/p&gt;
&lt;p&gt;删除文件夹：os.rmdir(&quot;test&quot;)&lt;/p&gt;
&lt;p&gt;跳转到其他目录：os.chdir(&quot;aaa&quot;)&lt;/p&gt;
&lt;p&gt;获取目录下文件夹和文件名称：os.listdir()（得到的数据类型是列表）&lt;/p&gt;
&lt;h2&gt;应用小练习&lt;/h2&gt;
&lt;h3&gt;制作文件的备份&lt;/h3&gt;
&lt;p&gt;要求：通过输入的文件名称备份该文件内容，且将文件名字更改成原文件名【复件】&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;1、想要在test.txt更改成test[复件].txt先要找到点的索引值，然后将字符串切片重组&lt;/p&gt;
&lt;p&gt;2、尽量不要一次全部读取原文件，所以使用每次读取1024字节来读取&lt;/p&gt;
&lt;p&gt;3、读取或者写入文件后不要忘记关闭文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830152656600-1286993723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;批量修改文件名&lt;/h3&gt;
&lt;p&gt;要求：通过输入的文件夹名称将文件夹下的所有文件全部重命名，在每个文件名开头上加上【测试修改】&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;图1：重命名前&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830153738819-997001586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;图2：重命名后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1468712/201808/1468712-20180830153857332-358459992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;1、需要python下os模块支持&lt;/p&gt;
&lt;p&gt;2、rename()只能修改当前路径下的文件，所以需事先跳转到test文件夹下&lt;/p&gt;
&lt;p&gt;3、获取文件名称操作得到的是列表，所以可以通过遍历列表来获取每一个文件名&lt;/p&gt;
</description>
<pubDate>Thu, 30 Aug 2018 07:41:00 +0000</pubDate>
<dc:creator>立鼕</dc:creator>
<og:description>文件操作 使用文件的目的：把执行代码时产生的数据存储起来，下一次执行代码时直接使用，不必重新在制作一份 文件操作方式：打开文件、读/写文件数据、关闭文件 打开文件 表现形式1：f = open(&amp;qu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lidongaistudy/p/9560562.html</dc:identifier>
</item>
<item>
<title>Nginx（一）------简介与安装 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9384877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9384877.html</guid>
<description>&lt;p&gt;　　说到 Nginx ，可能大家最先想到的就是其负载均衡以及反向代理的功能。没错，这也是当前使用 Nginx 最频繁的两个功能，但是 Nginx 可不仅仅只有这两个功能，其作用还是挺大的，本系列博客就来慢慢解开 Nginx 神秘的面纱。&lt;/p&gt;
&lt;h3&gt;1、Nginx 的简介&lt;/h3&gt;
&lt;p&gt;　　Nginx 是由俄罗斯人 Igor Sysoev 设计开发的，开发工作从2002 年开始，第一次公开发布在 2004 年 10 月 4 日。&lt;/p&gt;
&lt;p&gt;　　官方网站为：&lt;a href=&quot;http://nginx.org/&quot; target=&quot;_blank&quot;&gt;http://nginx.org/&lt;/a&gt; 。它是一款免费开源的高性能 HTTP 代理服务器及反向代理服务器（Reverse Proxy）产品，同时它还可以提供 IMAP/POP3 邮件代理服务等功能。它高并发性能很好，官方测试能够支撑 5 万的并发量；运行时内存和 CPU 占用率低，配置简单，容易上手，而且运行非常稳定。&lt;/p&gt;
&lt;h3&gt;2、Nginx 的常用功能&lt;/h3&gt;
&lt;p&gt;　　其实 Nginx 的功能特别多，这里我只介绍几个常用的功能，具体的大家可以参考&lt;a href=&quot;http://nginx.org/en/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;介绍。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、反向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这是 Nginx 服务器作为 WEB 服务器的主要功能之一，客户端向服务器发送请求时，会首先经过 Nginx 服务器，由服务器将请求分发到相应的 WEB 服务器。正向代理是代理客户端，而反向代理则是代理服务器，Nginx 在提供反向代理服务方面，通过使用正则表达式进行相关配置，采取不同的转发策略，配置相当灵活，而且在配置后端转发请求时，完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的连接、请求等。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这也是 Nginx 最常用的功能之一，负载均衡，一方面是将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后将结果汇总返回给用户，这样可以大幅度提高网络系统的处理能力；另一方面将大量的前端并发请求或数据流量分担到多个后端网络节点分别处理，这样可以有效减少前端用户等待相应的时间。而 Nginx 负载均衡都是属于后一方面，主要是对大量前端访问或流量进行分流，已保证前端用户访问效率，并可以减少后端服务器处理压力。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、Web 缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在很多优秀的网站中，Nginx 可以作为前置缓存服务器，它被用于缓存前端请求，从而提高 Web服务器的性能。Nginx 会对用户已经访问过的内容在服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 Nginx 服务器向后端发出请求。减轻网络拥堵，减小数据传输延时，提高用户访问速度。&lt;/p&gt;
&lt;h3&gt;3、Nginx 安装&lt;/h3&gt;
&lt;p&gt;　　关于 Nginx 的安装，分为在 Windows 平台和 Linux 平台安装，Windows 版本的 Nginx 服务器在效率上要比 Linux 版本的 Nginx 服务器差一些，而且实际使用的一般都是 Linux 平台的 Nginx 服务器。所以后期我们介绍时也会以 Linux 版本的为主。&lt;/p&gt;
&lt;h4&gt;①、下载地址&lt;/h4&gt;
&lt;p&gt;　　Nginx 下载地址：&lt;a href=&quot;http://nginx.org/en/download.html&quot; target=&quot;_blank&quot;&gt;http://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729191301014-1758800936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　开发版本主要用于 Nginx 软件项目的研发，稳定版本说明可以作为 Web 服务器投入商业应用。这里我们选择当前稳定版本：&lt;strong&gt;nginx-1.14.0&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;②、Windows 版本安装&lt;/h4&gt;
&lt;p&gt;　　我们将上一步下载的 nginx-1.14.0.zip 文件解压到当前目录。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729192109716-560612925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解压目录如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729192204644-36563477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面对这个目录下的主要文件夹进行介绍：&lt;/p&gt;
&lt;p&gt;　　1、conf 目录：存放 Nginx 的主要配置文件，很多功能实现都是通过配置该目录下的 nginx.conf 文件，后面我们会详细介绍。&lt;/p&gt;
&lt;p&gt;　　2、docs 目录：存放 Nginx 服务器的主要文档资料，包括 Nginx 服务器的 LICENSE、OpenSSL 的 LICENSE 、PCRE 的 LICENSE 以及 zlib 的 LICENSE ，还包括本版本的 Nginx服务器升级的版本变更说明，以及 README 文档。&lt;/p&gt;
&lt;p&gt;　　3、html 目录：存放了两个后缀名为 .html 的静态网页文件，这两个文件与 Nginx 服务器的运行相关。&lt;/p&gt;
&lt;p&gt;　　4、logs 目录：存放 Nginx 服务器运行的日志文件。&lt;/p&gt;
&lt;p&gt;　　5、nginx.exe：启动 Nginx 服务器的exe文件，如果 conf 目录下的 nginx.conf 文件配置正确的话，通过该文件即可启动 Nginx 服务器。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一、启动 nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　双击解压之后目录中的 nginx.exe 文件，出现一闪而过的画面，则启动成功。&lt;/p&gt;
&lt;p&gt;　　然后在浏览器中输入 http://localhost 或者 http://localhost:80 出现如下界面即启动成功。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729212236786-1123186926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ps:该页面即是上面解压目录中 html 目录下的 index.html 文件。&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;二、关闭 nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　进入到解压之后的目录，输入如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; nginx.exe -s stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729222251887-1052720801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或者也可以打开任务管理器，找到 nginx 的进程，直接右键结束。&lt;/p&gt;
&lt;h4&gt;③、Linux 版本安装&lt;/h4&gt;
&lt;p&gt;　　选择的 Linux 系统为 CentOS6.8。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一、安装 nginx 环境&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; yum install gcc-c++
&lt;span&gt;2&lt;/span&gt; yum install -y pcre pcre-&lt;span&gt;devel
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; yum install -y zlib zlib-&lt;span&gt;devel
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; yum install -y openssl openssl-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于 gcc，因为&lt;span&gt;安装&lt;/span&gt;nginx&lt;span&gt;需要先将官网下载的源码进行编译，编译依赖&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;环境，如果没有&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;环境的话，需要安装&lt;/span&gt;&lt;span&gt;gcc。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于 &lt;/span&gt;pcre，prce(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;对于 zlib，zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。&lt;/p&gt;
&lt;p&gt;　　对于 openssl，OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;二、编译安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先将下载的 nginx-1.14.0.tar.gz 文件复制到 Linux 系统中，然后解压：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; tar -zxvf nginx-1.14.0.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着进入到解压之后的目录，进行编译安装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ./configure --prefix=/usr/local/&lt;span&gt;nginx
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;make
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：指定 /usr/local/nginx 为nginx 服务安装的目录。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;三、启动 nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;进入到 /usr/local/nginx 目录，文件目录显示如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729220525790-1171040940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接着我们进入到 sbin 目录，通过如下命令启动 nginx：&lt;/p&gt;

&lt;p&gt;　　当然你也可以配置环境命令，这样在任意目录都能启动 nginx。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729220731705-1475271343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Linux 没有消息就好消息，不提示任何信息说明启动成功。&lt;/p&gt;
&lt;p&gt;　　或者也可以输入如下命令，查看 nginx 是否有服务正在运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ps -ef | grep nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们在浏览器输入Linux系统的IP地址，出现windows安装成功的界面即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180729221057300-343596218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;四、关闭 nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有两种方式：&lt;/p&gt;
&lt;p&gt;　　方式1：快速停止&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cd /usr/local/nginx/&lt;span&gt;sbin
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ./nginx -s stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。不太友好。&lt;/p&gt;
&lt;p&gt;　　方式2：平缓停止&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cd /usr/local/nginx/&lt;span&gt;sbin
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ./nginx -s quit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此方式是指允许 nginx 服务将当前正在处理的网络请求处理完成，但不在接收新的请求，之后关闭连接，停止工作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;五、重启 nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　方式1：先停止再启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ./nginx -&lt;span&gt;s quit
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ./nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相当于先执行停止命令再执行启动命令。&lt;/p&gt;
&lt;p&gt;　　方式2：重新加载配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ./nginx -s reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通常我们使用nginx修改最多的便是其配置文件 nginx.conf。修改之后想要让配置文件生效而不用重启 nginx，便可以使用此命令。&lt;/p&gt;

</description>
<pubDate>Thu, 30 Aug 2018 07:36:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Nginx（一）------简介与安装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9384877.html</dc:identifier>
</item>
<item>
<title>Deferred Shading 延迟着色（翻译） - 果子鲤鱼</title>
<link>http://www.cnblogs.com/gozili/p/9558580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gozili/p/9558580.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;https://en.wikipedia.org/wiki/Deferred_shading&quot;&gt;https://en.wikipedia.org/wiki/Deferred_shading&lt;/a&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5539033457249&quot;&gt;在3D计算机图形学领域，&lt;span&gt;deferred shading &lt;/span&gt;是一种&lt;a href=&quot;https://en.wikipedia.org/wiki/Screen-space&quot; target=&quot;_blank&quot;&gt;屏幕空间&lt;/a&gt;着色技术。它被称为Deferred，是因为实际上在第一次pass中的顶点和像素着色器中没有执行着色：相反，着色是“deferred（延迟）”到第二个pass中执行。&lt;/div&gt;
&lt;p&gt;在deferred着色器的第一次pass中，只收集着色计算所需的数据。每个表面的位置、法线和材质，然后使用“render to texture”技术渲染到几何缓冲（G-buffer）中。在这之后，像素着色器使用屏幕空间中纹理缓冲区的信息计算每个像素的直接和间接光照。&lt;/p&gt;
&lt;div readability=&quot;4.5428571428571&quot;&gt;


&lt;h3&gt;优点&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;Deferred着色的主要优点是场景几何与光照的分离。只需要一个几何Pass，而每一个灯光只计算它实际影响的像素。这样就可以在不影响性能的情况下渲染场景中的多个灯光。这种方法还有其他一些优点。这些优点可能包括更简单地管理复杂的光照资源、易于管理其他复杂的着色器资源、简化软件渲染管线。&lt;/p&gt;
&lt;h3&gt;缺点&lt;/h3&gt;
&lt;hr/&gt;&lt;div readability=&quot;13.527331189711&quot;&gt;Deferred渲染的一个关键缺点是无法处理算法中的透明，虽然这个问题是Z-buffer场景中的一个常见问题，它往往通过延迟和排序来处理渲染场景透明的部分。深度剥离可用于实现Deferred渲染中的&lt;a href=&quot;https://en.wikipedia.org/wiki/Order-independent_transparency&quot; target=&quot;_blank&quot;&gt;顺序无关透明度&lt;/a&gt;，但是要以额外的批处理和g-buffer大小为代价。支持DireactX 10或更高版本的现代硬件通常能够以足够快的速度执行批处理，以保持足够的帧率去实现交互。当采用顺序无关的透明度时（通常用于消费级应用程序），Deferred着色的效率并不低于使用相同技术的Forward着色。&lt;/div&gt;
&lt;p&gt;另一个严重的缺点是使用多个材质的困难。虽然可以使用多个不同的材质，但是需要在G-buffer中存储更多的数据，数据已经相当大了并且消耗了大量的内存带宽。&lt;/p&gt;
&lt;div readability=&quot;22.86108714409&quot;&gt;另一个相当严重的缺点是，由于光照阶段和几何阶段的分离，硬件&lt;a href=&quot;https://en.wikipedia.org/wiki/Spatial_anti-aliasing&quot; target=&quot;_blank&quot;&gt;抗锯齿&lt;/a&gt;不再产生正确的结果，因为插值子样本将导致无意义的位置、法线和切线属性。克服这一限制的常用技术之一是在最终图像上使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Edge_detection&quot; target=&quot;_blank&quot;&gt;边缘检测&lt;/a&gt;，然后在边缘上使用模糊，然而，最近开发了更先进的后处理边缘平滑技术，比如&lt;a href=&quot;http://igm.univ-mlv.fr/~biri/mlaa-gpu/TMLAA.pdf&quot; target=&quot;_blank&quot;&gt;MLAA&lt;/a&gt;（在《KillZone 3》和《Dragon Age II》中使用），FXAA（用于《Crysis 2》、《FEAR 3》、《Duke Nukem Forever》），&lt;a href=&quot;https://research.nvidia.com/publication/subpixel-reconstruction-antialiasing&quot; target=&quot;_blank&quot;&gt;SRAA&lt;/a&gt;,&lt;a href=&quot;http://and.intercon.ru/releases/talks/dlaagdc2011/&quot; target=&quot;_blank&quot;&gt;DLAA&lt;/a&gt;（用于《Star Wars：The Force Unileashed II》），和MSAA（在《孤岛危机2》中用作默认的反锯齿解决方案）。虽然它不是一种边缘平滑技术，但&lt;a href=&quot;https://en.wikipedia.org/wiki/Temporal_anti-aliasing&quot; target=&quot;_blank&quot;&gt;Temporal anti-aliasing&lt;/a&gt;（在Halo Reach和虚幻引擎中使用）也可以帮助边缘平滑外观。DirectX引入了允许着色器访问多重采样渲染目标中的单个样本的特性（10.1的深度缓冲区），让使用这个API的用户在Deferred着色器中访问硬件抗锯齿。这些特性还允许它们正确地将HDR亮度映射应用到抗锯齿边缘，在API的早期版本中，任何抗锯齿的优势都已经丢失了。&lt;/div&gt;
&lt;h3&gt;Deferred lighting&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;Deferred Lighting（也被称为Light Pre-Pass）是对Deferred Shading的一种修改。在Deferred shading中这个技术使用了三个Pass，而不是两个Pass。在第一遍pass场景几何图形时，只将计算每像素光照（辐射度）所需的属性写入G-buffer中。屏幕空间，“Deferred”Pass只输出漫反射和高光光照数据，所以必须在场景上进行第二遍Pass，以读取照明数据并输出最终的像素着色。Deferred lighting的明显优势是大大减少了G-buffer的大小。明显的代价是需要渲染场景几何两次而不是一次。另一个额外的成本是在Deferred lighting中的Deferred pass必须分别输出漫反射和镜面辐射，而Deferred shading中的Deferred pass只需要输出单个的组合辐射值。&lt;/p&gt;
&lt;p&gt;由于减小了G-buffer的大小，这种技术可以克服Deferred shading的一个严重缺点——多材质。另一个可以解决的问题是MSAA。Deferred lighting可以在DirectX9硬件上与MSAA一起使用。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Deferred lighting在商业游戏中的应用&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;span title=&quot;Alan Wake&quot;&gt;这种技术在视频游戏中的使用越来越多了，因为它可以使用大量的动态灯光，减少了需要的着色器指令的复杂性。一些使用了Deferred lighting的例子有：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Deferred shading在商业游戏中的应用&lt;/span&gt;&lt;/h3&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;与Deferred lighting相比，由于内存大小和带宽要求较高，这种技术并不是很流行。特别是在第7代主机上，图形内存大小和带宽是有限的，常常是瓶颈。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;具有Deferred shading技术的游戏引擎&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;h3&gt;历史&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;Deferred shading的概念最初是由Michael Deering和他的同事于1988年发表的一篇名为《 &lt;span&gt;The triangle processor and normal vector shader: a VLSI system for high performance graphics》论文中提出的。虽然文中从未使用“Deferred”一词，但介绍了一个关键的概念。 each pixel is shaded only once after depth resolution。我们今天所知道的Deferred shading，使用g-buffer，是由Saito和Takahashi在1990年的一片论文中介绍的，虽然他们也不使用“Deferred”这个词。第一个使用Deferred shading的视频游戏是《怪物史莱克》，这是2001年推出的xbox游戏。大约在2004年，商业图形硬件开始出现。这种技术后来在视频游戏等应用程序中流行起来，最终在2008年至2010年成为主流。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Aug 2018 07:19:00 +0000</pubDate>
<dc:creator>果子鲤鱼</dc:creator>
<og:description>原文地址：https://en.wikipedia.org/wiki/Deferred_shading 在3D计算机图形学领域，deferred shading 是一种屏幕空间着色技术。它被</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gozili/p/9558580.html</dc:identifier>
</item>
<item>
<title>C# WPF 通过委托实现多窗口间的传值 - hello黄先森</title>
<link>http://www.cnblogs.com/hellohxs/p/9528505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellohxs/p/9528505.html</guid>
<description>&lt;p&gt;在使用WPF开发的时候就不免会遇到需要两个窗口间进行传值操作，当然多窗口间传值的方法有很多种，本文介绍的是使用委托实现多窗口间的传值。&lt;/p&gt;
&lt;p&gt;在上代码之前呢，先简单介绍一下什么是C#中的委托（如果只想了解如何传值可以略过这部分）在网络上有很多对于委托的介绍和讲解，经过我的学习和总结加上了一点我自己的理解，我认为委托是一种类似于C语言的指针，但是它指向的是方法而不是变量。如果把委托看作一个变量，那么这个变量里存着的就是你目标方法的地址，&lt;strong&gt;调用委托约等于调用你的目标方法&lt;/strong&gt;。（个人理解欢迎指正交流）&lt;/p&gt;

&lt;p&gt;以下正文：&lt;/p&gt;
&lt;p&gt;实现窗口间的相互传值，先创建两个窗口，先上代码主窗口代码：&lt;/p&gt;
&lt;p&gt;MainWindow.xaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;Grid&amp;gt;
 　&amp;lt;TextBox Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MainWindowTextBox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10,61,0,0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; TextWrapping=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wrap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
 　&amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开新窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10,130,0,0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ButtonBase_OnClick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; MainWindow.xaml.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetValue(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value1, TextBox value2)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 　　&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 　　　　MainWindowTextBox.Text =&lt;span&gt; value1;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ButtonBase_OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 　　&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 　　　　Window1 newWindow1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Window1();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 　　　　newWindow1.getTextHandler = GetValue;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将方法赋给委托对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 　　　　&lt;span&gt;newWindow1.ShowDialog();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12　　 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223717/201808/1223717-20180830133310923-69425951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二个窗口Window1代码：&lt;/p&gt;
&lt;p&gt;Window1.xaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;Grid&amp;gt;
    &amp;lt;TextBox Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Window1TextBox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;84,73,0,0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; TextWrapping=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wrap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Text=&lt;span&gt;&quot;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;Button Content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;传值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Margin=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;84,125,0,0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalAlignment=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ButtonBase_OnClick&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Window1.xaml.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetTextHandler(&lt;span&gt;string&lt;/span&gt; value1, TextBox value2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明委托&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; GetTextHandler getTextHandler;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托对象&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ButtonBase_OnClick(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 　　&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 　　　　&lt;span&gt;getTextHandler(Window1TextBox.Text, Window1TextBox);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223717/201808/1223717-20180830134155893-1453387894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现效果当运行程序后，点击打开新窗口按钮后，会打开Window1窗口，在Window1窗口的Textbox中输入内容，点击传值，你所输入的内容就会传到主窗口，通过委托的事件将主窗口中的Textbox控件的内容更改为你传过去的值。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223717/201808/1223717-20180830134727381-777009062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1223717/201808/1223717-20180830134740821-1767025735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在就已经实现了窗口间传值的操作了。接下来我会简单介绍一下以上代码的实现方法和一些自己的理解，如果不感兴趣或者已经会使用委托进行多窗口间的传值了，后面的部分可以略过。 &lt;/p&gt;
&lt;p&gt;前台代码在此就先不介绍了哈，在MainWindow.xaml.cs文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetValue(&lt;span&gt;string&lt;/span&gt; value1, TextBox value2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此方法即为委托的目标方法，此方法返回值为空，也可以设置其返回值，当使用委托时也会收到目标方法的返回值。再有就是此方法接收两个参数，一个是字符串一个是TextBox，第二个参数倒是没什么实际含义，只是为了说明这里传递的变量可以多个，也可以是其它object类型。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
newWindow1.getTextHandler = GetValue;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将方法赋给委托对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将方法赋给委托对象，可以理解为把他们两个绑定在一起的getTextHandler这个委托对应的目标方法就是GetValue。&lt;/p&gt;
&lt;p&gt;在Windo1.xaml.cs中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetTextHandler(&lt;span&gt;string&lt;/span&gt; value1, TextBox value2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明委托&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; GetTextHandler getTextHandler;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;delegate是声明委托的关键字，这里的返回值为空，若目标方法是有返回值的，在这里将返回值写成同种类型即可，接收的两个变量类型也要和目标方法一致。&lt;/p&gt;
&lt;p&gt;接下来就是定义委托对象，大写的GetTextHandler是委托，而小写的getTextHandler是对象，在使用该委托时候使用的也是小写的getTextHandler使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
getTextHandler(Window1TextBox.Text, Window1TextBox);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;行文至尾，委托的使用还有很多，例如：事件订阅，匿名方法，多播委托等等，本文介绍的则是委托的基本使用方法，其他的用法仍在学习当中，欢迎指正交流。&lt;/p&gt;

&lt;p&gt;2018.8.30下午三点差五分&lt;/p&gt;
</description>
<pubDate>Thu, 30 Aug 2018 07:06:00 +0000</pubDate>
<dc:creator>hello黄先森</dc:creator>
<og:description>在使用WPF开发的时候就不免会遇到需要两个窗口间进行传值操作，当然多窗口间传值的方法有很多种，本文介绍的是使用委托实现多窗口间的传值。 在上代码之前呢，先简单介绍一下什么是C#中的委托（如果只想了解如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellohxs/p/9528505.html</dc:identifier>
</item>
<item>
<title>阻塞队列之LinkedBlockingQueue - 多读书多看报</title>
<link>http://www.cnblogs.com/duodushuduokanbao/p/9556555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duodushuduokanbao/p/9556555.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkedBlockingQueue内部由&lt;strong&gt;单链表实现&lt;/strong&gt;，只能从head取元素，从tail添加元素。添加元素和获取元素都有独立的锁，也就是说&lt;strong&gt;LinkedBlockingQueue是读写分离的&lt;/strong&gt;，读写操作可以并行执行。LinkedBlockingQueue采用可重入锁(&lt;strong&gt;ReentrantLock)&lt;/strong&gt;来保证在并发情况下的线程安全。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkedBlockingQueue一共有三个构造器，分别是无参构造器、可以指定容量的构造器、可以穿入一个容器的构造器。如果在创建实例的时候调用的是无参构造器，LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，这样做很可能会导致队列还没有满，但是内存却已经满了的情况（内存溢出）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; LinkedBlockingQueue()；   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置容量为Integer.MAX&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; LinkedBlockingQueue(&lt;span&gt;int&lt;/span&gt; capacity)；  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置指定容量&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; LinkedBlockingQueue(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt; c)；  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;穿入一个容器，如果调用该构造器，容量默认也是Integer.MAX_VALUE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;LinkedBlockingQueue常用操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;take()：首选。当队列为空时阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;poll()：弹出队顶元素，队列为空时，返回空&lt;/p&gt;
&lt;p&gt;peek()：和poll烈性，返回队队顶元素，但顶元素不弹出。队列为空时返回null&lt;/p&gt;
&lt;p&gt;remove(Object o)：移除某个元素，队列为空时抛出异常。成功移除返回true&lt;/p&gt;

&lt;p&gt;&lt;span&gt;添加数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;put()：首选。队满是阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;offer()：队满时返回false&lt;/p&gt;

&lt;p&gt;&lt;span&gt;判断队列是否为空&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size()方法会遍历整个队列，时间复杂度为O(n),所以最好选用isEmtpy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;put元素原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基本过程：&lt;/p&gt;
&lt;p&gt;1.判断元素是否为null，为null抛出异常&lt;/p&gt;
&lt;p&gt;2.加锁(可中断锁)&lt;/p&gt;
&lt;p&gt;3.判断队列长度是否到达容量，如果到达一直等待&lt;/p&gt;
&lt;p&gt;4.如果没有队满，enqueue()在队尾加入元素&lt;/p&gt;
&lt;p&gt;5.队列长度加1，此时如果队列还没有满，调用signal唤醒其他堵塞队列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;        
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; c = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Node&amp;lt;E&amp;gt; node = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt;(e);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; ReentrantLock putLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.putLock;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; AtomicInteger count = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        putLock.lockInterruptibly();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (count.get() ==&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                notFull.await();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            enqueue(node);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             c =&lt;span&gt; count.getAndIncrement();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c + 1 &amp;lt;&lt;span&gt; capacity)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                notFull.signal();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            putLock.unlock();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;take元素原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 基本过程：&lt;/p&gt;
&lt;p&gt;1.加锁(依旧是ReentrantLock)，注意这里的锁和写入是不同的两把锁&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;判断队列是否为空，如果为空就一直等待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.通过dequeue方法取得数据&lt;/p&gt;
&lt;p&gt;3.取走元素后队列是否为空，如果不为空唤醒其他等待中的队列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; E take() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        E x;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; c = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; AtomicInteger count = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; ReentrantLock takeLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.takeLock;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        takeLock.lockInterruptibly();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (count.get() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                notEmpty.await();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             x =&lt;span&gt; dequeue();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             c =&lt;span&gt; count.getAndDecrement();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (c &amp;gt; 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                notEmpty.signal();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            takeLock.unlock();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (c ==&lt;span&gt; capacity)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            signalNotFull();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enqueue()和dequeue()方法实现都比较简单，无非就是将元素添加到队尾，从队顶取走元素，感兴趣的朋友可以自己去看一下，这里就不粘贴了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;LinkedBlockingQueue与LinkedBlockingDeque比较&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;LinkedBlockingDeque和LinkedBlockingQueue的&lt;strong&gt;相同点&lt;/strong&gt;在于： &lt;br/&gt;1. 基于链表 &lt;br/&gt;2. 容量可选，不设置的话，就是Int的最大值&lt;/p&gt;
&lt;p&gt;和LinkedBlockingQueue的&lt;strong&gt;不同点&lt;/strong&gt;在于： &lt;br/&gt;1. 双端链表和单链表 &lt;br/&gt;2. 不存在哨兵节点 &lt;br/&gt;3. 一把锁+两个条件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 小记：&lt;strong&gt;AtomicInteger的getAndIncrment和getAndDcrement()等方法，这些方法分为两步，get和increment(decrement)，在get和increment中间可能有其他线程进入，导致多个线程get到的数值是相同的，也会导致多个线程累加后的值其实累加1.在这种情况下，使用volatile也是没有效果的&lt;/strong&gt;，因为get之后没有对值进行修改，不能触发&lt;a title=&quot;volatile&quot; href=&quot;https://www.cnblogs.com/duodushuduokanbao/p/9538067.html&quot; target=&quot;_blank&quot;&gt;volatile&lt;/a&gt;的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerAndConsumer {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             BlockingQueue queue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue(5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             ExecutorService executor = Executors.newFixedThreadPool(5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Produer producer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Produer(queue);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                executor.execute(producer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             executor.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(queue));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            executor.shutdown();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Produer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;  Runnable{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BlockingQueue queue;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nums = 20;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环次数
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记数据编号&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; AtomicInteger count = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isRunning = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Produer(){}
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Produer(BlockingQueue queue){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.queue =&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         String data = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             System.out.println(&quot;开始生产数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             System.out.println(&quot;-----------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;           &lt;span&gt;while&lt;/span&gt;(nums&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 nums--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                count.decrementAndGet();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;                 Thread.sleep(500&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 System.out.println(Thread.currentThread().getId()+ &quot; :生产者生产了一个数据&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                queue.put(count.getAndIncrement());
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             System.out.println(&quot;生产者线程退出！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Consumer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BlockingQueue queue;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nums = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isRunning = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Consumer(){}
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Consumer(BlockingQueue queue){
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.queue =&lt;span&gt; queue;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         System.out.println(&quot;消费者开始消费&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         System.out.println(&quot;-------------------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(nums&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             nums--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(isRunning){
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; data =&lt;span&gt; (Integer)queue.take();
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                     Thread.sleep(500&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;                     System.out.println(&quot;消费者消费的数据是&quot; +&lt;span&gt; data);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt;             }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;                Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;             }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                 System.out.println(&quot;消费者线程退出!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; 
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 12&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 11&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 13&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 12&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 消费者消费的数据是-3
&lt;span&gt; 6&lt;/span&gt; 11&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 13&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 12&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 消费者消费的数据是-3
&lt;span&gt;10&lt;/span&gt; 13&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 11&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 12&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 消费者消费的数据是-3
&lt;span&gt;14&lt;/span&gt; 13&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 11&lt;span&gt; :生产者生产了一个数据
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 消费者消费的数据是-3
&lt;span&gt;17&lt;/span&gt; 消费者消费的数据是-3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，有多个producer在生产数据的时候get到的是相同的值。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Aug 2018 07:03:00 +0000</pubDate>
<dc:creator>多读书多看报</dc:creator>
<og:description>概述 LinkedBlockingQueue内部由单链表实现，只能从head取元素，从tail添加元素。添加元素和获取元素都有独立的锁，也就是说LinkedBlockingQueue是读写分离的，读写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duodushuduokanbao/p/9556555.html</dc:identifier>
</item>
<item>
<title>APIGateway网关统一查看多个微服务asp.net core项目的swagger API接口 - LouieGuo</title>
<link>http://www.cnblogs.com/guolianyu/p/9557225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guolianyu/p/9557225.html</guid>
<description>&lt;hr/&gt;&lt;p&gt; 整体架构目录：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/9473676.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core分布式项目实战-目录&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;前提需要下载安装consul，项目需要懂添加swagger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;统一在网关中配置多个微服务的swagger，需要用到服务注册和发现，当然ocelot里面以及拥有了服务发现，因此需要把asp.net core项目先注册到consul中。&lt;/p&gt;
&lt;p&gt;楼主的项目是用到consul。下面的案例的我都是放在window系统上面弄的，正式环境需要把项目都部署到自己的服务器上面。&lt;/p&gt;
&lt;h3&gt;1、讲解：什么叫服务注册和发现&lt;/h3&gt;
&lt;p&gt;微服务的框架体系中，服务发现是不能不提的一个模块。我相信了解或者熟悉微服务的童鞋应该都知道它的重要性。这里我只是简单的提一下，毕竟这不是我们的重点。我们看下面的一幅图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830112427862-1046625971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中，客户端的一个接口，需要调用服务A-N。客户端必须要知道所有服务的网络位置的，以往的做法是配置是配置文件中，或者有些配置在数据库中。这里就带出几个问题：&lt;br/&gt;　　需要配置N个服务的网络位置，加大配置的复杂性&lt;br/&gt;　　服务的网络位置变化，都需要改变每个调用者的配置&lt;br/&gt;　　集群的情况下，难以做负载（反向代理的方式除外）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;总结起来一句话：服务多了，配置很麻烦，问题多多&lt;/p&gt;
&lt;p&gt;既然有这些问题，那么服务发现就是解决这些问题的。话说，怎么解决呢？我们再看一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830112514071-1973285074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与之前一张不同的是，加了个服务发现模块。图比较简单，这边文字描述下。服务A-N把当前自己的网络位置注册到服务发现模块（这里注册的意思就是告诉），服务发现就以K-V的方式记录下，K一般是服务名，V就是IP:PORT。服务发现模块定时的轮询查看这些服务能不能访问的了（这就是健康检查）。客户端在调用服务A-N的时候，就跑去服务发现模块问下它们的网络位置，然后再调用它们的服务。这样的方式是不是就可以解决上面的问题了呢？客户端完全不需要记录这些服务网络位置，客户端和服务端完全解耦！&lt;br/&gt;这个过程大体是这样，当然服务发现模块没这么简单。里面包含的东西还很多。这样表述只是方便理解。&lt;br/&gt;图中的服务发现模块基本上就是微服务架构中服务发现的作用了。&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt;首先先创建一个asp.net core web api 项目，我已经创建好了。然后添加nugut包 consul。&lt;/p&gt;
&lt;h3&gt;1、在项目里面的 Startup.cs  文件里面写上我们的服务注册，我把注册的信息放在了appsetting.json 文件里头了。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830115744356-1263458759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在ConfigureServices写上服务注册&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830142138354-733680577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Configure方法 写上服务注册。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830142158926-1722820507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ConsulApp方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830142228057-62071936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注册服务 RegisterService&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830142258926-1195267833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，consul注册已经OK。&lt;/p&gt;

&lt;h3&gt;2、配置swagger具体内容&lt;/h3&gt;
&lt;p&gt;我把swagger的微服务信息放在appsetting.json 里面了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830143208748-846465283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以在startup.cs中的数据是从这里面获取的&lt;/p&gt;

&lt;p&gt;ConfigureServices方法总填写如下：&lt;/p&gt;
&lt;p&gt;其中里面的【】中的内容是可以替换的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830143943233-1869550020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Configure 方法中填写以下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830143446528-668114988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，swagger配置完成。&lt;/p&gt;

&lt;h3&gt;3、接下来就要部署网关里面的内容啦。&lt;/h3&gt;
&lt;p&gt;apigateway项目也是创建一个asp.net core web api 项目，然后添加swaggernuget包。&lt;/p&gt;
&lt;p&gt;然后在 ConfigureServices方法中写上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830144741607-2135245684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在Configure 方法中写上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830144904775-477287552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;路由表里面写的内容为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830144559470-190277685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 自此配置完成。&lt;/p&gt;


&lt;hr/&gt;&lt;h3&gt; 1、先运行consul&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830145005214-203186268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器url地址：consul运行成功。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830145033435-367778062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2、运行userapi项目和apigateway项目。&lt;/h3&gt;
&lt;p&gt;在consul中发现多了一个userapi的服务注册&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830145132813-84209495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后打开apigateway的swagger项目，可以看到userapi的接口，至此完成配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180830145227933-356222594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 具体swagger怎么配置，可以参考我之前的文章（努力编写中）&lt;/h3&gt;

&lt;h3&gt;&lt;span&gt;参考网址：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;http://www.cnblogs.com/focus-lei/p/9047410.html&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;asp.net core 交流群：&lt;span&gt;787464275&lt;/span&gt; 欢迎加群交流&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;如果您认为这篇文章还不错或者有所收获，您可以点击右下角的【推荐】按钮精神支持，因为这种支持是我继续写作，分享的最大动力！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.7209302325581&quot;&gt;

&lt;p&gt;&lt;strong&gt;声明：原创博客请在转载时保留原文链接或者在文章开头加上本人博客地址，如发现错误，欢迎批评指正。凡是转载于本人的文章，不能设置打赏功能，如有特殊需求请与本人联系！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 30 Aug 2018 06:57:00 +0000</pubDate>
<dc:creator>LouieGuo</dc:creator>
<og:description>0、前言 整体架构目录：ASP.NET Core分布式项目实战-目录 一、准备 前提需要下载安装consul，项目需要懂添加swagger 统一在网关中配置多个微服务的swagger，需要用到服务注册</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guolianyu/p/9557225.html</dc:identifier>
</item>
<item>
<title>深入学习SpringMVC以及学习总结 - MrDong先生</title>
<link>http://www.cnblogs.com/MrXiaoAndDong/p/SpringMVC.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrXiaoAndDong/p/SpringMVC.html</guid>
<description>&lt;p&gt;一、优点：&lt;/p&gt;
&lt;p&gt;　　1.SpringMVC简化web程序开发;&lt;/p&gt;
&lt;p&gt;　　2.SpringMVC效率很好（单例模式）；&lt;/p&gt;
&lt;p&gt;　　3.SpringMVC提供了大量扩展点，方便程序员自定义功能；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1323694/201808/1323694-20180830110829105-1162608856.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　①.DispatcherServlet:核心控制器(springMVC的心脏)中转作用;&lt;/p&gt;
&lt;p&gt;　　　　②.HandlerMapping:映射处理器（处理请求，找到对应的Handler）；&lt;/p&gt;
&lt;p&gt;　　　　③.HandlerAdapter:处理器适配，（Handler实现有两种方法，所以必须适配时候才能运行）;&lt;/p&gt;
&lt;p&gt;　　　　④.Handler:(Controller层):处理器&lt;/p&gt;
&lt;p&gt;　　　　⑤.ViewResolver:视图解析器    通过视图的名称，解析具体的视图对象(jsp文件);&lt;/p&gt;
&lt;p&gt;　　　　⑥.View:具体的视图技术进行渲染;&lt;/p&gt;
&lt;p&gt;二、使用SpringMVC&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;添加依赖
    IOC+AOP
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-webmvc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;此处版本可以根据需要选择&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

配置
    1.配置核心控制器  (web.xml)
&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1.核心控制器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;包含静态资源，也需要拦截  *.do、*.action拦截不到静态资源&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    2. springMVC的配置文件
            默认在WEB-INF/servlet名称-servlet.xml     springMVC-servlet.xml

&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;2.配置HandlerMapping&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;3.配置HandlerAdapter&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;4.配置Handler&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;/hello&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.itany.controller.HelloController&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;5.视图解析器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/WEB-INF/view/&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suffix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.jsp&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;6.使用具体的视图技术渲染&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.JstlView&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、基于注解方式使用SpringMVC&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1.添加依赖
    IOC+AOP
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-webmvc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;此处版本可以根据需要选择&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

2.配置DispatcherServlet
    1.配置核心控制器  (web.xml)
&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;1.核心控制器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springMVC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;包含静态资源，也需要拦截  *.do、*.action拦截不到静态资源&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
3.SpringMVC的配置文件(自定义配置文件)
    需要在servlet中添加一个参数
    &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;自定义springMVC的配置文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;classpath:spring-mvc.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;2 配置HandlerMapping&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;3 配置HandlerAdapter&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;4 配置Handler&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;org.itany.controller&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;


    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;5 配置视图解析器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/WEB-INF/view/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suffix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.jsp&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;6 视图渲染技术&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.JstlView&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;


以上配置中:可以采用
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driver&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;替代我们的第2、3步配置
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、静态资源配置&lt;/p&gt;
&lt;p&gt;　　1.如果DispatcherServlet配置了url-pattern '/' ,那么静态资源放在webapp下也访问不到，DispatcherServlet覆盖了Tomcat提供的用于访问静态资源的servlet（DefaultServlet）；&lt;/p&gt;
&lt;p&gt;　　可以用&amp;lt;mvc:default-servlet-handler/&amp;gt;去打开静态资源访问方式；&lt;/p&gt;
&lt;p&gt;　　　　①.只能访问webapp下的静态资源;&lt;/p&gt;
&lt;p&gt;　　　　②.和tomcat耦合（和服务器耦合）；&lt;/p&gt;
&lt;p&gt;　　2.springMVC提供静态资源访问:&lt;/p&gt;
&lt;p&gt;　　&amp;lt;mvc:resources mapping=&quot;页面静态资源的映射&quot;  location=&quot;静态资源的目录路径&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;五、直接跳转页面&lt;/p&gt;
&lt;p&gt;　　&amp;lt;mvc:view-controller path=&quot;/showRegister&quot; view-name=&quot;register&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;　　等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@RequestMapping(&quot;/showRegister&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String showRegister(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;register&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 六、常用注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@Controller       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个类映射为Controller层&lt;/span&gt;
@RestController   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个类映射为Controller层(方法返回的都是数据模型)&lt;/span&gt;
@RequestMapping   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个方法映射到URL上&lt;/span&gt;
      @GetMapping   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个方法映射到URL上(只能为Get请求)&lt;/span&gt;
      @PostMapping  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个方法映射到URL上(只能为Post请求)&lt;/span&gt;
@RequestParam     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求参数封装到方法参数上&lt;/span&gt;
@RequestHeader    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求头部封装到方法参数上&lt;/span&gt;
@CookieValue      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Cookie封装到方法参数上&lt;/span&gt;
@PathVariable     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将URL中的值封装到方法参数上&lt;/span&gt;
@RequestBody      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求体(POST请求)中的值封装到方法参数上&lt;/span&gt;
@ModelAttrubite   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求参数封装为对象(在请求作用域中,参数和方法级别)&lt;/span&gt;
@SessionAttributes&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求参数封装为对象(在Session作用域中,类级别)&lt;/span&gt;
@Valid            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台校验&lt;/span&gt;
@InitBinder       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(Spring2.5及之前版本会使用)&lt;/span&gt;
@ResponseBody     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将方法返回值写入到ResponseBody中&lt;/span&gt;
@ExceptionHandler &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同一异常处理  &lt;/span&gt;
@ControllerAdvice &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Controller的通知&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;七、Controller层方法的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.方法的返回值
    ModelAndView       模型和视图
    String             视图
        字符串        &lt;/span&gt;--&amp;gt;&lt;span&gt;视图名
        forward:url  &lt;/span&gt;--&amp;gt;&lt;span&gt;转发
        redirect:url &lt;/span&gt;--&amp;gt;&lt;span&gt;重定向
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;               视图(用于请求url为视图名称)
    Object             模型

&lt;/span&gt;2&lt;span&gt;.URL的写法
    @RequestMapping()
        可以添加在类上&lt;/span&gt;--&amp;gt;&lt;span&gt;表示包的概念,访问这个类下的所有的方法都需要添加一个前缀
    &lt;/span&gt;1.直接写URL  如@RequestMapping(&quot;/m1&quot;&lt;span&gt;)
    &lt;/span&gt;2&lt;span&gt;.ant风格
        &lt;/span&gt;*&lt;span&gt;        单层路径
        &lt;/span&gt;**&lt;span&gt;       多层路径
        &lt;/span&gt;?&lt;span&gt;        单个字符
    &lt;/span&gt;3&lt;span&gt;.rest风格
        {name}
        {name:正则表达式}    
        
   @RequestMapping(path&lt;/span&gt;={&quot;/url1&quot;,&quot;/url2&quot;&lt;span&gt;}) 
   
   @RequestMapping(path&lt;/span&gt;=&quot;/url&quot;,method=RequestMethod.POST) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;method指定请求方式&lt;/span&gt;
&lt;span&gt;   
  @RequestMapping(path&lt;/span&gt;=&quot;/url&quot;,params={&quot;name&quot;})  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示该请求必须带一个name的参数 &lt;/span&gt;
&lt;span&gt;  
  @RequestMapping(path&lt;/span&gt;=&quot;/url&quot;,headers={&quot;User-Agent&quot;})  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示该请求必须带一个头部信息User-Agent(浏览器信息)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 八、Controller层方法参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
* 1&lt;span&gt;.JAVA EE主键
        HttpServletRequest&lt;/span&gt;/&lt;span&gt;HttpServletResponse
        HttpSession

&lt;/span&gt;2&lt;span&gt;. IO流
        InputStream
        OutputStream
        Reader
        Writer
            
&lt;/span&gt;3&lt;span&gt;.  Spring组件
    SessionStatus
    WebRequest
    NativeWebRequest

&lt;/span&gt;*4&lt;span&gt;.自定义类型   如User   (请求参数中的key需要和对象中的setter方法一致)

&lt;/span&gt;*5.获取错误信息   Errors/&lt;span&gt;BindingResult

&lt;/span&gt;*6&lt;span&gt;.用于传递数据   Model  Map  ModelMap

&lt;/span&gt;*7&lt;span&gt;.基本类型和字符串类型
            默认来源请求参数 (@RequestParam)
            如果想要参数来源于请求头部   可以使用@RequestHeader
            如果想要参数来源于cookie     可以使用@CookieValue
            如果想要参数来源于URL        可以使用注解@PathVariable
            如果想要参数来源于请求体      可以使用注解@RequestBody&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;九、数据转换&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方案一:spring2.5及之前版本使用
    &lt;/span&gt;1&lt;span&gt;.需要在Controller添加一个方法，方法采用@InitBinder
    &lt;/span&gt;2&lt;span&gt;.这个方法需要一个参数DataBinder
    &lt;/span&gt;3.DataBinder.registerCustomEditor(Class&amp;lt;?&amp;gt; clazz,PropertyEditor propEditor&amp;gt;&lt;span&gt;)
    
方案二:(只能做字符串到其他类型的转换)
        Formatter
        &lt;/span&gt;1&lt;span&gt;.实现接口Formtter
        &lt;/span&gt;2&lt;span&gt;.注册到IOC容器中
&lt;/span&gt;-&lt;span&gt; 管理系统中formatter
   &lt;/span&gt;&amp;lt;!--用来管理自定义的formatter和converter--&amp;gt;
&amp;lt;bean id=&quot;conversionService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;formatters&quot;&amp;gt;
            &amp;lt;set&amp;gt;
                &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;org.itany.formatter.String2DateFormatter&quot;&amp;gt;
                    &amp;lt;constructor-arg value=&quot;yyyy-mm-dd&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
 &amp;lt;/bean&amp;gt;
-&lt;span&gt; 将该coversion交个springMVC使用
&lt;/span&gt;&amp;lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&amp;gt;&lt;span&gt;
        

方法三:(能做任意类型到其他类型的转换)
        Converter
        &lt;/span&gt;1&lt;span&gt;.实现接口Converter
        &lt;/span&gt;2.注册到IOC容器中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十、统一异常处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.编写一个类
        编写方法
        @ExceptionHandler(Exception.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String exception(Exception ex){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;500&quot;&lt;span&gt;;
        }
 &lt;/span&gt;2.这个类上添加一个@ControllerAdvice
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十一、方法返回json以及xml数据格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1.方法的返回值为Object,方法需要注解@ResponseBody
2.需要添加一个方法返回值的转换器(使用的是jackson)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven &lt;/span&gt;&lt;span&gt;conversion-service&lt;/span&gt;&lt;span&gt;=&quot;conversionService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;消息转换器 告诉springMVC我们方法返回值返回什么格式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:message-converters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:message-converters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:annotation-driven&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
3.提供json处理包
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-databind&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;



使用gson
    1.将消息转换器换为
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.http.converter.json.GsonHttpMessageConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    2.将json处理的依赖修改为
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.google.code.gson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;gson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

使用fastjson
    1.将消息转换器换为
 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    2.将json处理的依赖包
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;fastjson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;






如果想要返回为xml
1.方法返回Object，需要注解@ResponseBody
 还需要在@RequestMapping(produces=&quot;application/xml&quot;)

2.需要添加消息转换器(这个转换需要在json转换器的前面)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.http.converter.xml.Jaxb2RootElementHttpMessageConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;

3.需要添加一个依赖
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-oxm&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;



注意:如果配置了json转换器,这个时候以前返回为String的方法，返回的时候会默认添加一对引号。
    可以在消息转换器中添加一个字符串的转换器(这个转换需要在json转换器的前面)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十二、自定义消息转换器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1.继承抽象类AbstractHttpMessageConverter
    2.将消息转换器配置到SpringMVC中
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:message-converters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;自定义的消息转换器&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:message-converters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:annotation-driver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十三、拦截器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1.实现接口  HandlerInterceptor/WebRequestInterceptor
    preHandler         在handler方法之前调用
            返回值表示true，不拦截
                     false, 拦截(不进入handler方法)  
    postHandler        在handler方法之后调用
    afterCompleition   在handler方法完成之后
    
2.配置
    在mvc的配置文件中
    1.表示拦截系统中所有的请求
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;拦截器&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    2.只需要拦截某些URL
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/url/**&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.itany.interceptors.ControllerInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    3.排除一些url
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/**&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:exclude-mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/url/**&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.itany.interceptors.ControllerInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十四、文件上传下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1.jsp需要二进制提交
        enctype=&quot;multipart/form-data&quot;
2.Controller方法需要参数接收,参数的类型CommonsMultipartFile
3.需要文件上传的解析器
&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;文件上传&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;multipartResolver&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maxUploadSize&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;10000000000&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultEncoding&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
4.需要添加依赖commons-fileupload
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-fileupload&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;commons-fileupload&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;



文件下载
    PS:只要mvc最后url是带后缀的，SpringMVC会将其截取掉。
  //告诉浏览器拿到资源不要打开，下载
        response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+fileName);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 30 Aug 2018 06:55:00 +0000</pubDate>
<dc:creator>MrDong先生</dc:creator>
<og:description>一、优点： 1.SpringMVC简化web程序开发; 2.SpringMVC效率很好（单例模式）； 3.SpringMVC提供了大量扩展点，方便程序员自定义功能； ①.DispatcherServl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrXiaoAndDong/p/SpringMVC.html</dc:identifier>
</item>
<item>
<title>[四] java虚拟机JVM编译器编译代码简介 字节码指令实例 代码到底编译成了什么形式 - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9560161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9560161.html</guid>
<description>
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;前言简介&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;前文已经对虚拟机进行过了简单的介绍,并且也对class文件结构,以及字节码指令进行了详尽的说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要了解JVM的运行机制,以及如何优化你的代码,你还需要了解一下,java编译器到底是如何编译你的代码的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文不是从最底层的编译原理讲解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文是针对java代码,去查看归纳总结编译器的结果行为,从而直观的感受到字节码指令集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说本文的内容,主要针对的是使用javap 查看字节码文件中方法的code属性中的字节码内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让你从java代码  class文件格式,以及字节码指令集 进行一个直观的演示&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;提醒:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你对字节码指令不了解,而且,没有看过前面的文章,本文可能会轻度不适.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文示例只是为了展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;您应该经常查看你自己的代码的class文件去发现其中的规律&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一条普通的指令格式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td readability=&quot;5&quot;&gt;&lt;span&gt;&amp;lt;index&amp;gt; &amp;lt;opcode&amp;gt; [ &amp;lt;operand1&amp;gt; [ &amp;lt;operand2&amp;gt;... ]] [&amp;lt;comment&amp;gt;]&lt;/span&gt;&lt;p&gt;&lt;span&gt;index 表示偏移量 行号  等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;opcode 表示操作码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;operandX表示操作数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;comment 为注释&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;比如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;行号 0 , 操作码 getstatic ,操作数 #24  注释为 Field java/lang/System..................&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145036106-799934115.png&quot;&gt;&lt;img title=&quot;image_5b879224_252b_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145036367-1872685842.png&quot; alt=&quot;image_5b879224_252b_thumb[1]&quot; width=&quot;949&quot; height=&quot;178&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;其中 index  行号/偏移量  可以作为控制跳转指令的跳转目标  比如 goto  8 表示跳转到索引为8的指令上&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;还有一点需要注意的是,javap查看到的内容,你可以认为是class文件表述的信息,但是绝不能理解为就是class文件中的内容&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如,class文件中没有操作码的助记符,比如,getstatic ,都是指令的二进制值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再比如刚才说到的,跳转到指定行号,对于控制转移指令,实际的操作数是在当前指令的操作码集合中的地址偏移量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并不是那个8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只不过javap工具按照更适合我们阅读的方式进行了翻译&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;加载存储与算数指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; m = 32767&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = 32768&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; add = i+&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sub = i-&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mul = j*&lt;span&gt;k;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; div = j/&lt;span&gt;k;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rem = k%&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; neg = ~&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; inc = i++&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145036637-872952305.png&quot;&gt;&lt;img title=&quot;image_5b879224_2d18_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145036866-735945401.png&quot; alt=&quot;image_5b879224_2d18_thumb[1]&quot; width=&quot;520&quot; height=&quot;776&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;


&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;-1 ~ 5 使用const加载到操作数栈 其中-1 使用iconst_m1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-128~127 使用bipush -32768~32767使用sipush&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其余常量池ldc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;store从操作数栈保存到局部变量表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;load加载局部变量到操作数栈&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td readability=&quot;13&quot;&gt;&lt;span&gt;0. 常量-1 加载到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 操作数栈保存到1号局部变量表 也就是 i = -1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 常量 3 加载到操作数栈      &lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 操作数栈保存到2号局部变量表 也就是j = 3;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. 常量 5 加载到操作数栈  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;5. 操作数栈保存到3号局部变量表 也就是k =5;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6. 常量 127 加载到操作数栈&lt;/span&gt;&lt;p&gt;&lt;span&gt;8. 操作数栈保存到4号局部变量表 也就是l = 127;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.常量 32767 加载到操作数栈&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;13.操作数栈保存到5号局部变量表 也就是m = 32767;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15.加载#17号常量池数据到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17. 操作数栈保存到6号局部变量表 也就是n = 32768;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145037069-850855836.png&quot;&gt;&lt;img title=&quot;image_5b879224_4b5a_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145037269-207966072.png&quot; alt=&quot;image_5b879224_4b5a_thumb[1]&quot; width=&quot;450&quot; height=&quot;49&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;p&gt;&lt;span&gt;19. 加载1号局部变量到操作数栈 对应 i&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20. 加载2号局部变量到操作数栈  对应 j&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21. 执行iadd指令计算并将结果压入栈顶   对应 i+j;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22. 保存栈顶元素到7号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24. 加载1号局部变量到操作数栈 对应 i&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25. 加载2号局部变量到操作数栈  对应 j&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26.执行isub指令计算并将结果压入栈顶   对应i-j;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27. 保存栈顶元素减法结果到8号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29,30 加载 2号和3号局部变量到操作数栈 也就是j   k&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31  执行imul指令并将结果压栈 j*k&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32 保存栈顶元素乘法结果到9号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;34.35 加载 2号和3号局部变量到操作数栈 也就是j   k&lt;/span&gt;&lt;br/&gt;&lt;span&gt;36 执行idiv 结果压入栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;37保存idiv结果到10号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;39.40 加载3号 和 2号 也就是k   j&lt;/span&gt;&lt;br/&gt;&lt;span&gt;41 执行求余irem 结果压入栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;42 栈顶元素结果保存到11号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;44加载2号局部变量  对应 j 到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;45 加载常量-1到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;46 执行异或运算结果压入栈顶  (~x = -1 ^ x;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;47栈顶结果保存到12号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;49 加载1号局部变量 对应 i&lt;/span&gt;&lt;br/&gt;&lt;span&gt;50 执行增量 1 计算 结果压入栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;53 栈顶结果保存到13号变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;55 void方法 return返回&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;类型转换&lt;/span&gt;指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; bNum = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; cNum = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; byteNum = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; sNum = 32767&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iNum = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lNum = 65536&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; fNum = 2.5f&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; dNum = 6.8&lt;span&gt;;
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c1 = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)byteNum;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c2 = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)sNum;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c3 = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)iNum;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c4 = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)lNum;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c5 = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)fNum;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c6 = (&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)dNum;

&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b1 = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)cNum;
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b2 = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)sNum;
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b3 = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)iNum;
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b4 = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)lNum;
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b5 = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)fNum;
&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; b6 = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)dNum;

&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; s1 = (&lt;span&gt;short&lt;/span&gt;&lt;span&gt;)cNum;
&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; s2 = (&lt;span&gt;short&lt;/span&gt;&lt;span&gt;)byteNum;
&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; s3 = (&lt;span&gt;short&lt;/span&gt;&lt;span&gt;)iNum;
&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; s4 = (&lt;span&gt;short&lt;/span&gt;&lt;span&gt;)lNum;
&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; s5 = (&lt;span&gt;short&lt;/span&gt;&lt;span&gt;)fNum;
&lt;/span&gt;&lt;span&gt;short&lt;/span&gt; s6 = (&lt;span&gt;short&lt;/span&gt;&lt;span&gt;)dNum;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i1 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)cNum;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i2 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)byteNum;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i3 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)sNum;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i4 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)lNum;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i5 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)fNum;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i6 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)dNum;

&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l1 = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)byteNum;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l2 = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)cNum;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l3 = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)sNum;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l4 = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)iNum;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l5 = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)fNum;
&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l6 = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)dNum;

&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f1 = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)byteNum;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f2 = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)cNum;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f3 = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)sNum;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f4 = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)iNum;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f5 = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)lNum;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f6 = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)dNum;

&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d1 = (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)byteNum;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d2 = (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cNum;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d3 = (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)sNum;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d4 = (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)iNum;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d5 = (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)lNum;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d6 = (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)fNum;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;javap解析后的内容太长,接下来分段解析&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;数据的加载与存储&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145037432-850911610.png&quot;&gt;&lt;img title=&quot;image_5b879224_1328_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145037632-258014470.png&quot; alt=&quot;image_5b879224_1328_thumb[1]&quot; width=&quot;941&quot; height=&quot;399&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;从数据的存储可以看得出来 boolean内部使用的是数值1  也就是1 表示true&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;数据类型转换为char类型&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;char byte short int  内部形式均为int  所以转换为char是,使用的全都是 i2c&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;long  float double 先转换为int(l2i f2i d2i) 然后在统一使用 i2c 转换为char&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145037951-478257592.png&quot;&gt;&lt;img title=&quot;image_5b879225_45f1_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145038279-1505474982.png&quot; alt=&quot;image_5b879225_45f1_thumb[1]&quot; width=&quot;762&quot; height=&quot;425&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;


&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据类型转换为byte 类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;char byte short int  内部形式均为int  所以转换为byte时,使用的全都是 i2b&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;long  float double 先转换为int(l2i f2i d2i) 然后在统一使用 i2b 转换为  byte&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145038460-2007374625.png&quot;&gt;&lt;img title=&quot;image_5b879225_7927_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145038718-2100158876.png&quot; alt=&quot;image_5b879225_7927_thumb[1]&quot; width=&quot;719&quot; height=&quot;440&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;数据类型转换为short 类型&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;还是同样的道理,&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;char byte short int  内部形式均为int  所以转换为short 使用的是   i2s&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;long  float double 先转换为int(l2i f2i d2i) 然后在统一使用 i2s 转换为  short&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145038878-646990273.png&quot;&gt;&lt;img title=&quot;image_5b879225_7e40_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145039077-432601287.png&quot; alt=&quot;image_5b879225_7e40_thumb[1]&quot; width=&quot;742&quot; height=&quot;419&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据类型转换为int 类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;char byte short内部都是int类型.将他们转换为int时,不需要进行转换&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;如下图所示,一个load 对应一个store&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;long  float double    (l2i f2i d2i)   转换为int&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145039238-368015617.png&quot;&gt;&lt;img title=&quot;image_5b879225_4c4a_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145039475-37576546.png&quot; alt=&quot;image_5b879225_4c4a_thumb[1]&quot; width=&quot;670&quot; height=&quot;331&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据类型转换为long 类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;char byte short  int   内部都是int类型.将他们转换为long 时,使用  i2l&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;float double   转换为long   f2l d2l&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145039994-1178397393.png&quot;&gt;&lt;img title=&quot;image_5b879225_209d_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145040346-549912096.png&quot; alt=&quot;image_5b879225_209d_thumb[1]&quot; width=&quot;683&quot; height=&quot;407&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;


&lt;div readability=&quot;8&quot;&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据类型转换为float 类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;char byte short  int   内部都是int类型.将他们转换为float 时,使用  i2f&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;long double   转换为float     l2f  d2f&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145040528-1128021373.png&quot;&gt;&lt;img title=&quot;image_5b879225_2e9e_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145040760-1526789575.png&quot; alt=&quot;image_5b879225_2e9e_thumb[1]&quot; width=&quot;676&quot; height=&quot;403&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;数据类型转换为double 类型&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;char byte short  int   内部都是int类型.将他们转换为double 时,使用  i2d&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;float   转换为double     l2d  f2d&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145040960-1100253696.png&quot;&gt;&lt;img title=&quot;image_5b879225_4660_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145041185-1518509909.png&quot; alt=&quot;image_5b879225_4660_thumb[1]&quot; width=&quot;697&quot; height=&quot;406&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;

&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;类相关指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Super{
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Sub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Super{
}

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Super();
Super s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Super();
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Double(1.5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();
Sub sub &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Sub();
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145041383-484747532.png&quot;&gt;&lt;img title=&quot;image_5b879225_51b9_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145041575-1705541780.png&quot; alt=&quot;image_5b879225_51b9_thumb[1]&quot; width=&quot;790&quot; height=&quot;412&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;17&quot;&gt;&lt;td readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;span&gt;new Object();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;new Super();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有赋值给局部变量 仅仅是创建对象  调用new之后,堆中对象的引用保存在栈顶&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后调用构造方法invokespecial&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Super s = new Super();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同上面的,需要调用new &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为还需要保存到局部变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以new之后 先copy一个,也就是dup&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后调用构造方法 invokespecial&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后从操作数栈保存到局部变量 store&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Super super1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Super();
Sub sub &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sub();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类引用可以指向子类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类引用不能指向父类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是对于指向子类的父类引用 可以通过类型转换为子类&lt;/span&gt;&lt;span&gt;
Super subToSuper &lt;/span&gt;=&lt;span&gt; sub;
Sub superToSub &lt;/span&gt;= (Sub) subToSuper;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145041801-1872211383.png&quot;&gt;&lt;img title=&quot;image_5b879225_2fff_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145042001-1554793172.png&quot; alt=&quot;image_5b879225_2fff_thumb[1]&quot; width=&quot;676&quot; height=&quot;333&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;0 创建Spper&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3 复制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4 调用构造方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7 保存到1号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8 创建Sub&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11 复制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12调用构造方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15 保存到2号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16 2号加载到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17保存到3号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18加载3号局部变量到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19 checkcast 进行校验确认是否可以转换为指定类型 否则报错抛 classCastException&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22 再次保存到局部变量&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;控制转移指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; intWhile() {
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; 100&lt;span&gt;) {
i&lt;/span&gt;++&lt;span&gt;;
}
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; intDoWhile() {
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
i&lt;/span&gt;++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; 100&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; intFor() {
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i =0;i&amp;lt;100;i++&lt;span&gt;) {
j&lt;/span&gt;++&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145042211-1978066641.png&quot;&gt;&lt;img title=&quot;image_5b879225_6bae_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145042455-1482849625.png&quot; alt=&quot;image_5b879225_6bae_thumb[1]&quot; width=&quot;427&quot; height=&quot;1543&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;intWhile()方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0. 加载常量0 到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.保存操作数栈元素到1号局部变量 i= 0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.直接跳转到第8行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8.1号局部变量加载到操作数栈 也就是i 作为第一个元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9.加载常量100到操作数栈 也就是100作为第二个元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11.比较大小,如果前者小于后者 也就是如果 i &amp;lt;100 满足 跳转到第5行  否则顺序执行到14 return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.给1号局部变量以增量1 增加&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后 8--&amp;gt;9--&amp;gt;11--&amp;gt;5--&amp;gt;8--&amp;gt;9--&amp;gt;11......往复循环 直到条件不满足,从11 跳转到14 结束&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt;intDoWhile()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0.加载常量0到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.保存常量0 到1号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.给1号局部变量以增量1 进行自增&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.1号局部变量加载到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6.常量100加载到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8,比较大小 如果前者小于后者也就是 1号局部变量 i&amp;lt;100 跳转到第2行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后进行往复循环,直到条件不满足,然后顺序到return&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td readability=&quot;10&quot;&gt;&lt;span&gt;intFor()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0.  加载常量0 到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.  保存栈顶元素到1号局部变量 j=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.  加载常量0到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.  保存栈顶元素到2号局部变量i=0;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.  跳转到13行&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13.  加载2号局部变量到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14.  加载常量100到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16.  比较大小,如果前者 2号局部变量 i &amp;lt;100 跳转到7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7.  1号局部变量以增量1  自增 j++&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10.   2号局部变量以增量1 自增 i++&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13.  2号局部变量加载到操作数栈&lt;/span&gt;&lt;p&gt;&lt;span&gt;14.  加载常量100到操作数栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;16.  比较大小,如果前者 2号局部变量 i &amp;lt;100 跳转到7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;往复循环 如果条件不满足 从16 顺序到19 结束方法 return&lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fun() {
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;2&lt;span&gt;) {
i&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
i&lt;/span&gt;--&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145042671-146264256.png&quot;&gt;&lt;img title=&quot;image_5b879225_6ec9_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145042881-740460996.png&quot; alt=&quot;image_5b879225_6ec9_thumb[1]&quot; width=&quot;339&quot; height=&quot;268&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;&lt;span&gt;0, 加载常量0 到栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1,保存栈顶元素 (0) 到1号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 加载1号局部变量到栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 加载常量2 到栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4,比较&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果大于后者等于跳转到13 然后1号局部变量 自增1 然后下一步顺序到16 return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;否则就是顺序执行到7 1号局部变量 增量为-1  自增运算 然后到10 ,10为跳转到16 return&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;



&lt;h3&gt;方法调用相关指令&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invoker() {
method(&lt;/span&gt;2&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; method(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;gt;5&lt;span&gt;) {
System.out.println(i);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145043037-1810794201.png&quot;&gt;&lt;img title=&quot;image_5b879225_55f1_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145043227-1481442111.png&quot; alt=&quot;image_5b879225_55f1_thumb[1]&quot; width=&quot;863&quot; height=&quot;504&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;&lt;span&gt;invoker()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0,加载0号 局变量到栈   (上面基本都是第一个数据被保存到1号局部变量,0 号其实是被this 占用了)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1,加载常量2 到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.调用实例方法(I)V&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5 return&lt;/span&gt;&lt;p&gt;&lt;span&gt;method(int)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0. 加载1号局部变量到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 加载常量5 到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2比较如果小于等于 跳转到12行 直接返回&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果大于&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那么顺序执行到5行       out 是类型为PrintStream的   System中的静态变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8 加载1号局部变量到操作数栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9 调用实例方法 println  是  PrintStream的实例方法 使用invokevirtual&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;switch 相关&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 6&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (i) {
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
j &lt;/span&gt;= j + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
j &lt;/span&gt;= j + 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 5&lt;span&gt;:
j &lt;/span&gt;= j + 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
j &lt;/span&gt;= j + 4&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145043419-452857369.png&quot;&gt;&lt;img title=&quot;image_5b879225_5641_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145043639-1674895994.png&quot; alt=&quot;image_5b879225_5641_thumb[1]&quot; width=&quot;457&quot; height=&quot;471&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td readability=&quot;5&quot;&gt;&lt;span&gt;0,1,2,4 分别将 5 和 6 加载并存储到1号和2号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5.加载1号局部变量到栈  对应 switch (i) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后根据tableswitch 表 进行跳转&lt;/span&gt;&lt;br/&gt;&lt;span&gt;虽然我们只有1,3,5  但是设置了1到5 ,对于2 和 4 直接跳转到default&lt;/span&gt;&lt;p&gt;&lt;span&gt;40: 2号局部变量 +1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;顺序到43&lt;/span&gt;&lt;br/&gt;&lt;span&gt;43: 跳转到61 return&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;46: 2号局部变量 +2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;顺序到49&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;49: 跳转到61 return&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;&lt;span&gt;52: 2号局部变量 +3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;顺序到55&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;55: 跳转到61 return&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;br/&gt;&lt;span&gt;58 2号局部变量 +4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;顺序到61 return&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; j = 6&lt;span&gt;;
String string &lt;/span&gt;= &quot;hehe&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (string) {
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;A&quot;&lt;span&gt;:
j &lt;/span&gt;= j + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;hehe&quot;&lt;span&gt;:
j &lt;/span&gt;= j + 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;C&quot;&lt;span&gt;:
j &lt;/span&gt;= j + 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
j &lt;/span&gt;= j + 4&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145043846-1124535233.png&quot;&gt;&lt;img title=&quot;image_5b879226_5e68_thumb[4]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145044040-589239347.png&quot; alt=&quot;image_5b879226_5e68_thumb[4]&quot; width=&quot;910&quot; height=&quot;722&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td readability=&quot;7&quot;&gt;&lt;span&gt;0  加载常量6到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1 保存到 1 号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.加载常量池 #36 到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145044208-1144437195.png&quot;&gt;&lt;img title=&quot;image_5b879226_6b5c_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145044380-402429729.png&quot; alt=&quot;image_5b879226_6b5c_thumb[1]&quot; width=&quot;446&quot; height=&quot;45&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5 保存到2 号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6 加载2号局部变量 到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7 复制栈顶元素&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8 复制的元素保存到3号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9 调用String实例化方法hashCode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12, lookupswitch表中,不在类似tableswitch 了,那个是连续的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lookupswitch  是不连续的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们总共有三个case一个default&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lookupswitch 总共有4项&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;A&quot; 的hashCode  为 65&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;C&quot; 的hashCode为 67&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;hehe&quot; 的hashCode为 3198650  不信的话,自己写个main方法打印下&lt;/span&gt;&lt;p&gt;&lt;span&gt;经过12行 路由之后跳转到指定的序列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;你会发现三个case他们的过程是一样的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;加载3号局部变量 ,然后将常量 A C  hehe 也加载到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后调用equal方法进行比较&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145044753-1212101707.png&quot;&gt;&lt;img title=&quot;image_5b879226_523c_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145045148-1453511594.png&quot; alt=&quot;image_5b879226_523c_thumb[1]&quot; width=&quot;283&quot; height=&quot;288&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;代码千千万,本文只是找一些基本的示例展示字节码与代码的对应关系,想要熟悉这块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;唯有没事多javap看看你代码的class文件,才能通宵领悟,进而更好地优化你的代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如看看下面的一个很典型的例子&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i = 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 8&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = i+&lt;span&gt;j;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l = 3+6;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145045576-8125527.png&quot;&gt;&lt;img title=&quot;image_5b879226_3a97_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180830145046119-1688013460.png&quot; alt=&quot;image_5b879226_3a97_thumb[1]&quot; width=&quot;342&quot; height=&quot;245&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td readability=&quot;6&quot;&gt;&lt;span&gt;前一部分:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0. 常量5 加载到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1,保存到 1号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 常量8 加载到栈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4 保存到2号 局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5,加载1号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6, 加载2号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7 执行iadd 结果会压入栈顶&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8 栈顶元素保存到3号局部变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;至此 完成了前三行代码&lt;/span&gt;&lt;p&gt;&lt;span&gt;后一部分:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9.常量9 加载到栈   (3+6  已经被计算好了)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11,保存到4号局部变量&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 30 Aug 2018 06:51:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>class文件是代码的静态存储形式, 字节码用于执行代码,但是对于一份代码,到底是变成了什么样子的形式呢? 本文以一些常见代码片段为例,展示了编译后的字节码指令形式,以一个直观的形式展示了编译器的行为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9560161.html</dc:identifier>
</item>
<item>
<title>Java多线程1：使用多线程的几种方式以及对比 - 时光漫步z</title>
<link>http://www.cnblogs.com/zivwong/p/9559931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zivwong/p/9559931.html</guid>
<description>&lt;p&gt;Java多线程的使用有三种方法：继承Thread类、实现Runnable接口和使用Callable和Future创建线程，本文将对这三种方法一一进行介绍。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;实现方式很简单，只需要创建一个类去继承Thread类然后重写run方法，在main方法中调用该类实例对象的start方法即可实现多线程并发。代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread extends Thread {
    @Override
    public void run(){
        super.run();
        System.out.println(&quot;执行子线程...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        System.out.println(&quot;主线程...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d7120c5gy1fupsrujeg0j209j01tjr7.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这里的结果不代表线程的执行顺序，线程是并发执行的，如果多运行几次，打印顺序可能会不一样。多线程的运行过程中，CPU是以不确定的方式去执行线程的，故运行结果与代码的执行顺序或者调用顺序无关，运行结果也可能不一样。关于线程执行的随机性本文后面也有代码示例。&lt;/p&gt;
&lt;p&gt;这里还有一个需要注意的点就是main方法中应该调用的是myThread的start方法，而不是run()方法。调用start()方法是告诉CPU此线程已经准备就绪可以执行，进而系统有时间就会来执行其run()方法。而直接调用run()方法，则不是异步执行，而是等同于调用函数般按顺序同步执行，这就失去了多线程的意义了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;这种方式的实现也很简单，就是把继承Thread类改为实现Runnable接口。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;执行子线程...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试用例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {

        Runnable runnable = new MyRunnable();
        Thread thread = new Thread(runnable);
        thread.start();
        System.out.println(&quot;主线程运行结束!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d7120c5gy1fuptodna68j2091020t8j.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果没啥好说的，这里main中可以看到真正创建新线程还是通过Thread创建：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Thread thread = new Thread(runnable);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步Thread类的作用就是把run()方法包装成线程执行体，然后依然通过start去告诉系统这个线程已经准备好了可以安排执行。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上面的两种方式都有这两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无法获取子线程的返回值&lt;/li&gt;
&lt;li&gt;run方法不可以抛出异常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了解决这两个问题，我们就需要用到Callable这个接口了。说到接口，上面的Runnable接口实现类实例是作为Thread类的构造函数的参数传入的，之后通过Thread的start执行run方法中的内容。但是Callable并不是Runnable的子接口，是个全新的接口，它的实例不能直接传入给Thread构造，所以需要另一个接口来转换一下。&lt;/p&gt;
&lt;p&gt;Java5提供了Future接口来代表Callable接口里call()方法的返回值，并为Future接口提供了一个实现类FutureTask，该实现类的继承关系如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d7120c5gy1fuqtfltsa5j20cq06rwei.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该实现类不仅实现了Future接口，还实现了Runnable接口，所以可以直接传给Thread构造函数。&lt;/p&gt;
&lt;p&gt;而关于FutureTask的构造函数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d7120c5gy1fuqto4e5xrj20ma041aa4.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以这里面其实就是要比上一个方法再多一个转换过程，最终一样是通过Thread的start来创建新线程。有了这个思路，代码就很容易理解了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.concurrent.Callable;

public class MyCallable implements Callable {
    int i = 0;
    @Override
    public Object call() throws Exception {
        System.out.println(Thread.currentThread().getName()+&quot;  i的值：&quot;+ i);
        return i++; //call方法可以有返回值
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Test {
    public static void main(String[] args) {
        Callable callable = new MyCallable();
        for (int i = 0; i &amp;lt; 10; i++) {
            FutureTask task = new FutureTask(callable);
            new Thread(task,&quot;子线程&quot;+ i).start();
            try {
                //获取子线程的返回值
                System.out.println(&quot;子线程返回值：&quot;+task.get() + &quot;\n&quot;);
            }  catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果（部分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d7120c5gy1fuqtuwd5dyj205d0be74b.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上面介绍第一种方法的时候，说了线程的执行顺序与start()的执行顺序无关，而是CPU有空隙了就过来执行该线程，所以具有随机性，执行顺序也是随机的。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread extends Thread {
    int i;
    public MyThread(int i){
        super();
        this.i = i;
    }
    @Override
    public void run(){
        System.out.println(i);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
        Thread thread1 = new MyThread(1);
        Thread thread2 = new MyThread(2);
        Thread thread3 = new MyThread(3);
        Thread thread4 = new MyThread(4);
        Thread thread5 = new MyThread(5);
        Thread thread6 = new MyThread(6);
        Thread thread7 = new MyThread(7);
        Thread thread8 = new MyThread(8);
        Thread thread9 = new MyThread(9);
        Thread thread10 = new MyThread(10);

        thread1.start();
        thread2.start();
        thread3.start();
        thread4.start();
        thread5.start();
        thread6.start();
        thread7.start();
        thread8.start();
        thread9.start();
        thread10.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果体现了这一点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8d7120c5gy1fuqu2jjllij202u069a9v.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;第一种和后面两种的对比&quot;&gt;第一种和后面两种的对比：&lt;/h2&gt;
&lt;p&gt;1、通过代码可以看出，第一种方法是最简洁方便的，直接就可以start，不需要任何转换&lt;br/&gt;2、但是第一种有一个很不好的地方就是继承了Thread类后由于java的单继承机制，就不可以继承其他的类了，而如果实现的是接口，就可以实现多个接口，使开发更灵活。&lt;/p&gt;
&lt;h2 id=&quot;第二种和第三种方式对比&quot;&gt;第二种和第三种方式对比：&lt;/h2&gt;
&lt;p&gt;1、同样的，第二种方法相对第三种方式来说代码更简洁，使用更方便，少了一次转换&lt;br/&gt;2、第三种方法有两个优点：有返回值、可以抛出异常&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;实际开发中可能有更复杂的代码实现，需要继承其他的类，所以平时更推荐通过实现接口来实现多线程，也就是通过第二或第三种方式来实现，这样能保持代码灵活和解耦。&lt;br/&gt;而选择第二还是第三种方式，则要根据run()方法是不是需要返回值或者捕获异常来决定，如果不需要，可以选择用第二种方式实现，代码更简洁。&lt;/p&gt;
&lt;blockquote readability=&quot;4.7391304347826&quot;&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;http://www.cnblogs.com/zivwong&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zivwong&lt;/a&gt;&lt;br/&gt;CSDN地址：&lt;a href=&quot;https://blog.csdn.net/wannafly_z&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wannafly_z&lt;/a&gt;&lt;br/&gt;作者个人网站：&lt;a href=&quot;http://www.comingnext.cn/&quot;&gt;时光漫步z&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎转载，请在明显位置给出出处及链接&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 30 Aug 2018 06:28:00 +0000</pubDate>
<dc:creator>时光漫步z</dc:creator>
<og:description>前言 Java多线程的使用有三种方法：继承Thread类、实现Runnable接口和使用Callable和Future创建线程，本文将对这三种方法一一进行介绍。 1、继承Thread类 实现方式很简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zivwong/p/9559931.html</dc:identifier>
</item>
</channel>
</rss>