<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vmware 上ubuntu server连接外网 - chengxiansheng</title>
<link>http://www.cnblogs.com/chengxiansheng/p/8076375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxiansheng/p/8076375.html</guid>
<description>&lt;p&gt;  　　最近在自己的电脑上搞了个ubuntu server，自己做点小demo，当需要连接网络时问题来了，没法连接网络，网上有一些资料都是一笔带过，并不符合自己的情况，现在将我解决的过程记录下：&lt;/p&gt;
&lt;p&gt;        首先，在自己的windows电脑上cmd下输入ipconfig&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220223218084-1736747161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    注意这个ip，要在linux网络配置中ip网段要一样，然后在vmware 中打开虚拟网络编辑器界面，在“”编辑“”菜单下&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220223453943-1979221711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我的虚拟机设置中网络适配器选的是NAT模式如下图，这个信息是在vmware左边栏中右键安装的虚拟机，选择设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220223756475-283360429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以选中虚拟网络编辑器中的VMnet8，并修改子网ip信息，满足ip的ip段和windows相同，我的windows是192.168.199.115，所以这里设置为了192.168.199.0，只有这里设置里，下一步的DCH IP区段和网关ip才能设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220224205084-1673071166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后进行NAT设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220233035334-1853431681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里设置的网关ip和我windows电脑的网关ip相同，点击确定之后回到虚拟网络编辑器界面，再进行DCH设置，设置起始ip和结束ip，这个范围设置网段也要和windows的ip是一个网段&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220225341521-156407833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击确认，再回到虚拟网络编辑器界面点击确认，重启虚拟机，ping www.baidu.com 已经可以ping通，说明外网已经开通&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220225858959-969985638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还不可以的检查下 /etc/network/ interfaces 是否正确设置，下图圆圈是网卡名称，方框里是dhcp是自动获取ip，static是配置静态ip，就要设置address等信息，指定ip地址&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220230634084-425748149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有dns设置，在/etc/resolv.conf 这里我设置的是网关地址，也可以设置成114.114.114.114等，dns服务器地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220231009115-1295433116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ping windows ip也是可以ping通的，&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 15:32:00 +0000</pubDate>
<dc:creator>chengxiansheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxiansheng/p/8076375.html</dc:identifier>
</item>
<item>
<title>vue2的keep-alive的总结 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/8076245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/8076245.html</guid>
<description>&lt;p&gt;vue2的keep-alive的总结&lt;/p&gt;
&lt;p&gt;keep-alive 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。结合vue-router中使用，可以缓存某个view&lt;br/&gt;的整个内容。&lt;br/&gt;基本使用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;keep-alive&amp;gt;
  &amp;lt;component&amp;gt;
    &amp;lt;!-- 该组件将被缓存！ --&amp;gt;
  &amp;lt;/component&amp;gt;
&amp;lt;/keep-alive&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般有这样的需求，当我们第一次进入列表页需要请求一下数据，当我从列表页进入详情页，详情页不缓存也需要请求下数据，然后返回列表页&lt;br/&gt;有两个情况：&lt;br/&gt;1. 直接点击浏览器的后退返回按钮。&lt;br/&gt;2. 点击导航栏中的 /list的链接返回。&lt;/p&gt;
&lt;p&gt;那么针对第一种情况下，我们直接通过后退按钮时，返回到列表页(/list) 是不需要请求数据。&lt;br/&gt;针对第二种情况下，我们通过链接返回到列表页是需要请求数据。&lt;/p&gt;
&lt;p&gt;所以这边有三种情况：&lt;br/&gt;1. 默认进来列表页需要请求数据。&lt;br/&gt;2. 进入详情页后，通过浏览器默认后退按钮返回，是不需要ajax的请求的。&lt;br/&gt;3. 进入详情页后，通过点击链接返回到列表页后，也是需要发ajax请求的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;配置如下：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1. 入口文件 app.vue 的配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 缓存所有的页面 --&amp;gt;
&amp;lt;keep-alive&amp;gt;
  &amp;lt;router-view v-&lt;span&gt;if&lt;/span&gt;=&quot;$route.meta.keep_alive&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/keep-alive&amp;gt;
&amp;lt;router-view v-&lt;span&gt;if&lt;/span&gt;=&quot;!$route.meta.keep_alive&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 在router中设置meta属性，设置 keepAlive: true 表示需要使用缓存，false的话表示不需要使用缓存。且添加滚动行为 scrollBehavior&lt;br/&gt;router/index.js 的配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;
import Router from &lt;/span&gt;'vue-router'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import HelloWorld from '@/views/HelloWorld';&lt;/span&gt;
&lt;span&gt;Vue.use(Router);
const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  mode: &lt;/span&gt;'history', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问路径不带井号  需要使用 history模式，才能使用 scrollBehavior&lt;/span&gt;
  base: '/page/app',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置单页应用的基路径&lt;/span&gt;
&lt;span&gt;  routes: [
    {
      path: &lt;/span&gt;'/'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve),  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/list'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存  false表示不需要被缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/detail'&lt;span&gt;,
      name: &lt;/span&gt;'detail'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/detail'], resolve) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;    }
  ],
  scrollBehavior (to, from, savedPosition) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存到 meta 中，备用&lt;/span&gt;
    to.meta.savedPosition =&lt;span&gt; savedPosition;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (savedPosition) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { x: 0, y: 0&lt;span&gt; };
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
  }
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. list.vue 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;h1&amp;gt;vue&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;{{msg}}&amp;lt;/h2&amp;gt;
    &amp;lt;router-link to=&quot;/detail&quot;&amp;gt;跳转到detail页&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'helloworld'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to Your Vue.js App'&lt;span&gt;
    };
  },
  methods: {
    ajaxRequest() {
      const obj &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;'aa': 1&lt;span&gt;
      };
      Promise.all([&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.dispatch('testUrl', obj)]).then((res) =&amp;gt;&lt;span&gt; {
        console.log(res);
      });
    }
  },
  beforeRouteEnter(to, from, next) {
    next(vm &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       如果 to.meta.savedPosition === undefined 说明是刷新页面或可以叫第一次进入页面 需要刷新数据
       如果savedPosition === null, 那么说明是点击了导航链接;
       此时需要刷新数据，获取新的列表内容。
       否则的话 什么都不做，直接使用 keep-alive中的缓存
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (to.meta.savedPosition ===&lt;span&gt; undefined) {
        vm.ajaxRequest();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (to.meta.savedPosition === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        vm.ajaxRequest();
      }
    })
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. detail.vue 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;list&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/list&quot;&amp;gt;返回列表页&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'list'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to Your Vue.js App'&lt;span&gt;
    };
  },
  created() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ajaxRequest();
  },
  methods: {
    ajaxRequest() {
      const obj &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;'aa': 1&lt;span&gt;
      };
      Promise.all([&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.dispatch('withdary', obj)]).then((res) =&amp;gt;&lt;span&gt; {
        console.log(res);
      });
    }
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：使用router.meta 扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假设现在有3个页面，需求如下：&lt;br/&gt;1. 默认有A页面，A页面进来需要一个请求。&lt;br/&gt;2. B页面跳转到A页面，A页面不需要重新请求。&lt;br/&gt;3. C页面跳转到A页面，A页面需要重新请求。&lt;/p&gt;
&lt;p&gt;实现方式如下：&lt;br/&gt;在 A 路由里面设置 meta 属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  path: &lt;/span&gt;'/a'&lt;span&gt;,
  name: &lt;/span&gt;'A'&lt;span&gt;,
  component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/a'&lt;span&gt;], resolve),
  meta: {
    keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以router/index下的所有代码变为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;
import Router from &lt;/span&gt;'vue-router'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import HelloWorld from '@/views/HelloWorld';&lt;/span&gt;
&lt;span&gt;
Vue.use(Router);

const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  mode: &lt;/span&gt;'history', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问路径不带井号  需要使用 history模式，才能使用 scrollBehavior&lt;/span&gt;
  base: '/page/app',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置单页应用的基路径&lt;/span&gt;
&lt;span&gt;  routes: [
    {
      path: &lt;/span&gt;'/'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve),  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/list'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存  false表示不需要被缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/detail'&lt;span&gt;,
      name: &lt;/span&gt;'detail'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/detail'], resolve) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;    },
    {
      path: &lt;/span&gt;'/a'&lt;span&gt;,
      name: &lt;/span&gt;'A'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/a'&lt;span&gt;], resolve),
      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/b'&lt;span&gt;,
      name: &lt;/span&gt;'B'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/b'&lt;span&gt;], resolve)
    },
    {
      path: &lt;/span&gt;'/c'&lt;span&gt;,
      name: &lt;/span&gt;'C'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/c'&lt;span&gt;], resolve)
    }
  ],
  scrollBehavior (to, from, savedPosition) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存到 meta 中，备用&lt;/span&gt;
    to.meta.savedPosition =&lt;span&gt; savedPosition;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (savedPosition) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { x: 0, y: 0&lt;span&gt; };
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
  }
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 B 组件里面设置 beforeRouteLeave&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeRouteLeave(to, from, next) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
  to.meta.keepAlive = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A缓存，不请求数据&lt;/span&gt;
  next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B组件所有代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;list&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/a&quot;&amp;gt;返回a页面&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'list'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to B Page'&lt;span&gt;
    };
  },
  created() {},
  methods: {
  },
  beforeRouteLeave(to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
    to.meta.keepAlive = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A缓存，不请求数据&lt;/span&gt;
    next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
&lt;span&gt;  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 C 组件里面设置 beforeRouteLeave：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeRouteLeave(to, from, next) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
  to.meta.keepAlive = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A不缓存，重新请求数据&lt;/span&gt;
&lt;span&gt;  console.log(to)
  next(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c组件所有代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;list&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/a&quot;&amp;gt;返回a页面&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'list'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to B Page'&lt;span&gt;
    };
  },
  created() {},
  methods: {
  },
  beforeRouteLeave(to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
    to.meta.keepAlive = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A不缓存，重新请求数据&lt;/span&gt;
&lt;span&gt;    console.log(to)
    next(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
&lt;span&gt;  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a组件内的所有的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;h1&amp;gt;vue&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;{{msg}}&amp;lt;/h2&amp;gt;
    &amp;lt;router-link to=&quot;/b&quot;&amp;gt;跳转到b页面&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/c&quot;&amp;gt;跳转到c页面&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'helloworld'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to A Page'&lt;span&gt;
    };
  },
  methods: {
    ajaxRequest() {
      const obj &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;'aa': 1&lt;span&gt;
      };
      Promise.all([&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.dispatch('testUrl', obj)]).then((res) =&amp;gt;&lt;span&gt; {});
    }
  },
  beforeRouteEnter(to, from, next) {
    next(vm &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       如果 to.meta.savedPosition === undefined 说明是刷新页面或可以叫第一次进入页面 需要刷新数据
       如果to.meta.keepAlive === false, 那么说明是需要请求的;
       此时需要刷新数据，获取新的列表内容。
       否则的话 什么都不做，直接使用 keep-alive中的缓存
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (to.meta.savedPosition ===&lt;span&gt; undefined) {
        vm.ajaxRequest();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;to.meta.keepAlive) {
        vm.ajaxRequest();
      }
    })
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意 b组件到a组件不重新请求数据 (包括点击链接和浏览器后退按钮)，c组件到a组件请求数据(包括点击链接和浏览器后退按钮).&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/vue-keep-alive&quot; target=&quot;_blank&quot;&gt;查看github上的代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 14:52:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/8076245.html</dc:identifier>
</item>
<item>
<title>Scala入门系列（十二）：隐式转换 - 小丑进场</title>
<link>http://www.cnblogs.com/LiCheng-/p/8076090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiCheng-/p/8076090.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-12486&quot; readability=&quot;18&quot;&gt;
&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;Scala提供的隐式转换和隐式参数功能，是非常有特色的功能。是Java等编程语言所没有的功能。它可以允许你手动指定，将某种类型的对象转换成其他类型的对象。通过这些功能可以实现非常强大而且特殊的功能。&lt;/p&gt;
&lt;p&gt;Scala的隐式转换，其实&lt;strong&gt;最核心的就是定义隐式转换函数&lt;/strong&gt;，即&lt;code&gt;implicit conversion function&lt;/code&gt;。定义的隐式转换函数，只要在编写的程序内引入，就会被Scala自动使用。&lt;strong&gt;在程序中使用到隐式转换函数参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回&lt;/strong&gt;。这就是“隐式转换”。&lt;/p&gt;
&lt;p&gt;隐式转换函数叫什么名字是无所谓的，因为通常不会由用户手动调用，而是由Scala进行调用。但是如果要使用隐式转换，则需要对隐式转换函数进行导入。因此通常建议将隐式转换函数的名称命名为“one2one”的形式。&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12503&quot; readability=&quot;13&quot;&gt;
&lt;h2&gt;隐式转换&lt;/h2&gt;
&lt;p&gt;要实现隐式转换，只要程序可见的范围内定义隐式转换函数即可。Scala会自动调用隐式转换函数。&lt;/p&gt;
&lt;p&gt;隐式转换函数与普通函数唯一的区别就是要以&lt;code&gt;implicit&lt;/code&gt;开头，而且最好要定义函数返回类型。&lt;/p&gt;
&lt;p&gt;案例：特殊售票窗口（只接受特殊人群：比如学生、老人等）&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12392&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpecialPerson&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Older&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 我们想通过隐式转化把学生和老人转化为特殊人群，这样他们就可以在特殊窗口买票。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;object2SpecialPerson&lt;/span&gt;&lt;/span&gt;(obj: &lt;span&gt;Object&lt;/span&gt;): &lt;span&gt;SpecialPerson&lt;/span&gt; = {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if&lt;/span&gt;(obj.getClass == classOf[&lt;span&gt;Student&lt;/span&gt;]){ &lt;span&gt;val&lt;/span&gt; stu = obj.asInstanceOf[&lt;span&gt;Student&lt;/span&gt;]; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SpecialPerson&lt;/span&gt;(stu.name) }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (obj.getClass == classOf[&lt;span&gt;Older&lt;/span&gt;]) { &lt;span&gt;val&lt;/span&gt; older = obj.asInstanceOf[&lt;span&gt;Older&lt;/span&gt;]; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SpecialPerson&lt;/span&gt;(&lt;/p&gt;
&lt;p&gt;older.name) }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;Nil&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;var&lt;/span&gt; ticketNumber = &lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 只接受特殊人群的买票服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;buySpecialTicket&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;SpecialPerson&lt;/span&gt;) = {&lt;/p&gt;
&lt;p&gt;ticketNumber += &lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;T-&quot;&lt;/span&gt; + ticketNumber&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; stu = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;stu: &lt;span&gt;Student&lt;/span&gt; = &lt;span&gt;Student&lt;/span&gt;@&lt;span&gt;388623&lt;/span&gt;ad&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; old = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Older&lt;/span&gt;(&lt;span&gt;&quot;leo&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;old: &lt;span&gt;Older&lt;/span&gt; = &lt;span&gt;Older&lt;/span&gt;@&lt;span&gt;3453&lt;/span&gt;acd2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 学生和老人通过隐式转换后均可买特殊票&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; buySpecialTicket(stu)&lt;/p&gt;
&lt;p&gt;res9: &lt;span&gt;String&lt;/span&gt; = &lt;span&gt;T&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; buySpecialTicket(old)&lt;/p&gt;
&lt;p&gt;res10: &lt;span&gt;String&lt;/span&gt; = &lt;span&gt;T&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13097&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;使用隐式转换加强现有类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;隐式转换非常强大的一个功能，就是可以在不知不觉中加强现有类型的功能&lt;/strong&gt;。也就是说，可以为某个类定义一个加强版的类，并定义互相之间的隐式转换函数，从而让源类在使用加强版类的方法时，由Scala自动进行隐式转换，然后再调用加强类中特有的方法。 &lt;br/&gt;  &lt;br/&gt;案例：超人变身&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12394&quot; readability=&quot;27&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;// 定义超人类，具有发射激光方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Superman&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;emitLaser&lt;/span&gt;&lt;/span&gt; = println(&lt;span&gt;&quot;emit a laster!&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 定义隐式转换函数，将普通人转为超人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;man2superman&lt;/span&gt;&lt;/span&gt;(man: &lt;span&gt;Man&lt;/span&gt;): &lt;span&gt;Superman&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Superman&lt;/span&gt;(man.name)&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Superman&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;man2superman: (man: &lt;span&gt;Man&lt;/span&gt;)&lt;span&gt;Superman&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 创建普通人类对象sparks&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; sparks = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt;(&lt;span&gt;&quot;leo&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;sparks: &lt;span&gt;Man&lt;/span&gt; = &lt;span&gt;Man&lt;/span&gt;@&lt;span&gt;75&lt;/span&gt;c56eb9&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// sparks通过隐式转换变身超人，拥有发射激光方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; sparks.emitLaser&lt;/p&gt;
&lt;p&gt;emit a laster!&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12587&quot; readability=&quot;14&quot;&gt;
&lt;h2&gt;隐式转化函数的作用域与导入&lt;/h2&gt;
&lt;p&gt;Scala默认会使用两种隐式转换，&lt;strong&gt;一种是源类型或目标类型的伴生对象内的的隐式转化函数；一种是当前程序作用域内的可以用唯一标识符表示的隐式转换函数&lt;/strong&gt;。（上面两个例子都属于第二种情况）&lt;/p&gt;
&lt;p&gt;如果隐式转换函数不在上述两种情况下的话，那么就必须手动使用import语法导入，例如：&lt;code&gt;import test._&lt;/code&gt; 。通常建议，仅仅在需要进行隐式转换的地方，比如某个函数或者方法内，用import导入隐式转换函数，这样可以缩小隐式转换函数的作用域，避免不需要的隐式转换。&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13084&quot; readability=&quot;7&quot;&gt;
&lt;h2&gt;隐式转换触发条件&lt;/h2&gt;
&lt;ol&gt;&lt;li rel=&quot;1&quot;&gt;调用某个函数，但是给函数传入的参数类型与函数定义的接收类型不匹配。（案例：特殊售票窗口） &lt;br/&gt; &lt;/li&gt;
&lt;li rel=&quot;2&quot;&gt;使用某个类型的对象，调用某个方法，而这个方法并不存在于该类型时。（案例：超人变身） &lt;br/&gt; &lt;/li&gt;
&lt;li rel=&quot;3&quot;&gt;使用某个类型的对象，调用该类中的某个方法，虽然该类型有这个方法，但是给方法传入的参数类型与定义接收类型不匹配（案例：特殊售票窗口加强版）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  &lt;br/&gt;案例：特殊售票窗口加强版&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12397&quot; readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 定义售票窗口类&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TicketHouse&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;var&lt;/span&gt; ticketNumber = &lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;buySpecialTicket&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;SpecialPerson&lt;/span&gt;) = {&lt;/p&gt;
&lt;p&gt;ticketNumber += &lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;T-&quot;&lt;/span&gt; + ticketNumber&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TicketHouse&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; ticketHouse = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TicketHouse&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ticketHouse: &lt;span&gt;TicketHouse&lt;/span&gt; = &lt;span&gt;TicketHouse&lt;/span&gt;@&lt;span&gt;522&lt;/span&gt;b2631&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; spark = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;spark: &lt;span&gt;Student&lt;/span&gt; = &lt;span&gt;Student&lt;/span&gt;@&lt;span&gt;588&lt;/span&gt;ffeb&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 当传入一个学生对象时，触发第三种隐式转换条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; ticketHouse.buySpecialTicket(spark)&lt;/p&gt;
&lt;p&gt;res2: &lt;span&gt;String&lt;/span&gt; = &lt;span&gt;T&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13038&quot; readability=&quot;12&quot;&gt;
&lt;h2&gt;隐式参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;隐式参数指的是在函数或者方法中，定义一个用implicit修饰的参数，此时Scala会尝试找到一个指定类型的，用implicit修饰的对象即隐式值，如果找到就将其注入参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Scala会在两个范围内查找：一种是当前作用域内可见的val或var定义的隐式变量；一种是隐式参数类型的伴生对象内的隐式值。 &lt;br/&gt; &lt;/p&gt;
&lt;p&gt;案例：考试签到&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13055&quot; readability=&quot;26&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignPen&lt;/span&gt;&lt;/span&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;/span&gt;(content: &lt;span&gt;String&lt;/span&gt;) =println(content)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 定义隐式参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;val&lt;/span&gt; signPen = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SignPen&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 函数中使用隐式参数，此时scala会尝试找到一个指定SignPen类型的用implicit修饰的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;signForExam&lt;/span&gt;&lt;/span&gt;(name: &lt;span&gt;String&lt;/span&gt;) (&lt;span&gt;implicit&lt;/span&gt; signPen: &lt;span&gt;SignPen&lt;/span&gt;) {&lt;/p&gt;
&lt;p&gt;signPen.write(name + &lt;span&gt;&quot; come to exam in time.&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignPen&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;signPen: &lt;span&gt;SignPen&lt;/span&gt; = &lt;span&gt;SignPen&lt;/span&gt;@&lt;span&gt;773&lt;/span&gt;dab28&lt;/p&gt;
&lt;p&gt;signForExam: (name: &lt;span&gt;String&lt;/span&gt;)(&lt;span&gt;implicit&lt;/span&gt; signPen: &lt;span&gt;SignPen&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 测试：当同学sparks来签到时，函数调用隐式参数的值完成签到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; signForExam(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;sparks come to exam in time.&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12400&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;Java数组与Scala数组的隐式转换&lt;/h2&gt;
&lt;p&gt;我们知道在Scala代码中，是直接可以调用JDK（JAVA）API的，比如调用一个Java数组类的方法，势必可能会传入Java类型的ArrayList，但是Scala中构造出来的其实是ArrayBuffer，你直接把Scala的ArrayBuffer传入Java接收ArrayList的方法，肯定不行。所以这时候隐式转换就派上用场了！&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13121&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 导入隐式转换函数，将scala的buffer类型转换为javalist类型&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.bufferAsJavaList&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.mutable.&lt;span&gt;ArrayBuffer&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; command = &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;&quot;javac&quot;&lt;/span&gt;, &lt;span&gt;&quot;C:\\Users\\Administrator\\Desktop\\Hello.java&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; processBuilder = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ProcessBuilder&lt;/span&gt;(command)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; process = processBuilder.start()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; res = process.waitFor()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;&lt;span&gt;// 导入隐式转换函数，将javalist类型转换为scala的buffer类型&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.asScalaBuffer&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.mutable.&lt;span&gt;Buffer&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; cmd: &lt;span&gt;Buffer&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;] = processBuilder.command()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cmd: scala.collection.mutable.&lt;span&gt;Buffer&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;] = &lt;span&gt;ArrayBuffer&lt;/span&gt;(javac, &lt;span&gt;C&lt;/span&gt;:\&lt;span&gt;Users&lt;/span&gt;\&lt;span&gt;Administrator&lt;/span&gt;\&lt;span&gt;Desktop&lt;/span&gt;\&lt;span&gt;Hel&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lo.java)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;&lt;code&gt;Java Map与Scala Map的隐式转换&lt;/code&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-12403&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// Java Map转换为Scala Map&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.mapAsScalaMap&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 创建Java.util.HashMap对象&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; javaScores = &lt;span&gt;new&lt;/span&gt; java.util.&lt;span&gt;HashMap&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Int&lt;/span&gt;]()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;javaScores.put(&lt;span&gt;&quot;Alice&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;javaScores.put(&lt;span&gt;&quot;Bob&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;javaScores.put(&lt;span&gt;&quot;Cindy&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; scalaScorces: scala.collection.mutable.&lt;span&gt;Map&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Int&lt;/span&gt;] = javaScores&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scalaScorces: scala.collection.mutable.&lt;span&gt;Map&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;,&lt;span&gt;Int&lt;/span&gt;] = &lt;span&gt;Map&lt;/span&gt;(&lt;span&gt;Bob&lt;/span&gt; -&amp;gt; &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;Alice&lt;/span&gt; -&amp;gt; &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;Cindy&lt;/span&gt; -&amp;gt; &lt;span&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;&lt;span&gt;// Scala Map转换为Java Map&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.mapAsJavaMap&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.awt.font.&lt;span&gt;TextAttribute&lt;/span&gt;._&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; scalaAttrMap = &lt;span&gt;Map&lt;/span&gt;(&lt;span&gt;FAMILY&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;Sermi&quot;&lt;/span&gt;, &lt;span&gt;SIZE&lt;/span&gt; -&amp;gt; &lt;span&gt;12&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scalaAttrMap: scala.collection.immutable.&lt;span&gt;Map&lt;/span&gt;[java.awt.font.&lt;span&gt;TextAttribute&lt;/span&gt;,&lt;span&gt;Any&lt;/span&gt;] = &lt;span&gt;Map&lt;/span&gt;(java.awt.font.&lt;span&gt;Te&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;xtAttribute(family) -&amp;gt; &lt;span&gt;Sermi&lt;/span&gt;, java.awt.font.&lt;span&gt;TextAttribute&lt;/span&gt;(size) -&amp;gt; &lt;span&gt;12&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; font = &lt;span&gt;new&lt;/span&gt; java.awt.&lt;span&gt;Font&lt;/span&gt;(scalaAttrMap)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;font: java.awt.&lt;span&gt;Font&lt;/span&gt; = java.awt.&lt;span&gt;Font&lt;/span&gt;[family=&lt;span&gt;Dialog&lt;/span&gt;,name=&lt;span&gt;Sermi&lt;/span&gt;,style=plain,size=&lt;span&gt;12&lt;/span&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 20 Dec 2017 14:10:00 +0000</pubDate>
<dc:creator>小丑进场</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiCheng-/p/8076090.html</dc:identifier>
</item>
<item>
<title>SLAM入门笔记(1)：特征点的匹配 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/8076061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/8076061.html</guid>
<description>&lt;p&gt;SLAM 主要分为两个部分：前端和后端，前端也就是视觉里程计（VO），它根据相邻图像的信息粗略的估计出相机的运动，给后端提供较好的初始值。VO的实现方法可以根据是否需要提取特征分为两类：基于特征点的方法，不使用特征点的直接方法。 基于特征点的VO运行稳定，对光照、动态物体不敏感。&lt;/p&gt;
&lt;p&gt;图像特征点的提取和匹配是计算机视觉中的一个基本问题，在视觉SLAM中就需要首先找到相邻图像对应点的组合，根据这些匹配的点对计算出相机的位姿（相对初始位置，相机的旋转和平移）。&lt;br/&gt;本文对这段时间对特征点的学习做一个总结，主要有以下几方面的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征点概述&lt;/li&gt;
&lt;li&gt;常用的特征点算法，如SIFT,SURF，FAST等&lt;/li&gt;
&lt;li&gt;OpenCV3中特征点的提取和匹配&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;特征点概述&quot;&gt;特征点概述&lt;/h3&gt;
&lt;p&gt;如何高效且准确的匹配出两个不同视角的图像中的同一个物体，是许多计算机视觉应用中的第一步。虽然图像在计算机中是以灰度矩阵的形式存在的，但是利用图像的灰度并不能准确的找出两幅图像中的同一个物体。这是由于灰度受光照的影响，并且当图像视角变化后，同一个物体的灰度值也会跟着变化。所以，就需要找出一种能够在相机进行移动和旋转（视角发生变化），仍然能够保持不变的特征，利用这些不变的特征来找出不同视角的图像中的同一个物体。&lt;/p&gt;
&lt;p&gt;为了能够更好的进行图像匹配，需要在图像中选择具有代表性的区域，例如：图像中的角点、边缘和一些区块，但在图像识别出角点是最容易，也就是说角点的辨识度是最高的。所以，在很多的计算机视觉处理中，都是提取交掉作为特征，对图像进行匹配，例如SFM，视觉SLAM等。&lt;/p&gt;
&lt;p&gt;但是，单纯的角点并不能很好的满足我们的需求，例如：相机从远处得到的是角点，但是在近处就可能不是角点；或者，当相机旋转后，角点就发生了变化。为此，计算机视觉的研究者们设计了许多更为稳定的的特征点，这些特征点不会随着相机的移动，旋转或者光照的变化而变化。例如：SIFT,SURF,ORB等&lt;/p&gt;
&lt;p&gt;一个图像的特征点由两部分构成：关键点（Keypoint）和描述子（Descriptor）。 关键点指的是该特征点在图像中的位置，有些还具有方向、尺度信息；描述子通常是一个向量，按照人为的设计的方式，描述关键点周围像素的信息。通常描述子是按照&lt;strong&gt;外观相似的特征应该有相似的描述子&lt;/strong&gt;设计的。因此，在匹配的时候，只要两个特征点的描述子在向量空间的距离相近，就可以认为它们是同一个特征点。&lt;/p&gt;
&lt;p&gt;特征点的匹配通常需要以下三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提取图像中的关键点，这部分是查找图像中具有某些特征（不同的算法有不同的）的像素&lt;/li&gt;
&lt;li&gt;根据得到的关键点位置，计算特征点的描述子&lt;/li&gt;
&lt;li&gt;根据特征点的描述子，进行匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里先介绍下特征点的描述子，一个好的描述子是准确匹配的基础，关键点的提取和特征点的匹配，在后面介绍。&lt;/p&gt;
&lt;h3 id=&quot;特征点描述子&quot;&gt;特征点描述子&lt;/h3&gt;
&lt;p&gt;从图像中提取到特征的关键点信息，通常只是其在图像的位置信息（有可能包含尺度和方向信息），仅仅利用这些信息无法很好的进行特征点的匹配，所以就需要更详细的信息，将特征区分开来，这就是特征描述子。另外，通过特征描述子可以消除视角的变化带来图像的尺度和方向的变化，能够更好的在图像间匹配。&lt;/p&gt;
&lt;p&gt;特征的描述子通常是一个精心设计的向量，描述了关键点及其周围像素的信息。为了能够更好的匹配，一个好的描述子通常要具有以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不变性 指特征不会随着图像的放大缩小旋转而改变。&lt;/li&gt;
&lt;li&gt;鲁棒性 对噪声、光照或者其他一些小的形变不敏感&lt;/li&gt;
&lt;li&gt;可区分性 每一个特征描述子都是独特的，具有排他性，尽可能减少彼此间的相似性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中描述子的可区分性和其不变性是矛盾的，一个具有众多不变性的特征描述子，其区分局部图像内容的能力就比较稍弱；而如果一个很容易区分不同局部图像内容的特征描述子，其鲁棒性往往比较低。所以，在设计特征描述子的时候，就需要综合考虑这三个特性，找到三者之间的平衡。&lt;/p&gt;
&lt;p&gt;特征描述子的不变性主要体现在两个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;尺度不变性 Scale Invarient&lt;/strong&gt;&lt;br/&gt;指的是同一个特征，在图像的不同的尺度空间保持不变。匹配在不同图像中的同一个特征点经常会有图像的尺度问题，不同尺度的图像中特征点的距离变得不同，物体的尺寸变得不同，而仅仅改变特征点的大小就有可能造成强度不匹配。如果描述子无法保证尺度不变性，那么同一个特征点在放大或者缩小的图像间，就不能很好的匹配。为了保持尺度的不变性，在计算特征点的描述子的时候，通常将图像变换到统一的尺度空间，再加上尺度因子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;旋转不变性 Rotation Invarient&lt;/strong&gt;&lt;br/&gt;指的是同一个特征，在成像视角旋转后，特征仍然能够保持不变。和尺度不变性类似，为了保持旋转不变性，在计算特征点描述子的时候，要加上关键点的方向信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了有个更直观的理解，下面给出SIFT,SURF,BRIEF描述子计算方法对比&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/439761/201712/439761-20171220215116521-1110847369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看出，SIFT,SURF和BRIEF描述子都是一个向量，只是维度不同。其中，SIFT和SURF在构建特征描述子的时候，保存了特征的方向和尺度特征，这样其特征描述子就具有尺度和旋转不变性；而BRIEF描述子并没有尺度和方向特征，不具备尺度和旋转不变性。&lt;/p&gt;
&lt;h3 id=&quot;常用的特征点算法&quot;&gt;常用的特征点算法&lt;/h3&gt;
&lt;p&gt;上面提到图像的特征点包含两个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征点的提取，在图像检测到特征点的位置&lt;/li&gt;
&lt;li&gt;特征点的描述，也就是描述子。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在图像中提取到关键点的位置信息后，为了能够更有效的匹配（主要是保证尺度和旋转不变性），通常使用一个向量来描述关键点及其周围的信息。特征的描述子，在特征点的匹配中是非常重要的，上一小节中对其应该具有的性质做了介绍。但具体到一个算法来说，可能其既有特征点的提取算法也有特征点描述子的算法，也有可能其仅仅是一个特征点提取算法或者是特征点的描述子算法。在本小节就常用的特征点算法做一个简要的说明。&lt;/p&gt;
&lt;h4 id=&quot;sift&quot;&gt;SIFT&lt;/h4&gt;
&lt;p&gt;提到特征点算法，首先就是大名鼎鼎的SIFT算法了。SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换，2004年由加拿大教授David G.Lowe提出的。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。&lt;br/&gt;SIFT算法主要有以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高斯差分金字塔的构建&lt;br/&gt;使用组和层的结构构建了一个具有线性关系的金字塔（尺度空间），这样可以在连续的高斯核尺度上查找图像的特征点；另外，它使用一阶的高斯差分来近似高斯的拉普拉斯核，大大的减少了运算量。&lt;/li&gt;
&lt;li&gt;尺度空间的极值检测及特征点的定位&lt;br/&gt;搜索上一步建立的高斯尺度空间，通过高斯差分来识别潜在的对尺度和旋转不变的特征点。但是，在离散空间中，局部极值点可能并不是真正意义的极值点，真正的极值点有可能落在离散点的间隙中，SIFT通过尺度空间DoG函数进行曲线拟合寻找极值点。&lt;/li&gt;
&lt;li&gt;特征方向赋值&lt;br/&gt;基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。&lt;/li&gt;
&lt;li&gt;特征描述子的生成&lt;br/&gt;通过上面的步骤已经找到的SIFT特征点的位置、方向、尺度信息，最后使用一组向量来描述特征点及其周围邻域像素的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SIFT算法中及包含了特征点的提取算法，也有如何生成描述子的算法，更进一步的SIFT算法介绍可参看&lt;a href=&quot;http://www.cnblogs.com/wangguchangqing/p/4853263.html&quot; title=&quot;SIFT特征详解&quot;&gt;SIFT特征详解&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;surf&quot;&gt;SURF&lt;/h4&gt;
&lt;p&gt;SURF全称 Speeded Up Robust Features，是在SIFT算法的基础上提出的，主要针对SIFT算法运算速度慢，计算量大的缺点进行了改进。&lt;br/&gt;SURF的流程和SIFT比较类似，这些改进体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征点检测是基于Hessian矩阵，依据Hessian矩阵行列式的极值来定位特征点的位置。并且将Hession特征计算与高斯平滑结合在一起，两个操作通过近似处理得到一个核模板。&lt;/li&gt;
&lt;li&gt;在构建尺度空间时，使用box filter与源图像卷积，而不是使用DoG算子。&lt;/li&gt;
&lt;li&gt;SURF使用一阶Haar小波在x、y两个方向的响应作为构建特征向量的分布信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;fast特征点提取算法&quot;&gt;FAST特征点提取算法&lt;/h4&gt;
&lt;p&gt;SIFT和SURF是非常好的，稳定的特征点算法，但运算速度是其一大弊端，无法做到实时的特征提取和匹配，其应用就有了很大的局限性。FAST特征提取算法弥补了这一局限，&lt;strong&gt;检测局部像素灰度变化明显的地方&lt;/strong&gt;，以速度快而著称，其全称为：Features From Accelerated Segment Test。在FAST算法的思想很简单：如果一个像素与周围邻域的像素差别较大（过亮或者过暗），那么可以认为该像素是一个角点。和其他的特征点提取算法相比，FAST算法只需要比较像素和其邻域像素的灰度值大小，十分便捷。&lt;br/&gt;FAST算法提取角点的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在图像中选择像素p，假设其灰度值为：&lt;span class=&quot;math inline&quot;&gt;\(I_p\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;设置一个阈值T，例如：&lt;span class=&quot;math inline&quot;&gt;\(I_p\)&lt;/span&gt;的20%&lt;/li&gt;
&lt;li&gt;选择p周围半径为3的圆上的16个像素，作为比较像素&lt;/li&gt;
&lt;li&gt;假设选取的圆上有连续的N个像素大于&lt;span class=&quot;math inline&quot;&gt;\(I_p + T\)&lt;/span&gt;或者&lt;span class=&quot;math inline&quot;&gt;\(I_p - T\)&lt;/span&gt;，那么可以认为像素p就是一个特征点。（N通常取12，即为FAST-12；常用的还有FAST-9,FAST-11）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FAST算法只检测像素的灰度值，其运算速度极快，同时不可避免的也有一些缺点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检测到的特征点过多并且会出现“扎堆”的现象。这可以在第一遍检测完成后，使用非最大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的情况。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点没有方向和尺度信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的介绍的SIFT和SURF算法都包含有各自的特征点描述子的计算方法，而FAST不包含特征点描述子的计算，仅仅只有特征点的提取方法，这就需要一个特征点描述方法来描述FAST提取到的特征点，以方便特征点的匹配。下面介绍一个专门的特征点描述子的计算算法。&lt;/p&gt;
&lt;h4 id=&quot;brief描述子&quot;&gt;BRIEF描述子&lt;/h4&gt;
&lt;p&gt;BRIEF是一种二进制的描述子，其描述向量是0和1表示的二进制串。0和1表示特征点邻域内两个像素（p和q）灰度值的大小：如果p比q大则选择1，反正就取0。在特征点的周围选择128对这样的p和q的像素对，就得到了128维由0，1组成的向量。那么p和q的像素对是怎么选择的呢？通常都是按照某种概率来随机的挑选像素对的位置。&lt;br/&gt;BRIEF使用随机选点的比较，速度很快，而且使用二进制串表示最终生成的描述子向量，在存储以及用于匹配的比较时都是非常方便的，其和FAST的搭配起来可以组成非常快速的特征点提取和描述算法。&lt;/p&gt;
&lt;h4 id=&quot;orb算法&quot;&gt;ORB算法&lt;/h4&gt;
&lt;p&gt;ORB的全称是Oriented FAST and Rotated BRIEF，是目前来说非常好的能够进行的实时的图像特征提取和描述的算法，它改进了FAST特征提取算法，并使用速度极快的二进制描述子BRIEF。&lt;br/&gt;针对FAST特征提取的算法的一些确定，ORB也做了相应的改进。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用非最大值抑制，在一定区域内仅仅保留响应极大值的角点，避免FAST提取到的角点过于集中。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点数量过多且不是很稳定，ORB中可以指定需要提取到的角点的数量N，然后对FAST提取到的角点分别计算Harris响应值，选择前N个具有最大响应值的角点作为最终提取到的特征点集合。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点不具有尺度信息，在ORB中使用图像金字塔，并且在每一层金字塔上检测角点，以此来保持尺度的不变性。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点不具有方向信息，在ORB中使用灰度质心法(Intensity Centroid)来保持特征的旋转不变性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;opencv3中特征点的提取和匹配&quot;&gt;OpenCV3中特征点的提取和匹配&lt;/h3&gt;
&lt;p&gt;OpenCV中封装了常用的特征点算法（如SIFT,SURF，ORB等），提供了统一的接口，便于调用。 下面代码是OpenCV中使用其feature 2D 模块的示例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Mat img1 = imread(&quot;F:\\image\\1.png&quot;);
    Mat img2 = imread(&quot;F:\\image\\2.png&quot;);

    // 1. 初始化
    vector&amp;lt;KeyPoint&amp;gt; keypoints1, keypoints2;
    Mat descriptors1, descriptors2;
    Ptr&amp;lt;ORB&amp;gt; orb = ORB::create();

    // 2. 提取特征点
    orb-&amp;gt;detect(img1, keypoints1);
    orb-&amp;gt;detect(img2, keypoints2);

    // 3. 计算特征描述符
    orb-&amp;gt;compute(img1, keypoints1, descriptors1);
    orb-&amp;gt;compute(img2, keypoints2, descriptors2);
    
    // 4. 对两幅图像的BRIEF描述符进行匹配，使用BFMatch，Hamming距离作为参考
    vector&amp;lt;DMatch&amp;gt; matches;
    BFMatcher bfMatcher(NORM_HAMMING);
    bfMatcher.match(descriptors1, descriptors2, matches);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;获取检测器的实例&lt;br/&gt;在OpenCV3中重新的封装了特征提取的接口，可统一的使用&lt;code&gt;Ptr&amp;lt;FeatureDetector&amp;gt; detector = FeatureDetector::create()&lt;/code&gt;来得到特征提取器的一个实例，所有的参数都提供了默认值，也可以根据具体的需要传入相应的参数。&lt;/li&gt;
&lt;li&gt;在得到特征检测器的实例后，可调用的&lt;code&gt;detect&lt;/code&gt;方法检测图像中的特征点的具体位置，检测的结果保存在&lt;code&gt;vector&amp;lt;KeyPoint&amp;gt;&lt;/code&gt;向量中。&lt;/li&gt;
&lt;li&gt;有了特征点的位置后，调用&lt;code&gt;compute&lt;/code&gt;方法来计算特征点的描述子，描述子通常是一个向量，保存在&lt;code&gt;Mat&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;得到了描述子后，可调用匹配算法进行特征点的匹配。上面代码中，使用了opencv中封装后的&lt;em&gt;暴力匹配算法&lt;/em&gt;&lt;code&gt;BFMatcher&lt;/code&gt;，该算法在向量空间中，将特征点的描述子一一比较，选择距离（上面代码中使用的是Hamming距离）较小的一对作为匹配点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面代码匹配后的结果如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/439761/201712/439761-20171220215154240-855351628.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;特征点的匹配后的优化&quot;&gt;特征点的匹配后的优化&lt;/h4&gt;
&lt;p&gt;特征的匹配是针对特征描述子的进行的，上面提到特征描述子通常是一个向量，两个特征描述子的之间的距离可以反应出其相似的程度，也就是这两个特征点是不是同一个。根据描述子的不同，可以选择不同的距离度量。如果是浮点类型的描述子，可以使用其欧式距离；对于二进制的描述子（BRIEF）可以使用其汉明距离（两个不同二进制之间的汉明距离指的是两个二进制串不同位的个数）。&lt;/p&gt;
&lt;p&gt;有了计算描述子相似度的方法，那么在特征点的集合中如何寻找和其最相似的特征点，这就是特征点的匹配了。最简单直观的方法就是上面使用的：暴力匹配方法(Brute-Froce Matcher)，计算某一个特征点描述子与其他所有特征点描述子之间的距离，然后将得到的距离进行排序，取距离最近的一个作为匹配点。这种方法简单粗暴，其结果也是显而易见的，通过上面的匹配结果，也可以看出有大量的错误匹配，这就需要使用一些机制来过滤掉错误的匹配。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;汉明距离小于最小距离的两倍&lt;br/&gt;选择已经匹配的点对的汉明距离小于最小距离的两倍作为判断依据，如果小于该值则认为是一个错误的匹配，过滤掉；大于该值则认为是一个正确的匹配。其实现代码也很简单，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 匹配对筛选
double min_dist = 1000, max_dist = 0;
// 找出所有匹配之间的最大值和最小值
for (int i = 0; i &amp;lt; descriptors1.rows; i++)
{
    double dist = matches[i].distance;
    if (dist &amp;lt; min_dist) min_dist = dist;
    if (dist &amp;gt; max_dist) max_dist = dist;
}
// 当描述子之间的匹配大于2倍的最小距离时，即认为该匹配是一个错误的匹配。
// 但有时描述子之间的最小距离非常小，可以设置一个经验值作为下限
vector&amp;lt;DMatch&amp;gt; good_matches;
for (int i = 0; i &amp;lt; descriptors1.rows; i++)
{
    if (matches[i].distance &amp;lt;= max(2 * min_dist, 30.0))
        good_matches.push_back(matches[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/439761/201712/439761-20171220215245146-476222421.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对比只是用暴力匹配的方法，进行过滤后的匹配效果好了很多。&lt;/p&gt;
&lt;ul readability=&quot;22.348325258058&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;交叉匹配&lt;br/&gt;针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的是想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中&lt;code&gt;BFMatcher&lt;/code&gt;已经封装了该方法，创建&lt;code&gt;BFMatcher&lt;/code&gt;的实例时，第二个参数传入&lt;code&gt;true&lt;/code&gt;即可，&lt;code&gt;BFMatcher bfMatcher(NORM_HAMMING,true)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;KNN匹配&lt;br/&gt;K近邻匹配，在匹配的时候选择K个和特征点最相似的点，如果这K个点之间的区别足够大，则选择最相似的那个点作为匹配点，通常选择K = 2，也就是最近邻匹配。对每个匹配返回两个最近邻的匹配，如果第一匹配和第二匹配距离比率足够大（向量距离足够远），则认为这是一个正确的匹配，比率的阈值通常在2左右。&lt;br/&gt;OpenCV中的匹配器中封装了该方法，上面的代码可以调用&lt;code&gt;bfMatcher-&amp;gt;knnMatch(descriptors1, descriptors2, knnMatches, 2);&lt;/code&gt;具体实现的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const float minRatio = 1.f / 1.5f;
const int k = 2;

vector&amp;lt;vector&amp;lt;DMatch&amp;gt;&amp;gt; knnMatches;
matcher-&amp;gt;knnMatch(leftPattern-&amp;gt;descriptors, rightPattern-&amp;gt;descriptors, knnMatches, k);

for (size_t i = 0; i &amp;lt; knnMatches.size(); i++) {
    const DMatch&amp;amp; bestMatch = knnMatches[i][0];
    const DMatch&amp;amp; betterMatch = knnMatches[i][1];

    float  distanceRatio = bestMatch.distance / betterMatch.distance;
    if (distanceRatio &amp;lt; minRatio)
        matches.push_back(bestMatch);
}const  float minRatio =  1.f  /  1.5f;
const  int k =  2;

vector&amp;lt;vector&amp;lt;DMatch&amp;gt;&amp;gt; knnMatches;
matcher-&amp;gt;knnMatch(leftPattern-&amp;gt;descriptors, rightPattern-&amp;gt;descriptors, knnMatches, 2);

for (size_t i =  0; i &amp;lt; knnMatches.size(); i++) {
    const DMatch&amp;amp; bestMatch = knnMatches[i][0];
    const DMatch&amp;amp; betterMatch = knnMatches[i][1];
    float distanceRatio = bestMatch.distance  / betterMatch.distance;
    if (distanceRatio &amp;lt; minRatio)
        matches.push_back(bestMatch);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将不满足的&lt;strong&gt;最近邻的匹配之间距离比率大于设定的阈值（1/1.5）&lt;/strong&gt;匹配剔除。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;20.726272912424&quot;&gt;
&lt;p&gt;RANSAC&lt;br/&gt;另外还可采用随机采样一致性（RANSAC）来过滤掉错误的匹配，该方法利用匹配点计算两个图像之间&lt;strong&gt;单应矩阵&lt;/strong&gt;，然后利用重投影误差来判定某一个匹配是不是正确的匹配。OpenCV中封装了求解单应矩阵的方法&lt;code&gt;findHomography&lt;/code&gt;,可以为该方法设定一个&lt;strong&gt;重投影误差的阈值&lt;/strong&gt;，可以得到一个向量mask来指定那些是符合该重投影误差的匹配点对，以此来剔除错误的匹配，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const int minNumbermatchesAllowed = 8;
if (matches.size() &amp;lt; minNumbermatchesAllowed)
    return;

//Prepare data for findHomography
vector&amp;lt;Point2f&amp;gt; srcPoints(matches.size());
vector&amp;lt;Point2f&amp;gt; dstPoints(matches.size());

for (size_t i = 0; i &amp;lt; matches.size(); i++) {
    srcPoints[i] = rightPattern-&amp;gt;keypoints[matches[i].trainIdx].pt;
    dstPoints[i] = leftPattern-&amp;gt;keypoints[matches[i].queryIdx].pt;
}

//find homography matrix and get inliers mask
vector&amp;lt;uchar&amp;gt; inliersMask(srcPoints.size());
homography = findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);

vector&amp;lt;DMatch&amp;gt; inliers;
for (size_t i = 0; i &amp;lt; inliersMask.size(); i++){
    if (inliersMask[i])
        inliers.push_back(matches[i]);
}
matches.swap(inliers);const  int minNumbermatchesAllowed =  8;
if (matches.size() &amp;lt; minNumbermatchesAllowed)
    return;

//Prepare data for findHomography
vector&amp;lt;Point2f&amp;gt;  srcPoints(matches.size());
vector&amp;lt;Point2f&amp;gt;  dstPoints(matches.size());

for (size_t i =  0; i &amp;lt; matches.size(); i++) {
    srcPoints[i] = rightPattern-&amp;gt;keypoints[matches[i].trainIdx].pt;
    dstPoints[i] = leftPattern-&amp;gt;keypoints[matches[i].queryIdx].pt;
}

//find homography matrix and get inliers mask
vector&amp;lt;uchar&amp;gt;  inliersMask(srcPoints.size());
homography =  findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);

vector&amp;lt;DMatch&amp;gt; inliers;
for (size_t i =  0; i &amp;lt; inliersMask.size(); i++){
    if (inliersMask[i])
        inliers.push_back(matches[i]);
}
matches.swap(inliers);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前写过一篇OpenCV的特征点匹配及一些剔除错误匹配的文章，&lt;a href=&quot;http://www.cnblogs.com/wangguchangqing/p/4333873.html&quot; title=&quot;OpenCV2:特征匹配及其优化&quot;&gt;OpenCV2:特征匹配及其优化&lt;/a&gt;，使用的是OpenCV2，在OpenCV3中更新了特征点检测和匹配的接口，不过大体还是差不多的。上一篇的文末附有练习代码的下载链接，不要直接打开sln或者project文件，有可能vs版本不一样打不开，本文的测试代码还没有整理，等有时间好好打理下github，练习的代码随手都丢了，到想用的时候又找不到了。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;翻了下，上一篇博客还是6月30号发布的，而今已是12月底，半年6个月时间就这样过去了。而我，好像没有什么成长啊，工资还是那么多，调试bug的技术倒是积累了很多，知道多线程程序调试;多进程通信;学会了用Windebug:分析dump文件，在无代码环境中attach到执行文件中分析问题或者拿着pdb文件和源代码在现场环境中进行调试...;实实在在的感受到了C++的内存泄漏和空指针导致的各种奇葩问题；知道了使用未初始化的变量的不稳定性；知道了项目设计中扩展性的重要的...&lt;br/&gt;写之前觉得自己虚度了半年，总结下来，这半年下来时间还是成长了不少的，心里的愧疚感降低了不少。不过以后还是要坚持写博客记录下学习的过程...&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 14:01:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/8076061.html</dc:identifier>
</item>
<item>
<title>深入浅出了解frame和bounds - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/8076051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/8076051.html</guid>
<description>&lt;h5 id=&quot;frame&quot;&gt;frame&lt;/h5&gt;
&lt;p&gt;frame的官方解释如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;This rectangle defines the size and position of the view in its superview’s coordinate system. Use this rectangle during layout operations to set the size and position the view. Setting this property changes the point specified by the center property and changes the size in the bounds rectangle accordingly. The coordinates of the frame rectangle are always specified in points.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它定义了一个view相对于父视图坐标系的位置和大小，它会影响center属性和bounds属性的size。&lt;br/&gt;先看一下它究竟是什么？&lt;br/&gt;它是一个CGRect类型,如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CGRect {
    CGPoint origin;
    CGSize size;
};
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CG_BOXABLE CGRect CGRect;

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CGPoint {
    CGFloat x;
    CGFloat y;
};
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CG_BOXABLE CGPoint CGPoint;

&lt;span class=&quot;co&quot;&gt;/* Sizes. */&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CGSize {
    CGFloat width;
    CGFloat height;
};
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CG_BOXABLE CGSize CGSize;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的origin就是该view的位置，它是一个CGPoint类型，也是一个结构体，包含了我们熟知的常用二维坐标系的x、y。根据x、y可以在坐标系里面唯一确定一个点。如下图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/frame.jpeg&quot; alt=&quot;frame&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个坐标系和我们平时接触的还不太一样，它是向右向下为正方向。所以对于window来说，其原点是左上角，比如现在的头像的起始坐标就是（200，40）。按照原来常规的坐标系来说，应该是（200，-40）。&lt;br/&gt;在设置一个CGRect的时候，用到的方法是CGRectMake,其实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;CG_INLINE CGRect
CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)
{
  CGRect rect;
  rect.origin.x = x; rect.origin.y = y;
  rect.size.width = width; rect.size.height = height;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; rect;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是自己在实现部分创建了一个rect，然后逐个赋值。&lt;br/&gt;关于frame，这里要注意的一点就是：frame是相对于父视图的坐标系来定位的。如果你这样设置frame:(0,0,100,200),也就是在父视图左上角添加了一个宽100，高200的子视图（前提是没有改变父视图的bounds，接下来会有介绍bounds）。&lt;/p&gt;
&lt;h5 id=&quot;bounds&quot;&gt;bounds&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The bounds rectangle, which describes the view’s location and size in its own coordinate system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;The default bounds origin is (0,0) and the size is the same as the size of the rectangle in the frame property. Changing the size portion of this rectangle grows or shrinks the view relative to its center point. Changing the size also changes the size of the rectangle in the frame property to match. The coordinates of the bounds rectangle are always specified in points.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Changing the bounds rectangle automatically redisplays the view without calling its drawRect: method. If you want UIKit to call the drawRect: method, set the contentMode property to UIViewContentModeRedraw.&lt;br/&gt;Changes to this property can be animated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它也是描述的是视图的位置和大小，只不过是在自己的坐标系上。也就是说它描述的是当前视图相对于自身坐标系的位置和大小。&lt;br/&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; viewDidLoad];
   
    CGRect rect  = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view.frame;
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView = [[ParentView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;, rect.size.width&lt;span class=&quot;dv&quot;&gt;-120&lt;/span&gt;, rect.size.height - &lt;span class=&quot;dv&quot;&gt;160&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.backgroundColor = [UIColor redColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view addSubview:_parentView];
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;frame:{{60, 80}, {200, 408}}
bounds:{{0, 0}, {200, 408}}
center:{160, 284}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，如果我们没有去更改bounds的值，它默认的位置坐标点是(0,0)。&lt;/p&gt;
&lt;h5 id=&quot;center&quot;&gt;center&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The center point of the view's frame rectangle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The center point is specified in points in the coordinate system of its superview. Setting this property updates the origin of the rectangle in the frame property appropriately.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Use this property, instead of the frame property, when you want to change the position of a view. The center point is always valid, even when scaling or rotation factors are applied to the view's transform.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Changes to this property can be animated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;center是view的中点。该属性是想归于父类的坐标系确定的。从bounds小节里面的例子可以看到center的值，其计算方法为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;center.x = frame.origin.x + frame.size.width/2&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;center.y = frame.origin.y + frame.size.height/2&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;transform&quot;&gt;transform&lt;/h5&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Specifies the transform applied to the view, relative to the center of its bounds.&lt;br/&gt;Use this property to scale or rotate the view's frame rectangle within its superview's coordinate system. (To change the position of the view, modify the center property instead.) The default value of this property is CGAffineTransformIdentity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Transformations occur relative to the view's anchor point. By default, the anchor point is equal to the center point of the frame rectangle. To change the anchor point, modify the anchorPoint property of the view's underlying CALayer object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Changes to this property can be animated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;In iOS 8.0 and later, the transform property does not affect Auto Layout. Auto layout calculates a view’s alignment rectangle based on its untransformed frame.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它用于指定视图的变换。使用这个属性可以放大或者旋转视图，它的frame会因此改变，是以中心点为变换的。看例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; viewDidLoad];
   
    CGRect rect  = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view.frame;
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView = [[ParentView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;, rect.size.width&lt;span class=&quot;dv&quot;&gt;-120&lt;/span&gt;, rect.size.height - &lt;span class=&quot;dv&quot;&gt;160&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.backgroundColor = [UIColor redColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view addSubview:_parentView];
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
    
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.transform = CGAffineTransformMakeRotation(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;);
   
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;after change transform,frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;after change transform,bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;after change transform,center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看输出的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;frame:{{60, 80}, {200, 408}}
bounds:{{0, 0}, {200, 408}}
center:{160, 284}
after change transform,frame:{{2.5773352536321568, 59.226689885086444}, {314.84532949273569, 449.54662022982711}}
after change transform,bounds:{{0, 0}, {200, 408}}
after change transform,center:{160, 284}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/transform.jpeg&quot; alt=&quot;transform&quot;/&gt;&lt;br/&gt;可以看出，当我们对图像通过旋转,旋转后的图片的frame已经变成了{{2.5773352536321568, 59.226689885086444}, {314.84532949273569, 449.54662022982711}},此时的起始位置为图上旋转后标的（2.58,59.2）,大小也变成了双箭头黑线标注的大小。&lt;br/&gt;因此得出结论：进行了transform变换，其frame改变了，但是其bounds和center并没有修改。此时bounds的size和frame的size已经没有关系了。当没有进行任何transform时，frame的size总是和bounds相等。&lt;/p&gt;
&lt;p&gt;以上便是对frame、bounds、center和transform做了一个简单的介绍。&lt;/p&gt;
&lt;h5 id=&quot;bounds的使用&quot;&gt;bounds的使用&lt;/h5&gt;
&lt;p&gt;接下来看一个例子（例子A）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
   
    CGRect rect  = self.view.frame;
    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(60, 80, rect.size.width-120, rect.size.height - 160)];
    self.parentView.backgroundColor = [UIColor redColor];
    [self.view addSubview:_parentView];
    NSLog(@&quot;frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));
    NSLog(@&quot;bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));
    NSLog(@&quot;center:%@&quot;,NSStringFromCGPoint(self.parentView.center));
 
    self.parentView.bounds = CGRectMake(-40, -40, self.parentView.frame.size.width, self.parentView.frame.size.height);
    NSLog(@&quot;parent change bound ,frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));
    NSLog(@&quot;parent change bound ,bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));
    NSLog(@&quot;parent change bound ,center:%@&quot;,NSStringFromCGPoint(self.parentView.center));

    self.childView = [[ChildView alloc] initWithFrame:CGRectMake(20, 20, 100, 100)];
    self.childView.backgroundColor = [UIColor yellowColor];
    [self.parentView addSubview:_childView];
   
    NSLog(@&quot;childView frame:%@&quot;,NSStringFromCGRect(self.childView.frame));
    NSLog(@&quot;childView ounds:%@&quot;,NSStringFromCGRect(self.childView.bounds));
    NSLog(@&quot;childView center:%@&quot;,NSStringFromCGPoint(self.childView.center));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里在parentView上添加了一个childView,然后对parentView的bounds进行修改和不修改进行了测试，结果如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/changebounds.jpeg&quot; alt=&quot;change bounds&quot;/&gt;&lt;br/&gt;你会发现当修改了parentView的bounds之后，发现childView缺向右向下做了偏移。这里设置parentView的bounds的origin为（-40,-40）为何会发生这种情况呢？接下来先看一下下面这张图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/coordient_system.jpeg&quot; alt=&quot;坐标系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;+代表正方向，-代表负方向。&lt;/p&gt;
&lt;p&gt;如果此时我们没有改变图中O的坐标，那么此时A的坐标是(20,20)，如果我们更改了O的坐标为（-20,-20），那么原来A点的坐标就成了A'（0,0）,但是A坐标是不变的，所以它会到黑色A处。所以你改变了原点坐标为负之后，A点会移动到黑色A。相反如果你设置了坐标原点为（20,20），那么A点就会和坐标原点重合。&lt;br/&gt;这就是为什么childView会向右向下移动的原因。&lt;br/&gt;接下来再做如下操作（例子B）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; viewDidLoad];
   
    CGRect rect  = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view.frame;
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView = [[ParentView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;, rect.size.width&lt;span class=&quot;dv&quot;&gt;-120&lt;/span&gt;, rect.size.height - &lt;span class=&quot;dv&quot;&gt;160&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.backgroundColor = [UIColor redColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view addSubview:_parentView];
     
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;parent change bound ,frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;parent change bound ,bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;parent change bound ,center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));

    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView = [[ChildView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame.origin.x, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame.origin.y+&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame.size.height&lt;span class=&quot;dv&quot;&gt;-200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.backgroundColor = [UIColor yellowColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView addSubview:_childView];
   
    
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;childView frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;childView ounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;childView center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.center));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;--------&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    CGRect parentBounds = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds;
    [UIView animateWithDuration:&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; animations:^{
        
        &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds = CGRectMake(parentBounds.origin.x, &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, parentBounds.size.width, parentBounds.size.height);
    } completion:^(BOOL finished) {
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,parentView frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,parentView ounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,parentView center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,childView frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.frame));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,childView bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.bounds));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,childView center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.center));
    }];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parent change bound ,frame:{{60, 80}, {200, 408}}
parent change bound ,bounds:{{0, 0}, {200, 408}}
parent change bound ,center:{160, 284}
childView frame:{{60, 288}, {100, 100}}
childView ounds:{{0, 0}, {100, 100}}
childView center:{110, 338}
--------
anim finished,parentView frame:{{60, 80}, {200, 408}}
anim finished,parentView ounds:{{0, 400}, {200, 408}}
anim finished,parentView center:{160, 284}
anim finished,childView frame:{{60, 288}, {100, 100}}
anim finished,childView bounds:{{0, 0}, {100, 100}}
anim finished,childView center:{110, 338}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果是childView向上移动，然后停止。结果前后对比图如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/animationbounds.jpeg&quot; alt=&quot;animation bounds&quot;/&gt;&lt;br/&gt;直观来看，按说childView的frame改变了，但是从console输出的结果来看，childView的frame/bounds/center都没有改变，但是直观来看其位置却改变了。再看一下parentView,只有bounds改变了，frame和center却没变，从直观来看parentView没有任何更改。所以很有可能是parentView的bounds修改引起了childView的位置更改。这是为什么呢？这里先不说明为什么，再看一下最常用的UIScrollView:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    self.scrollView = [[ZGUIScrolLView alloc] initWithFrame:self.view.frame];
    self.scrollView.delegate = self;
    [self.view addSubview:_scrollView];
    NSLog(@&quot;scrollview frame:%@&quot;,NSStringFromCGRect(_scrollView.frame));
    NSLog(@&quot;scrollview bounds:%@&quot;,NSStringFromCGRect(_scrollView.bounds));
    NSLog(@&quot;scrollview center:%@&quot;,NSStringFromCGPoint(_scrollView.center));
    self.scrollView.contentSize = CGSizeMake(800, 800);
    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(20, 100, 250, 300)];
    self.parentView.backgroundColor = [UIColor redColor];
    [self.scrollView addSubview:_parentView];
    NSLog(@&quot;parentView frame:%@&quot;,NSStringFromCGRect(_parentView.frame));
    NSLog(@&quot;parentView bounds:%@&quot;,NSStringFromCGRect(_parentView.bounds));
    NSLog(@&quot;parentView center:%@&quot;,NSStringFromCGPoint(_parentView.center));
    
}
- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    NSLog(@&quot;didScroll scrollview frame:%@&quot;,NSStringFromCGRect(_scrollView.frame));
    NSLog(@&quot;didScroll scrollview bounds:%@&quot;,NSStringFromCGRect(_scrollView.bounds));
    NSLog(@&quot;didScroll scrollview center:%@&quot;,NSStringFromCGPoint(_scrollView.center));
    NSLog(@&quot;didScroll parentView frame:%@&quot;,NSStringFromCGRect(_parentView.frame));
    NSLog(@&quot;didScroll parentView bounds:%@&quot;,NSStringFromCGRect(_parentView.bounds));
    NSLog(@&quot;didScroll parentView center:%@&quot;,NSStringFromCGPoint(_parentView.center));
    printf(&quot;\n-------------------------------------------\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当滚动视图的时候，console输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scrollview frame:{{0, 0}, {320, 568}}
scrollview bounds:{{0, 0}, {320, 568}}
scrollview center:{160, 284}
parentView frame:{{20, 100}, {250, 300}}
parentView bounds:{{0, 0}, {250, 300}}
parentView center:{145, 250}
didScroll scrollview frame:{{0, 0}, {320, 568}}
didScroll scrollview bounds:{{0, -20}, {320, 568}}
didScroll scrollview center:{160, 284}
didScroll parentView frame:{{20, 100}, {250, 300}}
didScroll parentView bounds:{{0, 0}, {250, 300}}
didScroll parentView center:{145, 250}
-------------------------------------------
didScroll scrollview frame:{{0, 0}, {320, 568}}
didScroll scrollview bounds:{{8.5, 31.5}, {320, 568}}
didScroll scrollview center:{160, 284}
didScroll parentView frame:{{20, 100}, {250, 300}}
didScroll parentView bounds:{{0, 0}, {250, 300}}
didScroll parentView center:{145, 250}
-------------------------------------------
didScroll scrollview frame:{{0, 0}, {320, 568}}
didScroll scrollview bounds:{{25.5, 162}, {320, 568}}
didScroll scrollview center:{160, 284}
didScroll parentView frame:{{20, 100}, {250, 300}}
didScroll parentView bounds:{{0, 0}, {250, 300}}
didScroll parentView center:{145, 250}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据输出结果可以看到，parentView的center、frame、bounds在滚动过程中都没有作出更改，但是我们看到的它的位置的确改变了。而对于scrollView来说，其frame和center也没有更改，但是bounds更改了。&lt;br/&gt;这种现象和上面提到的（例子B）的现象一样，都是对bounds进行了修改。然后子视图从新进行了布局。说道子视图重新布局，让我想到了一个方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)layoutSubviews;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从字面意思看就是布局某个视图的子视图，那么会不会和这个方法有关呢？因此我在自定义的ZGUIScrollView里面实现了该方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)layoutSubviews {
    NSLog(@&quot;scrollview's layoutSubViews called&quot;);
    [super layoutSubviews];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次滚动界面，发现每次滚动都会调用scrollview的layoutSubViews方法。苹果官方文档介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lays out subviews.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的作用就是布局一个视图上的子视图。确定子视图的大小和位置。如果你想强制布局更新，你不能直接去调用这个方法，而是在下次更新图形之前调用setNeedsLayout方法，如果你要立即更新视图布局，调用layoutIfNeeded方法。&lt;/p&gt;
&lt;p&gt;由此可知，&lt;strong&gt;UIScrollView的实现就是通过bounds来实现的。contentOffset是bounds的origin。然后当bounds修改之后，会在layoutSubviews方法里面对子视图进行布局。对子类进行更新&lt;/strong&gt;。&lt;br/&gt;另外，我们还可以用bounds实现如下效果：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/boundstocell.jpeg&quot; alt=&quot;bounds to set cell&quot;/&gt;&lt;br/&gt;图上右侧便是使用了bounds实现的效果。实现方式就是在自定义cell中重写drawReact:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)drawRect:(CGRect)rect {
     &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.bounds = CGRectMake(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.bounds.origin.x, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.bounds.origin.y, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.frame.size.width&lt;span class=&quot;dv&quot;&gt;-20&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.frame.size.height - &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; drawRect:rect];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实UITableView(它是UIScrollView)的实现也是类似，更改了bounds,来实现滚动加载cell。&lt;/p&gt;
&lt;h5 id=&quot;总结&quot;&gt;总结&lt;/h5&gt;
&lt;p&gt;对bounds和frame的理解就是这些，其实系统用bounds的地方还是很多的。例如UIScrollView的实现就用到了。有疑问的话可以留言交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：转赞请标明来源：&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/8076051.html&quot;&gt;张贵的博客&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 13:58:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/8076051.html</dc:identifier>
</item>
<item>
<title>FiddlerCoreAPI开发（一）源码分析 - real王一</title>
<link>http://www.cnblogs.com/realwy/p/8075705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/realwy/p/8075705.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;前一段时间想利用fiddlercore截取本地&lt;strong&gt;HTTPS&lt;/strong&gt;的流量做一些分析，按照样例代码的注释学习了一下，没搞清楚怎么实现，后来又在网上查了些资料，对HTTPS的处理提及很少，都没有解决我的问题，主要是HTTPS证书的问题，索性自己研究了一下，终于解决了问题。我会在下篇文章中分享下我的思路，本篇文章先简单分析下fiddlercore自带样例的代码，帮助刚接触fiddlercore的人快速入门，如果有说的不对的地方，欢迎批评指正。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;2.源码分析&lt;/h2&gt;
&lt;p&gt;首先从官网下载FiddlerCoreAPI&lt;br/&gt;&lt;a href=&quot;https://www.telerik.com/purchase/fiddlercore&quot; class=&quot;uri&quot;&gt;https://www.telerik.com/purchase/fiddlercore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载下来是一个安装文件，解压后有demo和FiddlerCoreAPI库，打开样例代码工程，开始分析。&lt;/p&gt;
&lt;p&gt;从主函数开始。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Fiddler.Session&amp;gt; oAllSessions = new List&amp;lt;Fiddler.Session&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了一个fiddler的Session类的List，里面存放的是客户端和服务端的消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.SetAppDisplayName(&quot;FiddlerCoreDemoApp&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命名自己的应用程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.OnNotification += delegate(object sender, NotificationEventArgs oNEA) { Console.WriteLine(&quot;** NotifyUser: &quot; + oNEA.NotifyString); };
Fiddler.FiddlerApplication.Log.OnLogString += delegate(object sender, LogEventArgs oLEA) { Console.WriteLine(&quot;** LogString: &quot; + oLEA.LogString); };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两句，第一句绑定了用户通知事件的函数，具体什么时候触发没仔细研究，第二句绑定了FiddlerApplication.Log触发的事件（FiddlerCore自己的日志系统），后面打印内容都会用到，总之这两句就是把内容打印在控制台上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.BeforeRequest += delegate(Fiddler.Session oS)
{
    // Console.WriteLine(&quot;Before request for:\t&quot; + oS.fullUrl);
    oS.bBufferResponse = false;
    Monitor.Enter(oAllSessions);
    oAllSessions.Add(oS);
    Monitor.Exit(oAllSessions);
    
    if ((oS.oRequest.pipeClient.LocalPort == iSecureEndpointPort) &amp;amp;&amp;amp; (oS.hostname == sSecureEndpointHostname))
    {
        oS.utilCreateResponseAndBypassServer();
        oS.oResponse.headers.SetStatus(200, &quot;Ok&quot;);
        oS.oResponse[&quot;Content-Type&quot;] = &quot;text/html; charset=UTF-8&quot;;
        oS.oResponse[&quot;Cache-Control&quot;] = &quot;private, max-age=0&quot;;
        oS.utilSetResponseBody(&quot;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Request for httpS://&quot; + sSecureEndpointHostname + &quot;:&quot; + iSecureEndpointPort.ToString() + &quot; received. Your request was:&amp;lt;br /&amp;gt;&amp;lt;plaintext&amp;gt;&quot; + oS.oRequest.headers.ToString());
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BeforeRequest，顾名思义，就是在客户端发送请求后拦截之，在此函数中可以获取甚至修改请求的内容。&lt;/p&gt;
&lt;p&gt;oS.fullUrl为请求的URL。&lt;/p&gt;
&lt;p&gt;bBufferResponse这个属性，要设置成true才可以修改服务器响应的内容。&lt;/p&gt;
&lt;p&gt;接下来的if判断，是一个例子，如果你访问https://localhost:7777，他会拦截你的请求，并构造响应报文返回给你，服务端不会收到该请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.Startup(iPort, oFCSF);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开启FiddlerCore在指定端口的监听。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;oSecureEndpoint = FiddlerApplication.CreateProxyEndpoint(iSecureEndpointPort, true, sSecureEndpointHostname);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立在指定端口的HTTPS的监听，这个函数下篇文章中还会说到。&lt;/p&gt;
&lt;p&gt;至此，这个样例的主要代码就分析完了，它实现了简单的http请求截获和响应替换，剩余的代码都是些与用户的交互，这里不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;注意&quot;&gt;3.注意&lt;/h2&gt;
&lt;p&gt;前面代码执行完后，一定要调用Shutdown()函数关闭FiddlerCore应用，不然会导致浏览器还是通过Fiddler代理，上不了网。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Fiddler.FiddlerApplication.Shutdown();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在证书管理器中可以看到FiddlerCore安装了自己的证书。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209573/201712/1209573-20171220202829131-1078374781.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;阅读样例代码的注释很有帮助，还有FiddlerCore的&lt;a href=&quot;http://download.csdn.net/download/u010156775/10164938&quot;&gt;帮助文档&lt;/a&gt;，里面各个函数的功能说的很详细。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 12:32:00 +0000</pubDate>
<dc:creator>real王一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/realwy/p/8075705.html</dc:identifier>
</item>
<item>
<title>程序员的自我救赎---3.2：SSO及应用案例 - Near_wen</title>
<link>http://www.cnblogs.com/demon28/p/8058662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demon28/p/8058662.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;《前言》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（一） Winner2.0 框架基础分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（二）PLSQL报表系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（三）SSO单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（四） 短信中心与消息中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（五）钱包系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（六）GPU支付中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（七）权限系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（八）监控系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（九）会员中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十） APP版本控制系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十一）Winner前端框架与RPC接口规范讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十二）上层应用案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十三）总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《SSO及应用案例》&lt;/p&gt;
&lt;p&gt;先说说SSO（单点登录）这种产物是怎么来的？ 场景是这样的假设一个大型应用平台（web）下面有几个模块比如：商城，机票，酒店。&lt;/p&gt;
&lt;p&gt;我上商城时候我没有登录，则登录一下，而又从商城跳转到酒店，发现酒店没登录则又需要登录一下酒店网站。&lt;/p&gt;
&lt;p&gt;这里人们就会想有没有，我在我当前域名下一处登录，就可以在当前域名（子域名）随处浏览以及操作，所以这时候就诞生了SSO。&lt;/p&gt;

&lt;p&gt;SSO不单单解决了我们“一处登录，到处操作”的问题以外，还省去了我们每个项目开发登录模块的时间。SSO的基本原理如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171218153553615-995131153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SSO虽然叫单点登录，但是我们更愿意叫他“统一登录中心”，因为的他的职责就是承担了所有的登录工作，虽然SSO在Web时代很盛行，但是在APP时代&lt;/p&gt;
&lt;p&gt;就又有很大的不同了，这个我后面会讲到。这里先讲一下上面一张图中SSO 以及客户端分别是做了哪些事情&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171218172603943-384965682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 这里画的还是比较抽象，有几点可以说一下：&lt;/p&gt;
&lt;p&gt;1，上图中应用里用Session存储用户信息，有的做法是用Cookie。这里用Session或Cookie都可以，但是Cookie本身存在客户端浏览器中，&lt;/p&gt;
&lt;p&gt;    所以从安全性上来说不如Session，Cookie的优点是不会随浏览器的关闭而销毁，下次访问网站时可以无需登录。这里各取所需，我们从安全性&lt;/p&gt;
&lt;p&gt;    上考虑说选择了用Session。&lt;/p&gt;
&lt;p&gt;2，关于创建Ticket后将Ticket传给子站。Ticket叫做“令牌”，本身包含用户的基础信息（比如账号、用户名）还有子站要访问的页面地址，以及过期时间等等。&lt;/p&gt;
&lt;p&gt;   Ticket要回传给子站有的是直接往SSO站的Cookie里面存，然后子站通过设置domain参数共享cookie读写。这个本身没有问题但是还是个第一点一样。&lt;/p&gt;
&lt;p&gt;    把握好安全性就行。&lt;/p&gt;
&lt;p&gt;3，图一我画的是用cookie的方式，尽管本地有用户信息（Ticket）但是为是安全还是要上SSO上请验证一下，登录是否过期。这种做法有的甚至每个页面都去&lt;/p&gt;
&lt;p&gt;    请求SSO看是否有过期，过期了则退出登录，这个是根据业务需求的不同做的。比如邮箱，没操作一次授权时间加长10分钟，如果十分钟没有任何操作&lt;/p&gt;
&lt;p&gt;     再操作的时候就被退出了。这个看具体应用，用法不同而已。&lt;/p&gt;
&lt;p&gt;4，如果客户端（浏览器）禁用Cookie那Session是拿不到的。这个其实都知道每个浏览器的Session_Id不同，Session本身是键值对，但是唯一性标识&lt;/p&gt;
&lt;p&gt;    不是Session的key，是Session_id，而session_id 是保存在浏览器的Cookie中的，其实就等于禁用了Cookie，Session也废了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171218175246756-1681739432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;============================华丽的分割线===================================&lt;/p&gt;

&lt;p&gt;接下来要说重点了，其实在上一篇&lt;a href=&quot;http://www.cnblogs.com/demon28/p/8036873.html&quot; target=&quot;_blank&quot;&gt;《理解Oauth2.0》&lt;/a&gt;中就讲到了很多和SSO类似的概念，其实两者本质是一样的。但是我们也可以&lt;/p&gt;
&lt;p&gt;分开来看。我就更习惯分开来看，我的理解是这样的，我认为OAuth更关注的是“授权”，SSO则侧重是“登录”。&lt;/p&gt;
&lt;p&gt;所以从概念上来说，OAuth的设计天生就不用去关注比如跨域这样的问题，SSO则更多是本平台下一站登录，随处操作。&lt;/p&gt;

&lt;p&gt;前期我们Winner框架中是SSO来扩展OAuth，今年Jason重构了一个版本则是OAuth来兼任SSO。这里没有好坏技术高低之分，只是场景不同。&lt;/p&gt;
&lt;p&gt;现在基本是一个APP的时代，所以SSO的功能被弱化了，更多时候我们使用APP就没有一个所谓的“一处登录，随处操作”的说法，就一个登录。&lt;/p&gt;

&lt;p&gt;我们来看看Winner中的核心代码：&lt;/p&gt;
&lt;p&gt;首先，我在前面讲《&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7977974.html&quot; target=&quot;_blank&quot;&gt;Winner.FrameWork.MVC&lt;/a&gt;》 的时候有说到，以前我们使用基类去验证用户是否登录，而现在我们使用更灵活的特性类去处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/161176/201712/161176-20171218181508240-1542504383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们Winner中特性类的验证最常用的是[AuthLogin] 和 [AuthRigth] 两者的不同在于 [AuthLogin] 只验证是否有登录，没有登录就去登录。&lt;/p&gt;
&lt;p&gt; 意思就是说该页面所有人都有权限访问，前提是有注册。而[AuthRigth] 则不单单是验证了是否登录，还验证了是否有权限访问本页面。&lt;/p&gt;
&lt;p&gt;关于权限那一块，在后面的文章中我再单独讲权限系统时再细讲。&lt;/p&gt;

&lt;p&gt;我们重点来看一下[AuthLogin] 的核心代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Dynamic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Xml;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.MVC.Attribute;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.MVC.GlobalContext;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.MVC.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.MVC.Models.Account;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Winner.Framework.MVC
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; PC Web用户登陆检查
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthLoginAttribute : AuthorizationFilterAttribute
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实例化一个新的验证对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;ignore&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否忽略检查&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; AuthLoginAttribute(&lt;span&gt;bool&lt;/span&gt; ignore = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(ignore)
        {
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 登陆验证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;当前上下文&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; OnAuthorizationing(AuthorizationContext context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Ajax请求但又未登录时则返回信息&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!ApplicationContext.Current.IsLogined &amp;amp;&amp;amp; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ContextProvider.IsAjaxRequest)
            {
                OutputResult(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未登录或者会话已过期，请重新登录！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;401&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.HttpContext.Session == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务器Session不可用！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用提供者进行登陆&lt;/span&gt;
&lt;span&gt;                ProviderManager.LoginProvider.Login();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Log.Error(ex);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ex.InnerException != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    Log.Error(ex.InnerException);
                }
                OutputResult(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登陆时出现系统繁忙，请稍后再试！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;401&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有登陆则返回&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ApplicationContext.Current.IsLogined)
            {
                OutputResult(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;401&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 我们看到一开始我们有base(ignore)；这个我在前面的篇章中有讲到过，这个可以通过配置文件配置，目的是省去我们每个项目开发的时候都要去登录。&lt;/p&gt;
&lt;p&gt;在配置文件中默认一个登录账号，这样调试时候能省很多时间。&lt;/p&gt;
&lt;p&gt;我们判断的步骤是这样的：&lt;/p&gt;
&lt;p&gt;第一步：如果用户是ajax请求，并且用户信息不存在的话直接返回false。这里是应对用户登录之后 用户长时间未操作造成用户信息过期失效&lt;/p&gt;
&lt;p&gt;             因为我们的Winner框架基本都是Ajax请求，所以当两个条件都存在的时候就直接返回401错误。如果界面显示401则重新刷新一下，&lt;/p&gt;
&lt;p&gt;             因为刷新就不是Ajax了，所以就会跳到登录页去登录。&lt;/p&gt;
&lt;p&gt;第二步：判断Session是否可用，不可用就直接抛异常了，就是我上面说的禁用Session这种情况。&lt;/p&gt;
&lt;p&gt;第三步：在ProviderManager.LoginProvider.Login()，我们才是做了具体的操作，我们看一下Login()代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Login()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否有SSO站点POST过来的用户退出数据&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; HttpContext.Current.Request.Url.Query;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO：退出本地登陆&lt;/span&gt;
&lt;span&gt;                Logout();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查本地系统是否已登陆&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ApplicationContext.Current.IsLogined)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否有配置自动登陆&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (GlobalConfig.IsAutoLogin)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理登陆配置文件所配置的用户&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; autoResult = ApplicationContext.UserLogin(GlobalConfig.DefaultAutoLoginUserId, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;autoResult.Success)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception(autoResult.Message);
                }
                HttpCookie cookie &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HttpCookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ticket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                cookie.Value &lt;/span&gt;=&lt;span&gt; GlobalConfig.DefaultAutoLoginToken;
                HttpContext.Current.Response.AppendCookie(cookie);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有Ticket直接跳转到SSO进行检查&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!ApplicationContext.GetNodeIdByTicket(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; userId))
            {
                SSOLogin();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            Log.Debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_id={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, userId);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登陆到本地系统&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; result = ApplicationContext.UserLogin(userId, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result.Success)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception(result.Message);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SSOLogin()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; service =&lt;span&gt; HttpContext.Current.Request.Url.AbsoluteUri;
            service &lt;/span&gt;= Regex.Replace(service, &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\?ticket[^&amp;amp;]*.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;string&lt;/span&gt;.Concat(GlobalConfig.SSO_LoginURL, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?service=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, HttpContext.Current.Server.UrlEncode(service));
            HttpContext.Current.Response.Redirect(url);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里ApplicationContext.Current.IsLogined为True的话，就是用户已经登录过了，登录过了就返回，IsLogined属性里面是判断了用户信息是否存在。&lt;/p&gt;
&lt;p&gt;如果配置了自动登录，则装载自动登录的用户信息，从配置文件中读取。最后，上面判断都False的话，就跳到SSO系统去登录获取ticket。&lt;/p&gt;

&lt;p&gt;===================================华丽的分割线===========================&lt;/p&gt;

&lt;p&gt;下面就是SSO系统做的事情，SSO最基本的职责就是登录，首先就是登录界面。根据用户填写的账号密码判断用户是否注册，没有注册则注册。&lt;/p&gt;
&lt;p&gt;说白了就是登录注册流程。用户在SSO登录成功之后则创建Session保存用户账号，然后生成一个ticket字符串。每个团队对于Ticket字符串的内容&lt;/p&gt;
&lt;p&gt;都不太相同，但是大抵就是要请求界面的url，账户号，授权码这些。&lt;/p&gt;

&lt;p&gt;当然子系统判断URL中有ticket值的时候，就将Ticket 写入子项目的Session，其实我们会有一个UserInfo的基础对象，这个Userinfo是一个用户信息的model。&lt;/p&gt;
&lt;p&gt;这个是根据Ticket带过来用户账户再到数据库查了一次的。&lt;/p&gt;

&lt;p&gt;Jason重构一次SSO，方式上有点变动，更多的是采用Oauth2.0的方式。不清楚Oauth的可以看我上篇文章&lt;a href=&quot;http://www.cnblogs.com/demon28/p/8036873.html&quot; target=&quot;_blank&quot;&gt;《理解Oauth2.0》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里我公开一下我们SSO项目的源码，所以我就不一一的贴出来了。有兴趣的朋友可以自己看代码不懂的可以在QQ群里咨询。&lt;/p&gt;

&lt;p&gt;SSO登录中心GitHub下载地址：&lt;a href=&quot;https://github.com/demon28/OAuth2.git&quot; target=&quot;_blank&quot;&gt;https://github.com/demon28/OAuth2.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;就写到这里。有兴趣一起探讨Winner框架的可以加我们QQ群：261083244。或者扫描左侧二维码加群。&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 12:11:00 +0000</pubDate>
<dc:creator>Near_wen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/demon28/p/8058662.html</dc:identifier>
</item>
<item>
<title>TCP头部分析与确认号的理解 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8075623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8075623.html</guid>
<description>&lt;p&gt;&lt;span&gt;1、TCP的特点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于字节流&lt;br/&gt;面向连接&lt;br/&gt;可靠传输&lt;br/&gt;缓冲传输&lt;br/&gt;全双工&lt;br/&gt;流量控制&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、头部格式和说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图源百度。如下图示，就是TCP包的头部结构。可以看到这个头部最少有4x5=20个字节。&lt;/p&gt;
&lt;p&gt;另外还需要理解TCP协议是承载在IP协议中的。关于IP协议可以参考：http://www.cnblogs.com/xcywt/p/8067521.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220194113475-1709447191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源端口号和目的端口号：&lt;/span&gt;再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接&lt;br/&gt;&lt;span&gt;数据序号：&lt;/span&gt;表示在这个报文段中的第一个数据字节序号&lt;br/&gt;&lt;span&gt;确认序号：&lt;/span&gt;仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号（这个下面再详细分析）&lt;br/&gt;&lt;span&gt;偏移：&lt;/span&gt;就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节&lt;br/&gt;&lt;span&gt;保留位：&lt;/span&gt;6位，必须为0&lt;br/&gt;&lt;span&gt;6个标志位：&lt;/span&gt;&lt;br/&gt;URG-紧急指针有效&lt;br/&gt;ACK-确认序号有效&lt;br/&gt;PSH-接收方应尽快将这个报文交给应用层&lt;br/&gt;RST-连接重置&lt;br/&gt;SYN-同步序号用来发起一个连接&lt;br/&gt;FIN-终止一个连接&lt;/p&gt;
&lt;p&gt;&lt;span&gt;窗口字段：&lt;/span&gt;16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节（这个下面再详细分析）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;校验和：&lt;/span&gt;源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;紧急指针：&lt;/span&gt;是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式&lt;br/&gt;&lt;span&gt;选项与填充（必须为4字节整数倍，不够补0）：&lt;/span&gt;&lt;br/&gt;最常见的可选字段的最长报文大小MSS（Maximum Segment Size），每个连接方通常都在一个报文段中指明这个选项。它指明本端所能接收的最大长度的报文段。&lt;br/&gt;该选项如果不设置，默认为536（20+20+536=576字节的IP数据报）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、TCP如何保证可靠性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）应用数据被分割成TCP认为最合适发送的数据块。称为段（Segment）传递给IP层&lt;br/&gt;2）当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。若没有及时收到确认，将重新发送这个报文段&lt;br/&gt;3）当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送的，通常将推迟几分之一秒。&lt;br/&gt;4）TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文也不进行确认（对方就会重复发送了）。&lt;br/&gt;5）TCP承载与IP数据报来传输，而IP数据报可能会失序，所以TCP的报文段到达时也可能会失序。但是TCP收到数据后会重新排序到正确的顺序（通过序号）。&lt;br/&gt;6）IP数据报会发生重复，TCP的接收端必须丢弃重复是数据&lt;br/&gt;7）TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 4、滑动窗口协议（也就是对包头中&lt;strong&gt;&lt;span&gt;窗口字段&lt;/span&gt;&lt;/strong&gt;的理解）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参考1：https://www.cnblogs.com/ulihj/archive/2011/01/06/1927613.html&lt;/p&gt;
&lt;p&gt;参考2：http://blog.chinaunix.net/uid-26275986-id-4109679.html&lt;/p&gt;
&lt;p&gt;先上两个概念：&lt;br/&gt;通告接收窗口（rwnd）：预防应用程序发送的数据超过对方的缓冲区，接收方使用的流量控制。&lt;br/&gt;拥塞窗口（cwnd）：预防应用程序发送的数据超过了网络所能承载的能力。发送方使用的流量控制。&lt;br/&gt;&lt;span&gt;发送窗口：&lt;/span&gt;就是指上面两者的较小值&lt;/p&gt;
&lt;p&gt;由于TCP的全双工的，所以其实TCP双方各自都维护一个发送窗口和接收窗口。&lt;/p&gt;
&lt;p&gt;假设是主机A发送给主机B&lt;br/&gt;A和B都会维护一个数据帧的序列，这个序列称为窗口。发送方的窗口大小由接收方确定。目的在于控制发送速度。以免接收方的缓存不够大而导致溢出，同时流量控制也可以避免网络拥塞。&lt;br/&gt;这里其实是指A的发送窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220195413256-790689929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;假设A发送了很多段给B，序号是1-10.这些段会处于种状态：&lt;br/&gt;1）已发送，已确认&lt;br/&gt;2）已发送，未确认&lt;br/&gt;3）等待发送&lt;br/&gt;4）不允许发送&lt;/p&gt;
&lt;p&gt;正常情况下，每个段都会由4状态-&amp;gt;3状态-&amp;gt;2状态-&amp;gt;1状态。而窗口就是指处于状态2和状态3的总数。&lt;br/&gt;由2状态-&amp;gt;1状态的时候，窗口就会往后滑动一下，表示最近那个4状态的段可以变成3状态了。&lt;br/&gt;&lt;span&gt;如果接收方一直不确认，那么处于4状态的段将永远不会被发送。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当窗口满了的时候，4状态的段将不会变成3状态。从而达到了控制发送速度的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220195424131-1217959153.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就像上图一样，123处于1状态，456处于2状态，789处于3状态，10以后的处于4状态。而窗口就是指哪个框起来的。这里为6。&lt;/p&gt;
&lt;p&gt;随着发送段被逐一的确认，这个窗口会往右滑动。&lt;/p&gt;
&lt;p&gt;就像一个水池，总体积V，进水速度是s1，出水速度s2。当水池满了就不能再注入了，强行注入会溢出丢失。窗口就是那个水池。&lt;/p&gt;
&lt;p&gt;滑动窗口实现面向流的可靠性：&lt;/p&gt;
&lt;p&gt;1）最基本的传输可靠性来源于确认重传机制&lt;br/&gt;2）滑动窗口的可靠性也是建立在确认重传机制上的&lt;br/&gt;3）发送窗口只有收到目的端口对本段发送窗口内字节的ACK确认，才会移动发送串口的左边界。&lt;br/&gt;4）接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有段未收到确认，但是收到了后面段的情况下，窗口不会移动，也不对后续段进行确认。以此确保发送端会对这个数据重传。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、关于包头中确认号ack的理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 确认序号：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号&lt;/p&gt;
&lt;p&gt;这里是拿三次握手之后，开始传输数据了进行分析。&lt;/p&gt;
&lt;p&gt;服务器向客户端发送一个数据包后，客户端收到了这个数据包，会向服务器发送一个确认数据包。&lt;/p&gt;
&lt;p&gt;传输数据的简要过程如下：&lt;/p&gt;
&lt;p&gt;1）发送数据：服务器向客户端发送一个带有数据的数据包。该数据包中的序列号和确认号与建立连接第三步的数据包找那个的序列号和确认号相同。&lt;/p&gt;
&lt;p&gt;2）确认收到：客户端收到该数据包，向服务器发送一个确认数据包。该数据包中，序列号是为上一个数据包中的确认号值。&lt;/p&gt;
&lt;p&gt;而确认号为服务器发送的上一个数据包中的序列号+该数据包中所带数据的大小。&lt;/p&gt;
&lt;p&gt;回复确认收到的ack = 收到了序列号 + 数据的大小（同时也表示下一次期望收到的序号）&lt;/p&gt;
&lt;p&gt;这里我们直接拿Wireshark抓包进行分析：&lt;/p&gt;
&lt;p&gt;实例1：客户端给服务器发送了”xcychongyong” 共13个字节。&lt;/p&gt;
&lt;p&gt;先看，服务器收到的，也就是客户端发送的：seq是10，数据长度是13.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220200502693-252858890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看服务器发送给客户端的确认包：根据上面的说明。ack应该是10 + 13 = 23&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220200531162-619227875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例2：&lt;/p&gt;
&lt;p&gt;如下图，208（就是192.168.0.208）一共向182（就是192.168.0.182）发送了6组数据。&lt;/p&gt;
&lt;p&gt;过滤条件：tcp and (ip.src==192.168.0.182 or ip.dst==192.168.0.182)&lt;/p&gt;
&lt;p&gt;对于182来说：&lt;/p&gt;
&lt;p&gt;第一次回应时ack是4，结果208下一次发送的序号就是4。&lt;/p&gt;
&lt;p&gt;第二次回应时ack是10，结果208下一次发送的序号就是10。&lt;/p&gt;
&lt;p&gt;第三次回应时ack是19，结果208下一次发送的序号就是19。&lt;/p&gt;
&lt;p&gt;以此类推…&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220200639193-830189717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来分析一个互相发送的：&lt;/p&gt;
&lt;p&gt;如图，一共发送了5次：&lt;/p&gt;
&lt;p&gt;第一次182发给208，发的长度是7，seq是1.所以208回复的ack是8。也相当于告诉182：“182，你下次发的时候，序号就从8开始”。看第2个红框，seq就是8.&lt;/p&gt;
&lt;p&gt;第二次208发给182，发的长度是11，seq是1，所以182回复的ack是12。也相当于告诉208：“208，你下次发的时候，序号就从12开始”。看第2个绿框，seq就是12.&lt;/p&gt;
&lt;p&gt;同理，&lt;/p&gt;
&lt;p&gt;182再发送一次给208，seq应该是17  &lt;/p&gt;
&lt;p&gt;208再发送一次给182，seq应该是33&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171220200705850-519834105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ack表示期望下次接收到的序号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么ack是如何算出来的呢，就是通过收到的序号，和数据长度相加得来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设A收到B过来的数据（seq = 5，len = 15）。len表示数据长度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么A就会回复B，“刚才的数据我已经收到了，你接下来就发序号为20的包给我吧”。这样就保证了数据不会乱序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 综上，&lt;strong&gt;&lt;span&gt;确认号就是下一次将要收到包的序号。同时也等于发送方的序号+数据长度&lt;/span&gt;&lt;/strong&gt;（确认号在ACK标志位有效时才有用。)&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 12:11:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8075623.html</dc:identifier>
</item>
<item>
<title>42.Linux应用调试-初步制作系统调用(用户态-&gt;内核态) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8075282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8075282.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1首先来讲讲应用程序如何实现系统调用(用户态-&amp;gt;内核态)?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们以应用程序的&lt;span&gt;write()&lt;/span&gt;函数为例:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;首先用户态的&lt;span&gt;write()&lt;/span&gt;函数会进入&lt;span&gt;glibc&lt;/span&gt;库,里面会将write()转换为&lt;span&gt;swi&lt;/span&gt;（Software Interrupt）指令,从而产生软件中断,&lt;span&gt;swi指令&lt;/span&gt;如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
swi   #val   //val: bit[23:0]立即数,该val用来判断用户函数需要调用哪个内核函数
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt;然后CPU会跳到异常向量入口&lt;span&gt;vector_swi&lt;/span&gt;处,根据swi指令后面的val值,在某个数组表里找到对应的&lt;span&gt;sys_write()&lt;/span&gt;函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下所示(位于arch\arm\kernel\&lt;span&gt;entry-common.S&lt;/span&gt;):&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ENTRY(vector_swi)              
&lt;/span&gt;&lt;span&gt;           /*&lt;/span&gt;&lt;span&gt;保护用户态的现场&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;            
sub  sp, sp, #S_FRAME_SIZE
       stmia      sp, {r0 &lt;/span&gt;- r12}                 @ Calling r0 -&lt;span&gt; r12
       add r8, sp, #S_PC
       stmdb     r8, {sp, lr}&lt;/span&gt;^&lt;span&gt;                   @ Calling sp, lr
       mrs  r8, spsr                 @ called &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; non-&lt;span&gt;FIQ mode, so ok.
       str   lr, [sp, #S_PC]                @ Save calling PC
       str   r8, [sp, #S_PSR]             @ Save CPSR
       str   r0, [sp, #S_OLD_R0]              @ Save OLD_R0
       zero_fp
  ... ...

       ldr   scno, [lr, #&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;]                 @ &lt;span&gt;get&lt;/span&gt; SWI instruction  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取SWI值&lt;/span&gt;&lt;span&gt;
    A710(       and  ip, scno, #&lt;/span&gt;&lt;span&gt;0x0f000000&lt;/span&gt; @ check &lt;span&gt;for&lt;/span&gt;&lt;span&gt; SWI)
    A710(       teq  ip, #&lt;/span&gt;&lt;span&gt;0x0f000000&lt;/span&gt;)                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验SWI的bit[27:24]是否为0xf&lt;/span&gt;&lt;span&gt;
    A710(       bne  .Larm710bug)
     ... ...

       enable_irq                           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用enable_irq()函数&lt;/span&gt;&lt;span&gt;
       get_thread_info tsk
       adr  tbl, sys_call_table            @ load syscall table pointer  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tbl等于数组表基地址&lt;/span&gt;&lt;span&gt;
       ldr   ip, [tsk, #TI_FLAGS]          @ check &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; syscall tracing  
     ... ...

bic  scno, scno, #&lt;/span&gt;&lt;span&gt;0xff000000&lt;/span&gt;              @ mask off SWI op-code &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只保留SWI的bit[23:0],也就是val值&lt;/span&gt;&lt;span&gt;
eor  scno, scno, #__NR_SYSCALL_BASE @ check OS number    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于2440而讲,__NR_SYSCALL_BASE基地址等于0x900000,也就是说val值为0x900000时,异或后,则等于数组表的基地址(第一个函数位置)&lt;/span&gt;&lt;span&gt;
... ...

    ldrcc pc, [tbl, scno, lsl #&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;]             @ call sys_* routine          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;pc=(tbl+scno)&amp;lt;&amp;lt;2,实现调用sys_write()
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tbl:数组表基地址,  scno:要调用的索引值     lsl #2:左移2位,一个函数指针占据4个字节&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;从上面代码可以看出,2440的val基值为&lt;span&gt;0x900000&lt;/span&gt;,也就是说要调用数组表的第一个函数时,则使用:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
swi  #&lt;span&gt;0x900000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2 接下来,我们便来自制一个系统调用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt;在内核中,仿照一个&lt;span&gt;sys_hello&lt;/span&gt;函数,然后放入数组表,供swi调用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;写应用程序,直接通过swi指令,来调用sys_hello函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3 仿照sys_hello()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1先来查找数组表,以sys_write为例,搜索找到位于arch/arm/kernel/&lt;span&gt;calls.S&lt;/span&gt;,如下图所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201712/1182576-20171220181602193-611203391.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;span&gt;CALL定义&lt;/span&gt;如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
.equ NR_syscalls,&lt;span&gt;0&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将NR_syscalls=0&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; CALL(x) .equ NR_syscalls,NR_syscalls+1   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将CALL(x) 定义为：NR_syscalls=NR_syscalls+1 ,也就是每有一个CALL(),则该CALL值则+1&lt;/span&gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calls.S&lt;/span&gt;&lt;span&gt;&quot;              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将calls.S的内容包进来，CALL(x)上面已经有了定义,就会将calls.S里面的所有CALL(sys_xx)排列起来&lt;/span&gt;

&lt;span&gt;#undef&lt;/span&gt; CALL                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;撤销CALL定义&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; CALL(x) .long x        /&lt;span&gt;/&lt;/span&gt;&lt;span&gt;然后将排列起来的sys_xx以long(4字节)对齐,一个函数指针占据4字节&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 所以我们在&lt;span&gt;call.S&lt;/span&gt;文件的CALL()列表的最后添加一段, 如下图所示, sys_hello()的val值为&lt;span&gt;352&lt;/span&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201712/1182576-20171220181638193-411943052.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 fs\&lt;span&gt;read_write.c&lt;/span&gt;文件里写一个&lt;span&gt;sys_hello()&lt;/span&gt;函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
asmlinkage &lt;span&gt;void&lt;/span&gt; sys_hello(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user * buf, size_t count)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印count长数据&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ker_buf[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(buf)
    { copy_from_user(ker_buf, buf, (count&lt;/span&gt;&amp;lt;&lt;span&gt;100&lt;/span&gt;)? count : &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
      ker_buf[&lt;/span&gt;&lt;span&gt;99&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sys_hello:%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ker_buf);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4  include\linux\&lt;span&gt;syscalls.h&lt;/span&gt;文件里&lt;span&gt;声明&lt;/span&gt;sys_hello()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
asmlinkage &lt;span&gt;void&lt;/span&gt; sys_hello(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user * buf, size_t count);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.写应用程序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include &amp;lt;errno.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;
&lt;span&gt;#define&lt;/span&gt; __NR_SYSCALL_BASE       0x900000

&lt;span&gt;void&lt;/span&gt; hello(&lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
{&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; swi &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        asm (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mov r0, %0\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; save the argment in r0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;%0等于buf &lt;/span&gt;
             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mov r1, %1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; save the argment in r0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;%1等于count&lt;/span&gt;
             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;swi %2\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do the system call &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;%2等于0x900352&lt;/span&gt;
             :                                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出部&lt;/span&gt;
             : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;(buf), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;(count), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; (__NR_SYSCALL_BASE + &lt;span&gt;352&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入部&lt;/span&gt;
             : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);                     　　　　　　　　　　   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;损坏部,指原有的数据会被破坏&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;argv)
{
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;in app, call hello\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.100ask.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个函数会调用内核的sys_hello()&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1 其中asm ()是一个内嵌汇编(参考linux内核源代码情景分析1.5.2节)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;asm( &lt;span&gt;指令部&lt;/span&gt; : &lt;span&gt;输出部&lt;/span&gt; : &lt;span&gt;输入部&lt;/span&gt; : &lt;span&gt;损坏部&lt;/span&gt; );&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;指令部&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在指令部中,若出现&lt;span&gt;%0、%1、%2&lt;/span&gt;等,则表示指令部后面的第几个变量.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如上面代码的&quot;mov r0, %0\n&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;span&gt;%0&lt;/span&gt;便会对应&lt;span&gt;buf值&lt;/span&gt;,而&quot;r&quot;是一个&lt;span&gt;约束条件字母&lt;/span&gt;,r&lt;/span&gt;&lt;span&gt;表示任意一个寄存器,在预处理时,便会自动分配一个寄存器,将buf值放入该寄存器里,然后运行mov  r0  (buf对应的寄存器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;输出部&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个输出部的约束条件字母都要加上&lt;span&gt;&quot;=&quot;&lt;/span&gt;,比如:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; num=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,val;

asm(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mov %0,%1\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;(val)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定val是一个输出部,执行mov后,val便等于5&lt;/span&gt;&lt;span&gt;
    :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;(num)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;i&quot;约束条件字母,表示num是一个立即数&lt;/span&gt;&lt;span&gt;
    :      );                &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;输入部&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和输出部唯一不同的就是,在约束条件字母前不能加上&lt;span&gt;&quot;=&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用的&lt;span&gt;约束条件字母&lt;/span&gt;,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201712/1182576-20171220181652506-1744211193.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;170&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;损坏部&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和输入输出类似,一般用来处理操作的中间过程,因为这些原有的内容都会被损坏,比如上面的hello()里的&quot;r0&quot;, &quot;r1&quot;,只是用来当做参数,传递给内核的sys_hello()&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.重新烧写内核,试验应用程序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201712/1182576-20171220181702615-1286066810.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示,一个简单的系统调用便&lt;span&gt;OK&lt;/span&gt;了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下节便来学习,如何通过应用程序的系统调用来给需要调试的应用程序打断点,实现调试&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 10:35:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8075282.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（18）——前台页面与接口整合 - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/8032150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/8032150.html</guid>
<description>&lt;p&gt;　　由于我们前后台系统没有分开，所以前台页面调用接口时，可以直接使用后台管理系统已经完成的接口，不过后台管理系统接口的访问加上了登录验证，所以需要将前台要用到的接口进行处理，让它们设置到白名单当中&lt;/p&gt;
&lt;p&gt;　　我们打开main.py文件，在勾子函数中&lt;span&gt;@hook('before_request')&lt;/span&gt;中找到下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 过滤不用做任何操作的路由（即过滤不用进行判断是否登录和记录日志的url）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; path_info &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/favicon.ico&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/verify/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里前面已讲过，是跳过那些需要权限判断和进行日志记录的访问，对于后台上传的图片来说，我们不需要进行日志记录和权限判断，所以在这里添加上日志访问的路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 过滤不用做任何操作的路由（即过滤不用进行判断是否登录和记录日志的url）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; path_info &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/favicon.ico&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/verify/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;or&lt;/span&gt; path_info.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/upload/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;gt; -1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　path_info是当前客户端访问的url，通常url是固定的话，我们可以通过in的方式直接进行判断&lt;/p&gt;
&lt;p&gt;　　因为上传的图片统一存放在&lt;span&gt;/upload/&lt;/span&gt;这个目录中，而访问图片的路由是&lt;span&gt;/upload/xxxx/xxxxxxxxx.jpg&lt;/span&gt;，每张图片访问路径都不一样，新上传的图片就会生成新的链接，url是动态变化的，所以我们使用查找的方式来进行判断当前url是否是图片，如果是的话，则不执行下面的操作。&lt;/p&gt;

&lt;p&gt;　　同样在勾子函数&lt;span&gt;@hook('before_request')&lt;/span&gt;中找到下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 过滤不用进行登录权限判断的路由（登录与退出登录不用检查是否已经登录）&lt;/span&gt;
url_list = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/login/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/logout/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; path_info &lt;span&gt;in&lt;/span&gt; url_list&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了方便出现问题时及时排查，所以我们会将客户端对接口的访问，以及提交的参数记录到日志中，保存一段时间，所以我们会将一些访问频繁但对分析无关的接口添加到前面过滤处理中。&lt;/p&gt;
&lt;p&gt;　　因为对后台管理系统操作时，我们需要对用户权限进行验证，所以会在勾子中统一进行验证用户是否已经登录成功。但有一些接口我们是不必要进行验证的，比如登录和退出登录接口，如果它们不排除在外的话，那么用户将无法登录，因为每次访问登录接口都会返回你未登录不能访问，这样就会出现死循环，未登录不能访问接口，而不能访问接口则无法进行登录的怪圈当中，所以我们需要对一些无需登录就可以访问的接口进行例外处理。&lt;/p&gt;
&lt;p&gt;　　对于前台获取公司介绍、联系我们、产品分类、产品列表和产品信息的接口，我们可以将它们添加到这里来，进行过滤。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 过滤不用进行登录权限判断的路由（登录与退出登录不用检查是否已经登录）&lt;/span&gt;
url_list = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/login/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/logout/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/about/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/contact_us/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/product_class/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; path_info &lt;span&gt;in&lt;/span&gt; url_list &lt;span&gt;or&lt;/span&gt; (request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; path_info.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;gt; -1&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为我们使用的是RESTful风格的路由，获取产品信息、修改产品信息和删除产品信息路由url是一样的，只是通过&lt;span&gt;get/put/delete&lt;/span&gt;来进行区分，所以我们在处理时，需要获取客户端的提交方式是GET还是PUT或DELETE，然后进行区分处理。&lt;/p&gt;
&lt;p&gt;　　我们知道获取产品信息的接口路由是：&lt;span&gt;@get('/api/product/&amp;lt;id:int&amp;gt;/')&lt;/span&gt; ，它会根据产品id的不同而不同，所以我们可以通过&lt;span&gt;request.method == 'GET'&lt;/span&gt; 来判断当前访问提交的是&lt;span&gt;GET&lt;/span&gt;方式，而且访问的路径是&lt;span&gt;/api/product/&lt;/span&gt;时，我们就不做权限判断处理。&lt;/p&gt;

&lt;p&gt;　　点击&lt;span&gt;main.py&lt;/span&gt;运行&lt;span&gt;debug&lt;/span&gt;，然后在浏览器上输入：&lt;span&gt;http://127.0.0.1:81/api/about/&lt;/span&gt; 就可以看到已经可以取到数据了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171213141619926-653705427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　打开index.html页面代码，将公司介绍那部分html代码删掉，替换成下面加上id标签的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;about_img&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;150&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;about&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们在底部javascript脚本中添加下面ajax代码，就可以看到展示效果了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    //读取服务器记录
    $.ajax({
        url: &quot;/api/about/&quot;,
        type: &quot;GET&quot;,
        dataType: 'json',
        success: function (data) {
            $(&quot;#about_img&quot;).attr('src', data.data.front_cover_img);
            $(&quot;#about&quot;).text(data.data.content);
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171213154657410-1646498837.png&quot; alt=&quot;&quot; width=&quot;942&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　产品中心这里需要显示四个产品，所以我们先登录后台管理系统，在产品中心那里可以先录入好产品，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220152549428-1490716144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后打开index.html，找到显示产品的html代码，将它们全部删除，替换成下面内容，用来接收到服务器端记录以后，替换成对应的html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-body&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;height:460px&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;productsDiv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将代码拉到底部，在javascript中，添加下面代码，它会读取到产品信息以后，对html内容重新进行组合&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
        url: &lt;/span&gt;&quot;/api/product/?rows=4&amp;amp;page=1&quot;&lt;span&gt;,
        type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
        dataType: &lt;/span&gt;'json'&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.rows != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; data.rows.length &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data.rows) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 4&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; data.rows[i];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; html = ' &amp;lt;div style=&quot;float:left; padding-right:6px; padding-bottom:10px&quot;&amp;gt;&amp;lt;a href=&quot;/product_details.html?id=' + item.id + '&quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;img style=&quot;width:290px; height:200px&quot; src=' + item.front_cover_img + ' alt=&quot;...&quot; class=&quot;thumbnail&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;text-c&quot; style=&quot;padding-top:5px;&quot;&amp;gt;&amp;lt;strong&amp;gt;' + item.name + '&amp;lt;/strong&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;
                    $(&lt;/span&gt;&quot;#productsDiv&quot;&lt;span&gt;).append(html);
                }
            }
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　由于前后台合用一个接口，前台接口调用的产口列表是启用状态的，不显示禁用状态的，而后台需要获取所有产品，所以我们要对接口数据处理一下才行，在接口添加一个参数进行判断处理，是否是后台获取数据，前台默认返回启用状态数据&lt;/p&gt;
&lt;p&gt;　　在product.py中找到接口&lt;span&gt;@get('/api/product/')&lt;/span&gt;，添加下面处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否是前台提交获取数据&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; type != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;backstage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否已经存在查询条件了，是的话在原查询条件后面拼接&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; wheres:
            wheres &lt;/span&gt;= wheres + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; and is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            wheres &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;where is_enable=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在后台产品中心页面的html中，访问&lt;span&gt;/api/product/&lt;/span&gt;接口时，也添加上这个参数，大家在&lt;span&gt;products_list.html&lt;/span&gt;页面中查找&lt;span&gt;/api/product/&lt;/span&gt;，将它改为：&lt;span&gt;/api/product/?type=backstage&lt;/span&gt; 或&lt;span&gt; /api/product/?type=backstage&amp;amp;product_class_id=&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这样再刷新首页，就会出现下面效果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220160548678-1213756777.png&quot; alt=&quot;&quot; width=&quot;934&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　关于我们页面和联系我们页面比较简单，只需要将页面中间显示的内容删除，替换成&lt;span&gt;&amp;lt;span id=&quot;content&quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在页面底部的javascript中添加下面代码，效果就可以直接看到了。注：联系我们页面只需要将&lt;span&gt;/api/about/&lt;/span&gt;替换成&lt;span&gt;/api/contact_us/&lt;/span&gt;就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({
    url: &lt;/span&gt;&quot;/api/about/&quot;&lt;span&gt;,
    type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
    dataType: &lt;/span&gt;'json'&lt;span&gt;,
    success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        $(&lt;/span&gt;&quot;#content&quot;&lt;span&gt;).html(data.data.content);
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220161827021-1159280510.png&quot; alt=&quot;&quot; width=&quot;916&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220161838475-45831269.png&quot; alt=&quot;&quot; width=&quot;916&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　打开产品中心&lt;span&gt;products.html&lt;/span&gt;页面，这个页面有两个位置需要从服务器端读取数据的，一是分类列表，一是产品列表，需要写两个ajax。另外，用户从菜单栏或首页进来时，有可能没有带分类id，所以在写js时，需要进行专门的处理，没有id的，需要从分类列表的ajax中获取一个id，用作产品列表查询，具体大家直接看javascript代码就知道了&lt;/p&gt;
&lt;p&gt;　　首先将分类列表项删除，替换成&lt;span&gt;&amp;lt;ol class=&quot;linenums&quot; id=&quot;product_class&quot;&amp;gt;&amp;lt;/ol&amp;gt;&lt;/span&gt;，将产品列表全部html代码删除，替换成&lt;span&gt;&amp;lt;div class=&quot;panel-body&quot; id=&quot;products&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在页面底部的javascript中添加下面代码，效果就可以直接看到了。&lt;/p&gt;
&lt;p&gt;　　由于前后台合用一个接口，需要和产品列表接口做样的处理，区分前后台获取数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; id = getQueryString('id'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id != ''&lt;span&gt;){
        get_product_list(id);
    }

    $.ajax({
        url: &lt;/span&gt;&quot;/api/product_class/&quot;&lt;span&gt;,
        type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
        dataType: &lt;/span&gt;'json'&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.rows != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; data.rows.length &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data.rows) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; data.rows[i];
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id == ''&lt;span&gt;) {
                        id &lt;/span&gt;=&lt;span&gt; item.id;
                        get_product_list(id);
                    }
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; html = ' &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/products.html?id=' + item.id + '&quot;&amp;gt;' + item.name + '&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;'&lt;span&gt;;
                    $(&lt;/span&gt;&quot;#product_class&quot;&lt;span&gt;).append(html);
                }
            }
        }
    });

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; get_product_list(id) {
        $.ajax({
            url: &lt;/span&gt;&quot;/api/product/?product_class_id=&quot; +&lt;span&gt; id,
            type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
            dataType: &lt;/span&gt;'json'&lt;span&gt;,
            success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.rows != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; data.rows.length &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data.rows) {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; data.rows[i];
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; html = '&amp;lt;div style=&quot;float:left; padding-right:20px; padding-bottom:20px&quot;&amp;gt;&amp;lt;a href=&quot;/product_details.html?id=' + item.id + '&quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;img style=&quot;width:290px; height:200px&quot; src=&quot;' + item.front_cover_img + '&quot; alt=&quot;' + item.name + '&quot; class=&quot;thumbnail&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;text-c&quot; style=&quot;padding-top:5px;&quot;&amp;gt;&amp;lt;strong&amp;gt;' + item.name + '&amp;lt;/strong&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;'&lt;span&gt;
                        $(&lt;/span&gt;&quot;#products&quot;&lt;span&gt;).append(html);
                    }
                }
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取url中的参数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getQueryString(name) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = &lt;span&gt;new&lt;/span&gt; RegExp(&quot;(^|&amp;amp;)&quot; + name + &quot;=([^&amp;amp;]*)(&amp;amp;|$)&quot;, &quot;i&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r = window.location.search.substr(1&lt;span&gt;).match(reg);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; r[2&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220164234146-1790014623.png&quot; alt=&quot;&quot; width=&quot;919&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们打开产品详情页面product_details.html，从这个页面的原型就可以看到，它也有两个地方需要与服务器接口交互，一个是产品分类列表，这个同产品中心的代码一样，复制过来就可以了。另一个是产品信息的展示，需要通过ajax从服务器端获取指定的产品信息，然后再写入到页面中。&lt;/p&gt;
&lt;p&gt;　　我们可以先在后台编辑好一个产品内容，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220174146021-2000615073.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;491&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　将分类列表项删除，替换成&lt;span&gt;&amp;lt;ol class=&quot;linenums&quot; id=&quot;product_class&quot;&amp;gt;&amp;lt;/ol&amp;gt;&lt;/span&gt;，为产品图片加上id：&lt;span&gt;&amp;lt;img style=&quot;width:400px; height:300px&quot; src=&quot;&quot; alt=&quot;...&quot; class=&quot;thumbnail&quot; id=&quot;front_cover_img&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　删除产品信息展示内容，替换成：&lt;span&gt;&amp;lt;div style=&quot;float:left; font-size: 16px&quot; id=&quot;product_info&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　删除产品描述替换成：&lt;span&gt;&amp;lt;div class=&quot;panel-body&quot; id=&quot;content&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在页面底部的javascript中添加下面代码，效果就可以直接看到了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    $.ajax({
        url: &lt;/span&gt;&quot;/api/product_class/&quot;&lt;span&gt;,
        type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
        dataType: &lt;/span&gt;'json'&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.rows != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; data.rows.length &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data.rows) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; data.rows[i];
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; html = ' &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/products.html?id=' + item.id + '&quot;&amp;gt;' + item.name + '&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;'&lt;span&gt;;
                    $(&lt;/span&gt;&quot;#product_class&quot;&lt;span&gt;).append(html);
                }
            }
        }
    });
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = getQueryString('id'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id != ''&lt;span&gt;) {
        $.ajax({
            url: &lt;/span&gt;&quot;/api/product/&quot; + id + &quot;/&quot;&lt;span&gt;,
            type: &lt;/span&gt;&quot;GET&quot;&lt;span&gt;,
            dataType: &lt;/span&gt;'json'&lt;span&gt;,
            success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.state == 0&lt;span&gt;) {
                    $(&lt;/span&gt;&quot;#front_cover_img&quot;).attr('src'&lt;span&gt;, data.data.front_cover_img);
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; html = '产品名称：' + data.data.name + '&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;产品编号：' + data.data.code + '&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;产品规格：' + data.data.standard + '&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;保 质 期：' + data.data.quality_guarantee_period + '&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;产 地：' + data.data.place_of_origin + '&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;'&lt;span&gt;;
                    $(&lt;/span&gt;&quot;#product_info&quot;&lt;span&gt;).append(html);
                    $(&lt;/span&gt;&quot;#content&quot;&lt;span&gt;).append(data.data.content);
                }
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取url中的参数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getQueryString(name) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = &lt;span&gt;new&lt;/span&gt; RegExp(&quot;(^|&amp;amp;)&quot; + name + &quot;=([^&amp;amp;]*)(&amp;amp;|$)&quot;, &quot;i&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; r = window.location.search.substr(1&lt;span&gt;).match(reg);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; r[2&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;;
    }
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201712/129385-20171220180133803-2033333958.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;624&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到此，我们整个代码部分就全部完成了，接下来要做的就是服务器的部署工作了&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;&lt;a href=&quot;https://pan.baidu.com/s/1nvUn8vv&quot; target=&quot;_blank&quot;&gt;本文对应的源码下载&lt;/a&gt;（完整代码）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;版权声明：本文原创发表于 &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博客园&lt;/a&gt;，作者为 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/EmptyFS/&quot; target=&quot;_blank&quot;&gt;AllEmpty&lt;/a&gt; &lt;/strong&gt;本文欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。&lt;/p&gt;
&lt;p&gt;python开发QQ群：669058475    作者博客：http://www.cnblogs.com/EmptyFS/&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 10:06:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/8032150.html</dc:identifier>
</item>
</channel>
</rss>