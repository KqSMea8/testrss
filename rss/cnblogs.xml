<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java HashMap类源码解析(续)-TreeNode - GrayWind</title>
<link>http://www.cnblogs.com/graywind/p/9471756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/graywind/p/9471756.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　由于TreeNode本身是红黑树的实现，所以在分析TreeNode的之前我还是摸了一篇算法导论里红黑树的读书笔记：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;a title=&quot;算法导论——红黑树&quot; href=&quot;https://www.cnblogs.com/graywind/p/9468965.html&quot; target=&quot;_blank&quot;&gt;算法导论——红黑树&lt;/a&gt;&lt;/strong&gt;&lt;span&gt;，从伪代码行数也可以看出完整的红黑树的插入和删除操作代码是很长的，下面源码分析部分的行数就更多了，所以所谓手写红黑树画个图分析下逻辑还行，手写代码估计要写死(滑稽)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　TreeNode从JDK8开始引入，作用是当HashMap解决冲突的链表长度超过了8时，生成一个红黑树来加速查找和插入，这里树结构存在并不影响本身依然存在线性链表结构，意思是Node.next这个属性依然有效，所以说树替换了线性链表依然还是链表法解决冲突，只不过链表的实现策略换了。当结点因为移除或分裂操作少于6个时，消除树结构。虽然生产树之后能加快查找插入和删除，但是建立和消除树本身是存在消耗的，所以在两个临界值之间来回插入和删除会导致开销快速增加。HashMap的源码分析见：&lt;a title=&quot;Java HashMap类源码解析&quot; href=&quot;https://www.cnblogs.com/graywind/p/9457521.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;Java HashMap类源码解析&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　红黑树是基于二叉搜索树扩展而来，对于TreeNode来说排序的依据是结点的hash值，若相等然后比较key值，若key不能比较或是相等则根据hash值，左儿子的hash值小于等于父亲，右儿子的hash值大于父亲。TreeNode 保有红黑树的性质：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;每个结点都是红色的或者是黑色的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;根结点是黑色的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个叶结点NIL是黑色的，但是通常我们不考虑NIL叶结点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果一个结点是红色的，它的两个子结点都是黑色的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个结点到其他所有后代叶结点的简单路径上，均包含相同数目的黑色结点，这个属性被称为黑高，记作bh(x)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　先来看一下TreeNode扩展的内部属性&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        TreeNode&amp;lt;K,V&amp;gt; parent;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父亲结点&lt;/span&gt;
&lt;span&gt;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; left;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左儿子&lt;/span&gt;
&lt;span&gt;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; right;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右儿子&lt;/span&gt;
&lt;span&gt;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; prev;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前方结点&lt;/span&gt;

        &lt;span&gt;boolean&lt;/span&gt; red;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是红色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;根据他的构造函数向上追溯TreeNode&amp;lt;K,V&amp;gt;继承了LinkedHashMap.Entry&amp;lt;K,V&amp;gt;而后者又继承了HashMap.Node&amp;lt;K,V&amp;gt;。所以TreeNode依然保有Node的属性，同时由于添加了prev这个前驱指针使得链表变为了双向的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
    TreeNode(&lt;span&gt;int&lt;/span&gt; hash, K key, V val, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
       &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, val, next);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; HashMap.Node&amp;lt;K,V&amp;gt;&lt;span&gt; {
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; before, after;
        Entry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, value, next);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面这个方法可以返回根结点，实现很简单就是不断从一个结点检查parent是否为null&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Returns root of tree containing this node.返回根结点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root() {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; r = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, p;;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = r.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
                r &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不断检查parent是否为null，为null的是根结点&lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;moveRootToFront&lt;/span&gt;这个方法的作用是确保根结点被保存在了table数组上面，如果不是的话，就将root从链表中取出，将他放到数组对应的位置上，原本在数组上的结点链接到root的后面。这里最后调用了断言方法checkInvariants，作用是递归检查整棵树是否符合红黑树的性质，若检查不符会返回false导致moveRootToFront抛出错误。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_95d676b5-00dd-461b-9e47-30b3b461190f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_95d676b5-00dd-461b-9e47-30b3b461190f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_95d676b5-00dd-461b-9e47-30b3b461190f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Ensures that the given root is the first node of its bin.
         * 确保给出的根结点是箱中的第一个结点也就是直接位于table上，原本的第一个结点若不是root则将root从链表中剪下放到第一个结点的前方
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;void&lt;/span&gt; moveRootToFront(Node&amp;lt;K,V&amp;gt;[] tab, TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tab != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (n - 1) &amp;amp; root.hash;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据root的hash值快速定位下标&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; first = (TreeNode&amp;lt;K,V&amp;gt;)tab[index];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出table[index]中的第一个结点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (root != first) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;root不是第一个结点&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt;&lt;span&gt; rn;
                    tab[index] &lt;/span&gt;= root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;root放到table[index]位置&lt;/span&gt;
                    TreeNode&amp;lt;K,V&amp;gt; rp = root.prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rp=root的前一个结点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((rn = root.next) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rn=root的后一个结点&lt;/span&gt;
                        ((TreeNode&amp;lt;K,V&amp;gt;)rn).prev = rp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rn的前指针指向root的前一个结点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (rp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        rp.next &lt;/span&gt;= rn;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rp的后指针指向root的后一个结点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (first != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        first.prev &lt;/span&gt;= root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将原本的first放到root的后面&lt;/span&gt;
                    root.next =&lt;span&gt; first;
                    root.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; checkInvariants(root);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;assert后面的表达式为false时会抛出错误&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Recursive invariant check
         * 从root开始递归检查红黑树的性质，仅在检查root是否落在table上时调用
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;boolean&lt;/span&gt; checkInvariants(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; t) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; tp = t.parent, tl = t.left, tr =&lt;span&gt; t.right,
                tb &lt;/span&gt;= t.prev, tn = (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)t.next;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tb != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tb.next !=&lt;span&gt; t)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的前一个结点的后续应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tn != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tn.prev !=&lt;span&gt; t)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的后一个结点的前驱应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tp != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != tp.left &amp;amp;&amp;amp; t !=&lt;span&gt; tp.right)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t因为t父亲的左儿子或右儿子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (tl.parent != t || tl.hash &amp;gt;&lt;span&gt; t.hash))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的左儿子的hash值应小于t，父亲应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (tr.parent != t || tr.hash &amp;lt;&lt;span&gt; t.hash))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t的右儿子的hash值应大于t，父亲应为t&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (t.red &amp;amp;&amp;amp; tl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tl.red &amp;amp;&amp;amp; tr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; tr.red)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t和t的儿子不能同时是红色&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;checkInvariants(tl))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归检查t的左儿子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;checkInvariants(tr))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归检查t的右儿子&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;getTreeNode这个方法在HashMap中被多次使用，左右是寻找某个结点所在的树中是否有hash和key值符合的结点。我们可以看到这个方法一定会确保最后调用的是root.find()，也就是说find方法调用时this一定是根结点。所以无论最初调用getTreeNode的结点在树中处于什么位置，最后都会从根结点开始寻找，由于红黑树是相对平衡的二叉搜索树，所以可以认为搜索时间相比于链表从O(n)下降到了O(lgn)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_cdfcd925-bc65-40fa-a614-60b758b5279b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cdfcd925-bc65-40fa-a614-60b758b5279b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cdfcd925-bc65-40fa-a614-60b758b5279b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Calls find for root node.从根结点寻找h和k符合的结点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; getTreeNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h, Object k) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((parent != &lt;span&gt;null&lt;/span&gt;) ? root() : &lt;span&gt;this&lt;/span&gt;).find(h, k, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Finds the node starting at root p with the given hash and key.
         * The kc argument caches comparableClassFor(key) upon first use
         * comparing keys.
         * 从根结点p开始根据hash和key值寻找指定的结点。kc是key的class
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; find(&lt;span&gt;int&lt;/span&gt; h, Object k, Class&amp;lt;?&amp;gt;&lt;span&gt; kc) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;this&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法调用时this是根结点&lt;/span&gt;
            &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ph, dir; K pk;
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; pl = p.left, pr =&lt;span&gt; p.right, q;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt;&lt;span&gt; h)
                    p &lt;/span&gt;= pl;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;gt;参数hash时，移向左子树&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                    p &lt;/span&gt;= pr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;lt;参数hash时，移向右子树&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((pk = p.key) == k || (k != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k.equals(pk)))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash=参数hash，且p.key与参数key相等找到指定结点并返回&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pl == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若hash相等但key不等，向左右子树非空的一侧移动&lt;/span&gt;
                    p =&lt;span&gt; pr;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    p &lt;/span&gt;=&lt;span&gt; pl;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                          (kc &lt;/span&gt;= comparableClassFor(k)) != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;kc是否是一个可比较的类&lt;/span&gt;
                         (dir = compareComparables(kc, k, pk)) != 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较k和p.key&lt;/span&gt;
                    p = (dir &amp;lt; 0) ? pl : pr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k&amp;lt;p.key向左子树移动否则向右子树移动&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((q = pr.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里开始的条件仅当输入k=null的时候才会进入，先检查右子树再检查左子树&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; q;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    p &lt;/span&gt;=&lt;span&gt; pl;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面这个treeify就是根据链表生成树了，遍历链表获取结点，一个个插入到红黑树中，每次插入从根开始根据hash值寻找到叶结点位置进行插入，插入一个结点后调用一次balanceInsertion(root, x)检查x位置的红黑树性质是否需要修复。tieBreakOrder(k, pk)是在插入结点的key值k和父结点的key值pk无法比较出大小时，用于比较k和pk的hash值大小。关于红黑树性质的修复和保持稍后一起讨论。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_25877a15-cc2c-4596-a9d8-12c61b16868b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_25877a15-cc2c-4596-a9d8-12c61b16868b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_25877a15-cc2c-4596-a9d8-12c61b16868b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeify(Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; x = &lt;span&gt;this&lt;/span&gt;, next; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; next) {
                next &lt;/span&gt;= (TreeNode&amp;lt;K,V&amp;gt;)x.next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据链表进行遍历&lt;/span&gt;
                x.left = x.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根结点一定是黑色的&lt;/span&gt;
                    root =&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    K k &lt;/span&gt;=&lt;span&gt; x.key;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; x.hash;
                    Class&lt;/span&gt;&amp;lt;?&amp;gt; kc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; p =&lt;span&gt; root;;) {
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dir, ph;
                        K pk &lt;/span&gt;=&lt;span&gt; p.key;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt; h)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;gt;h则dir=-1，p.hash&amp;lt;h则dir=1&lt;/span&gt;
                            dir = -1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                            dir &lt;/span&gt;= 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                                  (kc &lt;/span&gt;= comparableClassFor(k)) == &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                                 (dir &lt;/span&gt;= compareComparables(kc, k, pk)) == 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k是不可比较的类或者k和p.key相等，kc==null这个条件只是为了给kc初始化&lt;/span&gt;
                            dir = tieBreakOrder(k, pk);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较k和p.k的hash值大小，k大dir=-1，p.key大则dir=1，pk是父亲的hash，k是要插入结点的hash&lt;/span&gt;
&lt;span&gt;
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; xp =&lt;span&gt; p;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = (dir &amp;lt;= 0) ? p.left : p.right) == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要插入的位置已没有子结点，则进行插入，否则沿着要插入的子树位置继续向下遍历&lt;/span&gt;
                            x.parent =&lt;span&gt; xp;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dir &amp;lt;= 0&lt;span&gt;)
                                xp.left &lt;/span&gt;= x;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的hash值小于等于p的hash值时尝试插入到左子树&lt;/span&gt;
                            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                xp.right &lt;/span&gt;= x;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的hash值大于p的hash值时尝试插入到右子树&lt;/span&gt;
                            root = balanceInsertion(root, x);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入后修复红黑树性质&lt;/span&gt;
                            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }
            }
            moveRootToFront(tab, root);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保当前的root是直接落在table数组上&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tieBreakOrder(Object a, Object b) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; d;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt; || b == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                (d &lt;/span&gt;=&lt;span&gt; a.getClass().getName().
                 compareTo(b.getClass().getName())) &lt;/span&gt;== 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a和b的class相同或者一方是null&lt;/span&gt;
                d = (System.identityHashCode(a) &amp;lt;= System.identityHashCode(b) ?
                     -1 : 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a的hashcode&amp;lt;=b的hashcode则返回-1，否则返回1，不能比较返回0&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;untreeify的作用就是把树转为链表，由于replacementNode这个方法会生成新的Node，所以产生的新链表不再具有树的信息了，原本的TreeNode被gc了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_73cca3d7-1204-4dcf-aca3-ce27dcf88eb8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_73cca3d7-1204-4dcf-aca3-ce27dcf88eb8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_73cca3d7-1204-4dcf-aca3-ce27dcf88eb8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; untreeify(HashMap&amp;lt;K,V&amp;gt;&lt;span&gt; map) {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; hd = &lt;span&gt;null&lt;/span&gt;, tl = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hd是头部，tl是尾部&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; q = &lt;span&gt;this&lt;/span&gt;; q != &lt;span&gt;null&lt;/span&gt;; q =&lt;span&gt; q.next) {
                Node&lt;/span&gt;&amp;lt;K,V&amp;gt; p = map.replacementNode(q, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据q产生一个新的结点，next=null，hash key value和q相等&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (tl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    hd &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个结点产生时头部指向它&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    tl.next &lt;/span&gt;=&lt;span&gt; p;
                tl &lt;/span&gt;=&lt;span&gt; p;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hd;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;拆分这个方法只有在resize的时候调用，可以对照线性链表扩展的情况，作用是把树拆成两棵，一棵放到新扩展出来的数组高位去，一棵留在原来的位置，划分的依据是扩展后新增的hash有效位是0还是1，拆分的时候会破坏树结构，所以先拆成两个链表再调用treeify来组装树。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_c0d0379c-1962-4b4e-b19f-764a492bdc9a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c0d0379c-1962-4b4e-b19f-764a492bdc9a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c0d0379c-1962-4b4e-b19f-764a492bdc9a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Splits nodes in a tree bin into lower and upper tree bins,
         * or untreeifies if now too small. Called only from resize;
         * see above discussion about split bits and indices.
         * 将树从给定的结点分裂成低位和高位的两棵树，若新树结点太少则转为线性链表。只有resize时会调用
         *
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map the map
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; tab the table for recording bin heads存储链表头的hash表
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index the index of the table being split需要分裂的表下标位置
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bit the bit of hash to split on分裂时分到高位和低位的依据参数，实际使用时输入的是扩展之前旧数组的大小
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; split(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt; index, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bit) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; b = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Relink into lo and hi lists, preserving order&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低位头尾指针&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高位头尾指针&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; lc = 0, hc = 0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低位和高位的结点个数统计&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; e = b, next; e != &lt;span&gt;null&lt;/span&gt;; e = next) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e从this开始遍历直到next为null&lt;/span&gt;
                next = (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)e.next;
                e.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段决定了该结点被分到低位还是高位，依据算式是e.hash mod bit，由于bit是扩展前数组的大小，所以一定是2的指数次幂，所以bit一定只有一个高位是1其余全是0
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个算式实际是判断e.hash新多出来的有效位是0还是1，若是0则分去低位树，是1则分去高位树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; bit) == 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.prev = loTail) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        loHead &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        loTail.next &lt;/span&gt;=&lt;span&gt; e;
                    loTail &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;++&lt;span&gt;lc;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.prev = hiTail) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        hiHead &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        hiTail.next &lt;/span&gt;=&lt;span&gt; e;
                    hiTail &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;++&lt;span&gt;hc;
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loHead != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lc &amp;lt;=&lt;span&gt; UNTREEIFY_THRESHOLD)
                    tab[index] &lt;/span&gt;= loHead.untreeify(map);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分裂后的低位树结点太少转为线性链表&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    tab[index] &lt;/span&gt;=&lt;span&gt; loHead;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiHead != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若高位树为null则代表整棵树全保留在了低位，树没有变化所以不用进行后面的treeify&lt;/span&gt;
&lt;span&gt;                        loHead.treeify(tab);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiHead != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段与上面对于低位部分的分析相对应&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (hc &amp;lt;=&lt;span&gt; UNTREEIFY_THRESHOLD)
                    tab[index &lt;/span&gt;+ bit] =&lt;span&gt; hiHead.untreeify(map);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    tab[index &lt;/span&gt;+ bit] = hiHead;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高位所处的位置为原本位置+旧数组的大小即bit&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (loHead != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        hiHead.treeify(tab);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;下面开始要进入插入和删除操作部分分析了，为了便于说明把之前那篇几张关键的图贴过来方便与代码进行对照&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;旋转&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如图所示是基本的左旋和右旋操作，这部分对着图看很容易理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813232303759-104544341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_4ba3b869-94bb-4c12-bab5-fc0ab1773bfb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4ba3b869-94bb-4c12-bab5-fc0ab1773bfb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4ba3b869-94bb-4c12-bab5-fc0ab1773bfb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左旋操作，见图中右向左，p是x，r是y&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateLeft(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                              TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; r, pp, rl;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (r = p.right) != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r是p的右儿子，也就是图中的y&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((rl = p.right = r.left) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r的左儿子β成为p的右儿子&lt;/span&gt;
                    rl.parent =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((pp = r.parent = p.parent) == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p的父亲成为r的父亲&lt;/span&gt;
                    (root = r).red = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是根结点,r的颜色改黑色&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pp.left == p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;r取代p原本的位置&lt;/span&gt;
                    pp.left =&lt;span&gt; r;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;=&lt;span&gt; r;
                r.left &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p成为r的右儿子&lt;/span&gt;
                p.parent =&lt;span&gt; r;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋操作，见图中左向右，p是y，l是x&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateRight(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                               TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; l, pp, lr;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (l = p.left) != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l是p的左儿子，即图中x&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((lr = p.left = l.right) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l的右儿子β成为p的左儿子&lt;/span&gt;
                    lr.parent =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((pp = l.parent = p.parent) == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p的父亲成为l的父亲&lt;/span&gt;
                    (root = l).red = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是根结点,l的颜色改黑色&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pp.right == p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l取代p原本的位置&lt;/span&gt;
                    pp.right =&lt;span&gt; l;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.left &lt;/span&gt;=&lt;span&gt; l;
                l.right &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p成为l的右儿子&lt;/span&gt;
                p.parent =&lt;span&gt; l;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;插入分为如图所示的3中情况，具体描述和处理方法见文章最前面的链接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813233323432-870010423.png&quot; alt=&quot;&quot;/&gt;情况1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813233441284-1121761199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插入操作涉及到两段很长的代码，首先是putTreeVal只要有h和k值符合的结点就不做插入，这里k必须是==或者equals才算是相等，返回找到的结点由调用的方法修改已有结点的value值，否则插入一个新结点并返回null。前面提到过，结点在树中的排序按照hash值大小，再按照key的大小，最后比较key计算Hash的大小进行排列，对应方法中的查找逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_8dd21e5e-44e1-40be-99bb-3f68d39d546a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8dd21e5e-44e1-40be-99bb-3f68d39d546a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8dd21e5e-44e1-40be-99bb-3f68d39d546a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;final&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; putTreeVal(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab,
                                       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h, K k, V v) {
            Class&lt;/span&gt;&amp;lt;?&amp;gt; kc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; searched = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; root = (parent != &lt;span&gt;null&lt;/span&gt;) ? root() : &lt;span&gt;this&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.parent为null代表已是根结点，否则通过root()获取根结点&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; p =&lt;span&gt; root;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dir, ph; K pk;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt; h)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash&amp;gt;h时dir=-1，p.hash&amp;lt;h时dir=1&lt;/span&gt;
                    dir = -1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                    dir &lt;/span&gt;= 1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((pk = p.key) == k || (k != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k.equals(pk)))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash=h且p.key与k相等时，已存在k值对应的结点则返回&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                          (kc &lt;/span&gt;= comparableClassFor(k)) == &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                         (dir &lt;/span&gt;= compareComparables(kc, k, pk)) == 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;/k是不可比较的类或者k和p.key通过compareTo比较相等&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;searched) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这部分只会在在k和p.key通过compareTo比较相等时执行一次，若未能在在左右子树中寻找到k==p.key或者k.equals(p.key)的情况则下次不会再进入&lt;/span&gt;
                        TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; q, ch;
                        searched &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((ch = p.left) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                             (q &lt;/span&gt;= ch.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                            ((ch &lt;/span&gt;= p.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                             (q &lt;/span&gt;= ch.find(h, k, kc)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;))
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; q;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从p的左子树或者右子树中找到符合条件的结点则返回&lt;/span&gt;
&lt;span&gt;                    }
                    dir &lt;/span&gt;= tieBreakOrder(k, pk);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较k和p.key的hash值大小，-1表示k&amp;lt;p.key&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p.hash=hash但是key值不相等且p的左右子树中也没有找到符合的结点&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; xp =&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = (dir &amp;lt;= 0) ? p.left : p.right) == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到了新增结点该插入的位置&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt; xpn = xp.next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表关系上的下一个结点&lt;/span&gt;
                    TreeNode&amp;lt;K,V&amp;gt; x = map.newTreeNode(h, k, v, xpn);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个结点，插入到p与它在链表上的下一个结点之间&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (dir &amp;lt;= 0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据dir大小把p的左儿子或者右儿子设为新增的结点&lt;/span&gt;
                        xp.left =&lt;span&gt; x;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        xp.right &lt;/span&gt;=&lt;span&gt; x;
                    xp.next &lt;/span&gt;=&lt;span&gt; x;
                    x.parent &lt;/span&gt;= x.prev =&lt;span&gt; xp;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpn != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        ((TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;)xpn).prev =&lt;span&gt; x;
                    moveRootToFront(tab, balanceInsertion(root, x));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入后进行红黑树的性质修复，并检查root是否是直接在table数组上&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; balanceInsertion是插入后用于维持红黑树性质的修复操作，这里涉及到了上面图中展示的3中情况不同的操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_dce82fd4-1716-4adf-b4c2-79d5196fc68b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dce82fd4-1716-4adf-b4c2-79d5196fc68b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dce82fd4-1716-4adf-b4c2-79d5196fc68b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceInsertion(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                                    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
            x.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入的结点设为红色&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; xp, xpp, xppl, xppr;;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((xp = x.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲为null代表x是根结点，x改黑色直接结束&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!xp.red || (xpp = xp.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若x的父结点为黑色或者x的父亲为根结点(实际上根应该是黑色)插入红色结点不影响红黑树性质&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (xp == (xppl = xpp.left)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若x的父亲为左儿子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((xppr = xpp.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xppr.red) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xppr为x的叔叔，且叔叔为红色，图中的情况1，x的叔叔和父亲改为红色，x的爷爷改为黑色，x指针上移到爷爷的位置&lt;/span&gt;
                        xppr.red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        x &lt;/span&gt;=&lt;span&gt; xpp;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; xp.right) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况2，x的叔叔是黑色且x是右儿子。对x上升至父亲后执行一次左旋&lt;/span&gt;
                            root = rotateLeft(root, x =&lt;span&gt; xp);
                            xpp &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.parent;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况3，x的叔叔是黑色且x是左儿子。x的父亲改黑色，x的爷爷改红色后对x的爷爷进行右旋&lt;/span&gt;
                            xp.red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xpp);
                            }
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为对称的操作&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (xppl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xppl.red) {
                        xppl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        x &lt;/span&gt;=&lt;span&gt; xpp;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; xp.left) {
                            root &lt;/span&gt;= rotateRight(root, x =&lt;span&gt; xp);
                            xpp &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.parent;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;最后是删除操作部分，删除操作需要寻找一个后驱结点来顶替原结点的位置，在结点无儿子时删除后不需做其他调整，结点只有一个儿子时那个儿子是后驱，否则右子树中的最小结点作为后驱。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_e1bfc1a3-eaae-474d-ab5c-5b82afb7d03e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1bfc1a3-eaae-474d-ab5c-5b82afb7d03e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1bfc1a3-eaae-474d-ab5c-5b82afb7d03e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Removes the given node, that must be present before this call.
         * This is messier than typical red-black deletion code because we
         * cannot swap the contents of an interior node with a leaf
         * successor that is pinned by &quot;next&quot; pointers that are accessible
         * independently during traversal. So instead we swap the tree
         * linkages. If the current tree appears to have too few nodes,
         * the bin is converted back to a plain bin. (The test triggers
         * somewhere between 2 and 6 nodes, depending on tree structure).
         * 移除给定的结点，这个方法相比一般的红黑树删除更加杂乱，因为我们无法交换内部结点的内容他们被next指针给限制了，这个指针是在遍历的时候独立的。
         * 因此我们交换树的连接。如果当前的树结点太少，需要转换为线性链表，通常这个值设定为2-6个结点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeTreeNode(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab,
                                  &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; movable) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (n - 1) &amp;amp; hash;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index = hash mod n&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; first = (TreeNode&amp;lt;K,V&amp;gt;)tab[index], root =&lt;span&gt; first, rl;
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; succ = (TreeNode&amp;lt;K,V&amp;gt;)next, pred = prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;succ指向要删除结点的后一个点，pred指向要删除结点的前一个&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                tab[index] &lt;/span&gt;= first = succ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若要删除的结点的前一个为空，则first和tab[index]都指向要删除结点的后一个结点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                pred.next &lt;/span&gt;= succ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若要删除结点的前驱非空，则前一个结点的next指针指向该结点的后驱&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (succ != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                succ.prev &lt;/span&gt;= pred;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后驱结点不为空时，后驱结点的前置指针设为删除结点的前置结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (first == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若删除的结点是树中的唯一结点则直接结束&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (root.parent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                root &lt;/span&gt;= root.root();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确保root指向根结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt; || root.right == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                (rl &lt;/span&gt;= root.left) == &lt;span&gt;null&lt;/span&gt; || rl.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                tab[index] &lt;/span&gt;= first.untreeify(map);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根自身或者左右儿子其中一个为空说明结点数过少（不超过2）转为线性表并结束&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;this&lt;/span&gt;, pl = left, pr = right, replacement;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向要删除的结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; pr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; s =&lt;span&gt; pr, sl;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((sl = s.left) != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除结点的左右儿子都不为空时，寻找右子树中最左的叶结点作为后继，s指向这个后继结点&lt;/span&gt;
                    s =&lt;span&gt; sl;
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; c = s.red; s.red = p.red; p.red = c; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换后继结点和要删除结点的颜色&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; sr =&lt;span&gt; s.right;
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; pp =&lt;span&gt; p.parent;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; pr) { 
                    p.parent &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p是s的直接右儿子，交换p和s的位置&lt;/span&gt;
                    s.right =&lt;span&gt; p;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sp =&lt;span&gt; s.parent;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p.parent = sp) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; sp.left)
                            sp.left &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p放到s原本的位置&lt;/span&gt;
                        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            sp.right &lt;/span&gt;=&lt;span&gt; p;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s.right = pr) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        pr.parent &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s放到p原本的位置&lt;/span&gt;
&lt;span&gt;                }
                p.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p.right = sr) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    sr.parent &lt;/span&gt;= p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s原本的右子树成为p的右子树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((s.left = pl) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    pl.parent &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s原本的左子树成为p的左子树&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((s.parent = pp) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    root &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p原本是根则新的根是s&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                    pp.left &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是某个结点的左儿子，则s成为该结点的左儿子&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;= s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p是某个结点的右儿子，则s成为该结点的右儿子&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (sr != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若s结点有右儿子（s一定没有左儿子），则replacement为这个右儿子否则为p&lt;/span&gt;
                    replacement =&lt;span&gt; sr;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    replacement &lt;/span&gt;=&lt;span&gt; p;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pl != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p的左右儿子有一方为null，则replacement为非空的一方，否则为p自己&lt;/span&gt;
                replacement =&lt;span&gt; pl;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                replacement &lt;/span&gt;=&lt;span&gt; pr;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                replacement &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (replacement != p) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p有儿子或者s有儿子&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; pp = replacement.parent =&lt;span&gt; p.parent;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pp == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用replacement来替换p&lt;/span&gt;
                    root =&lt;span&gt; replacement;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                    pp.left &lt;/span&gt;=&lt;span&gt; replacement;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;=&lt;span&gt; replacement;
                p.left &lt;/span&gt;= p.right = p.parent = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除p结点&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以replacement为中心，进行红黑树性质的修复，replacement可能为s的右儿子或者p的儿子或者p自己&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; r = p.red ?&lt;span&gt; root : balanceDeletion(root, replacement);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (replacement == p) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p没有儿子或者s没有儿子，直接移除p&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; pp =&lt;span&gt; p.parent;
                p.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                        pp.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.right)
                        pp.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (movable)
                moveRootToFront(tab, r);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整理根结点&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1242799/201808/1242799-20180813234611480-1909610969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样有删除和删除之后维持红黑树性质的修复操作，这里涉及到图中展示的4种不同情况的操作 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_c87bd9ec-cb5e-46d3-89f3-cda59b8ba105&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c87bd9ec-cb5e-46d3-89f3-cda59b8ba105&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c87bd9ec-cb5e-46d3-89f3-cda59b8ba105&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceDeletion(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                                   TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; xp, xpl, xpr;;)  {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; || x ==&lt;span&gt; root)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; root;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除结点为空或者删除的是根结点，直接返回&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((xp = x.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除后x成为根结点，x的颜色改为黑色&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (x.red) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将一个红色的结点提升到删除结点的位置不会改变黑高&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((xpl = xp.left) == x) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的父亲是左儿子&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; ((xpr = xp.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xpr.red) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况1，x的兄弟是红色的&lt;/span&gt;
                        xpr.red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xp);
                        xpr &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.right;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        x &lt;/span&gt;= xp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若x没有兄弟，x上升到父亲的位置&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sl = xpr.left, sr =&lt;span&gt; xpr.right;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sr == &lt;span&gt;null&lt;/span&gt; || !sr.red) &amp;amp;&amp;amp;&lt;span&gt;
                            (sl &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sl.red)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况2，x兄弟是黑色，他的两个儿子是黑色的&lt;/span&gt;
                            xpr.red = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            x &lt;/span&gt;=&lt;span&gt; xp;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sr == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sr.red) {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况3，x兄弟是黑色，他的右儿子是黑色，左儿子红色&lt;/span&gt;
                                &lt;span&gt;if&lt;/span&gt; (sl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                xpr.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xpr);
                                xpr &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ?
                                    &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.right;
                            }
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况4&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (xpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpr.red &lt;/span&gt;= (xp == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt; : xp.red;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sr = xpr.right) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xp);
                            }
                            x &lt;/span&gt;=&lt;span&gt; root;
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下为对称操作&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (xpl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xpl.red) {
                        xpl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xp);
                        xpl &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.left;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        x &lt;/span&gt;=&lt;span&gt; xp;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sl = xpl.left, sr =&lt;span&gt; xpl.right;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sl == &lt;span&gt;null&lt;/span&gt; || !sl.red) &amp;amp;&amp;amp;&lt;span&gt;
                            (sr &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sr.red)) {
                            xpl.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                            x &lt;/span&gt;=&lt;span&gt; xp;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sl == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sl.red) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                xpl.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xpl);
                                xpl &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ?
                                    &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.left;
                            }
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpl.red &lt;/span&gt;= (xp == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt; : xp.red;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sl = xpl.left) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    sl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xp);
                            }
                            x &lt;/span&gt;=&lt;span&gt; root;
                        }
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 13 Aug 2018 15:49:00 +0000</pubDate>
<dc:creator>GrayWind</dc:creator>
<og:description>由于TreeNode本身是红黑树的实现，所以在分析TreeNode的之前我还是摸了一篇算法导论里红黑树的读书笔记：算法导论——红黑树，从伪代码行数也可以看出完整的红黑树的插入和删除操作代码是很长的，下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/graywind/p/9471756.html</dc:identifier>
</item>
<item>
<title>JasperReport 中踩过的坑 - pengisgood</title>
<link>http://www.cnblogs.com/penghongwei/p/9471801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghongwei/p/9471801.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Mac Book Pro 10.13.6&lt;br/&gt;Jaspersoft Studio community version 6.6.9&lt;br/&gt;JDK 8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;安装 Jaspersoft Studio&lt;/h2&gt;
&lt;p&gt;Jasper Report 分为专业版（收费）和社区版（免费），如果只是用来设计一些 基本的报表模板，社区版就足够了。从&lt;a href=&quot;https://community.jaspersoft.com/community-download&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;可以下载，选择 Jaspersoft Studio。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;727&quot; data-height=&quot;572&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-f95ab54688f71192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-f95ab54688f71192.png&quot; data-original-width=&quot;727&quot; data-original-height=&quot;572&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;113226&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;jaspersoft-studio.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;安装时可能遇到的问题&lt;/h3&gt;
&lt;p&gt;如果在安装时一切顺利，那么可以直接跳过本小节。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;420&quot; data-height=&quot;174&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-a991e8042c40d2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/420&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-a991e8042c40d2d8.png&quot; data-original-width=&quot;420&quot; data-original-height=&quot;174&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;25470&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;install-jasper-studio.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果安装过程中遇到如上错误，可以尝试一下 解决办法：&lt;/p&gt;
&lt;p&gt;System Preferences -&amp;gt; Security &amp;amp; Privacy -&amp;gt; General&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;667&quot; data-height=&quot;572&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-ac9f2beccbb345d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/667&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-ac9f2beccbb345d2.png&quot; data-original-width=&quot;667&quot; data-original-height=&quot;572&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;69025&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;security-privacy.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果 Step 1 不能解决问题，打开 Terminal，执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;# sudo bash
&lt;span class=&quot;hljs-meta&quot;&gt;# xattr -cr &lt;span class=&quot;hljs-meta-string&quot;&gt;&quot;/Applications/TIBCO Jaspersoft Studio 6.6.0.app&quot;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你对这个 &lt;code&gt;xattr&lt;/code&gt; 感到好奇，可以执行 &lt;code&gt;man xattr&lt;/code&gt; 读一读解释。&lt;/p&gt;
&lt;h2&gt;理解 Report Band&lt;/h2&gt;
&lt;p&gt;Jasper Studio 内置了很多种 Band，不同的 Band 有不同的用途，也有些不同默认行为。除了 Background Band，其他的 Band 的总高度要小于或等于一页的最大高度减去顶部和底部的边距。&lt;/p&gt;
&lt;h3&gt;Title&lt;/h3&gt;
&lt;p&gt;默认只会出现在第一页的最顶部。也可以像下面这样控制它显示在单独的一页上。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;370&quot; data-height=&quot;341&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-4f50480b8b620139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/370&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-4f50480b8b620139.png&quot; data-original-width=&quot;370&quot; data-original-height=&quot;341&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;42995&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;title-on-new-page.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;Page Header&lt;/h3&gt;
&lt;p&gt;页眉默认会出现在每一页的顶部。当 Title 和 Summary Band 设置为显示在单独的一页上时，页眉则不会显示出来。&lt;/p&gt;
&lt;h3&gt;Detail&lt;/h3&gt;
&lt;p&gt;Detail Band 比较神奇，它能够自动的迭代 DataSource 中的所有元素，如果 DataSource 为 null，则只有静态文本会显示出来。默认情况下，Main Dataset 的 Query 有多少条记录，Detail Band 就会重复多少遍。&lt;/p&gt;
&lt;p&gt;更加详细一点的解释看&lt;a href=&quot;https://stackoverflow.com/questions/8388178/jasperreport-purpose-of-the-details-band&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Page Footer&lt;/h3&gt;
&lt;p&gt;页脚默认会出现在每一页的底部。&lt;/p&gt;
&lt;h3&gt;Last Page Footer&lt;/h3&gt;
&lt;p&gt;如果想在最后一页的页脚上放一些不同的内容，就可以考虑使用这个 Band。&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;默认会显示在报表的最后，和 Title Band 一样，也可以设置为显示在单独的一页上。如果是基于统计的报表，一般会放一些计算出来的内容，比如：最大值，最小值，平均值，总值等。当然，根据实际需要，也可以放任意内容。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;371&quot; data-height=&quot;299&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-7df3cf6d1ffe4d9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/371&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-7df3cf6d1ffe4d9f.png&quot; data-original-width=&quot;371&quot; data-original-height=&quot;299&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;39357&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;summary-on-new-page.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;顾名思义，这个一般就是放报表的背景的，比如水印之类的。它的最大高度可以和报表一页的高度相同。&lt;/p&gt;
&lt;h3&gt;其他的 Band&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Column Header&lt;/code&gt;, &lt;code&gt;Group Header&lt;/code&gt;, &lt;code&gt;Group Footer&lt;/code&gt;, &lt;code&gt;Column Footer&lt;/code&gt;, &lt;code&gt;No Data&lt;/code&gt; 这些 Band 根据名字也比较容易理解，具体的解释在这篇&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/understanding-bands&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;中讲解的比较详细。&lt;/p&gt;
&lt;h2&gt;全局设置&lt;/h2&gt;
&lt;p&gt;在页面的全局设置中可以设置页面的大小，边距，尺寸单位，页面方向等。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;570&quot; data-height=&quot;489&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-9848ae10f0b997a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/570&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-9848ae10f0b997a2.png&quot; data-original-width=&quot;570&quot; data-original-height=&quot;489&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;54727&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;page-format.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;一个小建议是，如果设计稿是什么计量单位，这里就设置成什么计量单位，然后把尺寸设置的和设计稿一样，避免在设计模板的时候做繁琐的尺寸换算。&lt;/p&gt;
&lt;p&gt;关于页面边距需要注意的一点是，即使将上下左右都设置为 0，最终导出 PDF 打印出来，边距也不见得是 0，因为打印机的设置中可能还会有默认的边距设置。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;540&quot; data-height=&quot;546&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-6406bff8c65f13bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-6406bff8c65f13bd.png&quot; data-original-width=&quot;540&quot; data-original-height=&quot;546&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;55717&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;printer-settings.png&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;页码&lt;/h2&gt;
&lt;p&gt;在报表中，几乎都会有显示页码的需求，比如 &lt;code&gt;Page x of y&lt;/code&gt; 这种。看似很简单，并且 Jasper Studio 中已经提供预设好的组件。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;725&quot; data-height=&quot;254&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-9b51e9c397a26a3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-9b51e9c397a26a3f.png&quot; data-original-width=&quot;725&quot; data-original-height=&quot;254&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;59329&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;page-x-of-y.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个内置的组件是通过两个 Text Field 实现的，如果对对齐的精度要求不高，直接使用这个组件也是挺方便的。其原理就是使用了两次 &lt;code&gt;$V{PAGE_NUMBER}&lt;/code&gt; 变量，只是设置不同的求值时机即可。对于每一页的页码设置 &lt;code&gt;Evaluation Time&lt;/code&gt; 为 &lt;code&gt;Now&lt;/code&gt;，对于总页码设置为 &lt;code&gt;Report&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是如果对精度要求非常高的话，这个方式就不太合适了，我们需要用一个 Text Field 来实现，具体的做法参考&lt;a href=&quot;https://communities.ca.com/blogs/rob.ensinger/2015/12/28/how-to-single-textbox-page-x-of-y-page-counts-in-jaspersoft-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;设置中英文为不同的字体（Font Set）&lt;/h2&gt;
&lt;p&gt;相信用 Word 软件进行过中英文排版的可能应对过这种需求，就是对一篇文章中的中英文需要设置不同 的字体，在 Word 中是有这个菜单项可以设置的，但是在 Jasper Report 中要实现这个需求就不那么简单了。&lt;/p&gt;
&lt;p&gt;主要涉及到下面这些步骤：&lt;/p&gt;
&lt;h3&gt;创建 Font Set&lt;/h3&gt;
&lt;p&gt;创建 &lt;code&gt;Font Extension&lt;/code&gt; 和 &lt;code&gt;Font Set&lt;/code&gt; 的步骤比较直观，参考&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/working-font-extensions&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;即可。&lt;/p&gt;
&lt;h3&gt;在 Java 代码中引用字体文件&lt;/h3&gt;
&lt;p&gt;如果服务器所在的系统中没有相应的字体，在 Jasper Report 尝试生成 PDF 的时候就会报错。需要以下几步来解决：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先需要从 Jasper Studio 中导出包含字体的 Jar 包，一次点击 &lt;code&gt;Window &amp;gt; Preferences &amp;gt; Jaspersoft Studio &amp;gt; Fonts&lt;/code&gt;，选中创建的 Font Set 和其包含的字体并点击 &lt;code&gt;Export&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在导出 Font 到 Jar 包的对话框中写上名称并保存。比如 &lt;code&gt;SampleFontSet.jar&lt;/code&gt;。这个 Jar 包和一般普通的 Jar 包不同，它包含了一些 Jaspersoft 需要的额外信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在代码依赖中引入字体 Jar 包。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1203&quot; data-height=&quot;616&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-4077729344d87225.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-4077729344d87225.png&quot; data-original-width=&quot;1203&quot; data-original-height=&quot;616&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;157957&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;jasper-font-set.png&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;将字体嵌入到 PDF 中&lt;/h3&gt;
&lt;p&gt;有人可能会怀疑将报表中用到的字体嵌入到导出的 PDF 中是否会带来性能问题，毕竟一般汉字的字体文件体积都比较大，大几十兆。在用 Japser 导出 PDF 的时候，只会嵌入用到的字体文件的子集，所以 几乎不用担心导出的 PDF 的体积。&lt;/p&gt;
&lt;h3&gt;测量 Text Field 的实际宽度（使用 Font Set ）&lt;/h3&gt;
&lt;p&gt;如果在 Text Field 上设置的字体是自定义的 Font Set，那么需要注意了，不是那么容易能够测量出真实的宽度。目前的解决办法是先分离出文本中的汉字字符和非汉字字符，然后分别设置成相应的字体，再各自测量出宽度，最后相加即为文本所占的实际宽度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分离汉字字符和非汉字字符&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static Pair&amp;lt;String, String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;splitHanAndOthers&lt;span class=&quot;hljs-params&quot;&gt;(String str) {
        StringBuilder hanToken = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();
        StringBuilder othersToken = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();

        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; str.length(); ) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;int codePoint = str.codePointAt(i);

            &lt;span class=&quot;hljs-keyword&quot;&gt;if (UnicodeScript.of(codePoint) == UnicodeScript.HAN) {
                hanToken.append(str.charAt(i));
            } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                othersToken.append(str.charAt(i));
            }
            i += Character.charCount(codePoint);
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;return Pair.of(hanToken.toString(), othersToken.toString());
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测量文本的实际宽度&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;float &lt;span class=&quot;hljs-title&quot;&gt;getWidth&lt;span class=&quot;hljs-params&quot;&gt;(JRPrintText jrPrintText, String text, String fontName) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final DefaultJasperReportsContext instance = DefaultJasperReportsContext.getInstance();

        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRDefaultStyleProvider defaultStyleProvider = jrPrintText.getDefaultStyleProvider();
        JRPrintText printText = &lt;span class=&quot;hljs-keyword&quot;&gt;new JRBasePrintText(defaultStyleProvider);
        printText.setText(text);
        printText.setFontName(fontName);
        printText.setFontSize(jrPrintText.getFontsize());

        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRStyledText hanTextFullStyledText = printText.getFullStyledText(JRStyledTextAttributeSelector.getAllSelector(instance));
        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRTextMeasurer measure = JRTextMeasurerUtil.getInstance(instance).createTextMeasurer(jrPrintText);
        &lt;span class=&quot;hljs-keyword&quot;&gt;final JRMeasuredText measuredText = measure.measure(hanTextFullStyledText, &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-keyword&quot;&gt;false);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return measuredText.getTextWidth();
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;计算总宽度&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;float &lt;span class=&quot;hljs-title&quot;&gt;getTotalWidth&lt;span class=&quot;hljs-params&quot;&gt;(JRPrintText jrPrintText, String text) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final Pair&amp;lt;String, String&amp;gt; hanAndOthers = splitHanAndOthers(text);
        &lt;span class=&quot;hljs-keyword&quot;&gt;final String han = hanAndOthers.getLeft();
        &lt;span class=&quot;hljs-keyword&quot;&gt;final String others = hanAndOthers.getRight();

        &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;float hanWidth = getWidth(jrPrintText, han, &lt;span class=&quot;hljs-string&quot;&gt;&quot;JianSong&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;float othersWidth = getWidth(jrPrintText, others, &lt;span class=&quot;hljs-string&quot;&gt;&quot;CorporateS&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return hanWidth + othersWidth;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Image&lt;/h2&gt;
&lt;h3&gt;显示图片&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;路径问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Jasper Studio 中添加一个 Image 组件，正确的设置一个图片的路径，点击预览就可以看到显示出来的图片了。但是细心的同学会发现在 &lt;code&gt;.jrxml&lt;/code&gt; 模板文件中图片的路径是一个绝对路径，这在实际生产过程中肯定是不行的。&lt;/p&gt;
&lt;p&gt;因此，通过搜索找出了一个方法，可以解决静态图片的路径问题。在 Image 组件的表达式中写上这样的表达式：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.getClass().getResourceAsStream(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/images/logo.png&quot;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1300&quot; data-height=&quot;360&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-9cff7be68f81bdf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-9cff7be68f81bdf3.png&quot; data-original-width=&quot;1300&quot; data-original-height=&quot;360&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;161896&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image-expression.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;还有几种其他的场景可能直接写&lt;a href=&quot;https://stackoverflow.com/questions/3623420/image-expression-url-in-jasper-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;相对路径&lt;/a&gt;也能工作，我没有验证过。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传参问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，Image 组件的表达式中不仅支持写图片的路径，也可以在代码中将图片读入内存然后直接以 InputStream 的形式传递，不过要确保每个 Stream 只能被消费一次，不要复用同一个 InputStream，如果想要复用，考虑使用 Image 组件的 &lt;code&gt;isUsingCache&lt;/code&gt; 属性。不过 Jasper 支持的类型除此之外，还有好几种：&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.lang&lt;span class=&quot;hljs-selector-class&quot;&gt;.String
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.io&lt;span class=&quot;hljs-selector-class&quot;&gt;.File
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.net&lt;span class=&quot;hljs-selector-class&quot;&gt;.URL
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.io&lt;span class=&quot;hljs-selector-class&quot;&gt;.InputStream
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;java&lt;span class=&quot;hljs-selector-class&quot;&gt;.awt&lt;span class=&quot;hljs-selector-class&quot;&gt;.Image
* &lt;span class=&quot;hljs-selector-tag&quot;&gt;net&lt;span class=&quot;hljs-selector-class&quot;&gt;.sf&lt;span class=&quot;hljs-selector-class&quot;&gt;.jasperreports&lt;span class=&quot;hljs-selector-class&quot;&gt;.engine&lt;span class=&quot;hljs-selector-class&quot;&gt;.JRRenderable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子可以参考&lt;a href=&quot;http://jasperreports.sourceforge.net/sample.reference/images/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这个&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;使用 InputStream 时可能遇到的问题&lt;/h3&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;net.sf.jasperreports.engine.JRException: java.io.IOException: The byte &lt;span class=&quot;hljs-built_in&quot;&gt;array is &lt;span class=&quot;hljs-keyword&quot;&gt;not a recognized imageformat.
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.processImageRetainShape(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1747)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.process(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1604)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.access$&lt;span class=&quot;hljs-number&quot;&gt;300(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1532)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportImage(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1472)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportElements(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1090)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportFrame(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;3117)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportElements(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1098)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportPage(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1053)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportReportToStream(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;917)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter.exportReport(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;537)
      at net.sf.jasperreports.engine.JasperExportManager.exportToPdfFile(JasperExportManager.java:&lt;span class=&quot;hljs-number&quot;&gt;155)
      at net.sf.jasperreports.engine.JasperExportManager.exportReportToPdfFile(JasperExportManager.java:&lt;span class=&quot;hljs-number&quot;&gt;503)
      at com.finger.hr.controllers.HRCreatePDFController$&lt;span class=&quot;hljs-number&quot;&gt;2.run(HRCreatePDFController.java:&lt;span class=&quot;hljs-number&quot;&gt;244)
Caused by: java.io.IOException: The byte &lt;span class=&quot;hljs-built_in&quot;&gt;array is &lt;span class=&quot;hljs-keyword&quot;&gt;not a recognized imageformat.
      at com.lowagie.text.Image.getInstance(Unknown Source)
      at net.sf.jasperreports.engine.&lt;span class=&quot;hljs-keyword&quot;&gt;export.JRPdfExporter$InternalImageProcessor.processImageRetainShape(JRPdfExporter.java:&lt;span class=&quot;hljs-number&quot;&gt;1742)
      ... &lt;span class=&quot;hljs-number&quot;&gt;12 more
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.experts-exchange.com/questions/28991458/Jasper-Reports-Image-error-java-io-IOException-The-byte-array-is-not-a-recognized-imageformat-in-a-bulk-pdf-creation.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;解决办法&lt;/a&gt;很奇特，到现在我也不知道为什么。&lt;/p&gt;
&lt;p&gt;如果传递的参数是一个独立的 InputStream 类型的字段，就会有上述错误。 解决办法就是把这个单独的 字段包到一个 Java 对象中（:D）。&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Getter
&lt;span class=&quot;hljs-meta&quot;&gt;@Setter
&lt;span class=&quot;hljs-meta&quot;&gt;@AllArgsConstructor
&lt;span class=&quot;hljs-meta&quot;&gt;@NoArgsConstructor
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;PhotoDto {
    &lt;span class=&quot;hljs-keyword&quot;&gt;private InputStream photo;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;List&lt;/h2&gt;
&lt;h3&gt;List 显示行号&lt;/h3&gt;
&lt;p&gt;不管是 List 还是 Table 如果只是想显示简单的行号，最简单的办法就是使用 &lt;a href=&quot;https://community.jaspersoft.com/questions/500238/display-row-numbers&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;$V{REPORT_COUNT}&lt;/code&gt;&lt;/a&gt;。 如果对行号还有一些比较复杂的计算逻辑，则最好在代码中处理好，然后作为数据的一个字段传递给 Jasper 直接渲染。&lt;/p&gt;
&lt;h3&gt;_THIS 大法&lt;/h3&gt;
&lt;p&gt;如果传递给 List 的（或者是 Table）数据是一个基本类型（这里姑且把 String 也看做基本类型，其实只要是不包含属性的对象都满足条件）的数据的集合，那么在引用单个数据的时候就得注意了，因为基本类型的数据不存在字段一说，所以需要在 Field 的命名上做点文章。&lt;/p&gt;
&lt;p&gt;比如说 dataSource 是 &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;，那么在定义 Field 的时候就没办引用对象的字段名了，这时候我们只需要将字段名定义为 &lt;code&gt;_THIS&lt;/code&gt; 即可，在引用的地方写 &lt;code&gt;$F{_THIS}&lt;/code&gt;。更多解释参考&lt;a href=&quot;https://community.jaspersoft.com/questions/1032486/detailed-explanation&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Table&lt;/h2&gt;
&lt;h3&gt;Dataset&lt;/h3&gt;
&lt;h3&gt;Table 嵌套中的坑&lt;/h3&gt;
&lt;p&gt;Table 中嵌套 Table 可以实现类似合并单元格的效果，但是如果最外层的 Table 中一行的高度超过了页面的最大高度就会直接报错，而不是分页。&lt;/p&gt;
&lt;h3&gt;Table 中实现分组效果&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Merge Cell？impossible！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Table 组件中不能直接做合并单元格的操作，只能通过嵌套 Table 来实现类似的效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Table Cell 中的负数缩进&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在使用 Jasper Studio 6.6.0 版的设计器的时候，在界面上设置坐标值的时候，会出现保存不成功的情况。只能通过直接修改模板源文件的方式设置负数坐标。感觉是 IDE 的 Bug，在后续版本应该修复了。&lt;/p&gt;
&lt;p&gt;设置 right indent 为负数的时候，left indent 不能为 0，如果为 0 right indent 不会生效 :( (至今不知道为什么 :boom:)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用 Table 组件的特性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有分组的需求，可以考虑使用 Table 的 Group Header 和 Group Footer 来显示组名和小计之类的数据。&lt;/p&gt;
&lt;h2&gt;Text Field &amp;amp; Static Text&lt;/h2&gt;
&lt;p&gt;关于 Strech，在设计器里有一个属性叫做 &lt;code&gt;Strech With Overflow&lt;/code&gt;，当这个属性被勾选后，表示当数据的长度超过组件的长度时会自动折行，相当于垂直方向上的 Overflow，而 Jasper 也不支持水平方向的 Overflow。&lt;/p&gt;
&lt;p&gt;在 Jasper 中可以很方便的设置一些特殊文本的显示格式，比如： 日期，时间，货币，数字，百分比等。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;403&quot; data-height=&quot;332&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-c0f08762040a5afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/403&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-c0f08762040a5afe.png&quot; data-original-width=&quot;403&quot; data-original-height=&quot;332&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;48837&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;pattern.png&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;SubReport&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Compile 问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Jasper Studio 的设计器里可以通过直接引用 &lt;code&gt;*.jasper&lt;/code&gt; 文件的方式，在主报表中引用子报表。但是如果在实际的产品代码中这样做，非常不利于对源码的版本控制，因为这个 &lt;code&gt;*.jasper&lt;/code&gt; 文件是一个经过编译之后的临时文件。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;663&quot; data-height=&quot;374&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-4acee209d1305044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/663&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-4acee209d1305044.png&quot; data-original-width=&quot;663&quot; data-original-height=&quot;374&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;71351&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;subreport-expression.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们在生产代码中可以先将子报表的模板预编译好，然后直接以参数的形式传递给主报表（例如如下代码将编译好的 “checklist.jrxml” 子报表作为参数传给主报表，然后在主报表中的引用表达式写成&lt;code&gt;$P{checklist}&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;String subreport = &lt;span class=&quot;hljs-string&quot;&gt;&quot;checklist&quot;;
    JasperReport jasperReport = &lt;span class=&quot;hljs-literal&quot;&gt;null;
    &lt;span class=&quot;hljs-keyword&quot;&gt;try (InputStream inputStream = getResourceAsStream(subreport + &lt;span class=&quot;hljs-string&quot;&gt;&quot;.jrxml&quot;)) {
        jasperReport = JasperCompileManager.compileReport(inputStream);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (IOException | JRException e) {
        e.printStackTrace();
    }
    params.put(subreport, jasperReport);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Detail Band 重复多次的问题&lt;/h2&gt;
&lt;p&gt;Detail Band 被渲染的次数是由 Main Dataset 中数据条数决定的，如果发现 Detail Band 被重复渲染了多次，那么请检查是否添加了 Main Dataset 的 Query，并且查询出来的数据不止一条。如果没有要设置 Main Dataset 的场景，可以选择 &lt;code&gt;One Empty Record&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;页面的多列排版&lt;/h2&gt;
&lt;p&gt;在页面设置中的多列设置，只对 Detail Band，Column Header，Column Footer 有影响。&lt;/p&gt;
&lt;h2&gt;HTML Markup 的限制&lt;/h2&gt;
&lt;p&gt;对于 HTML Markup 的使用，其实没有想象中的那么美好，使用起来功能比较有限。只能支持文本格式相关的标签和属性，不支持布局相关的标签。所以想通过 CSS 实现 一些效果，基本上都行不通。&lt;/p&gt;
&lt;p&gt;支持的 HTML 标签如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;b&lt;/li&gt;
&lt;li&gt;u&lt;/li&gt;
&lt;li&gt;i&lt;/li&gt;
&lt;li&gt;font&lt;/li&gt;
&lt;li&gt;sup&lt;/li&gt;
&lt;li&gt;sub&lt;/li&gt;
&lt;li&gt;li&lt;/li&gt;
&lt;li&gt;br&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个列表是从源码中 找出来的，并没有什么文档（也有可能是我没搜到）明确的列出来。 源码参考&lt;a href=&quot;https://github.com/TIBCOSoftware/jasperreports/blob/a044d33a54d93f45000d99c818ca23403a30e6be/jasperreports/src/net/sf/jasperreports/engine/JRCommonText.java#L71&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Position Type 设置为 Float 中的误区&lt;/h2&gt;
&lt;p&gt;一开始我不是特别理解这个 Float Position Type 的原理，走了很多弯路，经过很长时间的摸索才理解 Float Position Type 的用法。其实主要是因为 Jaser Studio 设计器中显示出来的样子容易误导使用的人。&lt;/p&gt;
&lt;p&gt;正常情况下，在设计模板的时候我们会把一些组件摆放的规规矩矩，整整齐齐的，看着都觉得舒服。Float 是相对于设计器里离它最近的元素漂移的，其相对位置在设计模板的阶段就决定好了。而有的组件在设计器里展示的形状比较大，如果要摆放整齐，需要 Float 的元素就会有比较大的相对距离出现。其实，这个时候我们不能相信我们眼睛看到的，也不能有强迫症，在设计器里。因为很多时候需要一些元素看上去是叠在一起的，渲染出来的效果反而是我们需要的。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;871&quot; data-height=&quot;438&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1943822-22db6aa1c0e3a578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1943822-22db6aa1c0e3a578.png&quot; data-original-width=&quot;871&quot; data-original-height=&quot;438&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;117983&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;position-type-float.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们在实际项目中有一个模板设计出来是这样的，是不是看着感觉很乱，但是要使用 Float 达到我们想要的效果，还必须要设计成这样。&lt;/p&gt;
&lt;h2&gt;时间的时区问题&lt;/h2&gt;
&lt;p&gt;解决报表中时区问题很简单，只需要给报表内置的一个变量传入相应的时区就行了。&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Map&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;String, &lt;span class=&quot;hljs-built_in&quot;&gt;Object&amp;gt; params = &lt;span class=&quot;hljs-keyword&quot;&gt;new HashMap&amp;lt;&amp;gt;();
params.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;REPORT_TIME_ZONE&quot;, TimeZone.getTimeZone(ZoneId.of(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Asia/Shanghai&quot;)));
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;通过代码定位元素坐标（终极大法）&lt;/h2&gt;
&lt;p&gt;如果在 Jasper Studio 中无法实现组件的动态定位，基本上也就只有这么一条路可以走了。如果这条路也实现不了，要么改需求，要么换掉 Jasper Report 解决方案。&lt;/p&gt;
&lt;h2&gt;参考链接&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v71/getting-started-jaspersoft-studio-0&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v71/getting-started-jaspersoft-studio-0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/understanding-bands&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/understanding-bands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/wiki/report-structure-jaspersoft-studio&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/wiki/report-structure-jaspersoft-studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://communities.ca.com/blogs/rob.ensinger/2015/12/28/how-to-single-textbox-page-x-of-y-page-counts-in-jaspersoft-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://communities.ca.com/blogs/rob.ensinger/2015/12/28/how-to-single-textbox-page-x-of-y-page-counts-in-jaspersoft-reports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10673263/show-page-x-of-y-using-a-single-text-field&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/10673263/show-page-x-of-y-using-a-single-text-field&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/working-font-extensions&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://community.jaspersoft.com/documentation/tibco-jaspersoft-studio-user-guide/v630/working-font-extensions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3623420/image-expression-url-in-jasper-reports&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/3623420/image-expression-url-in-jasper-reports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/27903072/print-liststring-each-element-in-new-field&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/27903072/print-liststring-each-element-in-new-field&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/11949333/passing-the-list-of-primitive-type-objects-as-datasource-for-subreport&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:44:00 +0000</pubDate>
<dc:creator>pengisgood</dc:creator>
<og:description>Mac Book Pro 10.13.6Jaspersoft Studio community version 6.6.9JDK 8 安装 Jaspersoft Studio Jasper Repor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghongwei/p/9471801.html</dc:identifier>
</item>
<item>
<title>SpringBoot简单打包部署(附工程) - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9471802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9471802.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要介绍SpringBoot的一些打包事项和项目部署以及在其中遇到一些问题的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;springboot打包&quot;&gt;SpringBoot打包&lt;/h2&gt;
&lt;p&gt;在SpringBoot打包这块，我们就用之前的一个web项目来进行打包。&lt;br/&gt;首先需要明确的是，该项目打包的形态是可执行的&lt;strong&gt;jar&lt;/strong&gt;包，还是在&lt;strong&gt;tomcat&lt;/strong&gt;下运行的&lt;strong&gt;war&lt;/strong&gt;包。&lt;br/&gt;虽然本项目是用&lt;strong&gt;maven&lt;/strong&gt;构建的，用&lt;strong&gt;maven&lt;/strong&gt;打包也更加方便，但是这里也说明普通非&lt;strong&gt;maven&lt;/strong&gt;打包的项目如何打包。&lt;/p&gt;
&lt;h3 id=&quot;maven打包&quot;&gt;Maven打包&lt;/h3&gt;
&lt;p&gt;首先是&lt;strong&gt;maven&lt;/strong&gt;方式打包:&lt;br/&gt;如果是&lt;strong&gt;jar&lt;/strong&gt;包&lt;br/&gt;需在&lt;code&gt;pom.xml&lt;/code&gt;指定打成的包为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是&lt;strong&gt;war&lt;/strong&gt;包。&lt;br/&gt;需在&lt;code&gt;pom.xml&lt;/code&gt;指定打成的包为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并通过&lt;code&gt;&amp;lt;scope&amp;gt;&lt;/code&gt;标签在打包的时候排除&lt;strong&gt;tomcat&lt;/strong&gt;依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后添加&lt;strong&gt;SpringBoot&lt;/strong&gt;自带的打包方式&lt;br/&gt;&lt;strong&gt;示例如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
        &amp;lt;defaultGoal&amp;gt;compile&amp;lt;/defaultGoal&amp;gt;
        &amp;lt;sourceDirectory&amp;gt;src&amp;lt;/sourceDirectory&amp;gt;
        &amp;lt;finalName&amp;gt;springboot-package&amp;lt;/finalName&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin &amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;fork&amp;gt;true&amp;lt;/fork&amp;gt;
                    &amp;lt;mainClass&amp;gt;com.pancm.App&amp;lt;/mainClass&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;code&gt;&amp;lt;finalName&amp;gt;&lt;/code&gt;标签是指定打包之后的名称，&lt;code&gt;&amp;lt;mainClass&amp;gt;&lt;/code&gt;是指定main函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也可以不用&lt;strong&gt;SpringBoot&lt;/strong&gt;自带的打包方式，使用&lt;strong&gt;maven&lt;/strong&gt;的&lt;strong&gt;assembly&lt;/strong&gt;插件进行打包。&lt;br/&gt;&lt;strong&gt;示例如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
          &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;2.5.5&amp;lt;/version&amp;gt;  
            &amp;lt;configuration&amp;gt;
                &amp;lt;archive&amp;gt;  
                    &amp;lt;manifest&amp;gt;  
                        &amp;lt;mainClass&amp;gt;com.pancm.App&amp;lt;/mainClass&amp;gt;  
                    &amp;lt;/manifest&amp;gt;  
                &amp;lt;/archive&amp;gt;  
                &amp;lt;descriptorRefs&amp;gt;  
                    &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;  
                &amp;lt;/descriptorRefs&amp;gt;  
            &amp;lt;/configuration&amp;gt;  
        &amp;lt;/plugin&amp;gt; 
       &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;pom.xml&lt;/strong&gt;中添加完相应的标签之后，我们只需在项目同级（pom.xml同级）输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可完成打包&lt;br/&gt;如果想排除测试代码，则可以输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean package  -Dmaven.test.skip=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来进行打包。&lt;/p&gt;
&lt;p&gt;一般我们是把&lt;strong&gt;application.properties&lt;/strong&gt;和&lt;strong&gt;logback.xml&lt;/strong&gt;文件放在resources文件夹中，但是进行打包之后，它们也会包含在&lt;strong&gt;jar&lt;/strong&gt;或&lt;strong&gt;war&lt;/strong&gt;包中，如果我们想更改配置，则会比较麻烦。&lt;br/&gt;如果想将它们和项目放在同级目录下，&lt;strong&gt;application.properties&lt;/strong&gt;可以直接移出和项目同级的目录下，因为Spring程序会按优先级从下面这些路径来加载&lt;strong&gt;application.properties&lt;/strong&gt;配置文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前目录下的/config目录&lt;/li&gt;
&lt;li&gt;当前目录&lt;/li&gt;
&lt;li&gt;classpath里的/config目录&lt;/li&gt;
&lt;li&gt;classpath 根目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;springboot&lt;/strong&gt;默认加载的&lt;strong&gt;logback&lt;/strong&gt;是在&lt;strong&gt;classpath&lt;/strong&gt;目录下，这时我们只需要在&lt;strong&gt;application.properties&lt;/strong&gt;配置文件指定&lt;strong&gt;logback.xml&lt;/strong&gt;的路径即可。&lt;br/&gt;添加如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;logging.config=logback.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果引入了第三方的&lt;strong&gt;jar&lt;/strong&gt;包，但是又无法通过&lt;strong&gt;maven&lt;/strong&gt;私服进行下载，这时可以手动进行编译。&lt;br/&gt;例如，我写了一个工具类为&lt;strong&gt;Mytools&lt;/strong&gt;，然后把它打成了一个&lt;strong&gt;jar&lt;/strong&gt;包，然后放在我的这个项目中&lt;strong&gt;lib&lt;/strong&gt;目录下，并且需要引用它，那么此时便可以对该&lt;strong&gt;jar&lt;/strong&gt;包进行编译到本地仓库中，然后再&lt;strong&gt;pom.xml&lt;/strong&gt;添加相应的名称和版本号。&lt;br/&gt;命令示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn install:install-file -Dfile=lib/pancmtools.jar -DgroupId=com.panncm.utils -DartifactId=pancm-utils -Dversion=1.0 -Dpackaging=jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.panncm.utils&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pancm-utils&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便可以进行打包了。&lt;/p&gt;
&lt;h3 id=&quot;普通项目打包&quot;&gt;普通项目打包&lt;/h3&gt;
&lt;p&gt;如果是普通的项目，没有使用&lt;strong&gt;maven&lt;/strong&gt;构建的话，可以使用&lt;strong&gt;eclipse&lt;/strong&gt;等工具进行打包。&lt;br/&gt;如果是&lt;strong&gt;jar&lt;/strong&gt;包&lt;br/&gt;首先在&lt;strong&gt;eclipse&lt;/strong&gt;中运行该项目(&lt;strong&gt;main&lt;/strong&gt;方法运行)，然后在&lt;strong&gt;eclipse&lt;/strong&gt;中右键项目 &lt;code&gt;export -&amp;gt;java -&amp;gt; runnable jar file-&amp;gt; package required libraries into generated jar&lt;/code&gt; 指定&lt;strong&gt;main&lt;/strong&gt;方法，然后选择打包的名称以及打包的路径。点击&lt;strong&gt;finish&lt;/strong&gt;完成打包。&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;war&lt;/strong&gt;包&lt;br/&gt;在&lt;strong&gt;eclipse&lt;/strong&gt;中右键项目 &lt;code&gt;export -&amp;gt;web -&amp;gt; war file&lt;/code&gt;，然后选择打包的名称以及打包的路径。点击&lt;strong&gt;finish&lt;/strong&gt;完成打包。&lt;/p&gt;
&lt;h3 id=&quot;ant打包&quot;&gt;Ant打包&lt;/h3&gt;
&lt;p&gt;介绍了上述两种打包之后，这里介绍下通过&lt;strong&gt;ant&lt;/strong&gt;方法进行打包(需要安装&lt;strong&gt;ant&lt;/strong&gt;环境，安装方式基本和maven一致，指定路径，配置环境变量，这里就不在过多讲述了)。&lt;br/&gt;一般打包之后，我们需要将包和配置文件放在一个目录下，这时我们又不想手动进行复制粘贴的话，就可以用&lt;strong&gt;ant&lt;/strong&gt;来进行打包，将打包的文件整合在一起。&lt;br/&gt;这里我们就编写一个&lt;strong&gt;build.xml&lt;/strong&gt;的配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project name=&quot;springboot-package&quot; default=&quot;copyAll&quot; basedir=&quot;.&quot;&amp;gt;
    &amp;lt;property name=&quot;build&quot; value=&quot;build&quot; /&amp;gt;
    &amp;lt;property name=&quot;target&quot; value=&quot;target&quot; /&amp;gt;
    &amp;lt;target name=&quot;clean&quot;&amp;gt;
        &amp;lt;delete dir=&quot;${target}&quot; /&amp;gt;
        &amp;lt;delete dir=&quot;${build}&quot; /&amp;gt;
    &amp;lt;/target&amp;gt;

    &amp;lt;target name=&quot;create-path&quot; depends=&quot;clean&quot;&amp;gt;
        &amp;lt;mkdir dir=&quot;${build}&quot; /&amp;gt;
    &amp;lt;/target&amp;gt;

    &amp;lt;target name=&quot;mvn_package&quot; depends=&quot;create-path&quot;&amp;gt;
        &amp;lt;exec executable=&quot;cmd&quot; failonerror=&quot;true&quot;&amp;gt;
            &amp;lt;arg line=&quot;/c mvn install:install-file -Dfile=lib/pancmtools.jar -DgroupId=com.panncm.utils -DartifactId=pancm-utils -Dversion=1.0 -Dpackaging=jar&quot; /&amp;gt;
        &amp;lt;/exec&amp;gt;
        &amp;lt;exec executable=&quot;cmd&quot; failonerror=&quot;true&quot;&amp;gt;
            &amp;lt;arg line=&quot;/c mvn clean package&quot; /&amp;gt;
        &amp;lt;/exec&amp;gt;
    &amp;lt;/target&amp;gt;

    &amp;lt;target name=&quot;copyAll&quot; depends=&quot;mvn_package&quot;&amp;gt;
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;${target}/springboot-package.jar&quot;&amp;gt;&amp;lt;/copy&amp;gt; 
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;logback.xml&quot;&amp;gt;&amp;lt;/copy&amp;gt;
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;application.properties&quot;&amp;gt;&amp;lt;/copy&amp;gt;
        &amp;lt;copy todir=&quot;${build}&quot; file=&quot;run.bat&quot;&amp;gt;&amp;lt;/copy&amp;gt;
    &amp;lt;/target&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;&amp;lt;mkdir dir=&quot;${build}&quot; /&amp;gt;&lt;/code&gt;是指定文件存放的文件夹，&lt;strong&gt;executable&lt;/strong&gt;是使用cmd命令，&lt;strong&gt;line&lt;/strong&gt;是执行的语句， 标签是将文件复制到指定的文件夹中。&lt;/p&gt;
&lt;p&gt;然后再新建一个 &lt;strong&gt;build.bat&lt;/strong&gt;文件，里面只需要填写 &lt;code&gt;ant&lt;/code&gt;就行了。&lt;br/&gt;准备完之后，只需双击&lt;strong&gt;build.bat&lt;/strong&gt;，项目和配置文件就自动到&lt;strong&gt;build&lt;/strong&gt;文件中了，省去了很多操作。&lt;/p&gt;
&lt;p&gt;虽然现在流行通过&lt;strong&gt;jenkins&lt;/strong&gt;进行打包部署，不过使用ant加maven进行打包也不错的，比较简单。&lt;/p&gt;
&lt;h2 id=&quot;springboot部署&quot;&gt;SpringBoot部署&lt;/h2&gt;
&lt;p&gt;如果是&lt;strong&gt;jar&lt;/strong&gt;项目&lt;br/&gt;&lt;strong&gt;Windows&lt;/strong&gt;系统在项目同级目录下输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java -jar springboot-package &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可启动项目。&lt;br/&gt;关闭项目，只需关掉&lt;strong&gt;dos&lt;/strong&gt;界面就可以了。&lt;br/&gt;也可以写一个&lt;strong&gt;bat&lt;/strong&gt;文件进行运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;系统在项目同级目录下输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup -jar springboot-package &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即可启动。&lt;br/&gt;关闭输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill -9 pid（jar的进程id）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在&lt;code&gt;init.d&lt;/code&gt;注册一个服务&lt;br/&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ln -s /home/jars/app/springboot-package.jar /etc/init.d/springboot-package
chmod +x /etc/init.d/springboot-package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service springboot-package start|stop|restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行启动或者停止。&lt;br/&gt;当然也可以编写&lt;strong&gt;xshell&lt;/strong&gt;脚本进行启动和关闭。&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;war&lt;/strong&gt;项目&lt;br/&gt;将&lt;strong&gt;war&lt;/strong&gt;放在&lt;strong&gt;tomcat/webapp&lt;/strong&gt;目录下，然后启动&lt;strong&gt;tomcat&lt;/strong&gt;就可以了。&lt;strong&gt;Windows&lt;/strong&gt;系统 在&lt;strong&gt;tomcat/bin&lt;/strong&gt;目录下双击&lt;strong&gt;startup.bat&lt;/strong&gt;即可启动，双击&lt;strong&gt;shutdown.bat&lt;/strong&gt;关闭。&lt;br/&gt;&lt;strong&gt;Linux&lt;/strong&gt;系统则在&lt;strong&gt;tomcat/bin&lt;/strong&gt; 目录下输入&lt;strong&gt;startup.sh&lt;/strong&gt;即可启动， 输入&lt;strong&gt;shutdown.sh&lt;/strong&gt;关闭。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;关于SpringBoot打包部署就讲解到这里了，如有不妥，欢迎指正！&lt;br/&gt;SpringBoot打包部署的项目工程地址:&lt;br/&gt;&lt;a href=&quot;https://github.com/xuwujing/springBoot-study/tree/master/springboot-package&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/springBoot-study/tree/master/springboot-package&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot整合系列:&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:43:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 本文主要介绍SpringBoot的一些打包事项和项目部署以及在其中遇到一些问题的解决方案。 SpringBoot打包 在SpringBoot打包这块，我们就用之前的一个web项目来进行打包。 首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9471802.html</dc:identifier>
</item>
<item>
<title>推荐BIG DATA Spark 的7本学习电子书籍（大牛专区） - 跨界大数据</title>
<link>http://www.cnblogs.com/coxiebig/p/9471794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coxiebig/p/9471794.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813215309854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本书于2017-03由Packt Publishing出版，作者Muhammad Asif Abbasi，全书356页。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;概述大数据分析及其对组织和数据专业人员的重要性&lt;/li&gt;
&lt;li&gt;深入了解Spark，了解它与现有处理平台的区别&lt;/li&gt;
&lt;li&gt;了解各种文件格式的复杂性，以及如何使用Apache Spark处理它们。&lt;/li&gt;
&lt;li&gt;实现如何使用YARN，MESOS或独立集群管理器部署Spark。&lt;/li&gt;
&lt;li&gt;了解Spark SQL，SchemaRDD，缓存以及使用Hive和Parquet文件格式的概念&lt;/li&gt;
&lt;li&gt;了解Spark MLLib的架构，同时讨论Spark附带的一些现成算法。&lt;/li&gt;
&lt;li&gt;介绍一下SparkR的部署和使用情况。&lt;/li&gt;
&lt;li&gt;了解图形计算和市场上可用的图形处理系统的重要性&lt;/li&gt;
&lt;li&gt;通过使用ALS使用Spark构建推荐引擎来检查Spark的真实示例。&lt;/li&gt;
&lt;li&gt;使用Telco数据集，使用随机森林预测客户流失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813225538640?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本书适合数据工程师，数据科学家以及那些想使用Spark的读者。阅读本书之前最好有Scala的编程基础。通过本书你将学到以下知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在AWS上使用各种集群管理器安装和配置Apache Spark&lt;/li&gt;
&lt;li&gt;为Apache Spark设置开发环境，包括Databricks Cloud笔记本&lt;/li&gt;
&lt;li&gt;了解如何使用模式在Spark中操作数据&lt;/li&gt;
&lt;li&gt;使用Spark Streaming和Structured Streaming掌握实时流分析&lt;/li&gt;
&lt;li&gt;使用MLlib掌握监督学习和无监督学习&lt;/li&gt;
&lt;li&gt;使用MLlib构建推荐引擎&lt;/li&gt;
&lt;li&gt;使用GraphX和GraphFrames库进行图形处理&lt;/li&gt;
&lt;li&gt;开发一组通用应用程序或项目类型，以及解决复杂大数据问题的解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解Spark流媒体是如何适应全局的&lt;/li&gt;
&lt;li&gt;学习核心概念，如Spark RDDs、Spark流集群和DStream的基础知识&lt;/li&gt;
&lt;li&gt;了解如何创建健壮的部署&lt;/li&gt;
&lt;li&gt;深入流算法&lt;/li&gt;
&lt;li&gt;学习如何调优，测量和监测火花流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231454407?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用不同的文件格式处理数据，例如XML、JSON、CSV和纯文本，使用Spark core库。&lt;/li&gt;
&lt;li&gt;使用Spark流媒体库对来自各种数据源的数据进行分析，例如Kafka和Flume&lt;/li&gt;
&lt;li&gt;学习使用各种SQL函数(包括Spark SQL库中的窗口函数)创建SQL模式和分析结构化数据&lt;/li&gt;
&lt;li&gt;在实现机器学习技术以解决实际问题的同时，探索Spark Mlib api&lt;/li&gt;
&lt;li&gt;了解Spark GraphX，这样您就可以了解使用Spark执行的各种基于图形的分析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231635592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过本书你将学到以下知识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解Scala面向对象和函数式编程的概念&lt;/li&gt;
&lt;li&gt;深入了解Scala集合api&lt;/li&gt;
&lt;li&gt;使用RDD和DataFrame学习Spark的核心抽象&lt;/li&gt;
&lt;li&gt;使用SparkSQL和GraphX分析结构化和非结构化数据&lt;/li&gt;
&lt;li&gt;使用Spark结构化流进行可伸缩的容错流应用程序开发&lt;/li&gt;
&lt;li&gt;学习机器学习的最佳实践，分类，回归，降维，和推荐系统，以建立预测模型与广泛使用的算法在Spark MLlib &amp;amp; ML&lt;br/&gt;构建集群模型来集群大量数据&lt;/li&gt;
&lt;li&gt;了解Spark应用程序的调优、调试和监视&lt;br/&gt;在独立集群、Mesos和YARN上部署Spark应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231820463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本书适合软件工程师、数据工程师、开发者以及Spark系统管理员的使用。通过本数你可以学到：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解如何使Spark作业运行速度更快；&lt;/li&gt;
&lt;li&gt;使用Spark探索数据；&lt;/li&gt;
&lt;li&gt;使用Spark处理更大的数据集；&lt;/li&gt;
&lt;li&gt;减少管道运行时间以获得更快的洞察力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813232017662?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;接触最新版本的Spark ML&lt;/li&gt;
&lt;li&gt;用Scala和Python创建您的第一个Spark程序&lt;/li&gt;
&lt;li&gt;在您自己的计算机上以及在Amazon EC2上为Spark设置和配置开发环境&lt;/li&gt;
&lt;li&gt;访问公共机器学习数据集并使用Spark加载、处理、清理和转换数据&lt;/li&gt;
&lt;li&gt;使用Spark机器学习库通过使用众所周知的机器学习模型来实现程序&lt;/li&gt;
&lt;li&gt;处理大规模的文本数据，包括特征提取和使用文本数据作为机器学习模型的输入&lt;/li&gt;
&lt;li&gt;编写Spark函数来评估机器学习模型的性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813232155292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1YWppZWp1bmVuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎订阅博客&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:42:00 +0000</pubDate>
<dc:creator>跨界大数据</dc:creator>
<og:description>目录 [toc] Lean Apache Spark 2 本书于2017 03由Packt Publishing出版，作者Muhammad Asif Abbasi，全书356页。 通过本书你将学到以下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coxiebig/p/9471794.html</dc:identifier>
</item>
<item>
<title>Vue 实例以及生命周期 - 沉江、小鱼</title>
<link>http://www.cnblogs.com/blog-cxj2017522/p/9471785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog-cxj2017522/p/9471785.html</guid>
<description>&lt;p class=&quot;title&quot;&gt;最简单的 Vue 实例&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;&lt;span&gt;
  {{message}}
&lt;/span&gt;&amp;lt;/div&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;javascript&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  data: {
    message: &lt;/span&gt;'Hello Vue!'&lt;span&gt;
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于 Vue 借鉴了 MVVM 的思想，这里的字符串 &quot;Hello Vue!&quot; 就相当于 Model，DOM 就相当于 View，Vue 实例 &quot;vm&quot; 则是起连接 Mode 和 View 作用的 ViewModel，因此我们才得以通过数据驱动视图，而不需要关心它是怎么实现的，因为 Vue 已经帮我们做好了一切。&lt;/p&gt;
&lt;p&gt;　　Vue 实例内置的属性和方法都是以 &quot;$&quot; 开头的，例如：vm.$data、vm.$el 等，另外选项并不等于实例，选项是通过 new Vue() 构造函数时传入的参数对象，但是实例可以从暴露的接口访问某些选项的值，例如：console.log(vm.$data.message) 输出 &quot;Hello Vue!&quot;。&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;title&quot;&gt;实例的生命周期&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;50.5&quot;&gt;
&lt;p&gt;　　在创建实例的过程中，Vue 提供了一些生命周期钩子函数，允许我们再某一特定阶段执行一些额外的操作：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;beforeCreate：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实例初始化之后，数据绑定之前会调用这个函数，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;javascript&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  data: {
    message: &lt;/span&gt;'Hello Vue!'&lt;span&gt;
  },
  beforeCreate: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefind&lt;/span&gt;
&lt;span&gt;  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要说明的有两点：1、这里的 &quot;this&quot; 指向 Vue 实例，即 &quot;vm&quot;，2、Vue 实例同时也代理了选项中 &quot;data&quot; 下的所有属性，也就是说 vm.message == vm.$data.message == &quot;Hello Vue!&quot;，但是因为在这个阶段数据并没有绑定到 Vun 实例上面，所以输出 &quot;undefind&quot;。在这之前数据会先保存在 vm.$options 中，如果要在这个阶段获取数据，可以先通过 vm.$options.data() 方法，返回 &quot;data&quot; 对象，通过 vm.$options.data().message 返回对应的值。&lt;/p&gt;
&lt;p&gt;在这个阶段可以做一些不需要数据的工作，比如说开启全局 loading 效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;created：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实例创建完成，数据绑定之后会调用这个函数，此时 console.log(this.message) 输出正确的值 &quot;Hello Vue!&quot;。&lt;/p&gt;
&lt;p&gt;在这个阶段，数据已经初始化为选项中的默认值，但是真实的数据还要通过 ajax 从后端数据库获取，因此这个阶段可以向后端发请求获取数据，然后绑定到对应属性上。&lt;/p&gt;
&lt;p&gt;之后判断选项中有无 &quot;el&quot; 属性(作为 Vue 实例的挂载目标，在这里就是 id 为 app 的 div 标签)，如果没有，则需要手动调用 vm.$mount(el) 方法指定挂载的目标；&lt;/p&gt;
&lt;p&gt;接着判断选项中有无 &quot;template&quot; 属性，如果没有，则直接使用 &quot;el&quot; 属性指定的挂载目标，如果有，那么就用 &quot;template&quot; 属性指定的字符串模板替换挂载目标，挂载目标中的所有内容将被忽略；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;beforeMount：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实例挂载之前调用。&lt;/p&gt;
&lt;p&gt;在这个阶段可以移除全局 loading 效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mounted：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实例挂载之后调用。&lt;/p&gt;
&lt;p&gt;在这个阶段页面已经加载完毕，可以对 DOM 进行操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;beforeUpdate：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在数据更新时调用。&lt;/p&gt;
&lt;p&gt;在这个阶段可以在数据更新前访问现有的 DOM。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;updated：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在数据更新之后调用。&lt;/p&gt;
&lt;p&gt;在这个阶段可以对更新后的 DOM 进行操作。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:39:00 +0000</pubDate>
<dc:creator>沉江、小鱼</dc:creator>
<og:description>最简单的 Vue 实例 //html &lt;div id=&quot;app&quot;&gt; {{message}} &lt;/div&gt; //javascript var vm = new</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog-cxj2017522/p/9471785.html</dc:identifier>
</item>
<item>
<title>julia环境安装——输出HelloWorld - 练涛</title>
<link>http://www.cnblogs.com/famine/p/9471741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/famine/p/9471741.html</guid>
<description>&lt;h2 id=&quot;julia环境安装&quot;&gt;julia环境安装&lt;/h2&gt;
&lt;p&gt;文章分为2步：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 下载安装&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 运行测试&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;下载安装&lt;/h2&gt;
&lt;p&gt;官网下载地址：&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;julia 1.0.0&lt;/a&gt;&lt;br/&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813225445305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTUzMTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;julia1.0.0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图中红色框内是Windows自解压版的 32 bit 和 64 bit版本&lt;/strong&gt; 根据需要自行下载即可。&lt;/p&gt;
&lt;p&gt;另外官网下载速度太慢，所以附上一个我下好的资源(win64版，百度网盘)：&lt;br/&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1tLzDK0QFzT8PE8OR7fzQwA&quot;&gt;网盘地址&lt;/a&gt; 密码: mrm4&lt;br/&gt;(失效请私信我!）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装方法：&lt;/strong&gt;运行.exe文件，一直下一步即可，大概需要一分钟。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;运行测试&quot;&gt;运行测试&lt;/h2&gt;
&lt;p&gt;接下来是运行测试：&lt;br/&gt;在解压好的文件下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231508316?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTUzMTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;win64&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行图中的快捷方式即可看见julia交互界面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是代码测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180813231312516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTUzMTg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;julia&quot;/&gt;&lt;/p&gt;
&lt;p&gt;END&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:25:00 +0000</pubDate>
<dc:creator>练涛</dc:creator>
<og:description>julia环境安装 文章分为2步： 1. 下载安装 2. 运行测试 下载安装 官网下载地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/famine/p/9471741.html</dc:identifier>
</item>
<item>
<title>Python网络编程（进程池、进程间的通信） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9471734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9471734.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;线程池的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       线程池是预先创建线程的一种技术。线程池在还没有任务到来之前，&lt;/p&gt;
&lt;p&gt;       创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态，&lt;/p&gt;
&lt;p&gt;       即均为启动，不消耗CPU，而只是占用较小的内存空间。当请求到来之后，&lt;/p&gt;
&lt;p&gt;       缓冲池给这次请求分配一个空闲线程，把请求传入此线程中运行，进行处理。&lt;/p&gt;
&lt;p&gt;       当预先创建的线程都处于运行状态，即预制线程不够，线程池可以自由创建一定数量的新线程，&lt;/p&gt;
&lt;p&gt;       用于处理更多的请求。当系统比较闲的时候，也可以通过移除一部分一直处于停用状态的线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程间的通信原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         OS提供了沟通的媒介供进程之间“对话”用。既然要沟通，如同人类社会的沟通一样，&lt;/p&gt;
&lt;p&gt;         沟通要付出时间和金钱，计算机中也一样，必然有沟通需要付出的成本。&lt;/p&gt;
&lt;p&gt;         出于所解决问题的特性，OS提供了多种沟通的方式，每种方式的沟通成本也不尽相同，&lt;/p&gt;
&lt;p&gt;         使用成本和沟通效率也有所不同。我们经常听到的 管道、消息队列、共享内存都是OS提供的供进程之间对话的方式。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Process（target， name， args， kwargs）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;name&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;       给&lt;strong&gt;进程&lt;/strong&gt;取&lt;strong&gt;名&lt;/strong&gt;字&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;默认&lt;/strong&gt;为&lt;strong&gt;Process-1&lt;/strong&gt;，Process-2..... &lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt; p.name&lt;/span&gt;&lt;/strong&gt; 查看进程名&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; args：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       以&lt;strong&gt;元组&lt;/strong&gt;的形式&lt;strong&gt;给target函数传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;kwargs：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       以&lt;strong&gt;字典&lt;/strong&gt;的形式&lt;strong&gt;给对应键的值传参&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程对象&lt;/strong&gt;的其他&lt;strong&gt;常用属性方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;p.name  p.start()   p.join()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    p.pid:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;获取&lt;/strong&gt;创建进程的&lt;strong&gt;pid&lt;/strong&gt;号&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; &lt;span&gt;p.is_alive():&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        判断进程是处于alive状态&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;p.daemon&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;        默认为Flase 如果&lt;strong&gt;设置为True&lt;/strong&gt; &lt;strong&gt;主进程结束&lt;/strong&gt;时&lt;strong&gt;杀死所有子进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;daemon属性&lt;strong&gt;一定要在start（）前设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;daemon&lt;strong&gt;为True &lt;/strong&gt;一般&lt;strong&gt;不需要加join（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;daemon不是真正意义上的守护进程&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt; 守护进程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;不受终端控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;后台自动运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;  生命周期长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多进程copy一个文件拆分为两个进行保存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取文件的大小&lt;/span&gt;
size = os.path.getsize(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./timg.jpeg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取文件的字节数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f = open(&quot;timg.jpeg&quot;,'rb')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;复制前半部分&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; copy1(img):
    f &lt;/span&gt;= open(img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二进制读取要复制的文件&lt;/span&gt;
    n = size // 2&lt;span&gt;
    fw &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.jpeg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二进制创建文件&lt;/span&gt;

    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 1024:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断文件大小是否大于1024字节 如果小于则直接读取写入&lt;/span&gt;
            data =&lt;span&gt; f.read(n)
            fw.write(data)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        data &lt;/span&gt;= f.read(1024)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 否则每次循环读取1024字节并写入&lt;/span&gt;
&lt;span&gt;        fw.write(data)
        n &lt;/span&gt;-= 1024&lt;span&gt;
    f.close()
    fw.close()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;复制后半部分&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; copy2(img):
    f &lt;/span&gt;= open(img,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取文件必须要每次读取 如果在父进程中打开文件流对像 &lt;/span&gt;
                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 子进程会通同时调用一个文件流对像 由于文件流对象特性会记录游标&lt;/span&gt;
                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如若先执行后半部复制这前半部会导致读取不到数据&lt;/span&gt;
    fw = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.jpeg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    f.seek(size &lt;/span&gt;// 2&lt;span&gt;,0)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        data &lt;/span&gt;= f.read(1024&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; 
        fw.write(data)
    fw.close()
    f.close()

p1 &lt;/span&gt;= Process(target = copy1,args = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timg.jpeg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建子进程并让子进程分别同时复制&lt;/span&gt;
p2 = Process(target = copy2,args = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timg.jpeg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
p1.start()
p2.start()
p1.join()
p2.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;strong/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;os.path.getsize&lt;/span&gt;('./1.txt')：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    读取文件大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1.如果&lt;strong&gt;多个子进程拷贝同一个&lt;/strong&gt;&lt;strong&gt;父进程的对象&lt;/strong&gt;则多个&lt;strong&gt;子进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;使用的是同一个对象&lt;/strong&gt;（如文件队形，套接字，队列，管道。。。）&lt;/p&gt;
&lt;p&gt;    2.如果在&lt;strong&gt;创建子进程后单独创建的对象&lt;/strong&gt;，则多个&lt;strong&gt;子进程各不相同&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;创建子自定义进程类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1.编写类&lt;strong&gt;继承&lt;span&gt;Process&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    2.在自定义类中&lt;strong&gt;加载父类&lt;span&gt;__init__&lt;/span&gt;以获取父类属性&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;      同时可以&lt;strong&gt;自定义新的属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    3&lt;strong&gt;.重写&lt;span&gt;run&lt;/span&gt;方法&lt;/strong&gt; 在调用start时自动执行该方法&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time 

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClockProcess(Process):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,value):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用父类init&lt;/span&gt;
        super().&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.value &lt;/span&gt;=&lt;span&gt; value 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重写run方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
            time.sleep(self.value)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The time is {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(time.ctime()))

p &lt;/span&gt;= ClockProcess(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自动执行run&lt;/span&gt;
&lt;span&gt;p.start()

p.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;进程的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    进程在&lt;strong&gt;创建和销毁&lt;/strong&gt;的过程中&lt;strong&gt;消耗&lt;/strong&gt;的&lt;strong&gt;资源&lt;/strong&gt;相对&lt;strong&gt;较多&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程池技术：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;产生原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        如果有大量的任务需要多进程完成，而调用周期比较短且需要频繁创建&lt;/p&gt;
&lt;p&gt;此时可能产生大量进程频繁创建销毁的情况  消耗计算机资源较大&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; 使用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        1.&lt;strong&gt;创建进程池&lt;/strong&gt;，&lt;strong&gt;在池内放入适当数量的进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;将事件封装成函数&lt;/strong&gt;。&lt;strong&gt;放入&lt;/strong&gt;到&lt;strong&gt;进程池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.事件不断运行，&lt;strong&gt;直到所有放入进程池事件运行完成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;&lt;span&gt;关闭&lt;/span&gt;进程池&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;回收&lt;/span&gt;进程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt; pool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; &lt;span&gt;pool&lt;/span&gt;（Process）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       功能：&lt;strong&gt;创建进程池对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       参数：进程数量&lt;/p&gt;
&lt;p&gt;       返回值：进程池对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    pool = pool（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;pool.&lt;span&gt;apply_async&lt;/span&gt;(fun, args, kwds)（异步执行）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       功能：&lt;strong&gt;将事件放入进程池内&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       参数：&lt;/p&gt;
&lt;p&gt;          &lt;strong&gt;fun&lt;/strong&gt;：要执行的&lt;strong&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;args&lt;/strong&gt;：以&lt;strong&gt;元组&lt;/strong&gt;形式为fun&lt;strong&gt;传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;kwds&lt;/strong&gt;：以&lt;strong&gt;字典&lt;/strong&gt;形式为fun&lt;strong&gt;传参&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       返回值：&lt;/p&gt;
&lt;p&gt;          返回一个事件对象，通过p.&lt;strong&gt;&lt;span&gt;get（）&lt;/span&gt;&lt;/strong&gt;函数可以获取fun的返回值&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;pool.close():&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;关闭进程池&lt;/strong&gt;，无法再加入新的事件，并等待已有事件结束执行&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;pool.join()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：&lt;strong&gt;回收进程池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;pool.&lt;span&gt;apply&lt;/span&gt;(fun, args, kwds)&lt;/strong&gt;（同步执行）&lt;/p&gt;
&lt;p&gt;       功能：将事件放入进程池内&lt;/p&gt;
&lt;p&gt;       参数：&lt;/p&gt;
&lt;p&gt;          fun：要执行的函数&lt;/p&gt;
&lt;p&gt;  args：以元组形式为fun传参&lt;/p&gt;
&lt;p&gt;  kwds：以字典形式为fun传参&lt;/p&gt;
&lt;p&gt;       没有返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sleep,ctime 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; worker(msg):
    sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ctime()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建进程池对象&lt;/span&gt;
pool = Pool(processes = 4&lt;span&gt;)

result &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;i 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将事件放入进程池&lt;/span&gt;
    r = pool.apply_async(func = worker,args =&lt;span&gt; (msg,))
    result.append(r)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;同步执行&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pool.apply(func = worker,args = (msg,))&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭进程池&lt;/span&gt;
&lt;span&gt;pool.close()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;回收&lt;/span&gt;
&lt;span&gt;pool.join()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取事件函数返回值&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i.get())
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;    &lt;strong&gt;pool.&lt;span&gt;map&lt;/span&gt;（func， iter）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;将&lt;/strong&gt;要执行的&lt;strong&gt;事件放入进程池&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;func&lt;/strong&gt;  要执行的&lt;strong&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;iter&lt;/strong&gt;  &lt;strong&gt;可迭代对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(n):
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行 pool map事件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n ** 2&lt;span&gt; 

pool &lt;/span&gt;= Pool(4&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在进程池放入6个事件&lt;/span&gt;
r = pool.map(fun,range(6))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; map高阶函数 fun和iter执行6次&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;返回值列表:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,r)

pool.close()
pool.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;strong/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程间的通信（&lt;span&gt;IPC&lt;/span&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;由于&lt;/strong&gt;进程&lt;strong&gt;空间独立&lt;/strong&gt;，&lt;strong&gt;资源无法共享，&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;    此时在&lt;strong&gt;进程间通讯&lt;/strong&gt;就&lt;strong&gt;需要专门的通讯方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;通信方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       管道、消息队列、共享内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       信号、信号量、套接字&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;       管道通信：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;           在内存中&lt;strong&gt;开辟一块内存空间&lt;/strong&gt;，&lt;strong&gt;形成管道结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;多个进程使用同一个管道&lt;/strong&gt;，即可通过&lt;strong&gt;对管道&lt;/strong&gt;的&lt;strong&gt;读写操作进行通讯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; multiprocessing --&amp;gt;&lt;span&gt; Pipe&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   fd1，fd2 = Pipe(duplex=True)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       功能：&lt;strong&gt;创建管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       参数：&lt;/p&gt;
&lt;p&gt;           默认表示&lt;strong&gt;双向管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   如果设置为&lt;strong&gt;False&lt;/strong&gt;则为&lt;strong&gt;单向管道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       返回值：&lt;/p&gt;
&lt;p&gt;           俩个管道对象的，分别表示管道的两端&lt;/p&gt;
&lt;p&gt;   如果是&lt;strong&gt;双向管道则均可读写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   如果是&lt;strong&gt;单向管道&lt;/strong&gt;则&lt;strong&gt;fd1只读&lt;/strong&gt;，&lt;strong&gt;fd2只写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; fd.&lt;span&gt;recv&lt;/span&gt;（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：从管道&lt;strong&gt;读取信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回值：读取到的内容&lt;/p&gt;
&lt;p&gt;   当&lt;strong&gt;管道为空则阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;fd.&lt;span&gt;send&lt;/span&gt;（data）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：&lt;strong&gt;向管道写入内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数：要写入的内容&lt;/p&gt;
&lt;p&gt;   当&lt;strong&gt;管道满时会阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;可&lt;/strong&gt;以&lt;strong&gt;写入&lt;/strong&gt;几乎所有&lt;strong&gt;Python所有数据类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队列通信：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   在&lt;strong&gt;内存&lt;/strong&gt;中&lt;strong&gt;开辟队列结构空间&lt;/strong&gt;，多个进程可见，&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;多个进程操作同一个队列&lt;/strong&gt;对象可以&lt;strong&gt;实现消息存取工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   在取出时&lt;strong&gt;必须&lt;/strong&gt;按照存入&lt;strong&gt;顺序取出&lt;/strong&gt;（&lt;strong&gt;先进先出&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; q = &lt;span&gt;Queue&lt;/span&gt;（maxsize=0）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     功能：&lt;/p&gt;
&lt;p&gt; 创建队列对象&lt;/p&gt;
&lt;p&gt;     参数：&lt;/p&gt;
&lt;p&gt;         &lt;strong&gt;maxsize &lt;/strong&gt;默认表示根据系统分配空间&lt;strong&gt;储存消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如果&lt;strong&gt;传入一个正整数&lt;/strong&gt;则&lt;strong&gt;表示&lt;/strong&gt;最多&lt;strong&gt;存放多少条消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     返回值：队列对象&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;q.&lt;span&gt;put&lt;/span&gt;（data,[block,timeout]）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      功能：向队列&lt;strong&gt;存入消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      参数：&lt;/p&gt;
&lt;p&gt;          data：存入消息（&lt;strong&gt;支持Python数据类型&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;  block：默认&lt;strong&gt;True&lt;/strong&gt;表示当队&lt;strong&gt;满时阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         设置为&lt;strong&gt;False&lt;/strong&gt; 则为&lt;strong&gt;非阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  timeout：当&lt;strong&gt;block为True&lt;/strong&gt;是表示&lt;strong&gt;超时检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;data = q.&lt;span&gt;get&lt;/span&gt;([block,timeout])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       功能：取出消息&lt;/p&gt;
&lt;p&gt;       参数：&lt;/p&gt;
&lt;p&gt;            block：设置为&lt;strong&gt;True&lt;/strong&gt; 当队列为&lt;strong&gt;空时阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;           设置为&lt;strong&gt;False&lt;/strong&gt;表示&lt;strong&gt;非阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    timeout：&lt;/p&gt;
&lt;p&gt;         当&lt;strong&gt;block为True&lt;/strong&gt;是表示&lt;strong&gt;超时检测&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;  q.&lt;span&gt;full&lt;/span&gt;（）&lt;/strong&gt; &lt;strong&gt;判断队列是否为满&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; q.&lt;span&gt;empty&lt;/span&gt;()&lt;/strong&gt;  判断队列&lt;strong&gt;是否为空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;q.&lt;span&gt;qsize&lt;/span&gt;()&lt;/strong&gt;  &lt;strong&gt;获取&lt;/strong&gt;队列中&lt;strong&gt;消息的数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; q.close() &lt;/strong&gt; &lt;strong&gt;关闭&lt;/strong&gt;队列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;        共享内存通信：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在&lt;strong&gt;内存中开辟一段空间存储数据&lt;/strong&gt;对多个进程可见，&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;每次写入&lt;/strong&gt;共享内存中的内容&lt;strong&gt;都会覆盖之前内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    对内存的&lt;strong&gt;读操作不会改变内存中的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;form &lt;/span&gt;multiprocessing &lt;span&gt;import &lt;/span&gt;Value，Array&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;shm = &lt;span&gt;Value&lt;/span&gt;（ctype，obj）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：&lt;strong&gt;共享内存&lt;/strong&gt;共享&lt;strong&gt;空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;ctype&lt;/span&gt;：&lt;span&gt;字符串&lt;/span&gt;  要转换的c语言的数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    obj：共享内存的&lt;strong&gt;初始数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回值：返回共享内存对象&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; shm.&lt;span&gt;value&lt;/span&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;表示共享&lt;/strong&gt;内存&lt;strong&gt;的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;  multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Value 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random  

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建共享内存&lt;/span&gt;
money = Value(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,6000&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;存钱&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; deposite():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
        time.sleep(&lt;/span&gt;0.05&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对value的修改就是对共享内存的修改&lt;/span&gt;
        money.value += random.randint(1,200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花销&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; withdraw():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100&lt;span&gt;):
        time.sleep(&lt;/span&gt;0.04&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对value的修改就是对共享内存的修改&lt;/span&gt;
        money.value -= random.randint(1,200&lt;span&gt;)

d &lt;/span&gt;= Process(target =&lt;span&gt; deposite)
w &lt;/span&gt;= Process(target =&lt;span&gt; withdraw)

d.start()
w.start()

d.join()
w.join()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(money.value)
&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;shm = &lt;span&gt;Array&lt;/span&gt;（ctype，obj）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        功能：&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;开辟共享&lt;/strong&gt;内存&lt;strong&gt;空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;ctype：要转换的数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    obj：&lt;/p&gt;
&lt;p&gt;        要存入共享内容的的数据（&lt;strong&gt;结构化数据&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表、字符串&lt;/strong&gt; &lt;strong&gt;表示要存入得内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要求&lt;strong&gt;数据结构内&lt;/strong&gt;的&lt;strong&gt;类型相同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整数&lt;/strong&gt; &lt;strong&gt;表示&lt;/strong&gt;要&lt;strong&gt;开辟几个单元的空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt; 返回&lt;/strong&gt;共享内存对象  &lt;strong&gt;可迭代对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Array
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建共享内存&lt;/span&gt;
shm = Array(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,b&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;字符类型要求是bytes&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开辟5个整形单元的共享内存空间&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; shm = Array('i',5)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; shm:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
    shm[0] &lt;/span&gt;= b&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

p &lt;/span&gt;= Process(target =&lt;span&gt; fun)
p.start()
p.join()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(shm.value) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从首地址打印字符串&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; for i in shm:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三种进程间通信区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;管道通信：                           消息队列：                          共享内存：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开辟空间：&lt;/strong&gt;     内存                                      内存                                    内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读写方式：&lt;/strong&gt; 两端读写                               先进先出                        每次覆盖上次内容&lt;/p&gt;
&lt;p&gt;                  单向/双向 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率： &lt;/strong&gt;           一般                                     一般                                     较快&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用：&lt;/strong&gt;   多用于父子进程                        应用灵活广泛                   复杂，需要同步互斥&lt;/p&gt;



&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201808/1430617-20180813232344177-595307819.png&quot; alt=&quot;&quot;/&gt;

&lt;/div&gt;

</description>
<pubDate>Mon, 13 Aug 2018 15:24:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<og:description>线程池的原理： 线程池是预先创建线程的一种技术。线程池在还没有任务到来之前， 创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态， 即均为启动，不消耗CPU，而只是占用较小的内存空间。当请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9471734.html</dc:identifier>
</item>
<item>
<title>angular应用容器化部署 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/angular-app-containerization.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/angular-app-containerization.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;我自己有做一个个人主页，虽然效果不怎么样（不懂设计的典型程序猿...)，但是记录了我对于前端框架及工具的一些实践，&lt;br/&gt;从开始只有一个 angularjs 制作的页面到后面加入 less 动态写css， gulp 自动化的将 less 文件编译成 css 文件以及自动化的压缩 js 和 css，到后面加入的基于 vue 和 angular 实现，主要维护的是基于 angular 的，目前 angular 的个人主页已经支持 PWA（Progressive Web Application）,前几天添加了 docker 部署的支持，记录一篇文章记录一下。&lt;/p&gt;
&lt;p&gt;个人主页体验地址：&lt;a href=&quot;https://weihanli.xyz&quot; class=&quot;uri&quot;&gt;https://weihanli.xyz&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写-dockerfile&quot;&gt;编写 dockerfile&lt;/h2&gt;
&lt;p&gt;完整的 dockerfile 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM node
# set working directory
WORKDIR /app

# install and cache app dependencies
COPY . /app

# install dependencies and build the angular app
RUN yarn &amp;amp;&amp;amp; yarn run build

FROM nginx:stable-alpine

# copy from dist to nginx root dir
COPY --from=builder /app/dist/weihanli /usr/share/nginx/html

# expose port 80
EXPOSE 80

# set author info
LABEL maintainer=&quot;WeihanLi&quot;

# run nginx in foreground
# https://stackoverflow.com/questions/18861300/how-to-run-nginx-within-a-docker-container-without-halting
CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个 dockerfile 可分为两部分，第一部分是编译 angular 应用，生成最后要部署的文件。&lt;br/&gt;第二部分则是将生成的部分拷贝到基于 nginx 的环境中，部署到 nginx 中&lt;/p&gt;
&lt;h2 id=&quot;打包-docker-镜像&quot;&gt;打包 docker 镜像&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;docker build&lt;/code&gt; 命令打包 docker 镜像，详细命令使用参考 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/build/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/engine/reference/commandline/build/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker build -t weihanli/homepage .&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动容器&quot;&gt;启动容器&lt;/h2&gt;
&lt;h3 id=&quot;docker-run&quot;&gt;docker run&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;docker run&lt;/code&gt; 命令启动一个容器，部署打包好的镜像，详细命令使用参考 &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/run/&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/engine/reference/commandline/run/&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -p:5200:80 --rm --name homepage-demo weihanli/homepage&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;docker-compose&quot;&gt;docker compose&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;docker-compose.yml&lt;/code&gt; 启动容器，启动命令：&lt;code&gt;docker-compose up&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更多 compose 信息参考 &lt;a href=&quot;https://docs.docker.com/compose/compose-file&quot; class=&quot;uri&quot;&gt;https://docs.docker.com/compose/compose-file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker-compose.yml 文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: &quot;3&quot;
services:
  web:
    image: &quot;weihanli/homepage&quot;
    container_name: &quot;weihanli-homepage-demo&quot;
    ports:
        - &quot;5200:80&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;访问容器中的应用&quot;&gt;访问容器中的应用&lt;/h2&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://localhost:5200&quot; class=&quot;uri&quot;&gt;http://localhost:5200&lt;/a&gt; ，即可访问到容器中部署的应用&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;项目源代码：&lt;a href=&quot;https://github.com/WeihanLi/weihanli.github.io&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/weihanli.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Contact me: &lt;a href=&quot;mailto:weihanli@outlook.com&quot;&gt;weihanli@outlook.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:11:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>angular 应用容器化部署 Intro 我自己有做一个个人主页，虽然效果不怎么样（不懂设计的典型程序猿...)，但是记录了我对于前端框架及工具的一些实践， 从开始只有一个 angularjs 制作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/angular-app-containerization.html</dc:identifier>
</item>
<item>
<title>linux 与 windows 挖门罗币总结 - mysgk</title>
<link>http://www.cnblogs.com/mysgk/p/9471675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysgk/p/9471675.html</guid>
<description>&lt;p&gt;比特币之前一直很火,初次了解的时候才2000RMB一枚..看不懂哇,错失良机...当然了,看得懂也不买不起..当时还是穷学生.&lt;br/&gt;最近又一直看到黑客利用linux漏洞挖门罗币获利的新闻,决定好生研究一下这个东西.&lt;/p&gt;

&lt;p&gt;首先我们需要注册一个钱包,就是类似账号的东西.&lt;br/&gt;钱包分两种,一种是本地钱包,需要同步大量的数据,普通玩家一般不会选择这种.&lt;br/&gt;一种是在线钱包,直接生成就可以了.&lt;br/&gt;我们在这里讲一下怎么注册在线钱包.&lt;br/&gt;打开 &lt;a href=&quot;https://mymonero.com/&quot; class=&quot;uri&quot;&gt;https://mymonero.com&lt;/a&gt;&lt;br/&gt;点击 Create an Account&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813222724402-1959142444.png&quot;/&gt;&lt;br/&gt;跳转到了&lt;br/&gt;&lt;a href=&quot;https://mymonero.com/#/create-your-account&quot; class=&quot;uri&quot;&gt;https://mymonero.com/#/create-your-account&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813222856910-1475911747.png&quot;/&gt;&lt;br/&gt;此处需要记下 Your Private Login Key (私有的登录密钥) 这个相当于你的密码&lt;br/&gt;然后把 Private Login Key 复制到 Confirm your Private Login Key (请确认你的登录密钥) 下面的输入框就可以了&lt;br/&gt;如图:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813223159179-763601360.png&quot;/&gt;&lt;br/&gt;然后点击 I've written down my Private Login Key, log me in! (我已经输入了密钥....)&lt;br/&gt;然后页面就会跳转到 &lt;a href=&quot;https://mymonero.com/#/overview&quot; class=&quot;uri&quot;&gt;https://mymonero.com/#/overview&lt;/a&gt;&lt;br/&gt;然后记下 address 下面的内容,这个就是你的钱包ID&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813223328516-1270152658.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小结.注册钱包需要记录两个东西,一个是钱包ID,一个是 私钥(即上文的 Private Login Key ).&lt;/p&gt;

&lt;p&gt;好,我们有了钱包,就可以选取矿池了,&lt;br/&gt;挖矿又分为两种情况,&lt;br/&gt;一种是直接用官方的程序开始挖,这种情况不适用于普通玩家,因为普通玩家算力有限,一般很难挖出一块.&lt;br/&gt;第二种就是连接到矿池挖.矿池的原理就是大家把算力集中起来到一个人身上来挖,这样这个玩家算计就 很强,挖到币的概率就大一些.然后挖到币以后,矿池再根据每个玩家的算计来分配.&lt;br/&gt;我们这里直接讲用矿池挖的方法:&lt;br/&gt;先列举几个矿池:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.https://xmr.nanopool.org 
矿池地址：xmr-us-east1.nanopool.org:14444 （冒号后为端口，下面不再说明） 
nanopool的难度固定设置为12万。矿池总税为1%，现手续费固定为0.015XMR，最低0.3提现。本矿池适合算力比较大的矿工。

2.https://supportxmr.com/ 
矿池地址： 
pool.supportxmr.com:7777 （最大难度2.5W） 
pool.supportxmr.com:5555（最大难度1.5W） 
pool.supportxmr.com:3333（最大难度3K）

supportxmr的矿池总税为0.6%，最低0.3提现，提现手续费不详。难度会根据你的电脑算力自动调整，一般的电脑连接5555端口即可。

3.http://www.minexmr.com/ 
矿池地址： 
Europe (France, Germany): pool.minexmr.com 
France: fr.minexmr.com 
Germany: de.minexmr.com 
Canada: ca.minexmr.com

端口： 4444,5555，起始难度15000 
端口： 7777, 80, 443，起始难度35000 
端口： 3333，起始难度200000 
端口： 6666，起始难度35000

本矿池特点是有80和443端口，适合于公司或者企业防火墙策略屏蔽掉对外网其它端口访问的人群。矿池总税为1%。.

4 . https://get.bi-chi.com 
碧池，这个应该是国内挖矿人数最多的门罗币矿池，相对于上述几家，总算力大概7到8W，略低。经营者是在我们国内，但是服务器是在国外。 
矿池： 
get.bi-chi.com:3333 
get.bi-chi.com:5555 
get.bi-chi.com:7777 
以上矿池难度从地到高，但是矿池会根据你电脑算力来自动调整，一般1K以下的算力，就选择5555端口好了。矿池总税为1.6%

5.https://monero.crypto-pool.fr/ 
这是一个法国的矿池，但是我们测试的时候惊人地发现这个矿池的ping值非常小，几乎相当于在国内。 
矿池地址：xmr.crypto-pool.fr 
矿池端口：3333 6666 7777， 80,8080,443。难度18000 
矿池端口：8888，难度30000 
矿池端口：9999，8443，难度50000 
矿池总税2%。此矿池开通80和443端口，对于防火墙策略屏蔽了对外网端口访问的，也可以使用此矿池。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几个都是网上收集的,目前我在用的是第二个 pool.supportxmr.com:5555 ,大家随意选&lt;/p&gt;

&lt;p&gt;好,选好了矿池以后我们开始下载软件.&lt;br/&gt;我们选择用:xmr-stak 这款软件.下载地址:&lt;br/&gt;&lt;a href=&quot;https://github.com/fireice-uk/xmr-stak/releases&quot; class=&quot;uri&quot;&gt;https://github.com/fireice-uk/xmr-stak/releases&lt;/a&gt;&lt;br/&gt;至于为什么用这个,,,因为,,我也是刚接触,只知道这个....&lt;br/&gt;它这个只提供了Windows 下面的程序,那我们就先讲windows 吧.&lt;/p&gt;
&lt;h2 id=&quot;windows-挖矿&quot;&gt;windows 挖矿:&lt;/h2&gt;
&lt;p&gt;下载下来以后解压,解压完成后, 双击 exe 运行.&lt;br/&gt;如图:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813224520136-1849146849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1):Please enter:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Do you want to use the HTTP interface?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Unlike the screen display, browser interface is not affected by the GPU lag.&lt;/p&gt;
&lt;p&gt;If you don't want to use it, please enter 0, otherwise enter port number that the miner should listen on&lt;/p&gt;
&lt;p&gt;问你是否需要使用 http 接口, 一般我们不需要使用, 所以输入 0 并回车即可&lt;/p&gt;
&lt;p&gt;2):Please enter:&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Please enter the currency that you want to mine:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  - aeon7
  - cryptonight
  - cryptonight_lite
  - edollar
  - electroneum
  - graft
  - intense
  - karbo
  - monero7
  - stellite
  - sumokoin&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一步是问你挖什么币, 我们输入 monero7&lt;/p&gt;
&lt;p&gt;monero7&lt;/p&gt;
&lt;p&gt;3):- Pool address: e.g. pool.usxmrpool.com:3333&lt;/p&gt;
&lt;p&gt;这一步是问你使用什么矿池, 我们使用 supportxmr矿池, 所以输入 pool.supportxmr.com:5555&lt;/p&gt;
&lt;p&gt;4):- Username (wallet address or pool login): 这一步是问你的钱包地址是多少, 输入之前获得的钱包地址&lt;/p&gt;
&lt;p&gt;47mRbLBqmKMN5cXbr6X1Qe9PK5ey9DYULHQn3t7xCK9v8ZTnAanie8u3D3s51jd9hBT4ZyuLECYSTK5zPzetKhzkJz8rDox&lt;/p&gt;
&lt;p&gt;5):- Password (mostly empty or x): 一般没有所以输入 x&lt;/p&gt;
&lt;p&gt;剩下的按图输入即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813224629349-476792267.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你配置完成之后, 即可开始挖矿了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813224651173-41068037.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux-挖矿&quot;&gt;linux 挖矿:&lt;/h2&gt;
&lt;p&gt;linux 这边有几个坑,本来我也没接触过..看网上的教程都是讲用 xmr-stak-cpu 来挖的..但是经过试验发现用这个挖不了..会一直报错&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813225309787-679828258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;百度了也没啥结果,最后在 GitHub的 issues 里发现别人建议用 xmr-stak,好吧,,,那就用这个吧.&lt;/p&gt;
&lt;p&gt;linux 我这边用的ubuntu.其他版本自测.&lt;br/&gt;其实它的官网的文档也讲了怎么编译.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fireice-uk/xmr-stak/blob/master/doc/compile_Linux.md&quot; class=&quot;uri&quot;&gt;https://github.com/fireice-uk/xmr-stak/blob/master/doc/compile_Linux.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813225640064-1772981456.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt install libmicrohttpd-dev libssl-dev cmake build-essential libhwloc-dev
git clone https://github.com/fireice-uk/xmr-stak.git
mkdir xmr-stak/build
cd xmr-stak/build
cmake ..
make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这里还有两个坑就是,&lt;br/&gt;一: 这个程序默认会给开发者2%的捐赠,实现原理就是,你开着程序跑100分钟,会有两分钟把你的钱包ID换成他的.解决方式就是把 xmrstak/donate-level.hpp 里面的2.0 改为0.0 ,然后再编译&lt;br/&gt;二: 对于没有显卡的同学(比如在服务器上跑) 第五步的命令 要改为&lt;br/&gt;cmake -DCUDA_ENABLE=OFF -DOpenCL_ENABLE=OFF .&lt;/p&gt;
&lt;p&gt;编译好了以后,我们就到 bulud/bin 目录下面执行 ./xmr-stak 就可以了 .如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813230615803-1673725959.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们到 &lt;a href=&quot;https://www.supportxmr.com/#/dashboard&quot; class=&quot;uri&quot;&gt;https://www.supportxmr.com/#/dashboard&lt;/a&gt; 可以看到&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/695883/201808/695883-20180813230703026-894740881.png&quot;/&gt;&lt;br/&gt;这里输入我们的钱包ID ,就可以看到挖矿进度了.&lt;br/&gt;Total Due&lt;br/&gt;就是我们已经挖到的币的数量了..&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 15:10:00 +0000</pubDate>
<dc:creator>mysgk</dc:creator>
<og:description>比特币之前一直很火,初次了解的时候才2000RMB一枚..看不懂哇,错失良机...当然了,看得懂也不买不起..当时还是穷学生. 最近又一直看到黑客利用linux漏洞挖门罗币获利的新闻,决定好生研究一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mysgk/p/9471675.html</dc:identifier>
</item>
<item>
<title>基于编程人员Python学习第一章节 - Aikenwu</title>
<link>http://www.cnblogs.com/aikenwu/p/9471570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aikenwu/p/9471570.html</guid>
<description>&lt;p&gt;基于廖雪峰的python零基础学习后，自我总结。适用于有一定基础的编程人员，对我而言，则是基于.net已有方面，通过学习，记录自我觉得有用的地方，便于后续回顾。&lt;/p&gt;
&lt;p&gt;主要以快速定位内容，通过直观代码输入输出结果，展示独有的特性，更直观表现，而不拘禁于理论描述。待以后使用中遇到坑，再来详细阐述。&lt;/p&gt;
&lt;p&gt;本章包含，Python基础、函数、高级特性、函数式编程、模块&lt;/p&gt;
&lt;h4&gt;一、Python基础&lt;/h4&gt;
&lt;p&gt;　　Python程序大小写敏感，个人使用sublime编写程序，注意规范使用tab缩进或者空格，否则程序运行会报unexpected error&lt;/p&gt;
&lt;p&gt;　　字符串转义：用&lt;code&gt;r''&lt;/code&gt;表示&lt;code&gt;''&lt;/code&gt;内部的字符串默认不转义 　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\\t\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
\\\t\\&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　用&lt;code&gt;'''...'''&lt;/code&gt;的格式表示多行内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;line1
... line2
... line3&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;)
line1
line2
line3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　　　Encode &amp;amp; Decode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ascii&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中文&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xe4\xb8\xad\xe6\x96\x87&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ascii&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xe4\xb8\xad\xe6\x96\x87&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中文&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xe4\xb8\xad\xff&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, errors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ignore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　长度：len(str)&lt;/p&gt;
&lt;p&gt;　　　　　　格式化: %s 字符串； %d 整数； %f 浮点数；%x 十六进制整数；%%=&amp;gt;%&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%2d-%02d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (3, 1&lt;span&gt;))
 &lt;/span&gt;3-01
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%.2f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % 3.1415926&lt;span&gt;)
&lt;/span&gt;3.14、
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　布尔值：True，False&lt;/p&gt;
&lt;p&gt;　　空值：None &lt;/p&gt;
&lt;p&gt;　　集合list  和 元组 tuple&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
classmates = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Michael&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]　　　　集合list  append 添加，pop 删除
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;classmates = (&lt;span class=&quot;string&quot;&gt;'Michael', &lt;span class=&quot;string&quot;&gt;'Bob', &lt;span class=&quot;string&quot;&gt;'Tracy')&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; classmates[-3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Michael&lt;/span&gt;&lt;span&gt;'&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;#只有一个元素tuple 定义加上逗号 ，&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; t = (&lt;span class=&quot;number&quot;&gt;1,)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; t&lt;br/&gt;(&lt;span class=&quot;number&quot;&gt;1,)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;#“可变的”tuple 内部list改变，实际指向list位置未变&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; t = (&lt;span class=&quot;string&quot;&gt;'a', &lt;span class=&quot;string&quot;&gt;'b', [&lt;span class=&quot;string&quot;&gt;'A', &lt;span class=&quot;string&quot;&gt;'B'])
&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; t[&lt;span class=&quot;number&quot;&gt;2][&lt;span class=&quot;number&quot;&gt;0] = &lt;span class=&quot;string&quot;&gt;'X'
&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; t[&lt;span class=&quot;number&quot;&gt;2][&lt;span class=&quot;number&quot;&gt;1] = &lt;span class=&quot;string&quot;&gt;'Y'
&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; t
(&lt;span class=&quot;string&quot;&gt;'a', &lt;span class=&quot;string&quot;&gt;'b', [&lt;span class=&quot;string&quot;&gt;'X', &lt;span class=&quot;string&quot;&gt;'Y'])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　条件判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age = 20
&lt;span&gt;if&lt;/span&gt; age &amp;gt;= 6&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;teenager&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; age &amp;gt;= 18&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adult&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　dic 字典 和 set&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; d = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Michael&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 95, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 75, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 85&lt;span&gt;}
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; d[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Michael&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;95
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;#设定默认值&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; d.get(&lt;span class=&quot;string&quot;&gt;'Thomas', -&lt;span class=&quot;number&quot;&gt;1)
-&lt;span class=&quot;number&quot;&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;#删除&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; d.pop(&lt;span class=&quot;string&quot;&gt;'Bob')
&lt;span class=&quot;number&quot;&gt;75&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;#重复元素在set中自动被过滤：  add(key)　　remove(key)&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; s = set([&lt;span class=&quot;number&quot;&gt;1, &lt;span class=&quot;number&quot;&gt;2, &lt;span class=&quot;number&quot;&gt;3])
&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s
{&lt;span class=&quot;number&quot;&gt;1, &lt;span class=&quot;number&quot;&gt;2, &lt;span class=&quot;number&quot;&gt;3}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;二、函数&lt;/h4&gt;
&lt;p&gt;　　函数定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_abs(x):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;gt;=&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -x&lt;br/&gt;#返回多个值 return a,b,c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　函数参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#默认参数必须指向不变对象！&lt;/span&gt;&lt;br/&gt;def&lt;/span&gt; add_end(L=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; L &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        L &lt;/span&gt;=&lt;span&gt; []
    L.append(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; L
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# *args 可变参数 **关键字参数&lt;/span&gt;&lt;br/&gt;def&lt;/span&gt; f1(a, b, c=0, *args, **&lt;span&gt;kw):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a =&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, a, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b =&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, b, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c =&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;args =&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, args, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw =&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kw)
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f1(&lt;span class=&quot;number&quot;&gt;1, &lt;span class=&quot;number&quot;&gt;2, &lt;span class=&quot;number&quot;&gt;3, &lt;span class=&quot;string&quot;&gt;'a', &lt;span class=&quot;string&quot;&gt;'b', x=&lt;span class=&quot;number&quot;&gt;99)
a = &lt;span class=&quot;number&quot;&gt;1 b = &lt;span class=&quot;number&quot;&gt;2 c = &lt;span class=&quot;number&quot;&gt;3 args = (&lt;span class=&quot;string&quot;&gt;'a', &lt;span class=&quot;string&quot;&gt;'b') kw = {&lt;span class=&quot;string&quot;&gt;'x': &lt;span class=&quot;number&quot;&gt;99}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;# *,d 命名关键字参数&lt;br/&gt;def &lt;span class=&quot;title&quot;&gt;f2&lt;span class=&quot;params&quot;&gt;(a, b, c=&lt;span class=&quot;number&quot;&gt;0, *, d, **kw):
    print(&lt;span class=&quot;string&quot;&gt;'a =', a, &lt;span class=&quot;string&quot;&gt;'b =', b, &lt;span class=&quot;string&quot;&gt;'c =', c, &lt;span class=&quot;string&quot;&gt;'d =', d, &lt;span class=&quot;string&quot;&gt;'kw =', kw)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f2(&lt;span class=&quot;number&quot;&gt;1, &lt;span class=&quot;number&quot;&gt;2, d=&lt;span class=&quot;number&quot;&gt;99, ext=&lt;span class=&quot;built_in&quot;&gt;None)
a = &lt;span class=&quot;number&quot;&gt;1 b = &lt;span class=&quot;number&quot;&gt;2 c = &lt;span class=&quot;number&quot;&gt;0 d = &lt;span class=&quot;number&quot;&gt;99 kw = {&lt;span class=&quot;string&quot;&gt;'ext': &lt;span class=&quot;built_in&quot;&gt;None}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;title&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;string&quot;&gt;#对于任意函数，都可以通过类似&lt;code&gt;func(*args, **kw)&lt;/code&gt;的形式调用它，无论它的参数是如何定义的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;三、高级特性&lt;/h4&gt;
&lt;p&gt;　　切片 substring&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; L = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Michael&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sarah&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; L[1:3&lt;span&gt;]　　# L[1] L[2]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sarah&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; L = list(range(&lt;span class=&quot;number&quot;&gt;100))&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;tag&quot;&gt;L&lt;span class=&quot;attr_selector&quot;&gt;[-10:]　　# L[-10:100] 后10个
&lt;span class=&quot;attr_selector&quot;&gt;[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;tag&quot;&gt;L&lt;span class=&quot;attr_selector&quot;&gt;[:10:2]　　# L[0:10:2] 前10个数，每两个取一个
&lt;span class=&quot;attr_selector&quot;&gt;[0, 2, 4, 6, 8]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;tag&quot;&gt;L&lt;span class=&quot;attr_selector&quot;&gt;[:]　　# L[0:100:1] copy 复制
&lt;span class=&quot;attr_selector&quot;&gt;[0, 1, 2, 3, ..., 99]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　&amp;gt;&amp;gt;&amp;gt; L[::-1]　　#相当于 L[-1:-101:-1]  if s&amp;lt;0 then L[-1:-len(L)-1:-1]&lt;br/&gt;　[99, 98, 97, &lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;tag&quot;&gt;..., 0]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　迭代 for&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, Iterable) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; str是否可迭代&lt;/span&gt;
&lt;span&gt;True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; isinstance([1,2,3], Iterable) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; list是否可迭代&lt;/span&gt;
&lt;span&gt;True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(123, Iterable) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 整数是否可迭代&lt;/span&gt;
False
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;for i, value &lt;span class=&quot;keyword&quot;&gt;in enumerate([&lt;span class=&quot;string&quot;&gt;'A', &lt;span class=&quot;string&quot;&gt;'B', &lt;span class=&quot;string&quot;&gt;'C']):
&lt;span class=&quot;prompt&quot;&gt;...     print(i, value)
...
&lt;span class=&quot;number&quot;&gt;0 A
&lt;span class=&quot;number&quot;&gt;1 B
&lt;span class=&quot;number&quot;&gt;2 C&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　列表生成式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [x * x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(1, 11) &lt;span&gt;if&lt;/span&gt; x % 2 ==&lt;span&gt; 0]
[&lt;/span&gt;4, 16, 36, 64, 100]
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; L = [&lt;span class=&quot;string&quot;&gt;'Hello', &lt;span class=&quot;string&quot;&gt;'World', &lt;span class=&quot;string&quot;&gt;'IBM', &lt;span class=&quot;string&quot;&gt;'Apple']
&lt;span class=&quot;prompt&quot;&gt;&amp;gt;&amp;gt;&amp;gt; [s.lower() &lt;span class=&quot;keyword&quot;&gt;for s &lt;span class=&quot;keyword&quot;&gt;in L]
[&lt;span class=&quot;string&quot;&gt;'hello', &lt;span class=&quot;string&quot;&gt;'world', &lt;span class=&quot;string&quot;&gt;'ibm', &lt;span class=&quot;string&quot;&gt;'apple']&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　生成器 yield&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; L = [x * x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;)]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; L
[0, &lt;/span&gt;1, 4, 9, 16, 25, 36, 49, 64, 81&lt;span&gt;]
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; g = (x * x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;))
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; g
&lt;/span&gt;&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x1022ef630&amp;gt;&lt;br/&gt;# 使用next(g) or for n in g 可迭代对象g

#斐波拉契数&lt;br/&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(max):
    n, a, b &lt;/span&gt;= 0, 0, 1
    &lt;span&gt;while&lt;/span&gt; n &amp;lt;&lt;span&gt; max:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; b
        a, b &lt;/span&gt;= b, a +&lt;span&gt; b
        n &lt;/span&gt;= n + 1
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;done&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterator
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; isinstance((x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;)), Iterator)
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; isinstance([], Iterator)
False
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; isinstance({}, Iterator)
False
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, Iterator)
False

&lt;/span&gt;&lt;span&gt;#Iterable。 for 循环迭代
#Iterator。 next 迭代器
# Iterable 转换 Iterator&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; isinstance(iter([]), Iterator)
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(iter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), Iterator)
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;四、函数式编程 &lt;/h4&gt;
&lt;p&gt;　　高阶函数 map/reduce/filter/sorted&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;map 传入函数依次作用到序列每个元素，返回Iterator结果集&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; f(x):
...     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; x
...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;])
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; list(r)
[&lt;/span&gt;1, 4, 9, 16, 25, 36, 49, 64, 81&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; r 为Iterator惰性序列，list() 是整个序列返回&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;reduce  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reduce
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(x, y):
...     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y
...
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; reduce(add, [1, 3, 5, 7, 9&lt;span&gt;])
&lt;/span&gt;25

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;map reduce 结合使用&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reduce
DIGITS &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 5, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 6, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 7, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 8, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 9&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; char2num(s):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DIGITS[s]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; str2int(s):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: x * 10 + y, map(char2num, s))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;filter filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; not_empty(s):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s &lt;span&gt;and&lt;/span&gt;&lt;span&gt; s.strip()

list(filter(not_empty, [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果: ['A', 'B', 'C']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;sorted sorted()函数对list进行排序&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; sorted([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;about&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Zoo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Credit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], key=str.lower, reverse=&lt;span&gt;True)
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Zoo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Credit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;about&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　函数返回值 和 闭包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; lazy_sum(*&lt;span&gt;args):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sum():
        ax &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args:
            ax &lt;/span&gt;= ax +&lt;span&gt; n
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ax
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; f = lazy_sum(1, 3, 5, 7, 9&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; f
&lt;/span&gt;&amp;lt;function lazy_sum.&amp;lt;locals&amp;gt;.sum at 0x101c6ed90&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; f()
&lt;/span&gt;25
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;典型闭包错误&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; count():
    fs &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 4&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f():
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i*&lt;span&gt;i
        fs.append(f)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fs

f1, f2, f3 &lt;/span&gt;=&lt;span&gt; count()

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; f1()
&lt;/span&gt;9
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; f2()
&lt;/span&gt;9
&amp;gt;&amp;gt;　f3()&lt;br/&gt;9
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量&lt;p&gt;修改后：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def &lt;span class=&quot;title&quot;&gt;count&lt;span class=&quot;params&quot;&gt;():
    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def &lt;span class=&quot;title&quot;&gt;f&lt;span class=&quot;params&quot;&gt;(j):
        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def &lt;span class=&quot;title&quot;&gt;g&lt;span class=&quot;params&quot;&gt;():
            &lt;span class=&quot;keyword&quot;&gt;return j*j
        &lt;span class=&quot;keyword&quot;&gt;return g
    fs = []
    &lt;span class=&quot;keyword&quot;&gt;for i &lt;span class=&quot;keyword&quot;&gt;in range(&lt;span class=&quot;number&quot;&gt;1, &lt;span class=&quot;number&quot;&gt;4):
        fs.append(f(i)) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　匿名函数 lambda&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; list(map(&lt;span&gt;lambda&lt;/span&gt; x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]))
[&lt;/span&gt;1, 4, 9, 16, 25, 36, 49, 64, 81]&lt;br/&gt;#lambda 不包含return，返回即使return结果
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; log(text):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kw):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s %s():&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (text, func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kw)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator

@log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; now():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-8-13&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; now()
execute now():
&lt;/span&gt;2018-8-13
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　偏函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; int2 = functools.partial(int, base=2&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; int2(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;64
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;相当于下面这样调用&lt;/span&gt;
kw = { &lt;span&gt;'&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 2&lt;span&gt; }
int(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10010&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, **kw)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;五、模块&lt;/h4&gt;

</description>
<pubDate>Mon, 13 Aug 2018 14:51:00 +0000</pubDate>
<dc:creator>Aikenwu</dc:creator>
<og:description>基于廖雪峰的python零基础学习后，自我总结。适用于有一定基础的编程人员，对我而言，则是基于.net已有方面，通过学习，记录自我觉得有用的地方，便于后续回顾。 主要以快速定位内容，通过直观代码输入输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aikenwu/p/9471570.html</dc:identifier>
</item>
</channel>
</rss>