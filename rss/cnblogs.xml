<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>安卓menu的介绍与使用 - 葛利高里</title>
<link>http://www.cnblogs.com/shu94/p/9786562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shu94/p/9786562.html</guid>
<description>&lt;p&gt;&lt;span&gt;菜单之前是用户点击系统的菜单键才展示出来的，后来这个键渐渐被移除，菜单变成了点击任意的view都可以展示。菜单非为3种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.&lt;strong&gt;Options menu and action bar  选项菜单和操作栏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.&lt;/strong&gt;Context menu and contextual action mode &lt;/span&gt;上下文菜单和上下文动作模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.&lt;/strong&gt;Popup menu &lt;/span&gt; &lt;strong&gt;弹出式菜单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在逐一介绍这3种菜单的使用方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.Options menu&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个菜单比较原始，它的实现必须通过点击actionbar 上的按钮或手机自带的菜单键才能显示。首先，在res文件目录下，新建文件夹menu，然后再menu文件夹中新建menu的xml文件，这里我的文件名为&quot;option_menu&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;menu &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/add&quot;&lt;/span&gt;&lt;span&gt;
        android:icon&lt;/span&gt;&lt;span&gt;=&quot;@mipmap/addition&quot;&lt;/span&gt;&lt;span&gt;
        android:title&lt;/span&gt;&lt;span&gt;=&quot;添加&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/see&quot;&lt;/span&gt;&lt;span&gt;
        android:icon&lt;/span&gt;&lt;span&gt;=&quot;@mipmap/eye&quot;&lt;/span&gt;&lt;span&gt;
        android:title&lt;/span&gt;&lt;span&gt;=&quot;发现&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/state&quot;&lt;/span&gt;&lt;span&gt;
        android:icon&lt;/span&gt;&lt;span&gt;=&quot;@mipmap/emoji&quot;&lt;/span&gt;&lt;span&gt;
        android:title&lt;/span&gt;&lt;span&gt;=&quot;表情&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;menu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　我自己在mipmap文件夹中放了3张40*40 的小图标(你可以从图标网站自己去下载),这个xml文件比较简单。接着我们在activity中把这个xml填充成view。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater &lt;/span&gt;=&lt;span&gt; getMenuInflater();
        inflater.inflate(R.menu.option_menu,menu);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014111926297-2136400180.png&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;414&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这是点击actionbar右边的按钮弹出的界面截图，但奇怪的是我在xml配置的图标没显示出来￣︿￣。通过百度，原来是menu这个对象搞的鬼&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014112943585-926234321.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我在这里打断点时可以发现menu在运行时实际上引用的是MenuBuilder对象。这个MenuBuilder对象和menu是什么关系呢？ 通过sdk查询，他俩的关系是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MenuBuilder------实现-----》SupportMenu(接口)-------继承--------》Menu(接口)。而在MenuBuilder这个类中控制图标显示的方法是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014114020828-311969367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始时，mOptionlIconsVisible = false,我们只要调用setOptionalIconsVisible(true),就能解决问题。操作运行时的menuBuilder对象，很容易让我们想到用反射。。。我们写个方法，通过MenuBuilder的class对象，来调我们setOptionalIconsVisible方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014120054854-1848115323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;懂反射的语法，上面的方法应该很容易就能看懂了。最后看看效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014120355396-1879971269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大功告成！接下来就来监听菜单的点击事件了，方法是onOptionsItemSelected()，见名思意，这个方法和onCreateOptionsMenu()方法的关键字都是option,通过androidstudio强大的提示功能，也不用去记全名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014121403976-2111926724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我只写了菜单中其中一项的点击事件，其他的类似。提醒一点：这里的switch语句不像通常那样用break，而是用return true，有两个原因：1.我们用break，最后还是要在switch语句结束后，返回布尔值给方法，还不如在case 中直接返回。2：这一点更重要，方法要求返回布尔结果就是为了消费这次点击事件，true就是消费，false不消费，如果不消费，那么这个点击事件会继续传递给activity里的fragment。而我们这个简单到什么都没有，所有返回true还是false，没什么影响，但建议return true来消费这次点击事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，最简单的选项菜单已经介绍完了，接下来看看更高级一点的上下文菜单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.Context menu&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于第一个optionmenu 只跟actionBar关系好的这个事实，让开发人员不满意：我一个界面这么多元素难道就不能弹菜单吗？那么上下文菜单的出现就可以让我们少些抱怨。上下文菜单分为两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1) floating context menu  浮动上下文菜单：它的效果是当你长按控件时，会在屏幕中央出现一个列表。类似于你长按qq消息列表中的某一项，会弹出置顶、删除等选项&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先完成一个小目标，点击一个按钮，弹出浮动上下文菜单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;老规矩：定义个float_menu.xml。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;menu &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/top&quot;&lt;/span&gt;&lt;span&gt;
        android:icon&lt;/span&gt;&lt;span&gt;=&quot;@mipmap/up&quot;&lt;/span&gt;&lt;span&gt;
        android:title&lt;/span&gt;&lt;span&gt;=&quot;置顶&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/delete&quot;&lt;/span&gt;&lt;span&gt;
        android:icon&lt;/span&gt;&lt;span&gt;=&quot;@mipmap/delete&quot;&lt;/span&gt;&lt;span&gt;
        android:title&lt;/span&gt;&lt;span&gt;=&quot;删除&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;menu&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;布局中加一个按钮：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014125913462-1598387568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是activity中的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014131304493-2032070577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;长按按钮，出现的结果如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014131505477-98885862.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;488&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的图标怎么又不见了！！！难道之前的那个setIconEnable()方法失灵了。真是到处是坑。我通过打断点查看menu这个对象，结果如图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014132011099-951906242.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看看之前这里得到的是MenuBuilder对象，现在创建ContextMenu，就成了ContextMenuBuilder对象。我查了这个类，结果发现ContextMenuBuilder继承MenuBuilder，那就好办了，将setIconEnable()方法改一行就OK：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014132533029-1139703187.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;圈起来的就是获取父类的class对象，来看看结果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014132710018-1232109450.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可爱的图标终于又出现了。针对一个view弹出浮动菜单，除了不要忘记对控件注册上下文菜单，整体而言，还算简单。现在看看对listview 注册上下文菜单。别担心，更上面的代码有90%是一样的，不管怎么，把它做出来，也很有成就感。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.先把布局中的按钮换成listview:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014133409808-799661245.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.这是activity更改的代码，另外的两个方法&lt;/span&gt;onCreateContextMenu（）和 setIconEnable() 都未做更改:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014134608861-1165728305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.当你长按列表中任意一项出现的结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014134821444-2119001240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.处理点击浮动菜单事件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014135638797-1867170432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：如果是普通的view,红线那行是不需要的，其中info,position是长按项在list中的角标。&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;&lt;span&gt;contextual action mode 上下文操作模式，它会在屏幕顶部弹出 context action bar(简称CAB) .它的用处在于，你看到一段不错的文字，先把他复制下来，你长按控件就会在顶部出现CAB,操作完后再关掉CAB，很方便。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们基于上面的listview再做修改来展示出CAB。&lt;/p&gt;
&lt;p&gt;1.修改onCreate()里的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        listView &lt;/span&gt;=&lt;span&gt; findViewById(R.id.listview);
        Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;array.length;i++&lt;span&gt;){
            array[i] &lt;/span&gt;=String.valueOf(random.nextInt(1000&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就因为这行代码，使按钮的长按事件与onCreateContextMenu建立了联系，所以非常重要&lt;/span&gt;
        ArrayAdapter&amp;lt;String&amp;gt; adapter = &lt;span&gt;new&lt;/span&gt; ArrayAdapter&amp;lt;String&amp;gt;(MainActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,android.R.layout.simple_list_item_1,array);
        listView.setAdapter(adapter);

        listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
        listView.setMultiChoiceModeListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbsListView.MultiChoiceModeListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onCreateActionMode(ActionMode mode, Menu menu) {
                Log.d(TAG,&lt;/span&gt;&quot;onCreateActionMode&quot;&lt;span&gt;);
                MenuInflater inflater &lt;/span&gt;=&lt;span&gt; mode.getMenuInflater();
                inflater.inflate(R.menu.float_menu,menu);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onPrepareActionMode(ActionMode mode, Menu menu) {
                Log.d(TAG,&lt;/span&gt;&quot;onPrepareActionMode&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onItemCheckedStateChanged(ActionMode mode, &lt;span&gt;int&lt;/span&gt; position, &lt;span&gt;long&lt;/span&gt; id, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checked) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;长按控件调用的第一个方法。&lt;/span&gt;
                Log.d(TAG,&quot;onItemCheckedStateChanged&quot;&lt;span&gt;);
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onActionItemClicked(ActionMode mode, MenuItem item) {
                Log.d(TAG,&lt;/span&gt;&quot;onActionItemClicked&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (item.getItemId()){
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.top:
                        Toast.makeText(MainActivity.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;置顶&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                        mode.finish();
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroyActionMode(ActionMode mode) {
                Log.d(TAG,&lt;/span&gt;&quot;onDestroyActionMode&quot;&lt;span&gt;);
            }
        });
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面创建setMultiChoiceModeListener()的方法回调顺序，我特地进行了调整成了它回调的顺序，有前到后。5个回调中，当你长按listview中的某一项是，最先回调的是前3个方法，点击点击了头部CAB后，才会调用后两个。其中mode.finisha()如果不加进去，那么头部栏是不会消失的。最终结果图为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014145416700-310878950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只有图标，文字不见，我没有追究了，哎！这种从最上面弹出的actionbar更高级些。它把我们从点击控件到弹出bar，再到点击菜单项的全部过程用5个回调，解析的很全面。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.Popup menu  弹出式菜单:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;熟悉popopwindow 的情形下，使用popupmenu应该会觉得很容易。在默认情形下：popup menu 显示在控件上面，如果空间不过，则在下方显示，当前也可以自己自定义位置显示。它的使用与第一种options menu99%相似。&lt;/p&gt;
&lt;p&gt;将layout中的listview再改回button,这就不上截图了，直接看acvity中的代码就一目了然。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt; AppCompatActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PopupMenu.OnMenuItemClickListener{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAG = &quot;MainActivity&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button showPopMenuBtn;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        showPopMenuBtn &lt;/span&gt;=&lt;span&gt; findViewById(R.id.showPopmenuBtn);
        showPopMenuBtn.setOnClickListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
                PopupMenu popup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PopupMenu(MainActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,v);
                MenuInflater inflater &lt;/span&gt;=&lt;span&gt; popup.getMenuInflater();
                inflater.inflate(R.menu.option_menu,popup.getMenu());
                setIconEnable(popup.getMenu(),&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                popup.show();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里给popup设置监听事件,而整个activity实现了监听。&lt;/span&gt;
                popup.setOnMenuItemClickListener(MainActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setIconEnable(Menu menu, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isVisible){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (menu !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Method method &lt;/span&gt;= menu.getClass().getDeclaredMethod(&quot;setOptionalIconsVisible&quot;,&lt;span&gt;boolean&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                method.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                method.invoke(menu,isVisible);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onMenuItemClick(MenuItem item) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (item.getItemId()){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.add:
                Toast.makeText(MainActivity.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,&quot;添加&quot;&lt;span&gt;,Toast.LENGTH_SHORT).show();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行结果如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467941/201810/1467941-20181014152851607-1398349033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从popup menu设计初衷上，也只是为了对单个控件选定进行了操作，跟上下文菜单中的浮动上下文菜单功能是一模一样的，甚至官方推荐你用第二种。只不过由于popwindow自身的属性，所以让他在menu中也占了一席之地。我自人以为，如果你想点个控件，让它弹出菜单，用第二种是最好的。其中第二种上下文菜单中的浮动菜单比较简单，但可以满足非常多的普通需求，当你需要更详细的交互过程控制，就考虑上下文菜单中第二种操作模式。由于popmenu可以自定义位置显示菜单，它也算小巧而灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后一点：不要被这篇博客的滚动条给吓到，里面有很多代码、结果截图，真正有用的代码少的可怜。（￣︶￣）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Oct 2018 07:46:00 +0000</pubDate>
<dc:creator>葛利高里</dc:creator>
<og:description>安卓 menu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shu94/p/9786562.html</dc:identifier>
</item>
<item>
<title>spring-boot-maven-plugin 插件 - 撸码识途</title>
<link>http://www.cnblogs.com/tinyj/p/9786552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyj/p/9786552.html</guid>
<description>&lt;p&gt;添加了spring-boot-maven-plugin插件后，当运行maven打包的命令，项目会被打包成一个可以直接运行的jar包，使用&quot;java -jar&quot;可以直接运行。&lt;/p&gt;

&lt;p&gt;当项目中有两个启动类时，需要制定要执行的类，如果不指定，启动会报错。&lt;/p&gt;

&lt;p&gt;指定启动类有两种情况需要区分&lt;/p&gt;

&lt;p&gt;一：pom文件继承自spring-boot-starter-parent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;properties&amp;gt;
    &amp;lt;start-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.xx.xx&amp;lt;/start-&lt;span&gt;class&lt;/span&gt;&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二：pom文件不是继承自spring-boot-starter-parent&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;build&amp;gt;

&amp;lt;plugins&amp;gt;

&amp;lt;plugin&amp;gt;

&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;

          &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;

         &amp;lt;version&amp;gt;2.0.5.RELEASE&amp;lt;/version&amp;gt;

         &amp;lt;configuration&amp;gt;

            &amp;lt;mainClass&amp;gt;com.xx.xx&amp;lt;/mainClass&amp;gt;

         &amp;lt;/configuration&amp;gt;

          &amp;lt;executions&amp;gt;

            &amp;lt;execution&amp;gt;

            &amp;lt;goals&amp;gt;

                &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;

            &amp;lt;/goals&amp;gt;

            &amp;lt;/execution&amp;gt;

         &amp;lt;/executions&amp;gt;

&amp;lt;/plugin&amp;gt;

&amp;lt;/plugins&amp;gt;

&amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 14 Oct 2018 07:44:00 +0000</pubDate>
<dc:creator>撸码识途</dc:creator>
<og:description>添加了spring-boot-maven-plugin插件后，当运行maven打包的命令，项目会被打包成一个可以直接运行的jar包，使用&quot;java -jar&quot;可以直接运行。 当项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyj/p/9786552.html</dc:identifier>
</item>
<item>
<title>mysql数据库优化（三）--分区 - RGC</title>
<link>http://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_826days.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_826days.html</guid>
<description>&lt;p&gt;mysql的分区，分表&lt;/p&gt;
&lt;p&gt;分区：把一个数据表的文件和索引分散存储在不同的物理文件中。 特点：业务层透明，无需任何修改，即使从新分表，也是在mysql层进行更改（业务层代码不动）&lt;/p&gt;
&lt;p&gt;分表：把原来的表根据条件分成多个表，如原来的表为 user;现在分成2个小表 user_1,user_2;  特点：业务层需要修改代码。如过业务改变，可能需要从新分表，导致维护困难&lt;/p&gt;

&lt;p&gt;当数据量达到一定级别后，需要通过 分区或分表来提高用户体验&lt;/p&gt;
&lt;p&gt;如下知识点 为 分区&lt;/p&gt;
&lt;p&gt;如：现在生产环境有用户表 account_user，对其按照 日期（每季度）进行分区。&lt;/p&gt;
&lt;p&gt;表结构如下：&lt;/p&gt;
&lt;p&gt;输入命令：show create table account_user;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176050/201810/1176050-20181010163541453-1987053674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于此表有 主键和unique键，在分区时，必须要求被用来匹配分区的字段被包含在 主键，和unique键中（也就是复合主键和复合unique键）；&lt;/p&gt;
&lt;p&gt;通过如下命令进行操作把 create_time分别放在主键和unique键中&lt;strong&gt;&lt;span&gt;（这时mobile字段不能保证唯一性，这是个大问题，需要解决）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加unique键： ALTER TABLE account_user ADD UNIQUE KEY (mobile,create_time);&lt;/p&gt;
&lt;p&gt;删除unique键： ALTER TABLE account_user DROP UNIQUE KEY ;&lt;/p&gt;
&lt;p&gt;添加主键：ALTER TABLE account_user ADD PRIMARY KEY (id,create_time);&lt;/p&gt;
&lt;p&gt;删除主键：ALTER TABLE account_user DROP PRIMARY KEY;&lt;/p&gt;

&lt;p&gt;然后根据官网教程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176050/201810/1176050-20181010164159968-2056802547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下根据range分区进行添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE account_user PARTITION BY RANGE (TO_DAYS(create_time))
(
PARTITION account_user_2018_01 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_04 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-04-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_07 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_10 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-10-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_more VALUES less than MAXVALUE
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后查看 结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176050/201810/1176050-20181010164539847-1791537241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;验证分区效果：&lt;/p&gt;
&lt;p&gt;优点：根据create_time进行范围查询，会使用分区，避免全表扫描&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用分区的情况下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176050/201810/1176050-20181011090905797-991218558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只是查询了 3351行，或者说是查询了 （account_user_2018_01,account_user_2018_04,account_user_2018_07）三个分区&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在没有分区的情况下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176050/201810/1176050-20181011091103134-97048333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现进行全表扫描，行数为46808行&lt;/p&gt;

&lt;p&gt;相关操作：&lt;/p&gt;
&lt;p&gt;查看行数据所在分区：SELECT * FROM account_user PARTITION (account_user_2018_07) WHERE id=1; &lt;/p&gt;
&lt;p&gt;增加分区： &lt;span class=&quot;token keyword&quot;&gt;ALTER &lt;span class=&quot;token keyword&quot;&gt;TABLE account_user &lt;span class=&quot;token keyword&quot;&gt;ADD &lt;span class=&quot;token keyword&quot;&gt;PARTITION &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token keyword&quot;&gt;PARTITION &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;account_user_2019_01  &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;VALUES &lt;span class=&quot;token keyword&quot;&gt;LESS &lt;span class=&quot;token keyword&quot;&gt;THAN  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;(TO_DAYS('2019-01-01'))&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;    如果对应range分区有  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;MAXVALUE ，要先删除，否则报错&lt;/p&gt;
&lt;p&gt;删除分区： &lt;span class=&quot;token keyword&quot;&gt;ALTER &lt;span class=&quot;token keyword&quot;&gt;TABLE account_user  &lt;span class=&quot;token keyword&quot;&gt;DROP &lt;span class=&quot;token keyword&quot;&gt;PARTITION account_user_2019_01&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;删除分区数据：ALTER TABLE account_user TRUNCATE PARTITION account_user_2019_01，account_user_2019_04;  &lt;/p&gt;
&lt;p&gt;rebuild重建分区：ALTER &lt;span class=&quot;token keyword&quot;&gt;TABLE account_user  &lt;span class=&quot;token keyword&quot;&gt;REBUILD &lt;span class=&quot;token keyword&quot;&gt;PARTITION account_user_2019_01&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;   #相当于&lt;span class=&quot;keyword&quot;&gt;drop所有记录，然后再reinsert；可以解决磁盘碎片  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;优化分区：ALTER &lt;span class=&quot;token keyword&quot;&gt;TABLE account_user  &lt;/span&gt;OPTIMIZE &lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;PARTITION account_user_2019_01&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;   #在删除数据后回收空间和碎片整理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;analzye分区：ALTER &lt;span class=&quot;token keyword&quot;&gt;TABLE account_user  &lt;span class=&quot;token keyword&quot;&gt;ANALZYE &lt;span class=&quot;token keyword&quot;&gt;PARTITION account_user_2019_01&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;check分区：ALTER &lt;span class=&quot;token keyword&quot;&gt;TABLE account_user  &lt;span class=&quot;token keyword&quot;&gt;CHECK &lt;span class=&quot;token keyword&quot;&gt;PARTITION account_user_2019_01&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;所有分区方式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;list: 每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值. 将要匹配的任何值都必须在值列表中找到。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE account_user PARTITION BY LIST (TO_DAYS(create_time))
(
PARTITION account_user_2018_01 VALUES IN (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),TO_DAYS(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-01-02&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_04 VALUES IN (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-01-03&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),TO_DAYS(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-01-04&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;br/&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;range:每个分区包含那些分区表达式的值位于一个给定的连续区间内的行&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE account_user PARTITION BY RANGE (TO_DAYS(create_time))
(
PARTITION account_user_2018_01 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_04 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-04-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_07 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_10 VALUES less than (TO_DAYS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-10-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
PARTITION account_user_2018_more VALUES less than MAXVALUE
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用 范围查询 create_time 时，会使用分区进行查询（时间复杂度：O(log N)），所有速度比没有使用分区(时间复杂度：O(N))的快。&lt;/p&gt;
&lt;p&gt;hash:无需定义分区的条件，数据会平均分配到每个分区。只需要指明分区数即可。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE account_user PARTITION BY HASH(TO_DAYS(create_time))
PARTITIONS &lt;/span&gt;5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LINEAR HASH分区:在数据量大的场景，譬如TB级，增加、删除、合并和拆分分区会更快,缺点是，相对于HASH分区，它数据分布不均匀的概率更大。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER TABLE account_user PARTITION BY LINEAR HASH(TO_DAYS(create_time))
PARTITIONS &lt;/span&gt;5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;key分区:&lt;/p&gt;
&lt;p&gt;1. KEY分区允许多列，而HASH分区只允许一列。&lt;/p&gt;
&lt;p&gt;2. 如果在有主键或者唯一键的情况下，key中分区列可不指定，默认为主键或者唯一键，如果没有，则必须显性指定列。&lt;/p&gt;
&lt;p&gt;3. KEY分区对象必须为列，而不能是基于列的表达式。&lt;/p&gt;
&lt;p&gt;4. KEY分区和HASH分区的算法不一样，PARTITION BY HASH (expr)，MOD取值的对象是expr返回的值，而PARTITION BY KEY (column_list)，基于的是列的MD5值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1176050/201810/1176050-20181011170817119-396711206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;分区优点：&lt;/p&gt;
&lt;p&gt;分区可以分在多个磁盘，存储更大一点&lt;/p&gt;
&lt;p&gt;根据查找条件，也就是where后面的条件，查找只查找相应的分区不用全部查找了&lt;/p&gt;
&lt;p&gt;进行大数据搜索时可以进行并行处理。&lt;/p&gt;
&lt;p&gt;跨多个磁盘来分散数据查询，来获得更大的查询吞吐量&lt;/p&gt;

&lt;p&gt;分区缺点：&lt;/p&gt;
&lt;p&gt;其 分区对应的key必须包含主键或者unique键，导致 unique 键的字段失效（如用户注册表，手机号唯一性）&lt;/p&gt;

&lt;p&gt;需要仔细考虑评估业务系统 对表 进行操作的侧重点，然后选择字段和分区方式进行分区，尽量平均分配数据到每个分区。分区后进行相关验证性测试 是否有效果 &lt;/p&gt;

&lt;p&gt;案例：&lt;/p&gt;
&lt;p&gt;1.公司通过推荐注册可以提现红包的方式拉取用户，造成 其他人利用接口恶意注册僵尸用户，导致用户表数据量过多，影响正常用户的使用。需求：活跃用户只有总用户的5%，如何提高活跃用户的体验？&lt;/p&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;p&gt;1.在 用户表中增加一个 代表活跃度的字段，在用户每次活跃后，其值相应增加。通过 分区的方式（通过 活跃度 字段进行range分区）,提高访问速度 。&lt;/p&gt;
&lt;p&gt;           优点：无需系统层改变代码，活跃度改变后，会自动分区&lt;/p&gt;
&lt;p&gt;2.在 用户表中增加一个 代表活跃度的字段，在用户每次活跃后，其值相应增加。通过分表的方式（根据 活跃度），&lt;/p&gt;
&lt;p&gt;　　　缺点：需要系统层（应用程序）改变代码。&lt;/p&gt;
&lt;p&gt;                      在用户活跃度变化后，需要手动的从一个表变到另一个表，导致需要定期维护，较为复杂&lt;/p&gt;

&lt;p&gt;相关资料：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://dev.mysql.com/doc/refman/5.6/en/alter-table-partition-operations.html?spm=a2c4e.11153940.blogcont75306.15.77d71d1cWRwCrI&quot; href=&quot;https://dev.mysql.com/doc/refman/5.6/en/alter-table-partition-operations.html?spm=a2c4e.11153940.blogcont75306.15.77d71d1cWRwCrI&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/doc/refman/5.6/en/alter-table-partition-operations.html?spm=a2c4e.11153940.blogcont75306.15.77d71d1cWRwCrI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://blog.csdn.net/yongchao940/article/details/55266603&quot; href=&quot;https://blog.csdn.net/yongchao940/article/details/55266603&quot; target=&quot;_blank&quot;&gt; https://blog.csdn.net/yongchao940/article/details/55266603&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/phpshen/p/6198375.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/phpshen/p/6198375.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kingcat666/article/details/78324678&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/kingcat666/article/details/78324678&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Oct 2018 07:40:00 +0000</pubDate>
<dc:creator>RGC</dc:creator>
<og:description>mysql的分区，分表 分区：把一个数据表的文件和索引分散存储在不同的物理文件中。 特点：业务层透明，无需任何修改，即使从新分表，也是在mysql层进行更改（业务层代码不动） 分表：把原来的表根据条件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_826days.html</dc:identifier>
</item>
<item>
<title>简单谈谈DNS协议 - 酥风</title>
<link>http://www.cnblogs.com/su-feng/p/9786347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/su-feng/p/9786347.html</guid>
<description>&lt;p&gt;&lt;strong&gt;DNS协议&lt;/strong&gt;也可以称为DNS服务，全称是&lt;strong&gt;Domain Name System&lt;/strong&gt;，即&lt;strong&gt;域名系统&lt;/strong&gt;，和HTTP协议一样，也是一个位于&lt;strong&gt;应用层&lt;/strong&gt;的协议（服务），它是基于运输层的UDP协议的，关于网络协议的分层介绍，见&lt;a href=&quot;http://www.cnblogs.com/su-feng/p/9786347.html#&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;（还没有写好，先放这里一个空链接）。&lt;br/&gt;从DNS的名字我们就可以知道，它提供域名映射到IP地址的服务，那么在我们详细说DNS协议之前，先来大致讲讲互联网的&lt;strong&gt;域名结构&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;1. 域名结构&lt;/h3&gt;
&lt;p class=&quot;line&quot; data-line=&quot;4&quot;&gt;我们都知道，在互联网中，每一台计算机想要访问互联网，都需要一个IP地址来进行网络通信，可以是形如&lt;code&gt;192.168.1.1&lt;/code&gt;这样的点分十进制的IPv4地址，也可以是形如&lt;code&gt;[0:0:0:0:0:0:0:1]&lt;/code&gt;这样方括号包围的十六进制的IPv6地址，但是这些地址不便于记忆，所以就产生了域名这种方便人们记住的东西（当然你要是记忆力好能记住IP地址，在浏览器地址栏输入URL的时候，也可以直接用IP地址替换掉域名，效果是一样的）。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;6&quot;&gt;域名也可以叫做主机名。这里我们先给出一个域名，例如&lt;code&gt;www.abc.com&lt;/code&gt;，以这个域名为例，来看一下域名的结构。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;8&quot;&gt;域名采用层次化的结构，其中&lt;code&gt;com&lt;/code&gt;是顶级域名，&lt;code&gt;abc&lt;/code&gt;是二级域名，&lt;code&gt;www&lt;/code&gt;是三级域名，从语法上来说，每个域名都是几个不同层级的名字用&lt;code&gt;.&lt;/code&gt;连接起来的组合，域名不区分大小写字母，所以&lt;code&gt;www.ABC.com&lt;/code&gt;和&lt;code&gt;www.abc.com&lt;/code&gt;是一样的，按照规定来说，域名有长度限制，这里就不再细讲。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;10&quot;&gt;上面提到，&lt;code&gt;com&lt;/code&gt;是一个顶级域名（TLD，Top Level Domain），除了&lt;code&gt;com&lt;/code&gt;之外，顶级域名还有好多，一般来说可以分为：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;国家顶级域名&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;cn&lt;/code&gt;表示中国，&lt;code&gt;us&lt;/code&gt;表示美国，&lt;code&gt;uk&lt;/code&gt;表示英国，当然还有一些特殊地区也有所谓的国家顶级域名，比如&lt;code&gt;hk&lt;/code&gt;表示香港&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通用顶级域名&lt;/p&gt;
&lt;p&gt;如&lt;code&gt;com&lt;/code&gt;表示公司企业，&lt;code&gt;net&lt;/code&gt;表示网络服务机构，&lt;code&gt;org&lt;/code&gt;表示非营利组织，&lt;code&gt;edu&lt;/code&gt;表示美国教育机构（中国的教育机构一般来说是&lt;code&gt;xxx.edu.cn&lt;/code&gt;），&lt;code&gt;gov&lt;/code&gt;表示美国政府部门（中国的政府部门一般来说是&lt;code&gt;xxx.gov.cn&lt;/code&gt;）等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;基础结构域名&lt;/p&gt;
&lt;p&gt;不常见，不做叙述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;line&quot; data-line=&quot;23&quot;&gt;所以说，在中国，企业的域名一般可以是&lt;code&gt;xxx.com&lt;/code&gt;、&lt;code&gt;xxx.com.cn&lt;/code&gt;、&lt;code&gt;xxx.cn&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面这个域名树，清晰地展示了互联网的域名空间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8106684-2ea324f3743968cd.png?imageMogr2/auto-orient/&quot; alt=&quot;互联网的域名结构&quot; width=&quot;831&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在图中，&lt;code&gt;edu.cn&lt;/code&gt;下面，划分除了很多三级域名，如&lt;code&gt;tsinghua&lt;/code&gt;、&lt;code&gt;pku&lt;/code&gt;等，一旦某个单位有了一个域名，它就可以自己决定是否要进一步划分下属的子域，域名树的树叶节点就是单台计算机的名字，不能再继续划分了，例如&lt;code&gt;mail&lt;/code&gt;和&lt;code&gt;www&lt;/code&gt;这两台计算机的完整域名分别为&lt;code&gt;mail.tsinghua.edu.cn&lt;/code&gt;和&lt;code&gt;www.tsinghua.edu.cn&lt;/code&gt;（这里起什么名字都可以，一般来说，人们愿意把用作邮件服务器的计算机叫做mail，把用作网站的服务器叫做www）。&lt;/p&gt;
&lt;p&gt;到这里，我们已经知道了为什么要有域名以及域名的结构，域名就是为了便于人们记忆而产生的，但是域名是方便人们记忆了，计算机反而不好处理了，它更善于处理IP地址这种东西，所以这里就用到了我们要讲的DNS协议，用来把域名映射到IP地址，在了解DNS解析域名的过程之前，我们还需要了解一下域名服务器这种东西（怎么这么多东西，写个博客好麻烦啊23333）。&lt;/p&gt;
&lt;h3&gt;2. 域名服务器（DNS服务器）&lt;/h3&gt;
&lt;p&gt;上面说到了域名体系的树状结构，为了实现域名系统，我们首先想到的就是在域名树的每个节点都设置一台对应的服务器，这样就可以了，但是这样做的后果就是导致域名服务器太多，域名系统的运行效率太低，所以，通常是将好多个节点划分为一个区，用分区的方式来实现域名系统，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8106684-0508382d83b01fbc.png?imageMogr2/auto-orient/&quot; alt=&quot;DNS分区&quot; width=&quot;1049&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，(a)是abc这个公司只设置了一个分区的样子，(b)是abc公司设置了两个分区的样子，这两个区分别为&lt;code&gt;abc.com&lt;/code&gt;和&lt;code&gt;y.abc.com&lt;/code&gt;，这两个区对应了两个权限域名服务器（后面还会提到）。下图可以看出域名服务器的层次结构：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt; &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8106684-3b83a8c8a0c36547.png?imageMogr2/auto-orient/&quot; alt=&quot;域名服务器的层次结构&quot; width=&quot;937&quot; height=&quot;368&quot;/&gt;&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;由上图可以看出，根据域名服务器起的作用，可以把域名服务器分为四种不同的类型：&lt;/p&gt;
&lt;ul readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;根域名服务器&lt;/p&gt;
&lt;p&gt;根域名服务器对应的是域名树中的根节点，是最高层次的域名服务器，但是并不是只有一台，而是有好多台，总共有13个不同IP地址的根域名服务器，用a到m来表示，如&lt;code&gt;a.rootservers.net&lt;/code&gt;，每个IP地址对应一套装置，一套装置在世界不同地点安装了服务器，总之，数量很多，当访问根域名服务器时，往往就是由路由器找到最近的根域名服务器访问。&lt;/p&gt;
&lt;p&gt;一般来说，每台根域名服务器都知道所有的顶级域名服务器的域名以及IP地址，但往往也只知道这些，所以访问根域名服务器一般只能得到顶级域名服务器的IP地址，而不能直接知晓你要找的具体服务器的IP。一般来讲，如果要通过互联网解析域名，本地域名服务器首先访问的就是根域名服务器，下面还会讲到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;顶级域名服务器&lt;/p&gt;
&lt;p&gt;顶级域名服务器负责管理在顶级域名下的所有二级域名，例如&lt;code&gt;cn&lt;/code&gt;是顶级域名服务器，管理&lt;code&gt;edu&lt;/code&gt;、&lt;code&gt;gov&lt;/code&gt;等二级域名，当接收到查询请求时，要么给出最终结果（即具体IP地址），要么给出下一步应该访问的权限域名服务器的IP地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;权限域名服务器&lt;/p&gt;
&lt;p&gt;权限域名服务器上面已经提到过一次了，就是每个域名分区对应一个服务器就叫做权限域名服务器。当接收到DNS查询请求时，如果可以给出具体的IP地址就给出（例如前面的&lt;code&gt;abc.com&lt;/code&gt;可以给出&lt;code&gt;v.x.abc.com&lt;/code&gt;的IP地址，所以直接返回），如果不可以，就把下一步要访问的权限域名服务器的IP地址返回（如&lt;code&gt;abc.com&lt;/code&gt;不能给出&lt;code&gt;t.y.abc.com&lt;/code&gt;的IP，就会把&lt;code&gt;y.abc.com&lt;/code&gt;这个权限域名服务器的IP地址返回）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;本地域名服务器&lt;/p&gt;
&lt;p&gt;可能有人已经发现了，上面的图中并没有本地域名服务器这一层级结构，这是因为本地域名服务器（有时候也叫作首选域名服务器或者默认域名服务器）不属于域名树的层次结构，但是相当重要。当一台计算机要进行DNS查询的时候，就会将查询的请求发给本地域名服务器。&lt;/p&gt;
&lt;p&gt;一般来说，一个互联网服务提供商（ISP）或者是一个大学（甚至是一个系）都有一个本地域名服务器，也就是说，当你再学校内使用校园网时，你的本地域名服务器并不是指你自己的电脑，因为你的系或者你的学校，都共用一个本地域名服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3. 域名解析过程&lt;/h3&gt;
&lt;p&gt;在了解了上面的域名结构以及域名服务器之后，我们来看一下域名的解析过程，总的来讲，主机向本地域名服务器的域名查询一般采用递归查询，而本地域名服务器向根域名服务器的查询一般采用迭代查询。&lt;/p&gt;
&lt;p&gt;概念其实很简单，递归查询就是如果主机向本地域名服务器查询IP，本地域名服务器不知道IP地址，这是本地域名服务器就代替主机称为DNS客户，向根域名服务器进行下一步查询。而迭代查询就是，在本地域名服务器向根域名服务器查询时，根域名服务器要么给出最终的IP地址，要么给出下一步本地域名服务器要访问的顶级域名服务器的IP地址，之后本地域名服务器再去访问相应的顶级域名服务器（而不是让根域名服务器代替本地域名服务器去进行下一步查询）。简单来说，递归查询返回具体IP地址或者报错没找到，迭代查询返回具体IP地址或者返回下一步的IP地址。如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8106684-97c21098eb0be955.jpg?imageMogr2/auto-orient/&quot; alt=&quot;域名查询方式1&quot; width=&quot;539&quot; height=&quot;548&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也可以指定查询方式让查询过程全程使用递归查询，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8106684-5e45e081cfd76bba.jpg?imageMogr2/auto-orient/&quot; alt=&quot;域名查询方式2&quot; width=&quot;539&quot; height=&quot;548&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面以一个例子说说明在无缓存的情况下（下面会谈到缓存），通过DNS来查询域名的步骤，假设域名为&lt;code&gt;m.xyz.com&lt;/code&gt;的主机想要查询&lt;code&gt;y.abc.com&lt;/code&gt;这个域名对应的IP地址，那么他就会按照域名查询方式1（上图）中的方式进行查询：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;主机&lt;code&gt;m.xyz.com&lt;/code&gt;先向本地域名服务器&lt;code&gt;dns.xyz.com&lt;/code&gt;进行递归查询。&lt;/li&gt;
&lt;li&gt;本地域名服务器无法给出IP地址，所以本地域名服务器向（离自己最近的）根域名服务器查询，这是的查询已经变为了迭代查询。&lt;/li&gt;
&lt;li&gt;根域名服务器根据本地域名服务器发送的报文，知道了下一步应该查询的是哪个顶级域名服务器，这时根域名服务器告诉本地域名服务器，下一步应该查询的顶级域名服务器&lt;code&gt;dns.com&lt;/code&gt;的IP地址。&lt;/li&gt;
&lt;li&gt;本地域名服务器向顶级域名服务器&lt;code&gt;dns.com&lt;/code&gt;发送请求查询。&lt;/li&gt;
&lt;li&gt;顶级域名服务器&lt;code&gt;dns.com&lt;/code&gt;告诉本地域名服务器，下一步应该查询的权限域名服务器&lt;code&gt;dns.abc.com&lt;/code&gt;的IP地址。&lt;/li&gt;
&lt;li&gt;本地域名服务器向权限域名服务器&lt;code&gt;dns.abc.com&lt;/code&gt;发送请求查询。&lt;/li&gt;
&lt;li&gt;权限域名服务器&lt;code&gt;dns.abc.com&lt;/code&gt;告诉本地域名服务器想要查询的域名&lt;code&gt;y.abc.com&lt;/code&gt;的IP地址。&lt;/li&gt;
&lt;li&gt;本地域名服务器在拿到IP地址后，将IP地址返回给主机&lt;code&gt;m.xyz.com&lt;/code&gt;。&lt;br/&gt;这就是域名查询的具体过程，因为DNS协议的基于UDP协议，所以上述8个步骤中，总共使用了8个UDP报文。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面提到，这是在没有缓存的情况下的DNS查询，实际上，为了提高查询的效率以及降低根域名服务器的负荷，一般来说域名服务器中都有高速缓存，用来记录最近查询过的域名的缓存，如果在查询域名时，有想要的域名到IP的映射缓存，并且缓存没有过期，那么就直接将缓存中域名映射的IP地址返回，省去了接下来的查询。只有在没有缓存或者缓存过期了才会进行下一步的查询。实际上，不知域名服务器有缓存，每台计算机甚至浏览器都会对域名到IP的映射进行缓存，这样一来大大加快的DNS的查询速度。&lt;/p&gt;
&lt;p&gt;上面这些就是DNS协议的大概了，如果觉得有哪里写的不对的，还请多多指教。&lt;/p&gt;
&lt;p&gt;参考书籍：《计算机网络》谢希仁&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 14 Oct 2018 06:50:00 +0000</pubDate>
<dc:creator>酥风</dc:creator>
<og:description>DNS协议也可以称为DNS服务，全称是Domain Name System，即域名系统，和HTTP协议一样，也是一个位于应用层的协议（服务），它是基于运输层的UDP协议的，关于网络协议的分层介绍，见这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/su-feng/p/9786347.html</dc:identifier>
</item>
<item>
<title>声明式RESTful客户端在asp.net core中的应用 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/9786319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/9786319.html</guid>
<description>&lt;h2 id=&quot;声明式restful客户端&quot;&gt;1 声明式RESTful客户端&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;声明式服务调用的客户端，常见有安卓的Retrofit、SpringCloud的Feign等，.net有Refit和WebApiClient，这些客户端都是以java或.net某个语言来声明接口，描述如何请求RESTful api。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;webapiclient&quot;&gt;1.1 WebApiClient&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;由c#开发，但适用于任意.net语言，包括&lt;code&gt;c#、vb.net、f#&lt;/code&gt;等项目，其提供两个nuget包：WebApiClient.JIT和WebApiClient.AOT，均支持&lt;code&gt;.net framework4.5&lt;/code&gt;、&lt;code&gt;.NET Standard 1.3&lt;/code&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebApiClient.JIT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在运行时使用Emit创建Http请求接口的代理类，HttpApiClient.Create&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以在项目中直接引用WebApiClient.JIT.dll就能使用；&lt;/li&gt;
&lt;li&gt;不适用于不支持JIT技术的平台(IOS、UWP)；&lt;/li&gt;
&lt;li&gt;接口要求为public；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;WebApiClient.AOT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编译过程中使用Mono.Cecil修改编译得到的程序集，向其插入Http请求接口的代理类IL指令，这一步是在AOT编译阶段之前完成。代理类型所在的程序集、模块、命名空间与接口类型的一样，其名称为$前缀的接口类型名称，使用反编译工具查看项目编译后的程序集可以看到这些代理类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目必须使用nuget安装WebApiClient.AOT才能正常使用；&lt;/li&gt;
&lt;li&gt;没有JIT，支持的平台广泛；&lt;/li&gt;
&lt;li&gt;接口不要求为public，可以嵌套在类里面；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;refit&quot;&gt;1.2 Refit&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/reactiveui/refit&quot;&gt;Refit&lt;/a&gt;是一个开发很早的项目，在github有很高的人气，由c#开发，目前仅支持c#语言项目，支持&lt;code&gt;.NET Standard 1.4&lt;/code&gt;，.net framework需要4.6.1得以支持。&lt;/p&gt;
&lt;p&gt;Refit的内部实现与WebApiClient.AOT有相似之处，都是在编译阶段向声明接口项目插入接口实现类的代码或IL指令，我们可以称之为静态代理的编译时织入。Refit使用Microsoft.CodeAnalysis.CSharp来分析接口语法，编译前补充生成接口的代理类代码用来与项目代码一起编译。&lt;/p&gt;
&lt;h2 id=&quot;webapiclient的声明式接口&quot;&gt;2 WebApiClient的声明式接口&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;WebApiClient支持GET/HEAD、PUT/POST/DELETE、PATCH请求方法，请求内容体支持json、xml、multipart/form-data、application/x-www-form-urlencoded和自定义无结构内容等，其声明式接口风格与&lt;code&gt;asp.net core&lt;/code&gt;的接口声明非常相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;接口声明&quot;&gt;2.1 接口声明&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;远程服务&lt;code&gt;asp.net core&lt;/code&gt;接口示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class UsersController : ControllerBase
{
    // GET api/users
    [HttpGet]
    public UserInfo[] Get()
    {
        return new UserInfo[]
        {
            new UserInfo { Account=&quot;laojiu&quot; },
            new UserInfo { Account=&quot;webapicleint&quot; }
        };
    }

    // GET api/users/id001
    [HttpGet(&quot;{id}&quot;)]
    public UserInfo Get(string id)
    {
        return new UserInfo { Id = id, Account = &quot;laojiu&quot; };
    }

    // POST api/users
    [HttpPost]
    public bool Post([FromBody] UserInfo value)
    {
        return true;
    }

    // PUT api/users
    [HttpPut]
    public bool Put([FromBody] UserInfo value)
    {
        return true;
    }

    // PATCH api/users/id001
    [HttpPatch(&quot;{id}&quot;)]
    public bool Patch(string id, [FromBody] JsonPatchDocument&amp;lt;UserInfo&amp;gt; value)
    {
        var user = new UserInfo { Account = &quot;laojiu&quot; };
        value.ApplyTo(user);

        return true;
    }


    // DELETE api/users/id001
    [HttpDelete(&quot;{id}&quot;)]
    public bool Delete(string id)
    {
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;WebApiClient声明式调用接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[TraceFilter]
public interface IUsersApi : IHttpApi
{
    [HttpGet(&quot;api/users&quot;)]
    ITask&amp;lt;UserInfo[]&amp;gt; GetAsync();

    [HttpGet(&quot;api/users/{id}&quot;)]
    ITask&amp;lt;UserInfo&amp;gt; GetAsync(string id);

    [HttpPost(&quot;api/users&quot;)]
    ITask&amp;lt;bool&amp;gt; PostAsync([JsonContent] UserInfo value);

    [HttpPut(&quot;api/users&quot;)]
    ITask&amp;lt;bool&amp;gt; PutAsync([JsonContent] UserInfo value);

    [HttpPatch(&quot;api/users/{id}&quot;)]
    ITask&amp;lt;bool&amp;gt; PatchAsync(string id, JsonPatchDocument&amp;lt;UserInfo&amp;gt; value);

    [HttpDelete(&quot;api/users/{id}&quot;)]
    ITask&amp;lt;bool&amp;gt; DeleteAsync(string id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;webapiclient与di结合&quot;&gt;3 WebApiClient与DI结合&lt;/h2&gt;
&lt;blockquote readability=&quot;5.1976744186047&quot;&gt;
&lt;p&gt;在&lt;code&gt;asp.net core&lt;/code&gt;环境中，我们可以使用&lt;a href=&quot;https://github.com/xljiulang/WebApiClient.Extensions&quot;&gt;WebApiClient.Extensions&lt;/a&gt;项目简单WebApiClient的DI的配置，目前有DependencyInjection和HttpClientFactory的扩展等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;webapiclient.extensions.dependencyinjection&quot;&gt;3.1 WebApiClient.Extensions.DependencyInjection&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;引入nuget包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; install-package WebApiClient.Extensions.DependencyInjection &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Startup相关配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddHttpApi&amp;lt;IUsersApi&amp;gt;().ConfigureHttpApiConfig((c,p) =&amp;gt;
    {
        c.HttpHost = new Uri(&quot;https://localhost:5001/&quot;);
        c.FormatOptions.DateTimeFormat = &quot;yyyy-MM-dd HH:mm:ss.fff&quot;;
        c.LoggerFactory = p.GetRequiredService&amp;lt;ILoggerFactory&amp;gt;();
    });
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Controller&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class HomeController : Controller
{
    public async Task&amp;lt;string&amp;gt; Index([FromServices]IUsersApi usersApi)
    {
        var u = new UserInfo { Id = &quot;id001&quot;, Account = &quot;webapiclient&quot;, Password = &quot;123456&quot; };
        var doc = new JsonPatchDocument&amp;lt;UserInfo&amp;gt;();
        doc.Replace(item =&amp;gt; item.Password, &quot;888888&quot;);

        var users = await usersApi.GetAsync();
        var user = await usersApi.GetAsync(&quot;id001&quot;);
        var postState = await usersApi.PostAsync(u);
        var putState = await usersApi.PutAsync(u);
        var patchState = await usersApi.PatchAsync(&quot;id001&quot;, doc);
        var deleteState = await usersApi.DeleteAsync(&quot;id001&quot;);
        return &quot;ok&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;webapiclient.extensions.httpclientfactory&quot;&gt;3.2 WebApiClient.Extensions.HttpClientFactory&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;引入nuget包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; install-package WebApiClient.Extensions.HttpClientFactory &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Startup相关配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{   
    services.AddHttpApiTypedClient&amp;lt;IUsersApi&amp;gt;((c, p) =&amp;gt;
    {
        c.HttpHost = new Uri(&quot;https://localhost:5001/&quot;);
        c.FormatOptions.DateTimeFormat = &quot;yyyy-MM-dd HH:mm:ss.fff&quot;;
        c.LoggerFactory = p.GetRequiredService&amp;lt;ILoggerFactory&amp;gt;();
    });
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;4 总结&lt;/h2&gt;
&lt;p&gt;本文讲解了声明式客户端的概念、列表几个声明式客户端项目，同时讲解声明式客户端WebApiClient在&lt;code&gt;asp.net core&lt;/code&gt;项目中的简单使用，有关更多高级的应用，可以到WebApiClient的github上查看相关wiki。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Oct 2018 06:40:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<og:description>1 声明式RESTful客户端 声明式服务调用的客户端，常见有安卓的Retrofit、SpringCloud的Feign等，.net有Refit和WebApiClient，这些客户端都是以java或.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/9786319.html</dc:identifier>
</item>
<item>
<title>WinDbg探究CLR底层(1) - 应用程序域 - 行者小Q</title>
<link>http://www.cnblogs.com/tonqiang/p/9786163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tonqiang/p/9786163.html</guid>
<description>&lt;h3 id=&quot;一什么是应用程序域&quot;&gt;一、什么是应用程序域&lt;/h3&gt;
&lt;p&gt;操作系统由于其稳定性与可靠性的要求，都会使用隔离层，来确保运行在某个隔离层内的代码不会对其他隔扇层的代码产生影响。如Windows通过进程来实现这种隔离机制，所能的可执行代码、数据、以及其它资源都被包含在进程中，系统其他进程通常不允许对它们进行访问。同理、.NET应用程序同样也是被局限在进程内执行，但是.NET还进一步引入了另一种逻辑隔离层，也就是我们这里说的&lt;strong&gt;应用程序域(AppDomain)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;二如何查看应用程序域&quot;&gt;二、如何查看应用程序域&lt;/h3&gt;
&lt;p&gt;下面用一个例子看看应用程序域：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;

namespace Sample01
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Hello World&quot;);

            Console.ReadLine();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码是一个简单的控制台程序，没有任何逻辑。运行起来，使用WinDbg附加到进程，然后执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;0:006&amp;gt; .load sos
0:006&amp;gt; !EEVersion
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Windows\Microsoft.NET\Framework\v4.0.30319\clr.dll - 
PDB symbol for clr.dll not loaded
4.7.3190.0 retail
Workstation mode
SOS Version: 4.6.1648.0 retail build
0:006&amp;gt; !DumpDomain
The version of SOS does not match the version of CLR you are debugging.  Please
load the matching version of SOS for the version of CLR you are debugging.
CLR Version: 4.7.3190.0
SOS Version: 4.6.1648.0
--------------------------------------
System Domain:      7230d5a8
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
--------------------------------------
Shared Domain:      7230d258
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
Assembly:           00cb30e8 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00cb2bd0
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

--------------------------------------
Domain 1:           00c7f090
LowFrequencyHeap:   00c7f4fc
HighFrequencyHeap:  00c7f548
StubHeap:           00c7f594
Stage:              OPEN
SecurityDescriptor: 00c87cb0
Name:               Sample01.exe
Assembly:           00cb30e8 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00cb2bd0
SecurityDescriptor: 00cb3060
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

Assembly:           00cb6718 [E:\Workspace\DotNet\WinDbgInspectCLR\Sample01\bin\Debug\Sample01.exe]
ClassLoader:        00cb6c18
SecurityDescriptor: 00cb6b90
  Module Name
00be401c    E:\Workspace\DotNet\WinDbgInspectCLR\Sample01\bin\Debug\Sample01.exe&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;!DumpDomain&lt;/code&gt;命令输出，可以看到，这个示例执行程序所在进程中3个应用程序域，&lt;strong&gt;System&lt;/strong&gt;、&lt;strong&gt;Shared&lt;/strong&gt;、&lt;strong&gt;Domain 1&lt;/strong&gt;。其中，Domain 1是默认的应用程序域，它的名字就是映像本身的名字(Sample01.exe)。&lt;/p&gt;
&lt;p&gt;在每个应用程序域的输出消息中包含以下内容：&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;System Domain&lt;/strong&gt;： 指向应用程序域的指针。这个指针可以作为&lt;strong&gt;DumpDomain&lt;/strong&gt;命令的输入参数，以得到指定应用程序域的信息，如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;0:006&amp;gt; !DumpDomain 7230d5a8
The version of SOS does not match the version of CLR you are debugging.  Please
load the matching version of SOS for the version of CLR you are debugging.
CLR Version: 4.7.3190.0
SOS Version: 4.6.1648.0
--------------------------------------
System Domain:      7230d5a8
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;LowFrequencyHeap&lt;/strong&gt;、&lt;strong&gt;HighFrequencyHeap&lt;/strong&gt;、&lt;strong&gt;StubHeap&lt;/strong&gt;：.Net程序是建立在中间语言(&lt;strong&gt;IL&lt;/strong&gt;)的基础上的，因此，每个应用程序域都有相就的MSIL代码。在JIT编译成MSIL过程中，JIT编译器需要保存与编译过程相关的数据，如机器代码与方法表(Method Table)等。因此，每个应用程序域都需要创建一定数据的堆(Heap)来存储这些数据。LowFrequencyHeap中则保存的是一些更新、访问较少的数据，HighFrequencyHeap包含的是被访问频繁的数据，而StubHeap中包含的是CLR执行互用性调用 (例如COM互用性或者平台调用)时需要的辅助数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Name&lt;/strong&gt;：应用程序域名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Assembly&lt;/strong&gt;：在应用程序域中加载的所有程序集。从输出中来看，应用程序域Sample01.exe中加载了两个程序集：mscorlib.dll、Sample01.exe。其中更包含程序集版本、底层程序集数据结构地址，如Sample01.exe程序集的地址为&lt;code&gt;00c7f090&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;三各应用程序域的作用&quot;&gt;三、各应用程序域的作用&lt;/h3&gt;
&lt;h4 id=&quot;系统应用程序域&quot;&gt;系统应用程序域&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;创建其他两个应用程序域（共享应用程序域和默认应用程序域）。&lt;/li&gt;
&lt;li&gt;将mscorlib.dll加载到共享应用程序域中（在下面将进一步讨论）。&lt;/li&gt;
&lt;li&gt;记录进程中所有其他的应用程序域，包括提供加载/卸载应用程序域等功能。&lt;/li&gt;
&lt;li&gt;记录字符串池中的字符串常量，因此允许任意字符串在每个进程中都存在一个副本。&lt;/li&gt;
&lt;li&gt;初始化特定类型的异常，例如内存耗尽异常，栈溢出异常以及执行引擎异常等。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;共享应用程序域&quot;&gt;共享应用程序域&lt;/h4&gt;
&lt;p&gt;在共享应用程序域中包含的是与应用程序域无关的代码。mscorlib.dll将被加载到这个应用程序域中（由系统应用程序域负责加载），此外还包括在System命名空间中的一些基本类型（例如String、enum、ValueType、Array等）。在大多数情况下，非用户代码（non－user code）将被加载到共享应用程序域中，不过也有一些机制可以将用户代码（user code）加载到共享应用程序域中。启用了CLR的应用程序域可以通过加载器的优化属性来注入用户代码。&lt;/p&gt;
&lt;h4 id=&quot;默认应用程序域&quot;&gt; 默认应用程序域&lt;/h4&gt;
&lt;p&gt;通常，.NET程序在默认应用程序域中运行。位于默认应用程序域中的所有代码都只有在这个域中才是有效的。由于应用程序域实现了一种有逻辑并且可靠的边界，因此任何跨越应用程序域的访问操作都必须通过.NET远程对象来进行。&lt;/p&gt;
&lt;h3 id=&quot;四动态创建卸载应用程序域&quot;&gt;四、动态创建、卸载应用程序域&lt;/h3&gt;
&lt;p&gt;前面我们看到程序启动时，系统帮我们创建的默认应用程序域，然后手动创建应用程序域也是可以的，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;

namespace Sample02
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Before CreateDomain&quot;);
            Console.ReadLine();

            AppDomain domain = AppDomain.CreateDomain(&quot;NewDomain&quot;);
            

            Console.WriteLine(&quot;After CreateDomain, Before Unload&quot;);
            Console.ReadLine();

            AppDomain.Unload(domain);

            Console.WriteLine(&quot;After Unload&quot;);
            Console.ReadLine();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序开始运行时：&lt;/p&gt;
&lt;p&gt;有三个应用程序域：System Domain、Shared Domain、Domain 1&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;0:006&amp;gt; !DumpDomain
--------------------------------------
System Domain:      7230d5a8
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
--------------------------------------
Shared Domain:      7230d258
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
Assembly:           00df8468 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00df8520
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

--------------------------------------
Domain 1:           00dd7da0
LowFrequencyHeap:   00dd820c
HighFrequencyHeap:  00dd8258
StubHeap:           00dd82a4
Stage:              OPEN
SecurityDescriptor: 00dd0120
Name:               Sample02.exe
Assembly:           00df8468 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00df8520
SecurityDescriptor: 00dfc018
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

Assembly:           00dff8d8 [E:\Workspace\DotNet\WinDbgInspectCLR\Sample02\bin\Debug\Sample02.exe]
ClassLoader:        00dff318
SecurityDescriptor: 00dfcd60
  Module Name
00ec401c    E:\Workspace\DotNet\WinDbgInspectCLR\Sample02\bin\Debug\Sample02.exe&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按&lt;code&gt;Enter&lt;/code&gt;继续执行，多一个应用程序域Domain 2&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;0:006&amp;gt; !DumpDomain
The version of SOS does not match the version of CLR you are debugging.  Please
load the matching version of SOS for the version of CLR you are debugging.
CLR Version: 4.7.3190.0
SOS Version: 4.6.1648.0
--------------------------------------
System Domain:      7230d5a8
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
--------------------------------------
Shared Domain:      7230d258
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
Assembly:           00df8468 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00df8520
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

--------------------------------------
Domain 1:           00dd7da0
LowFrequencyHeap:   00dd820c
HighFrequencyHeap:  00dd8258
StubHeap:           00dd82a4
Stage:              OPEN
SecurityDescriptor: 00dd0120
Name:               Sample02.exe
Assembly:           00df8468 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00df8520
SecurityDescriptor: 00dfc018
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

Assembly:           00dff8d8 [E:\Workspace\DotNet\WinDbgInspectCLR\Sample02\bin\Debug\Sample02.exe]
ClassLoader:        00dff318
SecurityDescriptor: 00dfcd60
  Module Name
00ec401c    E:\Workspace\DotNet\WinDbgInspectCLR\Sample02\bin\Debug\Sample02.exe

--------------------------------------
Domain 2:           00e0cf00
LowFrequencyHeap:   00e0d36c
HighFrequencyHeap:  00e0d3b8
StubHeap:           00e0d404
Stage:              OPEN
SecurityDescriptor: 00e09fe0
Name:               NewDomain
Assembly:           00df8468 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00df8520
SecurityDescriptor: 00dfccd8
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

Assembly:           00e17398 [E:\Workspace\DotNet\WinDbgInspectCLR\Sample01\bin\Debug\Sample01.exe]
ClassLoader:        00e21d90
SecurityDescriptor: 00dfc128
  Module Name
011949f4    E:\Workspace\DotNet\WinDbgInspectCLR\Sample01\bin\Debug\Sample01.exe
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次按&lt;code&gt;Enter&lt;/code&gt;继续执行，应用程序域Domain 2中的Sample01.exe被卸载, 目前还没查到为什么Domain 2 没被整体卸载，我猜想是因为mscorlib.dll还在还在使用。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;0:006&amp;gt; !DumpDomain
The version of SOS does not match the version of CLR you are debugging.  Please
load the matching version of SOS for the version of CLR you are debugging.
CLR Version: 4.7.3190.0
SOS Version: 4.6.1648.0
--------------------------------------
System Domain:      7230d5a8
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
--------------------------------------
Shared Domain:      7230d258
LowFrequencyHeap:   7230d8cc
HighFrequencyHeap:  7230d918
StubHeap:           7230d964
Stage:              OPEN
Name:               None
Assembly:           00aa7a90 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00aa8818
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

--------------------------------------
Domain 1:           00a7f410
LowFrequencyHeap:   00a7f87c
HighFrequencyHeap:  00a7f8c8
StubHeap:           00a7f914
Stage:              OPEN
SecurityDescriptor: 00a869f0
Name:               Sample02.exe
Assembly:           00aa7a90 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00aa8818
SecurityDescriptor: 00aa7a08
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

Assembly:           00aab3b8 [E:\Workspace\DotNet\WinDbgInspectCLR\Sample02\bin\Debug\Sample02.exe]
ClassLoader:        00aab050
SecurityDescriptor: 00aab5f0
  Module Name
0097401c    E:\Workspace\DotNet\WinDbgInspectCLR\Sample02\bin\Debug\Sample02.exe

--------------------------------------
Domain 2:           00ab93d8
LowFrequencyHeap:   00ab9844
HighFrequencyHeap:  00ab9890
StubHeap:           00ab98dc
Stage:              HANDLETABLE_NOACCESS
Name:               NewDomain
Assembly:           00aa7a90 [C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll]
ClassLoader:        00aa8818
SecurityDescriptor: 00abd780
  Module Name
6a681000    C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll

Assembly:           00acdce0 []
ClassLoader:        00acde80
SecurityDescriptor: 00abcb48
  Module Name
04cf49f4    Dynamic Module
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六总结&quot;&gt;六、总结&lt;/h3&gt;
&lt;p&gt;一直听说应用程序域，但对其概念、作用不甚了解，因此结合WinDbg来试图对其进行深入理解，加深印象，后续系列会继续使用WinDbg对CLR底层进行研究。&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/5346548/&quot;&gt;《.NET高级调试》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/gaochundong/p/windbg_sos_cheat_sheet.html&quot;&gt;WinDbg 命令三部曲&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 14 Oct 2018 05:50:00 +0000</pubDate>
<dc:creator>行者小Q</dc:creator>
<og:description>一、什么是应用程序域 操作系统由于其稳定性与可靠性的要求，都会使用隔离层，来确保运行在某个隔离层内的代码不会对其他隔扇层的代码产生影响。如Windows通过进程来实现这种隔离机制，所能的可执行代码、数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tonqiang/p/9786163.html</dc:identifier>
</item>
<item>
<title>django框架--cookie/session - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9780973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9780973.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一http协议无状态问题&quot;&gt;一、http协议无状态问题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;http&lt;/code&gt;协议没有提供多次请求之间的关联功能，协议的本意也并未考虑到多次请求之间的状态维持，每一次请求都被协议认为是一次性的。但在某些场景下，如一次登录多次访问，我们希望可以保存登录状态，协议并没有直接提供会话跟踪的支持，需要靠其他手段来帮助实现目标。&lt;/p&gt;
&lt;h2 id=&quot;二会话跟踪技术--cookie&quot;&gt;二、会话跟踪技术--cookie&lt;/h2&gt;
&lt;h3 id=&quot;对cookie的理解&quot;&gt;1、对cookie的理解&lt;/h3&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;cookie&lt;/code&gt;是一个&lt;code&gt;key-value&lt;/code&gt;的数据结构（类似&lt;code&gt;python&lt;/code&gt;字典），用于保存需要维护状态的数据&lt;/strong&gt;，&lt;code&gt;cookie&lt;/code&gt;与&lt;code&gt;session&lt;/code&gt;最大的区别是&lt;code&gt;cookie&lt;/code&gt;的数据保存在客户端，而&lt;code&gt;session&lt;/code&gt;把数据保存在服务端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;cookie&lt;/code&gt;一般由服务器设置，并可以存放在&lt;code&gt;http&lt;/code&gt;的请求头和响应头中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;cookie&lt;/code&gt;由浏览器保存，浏览器已经实现了&lt;code&gt;cookie&lt;/code&gt;的保存和发送，而服务器上对&lt;code&gt;cookie&lt;/code&gt;的设置和接收则需要我们配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过&lt;code&gt;cookie&lt;/code&gt;，可以在多个会话之间共享一些必要的信息如登录状态数据、历史访问记录、个性化定制设置等，以实现会话跟踪，&lt;strong&gt;让用户感觉到网站可以'记录'自己的偏好，减少不必要的重复输入，从而提升用户体验。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;cookie的使用接口&quot;&gt;2、cookie的使用接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;的服务端发送响应有三种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. return HttpResponse()
2. return render()
3. return redirect()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三种方法实例化的结果都是&lt;code&gt;HttpResponse&lt;/code&gt;类的实例，可以直接用于设置&lt;code&gt;cookie&lt;/code&gt;。&lt;br/&gt;在&lt;code&gt;response&lt;/code&gt;对象上执行&lt;code&gt;set_cookie(key,value,...)&lt;/code&gt;即可设置&lt;code&gt;cookie&lt;/code&gt;, 其中特别注意&lt;code&gt;cookie&lt;/code&gt;属性的设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie的设置&lt;/strong&gt;&lt;br/&gt;服务器在响应对象上进行&lt;code&gt;set_cookie&lt;/code&gt;操作，一旦设置完成，客户端后续的请求就可以根据&lt;code&gt;cookie&lt;/code&gt;的属性规则携带&lt;code&gt;cookie&lt;/code&gt;数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def set_cookie(key, value='', max_age=None, expires=None, path='/',
               domain=None, secure=False, httponly=False, samesite=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cookie的获取&lt;/strong&gt;&lt;br/&gt;服务器在请求对象上通过&lt;code&gt;request.COOKIES&lt;/code&gt;得到&lt;code&gt;cookie&lt;/code&gt;字典数据，注意此处拿到的&lt;code&gt;cookie&lt;/code&gt;数据从安全性来说是未被验证正确性的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@cached_property
def COOKIES(self):
    raw_cookie = get_str_from_wsgi(self.environ, 'HTTP_COOKIE', '')
    return parse_cookie(raw_cookie)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意1：cookie在set的时候可以设置它被发送的范围，每个cookie都有对应的domain+path的属性，这约束了cookie发送范围，只有当http的请求落在此范围中的url，才会携带此cookie。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意2：一个cookie就是一个key-value项，不过它还携带有属性。一个cookies是一个字典，保存了很多cookie项，注意单个cookie项和整个cookies字典的关系。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;cookie的属性&quot;&gt;3、cookie的属性&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;max_age:
失效延迟时间，单位是秒，设置成15秒意味着在设置完之后的15秒之内，此cookie有效，超时之后cookie失效，浏览器会删除失效的cookie。此参数默认是None，代表着直到浏览器关闭，即默认是会话cookie。
注意：如果max_age是0，意味着让浏览器立刻删除此cookie，即此cookie即刻失效。
    
expires:
指定失效日期,同样用于失效cookie，只不过是另一种时间指定方式。
    
domain:
此cookie可以被使用的域名范围。
    
path:
与domain配合着使用，默认是根路径'/'，意味着在当前domain范围下任何url都会携带此cookie。可以主动设置其他的路径以缩小发送的范围，从而约束某一个cookie项只应用于某些url。
    
secure:
默认是False，一般配合https协议使用，在https协议下，只有secure属性是True的cookie才允许被发送。
    
httponly:
默认是False，这意味着js也可以通过document.cookie来访问和设置此cookie，而如果设置为True，则代表只允许服务端来访问和设置此cookie。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用cookie的问题&quot;&gt;4、使用cookie的问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;cookie的安全性问题&lt;/strong&gt;&lt;br/&gt;服务器是根据客户端发送过来的&lt;code&gt;cookie&lt;/code&gt;进行状态判断，这种保存在客户端的&lt;code&gt;cookie&lt;/code&gt;数据非常容易修改和伪装，服务器基本无法知晓&lt;code&gt;cookie&lt;/code&gt;的正确性，也就不能100%信任&lt;code&gt;cookie&lt;/code&gt;的数据。&lt;br/&gt;此外，&lt;code&gt;cookie&lt;/code&gt;很容易被盗取，如果客户端&lt;code&gt;cookie&lt;/code&gt;里面包含私密数据的话，就更不安全了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie的覆盖问题&lt;/strong&gt;&lt;br/&gt;在服务端上设置的新的&lt;code&gt;cookie&lt;/code&gt;会让客户端更新本地&lt;code&gt;cookie&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie的合理性问题&lt;/strong&gt;&lt;br/&gt;什么样的数据适合放到&lt;code&gt;cookie&lt;/code&gt;中?&lt;br/&gt;&lt;code&gt;cookie&lt;/code&gt;中的数据是每次交互都要被传输的，所以我认为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应该是常用的数据，如果不常用只会浪费带宽减少效率，最好是多次交互中都要使用或者修改&lt;/li&gt;
&lt;li&gt;应该是小数据量&lt;/li&gt;
&lt;li&gt;不应该是非常私密的数据，否则：要么在客户端上容易被盗取，要么在传输中容易被截取&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;所以cookie特别适合发送sessionid，它能满足上述所有条件。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie的存储问题&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;cookie&lt;/code&gt;是客户端临时存储，按规定单个&lt;code&gt;cookie&lt;/code&gt;文件存储量最大是&lt;code&gt;4kb&lt;/code&gt;，每个域下的&lt;code&gt;cookie&lt;/code&gt;文件不能超过20个，不应该将&lt;code&gt;cookie&lt;/code&gt;作为存储功能的滥用，要使用客户端存储功能应该启用&lt;code&gt;localstorage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cookie的访问限制问题&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;js&lt;/code&gt;的&lt;code&gt;document.cookie&lt;/code&gt;可以获取&lt;code&gt;cookie&lt;/code&gt;数据，将会在控制台输出一个字符串格式的&lt;code&gt;key-value&lt;/code&gt;数据,如果此&lt;code&gt;cookie&lt;/code&gt;的属性是&lt;code&gt;httponly=true&lt;/code&gt;就不能通过此方法获取。&lt;/p&gt;
&lt;h2 id=&quot;三会话跟踪技术--session&quot;&gt;三、会话跟踪技术--session&lt;/h2&gt;
&lt;h3 id=&quot;对session的理解&quot;&gt;1、对session的理解&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt;把数据存放在服务器上，并使用一个标签&lt;code&gt;session-key&lt;/code&gt;唯一标记此数据。&lt;code&gt;session-key&lt;/code&gt;作为&lt;code&gt;cookie&lt;/code&gt;发送给客户端，即客户端只保存&lt;code&gt;session-key&lt;/code&gt;，然后通过&lt;code&gt;cookie&lt;/code&gt;发送给服务端，以表明身份，所以&lt;code&gt;session&lt;/code&gt;比&lt;code&gt;cookie&lt;/code&gt;安全。&lt;/p&gt;
&lt;p&gt;每一次请求到达服务器的时候，服务器获取&lt;code&gt;cookie&lt;/code&gt;中保存的&lt;code&gt;session-key&lt;/code&gt;，并在数据库&lt;code&gt;django-session&lt;/code&gt;表中寻找对应的&lt;code&gt;session-data&lt;/code&gt;，进一步处理业务逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt;的使用有如下优点：&lt;br/&gt;1、数据保存在服务端，客户端仅保存一个&lt;code&gt;senssionid&lt;/code&gt;&lt;br/&gt;2、&lt;code&gt;sessionid&lt;/code&gt;数据量很小，适合每次发送&lt;br/&gt;3、安全性，&lt;code&gt;sessionid&lt;/code&gt;是一个随机字符串，不携带任何私密数据&lt;/p&gt;
&lt;h3 id=&quot;session的使用接口&quot;&gt;2、session的使用接口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;session的设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;实现了&lt;code&gt;session&lt;/code&gt;，帮我们完成了很多操作，且提供使用的接口非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;request.session['name'] = 'xxx'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置&lt;code&gt;session&lt;/code&gt;的时候会执行如下三个操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、创建一个随机字符串作为sessionid
2、把sessionid作为session-key，以及一个session_data字典加入到django-session表中
3、set-cookie,把sessionid发送给客户端&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意1：从底层源码来看，session_data其实就是一个字典{}，然后通过orm存到django_session表中(应该有dict--&amp;gt;str的序列化和加密操作)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意2：如果发现客户端的cookie中含有seesionid说明不是第一次登录，将会使用此sessionid并更新此sessionid对应的session_data数据&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意3：如果有两个用户在同一台电脑的同一个浏览器上，访问同一个url，因为sessionid是作为cookie存在，所以两个人会使用同一个sessionid。&lt;/em&gt;&lt;br/&gt;&lt;em&gt;而对于服务器而言，只认sessionid不认人，使用同一个sessionid的操作会覆盖之前的数据以导致在服务端上的session_data数据会相互覆盖，这样的结果是数据紊乱(尤其当两人的数据项目数量不一致时更严重)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;session的读取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读取&lt;code&gt;session&lt;/code&gt;的接口同样很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name = request.session['name']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取的时候会执行如下三个操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、获取request.COOKIES中的sessionid
2、拿着sessionid作为session_key到数据库的django-session表中查找对应的session-data,底层就是执行orm的objects.filter(session_key=sessionid)
3、获取session-data中的数据并进一步处理&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;session的删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除&lt;code&gt;session&lt;/code&gt;的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、del request.session[xxx]   # 删除一个会话数据属性
2、request.session.flush()    # 删除所有会话数据&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清空会话信息时会执行如下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、删除django-session表中的session-key=sessionid的记录，底层操作就是执行orm的objects.filter(session_key=sessionid).delete()
2、删除response中的cookie里的sessionid记录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意1：服务器把sessionid作为cookie的数据发给客户端保存，一般是会话cookie即不关闭浏览器程序就可以一直保持会话跟踪。但一旦客户端关闭了浏览器，则此sessionid便不再有效。但django颁发的cookie默认有效时间是2周，所以cookie会被保存到客户端硬盘上，即使关闭了浏览器也继续保存。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意2：因为服务器无法获知客户端浏览器将会在什么时候关闭，更无法获知浏览器什么时候会执行清空cookie的操作。客户端一般只有在logout的时候才会主动告知删除session，其他情况下浏览器不会主动告知，所以服务器的session不能无限保存，被迫要设置失效时间（不然存储空间浪费），在一定时间内如果还没有用户重新访问此session，便被服务端认为此用户已失效，进而可以删除session数据。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;session的属性&quot;&gt;3、session的属性&lt;/h3&gt;
&lt;p&gt;settings中还可以配置全局的session属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# settings.py文件

    SESSION_ENGINE = 'django.contrib.sessions.backends.db'   # 引擎（默认）
    SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）
    SESSION_COOKIE_PATH ＝ &quot;/&quot;                               # Session的cookie保存的路径（默认）
    SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）
    SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）
    SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）
    SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）
    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）
    SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用session的问题&quot;&gt;4、使用session的问题&lt;/h3&gt;
&lt;p&gt;1、&lt;code&gt;session&lt;/code&gt;的正常工作依赖于&lt;code&gt;cookie&lt;/code&gt;的启用，如果客户端禁用&lt;code&gt;cookie&lt;/code&gt;功能，该如何保证&lt;code&gt;session&lt;/code&gt;正常工作？---重写URL&lt;/p&gt;
&lt;p&gt;2、同一台电脑同一个浏览器，访问同一个&lt;code&gt;url&lt;/code&gt;，保存着同一个&lt;code&gt;sessionid&lt;/code&gt;，如何处理多用户使用同一&lt;code&gt;sessionid&lt;/code&gt;登录而导致的数据紊乱问题？---使用用户认证组件，使用账户密码来区别用户&lt;/p&gt;
&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;1、cookie和session都是为了解决http协议自身并不支持状态维持的缺点。&lt;br/&gt;2、会话跟踪的目的是为了让多次请求之间可以共享数据，以提供更好的用户体验。&lt;br/&gt;3、cookie和session都需要保存&lt;strong&gt;状态维持数据&lt;/strong&gt;，只不过cookie是保存在客户端，session是保存在服务端。&lt;br/&gt;4、分析和研究两者的技术相同点和区别有助于加深对会话跟踪的理解和使用。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Oct 2018 05:25:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<og:description>[TOC] 一、http协议无状态问题 协议没有提供多次请求之间的关联功能，协议的本意也并未考虑到多次请求之间的状态维持，每一次请求都被协议认为是一次性的。但在某些场景下，如一次登录多次访问，我们希望</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9780973.html</dc:identifier>
</item>
<item>
<title>HyperLedger Fabric 1.2 生产环境使用ca生成msp和tls（12） - 灵·龙</title>
<link>http://www.cnblogs.com/llongst/p/9786024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/llongst/p/9786024.html</guid>
<description>
&lt;p&gt;&lt;span&gt;       在上一章：Fabric kafka生产环境部署的基础上部署Fabric CA，使用Fabric CA进行生成公私钥和证书等文件，全部替换cryptogen工具，包括生成TLS相关的私钥和证书等文件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       Fabric kafka生产环境部署有三个组织，分别为orderer（排序）组织和两个Peer(节点)组织，对应的ID为example.com、org1.example.com和org2.example.com。为了让生产环境Fabric CA具有扩展性和安全性，存在一个逻辑的根CA（RootCA）和三个中间CA（Intermedia CA），三个中间CA（Intermedia CA）都隶属根CA（RootCA）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       三个中间CA（Intermedia CA）分别负责orderer（排序）组织和两个Peer(节点)组织的公私钥和证书生成。当有新的组织加入，只需再生成一个中间CA（Intermedia CA）接入到根CA（RootCA）下，不会影响其它中间CA（Intermedia CA），生产环境CA网络拓扑图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/544703/201810/544703-20181014130346794-1289725875.jpg&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;382&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       根据生产环境CA网络拓扑图，实现生产环境CA的部署及生成上一章：Fabric kafka生产环境部署所需要公私钥、证书及TLS证书等文件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;生产环境CA部署到上一章：Fabric kafka生产环境部署的kafka3（192.168.235.6）服务器上；由于四CA都在同一台电脑，端口号不能使用同一个，对应的端口号如下表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544703/201810/544703-20181014130210755-99031849.jpg&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行和配置步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(一) CA服务启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. RootCA启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 创建目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd $GOPATH/src/github.com/hyperledger/fabric-ca/&lt;span&gt;bin
# mkdir ca&lt;/span&gt;-&lt;span&gt;server
# cd ca&lt;/span&gt;-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin:adminpw --home ./rootca
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin:adminpw --home ./rootca --cfg.affiliations.allowremove --cfg.identities.allowremove
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-rootca.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-rootca.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. IntermediaCA1启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin1:adminpw1 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediaca1&lt;/span&gt;
# vi ./intermediaca1/fabric-ca-server-&lt;span&gt;config.yaml
修改
port: &lt;/span&gt;&lt;span&gt;7055&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin1:adminpw1 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediaca1 --cfg.affiliations.allowremove --cfg.identities.allowremove&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-intermediaca1.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-intermediaca1.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. IntermediaCAtls1启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin1:adminpw1 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediacatls1&lt;/span&gt;
# vi ./intermediacatls1/fabric-ca-server-&lt;span&gt;config.yaml
修改
port: &lt;/span&gt;&lt;span&gt;8055&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin1:adminpw1 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediacatls1 --cfg.affiliations.allowremove --cfg.identities.allowremove&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-intermediaca1.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-intermediacatls1.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. IntermediaCA2启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin2:adminpw2 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediaca2&lt;/span&gt;
# vi ./intermediaca2/fabric-ca-server-&lt;span&gt;config.yaml
修改
port:&lt;/span&gt;&lt;span&gt;7056&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin2:adminpw2 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediaca2 --cfg.affiliations.allowremove --cfg.identities.allowremove&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-intermediaca2.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-intermediaca2.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5. IntermediaCAtls2启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin2:adminpw2 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediacatls2&lt;/span&gt;
# vi ./intermediacatls2/fabric-ca-server-&lt;span&gt;config.yaml
修改
port:&lt;/span&gt;&lt;span&gt;8056&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin2:adminpw2 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediacatls2 --cfg.affiliations.allowremove --cfg.identities.allowremove&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-intermediaca2.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-intermediacatls2.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6. IntermediaCA3启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin3:adminpw3 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediaca3&lt;/span&gt;
# vi ./intermediaca3/fabric-ca-server-&lt;span&gt;config.yaml
修改
port: &lt;/span&gt;&lt;span&gt;7057&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin3:adminpw3 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediaca3 --cfg.affiliations.allowremove --cfg.identities.allowremove&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-intermediaca3.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-intermediaca3.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;7. IntermediaCAtls3启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 初始化CA服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server init -b admin3:adminpw3 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediacatls3&lt;/span&gt;
# vi ./intermediacatls3/fabric-ca-server-&lt;span&gt;config.yaml
修改
port: &lt;/span&gt;&lt;span&gt;8057&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 启动CA服务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【命令行启动】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# fabric-ca-server start -b admin3:adminpw3 -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin:adminpw@localhost:7054 --home ./intermediacatls3 --cfg.affiliations.allowremove --cfg.identities.allowremove&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【docker启动】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;拷贝文件docker-intermediaca3.yml到ca-server目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# docker-compose -f docker-intermediacatls3.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(二) IntermediaCA1生成证书&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 生成example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 登记example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# cd /opt/gopath/src/github.com/hyperledger/fabric-ca/bin/ca-&lt;span&gt;server
# fabric&lt;/span&gt;-ca-client enroll -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 添加联盟成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# fabric-ca-client affiliation list -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org1 -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org2 -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 生成Admin@example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name Admin@example.com --id.type client --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Admin@example.com:123456@localhost:7055 --csr.cn=example.com --csr.hosts=['example.com'] -M ./crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/&lt;span&gt;admincerts
# mkdir .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 生成orderer0.example.com的msp和tls&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册orderer0.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name orderer0.example.com --id.type orderer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=orderer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=orderer0.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderer0.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记orderer0.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orderer0.example.com:123456@localhost:7055 --csr.cn=orderer0.example.com --csr.hosts=['orderer0.example.com'] -M ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 生成orderer1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册orderer1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name orderer1.example.com --id.type orderer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=orderer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=orderer1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderer1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记orderer1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orderer1.example.com:123456@localhost:7055 --csr.cn=orderer1.example.com --csr.hosts=['orderer1.example.com'] -M ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5. 生成orderer2.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册orderer2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name orderer2.example.com --id.type orderer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=orderer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=orderer2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderer2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:7055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记orderer2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orderer2.example.com:123456@localhost:7055 --csr.cn=orderer2.example.com --csr.hosts=['orderer2.example.com'] -M ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(三) IntermediaCAtls1生成证书&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 生成example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 登记example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# cd /opt/gopath/src/github.com/hyperledger/fabric-ca/bin/ca-&lt;span&gt;server
# fabric&lt;/span&gt;-ca-client enroll -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 添加联盟成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# fabric-ca-client affiliation list -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org1 -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org2 -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 生成Admin@example.com的tls&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name Admin@example.com --id.type client --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Admin@example.com:123456@localhost:8055 --csr.cn=example.com --csr.hosts=['example.com'] -M ./crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8055&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls/&lt;span&gt;client.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/users/Admin@example.com/tls/client.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 生成orderer0.example.com的msp和tls&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册orderer0.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name orderer0.example.com --id.type orderer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=orderer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=orderer0.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderer0.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记orderer0.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orderer0.example.com:123456@localhost:8055 --csr.cn=orderer0.example.com --csr.hosts=['orderer0.example.com'] -M ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8055&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 生成orderer1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册orderer1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name orderer1.example.com --id.type orderer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=orderer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=orderer1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderer1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记orderer1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orderer1.example.com:123456@localhost:8055 --csr.cn=orderer1.example.com --csr.hosts=['orderer1.example.com'] -M ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8055&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5. 生成orderer2.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册orderer2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name orderer2.example.com --id.type orderer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=orderer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=orderer2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderer2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/ordererOrganizations/example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin1:adminpw1@localhost:8055 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记orderer2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;orderer2.example.com:123456@localhost:8055 --csr.cn=orderer2.example.com --csr.hosts=['orderer2.example.com'] -M ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8055&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(四) IntermediaCA2生成证书&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 生成org1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 登记org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll --csr.cn=org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 添加联盟成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# fabric-ca-client affiliation list -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org1 -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org2 -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example.org1 -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 生成Admin@example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name Admin@org1.example.com --id.type client --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Admin@org1.example.com:123456@localhost:7056 --csr.cn=org1.example.com --csr.hosts=['org1.example.com'] -M ./crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/&lt;span&gt;admincerts
# mkdir .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 生成peer0.org1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer0.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer0.org1.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer0.org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer0.org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer0.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer0.org1.example.com:123456@localhost:7056 --csr.cn=peer0.org1.example.com --csr.hosts=['peer0.org1.example.com'] -M ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 生成peer1.org1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer1.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer1.org1.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer1.org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer1.org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:7056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer1.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer1.org1.example.com:123456@localhost:7056 --csr.cn=peer1.org1.example.com --csr.hosts=['peer1.org1.example.com'] -M ./crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(五) IntermediaCAtls2生成证书&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 生成org1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 登记org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll --csr.cn=org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 添加联盟成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# fabric-ca-client affiliation list -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org1 -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org2 -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example.org1 -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 生成Admin@example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name Admin@org1.example.com --id.type client --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Admin@org1.example.com:123456@localhost:8056 --csr.cn=org1.example.com --csr.hosts=['org1.example.com'] -M ./crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8056&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls/&lt;span&gt;client.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/tls/client.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 生成peer0.org1.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer0.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer0.org1.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer0.org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer0.org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer0.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer0.org1.example.com:123456@localhost:8056 --csr.cn=peer0.org1.example.com --csr.hosts=['peer0.org1.example.com'] -M ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8056&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 生成peer1.org1.example.com的tls&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer1.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer1.org1.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer1.org1.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer1.org1.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org1.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin2:adminpw2@localhost:8056 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer1.org1.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer1.org1.example.com:123456@localhost:8056 --csr.cn=peer1.org1.example.com --csr.hosts=['peer1.org1.example.com'] -M ./crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8056&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(六) IntermediaCA3生成证书&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 生成org2.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 登记org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll --csr.cn=org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 添加联盟成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# fabric-ca-client affiliation list -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org1 -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org2 -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example.org2 -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 生成Admin@example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name Admin@org2.example.com --id.type client --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Admin@org2.example.com:123456@localhost:7057 --csr.cn=org2.example.com --csr.hosts=['org2.example.com'] -M ./crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/&lt;span&gt;admincerts
# mkdir .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 生成peer0.org2.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer0.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer0.org2.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer0.org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer0.org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer0.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer0.org2.example.com:123456@localhost:7057 --csr.cn=peer0.org2.example.com --csr.hosts=['peer0.org2.example.com'] -M ./crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp/&lt;span&gt;admincerts
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;.    生成peer1.org2.example.com的msp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1） 注册peer1.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer1.org2.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer1.org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer1.org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/msp -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:7057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer1.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer1.org2.example.com:123456@localhost:7057 --csr.cn=peer1.org2.example.com --csr.hosts=['peer1.org2.example.com'] -M ./crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成msp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# mkdir ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/&lt;span&gt;admincerts
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/admincerts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(七) IntermediaCAtls3生成证书&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. 生成org2.example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 登记org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll --csr.cn=org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 添加联盟成员&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# fabric-ca-client affiliation list -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org1 -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation remove --force org2 -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
# fabric-ca-client affiliation add com.example.org2 -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 生成Admin@example.com的msp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name Admin@org2.example.com --id.type client --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;hf.Registrar.Roles=client,orderer,peer,user&quot;,&quot;hf.Registrar.DelegateRoles=client,orderer,peer,user&quot;,hf.Registrar.Attributes=*,hf.GenCRL=true,hf.Revoker=true,hf.AffiliationMgr=true,hf.IntermediateCA=true,role=admin:ecert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2） 登记Admin@example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Admin@org2.example.com:123456@localhost:8057 --csr.cn=org2.example.com --csr.hosts=['org2.example.com'] -M ./crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8057&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls/&lt;span&gt;client.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/tls/client.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 生成peer0.org2.example.com的tls&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer0.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer0.org2.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer0.org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer0.org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer0.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer0.org2.example.com:123456@localhost:8057 --csr.cn=peer0.org2.example.com --csr.hosts=['peer0.org2.example.com'] -M ./crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8057&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 生成peer1.org2.example.com的tls&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1） 注册peer1.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# fabric-ca-client register --id.name peer1.org2.example.com --id.type peer --id.affiliation &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.example.org2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --id.attrs &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;role=peer&quot;,ecert=true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --id.secret=&lt;span&gt;123456&lt;/span&gt; --csr.cn=peer1.org2.example.com --csr.hosts=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peer1.org2.example.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -M ./crypto-config/peerOrganizations/org2.example.com/tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;admin3:adminpw3@localhost:8057 --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2） 登记peer1.org2.example.com&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# fabric-ca-client enroll -d --enrollment.profile tls -u http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;peer1.org2.example.com:123456@localhost:8057 --csr.cn=peer1.org2.example.com --csr.hosts=['peer1.org2.example.com'] -M ./crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls --home ./fabric-ca-client&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3） 生成tls&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# cp ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/tlsintermediatecerts/tls-localhost-&lt;span&gt;8057&lt;/span&gt;.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/&lt;span&gt;ca.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/signcerts/cert.pem ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/&lt;span&gt;server.crt
# cp .&lt;/span&gt;/fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/keystore/xxxxxxx_sk ./fabric-ca-client/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/server.key
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Oct 2018 04:59:00 +0000</pubDate>
<dc:creator>灵&amp;#183;龙</dc:creator>
<og:description>在上一章：Fabric kafka生产环境部署的基础上部署Fabric CA，使用Fabric CA进行生成公私钥和证书等文件，全部替换cryptogen工具，包括生成TLS相关的私钥和证书等文件。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/llongst/p/9786024.html</dc:identifier>
</item>
<item>
<title>通过源码浅析Java中的资源加载 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9785944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9785944.html</guid>
<description>&lt;p&gt;最近在做一个基础组件项目刚好需要用到JDK中的资源加载，这里说到的资源包括类文件和其他静态资源，刚好需要重新补充一下类加载器和资源加载的相关知识，整理成一篇文章。&lt;/p&gt;

&lt;p&gt;这一节主要分析类加载器和双亲委派模型。&lt;/p&gt;
&lt;h2 id=&quot;什么是类加载器&quot;&gt;什么是类加载器&lt;/h2&gt;
&lt;p&gt;虚拟机设计团队把类加载阶段中的&quot;通过一个类的全限定名来获取描述此类的二进制字节流&quot;这个动作放到了Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，而实现这个动作的代码模块称为&quot;类加载器(ClassLoader)&quot;。&lt;/p&gt;
&lt;p&gt;类加载器虽然只用于实现类加载的功能，但是它在Java程序中起到的作用不局限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立类在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。上面这句话直观来说就是：比较两个类是否&quot;相等&quot;，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这个两个类是来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必然&quot;不相等&quot;。这里说到的&quot;相等&quot;包括代表类的Class对象的&lt;code&gt;equals()&lt;/code&gt;方法、&lt;code&gt;isAssignableFrom()&lt;/code&gt;方法、&lt;code&gt;isInstance()&lt;/code&gt;方法的返回结果，也包括使用&lt;code&gt;instanceOf&lt;/code&gt;关键字做对象所属关系判定等情况。&lt;/p&gt;
&lt;p&gt;类和加载它的类加载器确定类在Java虚拟机中的唯一性这个特点为后来出现的热更新类、热部署等技术提供了基础。&lt;/p&gt;
&lt;h2 id=&quot;双亲委派模型&quot;&gt;双亲委派模型&lt;/h2&gt;
&lt;p&gt;从Java虚拟机的角度来看，只有两种不同的类加载器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、第一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++编程语言实现，是虚拟机的一部分。&lt;/li&gt;
&lt;li&gt;2、另一种是其他的类加载器，这些类加载器都是由Java语言实现，独立于虚拟机之外，一般就是内部于JDK中，它们都继承自抽象类加载器java.lang.ClassLoader。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JDK中提供几个系统级别的类加载器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、启动类加载器(Bootstrap ClassLoader)：这个类加载器负责将存放在${JAVA_HONE}\lib目录中，或者被XbootstrapPath参数所指定的目录中，并且是虚拟机基于一定规则(如文件名称规则，如rt.jar)标识的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，开发者在编写自定义类加载器如果想委派到启动类加载器只需直接使用null替代即可。&lt;/li&gt;
&lt;li&gt;2、扩展类加载器(Extension ClassLoader)：这个类加载器由sun.misc.Launcher的静态内部类ExtClassLoader实现，它负责加载${JAVA_HONE}\lib\ext目录中，或者通过java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用此类加载器。&lt;/li&gt;
&lt;li&gt;3、应用程序类加载器(Application ClassLoader)：这个类加载器由sun.misc.Launcher的静态内部类AppClassLoader实现，但是由于这个类加载器的实例是ClassLoader中静态方法&lt;code&gt;getSystemClassLoader()&lt;/code&gt;中的返回值，一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自实现的类加载器，一般情况下这个系统类加载器就是应用程序中默认使用的类加载器。&lt;/li&gt;
&lt;li&gt;4、线程上下文类加载器(Thread Context ClassLoader)：这个在下一小节&quot;破坏双亲委派模型&quot;再分析。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java开发者开发出来的Java应用程序都是由上面四种类加载器相互配合进行类加载的，如果有必要还可以加入自定义的类加载器。其中，启动类加载器、扩展类加载器、应用程序类加载器和自定义类加载器之间存在着一定的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/r-l-1.png&quot; alt=&quot;r-l-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示的类加载器之间的层次关系称为双亲委派模型(Parents Delegation Model)。双亲委派模型要求除了顶层的类加载器(Java中顶层的类加载器一般是Bootstrap ClassLoader)，其他的类加载器都应当有自己的父类加载器。这些类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是通过组合(Composition)的关系实现。类加载器层次关系这一点可以通过下面的代码验证一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {

    public static void main(String[] args) throws Exception{
        ClassLoader classLoader = Main.class.getClassLoader();
        System.out.println(classLoader);
        System.out.println(classLoader.getParent());
        System.out.println(classLoader.getParent().getParent());
    }
}

//输出结果，最后的null说明是Bootstrap ClassLoader
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@4629104a
null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双亲委派模型的工作机制：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成当前的类加载请求的时候(也就是在它的搜索范围中没有找到所需要的类)，子类加载器才会尝试自己去加载类。&lt;strong&gt;不过这里有一点需要注意，每一个类加载器都会缓存已经加载过的类，也就是重复加载一个已经存在的类，那么就会从已经加载的缓存中加载，如果从当前类加载的缓存中判断类已经加载过，那么直接返回，否则会委派类加载请求到父类加载器。这个缓存机制在AppClassLoader和ExtensionClassLoader中都存在，至于BootstrapClassLoader未知。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/r-l-2.png&quot; alt=&quot;r-l-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双亲委派模型的优势：使用双亲委派模型来组织类加载器之间的关系，一个比较显著的优点是Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。例如&lt;code&gt;java.lang&lt;/code&gt;包中的类库，它存放在&lt;code&gt;rt.jar&lt;/code&gt;中，无论使用哪一个类加载加载&lt;code&gt;java.lang&lt;/code&gt;包中的类，最终都是委派给处于模型顶层的启动类加载器进行加载，因此&lt;code&gt;java.lang&lt;/code&gt;包中的类如&lt;code&gt;java.lang.Object&lt;/code&gt;类在应用程序中的各类加载器环境中加载的都是同一个类。试想，如果可以使用用户自定义的ClassLoader去加载&lt;code&gt;java.lang.Object&lt;/code&gt;，那么用户应用程序中就会出现多个&lt;code&gt;java.lang.Object&lt;/code&gt;类，Java类型体系中最基础的类型也有多个，类型体系的基础行为无法保证，应用程序也会趋于混乱。如果尝试编写&lt;code&gt;rt.jar&lt;/code&gt;中已经存在的同类名的类通过自定义的类加载进行加载，将会接收到虚拟机抛出的异常。&lt;/p&gt;
&lt;p&gt;双亲委派模型的实现：类加载器双亲委派模型的实现提现在ClassLoader的源码中，主要是&lt;code&gt;ClassLoader#loadClass()&lt;/code&gt;中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}

protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{
        synchronized (getClassLoadingLock(name)) {
        // First, check if the class has already been loaded
        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                //父加载器不为null，说明父加载器不是BootstrapClassLoader
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    //父加载器为null，说明父加载器是BootstrapClassLoader
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // ClassNotFoundException thrown if class not found
                // from the non-null parent class loader
            }
            //所有的父加载加载失败,则使用当前的类加载器进行类加载
            if (c == null) {
                // If still not found, then invoke findClass in order
                // to find the class.
                long t1 = System.nanoTime();
                c = findClass(name);
                //记录一些统计数据如加载耗时、计数等
                // this is the defining class loader; record the stats
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;破坏双亲委派模型&quot;&gt;破坏双亲委派模型&lt;/h2&gt;
&lt;p&gt;双亲委派模型在Java发展历史上出现了三次比较大&quot;被破坏&quot;的情况:&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1、ClassLoader在JDK1.0已经存在，JDK1.2为了引入双亲委派模型并且需要向前兼容，java.lang.ClassLoader类添加了一个新的protected的&lt;code&gt;findClass()&lt;/code&gt;方法，在这之前，用户去继承java.lang.ClassLoader只能重写其&lt;code&gt;loadClass()&lt;/code&gt;方法才能实现自己的目标。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;2、双亲委派模型自身存在缺陷：双亲委派很好地解决了各个类加载器的基础类的加载的统一问题(越基础的类由越上层的类加载器加载)，这些所谓的基础类就是大多数情况下作为用户调用的基础类库和基础API，但是无法解决这些基础类需要回调用户的代码这一个问题，典型的例子就是JNDI。JNDI的类库代码是启动类加载器加载的，但是它需要调用独立厂商实现并且部署在应用的ClassPath的JNDI的服务接口提供者(SPI，即是Service Provider Interface)的代码，但是启动类加载器无法加载ClassPath下的类库。为了解决这个问题，Java设计团队引入了不优雅的设计：线程上下文类加载器(Thread Context ClassLoader)，这个类加载器可以通过java.lang.Thread类的&lt;code&gt;setContextClassLoader()&lt;/code&gt;设置，这样子，JNDI服务就可以使用线程上下文类加载器去加载所需的SPI类库，但是父类加载器中请求子类加载器去加载类这一点已经打破了双亲委派模型。目前，JNDI、JDBC、JCE、JAXB和JBI等模块都是通过此方式实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;3、基于用户对应用程序动态性的热切追求：如代码热替换(HotSwap)、热模块部署等，说白了就是希望应用程序能像我们的计算机外设那样可以热插拔，因此催生出&lt;code&gt;JSR-291&lt;/code&gt;以及它的业界实现OSGi，而OSGi定制了自己的类加载规则，不再遵循双亲委派模型，因此它可以通过自定义的类加载器机制轻易实现模块的热部署。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前边花大量的篇幅去分析类加载器的预热知识，是因为JDK中的资源加载依赖于类加载器(其实类文件本来就是资源文件的一种，类加载的过程也是资源加载的过程)。这里先列举出JDK中目前常用的资源(Resource)加载的API，先看ClassLoader中提供的方法。&lt;/p&gt;
&lt;h2 id=&quot;classloader提供的资源加载api&quot;&gt;ClassLoader提供的资源加载API&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1.实例方法

public URL getResource(String name)

//这个方法仅仅是调用getResource(String name)返回URL实例直接调用URL实例的openStream()方法
public InputStream getResourceAsStream(String name)

//这个方法是getResource(String name)方法的复数版本
public Enumeration&amp;lt;URL&amp;gt; getResources(String name) throws IOException

//2.静态方法

public static URL getSystemResource(String name)

//这个方法仅仅是调用getSystemResource(String name)返回URL实例直接调用URL实例的openStream()方法
public static InputStream getSystemResourceAsStream(String name)

//这个方法是getSystemResources(String name)方法的复数版本
public static Enumeration&amp;lt;URL&amp;gt; getSystemResources(String name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总的来看，只有两个方法需要分析：&lt;code&gt;getResource(String name)&lt;/code&gt;和&lt;code&gt;getSystemResource(String name)&lt;/code&gt;。查看&lt;code&gt;getResource(String name)&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public URL getResource(String name) {
    URL url;
    if (parent != null) {
        url = parent.getResource(name);
    } else {
        url = getBootstrapResource(name);
    }
    if (url == null) {
        url = findResource(name);
    }
    return url;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是否似曾相识?这里明显就是使用了类加载过程中类似的双亲委派模型进行资源加载，这个方法在API注释中描述通常用于加载数据资源如images、audio、text等等，资源名称需要使用路径分隔符'/'。&lt;code&gt;getResource(String name)&lt;/code&gt;方法中查找的根路径我们可以通过下面方法验证：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ResourceLoader {

    public static void main(String[] args) throws Exception {
        ClassLoader classLoader = ResourceLoader.class.getClassLoader();
        URL resource = classLoader.getResource(&quot;&quot;);
        System.out.println(resource);
    }
}

//输出：file:/D:/Projects/rxjava-seed/target/classes/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显输出的结果就是&lt;strong&gt;当前应用的ClassPath&lt;/strong&gt;，总结来说：&lt;code&gt;ClassLoader#getResource(String name)&lt;/code&gt;是基于用户应用程序的ClassPath搜索资源，资源名称必须使用路径分隔符'/'去分隔目录，但是不能以'/'作为资源名的起始，也就是不能这样使用：&lt;code&gt;classLoader.getResource(&quot;/img/doge.jpg&quot;)&lt;/code&gt;。接着我们再看一下&lt;code&gt;ClassLoader#getSystemResource(String name)&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static URL getSystemResource(String name) {
    //实际上Application ClassLoader一般不会为null
    ClassLoader system = getSystemClassLoader();
    if (system == null) {
        return getBootstrapResource(name);
    }
    return system.getResource(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法优先使用应用程序类加载器进行资源加载，如果应用程序类加载器为null(其实这种情况很少见)，则使用启动类加载器进行资源加载。如果应用程序类加载器不为null的情况下，它实际上退化为&lt;code&gt;ClassLoader#getResource(String name)&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;总结一下：ClassLoader提供的资源加载的方法中的核心方法是&lt;code&gt;ClassLoader#getResource(String name)&lt;/code&gt;，它是基于用户应用程序的ClassPath搜索资源，遵循&quot;资源加载的双亲委派模型&quot;，资源名称必须使用路径分隔符'/'去分隔目录，但是不能以'/'作为资源名的起始字符，其他几个方法都是基于此方法进行衍生，添加复数操作等其他操作。&lt;code&gt;getResource(String name)&lt;/code&gt;方法不会显示抛出异常，当资源搜索失败的时候，会返回null。&lt;/p&gt;
&lt;h2 id=&quot;class提供的资源加载api&quot;&gt;Class提供的资源加载API&lt;/h2&gt;
&lt;p&gt;java.lang.Class中也提供了资源加载的方法，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public java.net.URL getResource(String name) {
    name = resolveName(name);
    ClassLoader cl = getClassLoader0();
    if (cl==null) {
        // A system class.
        return ClassLoader.getSystemResource(name);
    }
    return cl.getResource(name);
}

public InputStream getResourceAsStream(String name) {
    name = resolveName(name);
    ClassLoader cl = getClassLoader0();
    if (cl==null) {
        // A system class.
        return ClassLoader.getSystemResourceAsStream(name);
    }
    return cl.getResourceAsStream(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的源码来看，&lt;code&gt;Class#getResource(String name)&lt;/code&gt;和&lt;code&gt;Class#getResourceAsStream(String name)&lt;/code&gt;分别比&lt;code&gt;ClassLoader#getResource(String name)&lt;/code&gt;和&lt;code&gt;ClassLoader#getResourceAsStream(String name)&lt;/code&gt;只多了一步，就是搜索之前先进行资源名称的预处理&lt;code&gt;resolveName(name)&lt;/code&gt;，我们重点看这个方法做了什么：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private String resolveName(String name) {
    if (name == null) {
        return name;
    }
    if (!name.startsWith(&quot;/&quot;)) {
        Class&amp;lt;?&amp;gt; c = this;
        while (c.isArray()) {
            c = c.getComponentType();
        }
        String baseName = c.getName();
        int index = baseName.lastIndexOf('.');
        if (index != -1) {
            name = baseName.substring(0, index).replace('.', '/')
                    +&quot;/&quot;+name;
         }
    } else {
         name = name.substring(1);
    }
    return name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逻辑相对比较简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、如果资源名称以'/'开头，那么直接去掉'/'，这个时候的资源查找实际上退化为ClassPath中的资源查找。&lt;/li&gt;
&lt;li&gt;2、如果资源名称不以'/'开头，那么解析出当前类的实际类型(因为当前类有可能是数组)，取出类型的包路径，替换包路径中的'.'为'/'，再拼接原来的资源名称。举个例子：&quot;club.throwable.Main.class&quot;中调用了&lt;code&gt;Main.class.getResource(&quot;doge.jpg&quot;)&lt;/code&gt;，那么这个调用的处理资源名称的结果就是&lt;code&gt;club/throwable/doge.jpg&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小结：如果看过我之前写过的一篇URL和URI相关的文章就清楚，实际上&lt;code&gt;Class#getResource(String name)&lt;/code&gt;和&lt;code&gt;Class#getResourceAsStream(String name)&lt;/code&gt;的资源名称处理类似于相对URL的处理，而&quot;相对URL的处理&quot;的根路径就是应用程序的ClassPath。如果资源名称以'/'开头，那么相当于从ClassPath中加载资源，如果资源名称不以'/'开头，那么相当于基于当前类的实际类型的包目录下加载资源。&lt;/p&gt;
&lt;p&gt;实际上类似这样的资源加载方式在File类中也存在，这里就不再展开。&lt;/p&gt;

&lt;p&gt;理解JDK中的资源加载方式有助于编写一些通用的基础组件，像Spring里面的ResourceLoader、ClassPathResource这里比较实用的工具也是基于JDK资源加载的方式编写出来。下一篇博文《浅析JDK中ServiceLoader的源码》中的主角ServiceLoader就是基于类加载器的功能实现，它也是SPI中的服务类加载的核心类。&lt;/p&gt;
&lt;p&gt;说实话，类加载器的&quot;双亲委派模型&quot;和&quot;破坏双亲委派模型&quot;是常见的面试题相关内容，这里可以简单列举两个面试题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、谈谈对类加载器的&quot;双亲委派模型&quot;的理解。&lt;/li&gt;
&lt;li&gt;2、为什么要引入线程上下文类加载器(或者是对于问题1有打破这个模型的案例吗)?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;希望这篇文章能帮助你理解和解决这两个问题。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《深入理解Java虚拟机第二版》&lt;/li&gt;
&lt;li&gt;JavaSE-8源码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(本文完 c-1-d e-20181014)&lt;/p&gt;
</description>
<pubDate>Sun, 14 Oct 2018 04:31:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 最近在做一个基础组件项目刚好需要用到JDK中的资源加载，这里说到的资源包括类文件和其他静态资源，刚好需要重新补充一下类加载器和资源加载的相关知识，整理成一篇文章。 理解类的工作原理 这一节主要分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9785944.html</dc:identifier>
</item>
<item>
<title>我所理解的Android组件化之通信机制 - cryAllen</title>
<link>http://www.cnblogs.com/cr330326/p/9785894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr330326/p/9785894.html</guid>
<description>&lt;p&gt;之前写过一篇关于Android组件化的文章，&lt;a href=&quot;https://www.jianshu.com/p/1c5afe686d75&quot;&gt;《Android组件化框架设计与实践》&lt;/a&gt;，之前没看过的小伙伴可以先点击阅读。那篇文章是从实战中进行总结得来，是公司的一个真实项目进行组件化架构改造，粒度会分的更粗些，是对整体架构实践进行相应的总结，里面说了要打造一个组件化框架的话，需要从以下7个方面入手：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码解耦。如何将一个庞大的工程分成有机的整体？&lt;/li&gt;
&lt;li&gt;组件单独运行。因为每个组件都是高度内聚的，是一个完整的整体，如何让其单独运行和调试？&lt;/li&gt;
&lt;li&gt;组件间通信。由于每个组件具体实现细节都互相不了解，但每个组件都需要给其他调用方提供服务，那么主项目与组件、组件与组件之间如何通信就变成关键？&lt;/li&gt;
&lt;li&gt;UI 跳转。UI 跳转指的是特殊的数据传递，跟组件间通信区别有什么不同？&lt;/li&gt;
&lt;li&gt;组件生命周期。这里的生命周期指的是组件在应用中存在的时间，组件是否可以做到按需、动态使用、因此就会涉及到组件加载、卸载等管理问题。&lt;/li&gt;
&lt;li&gt;集成调试。在开发阶段如何做到按需编译组件？一次调试中可能有一两个组件参与集成，这样编译时间就会大大降低，提高开发效率。&lt;/li&gt;
&lt;li&gt;代码隔离。组件之间的交互如果还是直接引用的话，那么组件之间根本没有做到解耦，如何从根本上避免组件之间的直接引用，也就是如何从根本上杜绝耦合的产生？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天则会从更小细粒度入手，主要讲讲在组件化架构下组件与组件之间通信机制是如何、包括所谓的UI跳转，其实也是组件化通信，只不过它稍微特殊点，单独抽取出来而已。学习知识的过程很常见的一个思路就是从整体概况入手，首先对整体有个粗略的印象，然后再深入细节，抽丝剥茧般去挖掘其中的内在原理，一个点一个不断去突破，这样就能建立起自己整个知识树，所以今天我们就从通信机制这个点入手，看看其中内在玄机有哪些。&lt;/p&gt;
&lt;h3 id=&quot;思维导图&quot;&gt;思维导图&lt;/h3&gt;
&lt;p&gt;同样，在每写一篇文章之前，放个思维导图，这样做的好处对于想写的内容有很好的梳理，逻辑和结构上显得清晰点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/331079/201810/331079-20181014121740459-1341125578.png&quot; alt=&quot;思维导图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;主流方式&quot;&gt;主流方式&lt;/h3&gt;
&lt;p&gt;总所周知，Android提供了很多不同的信息的传递方式，比如在四大组件中本地广播、进程间的AIDL、匿名间的内存共享、Intent Bundle传递等等，那么在这么多传递方式，哪种类型是比较适合组件与组件直接的传递呢。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地广播，也就是LoacalBroadcastRecevier。更多是用在同一个应用内的不同系统规定的组件进行通信，好处在于：发送的广播只会在自己的APP内传播，不会泄漏给其他的APP，其他APP无法向自己的APP发送广播，不用被其他APP干扰。本地广播好比对讲通信，成本低，效率高，但有个缺点就是两者通信机制全部委托与系统负责，我们无法干预传输途中的任何步骤，不可控制，一般在组件化通信过程中采用比例不高。&lt;/li&gt;
&lt;li&gt;进程间的AIDL。这个粒度在于进程，而我们组件化通信过程往往是在线程中，况且AIDL通信也是属于系统级通信，底层以Binder机制，虽说Android提供模板供我们实现，但往往使用者不好理解，交互比较复杂，往往也不适用应用于组件化通信过程中。&lt;/li&gt;
&lt;li&gt;匿名的内存共享。比如用Sharedpreferences，在处于多线程场景下，往往会线程不安全，这种更多是存储一一些变化很少的信息，比如说组件里的配置信息等等。&lt;/li&gt;
&lt;li&gt;Intent Bundle传递。包括显性和隐性传递，显性传递需要明确包名路径，组件与组件往往是需要互相依赖，这背离组件化中SOP（关注点分离原则），如果走隐性的话，不仅包名路径不能重复，需要定义一套规则，只有一个包名路径出错，排查起来也稍显麻烦，这个方式往往在组件间内部传递会比较合适，组件外与其他组件打交道则使用场景不多。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说了这么多，那组件化通信什么机制比较适合呢？既然组件层中的模块是相互独立的，它们之间并不存在任何依赖。没有依赖就无法产生关系，没有关系，就无法传递消息，那要如何才能完成这种交流？&lt;/p&gt;
&lt;p&gt;目前主流做法之一就是引入第三者，比如图中的Base Module。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/331079/201810/331079-20181014121759531-1483164841.png&quot; alt=&quot;基础组件化架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组件层的模块都依赖于基础层，从而产生第三者联系，这种第三者联系最终会编译在APP Module中，那时将不会有这种隔阂，那么其中的Base Module就是跨越组件化层级的关键，也是模块间信息交流的基础。比较有代表性的组件化开源框架有&lt;a href=&quot;https://github.com/luojilab/DDComponentForAndroid&quot;&gt;得到DDComponentForAndroid&lt;/a&gt;、&lt;a href=&quot;https://github.com/alibaba/Arouter&quot;&gt;阿里Arouter&lt;/a&gt;、&lt;a href=&quot;https://github.com/JumeiRdGroup/Router&quot;&gt;聚美Router&lt;/a&gt; 等等。&lt;/p&gt;
&lt;p&gt;除了这种以通过引入第三者方式，还有一种解决方式是以事件总线方式，但这种方式目前开源的框架中使用比例不高，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/331079/201810/331079-20181014121818403-378586396.png&quot; alt=&quot;事件总线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事件总线通过记录对象，使用监听者模式来通知对象各种事件，比如在现实生活中，我们要去找房子，一般都去看小区的公告栏，因为那边会经常发布一些出租信息，我们去查看的过程中就形成了订阅的关系，只不过这种是被动去订阅，因为只有自己需要找房子了才去看，平时一般不会去看。小区中的公告栏可以想象成一个事件总线发布点，监听者则是哪些想要找房子的人，当有房东在公告栏上贴上出租房信息时，如果公告栏有订阅信息功能，比如引入门卫保安，已经把之前来这个公告栏要查看的找房子人一一进行电话登记，那么一旦有新出租消息产生，则门卫会把这条消息一一进行短信群发，那么找房子人则会收到这条消息进行后续的操作，是马上过来看，还是延迟过来，则根据自己的实际情况进行处理。在目前开源库中，有EventBus、RxBus就是采用这种发布/订阅模式，优点是简化了Android组件之间的通信方式，实现解耦，让业务代码更加简洁，可以动态设置事件处理线程和优先级，缺点则是每个事件需要维护一个事件类，造成事件类太多，无形中加大了维护成本。那么在组件化开源框架中有&lt;a href=&quot;https://github.com/cangwang/ModuleBus&quot;&gt;ModuleBus&lt;/a&gt;、&lt;a href=&quot;https://github.com/luckybilly/CC&quot;&gt;CC&lt;/a&gt; 等等。&lt;/p&gt;
&lt;p&gt;这两者模式更详细的对比，可以查看这篇文章&lt;a href=&quot;https://github.com/luckybilly/AndroidComponentizeLibs&quot;&gt;多个维度对比一些有代表性的开源android组件化开发方案&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现方案&quot;&gt;实现方案&lt;/h3&gt;
&lt;p&gt;事件总线，又可以叫做组件总线，路由+接口，则相对好理解点，今天从阅读它们框架源码，我们来对比这两种实现方案的不同之处。&lt;/p&gt;
&lt;h5 id=&quot;组件总线&quot;&gt;组件总线&lt;/h5&gt;
&lt;p&gt;这边选取的是&lt;a href=&quot;https://github.com/cangwang/ModuleBus&quot;&gt;ModuleBus&lt;/a&gt;框架，这个方案特别之处在于其借鉴了&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot;&gt;EventBus&lt;/a&gt;的思想，组件的注册/注销和组件调用的事件发送都跟EventBus类似，能够传递一些基础类型的数据，而并不需要在Base Moudel中添加额外的类。所以不会影响Base模块的架构，但是无法动态移除信息接收端的代码，而自定义的事件信息类型还是需要添加到Base Module中才能让其他功能模块索引。&lt;/p&gt;
&lt;p&gt;其中的核心代码是在与 &lt;strong&gt;ModuleBus&lt;/strong&gt; 类，其内部维护了两个ArrayMap键对值列表，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     * Object methodClass
     * String methodName；
     * MethodInfo method info
     */
    private static ArrayMap&amp;lt;Object,ArrayMap&amp;lt;String,MethodInfo&amp;gt;&amp;gt; moduleEventMethods = new ArrayMap&amp;lt;&amp;gt;();

    /**
     * Class IBaseClient.class
     * String methodName
     * Object methodClass
     */
    private static ArrayMap&amp;lt;Class&amp;lt;?&amp;gt;,ArrayMap&amp;lt;String,ArrayList&amp;lt;Object&amp;gt;&amp;gt;&amp;gt; moduleMethodClient = new ArrayMap&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用方法上，在onCreate()和onDestroy()中需要注册和解绑，比如&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ModuleBus.getInstance().register(this);
ModuleBus.getInstance().unregister(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终使用类似EventBus 中 post 方法一样，进行两个组件间的通信。这个框架的封装的post 方法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void post(Class&amp;lt;?&amp;gt; clientClass,String methodName,Object...args){
        if(clientClass == null || methodName == null ||methodName.length() == 0) return;

        ArrayList&amp;lt;Object&amp;gt; clientList = getClient(clientClass,methodName);

        if(clientList == null) return;

        try{
            for(Object c: clientList){
                try{
                    ArrayMap&amp;lt;String,MethodInfo&amp;gt; methods = moduleEventMethods.get(c);
                    Method method = methods.get(methodName).m;
                    if(method == null){
                        Log.e(TAG,&quot;cannot find client method&quot;+methodName +&quot;for args[&quot;+args.length+&quot;]&quot; + Arrays.toString(args));
                        return;
                    }else if(method.getParameterTypes() == null){
                        Log.e(TAG,&quot;cannot find client method param:&quot;+method.getParameterTypes() +&quot;for args[&quot;+args.length+&quot;]&quot; + Arrays.toString(args));
                        return;
                    }else if(method.getParameterTypes().length != args.length){
                        Log.e(TAG,&quot;method &quot;+methodName +&quot; param number not matched:method(&quot;+method.getParameterTypes().length+&quot;), args(&quot; + args.length+&quot;)&quot;);
                        return;
                    }
                    method.invoke(c,args);
                }catch (Throwable e){
                    Log.e(TAG,&quot;Notifiy client method invoke error.&quot;,e);
                }
            }

        }catch (Throwable e){
            Log.e(TAG,&quot;Notify client error&quot;,e);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，它是通过遍历之前内部的ArrayMap，把注册在里面的方法找出，根据传入的参数进行匹配，使用反射调用。&lt;/p&gt;
&lt;h5 id=&quot;接口路由&quot;&gt;接口+路由&lt;/h5&gt;
&lt;p&gt;接口+路由实现方式则相对容易理解点，我之前实践的一个项目就是通过这种方式实现的。具体地址如下：&lt;a href=&quot;https://github.com/cr330326/DemoComponent&quot;&gt;DemoComponent&lt;/a&gt; 实现思路是专门抽取一个LibModule作为路由服务，每个组件声明自己提供的服务 Service API，这些 Service 都是一些接口，组件负责将这些 Service 实现并注册到一个统一的路由 Router 中去，如果要使用某个组件的功能，只需要向Router 请求这个 Service 的实现，具体的实现细节我们全然不关心，只要能返回我们需要的结果就可以了。&lt;/p&gt;
&lt;p&gt;比如定义两个路由地址，一个登陆组件，一个设置组件，核心代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RouterPath {

    //注意路由的命名，路径第一个开头需要不一致，保证唯一性
    //Login Service
    public static final String ROUTER_PATH_TO_LOGIN_SERVICE = &quot;/login/service&quot;;

    //Setting Service
    public static final String ROUTER_PATH_TO_SETTING_SERVICE = &quot;/setting/service&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么就相应着就有两个接口API，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ILoginProvider extends IProvider {

    void goToLogin(Activity activity);
}

public interface ISettingProvider extends IProvider {
    
    void goToSetting(Activity activity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个接口API对应着是向外暴露这两个组件的能提供的通信能力，然后每个组件对接口进行实现，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Route(path = RouterPath.ROUTER_PATH_TO_LOGIN_SERVICE, name = &quot;登陆页面&quot;)
public class LoginService implements ILoginProvider {
    @Override
    public void init(Context context) {}


    @Override
    public void goToLogin(Activity activity) {
        Intent loginIntent = new Intent(activity, LoginActivity.class);
        activity.startActivity(loginIntent);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这其中使用的到了阿里的&lt;a href=&quot;https://github.com/alibaba/Arouter&quot;&gt;ARouter&lt;/a&gt;页面跳转方式，内部本质也是接口+实现方式进行组件间通信。&lt;/p&gt;
&lt;p&gt;调用则很简单了，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; ILoginProvider loginService = (ILoginProvider) ARouter.getInstance().build(RouterPath.ROUTER_PATH_TO_LOGIN_SERVICE).navigation();
if(loginService != null){
    loginService.goToLogin(MainActivity.this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一个组件化框架，就是&lt;a href=&quot;https://github.com/SpinyTech/ModularizationArchitecture&quot;&gt;ModularizationArchitecture&lt;/a&gt; ，它本质实现方式也是接口+实现，但是封装形式稍微不一样点，它是每个功能模块中需要使用注解建立Action事件，每个Action完成一个事件动作。invoke只是方法名为反射，并未用到反射，而是使用接口方式调用，参数是通过HashMap&amp;lt;String,String&amp;gt;传递的，无法传递对象。具体详解可以看这篇文章 &lt;a href=&quot;http://blog.spinytech.com/2016/12/28/android_modularization/&quot;&gt;Android架构思考(模块化、多进程)&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;页面跳转&quot;&gt;页面跳转&lt;/h3&gt;
&lt;p&gt;页面跳转也算是一种组件间的通信，只不过它相对粒度更细化点，之前我们描述的组件间通信粒度会更抽象点，页面跳转则是定位到某个组件的某个页面，可能是某个Activity，或者某个Fragment，要跳转到另外一个组件的Activity或Fragment，是这两者之间的通信。甚至在一般没有进行组件化架构的工程项目中，往往也会封装页面之间的跳转代码类，往往也会有路由中心的概念。不过一般 UI 跳转基本都会单独处理，一般通过短链的方式来跳转到具体的 Activity。每个组件可以注册自己所能处理的短链的 Scheme 和 Host，并定义传输数据的格式，然后注册到统一的 UIRouter 中，UIRouter 通过 Scheme 和 Host 的匹配关系负责分发路由。但目前比较主流的做法是通过在每个 Activity 上添加注解，然后通过 APT 形成具体的逻辑代码。&lt;/p&gt;
&lt;p&gt;下面简单介绍目前比较主流的两个框架核心实现思路：&lt;/p&gt;
&lt;h5 id=&quot;arouter&quot;&gt;&lt;a href=&quot;https://github.com/alibaba/Arouter&quot;&gt;ARouter&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;ARouter 核心实现思路是，我们在代码里加入的@Route注解，会在编译时期通过apt生成一些存储path和activityClass映射关系的类文件，然后app进程启动的时候会拿到这些类文件，把保存这些映射关系的数据读到内存里(保存在map里)，然后在进行路由跳转的时候，通过build()方法传入要到达页面的路由地址，ARouter会通过它自己存储的路由表找到路由地址对应的Activity.class(activity.class = map.get(path))，然后new Intent()，当调用ARouter的withString()方法它的内部会调用intent.putExtra(String name, String value)，调用navigation()方法，它的内部会调用startActivity(intent)进行跳转，这样便可以实现两个相互没有依赖的module顺利的启动对方的Activity了。&lt;/p&gt;
&lt;h5 id=&quot;activityrouter&quot;&gt;&lt;a href=&quot;https://github.com/mzule/ActivityRouter&quot;&gt;ActivityRouter&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;ActivityRouter 核心实现思路是，它是通过路由 + 静态方法来实现，在静态方法上加注解来暴露服务，但不支持返回值，且参数固定位(context, bundle)，基于apt技术，通过注解方式来实现URL打开Activity功能，并支持在WebView和外部浏览器使用，支持多级Activity跳转，支持Bundle、Uri参数注入并转换参数类型。它实现相对简单点，也是比较早期比较流行的做法，不过学习它也是很有参考意义的。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;总的来说，组件间的通信机制在组件化编程和组件化架构中是很重要的一个环节，可能在每个组件独自开发阶段，不需要与其他组件进行通信，只需要在内部通信即可，当处于组件集成阶段，那就需要大量组件进行互相通信，体现在每个业务互相协作，如果组件间设计的不好，打开一个页面或调用一个方法，想当耗时或响应慢，那么体现的则是这个APP使用比较卡顿，仅仅打开一个页面就是需要好几秒才能打开，则严重影响使用者的体验了，甚至一些大型APP，可能组件分化更小，种类更多，那么组件间的通信则至关重要了。所以，要打造一个良好的组件化框架，如何设计一个更适合自己本身的业务类型的通信机制，就需要多多进行思考了。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;1，https://github.com/luckybilly/AndroidComponentizeLibs&lt;/p&gt;
&lt;p&gt;2，http://blog.spinytech.com/2016/12/28/android_modularization/&lt;/p&gt;
</description>
<pubDate>Sun, 14 Oct 2018 04:19:00 +0000</pubDate>
<dc:creator>cryAllen</dc:creator>
<og:description>之前写过一篇关于Android组件化的文章，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cr330326/p/9785894.html</dc:identifier>
</item>
</channel>
</rss>