<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>UnityShader-菲涅尔反射（Fresnel Reflection） - 那个少年</title>
<link>http://www.cnblogs.com/lijiajia/p/8013168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/8013168.html</guid>
<description>&lt;p&gt;菲涅耳公式（或菲涅耳方程），由奥古斯丁·让·菲涅耳导出。用来描述光在不同折射率的介质之间的行为。由公式推导出的光的反射称之为“菲涅尔反射”。菲涅尔公式是光学中的重要公式，用它能解释反射光的强度、折射光的强度、相位与入射光的强度的关系&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-7dd85cd97f12b406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;奥古斯丁·让·菲涅耳&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在计算机图形学中的应用&quot;&gt;在计算机图形学中的应用&lt;/h2&gt;
&lt;p&gt;一般运用于水面效果，试想一下你站在湖边，低头看向水里，你会发现近的地方非常清澈见底（反射较少），而看远的地方却倒映着天空（反射较多）。这就是菲尼尔效应&lt;/p&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-83212960c89a067e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot;/&gt;&lt;br/&gt;这里直接让反射颜色为红色，可以看到远处的更红，而近处的为光照颜色白色&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-cb3cadec841d7ee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;fresnel效果的球体&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1208599-290956e8e56cd533.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;fresnel+cubemap效果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简化后的公式&quot;&gt;简化后的公式&lt;/h2&gt;
&lt;p&gt;由于真实的菲尼尔公式计算量较多。在游戏里往往会用简化版的公式来提升效率达到近似的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fresnel = fresnel基础值 + fresnel缩放量*pow( 1 - dot( N, V ), 5 )&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;shader实现&quot;&gt;Shader实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Shader &quot;lijia/fresnelTest&quot;
{
    Properties
    {
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
        _fresnelBase(&quot;fresnelBase&quot;, Range(0, 1)) = 1
        _fresnelScale(&quot;fresnelScale&quot;, Range(0, 1)) = 1
        _fresnelIndensity(&quot;fresnelIndensity&quot;, Range(0, 5)) = 5
        _fresnelCol(&quot;_fresnelCol&quot;, Color) = (1,1,1,1)
    }

    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        LOD 100

        Pass
        {
            tags{&quot;lightmode=&quot;=&quot;forward&quot;}

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;
            #include &quot;Lighting.cginc&quot;

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
                float3 normal : NORMAL;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
                float3 L : TEXCOORD1;
                float3 N : TEXCOORD2;
                float3 V : TEXCOORD3;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            float _fresnelBase;

            float _fresnelScale;

            float _fresnelIndensity;

            float4 _fresnelCol;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                //将法线转到世界坐标
                o.N = mul(v.normal, (float3x3)unity_WorldToObject);
                //获取世界坐标的光向量
                o.L = WorldSpaceLightDir(v.vertex);
                //获取世界坐标的视角向量
                o.V = WorldSpaceViewDir(v.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                fixed4 col = tex2D(_MainTex, i.uv);

                float3 N = normalize(i.N);
                float3 L = normalize(i.L);
                float3 V = normalize(i.V);

                col.rgb *= saturate(dot(N, L)) * _LightColor0.rgb;
                //菲尼尔公式
                float fresnel = _fresnelBase + _fresnelScale*pow(1 - dot(N, V), _fresnelIndensity);

                col.rgb += lerp(col.rgb, _fresnelCol, fresnel) * _fresnelCol.a;

                return col;
            }

            ENDCG
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 09 Dec 2017 15:39:00 +0000</pubDate>
<dc:creator>那个少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiajia/p/8013168.html</dc:identifier>
</item>
<item>
<title>.NET作品集：linux下的博客程序 - 叶鹏</title>
<link>http://www.cnblogs.com/jqbird/p/7965995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jqbird/p/7965995.html</guid>
<description>&lt;p&gt;本博客程序是博主11年的时候参考loachs小泥鳅博客内核开发的.net跨平台博客cms，距今已有6年多了，个人博客网站一直在用，虽然没有wordpress那么强大，但是当时在深究.net的同时，自己能写一个博客程序，并且基于独立Linux服务器搭建一个自己的.net网站还是挺有意思，毕竟当年运行在linux下的.net网站还是极少数的，之前的部署方式一直沿用至今，网站服务器仅仅内存512M扩充到1G，毕竟现在的操作系统512M实在是有点少，如果是跑静态站点还可以，动态的再多放点东西就会内存报警了，废话不多说，看代码。&lt;/p&gt;
&lt;h2 id=&quot;技术栈&quot;&gt;技术栈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;.net framework 4.0&lt;/li&gt;
&lt;li&gt;sqlite 数据库&lt;/li&gt;
&lt;li&gt;mono linux 运行环境以及mono下的sqlite库&lt;/li&gt;
&lt;li&gt;nvelocity 模板引擎&lt;/li&gt;
&lt;li&gt;dapper 轻量级orm框架&lt;/li&gt;
&lt;li&gt;vs2010&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码结构&quot;&gt;代码结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209213858181-1690100031.png&quot; alt=&quot;代码结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左侧主要分为三个文件夹，Jqpress.web是存放web路由入口、模板皮肤、上传文件以及后台管理程序，上图default.aspx.cs代码里有处理301跳转的，主要用来处理jqpress.com自动跳转到www.jqpress上，确保对搜索引擎处理友好，需要大家手动移除此代码。&lt;/p&gt;
&lt;h2 id=&quot;路由设计&quot;&gt;路由设计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209214032650-40914953.png&quot; alt=&quot;路由设计&quot;/&gt;&lt;br/&gt;整个前台入口是从default.aspx作为路由入口跳转到核心路由控制器BlogController，Controller根据url请求的type参数做路由处理。&lt;/p&gt;
&lt;h2 id=&quot;模板引擎设计&quot;&gt;模板引擎设计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209214246915-564082437.png&quot; alt=&quot;模板引擎&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板引擎采用nvelocity，是java的velocity的.net翻译版本，现在依然活跃在java界,采用这个模板引擎的原因是因为简单，高效，通用，成熟。&lt;/p&gt;
&lt;p&gt;可以看到一个模板皮肤包含图片、模板、样式、预览图、配置文件，wordpress好像也跟这差不多。&lt;/p&gt;
&lt;h2 id=&quot;数据存储设计&quot;&gt;数据存储设计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209215610259-948966484.png&quot; alt=&quot;数据访问层&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为轻量级的博客程序，数据库就没必要用sqlserver或者mysql这样的大块头了，sqlite绝对够用了，如果是windows下的可以用access，但是sqlite真心好用，语法就是mysql的精简版，速度非常之快，上图是原生sqlite没通过orm的直接写法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209215811603-111104684.png&quot; alt=&quot;dapper&quot;/&gt;&lt;/p&gt;
&lt;p&gt;orm更是采用stackoverflow出品的dapper，速度快，原生sql，简单，因为要支持linux，所以sqlite的操作类需要&lt;code&gt;using Mono.Data.Sqlite;&lt;/code&gt; ，上图是通过dapper的写法，没有密密麻麻的参数了，不过当前项目还没有完全转dapper，希望有感兴趣的同学将此份源码改造成更好的.net 博客cms系统。&lt;/p&gt;
&lt;p&gt;由于windows下和linux操作sqlite的原生方法差别比较大，如果通过dapper来操作的话还是可以实现自由切换&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209225900247-2122689595.png&quot; alt=&quot;数据库&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;jq_category&lt;/code&gt; 分类及标签表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jq_comments&lt;/code&gt; 评论表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jq_links&lt;/code&gt; 友链及导航设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jq_posts&lt;/code&gt; 文章表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jq_sites&lt;/code&gt; 站点访问统计数字及文章、分类、数量统计表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jq_users&lt;/code&gt; 账户表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;vs2010调试模式预览&quot;&gt;vs2010调试模式预览&lt;/h2&gt;
&lt;p&gt;博客首页&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209220004931-929713759.png&quot; alt=&quot;首页&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台登录，默认用户名admin，密码admin&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209230531857-927221251.png&quot; alt=&quot;登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台首页&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209222459841-1698271926.png&quot; alt=&quot;管理后台首页&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章编辑&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209222740122-1851304180.png&quot; alt=&quot;文章编辑&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux部署方式&quot;&gt;linux部署方式&lt;/h2&gt;
&lt;p&gt;linux下需要安装mono和jexus就可以运行起来，mono作为.net framework的linux运行环境，jexus作为web服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209224416576-1007822281.png&quot; alt=&quot;jexus&quot;/&gt;&lt;br/&gt;如上图是我的博客站点jexus配置，因为我的服务器上还有其他语言的站点，所以没有直接采用jexus对外服务，前面还套了层nginx作为代理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/94489/201712/94489-20171209224739669-240915517.png&quot; alt=&quot;mono&quot;/&gt;&lt;br/&gt;上图为我服务器上的mono安装信息。&lt;/p&gt;
&lt;p&gt;linux服务器上的的.net 程序问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jexus不支持中文，所以文件上传的路径必须重写成字母加数字符号形式，&lt;/li&gt;
&lt;li&gt;jexus web服务器是默认对大小写敏感的，所以部署的时候一定要&lt;br/&gt;只需要把 jws这个脚本文件中的 “export MONO_IOMAP=...”这一句前边的“#”去掉，就可以不区分大小写了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/robotbird/jqpress-aspx&quot; class=&quot;uri&quot;&gt;https://github.com/robotbird/jqpress-aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了防止部分同学无法访问Github，所以放oschina的gitee上了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/robotbird/jqpress-aspx&quot; class=&quot;uri&quot;&gt;https://gitee.com/robotbird/jqpress-aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至于架构为什么不用.net mvc ，那是因为当时只买得起最便宜的.net 虚拟服务器，不用单独买服务器一年才几十块钱，所以说此版本的.net 博客程序对服务器的要求是极低的，基本支持所有的.net 空间提供商，如果是自建服务的话，我也重新开发了一套基于mvc3的cms程序，大家可以先预览下[&lt;a href=&quot;http://www.bjjxysbz.com/&quot;&gt;bjjxysbz.com&lt;/a&gt;，下回分解下。&lt;br/&gt;作为一个多年的.net开发人员，后又混迹java，现在成为产品狗，偶尔用用python做些日常的工作，作为一个迈入中年的老程序员，想想还是不忘初心，热爱技术，后续也会抽出时间将自己的作品逐一搬到网上，缅怀下青春，个人的博客站点 &lt;a href=&quot;http://www.jqpress.com/&quot;&gt;机器鸟&lt;/a&gt;,后续会将继续在博客园上发表技术类型的文章，回归社区，不再独自前行。&lt;/p&gt;
&lt;p&gt;博客程序还不是很完善，bug可能比较多，如果有代码、开发、部署问题请联系qq:330296409，或者邮箱robotbird#qq.com。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 15:36:00 +0000</pubDate>
<dc:creator>叶鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jqbird/p/7965995.html</dc:identifier>
</item>
<item>
<title>C#爬虫系列（二）——食品安全国家标准数据检索平台 - 马洪彪</title>
<link>http://www.cnblogs.com/mahongbiao/p/8013012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mahongbiao/p/8013012.html</guid>
<description>&lt;p&gt;上篇对“国家标准全文公开系统”的国标进行抓取，本篇对食品领域的标准公开系统“食品安全国家标准数据检索平台”进行抓取。&lt;/p&gt;
&lt;p&gt;平台地址：http://bz.cfsa.net.cn/db&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209221328728-1476139223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步还是去获取标准列表，通过高级搜索，输入空查询条件，则查询出全部的标准记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209221538540-551638420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209221450368-1878334499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这时候可以看到，列表页的URL仍然是http://bz.cfsa.net.cn/db。&lt;/p&gt;
&lt;p&gt;不同于“&lt;span class=&quot;postTitle2&quot;&gt;国家标准全文公开系统&lt;/span&gt;”，“食品安全国家标准数据检索平台”的请求多数是POST，即用户的多数操作是POST不同参数到http://bz.cfsa.net.cn/db，服务根据POST的参数返回相应的页面。&lt;/p&gt;
&lt;p&gt;那么要获取标准列表，则要POST特定参数到http://bz.cfsa.net.cn/db。POST哪些参数？可以通过查看源码，分析JS代码了解到。&lt;/p&gt;
&lt;p&gt;更简单、准确的方式是，通过浏览器（火狐、谷歌、IE都可）的Web调试工具查看其POST提交的参数，例如查询全部标准的POST数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209222519716-506152472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击标准名称超链接，将打开标准详细信息页，页面URL为http://bz.cfsa.net.cn/staticPages/002D3B53-DE13-42C1-B099-C57EC501138A.html。&lt;/p&gt;
&lt;p&gt;可见详细信息页通过GET请求获得，需要从列表页中解析到标准的GUID，然后GET相应的页面即可。解析GUID仍然使用正则表达式即可。&lt;/p&gt;
&lt;p&gt;当然，该站点也可以通过POST请求获取到标准详细信息页，因为其源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:void(0);&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;goto('3B34B8D6-7164-4419-B308-6AF683E8B606','2')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;食品安全国家标准 食品微生物学检验培养基和试剂的质量&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;font &lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;='red'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;要&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;font&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;求（GB 4789.28-2013）&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209222954607-2103478870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标准详细信息的抓取，仍然通过HTML解析组件进行解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209223122247-1000266129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下载标准PDF文件，点击“下载”链接获取文件。查看其源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
onclick=&quot;load('588072C8-F771-4F66-9B33-3BA4AF7C4540');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/378857/201712/378857-20171209223238779-995464112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可知下载PDF文件时，POST请求到该URL：&lt;a href=&quot;http://bz.cfsa.net.cn/cfsa_aiguo&quot;&gt;http://bz.cfsa.net.cn/cfsa_aiguo。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文件的GUID值和标准的GUID值不同，但仍然可以从页面中使用正则表达式解析出来。&lt;/p&gt;
&lt;p&gt;至此，该站点的标准可以抓取到，相比“国家标准全文公开系统”，该站点标准爬取时，只需要修改GET请求为POST请求即可。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 14:41:00 +0000</pubDate>
<dc:creator>马洪彪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mahongbiao/p/8013012.html</dc:identifier>
</item>
<item>
<title>程序员和烟民 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/8012862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/8012862.html</guid>
<description>&lt;p&gt;从我身边的情况来讲，程序员是一个很大的吸烟群体，作为曾经一个重度吸烟者，我想吸烟的好处太多了。初去一个公司方便融入团队，每一个互联网公司大概都会有一堆烟民，工作匮乏的时候大家一起下楼聊聊天八卦，马上会有都是革命同志的亲切感；吸烟可以帮助解决问题，当你遇到一个非常复杂的bug，想了半天不能解决，这个时候想出去抽根烟压压惊，可能在眼抽到一半的时候，突然灵光一闪想到了解决方案，回到工位一试果然是这样，还是抽烟有效率；吸烟能提神，能促进交流，能突现灵感，你看程序员们的偶像张小龙也是一个烟鬼，不然他怎么能搞出微信呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/life/ge.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;说起吸烟我可是一个十足的老烟民，2000年我第一次离开父母，独自住宿在县城，那时候古惑仔正流行，叛逆也是我们那一代小孩的特征。我迅速的学会了炸金花、打麻将、打游戏、那时候县城才出现第一代的网吧，一个小房间里面就几台电脑，黑黑的在里面玩CS，QQ号码注册了从来不会记，下次再注册就行。&lt;/p&gt;
&lt;p&gt;当然也学会了抽烟，那时候还买不起一盒烟，五毛钱买三根软猴王，每次点起一根烟的时候，一伙朋友你吸一口，我吸一口，一根烟往往会被四五个人吸，每次轮到我的时候，都会狠狠的扎一口，然后一种很爽的表情悠闲而出。后来认识了胖子，他们家老有人送礼，于是会偷出来各种各样我们从来没有见过的好烟，蓝色的、白色的、薄荷味的、不知道什么味的都以不同的方式刺激着我们的感官。到了高中，也买的起一盒烟了，一支烟仍然舍不得抽完，每次吸半根留着下次再抽完，家里人也慢慢知道了我吸烟。&lt;/p&gt;
&lt;p&gt;大学是抽烟最疯狂的时候，我们宿舍有六个人，只有一个不吸烟的，你们懂的，最后成了六个人一起吸，大学也没多少钱，经常半夜起来烟瘾犯了，找遍宿舍没有烟抽，捡起地上的烟蒂抽两口也是常有的事情，我们宿舍都用的白色蚊帐，每次到秋天的时候都会变成黄色。每次买完烟，一定要藏起来或者随身携带，不然上个厕所回来就发现没几根了，有一次一个朋友来我们宿舍，不知道这个规矩，买了一盒烟放到桌子出去了，回来发现剩下了一个空烟盒，然后用非常疑惑的表情扫荡了一遍我们的舍友，大家都很认真的做自己的事情，好像啥事都没有发生一样。&lt;/p&gt;
&lt;p&gt;工作之后，加班越狠抽烟越厉害，压力越大抽烟越厉害，聚会抽烟自不在说，慢慢的吸烟成了生活的一部分。在过去的17年中我以各种理由说服自己，抽烟是有很多好处的。但我心里也知道，身体越来越差不断的尝试着去戒烟，好像戒烟的次数应该也超过了100次，戒烟最长的记录有半年多，但最终又开始复吸了。曾经我认为我会一直抽下去，反正我吸的也不多(我一直这样想)，直到前两个月前。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/life/jie.jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;在10月份的时候得过一次小感冒，感冒嘛小病也没当回事，就是咳嗽比较多，当感冒都好了的时候，咳嗽还是没有停止。特别是晚上咳嗽的很厉害，其实我不怕晚上的时间，毕竟只有我和我老婆，但是到了地铁上或者办公室就比较尴尬，我的咳嗽声巨大，地铁上异样的目光让我顿时有一种“光彩照人”的感觉，和领导们一起开会的时候就更尴尬，一直憋着不想咳嗽，但是突然有一阵子咳意特别浓烈，这时候领导正在侃侃而谈说着公司的重大方针，我那实在憋不住了放声一阵大咳，周围一下就安静了...。这一次感冒持续了两周也就慢慢过去了，自己也没有当回事，过了几天又开始吸烟了。&lt;/p&gt;
&lt;p&gt;在11月初的时候，北京有一场大降温，上班的时候感觉不太舒服，赶紧就喝了一点感冒药；第二天症状开始加剧，慢慢的有点头疼，去药店又买了一些药，喝了两天感冒症状还是没有减轻，并且开始慢慢咳嗽，刚好到了周末，就又吃了一些特效感冒药，周末两天在家蒙头大睡了两天，感觉感冒好像好了一点，但是咳嗽却越来越严重了。&lt;/p&gt;
&lt;p&gt;到了周一上班的时候咳嗽慢慢变的不可控制，就是无论如何都止不住咳嗽，么办法又找了以前的灵丹妙药甘草片。甘草片是对我而言是感冒止咳的一个神药，但因为甘草片配方中有阿片粉，虽然有镇咳的疗效，却也有成瘾性，因此北京的各大药店已经陆续开始限制销售，跑了N个地方终于在一个商场的地下一层药店中买到，拿到甘草片的那一刻感觉生命都有了希望。&lt;/p&gt;
&lt;p&gt;甘草片确实是止咳神药，只要含在嘴里三分钟后立刻止咳，但是也有一个缺点，它只是治标不治本。你需要过三四个钟头就含三片，而且这药奇苦，但是剧烈咳嗽的那种痛苦和这点苦比都不算啥，甘草片如果含着超过十个小时就会出现这样一个现象，舌头是苦的，嘴里面是苦的，胃里面也是苦的，然后你会突觉生活好像也是苦的。幸亏有甘草片压阵，不然咳嗽真是快要了我半条小命，咳嗽最高潮期间，可以连续咳嗽十分钟不带歇着，咳得眼泪鼻涕一起往下流，感觉五脏六腑都会随着剧烈的咳嗽给抖动出来。因为剧烈的咳嗽呼吸都快喘不上来，甚至有一刻我都觉得这次会不会要了我的小命。&lt;/p&gt;
&lt;p&gt;我意识到我必须要去医院了，请了一天假去附近的307医院挂号，坐在等号大厅的时候，看到周围一片的大妈大爷们，就我一个年轻人，心中一片悲凉。到我就诊的时候，医生问了一下感冒的症状，咳嗽的情况，上次体检胸片是否有异常等等，一边让我大口的呼气吸气，一边用听诊器仔细的听诊肺部的声音，然后告诉我，肺没有太大的问题，我心中一块石头落地。&lt;/p&gt;
&lt;p&gt;紧接着又对我说，你是一个老烟民吧，烟龄多久了，回答17年，医生说每次感冒都会引起咳嗽有两方面的因素，北京的雾霾和你持续的吸烟，并且告诉我，北京的天气我肯定改变不了，那只能有一个选项尽快戒烟！现在肺还没有问题，但是需要注意，如果再持续下去可能会有轻微的损伤，说完给我开了一大堆的药，说是要修复肺，取完药一看都是哮喘消炎类。站在医院的大门外，心中又庆幸又后怕，我才30岁肺要真的出现问题，以后怎么整，我还有很多想要做还没有做的事情，虽然最后是虚惊一场，但已经给我狠狠的敲了警钟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/life/kill.jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;从医院回来后，按照医生的嘱咐喝了整整十多天的药，终于不咳嗽了。事后看了一下，一瓶的甘草片在这次咳嗽期间都被我含着吃完了。如今我已经戒烟一个多月，平时咳嗽和吐痰明显慢慢变少，生活又进入了正轨。&lt;/p&gt;
&lt;p&gt;我媳妇是南方人，我的老家在西北，每次逢年过节的时候，我就会发现一个现象，北方人抽烟的普遍度远远大于南方。过年在我家打牌喝酒的时候，一晚上需要十几包烟来散发，去我媳妇家过年，几天过去了我一包烟还么发完，看来南方人更注重养生，北方人更加豪放。&lt;/p&gt;
&lt;p&gt;我在呼吸科看病的时候，在就诊室的墙上看到这样一段话：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;戒烟1分钟：身体开始进行自我修复；
戒烟20分钟：身体循环系统得到改善，心率开始正常；
戒烟2小时：尼古丁开始排出体外，心率、血压恢复正常；
戒烟8小时：血液中含氧量增加，一氧化碳含量减少约1半；
戒烟12小时：体内尼古丁得到有效清除，身体开始出现不适；
戒烟24小时：血液系统、血压及心脏健康等会逐渐恢复正常；
戒烟48小时：消除大部分尼古丁，嗅觉与味觉也逐渐变更好；
戒烟3~9个月：呼吸问题变好了，肺部开始逐渐恢复健康；
戒烟1年：冠状动脉疾病风险降低50%；
戒烟5年：中风的风险降低至和不抽烟的人同样水平；
戒烟10年：患肺癌的几率达到了正常吸烟人的一半；
戒烟15年：患冠心病的风险同不抽烟的人一样。死亡的风险也恢复到了和不抽烟人一样。

如果你在35岁前戒烟成功，那么你的预期寿命将和正常人一样。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我国约有3.6亿烟民，约占世界烟民的25%，比烟草起源地的美国的总人口还要多,我们的烟民每年约消耗全球1／3的卷烟。多年来，中国烟草一直保持了七个&quot;世界第一&quot; ：烟叶种植面积第一；烟叶收购量第一；卷烟产量第一；卷烟消费量第一；吸烟人数世界第一；烟草利税第一；死于吸烟相关疾病人数第一，进入2000年以来，中国每年死于吸烟相关疾病约100万人，是全球死亡人数的五分之一。&lt;/p&gt;
&lt;p&gt;我在泰国旅游期间，被烟盒上面的图像深深的震撼了，回来的时候我给吸烟的同事一人带了一盒，大家也看看吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/2017/life/smoking2.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在身体健康面前一切都不那么重要了，你不想停的也得停下来，正常工作、生活都会受到影响。程序员本来就是一个极度缺乏锻炼的人群，希望大家都能培养一个爱好，打羽毛球、游泳、户外徒步都是不错的选择，生活不只有代码，多出去走走会给思维带来不同的思考纬度。&lt;/p&gt;
&lt;p&gt;最后一个调查，作为一个程序员你是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽烟一族&lt;/li&gt;
&lt;li&gt;被动抽烟&lt;/li&gt;
&lt;li&gt;没有接触&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个烟民都知道吸烟有害健康，每个烟民都有戒不掉的故事。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 13:48:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/8012862.html</dc:identifier>
</item>
<item>
<title>浅谈使用git进行版本控制 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/7992543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/7992543.html</guid>
<description>&lt;p&gt;     小编在学习可视化的时候，接触到git，所以这里写一下关于GitHub的有关知识，写这个的目的还是巩固自己的学习，一方面可以提高自己，另一方面回头看一下，有什么更深层次的东西还可以再记录。&lt;/p&gt;
&lt;p&gt;     首先说一下版本控制软件，它可以让我们能够拍摄处于可行状态的项目的快照，修改项目（如实现新功能）后，如果项目不能正常运行，可以恢复到前一个可行状态。&lt;/p&gt;
&lt;p&gt;    通过使用版本控制，我们可以无忧无虑的改进项目，不用担心项目因为我们犯错而遭到破坏，对于大型项目来说，这显得尤为重要，但是对于小项目来说，哪怕只包含一个文件的程序，也大有裨益。&lt;/p&gt;
&lt;p&gt;    GibHub的名字源于Git，Git是一个分布式版本控制系统，让程序员团队能够协作开发项目，Git帮助大家管理为项目所做的工作，避免一个人所做的修改影响其他人所做的修改。你在项目中实现一个新功能的时候，Git将跟踪你对每个文件所做的修改。确定代码可行后，你将提交所做的修改，而Git将记录项目最新的状态，如果你犯了错，想撤销所做的修改，可轻松的返回以前的任何可行状态。GitHub上的项目都存储在仓库中，后者包含与项目相关联的一切：代码，项目参与者的信息，问题和bug报告等&lt;/p&gt;
&lt;p&gt;   下面讲一下安装Git（小编是windows系统，就只演示windows系统的安装）&lt;/p&gt;
&lt;h3&gt; 第一步：下载（https://git-for-windows.github.io/），下载好如下图&lt;/h3&gt;
&lt;p&gt;             &lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201712/1226410-20171206164351800-1556555364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;第二步：安装过程，此处省略，要想安装可以点击下面链接&lt;/h3&gt;
&lt;p&gt; &lt;strong&gt;【如果还需要学习Git的安装，见此博文http://www.cnblogs.com/wj-1314/p/7993819.html】&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;第三步：配置&lt;/h3&gt;
&lt;p&gt;Git跟踪谁修改了项目，哪怕参与项目开发的只有一个人。为此，Git需要知道你的用户名和电子邮件。你必须提供用户名，但可以使用虚构的电子邮件地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git config --&lt;span&gt;global&lt;/span&gt;  user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
git config &lt;/span&gt;--&lt;span&gt;global&lt;/span&gt;  user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username@example.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;         因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。&lt;/p&gt;
&lt;p&gt;        注意&lt;code&gt;git config&lt;/code&gt;命令的&lt;code&gt;--global&lt;/code&gt;参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。&lt;/p&gt;
&lt;h3&gt;第四步：创建项目&lt;/h3&gt;
&lt;p&gt;我们来创建一个要进行版本控制的项目（又称版本库）。在你的系统创建一个文件夹，并将其命名为learngit。&lt;/p&gt;
&lt;p&gt;我创建learngit的程序如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mkdir  learngit   #创建文件learngit&lt;br/&gt;cd  learngit       #进入learngit文件里面&lt;br/&gt;pwd                #显示learngit的存在目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我创建了一个hello.world.py程序，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;第五步：忽略文件&lt;/h3&gt;
&lt;p&gt;忽略扩展名为.pyc的文件，它是根据.py文件自动生成啊，我们无需让Git去跟踪。这些文件存储在目录__pycache__中，未来让git忽略它，我们创建一个名为.gitignore的特殊文件，（这个文件是以局点打头，没有扩展名，并且让在其中添加下面一行内容）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
_pycache_/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201712/1226410-20171208223454952-383251847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;第六步：初始化仓库&lt;/h3&gt;
&lt;p&gt;我们创建了一个文件，并通过&lt;code&gt;git init&lt;/code&gt;命令把这个目录变成Git可以管理的仓库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git init
Initialized empty Git repository &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; C:/Users/learngit/.git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个&lt;code&gt;.git&lt;/code&gt;的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。要是删除这个东西，则丢弃项目的所有记录。&lt;/p&gt;
&lt;p&gt;       如果你没有看到&lt;code&gt;.git&lt;/code&gt;目录，那是因为这个目录默认是隐藏的，用&lt;code&gt;ls -ah&lt;/code&gt;命令就可以看见。&lt;/p&gt;
&lt;p&gt;      也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。&lt;/p&gt;
&lt;h3&gt;第七步：检查状态&lt;/h3&gt;
&lt;p&gt;在执行其他操作之前，先来看一下状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;p&gt;$ git status&lt;br/&gt;On branch master&lt;/p&gt;
&lt;p&gt;No commits yet&lt;/p&gt;
&lt;p&gt;Untracked files:&lt;br/&gt;  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)&lt;/p&gt;
&lt;p&gt;        hello_world.py&lt;/p&gt;
&lt;p&gt;nothing added to commit but untracked files present (use &quot;git add&quot; to track)&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    在Git中，分支是项目的一个版本，从这里的输出我们可以知道，我么位于分支的，master&lt;/p&gt;
&lt;p&gt;     我们每次查看项目的状态时候，输出的都是我们位于分支master上，接下里的输出表明，我们将进行初始项目的日叫，&lt;strong&gt;提交&lt;/strong&gt;是项目在特定时间的快照。&lt;/p&gt;
&lt;p&gt;  Git指出了项目中未被跟踪的文件，因为我们还没有告诉他要跟踪那些文件，接下里我们被告知没有任何东西添加到当前提交里面，但我们可能需要将为跟踪的文件加入仓库&lt;/p&gt;
&lt;h3&gt;第八步：将文件加入到仓库&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git add .

。。。@▒▒▒▒▒ĵ▒▒▒ MINGW64 &lt;/span&gt;~/&lt;span&gt;learngit (master)
$ git status
On branch master

No commits yet

Changes to be committed:
  (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git rm --cached &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; to unstage)

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; file:   hello_world.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令  git add .   将项目中未被跟踪的文件都加入到仓库中，它不提交这些文件，而只是让git开始关注他们。现在我们检查这个项目的状态，发现Git找到了需要提交的文件的一些修改，标签 new file  表示这些文件是新加入的。&lt;/p&gt;
&lt;h3&gt;第九步：执行提交&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ git commit -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Started project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[master (root&lt;/span&gt;-&lt;span&gt;commit) 5d6ceca] Started project
 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; file changed, &lt;span&gt;1&lt;/span&gt; insertion(+&lt;span&gt;)
 create mode &lt;/span&gt;&lt;span&gt;100644&lt;/span&gt; hello_world.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     我们在执行   git commit -m &quot;Started project&quot;    的时候以拍摄项目的快照。标志-m 让Git接下里的消息（“Started project&quot;）记录到项目中的历史记录中，输出表明我们在分支master 上，而且有一个文件被修改了&lt;/p&gt;
&lt;p&gt;     简单解释一下&lt;code&gt;git commit&lt;/code&gt;命令，&lt;code&gt;-m&lt;/code&gt;后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。&lt;/p&gt;
&lt;h3&gt;第十步：查看提交历史&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git log
commit 5d6cecad80427924b94b14c6fd2bb82a4fa86840 (HEAD &lt;/span&gt;-&amp;gt;&lt;span&gt; master)
Author: wangjian &lt;/span&gt;&amp;lt;&lt;span&gt;1171737614&lt;/span&gt;.qq.com&amp;gt;&lt;span&gt;
Date:   Sat Dec &lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;16&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt; +&lt;span&gt;0800&lt;/span&gt;&lt;span&gt;

    Started project&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们每次提交的时候，Git都会生成一个包含40字符的独一无二的引用ID，它记录提交是谁执行的，提交的时间以及提交的指定消息，并非在任何情况下你都需要所有的这些信息，因此Git提供一个选项，让我们能够打印提交历史条目的更简单的版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ git log --pretty=&lt;span&gt;oneline
5d6cecad80427924b94b14c6fd2bb82a4fa86840 (HEAD &lt;/span&gt;-&amp;gt; master) Started project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标志 --pretty=oneline   指定显示一项最重要的信息，提交的引用ID以及为提交记录的消息。&lt;/p&gt;
&lt;h3&gt;第十一步：第二次提交&lt;/h3&gt;
&lt;p&gt;为了显示版本控制的强大，我们需要对项目进行修改，并提交所做的修改。为此，我们在文件hello.world.py中再添加一行代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello git&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们查看项目的状态，将发现Git注意到这个文件的变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
Changes not staged &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; commit:
  (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git add &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; to update what will be committed)
  (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git checkout -- &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; to discard changes &lt;span&gt;in&lt;/span&gt;&lt;span&gt; working directory)

        modified:   hello_world.py

no changes added to commit (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; and/or &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git commit -a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  这个之处了我们当前所在的分支为master,其中做出修改的文件是hello_world.py，而且指出所做的修改还没有提交。&lt;/p&gt;
&lt;p&gt;    接下来我们提交所做操作，并在查看操作。&lt;/p&gt;
&lt;p&gt;     这一步，我们执行了提交，并且在执行命令git commit 的时候指定了标志-am.标志-a 让Git 将仓库中所有修改了的文件都加入当前提交中，（如果我们两次提交之间加入了新文件，我们执行get add . 操作，将新文件加入到仓库中）标志-m让Git咱提交历史中记录一条消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$ git commit -am &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Extrended greeting.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[master b4ee15d] Extrended greeting.
 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; file changed, &lt;span&gt;2&lt;/span&gt; insertions(+), &lt;span&gt;1&lt;/span&gt; deletion(-)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
nothing to commit, working tree clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ git log --pretty=&lt;span&gt;oneline
b4ee15ddf5274f488db8c74c327065c6f331ec5e (HEAD &lt;/span&gt;-&amp;gt;&lt;span&gt; master) Extrended greeting.
5d6cecad80427924b94b14c6fd2bb82a4fa86840 Started project&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在查看项目的状态的时候，发现工作目录也是干净的，最后我们发现提交历史中包含两个提交。&lt;/p&gt;
&lt;h3&gt;第十二步：撤销修改&lt;/h3&gt;
&lt;p&gt;下面来看看如何放弃所做的修改，恢复到一个可行状态，为此，我们首先在hello_world.py中添加一行代码&lt;/p&gt;
&lt;p&gt;hello_world.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello git&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the world is bad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存并运行这个文件&lt;/p&gt;
&lt;p&gt;我们查看状态，发现Git注意到所做的修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
Changes not staged &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; commit:
  (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git add &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; to update what will be committed)
  (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git checkout -- &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; to discard changes &lt;span&gt;in&lt;/span&gt;&lt;span&gt; working directory)

        modified:   hello_world.py

no changes added to commit (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; and/or &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git commit -a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Git注意到我们修改了hello_world.py，我么可以提交所做的修改，但是我们不提交所做的修改，而要恢复到最后一个提交，为此我们不对hello_world.py执行任何操作————不删除刚添加的代码行，也不使用文本编辑器的撤销功能，而是在终端会话中执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git checkout .&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令  git checkout .  能够让我们恢复到以前的任何提交。命令git checkout . 放弃最后一次提交所做的所有操作，将项目恢复到最后一次提交的状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
nothing to commit, working tree clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    就这个项目而言，我们恢复到前一个状态微不足道，但是如果我们开发的是大型项目，其中数十个文件都被修改了，那么恢复到前一个状态，将撤销来自最后一次提交的对这个文件所做的所有修改，这个功能很有用，比如：实现新功能，我们可以根据需要做任意数量的修改，如果这些修改都不行，可以撤销他们，而不会对项目有任何伤害，你无需记住做了那些修改，因而不必手工撤销所做的修改，Git会替我们完成所有的工作。&lt;/p&gt;
&lt;h3&gt;第十三步：检查以前的提交&lt;/h3&gt;
&lt;p&gt; 我们可以检查提交历史中的任何一次提交，而不仅仅是最后一次，为此我们可以在命令git check末尾指定该提交的引用ID的前6个字符（而不是局点）。通过检查出以前的提交，我们可以对其进行审核么然后返回到最后一次提交，或者放弃最近所做的工作，并选择以前的提交。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ git log --pretty=&lt;span&gt;oneline
b4ee15ddf5274f488db8c74c327065c6f331ec5e (HEAD &lt;/span&gt;-&amp;gt;&lt;span&gt; master) Extrended greeting.
5d6cecad80427924b94b14c6fd2bb82a4fa86840 Started project&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git checkout 5d6cec
Note: checking &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5d6cec&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.

You are &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;detached HEAD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
state without impacting any branches by performing another checkout.

If you want to create a &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; branch to retain commits you create, you may
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt; so (now or later) by &lt;span&gt;using&lt;/span&gt; -&lt;span&gt;b with the checkout command again. Example:

  git checkout &lt;/span&gt;-b &amp;lt;&lt;span&gt;new&lt;/span&gt;-branch-name&amp;gt;&lt;span&gt;

HEAD &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; now at 5d6ceca... Started project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     检查出以前的提交，我们将离开分支master，并进入Git所说的Git所说的分离头指针（detached HEAD）状态，HEAD表示项目的当前状态，之所以说我们处于分离状态是因为我们离开了一个命名分支（这里是master）&lt;/p&gt;
&lt;p&gt;      要回到分支master，可以检查出它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
$ git checkout master
Previous HEAD position was 5d6ceca... Started project
Switched to branch 'master'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这就会让你回到分支master 。除非i使用Git的高级功能，否则在提交以前的项目后，最好不要对项目做任何修改，然而，如果参与项目开发的人只有我们自己，而我自己又想放弃所有提交，并恢复到以前的状态，也可以将项目重置到以前的状态，为此，可在处于分支master上的任何情况下，执行如下命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
nothing to commit, working tree clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ git log --pretty=&lt;span&gt;oneline
b4ee15ddf5274f488db8c74c327065c6f331ec5e (HEAD &lt;/span&gt;-&amp;gt;&lt;span&gt; master) Extrended greeting.
5d6cecad80427924b94b14c6fd2bb82a4fa86840 Started project&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ git reset --&lt;span&gt;hard 5d6cec
HEAD &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; now at 5d6ceca Started project
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
nothing to commit, working tree clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ git log --pretty=&lt;span&gt;oneline
5d6cecad80427924b94b14c6fd2bb82a4fa86840 (HEAD &lt;/span&gt;-&amp;gt; master) Started project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，我们查看了状态，确认我们在分支master上，查看历史提交时，我们看见了两个提交。&lt;/p&gt;
&lt;p&gt;然后，我们执行了命令    git reset --hard    ，并在其指定了要永久性的恢复到的提交的引用ID的前6个字符。&lt;/p&gt;
&lt;p&gt;接下来，我们在次查看状态，大仙，我们在分支master上，并且没有需要任何修改，&lt;/p&gt;
&lt;p&gt;最后，我们再次查看提交的历史状态时候，我们发现我们处于重新开始的提交中。&lt;/p&gt;
&lt;h3&gt;第十四步：删除仓库&lt;/h3&gt;
&lt;p&gt;  有时候，仓库的历史纪录被我们搞乱了，而我们又不知道如何恢复，这时候我们首先应该考虑百度一下，看看自己的问题出在那里，如果无法恢复，而且参与项目的人只有自己，可以继续使用这些文件，但需要将这些项目的历史纪录删除——删除.git 这不会影响任何文件的当前状态，而只会删除文件的所有提交，因此我们将无法检查出项目的其他任何状态。&lt;/p&gt;
&lt;p&gt;   为此，可以打开一个文件浏览器，并将目录.git 删除，也可以通过命令完成这个任务。但是这样做过我们需要创建一个新的仓库，以重新对这些修改进行跟踪。&lt;/p&gt;
&lt;p&gt;  下面演示了如何在终端会话中完成这个过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
nothing to commit, working tree clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ rm -rf .git
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
 rm -rf .git  表示删除目录.git,删除后我们将继续查看状态。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
fatal: Not a git repository (or any of the parent directories): .git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这个意思是被告知我们，这不是一个仓库，（git用来跟踪仓库的信息都存储爱文件夹.git中，因此删除该文件夹也将会删除整个仓库）&lt;/p&gt;
&lt;p&gt;接下来，我们用命令 git init 来创建一个新的仓库，并查看状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git init
Initialized empty Git repository &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; C:/Users//learngit/.git/
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master

No commits yet

Untracked files:
  (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git add &amp;lt;file&amp;gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; to include &lt;span&gt;in&lt;/span&gt;&lt;span&gt; what will be committed)

        hello_world.py

nothing added to commit but untracked files present (use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;git add&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; to track)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  从状态中我们发现，又回到了初始状态，等待第一次提交，我们下面将所有的文件都添加到仓库中，并执行第一次提交，最后检查状态，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ git add .
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ git commit -m &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[master (root&lt;/span&gt;-&lt;span&gt;commit) 81350ab] Starting over
 &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; file changed, &lt;span&gt;1&lt;/span&gt; insertion(+&lt;span&gt;)
 create mode &lt;/span&gt;&lt;span&gt;100644&lt;/span&gt; hello_world.py
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ git status
On branch master
nothing to commit, working tree clean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从检查状态我们发现，我们在分支master上，并且没有任何未提交的修改。&lt;/p&gt;

&lt;p&gt;这就是版本控制的基本操作，希望能多多联系，这样我们才能学会版本控制。&lt;/p&gt;

</description>
<pubDate>Sat, 09 Dec 2017 13:39:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/7992543.html</dc:identifier>
</item>
<item>
<title>MongoDB优化与一些需要注意的细节 - 踏雪无痕SS</title>
<link>http://www.cnblogs.com/chenpingzhao/p/7979063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenpingzhao/p/7979063.html</guid>
<description>&lt;p&gt;这里总结下这段时间使用mongo的心得，列出了几个需要注意的地方。&lt;/p&gt;&lt;div id=&quot;article_content&quot; data-mod=&quot;popu_519&quot; data-dsm=&quot;post&quot; readability=&quot;82.367770802725&quot;&gt;
&lt;div class=&quot;markdown_views&quot; readability=&quot;77.375784693469&quot;&gt;
&lt;h3&gt;&lt;strong&gt;1. 系统参数及mongo参数设置&lt;/strong&gt; &lt;/h3&gt;
&lt;p&gt;mongo参数主要是storageEngine和directoryperdb，这两个参数一开始不选定后续就无法再更改。&lt;/p&gt;
&lt;p&gt;directoryperdb主要是将数据库分文件夹存放，方便后续的备份及数据迁移。&lt;/p&gt;
&lt;p&gt;storageEngine（存储引擎）默认使用的是MMAPv1，推荐使用3.0新加入的引擎wiredTiger。经实际使用wiredTiger占用的磁盘空间是MMAP的1/5，索引大小是其1/2，查询速度也提高很多，更重要的是该引擎提供了document级别的锁，当集合插入或更新数据时不需要阻塞读操作了。唯一的问题是市面上支持该引擎查询的工具不多，MongoVUE无法查到该引擎存储的集合，NosqlManager-mongo可以查到但需要.net环境支持。个人觉得熟悉下mongo command用mongo shell就足够了，所以还是强烈推荐使用wiredTiger引擎。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2. 无需对集合进行水平切分&lt;/strong&gt; &lt;/h3&gt;
&lt;p&gt;由于之前一直使用关系型数据库，关系型数据库当单表数据量超大时经常使用的一直方法是对数据表进行分表。在使用mongo时便很自然的觉得这招仍然有用。由于该系统的分表都是动态生成的，做到后面发现这招对mongo带来的性能提升远远抵不过维护成本的增加。&lt;/p&gt;
&lt;p&gt;分析一下关系型数据库分表会提高性能的最大原因是很多关系型数据库一张表是一个文件，分表可以避免一个文件过大所造成数据提取速度变慢。但是mongo并不是这样存储的，所以这条并不成立了。&lt;/p&gt;
&lt;p&gt;用过的都知道mongo对索引的依赖非常大，如果集合不能一开始就设计好，那后续索引就得写脚本来创建。这里贡献个给mongo大表动态创建索引的脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//找出所有数据量超过100w的信息集合info，并为其创建索引
eval(function () {
    var infos = [];
    var collNames = db.getCollectionNames();
    for (var i = 0; i &amp;lt; collNames.length; i++) {
        var collName = collNames[i];
        var collSize = db.getCollection(collName).count();
        if (collSize &amp;gt; 1000000 &amp;amp;&amp;amp; collName.indexOf(&quot;info_&quot;)==0) {
          db.getCollection(collName).ensureIndex({publishDate:-1,blendedScore:-1,publishTime:-1,isRubbish:1},{name:&quot;ScoreSortIdx&quot;,background:true});
            db.getCollection(collName).ensureIndex({similarNum:-1,publishTime:-1,isRubbish:1},{name:&quot;HotSortIdx&quot;,background:true});
            db.getCollection(collName).ensureIndex({publishTime:-1,isRubbish:1},{name:&quot;TimeSortIdx&quot;,background:true});
            infos.push(&quot;name:&quot; + collName + &quot;索引创建成功&quot;);
        }
    }
    return infos;
}());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么看动态创建索引勉强还是可以解决的，但是最坑的一个地方是sharding完全没办法做了。shard需要指定要shard的集合和分区键，这个就没法提前动态指定了。所以mongo集合不需要做水平切分（至少千万级不需要了，更大直接shard掉），只需要按业务分开就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 使用Capped Collection&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;有人使用mongo做数据缓存，而且是缓存固定数量的数据，仍然用正常的集合，然后定期清理数据。其实这时用capped collection性能会好很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 生产环境一定要用副本集&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;很多人线上环境还是用单机版，虽然部署快但是很多mongo自然提供的功能都没有用到像自动故障转移、读写分离，这些对后续系统扩容及性能优化太重要了。我想会使用mongo的应该是数据量达到一定级别，查询性能会非常重要，所以强烈建议上线时直接使用副本集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 学会使用explain&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;之前一直习惯用工具来查询，现在发现应该多使用mongo shell命令来查询，并使用explain查看查询计划。另外在寻找最优索引的时候hint命令也是非常有用的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
db.info.find({publishDate:{$gte:20160310,$lte:20160320},isRubbish:{$in:[0,1]},title:{$regex:&quot;.*test.*&quot;},$or:[{useId:10},{groupId:20}]}).explain(&quot;executionStats&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6. 写操作频繁无法使用读写分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于系统写操作较多，造成各种w级别锁经常出现（这种锁一般是block read的）而且系统对于数据一致性要求不会太多（大多是后台写入，前台读取，因此允许有一定延迟）所以想用副本集来做读写分离。当真正测试后发现副本集上的读取也经常出现阻塞的情况。通过db.currentOp()发现经常出现一个op:none的操作在申请global write lock，这时所有操作的状态都是在waitingForLock:true，这个问题google了很久都没找到解决方法。后面在官方文档有关&lt;a href=&quot;https://docs.mongodb.org/manual/faq/concurrency/#how-does-concurrency-affect-secondaries&quot; target=&quot;_blank&quot;&gt;并发的FAQ&lt;/a&gt;中发现下面这个大坑：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;How does concurrency affect secondaries?&lt;/p&gt;
&lt;p&gt;In replication, MongoDB does not apply writes serially to secondaries. &lt;br/&gt;Secondaries collect oplog entries in batches and then apply those &lt;br/&gt;batches in parallel. Secondaries do not allow reads while applying the &lt;br/&gt;write operations, and apply write operations in the order that they &lt;br/&gt;appear in the oplog.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来mongodb的副本在复制主节点数据执行oplog的时候，读取是被阻塞的，这基本宣告无法在副本上去读取数据了，白白耗费了几天精力。所以mongo&lt;span&gt;官方不推荐做读写分离&lt;/span&gt;，原来坑是在这里。。。其实写多读少的情况做读写分离作用也不大，因为性能瓶颈主要是在写入，读取一般不消耗多少资源（另外wiredTiger引擎的锁做到了doc级别，所以锁的情况相对较少）。&lt;span&gt;官方推荐的做法是shard&lt;/span&gt;，可以有效的将写入分配到多台服务器提高写入速度，使系统实现水平扩容。&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;h3&gt;7、千万不要让磁盘满了&lt;/h3&gt;
&lt;p&gt;80%的时候就要开始注意从集拆分片，如果你的数据增长特别快，很可能你还没有拆分磁盘就满了导致MongoDB挂掉了。如果数据量很大，尽量使用分片，不要使用副本集，做好磁盘容量规划，就是使用分片了也提前扩容，毕竟chunk迁移还是那么的慢。&lt;/p&gt;
&lt;h3&gt;8、安全风险&lt;/h3&gt;
&lt;p&gt;MongoDB是默认不提示用户设置密码的，所以，如果你没有配置密码又把MongoDB放在公网上面了，那么「恭喜」，你可能已经成为了肉鸡&lt;/p&gt;
&lt;h3&gt;9、&lt;strong&gt;数据库级锁&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MongoDB的锁机制和一般关系数据库如 MySQL（InnoDB）, Oracle 有很大的差异，InnoDB 和 Oracle 能提供行级粒度锁，而 MongoDB 只能提供 库级粒度锁，这意味着当 MongoDB 一个写锁处于占用状态时，其它的读写操作都得干等。&lt;/p&gt;
&lt;p&gt;初看起来库级锁在大并发环境下有严重的问题，但是 MongoDB 依然能够保持大并发量和高性能，这是因为 MongoDB 的锁粒度虽然很粗放，但是在锁处理机制和关系数据库锁有很大差异，主要表现在：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;MongoDB 没有完整事务支持，操作原子性只到单个 document 级别，所以通常操作粒度比较小；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MongoDB 锁实际占用时间是内存数据计算和变更时间，通常很快；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;MongoDB 锁有一种临时放弃机制，当出现需要等待慢速 IO 读写数据时，可以先临时放弃，等 IO 完成之后再重新获取锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常不出问题不等于没有问题，如果数据操作不当，依然会导致长时间占用写锁，比如下面提到的前台建索引操作，当出现这种情况的时候，整个数据库就处于完全阻塞状态，无法进行任何读写操作，情况十分严重。&lt;/p&gt;
&lt;p&gt;解决问题的方法，尽量避免长时间占用写锁操作，如果有一些集合操作实在难以避免，可以考虑把这个集合放到一个单独的 MongoDB 库里，因为 MongoDB 不同库锁是相互隔离的，分离集合可以避免某一个集合操作引发全局阻塞问题。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 09 Dec 2017 12:58:00 +0000</pubDate>
<dc:creator>踏雪无痕SS</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenpingzhao/p/7979063.html</dc:identifier>
</item>
<item>
<title>企业级自动化运维工具应用实战-ansible - 大天使彦</title>
<link>http://www.cnblogs.com/1477717815fuming/p/8012706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1477717815fuming/p/8012706.html</guid>
<description>&lt;p&gt;公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，当你接到这个任务时，有没有更快的解决方式？&lt;/p&gt;

&lt;p&gt;随着信息时代的持续发展，IT运维已经成为IT服务内涵中重要的组成部分。面对越来越复杂的业务，面对越来越多样化的用户需求，不断扩展的IT应用需要越来越合理的模式来保障IT服务能灵活便捷、安全稳定地持续保障，这种模式中的保障因素就是IT运维（其他因素是更加优越的IT架构等）。从初期的几台服务器发展到庞大的数据中心，单靠人工已经无法满足在技术、业务、管理等方面的要求，那么&lt;span&gt;&lt;strong&gt;标准化、自动化、架构优化、过程优化等降低IT服务成本的因素越来越被人们所重视。&lt;/strong&gt;&lt;/span&gt;其中，自动化最开始作为代替人工操作为出发点的诉求被广泛研究和应用。IT运维从诞生发展至今，自动化作为其重要属性之一已经不仅仅只是代替人工操作，更重要的是深层探知和全局分析，关注的是在当前条件下如何实现性能与服务最优化，同时保障投资收益最大化。自动化对IT运维的影响，已经不仅仅是人与设备之间的关系，已经发展到了面向客户服务驱动IT运维决策的层面，IT运维团队的构成，也从各级技术人员占大多数发展到业务人员甚至用户占大多数的局面。&lt;/p&gt;
&lt;p&gt;因此，&lt;span&gt;&lt;strong&gt;IT运维自动化是一组将静态的设备结构转化为根据IT服务需求动态弹性响应的策略，目的就是实现IT运维的质量，降低成本。可以说自动化运维一定是IT运维高层面的重要属性之一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205619165-317906939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;目前多数公司遇到的运维问题现状：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、硬件选型多样化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、系统多版本并存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、目录结构混乱&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、运维人员水平参差不齐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、历史遗留问题多&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、同一软件出现多个版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、无法批量化操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、工作效率低，故障率高&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、项目上线操作繁琐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;理想状态下的运维部门：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、只有少数类型的硬件，便于管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、系统版本统一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、目录结构规范&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、运维工程师水平层次高&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、无历史包袱&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、同一软件只有单一版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、同一类操作可自动化批量执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、工作效率高，无大量重复机械化操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、开发自己上线，运维比较轻松&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;日常运维工作中的重要事件：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、添加监控，收集系统指标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、对日志进行归档以及管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、数据备份于恢复&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、对计划任务进行管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、对软件包进行部署和管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、对脚本进行批量执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、对文件进行批量复制和移动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、设置文件或者目录对应的权限&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、关闭和启动服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10、对代码程序进行上下线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;所谓的运维自动化实际上就是某些运维过程的自动化，比如初始化自动化、测试/部署自动化，加监控自动化，简单报警处理自动化，业务降级/恢复自动化....集腋成裘，&lt;span&gt;&lt;strong&gt;慢慢的让系统可以承担更多的重复劳动，减少人力投入和学习成本。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;工具&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;安装系统&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;pxe/cobber&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;安装系统&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;虚拟化系统&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;kvm/xen/vmware&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;虚拟机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;应用部署&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;puppet/ansible/saltstack&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;中大型规模&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;命令执行&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;ansible/fabric/func&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;middle&quot;&gt;
&lt;p&gt;中小型规模&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;a&lt;strong&gt;nsible聚集以上部署和命令执行于一身，能够完整轻易的实现应用部署和批量命令功能，适用于主机数量中型规模，再大的用puppet。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为运维工程师，对于命令执行的工具要掌握ansible，fabric，func或者shell其中的一种&lt;/p&gt;


&lt;p&gt;ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，&lt;span&gt;&lt;strong&gt;实现了批量系统配置、批量程序部署、批量运行命令&lt;/strong&gt;&lt;/span&gt;等功能。&lt;/p&gt;
&lt;p&gt;ansible是基于 paramiko 开发的,并且基于模块化工作，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。ansible不需要在远程主机上安装client/agents，因为它们是&lt;span&gt;&lt;strong&gt;基于ssh&lt;/strong&gt;&lt;/span&gt;来和远程主机通讯的。ansible目前已经已经被红帽官方收购，是自动化运维工具中大家认可度最高的，并且上手容易，学习简单。&lt;span&gt;&lt;strong&gt;是每位运维工程师必须掌握的技能之一。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、默认使用SSH协议对设备进行管理；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、有大量常规运维操作模块，可实现日常绝大部分操作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、配置简单、功能强大、扩展性强；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、支持API及自定义模块，可通过Python轻松扩展；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、通过Playbooks来定制强大的配置、状态管理；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、提供一个功能强大、操作性强的Web管理界面和REST API接口——AWX平台。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205619868-298479193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;HostInventory：&lt;/strong&gt;&lt;/span&gt;记录由Ansible管理的主机信息，包括端口、密码、ip等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Playbooks：&lt;/strong&gt;&lt;/span&gt;&quot;剧本&quot;YAML格式文件，多个任务定义在一个文件中，定义主机需要调用哪些模块来完成的功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CoreModules：&lt;/strong&gt;&lt;/span&gt;核心模块，主要操作是通过调用核心模块来完成管理任务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CustomModules：&lt;/strong&gt;&lt;/span&gt;自定义模块，完成核心模块无法完成的功能，支持多种语言。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConnectionPlugins：&lt;/strong&gt;&lt;/span&gt;连接插件，Ansible和Host通信使用&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;ansible任务执行模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Ansible系统由控制主机对被管节点的操作方式可分为两类，即adhoc和playbook：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ad-hoc模式&lt;/strong&gt;&lt;/span&gt;使用单个模块，支持批量执行单条命令。 ad-hoc 命令是一种可以快速输入的命令，而且不需要保存起来的命令。就相当于bash中的一句话shell。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;playbook模式&lt;/strong&gt;&lt;/span&gt;是Ansible主要管理方式，也是&lt;span&gt;&lt;strong&gt;Ansible功能强大的关键&lt;/strong&gt;&lt;/span&gt;所在。playbook通过多个task集合完成一类功能，如Web服务的安装部署、数据库服务器的批量备份等。可以简单地把playbook理解为通过组合多条ad-hoc操作作的配置文件。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205620556-1154761157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单理解就是Ansible在运行时，首先读取ansible.cfg中的配置，根据规则获取Inventory中的管理主机列表，并行的在这些主机中执行配置的任务，最后等待执行返回的结果。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、加载自己的配置文件 默认/etc/ansible/ansible.cfg&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、查找对应的主机配置文件，找到要执行的主机或者组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、加载自己对应的模块文件，如command&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、对应执行用户的家目录的.ansible/tmp/XXX/XXX.PY文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6、给文件+x执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、执行并返回结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8、删除临时py文件，sleep 0退出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;ansible安装常用两种方式，yum安装和pip程序安装&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1使用yum安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;yum install epel-release -y&lt;/p&gt;
&lt;p&gt;yum install ansible –y&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2 使用pip（python的包管理模块）安装&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;pip install ansible&lt;/p&gt;
&lt;p&gt;如果没pip,需先安装pip.yum可直接安装：&lt;/p&gt;
&lt;p&gt;yum install python-pip&lt;/p&gt;
&lt;p&gt;pip install ansible&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;安装目录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;配置文件目录：/etc/ansible/&lt;/p&gt;
&lt;p&gt;执行文件目录：/usr/bin/&lt;/p&gt;
&lt;p&gt;Lib库依赖目录：/usr/lib/pythonX.X/site-packages/ansible/&lt;/p&gt;
&lt;p&gt;Help文档目录：/usr/share/doc/ansible-X.X.X/&lt;/p&gt;
&lt;p&gt;Man文档目录：/usr/share/man/man1/&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;ansible配置文件的查找顺序&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;(1).检查环境变量ANSIBLE_CONFIG指向的路径文件(export ANSIBLE_CONFIG=/etc/ansible.cfg)&lt;/p&gt;
&lt;p&gt;(2).~/.ansible.cfg,检查当前目录下的ansible.cfg配置文件&lt;/p&gt;
&lt;p&gt;(3)./etc/ansible.cfg 检查etc目录的配置文件&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;vim /etc/ansible/ansible.cfg&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设置ansible.cfg配置参数，ansible有许多参数，下面列出常用的参数：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;inventory：&lt;/strong&gt;&lt;/span&gt; #这个参数表示资源清单inventory文件的位置，资源清单就是一些Ansible需要连接管理的主 机列表。这个参数的配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;inventory = /etc/ansible/hosts&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;library：&lt;/strong&gt;&lt;/span&gt;Ansible的操作动作，无论是本地或远程，都使用一小段代码来执行，这小段代码称为模块，这个library参数就是指向存放Ansible模块的目录。配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;library = /usr/share/ansible&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Ansible支持多个目录方式，只要用冒号（：）隔开就可以，同时也会检查当前执行playbook位置下的./library目录。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;forks：&lt;/strong&gt;&lt;/span&gt; 设置默认情况下Ansible最多能有多少个进程同时工作， 从Ansible 1.3开始,fork数量默认自动设置为主机数量或者潜在的主机数量,默认设置最多5个进程并行处理。具体需要设置多少个，可以根据控制主机的性能和被管节点的数量来确定，可能是 50或100。默认值5是非常保守的值，配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;forks = 5&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;sudo_user：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是设置默认执行命令的用户，也可以在playbook中重新设置这个参数。配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;sudo_user = root&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;remote_port：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是指定连接被管节点的管理端口，默认是22。除非设置了特殊的SSH端口，不然这个参数一般是不需要修改的（如果需要修改，则还需修改ssh的配置文件，更改端口）。&lt;/p&gt;
&lt;p&gt;配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;remote_port = 22&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;host_key_checking：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是设置是否检查SSH主机的密钥。可以设置为True或False，关闭后第一次连接没有提示（就是第一次连接不在提示yes或者no）&lt;/p&gt;
&lt;p&gt;配置实例：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;host_key_checking = False&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;timeout：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是设置SSH连接的超时间隔，单位是秒。配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;timeout = 60&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;log_path：&lt;/strong&gt;&lt;/span&gt;Ansible系统默认是不记录日志的，如果想把Ansible系统的输出记录到日志文件中，需要置log_path&lt;/p&gt;
&lt;p&gt;来指定一个存储Ansible日志的文件。配置实例如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;log_path = /var/log/ansible.log&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另外需要注意，执行Ansible的用户需要有写入日志的权限，模块将会调用被管节点的syslog来记录&lt;/p&gt;


&lt;p&gt;编辑&lt;span&gt;&lt;strong&gt;/etc/ansible/hosts:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;#vim /etc/ansible/hosts定义方式：&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、直接指明主机地址或主机名：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;## green.example.com#&lt;/p&gt;
&lt;p&gt;# blue.example.com#&lt;/p&gt;
&lt;p&gt;# 192.168.100.1&lt;/p&gt;
&lt;p&gt;# 192.168.100.10&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、定义一个主机组[组名]把地址或主机名加进去&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;[mysql_test]&lt;/p&gt;
&lt;p&gt;192.168.253.159&lt;/p&gt;
&lt;p&gt;192.168.253.160&lt;/p&gt;
&lt;p&gt;192.168.253.153&lt;/p&gt;
&lt;p&gt;#组成员可以使用通配符来匹配，如下 &lt;span&gt;&lt;strong&gt;192.168.2.[1:6] #表示匹配从192.168.2.1——192.168.2.6的主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;Ansible命令集&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible&lt;/strong&gt;&lt;/span&gt; # Ansibe AD-Hoc 临时命令执行工具，常用于临时命令的执行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible-doc&lt;/strong&gt;&lt;/span&gt; # Ansible 模块功能查看工具&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible-galaxy&lt;/strong&gt;&lt;/span&gt; # 下载/上传优秀代码或Roles模块 的官网平台，基于网络的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible-playbook&lt;/strong&gt;&lt;/span&gt; # Ansible 定制自动化的任务集编排工具&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible-pull&lt;/strong&gt;&lt;/span&gt; # Ansible远程执行命令的工具，拉取配置而非推送配置（使用较少，海量机器时使用，对运维的架构能力要求较高）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible-vault&lt;/strong&gt;&lt;/span&gt; # Ansible 文件加密工具&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;/usr/bin/ansible-console&lt;/strong&gt;&lt;/span&gt; # Ansible基于Linux Consoble界面可与用户交互的命令执行工具&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Ansible-doc命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;查看 ansible-doc 的使用说明：&lt;/p&gt;
&lt;p&gt;一般用法:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible-doc -l 获取模块信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible-doc -s MOD_NAME 获取指定模块的使用帮助&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;ansible-doc 选项：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;-h --help 显示命令参数API文档&lt;/p&gt;
&lt;p&gt;-l --list 列出可用的模块&lt;/p&gt;
&lt;p&gt;-M MODULE_PATH, --module-path=MODULE_PATH 指定模块的路径&lt;/p&gt;
&lt;p&gt;-s, --snippet 显示playbook制定模块的用法&lt;/p&gt;
&lt;p&gt;--version 显示ansible-doc的版本号查看模块列表&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Ansible命令详解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;命令格式：&lt;/p&gt;
&lt;p&gt;ansible &amp;lt;host-pattern&amp;gt; [-f forks] [-m module_name] [-a args]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;host-pattern&lt;/strong&gt;&lt;/span&gt; 主机组&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-f forks&lt;/strong&gt;&lt;/span&gt; 并发连接数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-m module_name&lt;/strong&gt;&lt;/span&gt; 指定模块 执行模块的名字，默认使用 command 模块，所以如果是只执行单一命令可以不用 -m参数module name to execute (default=command)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-a args&lt;/strong&gt;&lt;/span&gt; 指定模块参数&lt;/p&gt;
&lt;p&gt;-k, --ask-pass登录密码，提示输入SSH密码而不是假设基于密钥的验证&lt;/p&gt;
&lt;p&gt;--ask-su-pass su切换密码&lt;/p&gt;
&lt;p&gt;-K, --ask-sudo-pass ask for sudo password 提示密码使用sudo,sudo表示提权操作&lt;/p&gt;
&lt;p&gt;--ask-vault-pass ask for vault password&lt;/p&gt;
&lt;p&gt;-B SECONDS, --background=SECONDS 后台运行超时时间&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-C, --check&lt;/strong&gt;&lt;/span&gt; don't make any changes; instead, try to predict some of the changes that may occur&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-c CONNECTION, --connection=CONNECTION 连接类型使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-i INVENTORY, --inventory-file=INVENTORY&lt;/strong&gt;&lt;/span&gt; 指定库存主机文件的路径,默认为/etc/ansible/hosts&lt;/p&gt;
&lt;p&gt;-M MODULE_PATH, --module-path=MODULE_PATH 要执行的模块的路径，默认为/usr/share/ansible/&lt;/p&gt;
&lt;p&gt;specify path(s) to module library (default=/usr/share/ansible/)&lt;/p&gt;
&lt;p&gt;-o, --one-line condense output 压缩输出，摘要输出.尝试一切都在一行上输出。&lt;/p&gt;
&lt;p&gt;-P POLL_INTERVAL, --poll=POLL_INTERVAL 调查背景工作每隔数秒。需要- b&lt;/p&gt;
&lt;p&gt;set the poll interval if using -B (default=15)&lt;/p&gt;
&lt;p&gt;-S, --su run operations with su 用 su 命令&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-R SU_USER, --su-user=SU_USER&lt;/strong&gt;&lt;/span&gt; 指定SU的用户，默认是root用户&lt;/p&gt;
&lt;p&gt;run operations with su as this user (default=root)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-s, --sudo&lt;/strong&gt;&lt;/span&gt; run operations with sudo &lt;span&gt;&lt;strong&gt;(nopasswd)（使用sudo需要配置sudo的配置文件）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-U SUDO_USER, --sudo-user=SUDO_USER&lt;/strong&gt;&lt;/span&gt; sudo到哪个用户，默认为 root&lt;/p&gt;
&lt;p&gt;desired sudo user (default=root)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-T TIMEOUT&lt;/strong&gt;&lt;/span&gt;, --timeout=TIMEOUT 指定SSH默认超时时间， 默认是10S&lt;/p&gt;
&lt;p&gt;-t TREE, --tree=TREE log output to this directory 将日志内容保存在该输出目录,结果保存在一个文件中在每台主机上。&lt;/p&gt;
&lt;p&gt;-u REMOTE_USER, --user=REMOTE_USER 远程用户， 默认是root用户 connect as this user (default=root)&lt;/p&gt;
&lt;p&gt;--vault-password-file=VAULT_PASSWORD_FILE vault password file&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-v, --verbose&lt;/strong&gt;&lt;/span&gt; verbose mode (-vvv for more, -vvvv to enable 详细信息&lt;/p&gt;
&lt;p&gt;--version show program's version number and exit 输出ansible的版本&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible all --lists-hosts&lt;/strong&gt;&lt;/span&gt; 列出所有主机组里面主机&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible web --lists-hosts&lt;/strong&gt;&lt;/span&gt; 列出指定主机组里面的主机&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;配置ansible使用公钥验证&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;虽然ansible支持其他主机认证方式，但是我们最常用的的还是基于秘钥的认证&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、首先生成秘钥&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ssh-keygen -t rsa -P ''&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、然后向主机分发秘钥：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ssh-copy-id root@ #@后面跟主机名或者IP地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如：ssh-copy-id &lt;span&gt;root@192.168.10.190&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3.然后测试，使用ssh连接，不用密码就可登陆&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;4、如果出现以下情况：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;# ssh-copy-id -i ~/.ssh/id_rsa.pub 10.1.6.72&lt;/p&gt;
&lt;p&gt;-bash: ssh-copy-id: command not found请尝试：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;yum -y install openssh-clientsansible&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;我在/etc/ansible/hosts中配置了主机组，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205620759-1787168533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1、主机连通性测试：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;#ansible all -m ping执行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205621040-89483415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以ansible web -m ping&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、command：在远程主机执行命令；不支持|管道命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ansible all|web -m command -a 'ifconfig'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205621603-282921948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令模块接受命令名称，后面是空格分隔的列表参数。给定的命令将在所有选定的节点上执行。它不会通过shell进行处理，&lt;span&gt;&lt;strong&gt;比如$HOME和操作如&quot;小于&quot;&amp;lt;&quot;,&quot;&amp;gt;&quot;, &quot;|&quot;, &quot;;&quot;,&quot;&amp;amp;&quot;' 工作(需要使用(shell)模块实现这些功能)。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;action: command&lt;/p&gt;
&lt;p&gt;chdir # 在执行命令之前，先切换到该目录&lt;/p&gt;
&lt;p&gt;ansible web -a &quot;chdir=/app ls&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205621822-496901734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;creates # 一个文件名，当这个文件存在，则该命令不执行,可以用来做判断&lt;/p&gt;
&lt;p&gt;ansible web -a &quot;creates=/app/111 chdir=/app ls&quot; 因为192.168.10.187主机上存在/app/111所以跳过，不列出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205622009-987269001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;executable # 切换shell来执行命令，需要使用命令的绝对路径&lt;/p&gt;
&lt;p&gt;free_form # 要执行的Linux指令，一般使用Ansible的-a参数代替。&lt;/p&gt;
&lt;p&gt;removes # 一个文件名，这个文件不存在，则该命令不执行,与creates相反的判断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205622259-1998776882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为192.168.10.190主机上没有/app/111，所以跳过，不列出&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;span&gt;3、shell模块在远程主机上调用shell解释器运行命令，支持shell的各种功能，例如管道等&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;例如：ansible web -m shell -a 'cat /etc/passwd|grep root'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205622478-251755673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;4、copy：复制文件到远程主机，可以改权限等用法：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;(1) 复制文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;-a &quot;src= dest= &quot;&lt;/p&gt;
&lt;p&gt;例如：ansible web -m copy -a &quot;src=/app/111 dest=/app/test.sh&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205622790-213377604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在主机组中看看拷贝的文件&lt;/p&gt;
&lt;p&gt;主机192.168.10.187&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205622915-482467925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主机192.168.10.190&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205623087-20292079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(2) 给定内容生成文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;-a &quot;content= dest= &quot;&lt;/p&gt;
&lt;p&gt;例如：ansible web -m copy -a &quot;content='hello word' dest=/app/test.ansible mode=666&quot;源是给定的内容hello word,目标是/app/test.ansible,拷贝过去的文件权限为666&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205623322-1178594007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在主机组中看看拷贝的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205623603-1778576529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一个也是如此&lt;/p&gt;

&lt;p&gt;相关选项如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;backup：&lt;/strong&gt;&lt;/span&gt;在覆盖之前，将源文件备份，备份文件包含时间信息。有两个选项：yes|no backup=yes备份&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;content：&lt;/strong&gt;&lt;/span&gt;用于替代&quot;src&quot;，可以直接设定指定文件的值&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;dest：&lt;/strong&gt;&lt;/span&gt;必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;directory_mode：&lt;/strong&gt;&lt;/span&gt;递归设定目录的权限，默认为系统默认权限&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;force：&lt;/strong&gt;&lt;/span&gt;如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;others：&lt;/strong&gt;&lt;/span&gt;所有的file模块里的选项都可以在这里使用&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;src：&lt;/strong&gt;&lt;/span&gt;被复制到远程主机的本地文件，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用&quot;/&quot;来结尾，则只复制目录里的内容，如果没有使用&quot;/&quot;来结尾，则包含目录在内的整个内容全部复制，类似于rsync。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;5、file 设置文件属性：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建目录：&lt;/strong&gt;&lt;/span&gt;-a &quot;path= state=directory&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;创建链接文件：&lt;/strong&gt;&lt;/span&gt;-a &quot;path= src= state=link&quot;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;删除文件：&lt;/strong&gt;&lt;/span&gt;-a &quot;path= state=absent&quot;&lt;/p&gt;
&lt;p&gt;其他选项：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;force：&lt;/strong&gt;&lt;/span&gt;需要在两种情况下强制创建软链接，一种是源文件不存在，但之后会建立的情况下；另一种是目标软链接已存在，需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;group：&lt;/strong&gt;&lt;/span&gt;定义文件/目录的属组 mode：定义文件/目录的权限&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;owner：&lt;/strong&gt;&lt;/span&gt;定义文件/目录的属主 path：必选项，定义文件/目录的路径&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;recurse：&lt;/strong&gt;&lt;/span&gt;递归设置文件的属性，只对目录有效 src：被链接的源文件路径，只应用于state=link的情况&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;dest：&lt;/strong&gt;&lt;/span&gt;被链接到的路径，只应用于state=link的情况&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;state：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;directory：&lt;/strong&gt;如果目录不存在，就创建目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;file：&lt;/strong&gt;即使文件不存在，也不会被创建&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;link：&lt;/strong&gt;创建软链接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hard：&lt;/strong&gt;创建硬链接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;touch：&lt;/strong&gt;如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;absent：&lt;/strong&gt;删除目录、文件或者取消链接文件&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;ansible web -m file -a &quot;path=/data/webapps state=directory&quot; 创建目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205623853-1162257763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ansible web -m file -a &quot;path=/data/webapps/111 state=touch&quot;创建文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205624103-1303137622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ansible web -m file -a &quot;path=/data/webapps/111.link src=/data/webapps/111 state=link&quot; 创建软链接&lt;/p&gt;
&lt;p&gt;或者ansible web -m file -a &quot;dest=/data/webapps/111.link src=/data/webapps/111 state=link&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205624322-525128675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ansible web -m file -a &quot;path=/data/webapps state=absent&quot;删除目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205624525-1050723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;6、fetch从远程某主机获取文件到本地：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;dest：&lt;/strong&gt;&lt;/span&gt;用来存放文件的目录，例如存放目录为backup，源文件名称为/etc/profile在主机pythonserver中，那么保存为/backup/pythonserver/etc/profile&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Src：&lt;/strong&gt;&lt;/span&gt;在远程拉取的文件，并且必须是一个file，不能是目录&lt;/p&gt;
&lt;p&gt;例如：ansible web -m fetch -a &quot;src=/app/111 dest=/root/test&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205624837-1377839829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在本机查看从远程主机获取的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205625072-296598068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经用远程主机IP给你建好了目录结构，让你知道是从哪台主机拷过来的文件，非常贴心&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;7、cron 管理cron计划任务：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;-a &quot;&quot;: 设置管理节点生成定时任务&lt;/p&gt;
&lt;p&gt;action: cron backup= # 如果设置，创建一个crontab备份 【yes|no】&lt;/p&gt;
&lt;p&gt;cron_file= #如果指定, 使用这个文件cron.d，而不是单个用户&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;crontab&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;day= #日应该运行的工作( 1-31, *, */2, )&lt;/p&gt;
&lt;p&gt;hour= # 小时 ( 0-23, *, */2, )&lt;/p&gt;
&lt;p&gt;minute= #分钟( 0-59, *, */2, )&lt;/p&gt;
&lt;p&gt;month= # 月( 1-12, *, /2, )&lt;/p&gt;
&lt;p&gt;weekday # 周 ( 0-6 for Sunday-Saturday,, )&lt;/p&gt;
&lt;p&gt;job= #指明运行的命令是什么&lt;/p&gt;
&lt;p&gt;name= #定时任务描述&lt;/p&gt;
&lt;p&gt;reboot # 任务在重启时运行，不建议使用，建议使用special_time&lt;/p&gt;
&lt;p&gt;special_time #特殊的时间范围，参数：reboot（重启时）,annually（每年）,monthly（每月）,weekly&lt;/p&gt;
&lt;p&gt;（每周）,daily（每天）,hourly（每小时）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;state #指定状态，present表示添加定时任务，也是默认设置，absent表示删除定时任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;user # 以哪个用户的身份执行&lt;/p&gt;
&lt;p&gt;例如：ansible web -m cron -a &quot;name='ntp update every 5' minute=*/5 job='/sbin/ntpdate 172.17.0.1 &amp;amp;&amp;gt; /dev/null'&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205625290-42710545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再去查看一下，计划任务已经添加进去了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205625493-314346673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再添加计划任务，但是name注释不能和之前设置的name注释一样，否则将会覆盖之前的计划任务&lt;/p&gt;
&lt;p&gt;删除已经设置的计划任务，指定状态state=absent&lt;/p&gt;
&lt;p&gt;ansible web -m cron -a &quot;name='ntp update every 5' minute=*/5 job='/sbin/ntpdate 172.17.0.1 &amp;amp;&amp;gt; /dev/null' state=absent&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205625884-451058706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以用special_time来设置计划任务,例如：&lt;/p&gt;
&lt;p&gt;ansible web -m cron -a &quot;name='ntp update every 5' special_time=hourly job='/sbin/ntpdate 172.17.0.1 &amp;amp;&amp;gt; /dev/null'&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205626150-1961671366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;8、yum安装软件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;conf_file #设定远程yum安装时所依赖的配置文件。如配置文件没有在默认的位置。&lt;/p&gt;
&lt;p&gt;disable_gpg_check #是否禁止GPG checking，只用于`present' or `latest'。&lt;/p&gt;
&lt;p&gt;disablerepo #临时禁止使用yum库。 只用于安装或更新时。&lt;/p&gt;
&lt;p&gt;enablerepo #临时使用的yum库。只用于安装或更新时。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;name=&lt;/strong&gt;&lt;/span&gt;#所安装的包的名称&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;state=&lt;/strong&gt;&lt;/span&gt; #present安装， latest安装最新的, absent 卸载软件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;update_cache&lt;/strong&gt;&lt;/span&gt;#强制更新yum的缓存。&lt;/p&gt;
&lt;p&gt;例如：ansible web -m yum -a &quot;name=vsftpd state=present disable_gpg_check=yes&quot; 安装包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205626650-478547641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ansible web -m yum -a &quot;name=vsftpd state=absent&quot;卸载包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205627150-60836524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装yum仓库里面没有的包&lt;/p&gt;
&lt;p&gt;1.将一个rpm包从本机拷贝到远程主机的家目录中&lt;/p&gt;
&lt;p&gt;ansible web -m copy -a &quot;src=/root/mha4mysql-node-0.56-0.el6.noarch.rpm dest=/root&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205627431-1042967359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.安装包，需要指定路径&lt;/p&gt;
&lt;p&gt;ansible web -m yum -a &quot;name=&lt;span&gt;&lt;strong&gt;/root/mha4mysql-node-0.56-0.el6.noarch.rpm&lt;/strong&gt;&lt;/span&gt; state=present disable_gpg_check=yes&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205627900-1907982056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3，卸载包，此时就不需要指定路径了，而且名字也改变了&lt;/p&gt;
&lt;p&gt; ansible web -m yum -a &quot;&lt;span&gt;&lt;strong&gt;name=mha4mysql-node&lt;/strong&gt;&lt;/span&gt; state=absent&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205628322-1828444720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;9、service: 服务程序管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;arguments #命令行提供额外的参数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;enabled&lt;/strong&gt;&lt;/span&gt; #设置开机启动。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;name=&lt;/strong&gt;&lt;/span&gt;#服务名称&lt;/p&gt;
&lt;p&gt;runlevel #开机启动的级别，一般不用指定。&lt;/p&gt;
&lt;p&gt;sleep #在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;state&lt;/strong&gt;&lt;/span&gt;#started启动服务， stopped停止服务， restarted重启服务， reloaded重载配置启动nginx服务并设置范围自启动：&lt;/p&gt;
&lt;p&gt;例如：nginx服务&lt;/p&gt;
&lt;p&gt;1.先安装个nginx&lt;/p&gt;
&lt;p&gt;ansible web -m yum -a &quot;name=nginx state=present disable_gpg_check=yes&quot;&lt;/p&gt;
&lt;p&gt;2.开启nginx服务，并设置为开机自启&lt;/p&gt;
&lt;p&gt;ansible web -m service -a &quot;name=nginx state=started enabled=yes&quot;&lt;/p&gt;
&lt;p&gt;3.关闭nginx服务&lt;/p&gt;
&lt;p&gt;ansible web -m service -a &quot;name=nginx state=stopped&quot;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;10、user模块管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;用户模块,管理用户帐号action: user&lt;/p&gt;
&lt;p&gt;comment # 用户的描述信息&lt;/p&gt;
&lt;p&gt;createhome # 是否创建家目录&lt;/p&gt;
&lt;p&gt;force # 在使用state=absent是, 行为与userdel –force一致.&lt;/p&gt;
&lt;p&gt;group # 指定基本组&lt;/p&gt;
&lt;p&gt;groups # 指定附加组，如果指定为(groups=)表示删除所有组&lt;/p&gt;
&lt;p&gt;home # 指定用户家目录&lt;/p&gt;
&lt;p&gt;move_home # 如果设置为home=时, 试图将用户主目录移动到指定的目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;/span&gt; # 指定用户名&lt;/p&gt;
&lt;p&gt;non_unique # 该选项允许改变非唯一的用户ID值（可以多个 用户共用一个ID）&lt;/p&gt;
&lt;p&gt;password # 指定用户密码&lt;/p&gt;
&lt;p&gt;remove # 在使用state=absent时, 行为是与userdel –remove一致&lt;/p&gt;
&lt;p&gt;shell # 指定默认shell（例如：不让用户登录的shell是/sbin/nologin）&lt;/p&gt;
&lt;p&gt;state # 设置帐号状态，不指定为创建，指定值为absent表示删除&lt;/p&gt;
&lt;p&gt;system # 当创建一个用户，设置这个用户是系统用户。这个设置不能更改现有用户（centos6是0-500是系统用户，centos7 0-1000是系统用户）&lt;/p&gt;
&lt;p&gt;uid # 指定用户的uid&lt;/p&gt;
&lt;p&gt;update_password # 更新用户密码&lt;/p&gt;
&lt;p&gt;例如:创建一个用户ansible web -m user -a &quot;name=magedu01 password=magedu uid=10001 shell=/bin/sh&quot; （注意：这里指定的密码在/etc/shadow里面是明文的，所以密码还需要通过openssl去加密一下）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205628603-1955817595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看一下，创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205628775-977493321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除用户ansible web -m user -a &quot;name=magedu01 state=absent&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205629025-350800265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;11、group&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;用户组模块,添加或删除组&lt;/p&gt;
&lt;p&gt;action: group&lt;/p&gt;
&lt;p&gt;gid # 设置组的GID号&lt;/p&gt;
&lt;p&gt;name= # 管理组的名称&lt;/p&gt;
&lt;p&gt;state # 指定组状态，默认为创建，设置值为absent为删除&lt;/p&gt;
&lt;p&gt;system # 设置值为yes，表示为创建系统组&lt;/p&gt;
&lt;p&gt;创建名为tom的组&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible web -m group -a 'name=tom state=present'&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;12、script在指定节点运行服务端的脚本&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在本机家目录下写一个脚本，然后在两台远程主机上运行&lt;/p&gt;
&lt;p&gt;vim /root/test.sh&lt;/p&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;p&gt;date &amp;gt;&amp;gt; /app/disk_total.log&lt;/p&gt;
&lt;p&gt;df -lh &amp;gt;&amp;gt; /app/disk_total.log&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible web -m script -a '/root/test.sh'&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205629353-1498150470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205629665-1703647034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;13、setup模块&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;facts组件是Ansible用于采集被管机器设备信息的一个功能，我们可以使用setup模块查机器的所有facts信息，可以使用filter来查看指定信息。整个facts信息被包装在一个JSON格式的数据结构中，ansible_facts是最上层的值&lt;/p&gt;
&lt;p&gt;facts就是变量，内建变量 。每个主机的各种信息，cpu颗数、内存大小等。会存在facts中的某个变量中。调用后返回很多对应主机的信息，在后面的操作中可以根据不同的信息来做不同的操作。如redhat系列用yum安装，而debian系列用apt来安装软件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;setup模块，主要用于获取主机信息，在playbooks里经常会用到的一个参数gather_facts就与该模块相关。&lt;/strong&gt;&lt;/span&gt;setup模块下经常使用的一个参数是filter参数，具体使用示例如下（由于输出结果较多，这里只列命令不写结果）：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;absible web -m setup&lt;/strong&gt;&lt;/span&gt; 获取所有的主机信息&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible web -m setup -a 'filter=ansible_*_mb'&lt;/strong&gt;&lt;/span&gt; //查看主机内存信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205629993-1334164306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible web -m setup -a 'filter=ansible_eth[0-2]'&lt;/strong&gt;&lt;/span&gt; //查看地接口为eth0-2的网卡信息&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ansible all -m setup --tree /tmp/facts&lt;/strong&gt;&lt;/span&gt; //将所有主机的信息输入到/tmp/facts目录下，每台主机的信息输入到主机名文件中（/etc/ansible/hosts里的主机名）&lt;/p&gt;
&lt;p&gt;在本机中查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205631056-1742516363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;playbook是ansible用于配置，部署，和管理被控节点的剧本。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过playbook的详细描述，执行其中的一系列tasks，可以让远端主机达到预期的状态。playbook就像Ansible控制器给被控节点列出的的一系列to-do-list，而被控节点必须要完成。&lt;/p&gt;
&lt;p&gt;也可以这么理解，playbook 字面意思，即剧本，现实中由演员按照剧本表演，在Ansible中，这次由计算机进行表演，由计算机安装，部署应用，提供对外服务，以及组织计算机处理各种各样的事情。&lt;/p&gt;


&lt;p&gt;（1）执行一些简单的任务，使用ad-hoc命令可以方便的解决问题，但是有时一个设施过于复杂，需要大量的操作时候，执行的ad-hoc命令是不适合的，这时最好使用playbook。&lt;/p&gt;
&lt;p&gt;（2）就像执行shell命令与写shell脚本一样，也可以理解为批处理任务，不过playbook有自己的语法格式。&lt;/p&gt;
&lt;p&gt;（3）使用playbook你可以方便的重用这些代码，可以移植到不同的机器上面，像函数一样，最大化的利用代码。在你使用Ansible的过程中，你也会发现，你所处理的大部分操作都是编写playbook。可以把常见的应用都编写成playbook，之后管理服务器会变得十分简单。&lt;/p&gt;


&lt;p&gt;playbook由YMAL语言编写。YAML( /ˈjæməl/ )参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822，Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。&lt;/p&gt;
&lt;p&gt;YMAL格式是类似于JSON的文件格式，便于人理解和阅读，同时便于书写。首先学习了解一下YMAL的格式，对我们后面书写playbook很有帮助。以下为playbook常用到的YMAL格式。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;文件的第一行应该以 &quot;—&quot; (三个连字符)开始，表明YMAL文件的开始。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在同一行中，#之后的内容表示注释，类似于shell，python和ruby。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;YMAL中的列表元素以&quot;-&quot;开头然后紧跟着一个空格，后面为元素内容。就像这样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- apple - banana - orange等价于JSON的这种格式&lt;/p&gt;

&lt;p&gt;[ &quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot; ]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同一个列表中的元素应该保持相同的缩进。否则会被当做错误处理。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;play中hosts，variables，roles，tasks等对象的表示方法都是键值中间以&quot;:&quot;分隔表示,&quot;:&quot;后面还要增加一&lt;/p&gt;
&lt;p&gt;个空格。&lt;/p&gt;
&lt;p&gt;例如：vim /etc/ansible/mysql.yml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205631415-354230091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在mysql.yml中，主要由三个部分组成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;hosts部分&lt;/strong&gt;&lt;/span&gt;：使用hosts指示使用哪个主机或主机组来运行下面的tasks，每个playbook都必须指定hosts，hosts也可以使用通配符格式。主机或主机组在inventory清单中指定，可以使用系统默认的&lt;/p&gt;
&lt;p&gt;/etc/ansible/hosts，也可以自己编辑，在运行的时候加上-i选项，指定清单的位置即可。在运行清单文件的时候，–list-hosts选项会显示那些主机将会参与执行task的过程中&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;remote_user：&lt;/strong&gt;&lt;/span&gt;指定远端主机中的哪个用户来登录远端系统，在远端系统执行task的用户，可以任意指定，也可以使用sudo，但是用户必须要有执行相应task的权限。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tasks：&lt;/strong&gt;&lt;/span&gt;指定远端主机将要执行的一系列动作。tasks的核心为ansible的模块，前面已经提到模块的用法。tasks包含name和要执行的模块，name是可选的，只是为了便于用户阅读，不过还是建议加上去，模块是必须的，同时也要给予模块相应的参数。&lt;/p&gt;

&lt;p&gt;使用ansible-playbook运行playbook文件，得到如下输出信息，输出内容为JSON格式。并且由不同颜色组成，便于识别。一般而言&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;绿色代表执行成功，系统保持原样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;黄色代表系统代表系统状态发生改变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;红色代表执行失败，显示错误输出。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;执行有三个步骤：1、收集facts 2、执行tasks 3、报告结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205631806-1341684306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Playbook的核心元素：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Hosts：主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tasks：任务列表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Variables&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Templates：包含了模板语法的文本文件；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Handlers：由特定条件触发的任务；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Playbooks配置文件的基础组件：&lt;/p&gt;
&lt;p&gt;Hosts：运行指定任务的目标主机；&lt;/p&gt;
&lt;p&gt;remoute_user: 在远程主机上执行任务的用户；&lt;/p&gt;
&lt;p&gt;sudo_user：&lt;/p&gt;
&lt;p&gt;tasks：任务列表&lt;/p&gt;
&lt;p&gt;模块，模块参数；&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;(1) action: module arguments&lt;/p&gt;
&lt;p&gt;(2) module: arguments&lt;/p&gt;
&lt;p&gt;注意：shell和command模块后面直接跟命令，而非key=value类的参数列表；&lt;/p&gt;
&lt;p&gt;(1) 某任务的状态在运行后为changed时，可通过&lt;span&gt;&lt;strong&gt;&quot;notify&quot;通知给相应的handlers&lt;/strong&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;(2) &lt;span&gt;&lt;strong&gt;任务可以通过&quot;tags&quot;打标签，而后可在ansible-playbook命令上使用-t指定进行调用&lt;/strong&gt;&lt;/span&gt;；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;handlers：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;任务，在特定条件下触发；&lt;/p&gt;
&lt;p&gt;接收到其它任务的通知时被触发；&lt;/p&gt;
&lt;p&gt;tasks：&lt;/p&gt;
&lt;p&gt;– name: TASK_NAME&lt;/p&gt;
&lt;p&gt; module: arguments&lt;/p&gt;
&lt;p&gt; notify: HANDLER_NAME&lt;/p&gt;
&lt;p&gt; handlers:&lt;/p&gt;
&lt;p&gt;– name: HANDLER_NAME&lt;/p&gt;
&lt;p&gt; module: arguments&lt;/p&gt;
&lt;p&gt;小实验：&lt;/p&gt;
&lt;p&gt;先做一个简单的剧本，安装个samba，然后再开启服务，剧本内容如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205631993-928600609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再去让web中的远程主机执行剧本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205632290-1559878946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是现在我只想开启服务，不想再次安装samba（因为已经安装过了），此时就可以给启动服务打个标签，这样执行剧本就只开启服务了&lt;/p&gt;
&lt;p&gt;更改剧本，打个标签,如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205632540-1629234335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先停掉smb服务&lt;/p&gt;
&lt;p&gt;ansible web -m service -a &quot;name=smb state=stopped&quot;&lt;/p&gt;
&lt;p&gt;然后再去执行剧本，使用-t调用我们刚才打的标签，如图：没有再去安装samba，只启动服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205632884-902377748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在有一个需求，当nginx的配置文件发生变化时，就restarted,剧本如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205633150-487335399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后执行剧本&lt;/p&gt;
&lt;p&gt;ansible-playbook nginx.yml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205633493-1550294807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看端口号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205633712-2033457736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在改变nginx的配置文件，也就是修改/app/nginx.conf，然后就可以触发handlers&lt;/p&gt;
&lt;p&gt;我就修改一个端口，将nginx监听的端口改为8888&lt;/p&gt;
&lt;p&gt;然后再次执行剧本，-t调用打的标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205634056-661648623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再来查看端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205634259-429053519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;variables：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;(1) facts：可直接调用；&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;注意：可使用setup模块直接获取目标主机的facters；ansible web -m setup 来获取主机的信息，里面有各种变量&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;{{ ansible_eth0['ipv4']['address'] }} centos6的IP地址变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;{{ ansible_ens33['ipv4']['address'] }} centos7的IP地址变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;(2) 用户自定义变量：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(a) ansible-playbook命令的命令行中的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-e VARS, --extra-vars=VARS 也就是在命令中指定变量是什么&lt;/p&gt;
&lt;p&gt;ansible-playbook nginx.yml -e rpmname=vsftpd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205634556-1280185895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205634775-1805746284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(b) 在playbook中定义变量的方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205635072-269117400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再去改一下/app/nginx.conf，再改变一个端口如：9999&lt;/p&gt;
&lt;p&gt;然后执行剧本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205635368-116910237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(3) 通过roles传递变量；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(4) Host Inventory&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(a) 用户自定义变量&lt;/p&gt;
&lt;p&gt;(i) 向不同的主机传递不同的变量；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP/HOSTNAME varaiable=value var2=value2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(ii) 向组中的主机传递相同的变量；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;[groupname:vars]&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;variable=value&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[web]&lt;/p&gt;
&lt;p&gt;172.17.251.188&lt;/p&gt;
&lt;p&gt;172.17.250.209&lt;/p&gt;
&lt;p&gt;[web:vars]&lt;/p&gt;
&lt;p&gt;rpmname=samba&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;运行playbook的方式：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;(1) 测试&lt;/p&gt;
&lt;p&gt;ansible-playbook --check 只检测可能会发生的改变，但不真正执行操作；&lt;/p&gt;
&lt;p&gt;ansible-playbook --list-hosts 列出运行任务的主机；&lt;/p&gt;
&lt;p&gt;(2) 直接运行&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;模板：templates&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;文本文件，嵌套有脚本（使用模板编程语言编写）&lt;/p&gt;
&lt;p&gt;Jinja2：Jinja2是python的一种模板语言，以Django的模板语言为原本&lt;/p&gt;
&lt;p&gt;支持：&lt;/p&gt;
&lt;p&gt;字符串：使用单引号或双引号；&lt;/p&gt;
&lt;p&gt;数字：整数，浮点数；&lt;/p&gt;
&lt;p&gt;列表：[item1, item2, ...]&lt;/p&gt;
&lt;p&gt;元组：(item1, item2, ...)&lt;/p&gt;
&lt;p&gt;字典：{key1:value1, key2:value2, ...}&lt;/p&gt;
&lt;p&gt;布尔型：true/false&lt;/p&gt;
&lt;p&gt;算术运算：&lt;/p&gt;
&lt;p&gt;+, -, *, /, //, %, **&lt;/p&gt;
&lt;p&gt;比较操作：&lt;/p&gt;
&lt;p&gt;==, !=, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/p&gt;
&lt;p&gt;逻辑运算：&lt;/p&gt;
&lt;p&gt;and, or, not&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;使用模板示例：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1.将/app/nginx.conf改名为/app/nginx.conf.j2 这个配置文件就变成模板配置文件了&lt;/p&gt;
&lt;p&gt;mv /app/nginx.conf /app/nginx.conf.j2&lt;/p&gt;
&lt;p&gt;2.然后将模板配置文件里面的监听端口写成变量,cpu颗数也写成变量&lt;/p&gt;
&lt;p&gt;变量nginxport是我们自己定义的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205635556-165076636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;变量ansible_processor_vcpus是用ansible命令获取的ansible web -m setup |grep cpu&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205635775-928176881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.编写剧本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205636072-1854022331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.执行剧本，查看端口，有8888端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205636400-1618770371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;条件测试：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;when语句：&lt;/strong&gt;&lt;/span&gt;在task中使用，jinja2的语法格式&lt;/p&gt;
&lt;p&gt;tasks:&lt;/p&gt;
&lt;p&gt;- name: install conf file to centos7&lt;/p&gt;
&lt;p&gt; template: src=files/nginx.conf.c7.j2&lt;/p&gt;
&lt;p&gt;when: ansible_distribution_major_version == &quot;7&quot;&lt;/p&gt;
&lt;p&gt;- name: install conf file to centos6&lt;/p&gt;
&lt;p&gt; template: src=files/nginx.conf.c6.j2&lt;/p&gt;
&lt;p&gt;when: ansible_distribution_major_version == &quot;6&quot;&lt;/p&gt;
&lt;p&gt;判断ansible_distribution_major_version这个变量等于6还是7，如果是6，说明是centos6系统，就执行template: src=files/nginx.conf.c6.j2，如果是7，说明是centos7的系统，就执行 template: src=files/nginx.conf.c7.j2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;循环：&lt;/strong&gt;&lt;/span&gt;迭代，需要重复执行的任务；对迭代项的引用，固定变量名为&quot;item&quot;而后，要在task中使用with_items给定要迭代的元素列表；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205636697-931647140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;Ansible playbook字典&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;- name: install some packages&lt;/p&gt;
&lt;p&gt;yum: name={{ item }} state=present&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;with_items:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- nginx&lt;/p&gt;
&lt;p&gt;- memcached&lt;/p&gt;
&lt;p&gt;- php-fpm&lt;/p&gt;

&lt;p&gt;- name: add some groups&lt;/p&gt;
&lt;p&gt;group: name={{ item }} state=present&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;with_items:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- group11&lt;/p&gt;
&lt;p&gt;- group12&lt;/p&gt;
&lt;p&gt;- group13&lt;/p&gt;
&lt;p&gt;- name: add some users&lt;/p&gt;
&lt;p&gt;user: name={{ item.name }} group={{ item.group }} state=present&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;with_items:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;- { name: 'user11', group: 'group11' }&lt;/p&gt;
&lt;p&gt;- { name: 'user12', group: 'group12' }&lt;/p&gt;
&lt;p&gt;- { name: 'user13', group: 'group13' }&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205636962-1960228068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;角色定制：roles&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于以上所有的方式有个弊端就是无法实现复用假设在同时部署Web、db、ha 时或不同服务器组合不同的应用就需要写多个yml文件。很难实现灵活的调用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;roles 用于层次性、结构化地组织playbook。roles 能够根据层次型结构自动装载变量文件、tasks以及handlers等。&lt;/strong&gt;&lt;/span&gt;要使用&lt;/p&gt;
&lt;p&gt;roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量(vars)、文件(file)、任务(tasks)、模块&lt;/p&gt;
&lt;p&gt;(modules)及处理器(handlers)放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;roles目录结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;角色集合：roles/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;mysql/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;httpd/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;nginx/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;files/：&lt;/strong&gt;&lt;/span&gt;存储由copy或script等模块调用的文件；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tasks/：&lt;/strong&gt;&lt;/span&gt;此目录中至少应该有一个名为main.yml的文件，用于定义各task；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;handlers/：&lt;/strong&gt;&lt;/span&gt;此目录中至少应该有一个名为main.yml的文件，用于定义各handler；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;vars/：&lt;/strong&gt;&lt;/span&gt;此目录中至少应该有一个名为main.yml的文件，用于定义各variable；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;templates/：&lt;/strong&gt;&lt;/span&gt;存储由template模块调用的模板文本；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;meta/：&lt;/strong&gt;&lt;/span&gt;此目录中至少应该有一个名为main.yml的文件，定义当前角色的特殊设定及其依赖关系；其它的文件需要由main.yml进行&quot;包含&quot;调用；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;default/：&lt;/strong&gt;&lt;/span&gt;此目录中至少应该有一个名为main.yml的文件，用于设定默认变量；&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;1、在roles目录下生成对应的目录结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cd /etc/ansible/roles&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;mkdir -pv ./{nginx,mysql,httpd}/{files,templates,vars,tasks,handlers,meta,default}&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;我们就以定义nginx角色为例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、定义tasks/main.yml的配置文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;vim /etc/ansible/roles/nginx/tasks/main.yml&lt;/p&gt;
&lt;p&gt;- name: cp&lt;/p&gt;
&lt;p&gt; copy: src=nginx-1.10.2-1.el7.ngx.x86_64.rpm dest=/tmp/nginx-1.10.2-1.el7.ngx.x86_64.rpm&lt;/p&gt;

&lt;p&gt;- name: install&lt;/p&gt;
&lt;p&gt; yum: name=/tmp/nginx-1.10.2-1.el7.ngx.x86_64.rpm state=latest&lt;/p&gt;

&lt;p&gt;- name: conf&lt;/p&gt;
&lt;p&gt; template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf&lt;/p&gt;
&lt;p&gt; tags: nginxconf&lt;/p&gt;
&lt;p&gt; notify: new conf to reload&lt;/p&gt;

&lt;p&gt;- name: start service&lt;/p&gt;
&lt;p&gt; service: name=nginx state=started enabled=true&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.将最新版本的nginx rpm包下载到/etc/ansible/roles/nginx/files下&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cd /etc/ansible/roles/nginx/files&lt;/p&gt;
&lt;p&gt;lftp 172.17.0.1&lt;/p&gt;
&lt;p&gt;cd /pub/Sources/7.x86_64/nginx&lt;/p&gt;
&lt;p&gt;get nginx-1.10.2-1.el7.ngx.x86_64.rpm&lt;/p&gt;
&lt;p&gt;quit&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205637150-148739537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.在/etc/ansible/roles/nginx/templates中配置模板文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cp /etc/nginx/nginx.conf /etc/ansible/roles/nginx/templates/nginx.conf.j2&lt;/p&gt;
&lt;p&gt;vim nginx.conf.j2&lt;/p&gt;
&lt;p&gt;将nginx监听端口和cpu颗数设置为变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205637306-763798763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205637540-377439503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5.在/etc/ansible/roles/nginx/vars目录下配置变量文件mian.yml&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;cd /etc/ansible/roles/nginx/vars&lt;/p&gt;
&lt;p&gt;vim main.yml&lt;/p&gt;
&lt;p&gt;nginxport: 6666&lt;/p&gt;
&lt;p&gt;只配置端口变量就行了，cpu颗数变量是內建的，不用声明&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.配置handlers文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cd /etc/ansible/roles/nginx/handlers&lt;/p&gt;
&lt;p&gt;vim main.yml&lt;/p&gt;
&lt;p&gt;- name: new conf to reload&lt;/p&gt;
&lt;p&gt; service: name=nginx state=restarted&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;7.定义/etc/ansible/roles.yml的playbook文件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;---&lt;/p&gt;
&lt;p&gt;- hosts: web&lt;/p&gt;
&lt;p&gt; remote_user: root&lt;/p&gt;
&lt;p&gt; roles:&lt;/p&gt;
&lt;p&gt; - nginx&lt;/p&gt;
&lt;p&gt;只需定义主机组，远程连接的用户和角色（角色可以配置多个）&lt;/p&gt;
&lt;p&gt;8.测试，执行剧本&lt;/p&gt;
&lt;p&gt;ansible-playbook roles.yml 执行成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205637837-337219080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1235933/201712/1235933-20171209205638025-1814409501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;文件目录结构：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;├── httpd&lt;/p&gt;
&lt;p&gt;│   ├── default&lt;/p&gt;
&lt;p&gt;│   ├── files&lt;/p&gt;
&lt;p&gt;│   ├── handlers&lt;/p&gt;
&lt;p&gt;│   ├── meta&lt;/p&gt;
&lt;p&gt;│   ├── tasks&lt;/p&gt;
&lt;p&gt;│   ├── templates&lt;/p&gt;
&lt;p&gt;│   └── vars&lt;/p&gt;
&lt;p&gt;├── mysql&lt;/p&gt;
&lt;p&gt;│   ├── default&lt;/p&gt;
&lt;p&gt;│   ├── files&lt;/p&gt;
&lt;p&gt;│   ├── handlers&lt;/p&gt;
&lt;p&gt;│   ├── meta&lt;/p&gt;
&lt;p&gt;│   ├── tasks&lt;/p&gt;
&lt;p&gt;│   ├── templates&lt;/p&gt;
&lt;p&gt;│   └── vars&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;└── nginx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ├── default&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ├── files&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; │   └── nginx-1.10.2-1.el7.ngx.x86_64.rpm&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ├── handlers&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; │   └── main.yml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ├── meta&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ├── tasks&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; │   └── main.yml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; ├── templates&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; │   └── nginx.conf.j2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; └── vars&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; └── main.yml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 12:56:00 +0000</pubDate>
<dc:creator>大天使彦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1477717815fuming/p/8012706.html</dc:identifier>
</item>
<item>
<title>OpenCASCADE 参数曲面面积 - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/OpenCASCADE_GaussIntegration.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/OpenCASCADE_GaussIntegration.html</guid>
<description>&lt;h3&gt;OpenCASCADE 参数曲面面积&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;. 本文介绍了参数曲面的第一基本公式，并应用曲面的第一基本公式，结合OpenCASCADE中计算多重积分的类，对任意参数曲面的面积进行计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Words.&lt;/strong&gt; Parametric Curve, Parametric Surface, Gauss Integration, Global Properties&lt;/p&gt;
&lt;h3&gt;1.Introduction&lt;/h3&gt;
&lt;p&gt;我们知道一元函数y=f(x)的图像是一条曲线，二元函数z=f(x,y)的图像是一张曲面。但是，把曲线曲面表示成参数方程则更加便利于研究，这种表示方法首先是由欧洲瑞士数学家Euler引进的。例如，在空间中的一条曲线可以表示为三个一元函数：&lt;/p&gt;
&lt;p&gt;X=x(t), Y=y(t), Z=z(t)&lt;/p&gt;
&lt;p&gt;在向量的概念出现后，空间中的一条曲线可以自然地表示为一个一元向量函数：&lt;/p&gt;
&lt;p&gt;r=r(t)=(x(t), y(t), z(t))&lt;/p&gt;
&lt;p&gt;用向量函数来表示曲线和曲面后，使曲线曲面一些量的计算方式比较统一。如曲线可以表示为一元向量函数，曲面可以表示为二元向量函数。&lt;/p&gt;
&lt;p&gt;本文结合OpenCASCADE来介绍参数曲线曲面积分分别计算曲线弧长和曲面的面积。结合《微分几何》来更好地理解曲线曲面相关知识。&lt;/p&gt;
&lt;h3&gt;2.Curve Natural Parametric Equations&lt;/h3&gt;
&lt;p&gt;设曲线C的参数方程是r=r(t)，命：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204818759-1886017527.png&quot;&gt;&lt;img title=&quot;wps_clip_image-10887&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204818931-600590227.png&quot; alt=&quot;wps_clip_image-10887&quot; width=&quot;255&quot; height=&quot;62&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;则s是该曲线的一个不变量，即它与空间中的坐标系的选择无关，也与该曲线的参数变换无关。前者是因为在笛卡尔直角坐标变换下，切向量的长度|r’(t)|是不变的，故s不变。关于后者可以通过积分的变量的替换来证明，设参数变换是：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819072-907751104.png&quot;&gt;&lt;img title=&quot;wps_clip_image-21189&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819228-233260143.png&quot; alt=&quot;wps_clip_image-21189&quot; width=&quot;311&quot; height=&quot;38&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;并且&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819353-28312953.png&quot;&gt;&lt;img title=&quot;wps_clip_image-16009&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819493-1265592099.png&quot; alt=&quot;wps_clip_image-16009&quot; width=&quot;88&quot; height=&quot;72&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819634-532535419.png&quot;&gt;&lt;img title=&quot;wps_clip_image-31864&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819775-97593601.png&quot; alt=&quot;wps_clip_image-31864&quot; width=&quot;233&quot; height=&quot;64&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据积分的变量替换公式有：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204819947-587719447.png&quot;&gt;&lt;img title=&quot;wps_clip_image-29413&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204820118-257861432.png&quot; alt=&quot;wps_clip_image-29413&quot; width=&quot;470&quot; height=&quot;69&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不变量s的几何意义就是曲线段的弧长。这说明曲线参数t可以是任意的，但选择不同的参数得到的参数方程会有不同，但是曲线段的弧长是不变的。以曲线弧长作为曲线方程的参数，这样的方程称为曲线的自然参数方程Natural Parametric Equations。&lt;/p&gt;
&lt;p&gt;由曲线的参数方程可知，曲线弧长的计算公式为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204820275-112689257.png&quot;&gt;&lt;img title=&quot;wps_clip_image-8988&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204820431-1296219806.png&quot; alt=&quot;wps_clip_image-8988&quot; width=&quot;255&quot; height=&quot;62&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;几何意义就是在每个微元处的切向量的长度求和。&lt;/p&gt;
&lt;h3&gt;3.Gauss Integration for Arc Length&lt;/h3&gt;
&lt;p&gt;曲线弧长的计算就是一元函数的积分。OpenCASCADE中是如何计算任意曲线弧长的呢？直接找到相关的源码列举如下：(在类CPnts_AbscissaPoint中)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; auxiliary functions to compute the length of the derivative&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; Standard_Real f3d(&lt;span&gt;const&lt;/span&gt; Standard_Real X, &lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Address C)

{

  gp_Pnt P;

  gp_Vec V;

((Adaptor3d_Curve&lt;/span&gt;*)C)-&amp;gt;&lt;span&gt;D1(X,P,V);

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; V.Magnitude();

}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Standard_Real f2d(&lt;span&gt;const&lt;/span&gt; Standard_Real X, &lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Address C)

{

  gp_Pnt2d P;

  gp_Vec2d V;

((Adaptor2d_Curve2d&lt;/span&gt;*)C)-&amp;gt;&lt;span&gt;D1(X,P,V);

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; V.Magnitude();

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================================================================

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;function : Length

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;purpose  : 3d with parameters

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================================================================&lt;/span&gt;
&lt;span&gt;
Standard_Real CPnts_AbscissaPoint::Length(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Adaptor3d_Curve&amp;amp;&lt;span&gt; C,

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Real U1,

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Real U2)

{

  CPnts_MyGaussFunction FG;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;POP pout WNT&lt;/span&gt;
&lt;span&gt;
  CPnts_RealFunction rf &lt;/span&gt;=&lt;span&gt; f3d;

  FG.Init(rf,(Standard_Address)&lt;/span&gt;&amp;amp;&lt;span&gt;C);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  FG.Init(f3d,(Standard_Address)&amp;amp;C);&lt;/span&gt;
&lt;span&gt;
  math_GaussSingleIntegration TheLength(FG, U1, U2, order(C));

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;TheLength.IsDone()) {

&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; Standard_ConstructionError();

}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Abs(TheLength.Value());

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================================================================

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;function : Length

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;purpose  : 2d with parameters

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==================================================================&lt;/span&gt;
&lt;span&gt;
Standard_Real CPnts_AbscissaPoint::Length(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Adaptor2d_Curve2d&amp;amp;&lt;span&gt; C,

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Real U1,

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Real U2)

{

  CPnts_MyGaussFunction FG;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;POP pout WNT&lt;/span&gt;
&lt;span&gt;
  CPnts_RealFunction rf &lt;/span&gt;=&lt;span&gt; f2d;

  FG.Init(rf,(Standard_Address)&lt;/span&gt;&amp;amp;&lt;span&gt;C);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  FG.Init(f2d,(Standard_Address)&amp;amp;C);&lt;/span&gt;
&lt;span&gt;
  math_GaussSingleIntegration TheLength(FG, U1, U2, order(C));

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;TheLength.IsDone()) {

&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; Standard_ConstructionError();

}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Abs(TheLength.Value());

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码的意思是直接对曲线的一阶导数的长度求积分，即是弧长。OpenCASCADE的代码写得有点难懂，根据意思把对三维曲线求弧长的代码改写下，更便于理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;! Function for curve length evaluation.&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; math_LengthFunction : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; math_Function

{

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    math_LengthFunction(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Handle(Geom_Curve)&amp;amp;&lt;span&gt; theCurve)

: myCurve(theCurve)

{

}

&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; Standard_Boolean Value(&lt;span&gt;const&lt;/span&gt; Standard_Real X, Standard_Real&amp;amp;&lt;span&gt; F)

{

        gp_Pnt aP;

        gp_Vec aV;

        myCurve&lt;/span&gt;-&amp;gt;&lt;span&gt;D1(X, aP, aV);

        F &lt;/span&gt;=&lt;span&gt; aV.Magnitude();

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Standard_True;

}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    Handle(Geom_Curve) myCurve;

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4.First Fundamental Form of a Surface&lt;/h3&gt;
&lt;p&gt;曲面参数方程是个二元向量函数。根据《微分几何》中曲面的第一基本公式（First Fundamental Form of a Surface）可知，曲面上曲线的表达式为：&lt;/p&gt;
&lt;p&gt;r=r(u(t), v(t)) = (x(t), y(t), z(t))&lt;/p&gt;
&lt;p&gt;若以s表示曲面上曲线的弧长，则由复合函数求导公式可得弧长微分公式：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204820587-57328139.png&quot;&gt;&lt;img title=&quot;wps_clip_image-11118&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204820759-911089406.png&quot; alt=&quot;wps_clip_image-11118&quot; width=&quot;586&quot; height=&quot;117&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在古典微分几何中，上式称为曲面的第一基本公式，E、F、G称为第一基本量。在曲面上，每一点的第一基本量与参数化无关。&lt;/p&gt;
&lt;p&gt;利用曲面第一基本公式可以用于计算曲面的面积。参数曲面上与u,v参数空间的元素dudv对应的面积元为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204820900-1683595318.png&quot;&gt;&lt;img title=&quot;wps_clip_image-3399&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204821103-1715045448.png&quot; alt=&quot;wps_clip_image-3399&quot; width=&quot;451&quot; height=&quot;53&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由参数曲面法向的计算可知，曲面的面积元素即为u,v方向上的偏导数的乘积的模。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204821353-782880923.png&quot;&gt;&lt;img title=&quot;wps_clip_image-26176&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204821618-1503876357.png&quot; alt=&quot;wps_clip_image-26176&quot; width=&quot;264&quot; height=&quot;182&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其几何意义可以理解为参数曲面的面积微元是由u,v方向的偏导数的向量围成的一个四边形的面积，则整个曲面的面积即是对面积元素求积分。由于参数曲面有两个参数，所以若要计算曲面的面积，只需要对面积元素计算二重积分即可。&lt;/p&gt;
&lt;h3&gt;5.Gauss Integration for Area&lt;/h3&gt;
&lt;p&gt;OpenCASCADE的math包中提供了多重积分的计算类math_GaussMultipleIntegration，由类名可知积分算法采用了Gauss积分算法。下面通过具体代码来说明OpenCASCADE中计算曲面积分的过程。要计算积分，先要定义被积函数。因为参数曲面与参数曲线不同，参数曲线只有一个参数，而参数曲面有两个参数，所以是一个多元函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;! 2D variable function for surface area evaluation.&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; math_AreaFunction : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; math_MultipleVarFunction

{

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    math_AreaFunction(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Handle(Geom_Surface)&amp;amp;&lt;span&gt; theSurface)

: mySurface(theSurface)

{

}

&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; Standard_Integer NbVariables() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;

{

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

}

&lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; Standard_Boolean Value(&lt;span&gt;const&lt;/span&gt; math_Vector&amp;amp; X, Standard_Real&amp;amp;&lt;span&gt; Y)

{

        gp_Pnt aP;

        gp_Vec aDu;

        gp_Vec aDv;

        mySurface&lt;/span&gt;-&amp;gt;D1(X(&lt;span&gt;1&lt;/span&gt;), X(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;), aP, aDu, aDv);

        Y &lt;/span&gt;=&lt;span&gt; aDu.Crossed(aDv).Magnitude();

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Standard_True;

}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    Handle(Geom_Surface) mySurface;

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于参数曲面是多元函数，所以从类math_MultipleVarFunction派生，并在虚函数NbVariables()中说明有两个变量。在虚函数Value()中计算面积元素的值，即根据曲面第一基本公式中面积元素的定义，对参数曲面求一阶导数，计算两个偏导数向量的叉乘的模。&lt;/p&gt;
&lt;p&gt;有了被积函数，只需要在定义域对其计算二重积分，相应代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; evalArea(&lt;span&gt;const&lt;/span&gt; Handle(Geom_Surface)&amp;amp; theSurface, &lt;span&gt;const&lt;/span&gt; math_Vector&amp;amp; theLower, &lt;span&gt;const&lt;/span&gt; math_Vector&amp;amp;&lt;span&gt; theUpper)

{

    math_IntegerVector aOrder(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, math::GaussPointsMax());

    math_AreaFunction aFunction(theSurface);

    math_GaussMultipleIntegration anIntegral(aFunction, theLower, theUpper, aOrder);

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (anIntegral.IsDone())

{

        anIntegral.Dump(std::cout);

}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过theLower和theUpper指定定义域，由于采用了Gauss-Legendre算法计算二重积分，所以需要指定阶数，且阶数越高积分结果精度越高，这里使用了OpenCASCADE中最高的阶数。&lt;/p&gt;
&lt;p&gt;下面通过对基本曲面的面积计算来验证结果的正确性，并将计算结果和OpenCASCADE中计算面积的类BRepGProp::SurfaceProperties()结果进行对比。&lt;/p&gt;
&lt;h3&gt;6.Elementary Surface Area Test&lt;/h3&gt;
&lt;p&gt;下面通过对OpenCASCADE中几个初等曲面的面积进行计算，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;122&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
Copyright(C) 2017 Shing Liu(eryar@163.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files(the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;gp_Pnt.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;gp_Vec.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;math.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math_Function.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math_MultipleVarFunction.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math_GaussMultipleIntegration.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;Geom_Plane.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Geom_ConicalSurface.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Geom_CylindricalSurface.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Geom_SphericalSurface.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Geom_ToroidalSurface.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Geom_BSplineSurface.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Geom_RectangularTrimmedSurface.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;GeomConvert.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;GProp_GProps.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;TopoDS_Face.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;BRepGProp.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;BRepBuilderAPI_MakeFace.hxx&amp;gt;

&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKernel.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKMath.lib&quot;)

&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKG2d.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKG3d.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKGeomBase.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKGeomAlgo.lib&quot;)

&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKBRep.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKTopAlgo.lib&quot;)


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;! 2D variable function for surface area evaluation.&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; math_AreaFunction : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; math_MultipleVarFunction
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    math_AreaFunction(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Handle(Geom_Surface)&amp;amp;&lt;span&gt; theSurface)
        : mySurface(theSurface)
    {

    }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; Standard_Integer NbVariables() &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; Standard_Boolean Value(&lt;span&gt;const&lt;/span&gt; math_Vector&amp;amp; X, Standard_Real&amp;amp;&lt;span&gt; Y)
    {
        gp_Pnt aP;
        gp_Vec aDu;
        gp_Vec aDv;

        Standard_Real E &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
        Standard_Real F &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
        Standard_Real G &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;

        mySurface&lt;/span&gt;-&amp;gt;D1(X(&lt;span&gt;1&lt;/span&gt;), X(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;), aP, aDu, aDv);

        E &lt;/span&gt;=&lt;span&gt; aDu.Dot(aDu);
        F &lt;/span&gt;=&lt;span&gt; aDu.Dot(aDv);
        G &lt;/span&gt;=&lt;span&gt; aDv.Dot(aDv);

        Y &lt;/span&gt;= Sqrt(E * G - F *&lt;span&gt; F);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y = aDu.Crossed(aDv).Magnitude();&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Standard_True;
    }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    Handle(Geom_Surface) mySurface;
};

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; evalArea(&lt;span&gt;const&lt;/span&gt; Handle(Geom_Surface)&amp;amp; theSurface, &lt;span&gt;const&lt;/span&gt; math_Vector&amp;amp; theLower, &lt;span&gt;const&lt;/span&gt; math_Vector&amp;amp;&lt;span&gt; theUpper)
{
    math_IntegerVector aOrder(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, math::GaussPointsMax());

    math_AreaFunction aFunction(theSurface);
    math_GaussMultipleIntegration anIntegral(aFunction, theLower, theUpper, aOrder);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (anIntegral.IsDone())
    {
        anIntegral.Dump(std::cout);
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; evalArea(&lt;span&gt;const&lt;/span&gt; Handle(Geom_BoundedSurface)&amp;amp;&lt;span&gt; theSurface)
{
    math_IntegerVector aOrder(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, math::GaussPointsMax());

    math_Vector aLower(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
    math_Vector aUpper(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);

    theSurface&lt;/span&gt;-&amp;gt;Bounds(aLower(&lt;span&gt;1&lt;/span&gt;), aUpper(&lt;span&gt;1&lt;/span&gt;), aLower(&lt;span&gt;2&lt;/span&gt;), aUpper(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));

    math_AreaFunction aFunction(theSurface);
    math_GaussMultipleIntegration anIntegral(aFunction, aLower, aUpper, aOrder);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (anIntegral.IsDone())
    {
        anIntegral.Dump(std::cout);
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; testFace(&lt;span&gt;const&lt;/span&gt; TopoDS_Shape&amp;amp;&lt;span&gt; theFace)
{
    GProp_GProps aSurfaceProps;

    BRepGProp::SurfaceProperties(theFace, aSurfaceProps);

    std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Face area: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aSurfaceProps.Mass() &amp;lt;&amp;lt;&lt;span&gt; std::endl;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testPlane()
{
    std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;====== Test Plane Area =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    Handle(Geom_Plane) aPlaneSurface &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Geom_Plane(gp::XOY());

    math_Vector aLower(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    math_Vector aUpper(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parameter U range.&lt;/span&gt;
    aLower(&lt;span&gt;1&lt;/span&gt;) = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    aUpper(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) = &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parameter V range.&lt;/span&gt;
    aLower(&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    aUpper(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;;

    evalArea(aPlaneSurface, aLower, aUpper);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Convert to BSpline Surface.&lt;/span&gt;
    Handle(Geom_RectangularTrimmedSurface) aTrimmedSurface =
        &lt;span&gt;new&lt;/span&gt; Geom_RectangularTrimmedSurface(aPlaneSurface, aLower(&lt;span&gt;1&lt;/span&gt;), aUpper(&lt;span&gt;1&lt;/span&gt;), aLower(&lt;span&gt;2&lt;/span&gt;), aUpper(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));

    Handle(Geom_BSplineSurface) aBSplineSurface &lt;/span&gt;=&lt;span&gt; GeomConvert::SurfaceToBSplineSurface(aTrimmedSurface);
    evalArea(aBSplineSurface);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Test Face.&lt;/span&gt;
    TopoDS_Face aFace =&lt;span&gt; BRepBuilderAPI_MakeFace(aTrimmedSurface, Precision::Confusion()).Face();
    testFace(aFace);

    aFace &lt;/span&gt;=&lt;span&gt; BRepBuilderAPI_MakeFace(aBSplineSurface, Precision::Confusion()).Face();
    testFace(aFace);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCylinder()
{
    std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;====== Test Cylinder Area =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    Handle(Geom_CylindricalSurface) aCylindrialSurface &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Geom_CylindricalSurface(gp::XOY(), &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);

    math_Vector aLower(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    math_Vector aUpper(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    aLower(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    aUpper(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) = M_PI * &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;;

    aLower(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    aUpper(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;) = &lt;span&gt;3.0&lt;/span&gt;&lt;span&gt;;

    evalArea(aCylindrialSurface, aLower, aUpper);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Convert to BSpline Surface.&lt;/span&gt;
    Handle(Geom_RectangularTrimmedSurface) aTrimmedSurface =
        &lt;span&gt;new&lt;/span&gt; Geom_RectangularTrimmedSurface(aCylindrialSurface, aLower(&lt;span&gt;1&lt;/span&gt;), aUpper(&lt;span&gt;1&lt;/span&gt;), aLower(&lt;span&gt;2&lt;/span&gt;), aUpper(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));

    Handle(Geom_BSplineSurface) aBSplineSurface &lt;/span&gt;=&lt;span&gt; GeomConvert::SurfaceToBSplineSurface(aTrimmedSurface);
    evalArea(aBSplineSurface);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Test Face.&lt;/span&gt;
    TopoDS_Face aFace =&lt;span&gt; BRepBuilderAPI_MakeFace(aTrimmedSurface, Precision::Confusion()).Face();
    testFace(aFace);

    aFace &lt;/span&gt;=&lt;span&gt; BRepBuilderAPI_MakeFace(aBSplineSurface, Precision::Confusion()).Face();
    testFace(aFace);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSphere()
{
    std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;====== Test Sphere Area =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    Handle(Geom_SphericalSurface) aSphericalSurface &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Geom_SphericalSurface(gp::XOY(), &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);

    math_Vector aLower(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    math_Vector aUpper(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    aSphericalSurface&lt;/span&gt;-&amp;gt;Bounds(aLower(&lt;span&gt;1&lt;/span&gt;), aUpper(&lt;span&gt;1&lt;/span&gt;), aLower(&lt;span&gt;2&lt;/span&gt;), aUpper(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));

    evalArea(aSphericalSurface, aLower, aUpper);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Convert to BSpline Surface.&lt;/span&gt;
    Handle(Geom_BSplineSurface) aBSplineSurface =&lt;span&gt; GeomConvert::SurfaceToBSplineSurface(aSphericalSurface);
    evalArea(aBSplineSurface);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Test Face.&lt;/span&gt;
    TopoDS_Face aFace =&lt;span&gt; BRepBuilderAPI_MakeFace(aSphericalSurface, Precision::Confusion()).Face();
    testFace(aFace);

    aFace &lt;/span&gt;=&lt;span&gt; BRepBuilderAPI_MakeFace(aBSplineSurface, Precision::Confusion()).Face();
    testFace(aFace);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; test()
{
    testPlane();

    testSphere();

    testCylinder();
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    test();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;计算结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204821868-175001418.png&quot;&gt;&lt;img title=&quot;wps_clip_image-21244&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171209204822165-999359449.png&quot; alt=&quot;wps_clip_image-21244&quot; width=&quot;577&quot; height=&quot;377&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上述代码计算了曲面的面积，再将曲面转换成B样条曲面，再使用算法计算面积。再将曲面和转换的B样条曲面生成拓朴面，利用OpenCASCADE中计算曲面面积功能进行对比。使用自定义函数math_AreaFunction利用多重积分类计算的结果与OpenCASCADE中计算曲面面积的值是一致的。当把曲面转换成B样条曲面后，OpenCASCADE计算的曲面面积偏大。&lt;/p&gt;
&lt;h3&gt;7.Conclusion&lt;/h3&gt;
&lt;p&gt;在学习《高等数学》的积分时，其主要的一个应用就是计算弧长、面积和体积等。学习高数抽象概念时，总会问学了高数有什么用？就从计算机图形方面来看，可以利用数学工具对任意曲线求弧长，对任意曲面计算面积等，更具一般性。&lt;/p&gt;
&lt;p&gt;通过自定义被积函数再利用积分算法来计算任意曲面的面积，将理论与实践结合起来了。即将曲面的第一基本公式与具体的代码甚至可以利用OpenCASCADE生成对应的图形，这样抽象的理论就直观了，更便于理解相应的概念。&lt;/p&gt;
&lt;h3&gt;8.References&lt;/h3&gt;
&lt;p&gt;1.朱心雄. 自由曲线曲面造型技术. 科学出版社. 2000&lt;/p&gt;
&lt;p&gt;2.陈维桓. 微分几何. 北京大学出版社. 2006&lt;/p&gt;
&lt;p&gt;3.同济大学数学教研室. 高等数学. 高等教育出版社. 1996&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 12:49:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/OpenCASCADE_GaussIntegration.html</dc:identifier>
</item>
<item>
<title>IntelliJ IDEA（二） ：面板介绍 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/7994126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/7994126.html</guid>
<description>&lt;h2&gt;一、面板说明&lt;/h2&gt;
&lt;p&gt;IDEA面板的全貌如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209170811355-1484626138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 二、菜单栏&lt;/h2&gt;
&lt;p&gt;下面会简单介绍下一些常用的部分菜单使用，如有疑问或补充欢迎留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209170831355-115731291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(1)、File文件&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209170849824-949216683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. New：新建一个工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209170912511-882340968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以新建project，导入已存在的资源project，从版本控制库导入工程，新建Module，导入已存在的资源Module，新建文件（JS，DB，JSP，Java，CSS……），新建FMXL文件。&lt;/p&gt;
&lt;p&gt;2. Open：打开本地的文件或工程&lt;/p&gt;
&lt;p&gt;3. Open URL：&lt;/p&gt;
&lt;p&gt;4. Open Recent：打开最近已导入过的工程&lt;/p&gt;
&lt;p&gt;5. Close Project：关闭工程&lt;/p&gt;
&lt;p&gt;7. Setting：IDEA配置文件&lt;/p&gt;
&lt;p&gt;8. Project Structure：显示当前工程结构&lt;/p&gt;
&lt;p&gt;9. Other Setting：全局默认配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Default Settings…，Default Project Structure…
IDEA在Setting中某些配置是For当前project的，也就是意味着你新打开的一个project并不能够默认通用这些配置，你需要另外重新配置。&lt;br/&gt;你可以在DefaultSetting中进行一些全局通用配置。例如：maven的安装路径，maven仓库地址，git.exe地址等。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10. Import Settings：导入Settins文件&lt;/p&gt;
&lt;p&gt;你可以将自己以前保存过的settings文件导入进来，也可以导入外来的settings文件，例如换主题皮肤。&lt;/p&gt;
&lt;p&gt;11. Exoort Settings：导出Settings文件&lt;/p&gt;
&lt;p&gt;将自己习惯的settings文件导出到本地或云盘，下次在新的地点使用时可以直接导入使用。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;h3&gt;(2)、Edit编辑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209170932667-500494130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.Undo：撤销&lt;/p&gt;
&lt;p&gt;2.Redo Duplicate Line or Selection：重新复制行或选择。（返回撤销之前）&lt;/p&gt;
&lt;p&gt;3.Cut：剪切&lt;/p&gt;
&lt;p&gt;4.Copy：复制&lt;/p&gt;
&lt;p&gt;5.Copy：复制文件路径&lt;/p&gt;
&lt;p&gt;6.Copy Reference&lt;/p&gt;
&lt;p&gt;7.Paste：粘贴&lt;/p&gt;
&lt;p&gt;8.Paste from History…：从剪切板中选择历史复制的内容粘贴&lt;/p&gt;
&lt;p&gt;9.Paste：&lt;/p&gt;
&lt;p&gt;10.Delete：删除&lt;/p&gt;
&lt;p&gt;11.Find：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209170953355-731585101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;h3&gt;(3)、View视图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171018027-720619837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. Tool Windows：一些工具窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171040714-1074338834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. Recent Files：最近打开过的文件（Crtl + E）&lt;/p&gt;
&lt;p&gt;3. Recently Changed Files：最近做过修改过的文件&lt;/p&gt;
&lt;p&gt;4. Recent Changes：最近修改记录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171347933-1527064196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. Quick Switch Scheme…：&lt;/p&gt;
&lt;p&gt;6. Toolbar：工具栏（显示/关闭）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171417245-2079949646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7. Tool Buttons：工具按钮（IDEA左右和底部的工具框）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171456761-1429743346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8. Status Bar：IDEA右下角的状态栏&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171521402-1323329511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9. Navigation Bar：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171545792-1487939373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;h3&gt;(4)、Navigate导航 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171631745-1574332773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. Class：查询类&lt;/p&gt;
&lt;p&gt;2. File：查询文件&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;3. Jump to Navigation Bar：跳到导航栏&lt;/p&gt;
&lt;p&gt;4.Declaration：进入光标所在的方法/变量的接口或是定义处&lt;/p&gt;
&lt;p&gt;5.Implementations：方法的实现&lt;/p&gt;
&lt;p&gt;6.Type Declaration：进入光标当前所在属性的类&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;7.Type Hierarchy：当前类的分层结构&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;h3&gt;(5)、Code编码&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171654152-945362368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这都是些和编码相关的，重写方法，实现方法，环绕（try…catch，if…else，…），上面显示的快捷键基本都需要记住，因为是比价常用的。&lt;/p&gt;
&lt;h3&gt;(6)、Analyze分析&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171708105-1634146262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;(7)、Refactor重构&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171718902-616125030.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这些在项目重构时会使用的加多，例如类名更改，可以通过Rename(Shift + F6)来快速替换所有使用该类的地方。&lt;/p&gt;
&lt;h3&gt;(8)、Build构建&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171737355-414006221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建项目相关的。&lt;/p&gt;
&lt;h3&gt;(9)、Run运行&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209171954699-1321185298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动项目相关的，Run，Debug，……&lt;/p&gt;
&lt;h3&gt;(10)、Tools工具&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209172014870-1715711460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(11)、VCS版本控制&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209172028761-1813979974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(12)、Window窗体&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209172054324-769438941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(14)、Help帮助&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201712/1162587-20171209172106417-1206181689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 09 Dec 2017 12:44:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/7994126.html</dc:identifier>
</item>
<item>
<title>浅谈架构-从传统走向分布式 - 回首笑人间</title>
<link>http://www.cnblogs.com/Survivalist/p/8012266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Survivalist/p/8012266.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1290673/201712/1290673-20171209160328105-1998429315.jpg&quot; alt=&quot;&quot;/&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　随笔：最近再做这些年的知识整理，今天整理到了架构这方便，就索性拿出来和大家分享一下，有什么写错的，欢迎大家指正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;架构拆分的演变：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.传统项目的架构：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;特点：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.all in one(所有模块在一起，技术也不分层)，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　注：像05年06年那会儿，就是这样，把代码写在jsp里面，那时候还没有分层的概念，把所有的东西都写在一起，这就叫做all in one &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2.servlet(jsp)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1.并发量差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.容错性差(不具有高可用性)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注：不具有高可用性的意思是，比如当用户访问时，服务器后台因为一些原因导致服务器崩溃，用户就能直接看到错误页面，服务器也因为错误从而停止运行(宕机)，这就叫做不具有高可用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.分层开发(可以提高并发量)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.mvc架构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.服务器的分离部署&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用图说话：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1290673/201712/1290673-20171209161726449-633591612.png&quot; alt=&quot;&quot; width=&quot;959&quot; height=&quot;535&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;集群的配置：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1290673/201712/1290673-20171209172039652-1219569955.png&quot; alt=&quot;&quot; width=&quot;887&quot; height=&quot;447&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　集群架构：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　特点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　1.项目采用多台服务器集群部署&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　2.mysql数据库采用多台服务器集群部署&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　优势：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　1.并发量提高(1000+)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　2.容错性提高(具有高可用性)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　注：一般的it公司，基本都是采用集群架构，因为这种架构方式已经基本能满足需求了，但是一些大型项目，这种方式就显然是力不从心了，只能采用分布式的架构方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　但是，通过上图我们发现这种集群部署存在两个问题，什么问题呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1.session如何共享？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2.这么服务器，请求该往哪发送？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　下面咱们就针对这两个问题一一解答：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　首先第一个问题，session的问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　我们都知道，session是会话，即一个用户访问服务器的时候，就会产生一个session，这个session会一致伴随着这个用户的访问全程，直到用户关闭浏览器结束这次会话，那么问题来了，问，挖掘技术哪家强？咳咳，错了，是如果用户访问服务器时，这台服&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　务器&lt;/span&gt;&lt;/span&gt;&lt;span&gt;挂掉了(宕机)，那么原先保存在这台服务器上的session也肯定挂掉了，那么就会产生一个后果，就是这个用户原本访问好好的，现在突然session没有了，而session没有了就意味着需要用户重新登陆才能进行一些相应操作，这显然是不行的，这样的服务用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　体验&lt;/span&gt;&lt;span&gt;&lt;span&gt;实在太差了，根本不能满足互联网行业的用户需求，那么这就涉及到一个session共享的问题，即怎么把原有的session从一台服务器转移到另一台服务器上，但是怎么解决呢？有多种方案，但咱们今天先说两种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　第一种解决方案：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　用Tomcat集群复制(广播模式)来共享session：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　这种解决方案是利用Tomcat来进行集群复制，把每个服务器上的session都共享式的都复制一遍，保证每个服务器上都有着一个用户的session数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　应用场景：在传统项目中一般这么应用，因为传统项目的用户量少，可以承担压力，但当到互联网项目时，这种方式就绝对不可取了，打个比方，比如用户量有100万，那么就需要在每个服务器上都复制这100万个用户的session，这样做显然会极大的消耗系统&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　资&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;源，使系统变得极为臃肿和不稳的，所以在互联网项目里是绝对不会采用这种方式的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　缺点：当有大量用户时，服务器的压力会亚历山大，所以只适合用户访问量小的传统项目&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;第二种解决方案：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　用第三方redis服务器来存储session&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　用这种方式来存储session的话，只需当前正在使用的项目把所有session都放在redis里面，当有其他项目需要使用时，就可以直接从redis中直接获取session，从而解决了这个问题&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　示例如图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1290673/201712/1290673-20171209173510730-535859547.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;414&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　现在第一个问题解决了，我们来考虑第二个问题，怎么解决选择哪个作为解释请求的服务器呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　答案是：用nginx服务器来分发请求，实现负载均衡。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1290673/201712/1290673-20171209174945558-468319546.png&quot; alt=&quot;&quot; width=&quot;859&quot; height=&quot;794&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　这种架构的并发量是多少呢？大概是1000+左右，如果服务器更多的话，能达到1000以上，一万以下，但是这能满足互联网的极致要求呢？答案当然是不能了，虽说也可以不断的扩展服务器，但是对于公司的成本和维护成本来说，无疑会达到一个非常高昂的&lt;/p&gt;
&lt;p&gt;　　消耗，比如说一台最便宜的服务器的价格大概是3到5万，假如要抵御一万的并发，每台服务器能支持200的并发率，那么需要多少台服务器？50台！这还仅是单击版的，还构建集群呢？比如说构建3台服务器，3*50=150台，服务器构建完了，数据库呢？数据库也需&lt;/p&gt;
&lt;p&gt;　　要&lt;span&gt;构建集群呀！，这就又是好几百台，这么一算下来大概的费用就是好几百万了，这仅仅是配置的费用，还没有计算维护的成本呢？比如说我们都知道服务器对于机房的要求是非常苛刻的，比如恒温，无尘等等(题外话：阿里之所以把云计算基地定在杭州就是看中了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那&lt;/span&gt;里气温稳定，适合布置服务器集群)。这样一来又需要布置大型的机房，综合以上所述，虽说集群能后解决部分问题，但并不能解决所有问题，无论是从公司成本还是运营成本来说，显然这种传统的集群架构是不适应现在的互联网行业的，而且对于一般的公司来说&lt;/p&gt;
&lt;p&gt;　　也不可&lt;span&gt;能去花大价钱做这种布置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　所以，这种情况下我们就必须对我们的架构来进行优化了，那么如何在服务器只有一定数量的情况下，让我们的项目的成本能达到一定控制，并且让我们的项目达到一个最优化的并发的访问量呢？那么就需要对现有的这种架构进行再次拆分，让我们的项目成为面向服务的分布式架构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;面向服务的分布式架构(SOA)：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;strong&gt;远程框架：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　1.webservice&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1290673/201712/1290673-20171209195854556-1316111695.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;347&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　如图所示，第一种方式还是有着明显的缺点的，如服务层的网路抖动或是服务层进程繁忙，可能有人对这两个名词不太理解，这里就解释一下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　网络抖动：当有大量用户访问时，可能会出现service层的延迟现象，而web层因为长期得不到响应，则会抛出时间超出异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　进程繁忙：这个的意思和前边的差不多，都是指service层业务太多，顾不上web层的请求，web层的请求就只能一直在那等着，时间长了也就抛出超时异常了&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;strong&gt;服务治理中间件：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　2.dubbo&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1290673/201712/1290673-20171209200515681-1521971021.png&quot; alt=&quot;&quot; width=&quot;678&quot; height=&quot;414&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　原理讲解：看了第一种webservice的方法之后，我们采用了第二种方法，即dubbo这种中间件的方式，采用这种方式有什么好处呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　好处：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　当服务器启动时service会把所有的对象通过dubbo注册给zookeeper，而以后每次需要请求获取对象时，就可以直接从dubbo中异步获取，不需要再去访问service层，这样就解决了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　服务层网络抖动和服务层进程繁忙的弊端。zeekeeper可以看成是一个数据库，用来存储数据的，具体的原理以后会专门开篇文章描述它。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　这种方式是目前最常用的，起码是我最常用的，顺嘴一提，dubbo是阿里巴巴开发的一款中间件，性能强大，而且这是由中国人自主开发的软件，有木有很&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;自豪&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　3.springcloud&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;这个软件是由外国开发，原理和dubbo差不太，就暂且不提了，有兴趣的可以自己百度一下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　下面我们来总结一下分布式框架的优点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　优点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　1.大幅提高并发访问量(10000+)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　2.可以节省成本(因为这种优化仅是从架构方面进行优化，而不需要去配置大量的服务器)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　3.实现了服务层与表现层的解耦合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　注：1.其实还有一种方式，即是提升带宽，把带宽搞多一点，但前提是服务器能承受这么大的量。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　2.集群也不是越多越好的，越多的话就会发现，其实并发的提升是有限的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　总结：说道这里就基本已经讲解了架构的发展历史，当然现在目前还有一种比分布式更火的架构模式，叫做微架构，它是通过服务的原子化拆分，以及微服务的独立打包、部署和升级，可以让小团队的交付周期将缩短，运维成本也将大幅度下降，可以预见，这&lt;/p&gt;
&lt;p&gt;　　　　　　　 种架构模式将会越来越受到广大企业的应用与喜爱，但由于笔者功力有限，目前也还是在学习了解阶段，就不在这里献丑了。(本文写的比较浅显，如有写错写漏处，欢迎指正！谢谢观看！)&lt;/p&gt;
</description>
<pubDate>Sat, 09 Dec 2017 12:35:00 +0000</pubDate>
<dc:creator>回首笑人间</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Survivalist/p/8012266.html</dc:identifier>
</item>
</channel>
</rss>