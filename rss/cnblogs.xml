<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>TensorFlow学习笔记（六）循环神经网络 - 左手十字</title>
<link>http://www.cnblogs.com/zuoshoushizi/p/9243691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoshoushizi/p/9243691.html</guid>
<description>


&lt;h2&gt;一、循环神经网络简介&lt;/h2&gt;
&lt;p&gt;　　循环神经网络的主要用途是处理和预测序列数据。循环神经网络刻画了一个序列当前的输出与之前信息的关系。从网络结构上，循环神经网络会记忆之前的信息，并利用之前的信息影响后面节点的输出。&lt;/p&gt;
&lt;p&gt;下图展示了一个典型的循环神经网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629132602282-2091067140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;循环神经网络的一个重要的概念就是时刻。上图中循环神经网络的主体结构A的输入除了来自输入层的Xt，还有一个自身当前时刻的状态St。&lt;/p&gt;
&lt;p&gt;在每一个时刻，A会读取t时刻的输入Xt，并且得到一个输出Ht。同时还会得到一个当前时刻的状态St，传递给下一时刻t+1。&lt;/p&gt;
&lt;p&gt;因此，循环神经网络理论上可看作同一神经结构被无限重复的过程。（无限重复目前还是不可行的）&lt;/p&gt;
&lt;p&gt;将循环神经网络按照时间序列展开，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629133843095-897160849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; xt是t时刻的输入&lt;/p&gt;
&lt;p&gt;St是t时刻的“记忆”，St = f（WSt-1 + Uxt），f是tanh等激活函数&lt;/p&gt;
&lt;p&gt;Ot 是t时刻的输出&lt;/p&gt;
&lt;p&gt;下图给出一个最简单的循环体或者叫记忆体的结构图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629135559230-329735656.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图展示了一个循环神经网络的前向传播算法的具体计算过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180629135821543-1058634546.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在得到前向传播计算结果之后，可以和其他网络类似的定义损失函数。神经网络的唯一区别在于它每一个时刻都有一个输出，所以循环神经网络的总损失为前面所有时刻的损失函数的总和。&lt;/p&gt;
&lt;p&gt;我们利用代码来实现这个简单的前向传播过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

X &lt;/span&gt;= [1,2&lt;span&gt;]
state &lt;/span&gt;= [0.0,0.0&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义不同输入部分的权重&lt;/span&gt;
w_cell_state = np.asarray([[0.1,0.2],[0.3,0.4&lt;span&gt;]])
w_cell_input &lt;/span&gt;= np.asarray([0.5,0.6&lt;span&gt;])
b_cell &lt;/span&gt;= np.asarray([0.1,-0.1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输出层的权重&lt;/span&gt;
w_output = np.asarray([[0.1],[0.2&lt;span&gt;]])
b_output &lt;/span&gt;= 0.1
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照时间顺序执行循环神经网络的前向传播过程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(X)):
    before_activetion &lt;/span&gt;= np.dot(state,w_cell_state) + X[i] * w_cell_input +&lt;span&gt; b_cell
    state &lt;/span&gt;=&lt;span&gt; np.tanh(before_activetion)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算当前时刻的最终输出&lt;/span&gt;
    final_output = np.dot(state,w_output) +&lt;span&gt; b_output
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出每一时刻的信息&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before_activation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,before_activetion)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,state)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;final_output&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,final_output)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二、长短时记忆网络（LSTM）结构&lt;/h2&gt;
&lt;p&gt;循环神经网络工作的关键点就是使用历史的信息来帮助当前的决策。循环神经网络能很好的利用传统的神经网络不能建模的信息，但同时，也带来了更大的挑战——长期依赖的问题。&lt;/p&gt;
&lt;p&gt;　　在有些问题中，模型仅仅需要短期内的信息来执行当前的任务。但同时也会有一些上下文场景更加复杂的情况。当间隔不断增大时，简单的循环神经网络可能会丧失学习到如此远的信息的能力。或者在复杂的语言场景中，有用的信息的间隔有大有小，长短不一，循环神经网络的性能也会受限。&lt;/p&gt;
&lt;p&gt;　　为了解决这类问题，设计了LSTM。与单一tanh循环结构不同，LSTM拥有三个门：“输入门”、“输出门”、“遗忘门”。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630154235185-1750123778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630154449226-2017305431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LSTM靠这些“门”的结构信息有选择的影响循环神经网络中每个时刻的状态。所谓的“门”就是一个sigmod网络和一个按位做乘法的操作。当sigmod输出为1时，全部信息通过；为0时，信息无法通过。为了使循环神经网络更有效的保持长期记忆。“遗忘门“和”输入门”就至关重要。“遗忘门”就是让神经网络忘记之前没有用的信息。从当前的输入补充新的“记忆”是“输入门”作用。&lt;/p&gt;
&lt;p&gt;使用LSTM结构的循环神经网络的前向传播时一个比较复杂的计算过程。在TensorFlow中可以被很简单的实现。例如下面的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个LSTM结构。TF通过一句简单的命令就可以定义一个LSTM循环体&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;LSTM中使用的变量也会自动声明&lt;/span&gt;
&lt;span&gt;
lstm &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(lstm_hidden_size)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将LSTM中的状态初始化问哦全0数组。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;BasicLSTMCell类提供了zero_state函数来生成全0 的初始状态&lt;/span&gt;
state =&lt;span&gt; lstm.zero_state(batch_size,tf.float32)
current_input &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义损失函数&lt;/span&gt;
loss = 0.0
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;虽然rnn理论上可以处理任意长度的序列，但是在训练时为了避免梯度消散的问题，会规定一个最大的循环长度num_temps&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_temps):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在第一个时刻声明LSTM结构中使用的变量，在之后的时刻都需要服用之前的定义好的变量。&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; i &amp;gt;&lt;span&gt; 0:
        tf.get_variable_scope().reuse_variables()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每一步处理时间序列中的一个时刻&lt;/span&gt;
    lstm_output,state =&lt;span&gt; lstm(current_input,state)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将当前时刻LSTM结构的输出传入一个全连接层得到最后的输出&lt;/span&gt;
    final_output =&lt;span&gt; full_connected(lstm_output)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算当前时刻的输出的损失&lt;/span&gt;
    loss +=&lt;span&gt; calc_loss(final_output,expected_output)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用BP后向传播算法训练模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、循环神经网络的变种&lt;/p&gt;
&lt;p&gt;1、双向循环神经网络和深层循环神经网络&lt;/p&gt;
&lt;p&gt;在经典的循环神经网络中，状态的传输时从前向后单向的。然而，在有些问题中，当前时刻的输出不仅和之前的状态有关，也和之后的转台有关。只是后就需要使用双向循环神经网络来解决此类问题。双向循环神经网络时由连个神经网络上下叠加在一起组成的。输出有这两个神经网络的转台共同决定的。下图展示了一个双向循环神经网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630224936664-1664356469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;深层循环神经网络是循环神经网络的另外一种变体。为了增强模型的表达能力，可以将每一时刻上的循环体重复多次。深层循环神经网络在每一时刻上将循环体结构重复了多次。 每一层循环体中的参数是一致的，不同层的循环体参数可以不一致。TF提供了MultiRNNCell类来实现深层循环神经网络的前向传播过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201806/1224905-20180630230531884-2064172812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个基本的LSTM结构作为循环体的基础结构，深层循环神经网络也可以支持其他的循环提结构&lt;/span&gt;
lstm =&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(lstm_size)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过MultiRNNCell类来实现深层循环神经网络中每一时刻的前向传播过程。其中。number_of_layers 表示了有多少层，也就是图&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;中从xi到hi需要经过多少个LSTM结构。&lt;/span&gt;
stacked_lstm = tf.nn.rnn_cell.MultiRNNCell([lstm]*&lt;span&gt;number_of_layers)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;和经典神经网络一样，可以通过zero_state函数获得初始状态。&lt;/span&gt;
state =&lt;span&gt; stacked_lstm.zero_state(batch_size,tf.float32)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算每一时刻的前向传播过程&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_steps):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i &amp;gt;&lt;span&gt; 0:
        tf.get_variable_scope().reuse_variables()
    stacked_lstm_output  ,state &lt;/span&gt;=&lt;span&gt; stacked_lstm(current_input,state)
    final_output &lt;/span&gt;=&lt;span&gt;  fully_connected(stacked_lstm_output)
    loss &lt;/span&gt;+=&lt;span&gt; calc_loss(final_output,expected_output)
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、循环神经网络的dropout&lt;/p&gt;
&lt;p&gt;　　dropout可以样循环神经网络更加的健壮。dropout一般只在不同层循环体之间使用。也就是说从t-1时刻传递到时刻t，RNN不会进行状态的dropout，而在同一时刻t，不同层循环体之间会使用dropout。&lt;/p&gt;
&lt;p&gt;在TF中，使用tf.nn.rnn_cell.DropoutWrapper类可以很容易实现dropout功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义LSTM结构&lt;/span&gt;
lstm  =&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(lstm_size)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过DropoutWrapper来实现dropout功能。input_keep_drop参数用来控制输入的dropout的概率，output_keep_drop参数用来控制输出的dropout的概率，&lt;/span&gt;
dropout_lstm = tf.nn.rnn_cell.DropoutWrapper(lstm,input_keep_prob=0.5,output_keep_prob=0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在使用了dropout的基础上定义深层RNN&lt;/span&gt;
stacked_lstm = tf.nn.rnn_cell.MultiRNNCell([dropout_lstm]* 5)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四、循环神经网络的样例应用&lt;/p&gt;
&lt;p&gt;1、自然语言建模&lt;/p&gt;
&lt;p&gt;　　简单的说，语言模型的目的就是为了计算一个句子的出现概率。在这里把句子看成单词的序列S = （w1,w2,w3....wm），其中m为句子的长度，它的概率可以表示为&lt;/p&gt;
&lt;p&gt;P（S） = p（w1，w2,w3.....wm） = p(w1)p(w2|w1)p(w3|w1,w2)p(wm| w1,w2...wm)&lt;/p&gt;
&lt;p&gt;等式右边的每一项都是语言模型中的一个参数。为了估计这些参数的取值，常用的方法有n-gram、决策树、最大熵模型、条件随机场、神经网络模型。&lt;/p&gt;
&lt;p&gt;　　语言模型效果的好坏的常用的评价指标是复杂度（perplexity）。简单来说，perplexity刻画的就是通过某一语言模型估计一句话出现的概率。值越小越好。复杂度的计算公式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1224905/201807/1224905-20180701120747752-398278763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就利用语言模型来处理PTB数据集。&lt;/p&gt;
&lt;p&gt;为了让PTB数据集使用更方便，TF提供了两个函数来预处理PTB数据集。ptb_raw_data用来读取原始数据，并将原始数据的单词转化为单词ID，形成一个非常长的序列。ptb_iterator将序列按照某固定的长度来截断，并将数据组成batch。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用循环神经网络实现语言模型&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;111&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.models.rnn.ptb &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reader
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.legacy_seq2seq &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sequence_loss_by_example
DATA_PATH &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path/to/ptb/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
HIDDEN_SIZE &lt;/span&gt;= 200 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏层的规模&lt;/span&gt;
NUM_LAYERS = 2 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;DRNN中LSTM结构的层数&lt;/span&gt;
VOCAB_SIZE = 10000 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;词典规模，加上语句结束符和稀有单词结束符总共10000&lt;/span&gt;
LEARNING_RATE = 1.0&lt;span&gt;
TRAIN_BATCH_SIZE &lt;/span&gt;= 20  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据BATCH大小&lt;/span&gt;
TRAIN_NUM_STEPS = 35    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据截断长度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在测试的时候不需要使用截断&lt;/span&gt;
EVAL_BATCH_SIZE = EVAL_NUM_STEP = 1&lt;span&gt;
NUM_EPOCH &lt;/span&gt;= 2 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用训练数据的轮数&lt;/span&gt;
KEEP_DROP =0.5 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;节点不被dropout的概率&lt;/span&gt;
MAX_GRAD_NORM =5 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用于控制梯度膨胀的参数&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个PTBMODEL类来描述模型，方便维护循环神经网络中的状态&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PTBMODEL:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,batch_size,num_steps,is_training =&lt;span&gt; True):
        self.batch_size &lt;/span&gt;=&lt;span&gt; batch_size
        self.num_steps &lt;/span&gt;=&lt;span&gt; num_steps
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输入层，维度为batch_size* num_steps&lt;/span&gt;
        self.input_data = tf.placeholder(tf.int32,shape=&lt;span&gt;[batch_size,num_steps])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义预期输出。它的维度和ptb_iterrattor输出的正确答案维度是一样的。&lt;/span&gt;
        self.targets =&lt;span&gt; tf.placeholder(tf.int32,[batch_size,num_steps])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义使用LSTM结构为循环体结构且使用dropout的深层循环神经网络&lt;/span&gt;
        lstm_cell =&lt;span&gt; tf.nn.rnn_cell.BasicLSTMCell(HIDDEN_SIZE)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; is_training:
            lstm_cell &lt;/span&gt;= tf.nn.rnn_cell.DropoutWrapper(lstm_cell,output_keep_prob=&lt;span&gt;KEEP_DROP)
        cell &lt;/span&gt;=&lt;span&gt; tf.nn.rnn_cell.MultiRNNCell(lstm_cell)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化初始状态&lt;/span&gt;
        self.initial_state =&lt;span&gt; cell.zero_state(batch_size,tf.float32)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将单词ID转换为单词向量，总共有VOCAB_SIZE个单词，每个单词向量的维度为HIDDEN_SIZE，所以embedding参数的维度为&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;VOCAB_SIZE*HIDDEN_SIZE&lt;/span&gt;
        embedding = tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embedding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[VOCAB_SIZE,HIDDEN_SIZE])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将原本batch_size * num_steps个单词ID转化为单词向量，转化后的输入层维度为batch_size * num_steps * HIDDEN_SIZE&lt;/span&gt;
        inputs =&lt;span&gt; tf.nn.embedding_lookup(embedding,self.input_data)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只在训练时使用dropout&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; is_training:
            inputs  &lt;/span&gt;=&lt;span&gt; tf.nn.dropout(inputs,KEEP_DROP)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义输出列表，在这里现将不同时刻LSTM结构的输出收集起来，再通过一个全连接层得到最终输出&lt;/span&gt;
        output =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;state 存储不同batch中LSTM的状态，并且初始化为0.&lt;/span&gt;
        state =&lt;span&gt; self.initial_state
        with tf.variable_scope(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RNN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; time_step  &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_steps):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; time_step &amp;gt;&lt;span&gt; 0 :
                    tf.get_variable_scope().reuse_variables()
                cell_output,state &lt;/span&gt;=&lt;span&gt; cell(inputs[:,time_step,:],state)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将当前输出加入输出队列&lt;/span&gt;
&lt;span&gt;                output.append(cell_output)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把输出队列展开成[batch,hidden_size*num_steps]的形状，然后再reshape成【batch*num_steps,hidden_size】的形状。&lt;/span&gt;
        output = tf.reshape(tf.concat(output,1),[-1&lt;span&gt;,HIDDEN_SIZE])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将从LSTM中得到的输出再经过一个全连接层得到最后的预测结果，最终的预测结果在每一时刻上都是一个长度为VOCAB_SIZE的数组&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;经过SoftMax层之后表示下一个位置是不同单词的概率。&lt;/span&gt;
        weight = tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;weight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[HIDDEN_SIZE,VOCAB_SIZE])
        baias  &lt;/span&gt;=  tf.get_variable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bias&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[VOCAB_SIZE])
        logits &lt;/span&gt;= tf.matmul(output,weight) +&lt;span&gt; baias
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义交叉熵损失函数&lt;/span&gt;
        loss  = sequence_loss_by_example([logits],[tf.reshape(self.targets,[-1&lt;span&gt;])],
                                                                   [tf.ones([batch_size&lt;/span&gt;*num_steps],dtype=&lt;span&gt;tf.float32)]
                                                                   )
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算得到每个batch的平均损失&lt;/span&gt;
        self.cost = tf.reduce_sum(loss)/&lt;span&gt;batch_size
        self.final_state &lt;/span&gt;=&lt;span&gt; state
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只在训练模型是定义反向传播操作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; is_training:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;

        trainable_variables &lt;/span&gt;=&lt;span&gt; tf.trainable_variables()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过clip_by_global_norm函数控制梯度的大小，避免梯度膨胀的问题&lt;/span&gt;
        grads,_ =&lt;span&gt; tf.clip_by_global_norm(tf.gradients(self.cost,trainable_variables),MAX_GRAD_NORM)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义优化方法&lt;/span&gt;
        optimizer =&lt;span&gt; tf.train.GradientDescentOptimizer(LEARNING_RATE)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义训练步骤&lt;/span&gt;
        self.train_op =&lt;span&gt; optimizer.apply_gradients(zip(grads,trainable_variables))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用给定的模型model在数据data上运行train_op并返回全部数据上的perplexity值&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run_epoch(session,model,data,train_op,output_log):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算perplexity的辅助变量&lt;/span&gt;
    total_costs = 0.0&lt;span&gt;
    iters &lt;/span&gt;=&lt;span&gt; 0
    state &lt;/span&gt;=&lt;span&gt; session.run(model.initial_state)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用当前数据训练或者测试模型&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; step ,(x,y) &lt;span&gt;in&lt;/span&gt;&lt;span&gt;  enumerate(reader.ptb_iterator( data,model.batch_size,model.num_steps)):
        cost,state,_ &lt;/span&gt;=&lt;span&gt; session.run([model.cost,model.final_output,model.train_op],{
            model.input_data:x,model.targets:y,
            model.initial_state:state
        })
        total_costs &lt;/span&gt;+=&lt;span&gt; cost
        iters &lt;/span&gt;+=&lt;span&gt; model.num_steps
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只有在训练时输出日志&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; output_log &lt;span&gt;and&lt;/span&gt; step % 100 ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After %s steps ,perplexity is %.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(step,np.exp(total_costs/&lt;span&gt;iters)))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回给定模型在给定数据上的perplexity&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; np.exp(total_costs/&lt;span&gt;iters)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(_):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取原始数据&lt;/span&gt;
    train_data,valid_data,test_data =&lt;span&gt; reader.ptb_raw_data(DATA_PATH)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义初始化函数&lt;/span&gt;
    initializer = tf.random_uniform_initializer(-0.05,0.05&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义训练用的循环神经网络模型&lt;/span&gt;
    with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;language_model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,reuse=True,initializer=&lt;span&gt;initializer):
        train_model &lt;/span&gt;= PTBMODEL(TRAIN_BATCH_SIZE,TRAIN_NUM_STEPS,is_training=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义评估用的循环神经网络模型&lt;/span&gt;
    with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;language_model&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,reuse=True,initializer=&lt;span&gt;initializer):
        eval_model &lt;/span&gt;= PTBMODEL(EVAL_BATCH_SIZE,EVAL_NUM_STEP,is_training=&lt;span&gt;False)
    with tf.Session() as sess:
        tf.global_variables_initializer().run()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用训练数据训练模型&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(NUM_EPOCH):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;In iteration:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(i+1&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在所有训练数据上训练RNN&lt;/span&gt;
&lt;span&gt;            run_epoch(sess,train_model,train_data,train_model.train_op,True)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用验证集评测模型效果&lt;/span&gt;
            valid_perplexity =&lt;span&gt; run_epoch(sess,eval_model,valid_data,tf.no_op(),False)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Epoch %s ,Validation perplexity :%.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(i+1&lt;span&gt;,valid_perplexity))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最后使用测试集验证模型效果&lt;/span&gt;
        test_perplexity =&lt;span&gt; run_epoch(sess,eval_model,valid_data,tf.no_op(),False)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEST perplexity :%.3f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(test_perplexity))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    tf.app.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 四、时间序列预测&lt;/p&gt;
&lt;p&gt; 　　怎么用循环神经网络来预测正弦函数，可利用TF的高级封装--TFLearn.&lt;/p&gt;
&lt;p&gt;　　1、使用TFLearn自定义模型&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn  &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cross_validation
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datasets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; metrics
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.learn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models,Estimator,SKCompat
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; layers,framework
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入TFLearn&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义模型，对于给定的输入数据以及其对应的正确答案，返回在这些输入上的预测值、损失值以及训练步骤&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_model(feature,target):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将预测的模型转换为one-hot编码的形式，因为共有三个类别，所以向量长度为3.经过转化后，三个个类别（1，0，0），（0，1，0），（0，0，1）&lt;/span&gt;
    target = tf.one_hot(target,3,1&lt;span&gt;,0)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义模型以及其在给定数据上的损失函数。TFLearn通过logistic_regression封装了一个单层全链接神经网络&lt;/span&gt;
    logits,loss =&lt;span&gt; models.logistic_regression(feature,target)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建模型的优化器，并得到优化步骤&lt;/span&gt;
    train_op = layers.optimize_loss(loss,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;损失函数&lt;/span&gt;
                                    framework.get_global_step(), &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取训练步数并在训练时更新&lt;/span&gt;
                                    optimizer=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Adagrad&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义优化器&lt;/span&gt;
                                    learning_rate=0.1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义学习率&lt;/span&gt;
&lt;span&gt;                                    )
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回在给定数据上的预测结果、损失值以及优化步骤&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; tf.argmax(logits,1&lt;span&gt;) ,loss,train_op

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载iris数据集，并划分为训练集合和测试集合&lt;/span&gt;
iris  =&lt;span&gt; datasets.load_iris()
x_train,x_test,y_train,y_test &lt;/span&gt;= cross_validation.train_test_split(iris.data,iris.target,test_size=0.2,random_state=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对自定义的模型进行封装&lt;/span&gt;
classifier =Estimator(model_fn=&lt;span&gt;my_model)
classifier &lt;/span&gt;=&lt;span&gt; SKCompat(classifier)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用封装好的模型和训练数据执行100轮的迭代&lt;/span&gt;
classifier.fit(x_train,y_train,steps=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用训练好的模型进行预测&lt;/span&gt;
y_predicted =&lt;span&gt; classifier.predict(x_test)



&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算模型的准确度&lt;/span&gt;
score  =&lt;span&gt; metrics.accuracy_score(y_test,y_predicted)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accuracy: %.2f %%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(score * 100))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、预测正选函数&lt;/p&gt;
&lt;p&gt;　　因为标准的RNN预测的是离散值，所以程序需要将连续的sin函数曲线离散化。&lt;/p&gt;
&lt;p&gt;　　每个SAMPLE_ITERVAL对sin函数进行一次采样，采样得到的序列就是sin函数离散化之后的结果&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib as mpl
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; matplotlib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.contrib.learn.python.learn.estimators.estimator &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SKCompat

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TensorFlow的高层封装TFLearn&lt;/span&gt;
learn =&lt;span&gt; tf.contrib.learn

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 神经网络参数&lt;/span&gt;
HIDDEN_SIZE = 30  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; LSTM隐藏节点个数&lt;/span&gt;
NUM_LAYERS = 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; LSTM层数&lt;/span&gt;
TIMESTEPS = 10  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环神经网络截断长度&lt;/span&gt;
BATCH_SIZE = 32  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; batch大小&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据参数&lt;/span&gt;
TRAINING_STEPS = 3000  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练轮数&lt;/span&gt;
TRAINING_EXAMPLES = 10000  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练数据个数&lt;/span&gt;
TESTING_EXAMPLES = 1000  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试数据个数&lt;/span&gt;
SAMPLE_GAP = 0.01  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采样间隔&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; generate_data(seq):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列的第i项和后面的TIMESTEPS-1项合在一起作为输入，第i+TIMESTEPS项作为输出&lt;/span&gt;
    X =&lt;span&gt; []
    y &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(seq) - TIMESTEPS - 1&lt;span&gt;):
        X.append([seq[i:i &lt;/span&gt;+&lt;span&gt; TIMESTEPS]])
        y.append([seq[i &lt;/span&gt;+&lt;span&gt; TIMESTEPS]])
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; np.array(X, dtype=np.float32), np.array(y, dtype=&lt;span&gt;np.float32)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; LSTM结构单元&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; LstmCell():
    lstm_cell &lt;/span&gt;=&lt;span&gt; tf.contrib.rnn.BasicLSTMCell(HIDDEN_SIZE)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lstm_cell


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; lstm_model(X, y):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用多层LSTM，不能用lstm_cell*NUM_LAYERS的方法，会导致LSTM的tensor名字都一样&lt;/span&gt;
    cell = tf.contrib.rnn.MultiRNNCell([LstmCell() &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(NUM_LAYERS)])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将多层LSTM结构连接成RNN网络并计算前向传播结果&lt;/span&gt;
    output, _ = tf.nn.dynamic_rnn(cell, X, dtype=&lt;span&gt;tf.float32)
    output &lt;/span&gt;= tf.reshape(output, [-1&lt;span&gt;, HIDDEN_SIZE])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过无激活函数的全联接层计算线性回归，并将数据压缩成一维数组的结构&lt;/span&gt;
    predictions = tf.contrib.layers.fully_connected(output, 1&lt;span&gt;, None)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将predictions和labels调整为统一的shape&lt;/span&gt;
    y = tf.reshape(y, [-1&lt;span&gt;])
    predictions &lt;/span&gt;= tf.reshape(predictions, [-1&lt;span&gt;])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算损失值&lt;/span&gt;
    loss =&lt;span&gt; tf.losses.mean_squared_error(predictions, y)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建模型优化器并得到优化步骤&lt;/span&gt;
    train_op =&lt;span&gt; tf.contrib.layers.optimize_loss(
        loss,
        tf.train.get_global_step(),
        optimizer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Adagrad&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        learning_rate&lt;/span&gt;=0.1&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; predictions, loss, train_op


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用sin生成训练和测试数据集&lt;/span&gt;
test_start = TRAINING_EXAMPLES *&lt;span&gt; SAMPLE_GAP
test_end &lt;/span&gt;= (TRAINING_EXAMPLES + TESTING_EXAMPLES) *&lt;span&gt; SAMPLE_GAP
train_X, train_y &lt;/span&gt;=&lt;span&gt; generate_data(
    np.sin(np.linspace(0, test_start, TRAINING_EXAMPLES, dtype&lt;/span&gt;=&lt;span&gt;np.float32)))
test_X, test_y &lt;/span&gt;=&lt;span&gt; generate_data(
    np.sin(
        np.linspace(test_start, test_end, TESTING_EXAMPLES, dtype&lt;/span&gt;=&lt;span&gt;np.float32)))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 建立深层循环网络模型&lt;/span&gt;
regressor = SKCompat(learn.Estimator(model_fn=lstm_model, model_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;model/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用fit函数训练模型&lt;/span&gt;
regressor.fit(train_X, train_y, batch_size=BATCH_SIZE, steps=&lt;span&gt;TRAINING_STEPS)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用训练好的模型对测试集进行预测&lt;/span&gt;
predicted = [[pred] &lt;span&gt;for&lt;/span&gt; pred &lt;span&gt;in&lt;/span&gt;&lt;span&gt; regressor.predict(test_X)]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算rmse作为评价指标&lt;/span&gt;
rmse = np.sqrt(((predicted - test_y)**2).mean(axis=&lt;span&gt;0))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mean Square Error is: %f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (rmse[0]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对预测曲线绘图，并存储到sin.jpg&lt;/span&gt;
fit =&lt;span&gt; plt.figure()
plot_predicted &lt;/span&gt;= plt.plot(predicted,label = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;predicted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plot_test &lt;/span&gt;= plt.plot(test_y,label = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;real_sin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.legend([plot_predicted, plot_test], [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;predicted&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;real_sin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

plt.savefig(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sin.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 02 Jul 2018 15:23:00 +0000</pubDate>
<dc:creator>左手十字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoshoushizi/p/9243691.html</dc:identifier>
</item>
<item>
<title>性能测试day01_性能基本概念 - ~泪小白~</title>
<link>http://www.cnblogs.com/leixiaobai/p/9256363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leixiaobai/p/9256363.html</guid>
<description>&lt;p&gt;　　其实第一次接触性能是15年的时候，懵懵懂懂的被领导拉去做第一次做性能压测，如今有机会重新听一下云层大大讲解性能，于是打算以此博客记录下整个学习的过程，如若有不同意见者可以在下面留言指出，也欢迎大家一起来探讨性能测试。&lt;/p&gt;
&lt;p&gt;      进入今天的主题，今天的主要目的就是构建整体的思想，那么第一个问题来了，什么是性能测试？简单的来讲是不是就是性价比测试（这个本质上来讲是不是就是对比单位价格内的处理能力），性价比准确的来讲又是软硬件的投入对TPS的影响。&lt;/p&gt;
&lt;p&gt;请看下图的一个思路过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064304/201807/1064304-20180702215036799-961469590.png&quot; alt=&quot;&quot; width=&quot;1388&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　什么是性能问题？时间性价比的问题，具体到我们系统来讲是不是就是访问量的问题？&lt;/p&gt;
&lt;p&gt;　　那性能测试做什么呢？目前来讲有两种，第一种是证明满足需求的过程（性能需求-&amp;gt;验证需求-&amp;gt;给出结论），第二种是获取相关指标提供决策（设定方案-&amp;gt;获取指标-&amp;gt;决策判断依据），大部分人可能都是第一种。&lt;/p&gt;
&lt;p&gt;　　测试系统满足性能需求需要经历的阶段如下：&lt;/p&gt;
&lt;p&gt;　　　　　　1.性能需求是啥？（大部分性能问题没法做就是需求问题没弄清楚）&lt;/p&gt;
&lt;p&gt;　　　　　　2.测试方式是啥？（第一点性能方案的设计，第二点就是工具方法）&lt;/p&gt;
&lt;p&gt;　　　　　　3.结果怎么收集？（监控命令和监控平台如：zabbix、普罗米修斯）&lt;/p&gt;
&lt;p&gt;　　　　　　4.报告怎么编写？&lt;/p&gt;
&lt;p&gt;　　所以说性能测试就是为了验证在一定环境下系统满足性能需求的测试，主要验证性能指标（响应时间、吞吐量、资源利用率）。&lt;/p&gt;
&lt;p&gt;　　由于网上对这几个性能指标众说纷纭，而且不一定准确，这边来重新梳理下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应时间：分为事务响应时间（做一件事情所产生的所有时间开销，包括前后的等待时间等）和平均响应时间（某一个时间段内的响应时间分布趋势，这里有有两个点，一个是时间段的长度还有个就是时间段的位置；TPS也不一定是每秒的事务个数，取决于工具切的时间段），一般用平均响应时间作为参考依据而不是事务响应时间。&lt;/li&gt;
&lt;li&gt;吞吐量：是否以秒为单位以及单位下事务分布的情况？工具求出来的TPS不能完全以秒为单位！&lt;/li&gt;
&lt;li&gt;资源利用率：占用资源的百分比（可能存在某个节点的瓶颈但总占用率不高，例如多核CPU中的一个占用很高）和数量制（不太明确的总量，比如IO的处理能力（每秒字节数。不是百分比），以数量来表达，此时我们就需要了解每个计数器的概念和表达方式）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的来讲，根据这些数据了解系统的工作情况，最终给出分析调优的建议和总结报告，而分析调优的建议则取决于自身的眼界，所以说性能测试是一项需要掌握知识面非常广的测试项目。（千万别放弃哈！）&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 15:15:00 +0000</pubDate>
<dc:creator>~泪小白~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leixiaobai/p/9256363.html</dc:identifier>
</item>
<item>
<title>浮动与浮动的清除 - SoulDee</title>
<link>http://www.cnblogs.com/souldee/p/9256260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/souldee/p/9256260.html</guid>
<description>&lt;h2 id=&quot;一浮动&quot;&gt;一、浮动&lt;/h2&gt;
&lt;p&gt;说浮动就必须提及一下文档流，HTML当中的元素按照从左到右，从上到下的顺序进行排列称之为文档流，也就是正常排列。&lt;/p&gt;
&lt;p&gt;而浮动是什么呢？浮动会让元素脱离文档流，假如A元素浮动了，原本排在该元素之后的元素发现A元素不在这个文档流了，就会无视它往上接到A元素前面的元素之后(PS:但是文字并不会无视它，还会环绕A元素，也就是A元素没有脱离文字流，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702214000955-524538997.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如果使用position的绝对定位会连文字流也脱离文档流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702214219688-744311001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浮动的好处当然是布局了，例如通过浮动来形成三列布局，文字环绕等等。但是浮动也有一个问题，那就是会导致高度的塌陷，就像上面的图片显示，父元素的高度塌陷了，并没有将浮动的子元素包裹进去，这样子就会造成布局上的错误。&lt;/p&gt;
&lt;h2 id=&quot;二bfc&quot;&gt;二、BFC&lt;/h2&gt;
&lt;p&gt;什么是BFC？BFC是Block Formatting Context的缩写，也就是&lt;code&gt;块级格式化上下文&lt;/code&gt;，创建BFC有以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;float的值不为none。&lt;/li&gt;
&lt;li&gt;overflow的值不为visible。&lt;/li&gt;
&lt;li&gt;display的值为table-cell, table-caption, inline-block中的任何一个。&lt;/li&gt;
&lt;li&gt;position的值不为relative和static。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;BFC的特性就是包裹浮动的元素。按照我的理解，当你创建BFC之后元素就会把里面的东西视为自己的东西，包括浮动元素，然后创建一个私有领域给包裹进来。此外BFC还有还有如下特性。&lt;/p&gt;
&lt;p&gt;1.让原本会叠加的上下外边距叠加无效。将想要边距失效的两个盒子分别放入一个父盒子，然后为父盒子创建BFC。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702221214995-1055365897.png&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702221221844-1168897249.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.创建BFC的元素将不会围绕浮动元素，图中文字用p标签包裹并创建BFC，右上角浮动元素，可以看见文字并没有环绕浮动元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1359286/201807/1359286-20180702222127466-1411057661.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-清除浮动的方法&quot;&gt;三、 清除浮动的方法&lt;/h2&gt;
&lt;p&gt;清除浮动方法大致有两类，一类是&lt;code&gt;clear:both | left | right&lt;/code&gt; ,另一类则是创建&lt;code&gt;BFC&lt;/code&gt;,细分又可以分为多种。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过在浮动元素末尾添加一个空的标签例如并设置样式为&lt;code&gt;clear:both | left | right&lt;/code&gt; ，其他标签br等亦可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
    &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&quot;clear: both;&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：简单。&lt;/p&gt;
&lt;p&gt;缺点：增加了额外的标签，并且很显然这并不符合语义化。&lt;/p&gt;
&lt;p&gt;*使用 br标签和其自身的 html属性，br 有 &lt;code&gt;clear=all | left | right | none；&lt;/code&gt;的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;parent&quot;&amp;gt;
    &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;br clear='all'&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：简单代码量少，比空标签语义化稍好。&lt;/p&gt;
&lt;p&gt;缺点：同上。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;::after&lt;/code&gt;伪元素(万金油方法)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ps:由于IE6-7不支持&lt;code&gt;:after&lt;/code&gt;，使用`&lt;code&gt;zoom:1&lt;/code&gt;触发&lt;code&gt;hasLayout&lt;/code&gt;。其实是通过 content 在元素的后面生成了内容为空的块级元素&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.clearfix:after {
    content:&quot;&quot;;
    display:block;
    height:0;
    visibility:hidden;//这一条可以省略，证明请看原文精益求精部分
    clear:both; 
}
.clearfix {
    zoom:1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：结构和语义化完全正确,代码量居中。&lt;/p&gt;
&lt;p&gt;缺点：复用方式不当会造成代码量增加。&lt;/p&gt;
&lt;p&gt;伪元素还有一种写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用display:table 是为了避免外边距margin重叠导致的margin塌陷, 内部元素默认会成为 table-cell 单元格的形式
.clearfix:before, .clearfix:after {
    content:&quot;&quot;;
    display:table;
}
.clearfix:after{
    clear:both;
    overflow:hidden;
}
.clearfix{
    zoom:1; 
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;父元素设置 &lt;code&gt;overflow：hidden&lt;/code&gt;,(PS:在IE6中还需要触发 hasLayout ，例如 &lt;code&gt;zoom:1&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：不存在结构和语义化问题，代码量极少。&lt;/p&gt;
&lt;p&gt;缺点：由于hidden的原因，当内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素，还会导致中键失效（鼠标中键）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父元素设置 &lt;code&gt;overflow：auto&lt;/code&gt; 属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：同上&lt;/p&gt;
&lt;p&gt;缺点：多个嵌套后，会有bug，详情看原文。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父元素也浮动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：代码少&lt;/p&gt;
&lt;p&gt;缺点：总不能一直浮动到body吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;父元素设置&lt;code&gt;display:table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：结构语义化完全正确，代码量极少。&lt;/p&gt;
&lt;p&gt;缺点：会造成盒模型的改变。&lt;/p&gt;
&lt;p&gt;其余的参考上面如何创建BFC。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.iyunlu.com/view/css-xhtml/55.html&quot;&gt;那些年我们一起清除过的浮动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/pigtail/archive/2013/01/23/2871627.html&quot;&gt;关于Block Formatting Context－－BFC和IE的hasLayout&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NzE0MjQ2Mw==&amp;amp;mid=2652493490&amp;amp;idx=1&amp;amp;sn=8015c7e1eafb5b4920124d9bdeeeebea&amp;amp;chksm=bd33fc628a447574e547ca35bf832f9a096f9e35ffdef62a6374140f2711bb3639b300804202&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=0316bCgK2ZqaVHBMtUTikw6D#rd&quot;&gt;理解CSS布局和BFC&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 14:47:00 +0000</pubDate>
<dc:creator>SoulDee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/souldee/p/9256260.html</dc:identifier>
</item>
<item>
<title>Nginx安装 - palapala</title>
<link>http://www.cnblogs.com/ssskkk/p/9256201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ssskkk/p/9256201.html</guid>
<description>&lt;p&gt;nginx&lt;span&gt;是&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言开发，建议在&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;上运行，本教程使用&lt;/span&gt;&lt;span&gt;Centos6.5&lt;/span&gt;&lt;span&gt;作为安装环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　安装&lt;/span&gt;nginx&lt;span&gt;需要先将官网下载的源码进行编译，编译依赖&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;环境，如果没有&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;环境，需要安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　gcc&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;yum install gcc-c++&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　PCRE(Perl Compatible Regular Expressions)&lt;span&gt;是一个&lt;/span&gt;&lt;span&gt;Perl&lt;/span&gt;&lt;span&gt;库，包括&lt;/span&gt; &lt;span&gt;perl&lt;/span&gt; &lt;span&gt;兼容的正则表达式库。&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;模块使用&lt;/span&gt;&lt;span&gt;pcre&lt;/span&gt;&lt;span&gt;来解析正则表达式，所以需要在&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;上安装&lt;/span&gt;&lt;span&gt;pcre&lt;/span&gt;&lt;span&gt;库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　yum install -y pcre pcre-devel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　注：&lt;/span&gt;pcre-devel&lt;span&gt;是使用&lt;/span&gt;&lt;span&gt;pcre&lt;/span&gt;&lt;span&gt;开发的一个二次开发库。&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;也需要此库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　zlib&lt;span&gt;库提供了很多种压缩和解压缩的方式，&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;zlib&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;包的内容进行&lt;/span&gt;&lt;span&gt;gzip&lt;/span&gt;&lt;span&gt;，所以需要在&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;上安装&lt;/span&gt;&lt;span&gt;zlib&lt;/span&gt;&lt;span&gt;库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　yum install -y zlib zlib-devel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　OpenSSL &lt;span&gt;是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及&lt;/span&gt;&lt;span&gt;SSL&lt;/span&gt;&lt;span&gt;协议，并提供丰富的应用程序供测试或其它目的使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　nginx&lt;span&gt;不仅支持&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;协议，还支持&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;（即在&lt;/span&gt;&lt;span&gt;ssl&lt;/span&gt;&lt;span&gt;协议上传输&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;），所以需要在&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt;openssl&lt;/span&gt;&lt;span&gt;库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　yum install -y openssl openssl-devel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　将&lt;/span&gt;nginx-1.8.0.tar.gz&lt;span&gt;拷贝至&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　解压：&lt;/p&gt;
&lt;p&gt;　　　　tar -zxvf nginx-1.8.0.tar.gz&lt;/p&gt;
&lt;p&gt;　　　　cd nginx-1.8.0&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;配置&lt;/span&gt;makefile 参数设置如下：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　./configure \&lt;/p&gt;
&lt;p&gt;　　　　--prefix=/usr/local/nginx \&lt;/p&gt;
&lt;p&gt;　　　　--pid-path=/var/run/nginx/nginx.pid \&lt;/p&gt;
&lt;p&gt;　　　　--lock-path=/var/lock/nginx.lock \&lt;/p&gt;
&lt;p&gt;　　　　--error-log-path=/var/log/nginx/error.log \&lt;/p&gt;
&lt;p&gt;　　　　--http-log-path=/var/log/nginx/access.log \&lt;/p&gt;
&lt;p&gt;　　　　--with-http_gzip_static_module \&lt;/p&gt;
&lt;p&gt;　　　　--http-client-body-temp-path=/var/temp/nginx/client \&lt;/p&gt;
&lt;p&gt;　　　　--http-proxy-temp-path=/var/temp/nginx/proxy \&lt;/p&gt;
&lt;p&gt;　　　　--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \&lt;/p&gt;
&lt;p&gt;　　　　--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \&lt;/p&gt;
&lt;p&gt;　　　　--http-scgi-temp-path=/var/temp/nginx/scgi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　注意：上边将临时文件目录指定为&lt;/span&gt;/var/temp/nginx&lt;span&gt;，需要在&lt;/span&gt;&lt;span&gt;/var&lt;/span&gt;&lt;span&gt;下创建&lt;/span&gt;&lt;span&gt;temp&lt;/span&gt;&lt;span&gt;及&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;目录(&lt;/span&gt;&lt;/strong&gt;mkdir /var/temp/nginx -p)&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;15&quot;&gt;&lt;span&gt;&lt;strong&gt;编译安装&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　make&lt;/p&gt;
&lt;p&gt;　　　　make  install (会安装到usr/local/nginx)&lt;/p&gt;
&lt;p&gt;　　cd /usr/local/nginx/sbin/&lt;/p&gt;
&lt;p&gt;　　./nginx&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　注意：执行&lt;/span&gt;./nginx&lt;span&gt;启动&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;，这里可以&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;指定加载的&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;配置文件，如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　./nginx -c /usr/local/nginx/conf/nginx.conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　如果不指定&lt;/span&gt;-c&lt;span&gt;，&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;在启动时默认加载&lt;/span&gt;&lt;span&gt;conf/nginx.conf&lt;/span&gt;&lt;span&gt;文件，此文件的地址也可以在编译安装&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;时指定&lt;/span&gt;&lt;span&gt;./configure&lt;/span&gt;&lt;span&gt;的参数（&lt;/span&gt;&lt;span&gt;--conf-path=&lt;/span&gt; &lt;span&gt;指向配置文件（&lt;/span&gt;&lt;span&gt;nginx.conf&lt;/span&gt;&lt;span&gt;））&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　方式&lt;/span&gt;1&lt;span&gt;，快速停止：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　cd /usr/local/nginx/sbin&lt;/p&gt;
&lt;p&gt;　　　　./nginx -s stop&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　此方式相当于先查出&lt;/span&gt;nginx&lt;span&gt;进程&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;再使用&lt;/span&gt;&lt;span&gt;kill&lt;/span&gt;&lt;span&gt;命令强制杀掉进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　方式&lt;/span&gt;2&lt;span&gt;，完整停止&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;建议使用)&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　cd /usr/local/nginx/sbin&lt;/p&gt;
&lt;p&gt;　　　　./nginx -s quit&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　此方式停止步骤是待&lt;/span&gt;nginx&lt;span&gt;进程处理任务完毕进行停止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　方式&lt;/span&gt;1&lt;span&gt;，先停止再启动（&lt;/span&gt;建议使用）：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　对&lt;/span&gt;nginx&lt;span&gt;进行重启相当于先停止&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;再启动&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;，即先执行停止命令再执行启动命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　如下：&lt;/p&gt;
&lt;p&gt;　　　　　　./nginx -s quit&lt;/p&gt;
&lt;p&gt;　　　　　　./nginx&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　方式&lt;/span&gt;2&lt;span&gt;，重新加载配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　当&lt;/span&gt;nginx&lt;span&gt;的配置文件&lt;/span&gt;&lt;span&gt;nginx.conf&lt;/span&gt;&lt;span&gt;修改后，要想让配置生效需要重启&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;，使用&lt;/span&gt;&lt;span&gt;-s reload&lt;/span&gt;&lt;span&gt;不用先停止&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;再启动&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;即可将配置信息在&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;中生效，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　./nginx -s reload&lt;/p&gt;
&lt;p&gt;输入ip119.23.50.194 即可访问nginx (nginx默认80端口)&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 14:33:00 +0000</pubDate>
<dc:creator>palapala</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ssskkk/p/9256201.html</dc:identifier>
</item>
<item>
<title>PHP内核之旅-6.垃圾回收机制 - jackson0714</title>
<link>http://www.cnblogs.com/jackson0714/p/php6.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/php6.html</guid>
<description>&lt;p&gt;回收PHP 内核之旅系列&lt;/p&gt;


&lt;p&gt;只有使用引用计数的变量才需要回收。引用计数就是用来标记变量的引用次数的。&lt;/p&gt;
&lt;p&gt;当有新的变量zval指向value时，计数器加1，当变量zval销毁时，计数器减一。当引用计数为0时，表示此value没有被任何变量指向，可以对value进行释放。&lt;/p&gt;
&lt;p&gt;下面的例子说明引用计数的是如何变化的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
$x = array(); //array这个value被变量$x引用1次，refcount = 1
$y = $x; //array这个value被变量$x,$y分别引用1次，refcount = 2
$z = $y; //array这个value被变量$x,$y,$z分别引用1次，refcount = 3
unset($y); //array这个value被变量$x,$z分别引用1次，refcount = 2，$y被销毁了，没有引用array这个value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用引用计数的类型有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string、array、object、resource、reference&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;下面的表格说明了只有type_flag为以下8种类型且IS_TYPE_REFOUNTED=true的变量才使用引用计数&lt;/p&gt;
&lt;table dir=&quot;ltr&quot; border=&quot;2&quot; frame=&quot;vsides&quot; rules=&quot;all&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;strong&gt;type_flag&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;IS_TYPE_REFCOUNTED&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1        &lt;/td&gt;
&lt;td&gt;simple types&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;string&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;interned string&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;array&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;immutable array&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;object&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;resource&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;reference&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2&gt;1.正常回收场景：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;a.自动回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在zval断开value的指向时，如果发现refcount=0则会直接释放value。&lt;/p&gt;
&lt;p&gt;　　　　断开value指向的情形：&lt;/p&gt;
&lt;p&gt;　　　　（1）修改变量时会断开原有value的指向&lt;/p&gt;
&lt;p&gt;　　　　（2）函数返回时会释放所有的局部变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.主动回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　unset()函数&lt;/p&gt;
&lt;h2&gt;2.垃圾回收场景：&lt;/h2&gt;
&lt;p&gt;当因循环引用导致无法释放的变量称为&lt;span&gt;&lt;strong&gt;垃圾&lt;/strong&gt;&lt;/span&gt;，用垃圾回收器进行回收。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;（1）如果一个变量value的refcount减一之后等于0，此value可以被释放掉，不属于垃圾。垃圾回收器不会处理。&lt;/p&gt;
&lt;p&gt;（2）如果一个变量value的refcount减一之后还是大于0，此value被认为不能被释放掉，可能成为一个垃圾。&lt;/p&gt;
&lt;p&gt;（3）垃圾回收器会将可能的垃圾收集起来，等达到一定数量后开始启动垃圾鉴定程序，把真正的垃圾释放掉。&lt;/p&gt;
&lt;p&gt;（4）收集的时机是refount减少时。&lt;/p&gt;
&lt;p&gt;（5）收集到的垃圾保存到一个buffer缓冲区中。&lt;/p&gt;
&lt;p&gt;（6）垃圾只会出现在array、object类型中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1.垃圾是如何回收的&lt;/h2&gt;
&lt;p&gt;垃圾收集器收集的可能垃圾到达一定数量后，启动垃圾鉴定、回收程序。&lt;/p&gt;
&lt;h2&gt;2.垃圾鉴定&lt;/h2&gt;
&lt;p&gt;垃圾是由于成员引用自身导致的，那么就对value的refcount减一操作，如果value的refount变为了0，则表明其引用全部来自自身成员，value属于垃圾。&lt;/p&gt;
&lt;h2&gt;3.垃圾回收的步骤&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/414640/201806/414640-20180620195053392-44636031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;note&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;步骤一：遍历垃圾回收器的buffer缓冲区，把value标为灰色，把value的成员的refount-1，标为白色。&lt;/p&gt;
&lt;p&gt;步骤二：遍历垃圾回收器的buffer缓冲区，如果value的 refcount等于0，则认为是垃圾，标为白色；如果不等于0，则表示还有外部的引用，不是垃圾，将refcount+1还原回去，标为黑色。&lt;/p&gt;
&lt;p&gt;步骤三：遍历垃圾回收器的buffer缓冲区，将value为非白色的节点从buffer中删除，最终buffer缓冲区中都是真正的垃圾。&lt;/p&gt;
&lt;p&gt;步骤四：遍历垃圾回收器的buffer缓冲区，释放此value。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;1.垃圾管家&lt;/h2&gt;
&lt;p&gt;_zend_gc_globals 对垃圾进行管理，收集到的可能成为垃圾的value就保存在这个结构的buf中，称为垃圾缓存区。&lt;/p&gt;
&lt;p&gt;文件路劲：\Zend\zend_gc.h&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e29b1dee-fe6c-478c-9fce-ddfa43a6efa2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e29b1dee-fe6c-478c-9fce-ddfa43a6efa2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e29b1dee-fe6c-478c-9fce-ddfa43a6efa2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e29b1dee-fe6c-478c-9fce-ddfa43a6efa2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e29b1dee-fe6c-478c-9fce-ddfa43a6efa2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;typedef struct _zend_gc_globals {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     zend_bool         gc_enabled; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否启用GC&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     zend_bool         gc_active; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否处于垃圾检查中&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     zend_bool         gc_full; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存区是否已满&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     gc_root_buffer   *buf; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预分配的垃圾缓存区，用于保存可能成为垃圾的value&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     gc_root_buffer    roots; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向buf中最新加入的一个可能垃圾&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     gc_root_buffer   *unused; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向buf中没有使用的buffer&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     gc_root_buffer   *first_unused; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向第一个没有使用的buffer&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     gc_root_buffer   *last_unused; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向最后一个没有使用的buffer&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     gc_root_buffer    to_free; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待释放的垃圾&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     gc_root_buffer   *next_to_free; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下指向下一个待释放的垃圾&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     uint32_t gc_runs; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计GC运行次数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     uint32_t collected; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计已回收的垃圾数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;if GC_BENCH&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    uint32_t root_buf_length;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    uint32_t root_buf_peak;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    uint32_t zval_possible_root;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    uint32_t zval_buffered;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    uint32_t zval_remove_from_buffer;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    uint32_t zval_marked_grey;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;endif&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     gc_additional_buffer *&lt;span&gt;additional_buffer;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; } zend_gc_globals;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;_zend_gc_globals&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;h2&gt;2.垃圾管家初始化&lt;/h2&gt;
&lt;p&gt;（1）php.ini解析后调用gc_init()初始垃圾管家_zend_gc_globals &lt;/p&gt;
&lt;p&gt;文件路径：\Zend\zend_gc.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('eba99e6e-2ca5-4cca-bd61-40418ea68879')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_eba99e6e-2ca5-4cca-bd61-40418ea68879&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eba99e6e-2ca5-4cca-bd61-40418ea68879&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('eba99e6e-2ca5-4cca-bd61-40418ea68879',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eba99e6e-2ca5-4cca-bd61-40418ea68879&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ZEND_API void gc_init(void)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (GC_G(buf) == &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; GC_G(gc_enabled)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         GC_G(buf) = (gc_root_buffer*) malloc(&lt;span&gt;sizeof&lt;/span&gt;(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GC_ROOT_BUFFER_MAX_ENTRIES=10001&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         GC_G(last_unused) = &amp;amp;&lt;span&gt;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        gc_reset();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_init&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;（2）gc_init()函数里面调用gc_reset()函数初始化变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1ea541d2-b204-4670-b340-c993449fa45d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1ea541d2-b204-4670-b340-c993449fa45d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1ea541d2-b204-4670-b340-c993449fa45d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1ea541d2-b204-4670-b340-c993449fa45d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1ea541d2-b204-4670-b340-c993449fa45d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;ZEND_API void gc_reset(void)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     GC_G(gc_runs) = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     GC_G(collected) = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     GC_G(gc_full) = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     GC_G(roots).&lt;span&gt;next&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(roots);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     GC_G(roots).&lt;span&gt;prev&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(roots);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     GC_G(to_free).&lt;span&gt;next&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     GC_G(to_free).&lt;span&gt;prev&lt;/span&gt; = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     GC_G(unused) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     GC_G(first_unused) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     GC_G(last_unused) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     GC_G(additional_buffer) = &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_reset&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3.判断是否需要收集&lt;/h2&gt;
&lt;p&gt;（1）在销毁一个变量时就会判断是否需要收集。调用i_zval_ptr_dtor()函数&lt;/p&gt;
&lt;p&gt;文件路径：Zend\zend_variables.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b8ec44f4-3129-4d87-8973-773ef776e6d1')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b8ec44f4-3129-4d87-8973-773ef776e6d1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b8ec44f4-3129-4d87-8973-773ef776e6d1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b8ec44f4-3129-4d87-8973-773ef776e6d1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b8ec44f4-3129-4d87-8973-773ef776e6d1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; zend_always_inline void i_zval_ptr_dtor(zval *&lt;span&gt;zval_ptr ZEND_FILE_LINE_DC)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Z_REFCOUNTED_P(zval_ptr)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;type_flags &amp;amp; IS_TYPE_REFCOUNTED&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         zend_refcounted *ref =&lt;span&gt; Z_COUNTED_P(zval_ptr);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!--GC_REFCOUNT(ref)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;refcount - 1 之后等于0，则不是垃圾，正常回收&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            _zval_dtor_func(ref ZEND_FILE_LINE_RELAY_CC);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果refcount - 1 之后仍然大于0，垃圾管家进行收集&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            gc_check_possible_root(ref);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;i_zval_ptr_dtor&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;（2）如果refcount减一后，refcount等于0，则认为不是垃圾，释放此value&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d522d3b8-e524-4e15-acd6-fc8a62557d8f')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d522d3b8-e524-4e15-acd6-fc8a62557d8f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d522d3b8-e524-4e15-acd6-fc8a62557d8f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d522d3b8-e524-4e15-acd6-fc8a62557d8f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d522d3b8-e524-4e15-acd6-fc8a62557d8f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件路径：\Zend\zend_variables.c&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ZEND_API void ZEND_FASTCALL _zval_dtor_func(zend_refcounted *&lt;span&gt;p ZEND_FILE_LINE_DC)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (GC_TYPE(p)) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_STRING&lt;/span&gt;:
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; IS_CONSTANT:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 zend_string *str = (zend_string*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                CHECK_ZVAL_STRING_REL(str);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                zend_string_free(str);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_ARRAY&lt;/span&gt;:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 zend_array *arr = (zend_array*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                zend_array_destroy(arr);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; IS_CONSTANT_AST:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 zend_ast_ref *ast = (zend_ast_ref*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 zend_ast_destroy_and_free(ast-&amp;gt;&lt;span&gt;ast);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 efree_size(ast, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(zend_ast_ref));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_OBJECT&lt;/span&gt;:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 zend_object *obj = (zend_object*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                zend_objects_store_del(obj);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IS_RESOURCE&lt;/span&gt;:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 zend_resource *res = (zend_resource*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; destroy resource &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                zend_list_free(res);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;case&lt;/span&gt; IS_REFERENCE:&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 zend_reference *ref = (zend_reference*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;                 i_zval_ptr_dtor(&amp;amp;ref-&amp;gt;&lt;span&gt;val ZEND_FILE_LINE_RELAY_CC);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 efree_size(ref, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(zend_reference));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;default&lt;/span&gt;:
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;_zval_dtor_func&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;（3）如果refcount减一后，refcount大于0，则认为value可能是垃圾，垃圾管家进行收集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e0074413-019b-4a95-8cbc-61e036162ff5')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e0074413-019b-4a95-8cbc-61e036162ff5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e0074413-019b-4a95-8cbc-61e036162ff5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e0074413-019b-4a95-8cbc-61e036162ff5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e0074413-019b-4a95-8cbc-61e036162ff5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; \\文件路径：\Zend\zend_gc.&lt;span&gt;h
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; zend_always_inline void gc_check_possible_root(zend_refcounted *&lt;span&gt;ref)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (GC_TYPE(ref) ==&lt;span&gt; IS_REFERENCE) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         zval *zv = &amp;amp;((zend_reference*)ref)-&amp;gt;&lt;span&gt;val;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Z_REFCOUNTED_P(zv)) { 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            Z_TYPE_FLAGS 与 IS_TYPE_REFCOUNTED 与运算后，不等于0，则会被释放掉
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            Z_REFCOUNTED_P --&amp;gt; ((Z_TYPE_FLAGS(zval) &amp;amp; IS_TYPE_REFCOUNTED) != 0)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            Z_TYPE_FLAGS(zval) --&amp;gt; (zval).u1.v.type_flags
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            IS_TYPE_REFCOUNTED -&amp;gt; 1&amp;lt;&amp;lt;2 (0100)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         ref = Z_COUNTED_P(zv); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Z_COUNTED_P --&amp;gt; (zval).value.counted  GC头部&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (UNEXPECTED(GC_MAY_LEAK(ref))) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         gc_possible_root(ref); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;垃圾管家收集可能的垃圾&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_check_possible_root&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt; 4.收集垃圾&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9d36c16-2769-49bb-9f59-47821a85fc44')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c9d36c16-2769-49bb-9f59-47821a85fc44&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9d36c16-2769-49bb-9f59-47821a85fc44&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9d36c16-2769-49bb-9f59-47821a85fc44',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9d36c16-2769-49bb-9f59-47821a85fc44&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;\\&lt;/span&gt;&lt;span&gt;文件路径：\Zend\zend_gc.c&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; ZEND_API &lt;span&gt;void&lt;/span&gt; ZEND_FASTCALL gc_possible_root(zend_refcounted *&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     gc_root_buffer *&lt;span&gt;newRoot;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (UNEXPECTED(CG(unclean_shutdown)) ||&lt;span&gt; UNEXPECTED(GC_G(gc_active))) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     ZEND_ASSERT(GC_TYPE(&lt;span&gt;ref&lt;/span&gt;) == IS_ARRAY || GC_TYPE(&lt;span&gt;ref&lt;/span&gt;) == IS_OBJECT); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有数组和对象才会出现循环引用的产生的垃圾，所以只需要收集数组类型和对象类型的垃圾&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     ZEND_ASSERT(EXPECTED(GC_REF_GET_COLOR(&lt;span&gt;ref&lt;/span&gt;) == GC_BLACK)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只收集颜色为GC_BLACK的变量&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     ZEND_ASSERT(!GC_ADDRESS(GC_INFO(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    GC_BENCH_INC(zval_possible_root);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     newRoot = GC_G(unused); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿出unused指向的节点&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (newRoot) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拿出的节点是可用的，则将unused指向下一个节点&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         GC_G(unused) = newRoot-&amp;gt;&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GC_G(first_unused) != GC_G(last_unused)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果unused没有可用的，且first_unused还没有推进到last_unused，则表示buf缓存区中还有可用的节点&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         newRoot = GC_G(first_unused); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿出first_unused指向的节点&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         GC_G(first_unused)++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;first_unused指向下一个节点&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;buf缓存区已满，启动垃圾鉴定、垃圾回收&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!GC_G(gc_enabled)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果未启用垃圾回收，则直接返回&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         GC_REFCOUNT(&lt;span&gt;ref&lt;/span&gt;)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        gc_collect_cycles();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         GC_REFCOUNT(&lt;span&gt;ref&lt;/span&gt;)--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (UNEXPECTED(GC_REFCOUNT(&lt;span&gt;ref&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             zval_dtor_func(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (UNEXPECTED(GC_INFO(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         newRoot =&lt;span&gt; GC_G(unused);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;newRoot) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;GC_G(gc_full)) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 fprintf(stderr, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GC: no space to record new root candidate\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 GC_G(gc_full) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         GC_G(unused) = newRoot-&amp;gt;&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     GC_TRACE_SET_COLOR(&lt;span&gt;ref&lt;/span&gt;, GC_PURPLE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将插入的变量标为紫色，防止重复插入
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将该节点在buf数组中的位置保存到了gc_info中，当后续value的refcount变为了0，
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要将其从buf中删除时可以知道该value保存在哪个gc_root_buffer中&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     GC_INFO(&lt;span&gt;ref&lt;/span&gt;) = (newRoot - GC_G(buf)) |&lt;span&gt; GC_PURPLE; 
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     newRoot-&amp;gt;&lt;span&gt;ref&lt;/span&gt; = &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入roots链表头部&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     newRoot-&amp;gt;next =&lt;span&gt; GC_G(roots).next;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     newRoot-&amp;gt;prev = &amp;amp;&lt;span&gt;GC_G(roots);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     GC_G(roots).next-&amp;gt;prev =&lt;span&gt; newRoot;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     GC_G(roots).next =&lt;span&gt; newRoot;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    GC_BENCH_INC(zval_buffered);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    GC_BENCH_INC(root_buf_length);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    GC_BENCH_PEAK(root_buf_peak, root_buf_length);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;gc_possible_root&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;5.释放垃圾&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1163b70e-4d04-44d5-83da-5fc4bf13e2be')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1163b70e-4d04-44d5-83da-5fc4bf13e2be&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1163b70e-4d04-44d5-83da-5fc4bf13e2be&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1163b70e-4d04-44d5-83da-5fc4bf13e2be',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1163b70e-4d04-44d5-83da-5fc4bf13e2be&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; ZEND_API &lt;span&gt;int&lt;/span&gt; zend_gc_collect_cycles(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (GC_G(roots).next != &amp;amp;&lt;span&gt;GC_G(roots)) {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         gc_root_buffer *current, *next, *&lt;span&gt;orig_next_to_free;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         zend_refcounted *&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;        gc_root_buffer to_free;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         uint32_t gc_flags = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         gc_additional_buffer *&lt;span&gt;additional_buffer_snapshot;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        zend_bool orig_gc_full;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (GC_G(gc_active)) {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Collecting cycles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         GC_G(gc_runs)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Marking roots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        gc_mark_roots();
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scanning roots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        gc_scan_roots();
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 29&lt;/span&gt;         orig_gc_full =&lt;span&gt; GC_G(gc_full);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         GC_G(gc_full) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Collecting roots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         additional_buffer_snapshot =&lt;span&gt; GC_G(additional_buffer);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         count = gc_collect_roots(&amp;amp;&lt;span&gt;gc_flags);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 37&lt;/span&gt;         GC_G(gc_full) =&lt;span&gt; orig_gc_full;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (GC_G(to_free).next == &amp;amp;&lt;span&gt;GC_G(to_free)) {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; nothing to free &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;             GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nothing to free&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Copy global to_free list into local list &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         to_free.next =&lt;span&gt; GC_G(to_free).next;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         to_free.prev =&lt;span&gt; GC_G(to_free).prev;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         to_free.next-&amp;gt;prev = &amp;amp;&lt;span&gt;to_free;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         to_free.prev-&amp;gt;next = &amp;amp;&lt;span&gt;to_free;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free global list &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         GC_G(to_free).next = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         GC_G(to_free).prev = &amp;amp;&lt;span&gt;GC_G(to_free);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;         orig_next_to_free =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt; 60&lt;/span&gt;         orig_gc_full =&lt;span&gt; GC_G(gc_full);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         GC_G(gc_full) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (gc_flags &amp;amp;&lt;span&gt; GC_HAS_DESTRUCTORS) {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Calling destructors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remember reference counters before calling destructors &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;             current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 current-&amp;gt;refcount = GC_REFCOUNT(current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 current = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Call destructors &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;             current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 GC_G(next_to_free) = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (GC_TYPE(p) ==&lt;span&gt; IS_OBJECT) {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     zend_object *obj = (zend_object*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!(GC_FLAGS(obj) &amp;amp;&lt;span&gt; IS_OBJ_DESTRUCTOR_CALLED)) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         GC_TRACE_REF(obj, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calling destructor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                         GC_FLAGS(obj) |=&lt;span&gt; IS_OBJ_DESTRUCTOR_CALLED;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;dtor_obj
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                          &amp;amp;&amp;amp; (obj-&amp;gt;handlers-&amp;gt;dtor_obj !=&lt;span&gt; zend_objects_destroy_object
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                           || obj-&amp;gt;ce-&amp;gt;&lt;span&gt;destructor)) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                             GC_REFCOUNT(obj)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                             obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;dtor_obj(obj);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                             GC_REFCOUNT(obj)--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 current =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remove values captured in destructors &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 GC_G(next_to_free) = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (GC_REFCOUNT(current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;) &amp;gt; current-&amp;gt;&lt;span&gt;refcount) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     gc_remove_nested_data_from_buffer(current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;, current);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 current =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Destroy zvals &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Destroying zvals&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             GC_G(next_to_free) = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             GC_TRACE_REF(p, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destroying&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (GC_TYPE(p) ==&lt;span&gt; IS_OBJECT) {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 zend_object *obj = (zend_object*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;                 EG(objects_store).object_buckets[obj-&amp;gt;handle] =&lt;span&gt; SET_OBJ_INVALID(obj);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                 GC_TYPE(obj) =&lt;span&gt; IS_NULL;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!(GC_FLAGS(obj) &amp;amp;&lt;span&gt; IS_OBJ_FREE_CALLED)) {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                     GC_FLAGS(obj) |=&lt;span&gt; IS_OBJ_FREE_CALLED;
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;free_obj) {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                         GC_REFCOUNT(obj)++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                         obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;free_obj(obj);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                         GC_REFCOUNT(obj)--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                 SET_OBJ_BUCKET_NUMBER(EG(objects_store).object_buckets[obj-&amp;gt;&lt;span&gt;handle], EG(objects_store).free_list_head);
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 EG(objects_store).free_list_head = obj-&amp;gt;&lt;span&gt;handle;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                 p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt; = (zend_refcounted*)(((&lt;span&gt;char&lt;/span&gt;*)obj) - obj-&amp;gt;handlers-&amp;gt;&lt;span&gt;offset);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GC_TYPE(p) ==&lt;span&gt; IS_ARRAY) {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 zend_array *arr = (zend_array*&lt;span&gt;)p;
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;                 GC_TYPE(arr) =&lt;span&gt; IS_NULL;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; GC may destroy arrays with rc&amp;gt;1. This is valid and safe. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                HT_ALLOW_COW_VIOLATION(arr);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                zend_hash_destroy(arr);
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             current =&lt;span&gt; GC_G(next_to_free);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free objects &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         current =&lt;span&gt; to_free.next;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (current != &amp;amp;&lt;span&gt;to_free) {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             next = current-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             p = current-&amp;gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (EXPECTED(current &amp;gt;= GC_G(buf) &amp;amp;&amp;amp; current &amp;lt; GC_G(buf) +&lt;span&gt; GC_ROOT_BUFFER_MAX_ENTRIES)) {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                 current-&amp;gt;prev =&lt;span&gt; GC_G(unused);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                 GC_G(unused) =&lt;span&gt; current;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;            efree(p);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             current =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; 
&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (GC_G(additional_buffer) !=&lt;span&gt; additional_buffer_snapshot) {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             gc_additional_buffer *next = GC_G(additional_buffer)-&amp;gt;&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;            efree(GC_G(additional_buffer));
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             GC_G(additional_buffer) =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; 
&lt;span&gt;164&lt;/span&gt;         GC_TRACE(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Collection finished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         GC_G(collected) +=&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         GC_G(next_to_free) =&lt;span&gt; orig_next_to_free;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; ZEND_GC_DEBUG
&lt;span&gt;168&lt;/span&gt;         GC_G(gc_full) =&lt;span&gt; orig_gc_full;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt;         GC_G(gc_active) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;zend_gc_collect_cycles&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;PHP7内核剖析&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.030303030303&quot;&gt;
&lt;p&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;Jackson0714&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/jackson0714/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jackson0714/&lt;/a&gt;&lt;br/&gt;关于作者：专注于微软平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/jackson0714&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; onclick=&quot;votePost(5111347,'Digg')&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 02 Jul 2018 14:02:00 +0000</pubDate>
<dc:creator>jackson0714</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackson0714/p/php6.html</dc:identifier>
</item>
<item>
<title>一张脑图说清 Nginx 的主流程 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/9255975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/9255975.html</guid>
<description>&lt;p&gt;这个脑图在 &lt;a href=&quot;https://github.com/its-tech/nginx-1.14.0-research/tree/master/docs&quot;&gt;nginx-1.14.0-research&lt;/a&gt; 上。这是我在研究nginx的http模块的时候画的。基本上把 Nginx 主流程（特别是 HTTP 的部分）的关键函数和关键设置画了下来，了解了这个脑图，就对整个 Nginx 的主流程有了定性的了解了。&lt;/p&gt;
&lt;p&gt;Nginx 的启动过程分为两个部分，一个部分是读取配置文件，做配置文件中配置的一些事情（比如监听端口等）。第二个部分是形成 Master-Worker 的多进程模型。这两个过程就是 Nginx 代码中最重要的两个函数：&lt;code&gt;ngx_init_cycle&lt;/code&gt; 和 &lt;code&gt;ngx_master_process_cycle&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/29766630.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ngx_init_cycle 是 Nginx 中最重要的函数，没有之一。我们可以想想，如果我们写一个和 Nginx 一样的 Web 服务，我们会怎么做？我们大致的思路一定是解析配置文件，把配置文件存入到一个数据结构中，然后根据数据结构，进行端口监听。是的，差不多，Nginx 就是这么一个流程。不过 Nginx 里面有个模块的概念，所有的功能都是用模块的方式进行加载的。&lt;/p&gt;
&lt;h2 id=&quot;nginx-的模块&quot;&gt;Nginx 的模块&lt;/h2&gt;
&lt;p&gt;Nginx 的模块分为几类，这几类分别为 Core，Event，Conf，Http，Mail。看名字就知道 Core 模块是最重要的。模块是什么意思呢？它包含一堆命令（cmd）和命令对应的处理函数（cmd-&amp;gt;handler），我们根据配置文件中的配置（token）就知道这个配置是属于哪个模块的哪个命令，然后调用命令对应的处理函数来处理或者设置我们的服务。&lt;/p&gt;
&lt;p&gt;这几类模块中，Core 模块是 Nginx 启动的时候一定会加载的，其他的模块，只有在解析配置的时候，遇到了这个模块的命令，才会加载对应的模块。&lt;br/&gt;这个也是体现了 Nginx 按需加载的理念。（昨天还和小组成员讨论，如果我们写的话，可能就会先把所有模块都加载，然后根据配置文件进行匹配，这样可能 Nginx 的启动过程和进程资源就变大了）。&lt;/p&gt;
&lt;p&gt;模块的另一个问题是我这个 Nginx 最多有哪些模块的能力呢？这个是编译的时候就决定了，Nginx 的编译过程可以参考这篇&lt;a href=&quot;https://www.cnblogs.com/yjf512/p/9177562.html&quot;&gt;文章&lt;/a&gt; 。我们可以不用管./configure 的时候的具体内容，但是我们最关注的就是 &lt;code&gt;objs/ngx_modules.c&lt;/code&gt; 这个编译出来的文件，里面有个&lt;code&gt;ngx_modules&lt;/code&gt;全局变量，这个变量里面就存放了我们这次编译的 Nginx 最多可以支持的模块。&lt;/p&gt;
&lt;p&gt;模块的结构是我们需要关注的另外一个问题。 Nginx 中模块的结构叫做&lt;code&gt;ngx_module_s&lt;/code&gt;（你或许会看到&lt;code&gt;ngx_module_t&lt;/code&gt;，其实就是&lt;code&gt;struct ngx_moudle_s&lt;/code&gt;的缩写）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/26236212.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有个结构&lt;code&gt;*ctx&lt;/code&gt;，对于不同的模块类型，这个&lt;code&gt;ctx&lt;/code&gt;指向的结构是不一样的，我们这里最主要是研究 HTTP 类型的模块，所以我们就记得 HTTP 模块指向的结构是&lt;code&gt;ngx_http_module_t&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/79112482.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主流程&quot;&gt;主流程&lt;/h2&gt;
&lt;p&gt;了解了 Nginx 的模块概念，我们再回到&lt;code&gt;ngx_init_cycle&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/63307342.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数里面做了几个事情:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ngx_cycle_modules&lt;/code&gt;，它本质就是把&lt;code&gt;objs/ngx_modules.c&lt;/code&gt;里面的全局变量拷贝到&lt;code&gt;cycle&lt;/code&gt;这个全局变量里面&lt;/li&gt;
&lt;li&gt;调用了每个 Core 类型模块的&lt;code&gt;create_conf&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngx_conf_parse&lt;/code&gt; 解析配置文件，调用每个Core 类型模块的&lt;code&gt;init_conf&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;调用了每个 Core 类型模块的&lt;code&gt;init_conf&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngx_open_listening_sockets&lt;/code&gt; 打开配置文件中设置的监听端口和IP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ngx_init_modules&lt;/code&gt; 调用每个加载模块的&lt;code&gt;init_module&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;create_conf&lt;/code&gt;是创建一些模块需要初始化的结构，但是这个结构里面并没有具体的值。&lt;code&gt;init_conf&lt;/code&gt;是往这些初始化结构里面填写配置文件中解析出来的信息。&lt;/p&gt;
&lt;p&gt;其中的&lt;code&gt;ngx_conf_parse&lt;/code&gt;是真正解析配置文件的。&lt;/p&gt;
&lt;p&gt;在代码&lt;code&gt;ngx_open_listening_sockets&lt;/code&gt;里面我们看到熟悉的bind，listen的命令。所以 Nginx 是如何多个进程同时监听一个80端口的？本质是启动了一个master进程，在&lt;code&gt;ngx_init_cycle&lt;/code&gt;里面监听了端口，然后在&lt;code&gt;ngx_master_process_cycle&lt;/code&gt;里面 fork 出来多个 worker 子进程。&lt;/p&gt;
&lt;h2 id=&quot;ngx_conf_parse&quot;&gt;ngx_conf_parse&lt;/h2&gt;
&lt;p&gt;这个函数是非常非常重要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-6-29/56409966.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的逻辑，就是这两步，首先使用函数&lt;code&gt;ngx_conf_read_token&lt;/code&gt;先循环逐行逐字符查找，看匹配的字符，获取出&lt;code&gt;cmd&lt;/code&gt;, 然后去所有的模块查找对应的&lt;code&gt;cmd&lt;/code&gt;,调用那个查找后的&lt;code&gt;cmd-&amp;gt;set&lt;/code&gt;方法。用Http模块举例子，我们的配置文件中一定有且只有一个关键字叫http&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先解析这个配置的时候发现了&lt;code&gt;http&lt;/code&gt;这个关键字，然后去各个模块匹配，发现&lt;code&gt;ngx_http_module&lt;/code&gt;这个模块包含了&lt;code&gt;http&lt;/code&gt;命令。它对应的set方法是&lt;code&gt;ngx_http_block&lt;/code&gt;。这个方法就是http模块非常重要的方法了。当然，这里顺带提一下，event模块也有类似的方法，&lt;code&gt;ngx_events_block&lt;/code&gt;。它具体做的事情就是解析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;event epoll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的命令，并创建出事件驱动的模型。&lt;/p&gt;
&lt;h2 id=&quot;ngx_http_block&quot;&gt;ngx_http_block&lt;/h2&gt;
&lt;p&gt;这个函数是&lt;code&gt;http&lt;/code&gt;模块加载的时候最重要的函数，首先，它会遍历&lt;code&gt;modules.c&lt;/code&gt;中的所有 http 模块，还记得上文说的，HTTP 模块结构&lt;code&gt;ngx_module_s&lt;/code&gt;中的&lt;code&gt;**ctx&lt;/code&gt; 指向的是 &lt;code&gt;ngx_http_module&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-7-2/24841255.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一步模块对三个层级的回调&quot;&gt;第一步，模块对三个层级的回调&lt;/h3&gt;
&lt;p&gt;它内部有这个 HTTP 模块定义的，在各个层级（http，server，location）所需要加载回调的方法。&lt;/p&gt;
&lt;p&gt;我们这里再附带说一下 HTTP 的三个层级，这三个层级对应我们配置文件里面的三个不同的 Block 语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http {
  server {
    listen       80;
    location {
      root   html;
      index  index.html;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个层次里面的命令有可能会有重复，有冲突。比如，root这个命令，在 location 中可以有，在 server 中也可以有，如果赋值不一致的化，是上层覆盖下层，还是下层覆盖上层（当然大部分都是下层覆盖上层）。这个就在具体的模块定义的&lt;code&gt;ngx_http_module&lt;/code&gt;结构中定义了 &lt;code&gt;create_main_conf&lt;/code&gt;, &lt;code&gt;create_srv_conf&lt;/code&gt;,...,&lt;code&gt;merge_srv_conf&lt;/code&gt;等方法。这些方法的调用就是在&lt;code&gt;ngx_http_block&lt;/code&gt;方法的第一步进行调用的。&lt;/p&gt;
&lt;h3 id=&quot;第二步设置连接回调和请求监听回调&quot;&gt;第二步，设置连接回调和请求监听回调&lt;/h3&gt;
&lt;p&gt;第二步是调用方法&lt;code&gt;ngx_http_optimize_servers&lt;/code&gt;。它对配置文件中的所有listening的端口和IP进行监听设置。记住，这里只是进行回调的设置，具体的&lt;code&gt;listening&lt;/code&gt;和&lt;code&gt;binding&lt;/code&gt;操作不是在&lt;code&gt;ngx_conf_parse&lt;/code&gt;中，而是在&lt;code&gt;ngx_open_listening_sockets&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-7-2/69227664.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个XMind中有标注（xxx时候回调）的分支就是只有在事件回调的时候会进行调用，不是在&lt;code&gt;ngx_conf_parse&lt;/code&gt;的时候调用的。&lt;/p&gt;
&lt;p&gt;我们再仔细看看这个脑图中的流程，在conf_parse的时候，我实际上只对HTTP连接的时候设置了一个回调函数（ngx_http_init_connection）。在有HTTP连接上来的时候，才会设置读请求的回调（ngx_http_wait_request_handler）。在这个回调，才是真正的解析 HTTP 请求的请求头，请求体等。nginx 中著名的11阶段就是在这个地方进行一个个步骤进行调用的。&lt;/p&gt;
&lt;p&gt;这里说一下回调。nginx 是由各种各样的回调组合起来的。回调就需要要求有一个事件驱动机制。在nginx中，这个事件驱动机制也是一个模块，event 模块。在编译的时候，编译程序会判断你的系统支持哪些事件驱动，比如我的是centos，支持的是epoll，在配置文件配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;event epoll;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，就用这个epoll事件驱动监听IO事件。其他模块和事件驱动的交互就是通过&lt;code&gt;ngx_add_event&lt;/code&gt;进行事件监听和回调的。&lt;/p&gt;
&lt;p&gt;http请求由于可能请求体或者返回体比较大，所以不一定会在一个事件中完成，为了整体的 nginx 高效，http 模块在处理 http请求的时候，处理完成了一个event回调函数之后，如果没有处理完成整个HTTP，就会在event中继续注册一个回调，然后把处理权和资源都交给事件驱动中心。等待事件驱动下一次触发回调。&lt;/p&gt;
&lt;h3 id=&quot;第三步初始化定义-http-的11个处理阶段&quot;&gt;第三步，初始化定义 HTTP 的11个处理阶段&lt;/h3&gt;
&lt;p&gt;HTTP请求在nginx中会经过11个处理阶段和他们的checker方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NGX_HTTP_POST_READ_PHASE阶段（ngx_http_core_generic_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_SERVER_REWRITE_PHASE阶段（ngx_http_rewrite_handler）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_FIND_CONFIG_PHASE阶段（ngx_http_core_find_config_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_REWRITE_PHASE阶段（ngx_http_rewrite_handler）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_POST_REWRITE_PHASE阶段（ngx_http_core_post_rewrite_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_PREACCESS_PHASE阶段（ngx_http_core_generic_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_ACCESS_PHASE阶段（ngx_http_core_access_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_POST_ACCESS_PHASE阶段（ngx_http_core_post_access_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_TRY_FILES_PHASE阶段（ngx_http_core_try_files_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_CONTENT_PHASE阶段（ngx_http_core_content_phase）&lt;/li&gt;
&lt;li&gt;NGX_HTTP_LOG_PHASE阶段（ngx_http_log_module中的ngx_http_log_handler）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就像把大象放冰箱需要几步，处理 HTTP 需要11步，这11个步骤，有的是处理配置文件，有的是处理rewrite，有的是处理权限，有的是处理日志。所以，如果我们要自己开发一个http模块，我们就需要定义我们这个http模块处理http请求的这11个阶段（当然并不是这11个阶段都可以被自定义的，有的阶段是不能被自定义模块设置的）。然后当一个请求进来的时候，就按照顺序把请求经过所有模块的这11个阶段。&lt;/p&gt;
&lt;p&gt;这里所谓的经过这些11个阶段本质上就是调用他们的 checker 方法。这些checker方法除了最后一个 NGX_HTTP_LOG_NGX_HTTP_LOG_PAHSE 是在 ngx_http_log_module 里面之外，其他的都是在 http 的 core 模块中定义好了。&lt;/p&gt;
&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;
&lt;p&gt;这里其他的函数调用就没有特别需要注意的了。&lt;/p&gt;
&lt;h2 id=&quot;ngx_http_wait_request_handler&quot;&gt;ngx_http_wait_request_handler&lt;/h2&gt;
&lt;p&gt;我们继续跟着&lt;code&gt;ngx_http_optimize_servers&lt;/code&gt;,&lt;code&gt;ngx_http_init_listening&lt;/code&gt;,&lt;code&gt;ngx_http_add_listening&lt;/code&gt;,&lt;code&gt;ngx_http_init_connection&lt;/code&gt; 进入到处理http请求内容的函数里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-7-2/8260342.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数先调用recv将http请求的数据获取到，然后调用&lt;code&gt;ngx_http_create_request&lt;/code&gt;创建了 HTTP 的请求结构体。&lt;/p&gt;
&lt;p&gt;首先nginx处理的是HTTP的第一行，就是&lt;code&gt;HTTP 1.0 GET&lt;/code&gt;, 从这一行，HTTP 会获取到协议，方法等。接着再调用&lt;code&gt;ngx_http_process_request_line&lt;/code&gt;一行一行处理请求头。&lt;code&gt;ngx_http_read_request_header&lt;/code&gt;，&lt;code&gt;ngx_http_process_request_headers&lt;/code&gt;。处理完成 http header 头之后，&lt;code&gt;ngx_http_process_request&lt;/code&gt; 再接着进行后续的处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ngx_http_process_request&lt;/code&gt; 设置了读和写的handler，并且把监听事件从epoll事件驱动队列中拿出来（ngx_http_block_reading），就代表这个时候是阻塞做事件处理的事情。然后再调用&lt;code&gt;ngx_http_core_run_phases&lt;/code&gt;来让请求经过那11个阶段。&lt;/p&gt;
&lt;p&gt;其实并不是所有请求都需要读取整个HTTP请求体。比如你只是获取一个css文件，nginx在11个阶段中的配置读取阶段就不会再继续读取HTTP的body了。但是如果是一个fastcgi请求，在http_fastcgi的模块中，就会进入到NGX_HTTP_CONTENT_PHASE阶段，在这个阶段，它做的一个事情就是循环读取读缓存区的数据，直到读取完毕，然后进行处理，再返回结构。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 13:49:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/9255975.html</dc:identifier>
</item>
<item>
<title>Apollo 3 定时/长轮询拉取配置的设计 - 莫那-鲁道</title>
<link>http://www.cnblogs.com/stateis0/p/9255966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stateis0/p/9255966.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-b852957c3897832b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Apollo 基础模型&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;如上图所示，Apollo portal 更新配置后，进行轮询的客户端获取更新通知，然后再调用接口获取最新配置。不仅仅只有轮询，还有定时更新（默认 5 分钟一次）。目的就是让客户端能够稳定的获取到最新的配置。&lt;/p&gt;
&lt;p&gt;一起来看看他的设计。&lt;/p&gt;
&lt;h2 id=&quot;核心代码&quot;&gt;核心代码&lt;/h2&gt;
&lt;p&gt;具体的类是 &lt;code&gt;RemoteConfigRepository&lt;/code&gt;，每一个 Config —— 也就是 namespace 都有一个 RemoteConfigRepository 对象，表示这个 Config 的远程配置仓库，可以利用这个仓库请求远程服务，得到配置。&lt;/p&gt;
&lt;p&gt;RemoteConfigRepository 的构造方法需要一个 &lt;code&gt;namespace&lt;/code&gt; 字符串，表明这个 Repository 所属的 Config 名称。&lt;/p&gt;
&lt;p&gt;下面是该类的构造方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public RemoteConfigRepository(String namespace) {
    m_namespace = namespace;// Config 名称
    m_configCache = new AtomicReference&amp;lt;&amp;gt;(); //  Config 引用
    m_configUtil = ApolloInjector.getInstance(ConfigUtil.class);// 单例的 config 配置,存放 application.properties
    m_httpUtil = ApolloInjector.getInstance(HttpUtil.class);// HTTP 工具
    m_serviceLocator = ApolloInjector.getInstance(ConfigServiceLocator.class);// 远程服务 URL 更新类
    remoteConfigLongPollService = ApolloInjector.getInstance(RemoteConfigLongPollService.class);// 长轮询服务
    m_longPollServiceDto = new AtomicReference&amp;lt;&amp;gt;();// 长轮询发现的当前配置发生变化的服务
    m_remoteMessages = new AtomicReference&amp;lt;&amp;gt;();
    m_loadConfigRateLimiter = RateLimiter.create(m_configUtil.getLoadConfigQPS());// 限流器
    m_configNeedForceRefresh = new AtomicBoolean(true);// 是否强制刷新
    m_loadConfigFailSchedulePolicy = new ExponentialSchedulePolicy(m_configUtil.getOnErrorRetryInterval(),//1
        m_configUtil.getOnErrorRetryInterval() * 8);// 1 * 8;失败定时重试策略: 最小一秒,最大 8 秒.
    gson = new Gson();// json 序列化
    this.trySync(); // 第一次同步
    this.schedulePeriodicRefresh();// 定时刷新
    this.scheduleLongPollingRefresh();// 长轮询刷新
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在构造方法中，就执行了 3 个本地方法，其中就包括定时刷新和长轮询刷新。这两个功能在 apollo 的 github 文档中也有介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.客户端和服务端保持了一个长连接，从而能第一时间获得配置更新的推送。&lt;br/&gt;2.客户端还会定时从Apollo配置中心服务端拉取应用的最新配置。&lt;br/&gt;3.这是一个fallback机制，为了防止推送机制失效导致配置不更新。&lt;br/&gt;4.客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified。&lt;br/&gt;5.定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，长连接是更新配置的主要手段，然后用定时任务辅助长连接，防止长连接失败。&lt;/p&gt;
&lt;p&gt;那就看看长连接和定时任务的具体代码。&lt;/p&gt;
&lt;h2 id=&quot;定时任务&quot;&gt;定时任务&lt;/h2&gt;
&lt;p&gt;定时任务主要由一个单 core 的线程池维护这定时任务。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static {
    // 定时任务,单个 core. 后台线程
    m_executorService = Executors.newScheduledThreadPool(1,
        ApolloThreadFactory.create(&quot;RemoteConfigRepository&quot;, true));
}

private void schedulePeriodicRefresh() {
    // 默认 5 分钟同步一次.
    m_executorService.scheduleAtFixedRate(
        new Runnable() {
          @Override
          public void run() {
            trySync();
          }
        }, m_configUtil.getRefreshInterval(), m_configUtil.getRefreshInterval(),// 5
        m_configUtil.getRefreshIntervalTimeUnit());//单位：分钟
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体就是每 5 分钟执行 sync 方法。我简化了一下 sync 方法，一起看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected synchronized void sync() {
  ApolloConfig previous = m_configCache.get();
  // 加载远程配置
  ApolloConfig current = loadApolloConfig();

  //reference equals means HTTP 304
  if (previous != current) {
    m_configCache.set(current);
    // 触发监听器
    this.fireRepositoryChange(m_namespace, this.getConfig());
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，拿到上一个 config 对象的引用，然后，加载远程配置，判断是否相等，如果不相等，更新引用缓存，触发监听器。&lt;/p&gt;
&lt;p&gt;可以看出，关键是加载远程配置和触发监听器，这两个操作。&lt;/p&gt;
&lt;p&gt;loadApolloConfig 方法主要逻辑就是通过 HTTP 请求从 configService 服务里获取到配置。大概步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先限流。获取服务列表。然后根据是否有更新通知，决定此次重试几次，如果有更新，重试2次，反之一次。&lt;/li&gt;
&lt;li&gt;优先请求通知自己的 configService，如果失败了，就要进行休息，休息策略要看是否得到更新通知了，如果是，就休息一秒，否则按照 SchedulePolicy 策略来。&lt;/li&gt;
&lt;li&gt;拿到数据后，重置强制刷新状态和失败休息状态，返回配置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;触发监听器步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;循环远程仓库的监听器，调用他们的 onRepositoryChange 方法。其实就是 Config。&lt;/li&gt;
&lt;li&gt;然后，更新 Config 内部的引用，循环向线程池提交任务—— 执行 Config 监听器的 onChange 方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好，到这里，定时任务就算处理完了，总之就是调用 sync 方法，请求远程 configServer 服务，得到结果后，更新 Config 对象里的配置，并通知监听器。&lt;/p&gt;
&lt;p&gt;再来说说长轮询。&lt;/p&gt;
&lt;h2 id=&quot;长连接-长轮询&quot;&gt;长连接 / 长轮询&lt;/h2&gt;
&lt;p&gt;长轮询实际上就是在一个类似死循环里，不停请求 ConfigServer 的配置变化通知接口 notifications/v2，如果配置有变更，就会返回变更信息，然后向定时任务线程池提交一个任务，任务内容是执行 sync 方法。&lt;/p&gt;
&lt;p&gt;在请求 ConfigServer 的时候，ConfigServer 使用了 Servlet 3 的异步特性，将 hold 住连接 30 秒，等到有通知就立刻返回，这样能够实现一个基于 HTTP 的长连接。&lt;/p&gt;
&lt;p&gt;关于为什么使用 HTTP 长连接，初次接触 Apollo 的人都会疑惑，为什么使用这种方式，而不是&quot;那种&quot;方式？&lt;/p&gt;
&lt;p&gt;下面是作者宋顺的回复：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-fd8d97b7ee24aaa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么不使用消息系统？太复杂，杀鸡用牛刀。&lt;/li&gt;
&lt;li&gt;为什么不用 TCP 长连接？对网络环境要求高，容易推送失败。且有双写问题。&lt;/li&gt;
&lt;li&gt;为什么使用 HTTP 长轮询？性能足够，结合 Servlet3 的异步特性，能够维持万级连接（一个客户端只有一个长连接）。直接使用 Servlet 的 HTTP 协议，比单独用 TCP 连接方便。HTTP 请求/响应模式，保证了不会出现双写的情况。&lt;strong&gt;最主要还是简单，性能暂时不是瓶颈&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文没有贴很多的代码。因为不是一篇源码分析的文章。&lt;/p&gt;
&lt;p&gt;总之，Apollo 的更新配置设计就是通过定时轮询和长轮询进行组合而来。&lt;/p&gt;
&lt;p&gt;定时轮询负责调用获取配置接口，长轮询负责调用配置更新通知接口，长轮询得到结果后，将提交一个任务到定时轮询线程池里，执行同步操作——也就是调用获取配置接口。&lt;/p&gt;
&lt;p&gt;为什么使用 HTTP 长轮询？ 简单！简单！简单！&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 13:47:00 +0000</pubDate>
<dc:creator>莫那-鲁道</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stateis0/p/9255966.html</dc:identifier>
</item>
<item>
<title>从零开始学 Web 之 JS 高级（二）原型链，原型的继承 - Daotin</title>
<link>http://www.cnblogs.com/lvonve/p/9255350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvonve/p/9255350.html</guid>
<description>&lt;blockquote readability=&quot;6.9491150442478&quot;&gt;
&lt;p&gt;大家好，这里是「 从零开始学 Web 系列教程 」，并在下列地址同步更新......&lt;/p&gt;
&lt;p&gt;在这里我会从 Web 前端零基础开始，一步步学习 Web 相关的知识点，期间也会分享一些好玩的项目。现在就让我们一起进入 Web 前端学习的冒险之旅吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;原型链表示的是实例对象与原型对象之间的一种关系，这种关系是通过&lt;code&gt;__proto__&lt;/code&gt;原型来联系的。&lt;/p&gt;
&lt;h2 id=&quot;原型的指向改变&quot;&gt;1、原型的指向改变&lt;/h2&gt;
&lt;p&gt;实例对象的原型 &lt;code&gt;__proto__&lt;/code&gt; 指向的是该对象的构造函数中的原型对象 prototype，如果该对象的构造函数的 prototype 指向改变了，那么实例对象中的原型 &lt;code&gt;__proto__&lt;/code&gt; 的指向也会跟着改变。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Person.prototype = new Cat();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;因为 Person.prototype = {}； 可以是一个对象，所以传入另一个对象的实例函数是可以的，这时候 Person 的实例对象可以访问 Cat 原型 prototype 中的属性和方法，而不能再访问自己 Person 中原型的属性和方法了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;原型链的最终指向&quot;&gt;2、原型链的最终指向&lt;/h2&gt;
&lt;p&gt;实例对象的&lt;code&gt;__proto__&lt;/code&gt;指向的是构造函数的原型对象 prototype，由于prototype也是个对象，所以也有 &lt;code&gt;__proto__&lt;/code&gt; ，这个 &lt;code&gt;__proto__&lt;/code&gt; 指向的是 Object 的 prototype，而 Object 的 prototype 里面的 &lt;code&gt;__proto__&lt;/code&gt; 指向的是 null。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Person() {}
    var per = new Person();

    console.log(per.__proto__ === Person.prototype); // true
    console.log(Person.prototype.__proto__ === Object.prototype); // true
    console.log(Object.prototype.__proto__); // null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原型链图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201807/754332-20180702191108905-3791413.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原型指向改变后添加原型方法&quot;&gt;3、原型指向改变后添加原型方法&lt;/h2&gt;
&lt;p&gt;先看个案例：问下面程序有问题吗？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Person() {}
Person.prototype.eat = function () {};
function Student() {}
Student.prototype.say = function () {};
Student.prototype = new Person();

var stu = new  Student();
stu.say();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解答：stu.say(); 会报错。因为 Student 的原型指向变成了 Person 的一个实例对象，Person 的实例对象钟并没有 say 方法，所以报错。&lt;/p&gt;
&lt;p&gt;解决办法：在原型指向改变之后再添加原型方法。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Person() {}
Person.prototype.eat = function () {};
function Student() {}

Student.prototype = new Person();
Student.prototype.say = function () {};

var stu = new  Student();
stu.say();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：这个时候就不会报错， Student 添加的原型方法的位置是一个匿名 Person 的实例对象中，这里是一个 Person 的实例对象，不是所有的，所以当你再 new 一个 Person 的实例对象的时候，不会有 say 方法。&lt;/p&gt;
&lt;h2 id=&quot;实例对象和原型对象属性重名问题&quot;&gt;4、实例对象和原型对象属性重名问题&lt;/h2&gt;
&lt;p&gt;当实例对象访问一个属性的时候，会先从实例对象中找，找到了直接使用，找不到再到指向的原型对象中找，找到了使用，还是找不到，则为 undefined。&lt;/p&gt;
&lt;p&gt;如何改变原型对象中的属性的值呢？&lt;strong&gt;怎么赋值的怎么修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用 &lt;code&gt;对象.属性 = 值&lt;/code&gt; 的方式来赋值的话，如果这个属性在实例对象中有的话，改变的是实例对象中属性的值；如果实例对象中没有这个属性的话，则这次修改相当于给该实例对象添加了一个属性，其指向的原型对象中相应的属性的值并没有被改变。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;原型的继承&quot;&gt;1、原型的继承&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;原型的第二个作用：继承。目的也是节省内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过改变子类原型的指向到父类的实例对象，可以实现继承。&lt;/p&gt;
&lt;p&gt;案例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; // 父类：人
function Person(name, age) {
        this.name= name;
        this.age=age;
    }
    Person.prototype.eat = function () {
        console.log(&quot;eat()&quot;);
    };

    // 子类：学生
    function Student(sex) {
        this.sex=sex;
    }
    // 子类继承父类只需要改变子类原型的指向到父类的实例对象。
    Student.prototype = new Person(&quot;Daotin&quot;, 18); 
    Student.prototype.study = function () {
        console.log(&quot;study()&quot;);
    };

    var stu = new Student(&quot;male&quot;);
    console.log(stu.name); // Daotin
    console.log(stu.age); // 18
    stu.eat(); // eat()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缺陷1&lt;/strong&gt;：在改变子类原型对象的指向的时候，属性在初始化的时候就固定了，那么每个子类实例对象的值都固定了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：不需要子类原型的指向到父类的实例对象，只需要借用父类的构造函数。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    function Person(name, age) {
        this.name = name;
        this.age = age;
    }

    Person.prototype.eat = function () {
        console.log(&quot;eat()&quot;);
    };


    function Student(name, age, sex) {
        Person.call(this, name, age);
        this.sex = sex;
    }

    //Student.prototype = new Person(&quot;Daotin&quot;, 18);
    Student.prototype.study = function () {
        console.log(&quot;study()&quot;);
    };

    var stu = new Student(&quot;Daotin&quot;, 18, &quot;male&quot;);
    console.log(stu.name);
    console.log(stu.age);
    console.log(stu.sex);
    stu.eat(); // 不能访问&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;Person.call(this, name, age);&lt;/code&gt;第一个参数 this，表示当前对象，意思是当前对象呼叫 Person，将 name 和 age 传过来，具体传多少，我自己指定。这样不同的子类，通过自己可以设置不同的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;缺陷2&lt;/strong&gt;：&lt;code&gt;stu.eat();&lt;/code&gt;不能访问了，就是父类原型方法不能继承了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：&lt;strong&gt;组合继承（原型方式继承 + 借用构造函数继承）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    function Person(name, age) {
        this.name = name;
        this.age = age;
    }

    Person.prototype.eat = function () {
        console.log(&quot;eat()&quot;);
    };

    function Student(name, age, sex) {
        Person.call(this, name, age); // 借用父类构造函数，实现父类属性的继承
        this.sex = sex;
    }

    Student.prototype = new Person(); // 不传参数了，实现原型方法的继承
    Student.prototype.study = function () {
        console.log(&quot;study()&quot;);
    };

    var stu = new Student(&quot;Daotin&quot;, 18, &quot;male&quot;);
    console.log(stu.name);
    console.log(stu.age);
    console.log(stu.sex);
    stu.eat();
    stu.study();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;Student.prototype = new Person();&lt;/code&gt;// 不传参数了，实现原型方法的继承。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Person.call(this, name, age);&lt;/code&gt;// 借用父类构造函数，实现父类属性的继承。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;拷贝继承&quot;&gt;2、拷贝继承&lt;/h2&gt;
&lt;p&gt;就是把对象中需要共享的属性和方法直接以遍历的方式复制到了另一个对象中。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    function Person(name, age) {
        this.name = name;
        this.age = age;
    }

    Person.prototype.eat = function () {
        console.log(&quot;eat()&quot;);
    };

    var per = {};

    // 循环拷贝
    for(var key in Person.prototype) {
        per[key] = Person.prototype[key];
    }
    console.log(per);&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;函数的声明和函数表达式的区别&quot;&gt;1、函数的声明和函数表达式的区别&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 函数的声明
    if(true) {
        function f1() {
            console.log(&quot;f1()--1&quot;);
        }
    } else {
        function f1() {
            console.log(&quot;f1()--2&quot;);
        }
    }
    f1();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;函数声明如果放在 if-else- 里面，chrome 和 firefox 输出 f1()--1,IE8 下输出 f1()--2，因为函数声明会提前，第二个将第一个覆盖了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 函数表达式
    var func;
    if(true) {
        func = function () {
            console.log(&quot;f1()--1&quot;);
        };
    } else {
        func = function () {
            console.log(&quot;f1()--2&quot;);
        };
    }
    func();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;函数表达式的方式，输出都是 f1()--1。所以尽量使用函数表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;严格模式&quot;&gt;2、严格模式&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function func() {
  console.log(this) // window
}
func(); &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正常情况下是证正确的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
function func() {
  console.log(this) // window
}
window.func(); // 严格模式下必须加 window，因为他认为函数是一个方法，方法必须通过对象来调用的。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.1、函数也是对象，对象不一定是函数（比如：Math）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要有 &lt;code&gt;__proto__&lt;/code&gt; 的就是对象；&lt;/p&gt;
&lt;p&gt;只有要 &lt;code&gt;prototype&lt;/code&gt; 的就是函数，因为函数才会调用 prototype 属性。&lt;/p&gt;
&lt;p&gt;对象不一定是函数：比如 Math，中有 &lt;code&gt;__proto__&lt;/code&gt; ，但是没有 &lt;code&gt;prototype&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2、所有的函数都是由 Function 构造函数创建的实例对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然函数是对象，那么是什么构造函数创建的呢？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var f1 = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a+b&quot;);
f1(1,2);

// 上面相当于：函数的声明
function f1(a, b) {
  return a+b;
}
f1(1,2);

// 相当于：函数表达式
var f1 = function (a, b) {
  return a+b;
}
f1(1,2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么 Function 是个什么东西呢？&lt;/p&gt;
&lt;p&gt;经查看是对象也是函数？然后查看它的 &lt;code&gt;__proto__&lt;/code&gt; 指向的是 Object的原型对象。所有的对象指向的都是Object的原型对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/wx.jpg&quot; alt=&quot;Web前端之巅&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 11:12:00 +0000</pubDate>
<dc:creator>Daotin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvonve/p/9255350.html</dc:identifier>
</item>
<item>
<title>关于RecyclerView你知道的不知道的都在这了（下） - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9255335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9255335.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。&lt;/p&gt;
&lt;p&gt;另外，由于有些平台可能不支持 `` 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LayoutManager&lt;/strong&gt;&lt;/p&gt;
1.1 &lt;strong&gt;LinearLayoutManager&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;findFirstCompletelyVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findFirstVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findLastCompletelyVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;findLastVisibleItemPosition()&lt;/li&gt;
&lt;li&gt;setRecycleChildrenOnDetach()&lt;/li&gt;
&lt;/ul&gt;
1.2 &lt;strong&gt;GridLayoutManager&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;setSpanSizeLookUp()&lt;/li&gt;
&lt;/ul&gt;
1.3 &lt;strong&gt;StaggeredGridLayoutManager&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;基本效果介绍&lt;/li&gt;
&lt;li&gt;setFullSpan()&lt;/li&gt;
&lt;li&gt;findXXX() 系列方法介绍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ViewHolder&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;getAdapterPosition()&lt;/li&gt;
&lt;li&gt;getLayoutPosition()&lt;/li&gt;
&lt;li&gt;setIsRecyclable()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LayoutParams&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Adapter&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本用法介绍&lt;/li&gt;
&lt;li&gt;onViewRecycled()&lt;/li&gt;
&lt;li&gt;onViewAttachedFromWindow()&lt;/li&gt;
&lt;li&gt;onViewDetachedFromWindow()&lt;/li&gt;
&lt;li&gt;onAttachedToRecyclerView()&lt;/li&gt;
&lt;li&gt;onDetachedFromRecyclerView()&lt;/li&gt;
&lt;li&gt;registerAdapterDataObserver()&lt;/li&gt;
&lt;li&gt;unregisterAdapterDataObserver()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RecyclerView&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;addOnItemTouchListener()&lt;/li&gt;
&lt;li&gt;addOnScrollListener()&lt;/li&gt;
&lt;li&gt;setHasFixedSize()&lt;/li&gt;
&lt;li&gt;setLayoutFrozen()&lt;/li&gt;
&lt;li&gt;setPreserveFocusAfterLayout()&lt;/li&gt;
&lt;li&gt;findChildViewUnder()&lt;/li&gt;
&lt;li&gt;findContainingItemView()&lt;/li&gt;
&lt;li&gt;findContainingViewHolder()&lt;/li&gt;
&lt;li&gt;findViewHolderXXX()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Recycler&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setItemViewCacheSize()&lt;/li&gt;
&lt;li&gt;setViewCacheExtension()&lt;/li&gt;
&lt;li&gt;setRecycledViewPool()&lt;/li&gt;
&lt;li&gt;setRecyclerListener()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ItemAnimator&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7.1 &lt;strong&gt;SimpleItemAnimator&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7.2 &lt;strong&gt;DefaultItemAnimator&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ItemDecoration&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8.1 &lt;strong&gt;DividerItemDecoration&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8.2 &lt;strong&gt;ItemTouchHelper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8.3 &lt;strong&gt;FastScroller&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OnFlingListener&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;9.1 &lt;strong&gt;SnapHelper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;9.2 &lt;strong&gt;LinearSnapHelper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;9.3 &lt;strong&gt;PagerSnapHelper&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;阅读须知：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本篇力求列举 RecyclerView 所有功能的使用示例，由于篇幅原因，并不会将实现代码全部贴出，只贴出关键部分的代码。&lt;/li&gt;
&lt;li&gt;本篇所使用的 RecyclerView 的版本是 26.0.0。&lt;/li&gt;
&lt;li&gt;下列标题中，但凡是斜体字，表示该知识点目前暂时没理清楚，留待后续继续补充。&lt;/li&gt;
&lt;li&gt;第 1 章至第 5 章节内容在上一篇中：&lt;a href=&quot;https://www.jianshu.com/p/aff499a5953c&quot;&gt;关于RecyclerView你知道的不知道的都在这了（上）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;recycler&quot;&gt;6. Recycler&lt;/h3&gt;
&lt;p&gt;Recycler 是 RecyclerView 的一个内部类，主要职责就是处理回收复用相关工作的。&lt;/p&gt;
&lt;p&gt;回收复用的单位是 ViewHolder，至于 Item 移出屏幕是怎样回收，回收到哪里，Item 移进屏幕时是怎样复用，整个流程是先复用再回收，还是先回收再复用，还是两边同时进行等等一系列的工作都是交由 Recycler 来处理。&lt;/p&gt;
&lt;p&gt;关于回收复用机制的部分原理，之前已经梳理过一篇文章了：&lt;a href=&quot;https://www.jianshu.com/p/9306b365da57&quot;&gt;基于滑动场景解析RecyclerView的回收复用机制原理&lt;/a&gt;，感兴趣的可以先去看看。&lt;/p&gt;
&lt;p&gt;本篇侧重点是介绍各个接口的含义和使用场景，至于回收复用机制，后续肯定还会继续深入去分析，敬请期待。&lt;/p&gt;
&lt;h4 id=&quot;setitemviewcachesize&quot;&gt;6.1 setItemViewCacheSize()&lt;/h4&gt;
&lt;p&gt;有看到上面链接那篇文章的应该就清楚，当 item 被移出屏幕外时，其实这个 item 的 ViewHolder 会被回收掉，而 Recycler 里有一种分级缓存的概念。&lt;/p&gt;
&lt;p&gt;分级缓存，说得白点，就是不同的容器，容器之间有优先级，回收时先将 ViewHolder 缓存到高优先级的容器中，容器满了的话，那就将容器腾出个位置来，被腾出来的 ViewHolder 这时就可以放到优先级较低的容器中。分级缓存的概念就是这样。&lt;/p&gt;
&lt;p&gt;移出屏幕的 ViewHolder 会被缓存到两个容器中，按优先级高到低分别是：&lt;strong&gt;mCachedViews&lt;/strong&gt; 和 &lt;strong&gt;mRecyclerPool&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方法就是用于设置 &lt;strong&gt;mCachedViews&lt;/strong&gt; 容器的大小，默认值为 2，可通过该方法随时改变缓存容器的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;要搞清楚应用场景，那得先明白 &lt;strong&gt;mCachedViews&lt;/strong&gt; 这一级的缓存有什么作用，建议还是到上面给出的链接的那篇文章看一看，就明白了。&lt;/p&gt;
&lt;p&gt;这里大概说一下，个人对于 &lt;strong&gt;mCachedViews&lt;/strong&gt; 这一级缓存的理解：这一级的缓存仅仅就只是用来缓存而已，里面存储的 ViewHolder 并没有通用的能力。换句话说也就是，只有原来位置的 Item 可复用这级容器里的 ViewHolder，其他位置的 Item 没办法使用。效果就好像是 ViewPager 之类的缓存一样，所以我才说它仅仅只有缓存的功能。&lt;/p&gt;
&lt;p&gt;这样能达到的效果就是：当某个 Item 刚被移出屏幕外，下一步又立马移进屏幕时，此时并不会去触发到 Adapter 的 onBindXXX 的调用，也就是说，这一级缓存里的 ViewHolder 可直接 addView 到 RecyclerView 上面，不需要重新去设置数据，因为它原本携带的数据都还处于正常状态，并没有被重置掉。&lt;/p&gt;
&lt;h4 id=&quot;setviewcacheextension&quot;&gt;6.2 setViewCacheExtension()&lt;/h4&gt;
&lt;p&gt;当 Item 要被移进屏幕时，Recycler 会先去那些不需要重新调用 onBindViewHolder() 的缓存容器中寻找是否有可直接复用的 Item，如果没找到，那么会接着调用开发者自定义扩展的复用工作，如果在这里也没找到，那么才会去 RecyclerViewPool 中根据 type 来寻找可复用的，再没找到最后就直接调用 onCreateViewHolder() 新建一个来使用。&lt;/p&gt;
&lt;p&gt;先来看看开发者要怎么自定义扩展：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 我删了一些注释，留下一些困惑的点
 * 1. Note that, Recycler never sends Views to this method to be cached. It is developers
 * responsibility to decide whether they want to keep their Views in this custom cache
 * or let the default recycling policy handle it.
 */
public abstract static class ViewCacheExtension {
    /**
     * 2.This method should not create a new View. Instead, it is expected to return
     * an already created View that can be re-used for the given type and position.
     */
    public abstract View getViewForPositionAndType(Recycler recycler, int position, int type);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看着好像很简单是吧，就只需要实现一个方法，返回指定 position 和 type 下的 Item 的 View 即可，网上所有分析到回收复用机制时也全部都是这么一笔带过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但实际上，存在很多困惑点，这个到底该怎么用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注释 1 里说了，Recycler 永远也不会将 ItemView 发送到这个类里来缓存，然后还说由开发者自行决定是要自己维护这些缓存还说交由 Recycler 来处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;困惑1：&lt;/strong&gt;交由 Recycler 来处理我能理解，毕竟 Recycler 只在复用的过程中开了个接口给开发者扩展使用，但回收的过程并没有开任何接口给开发者扩展。也正是基于这点，我就不理解官方说的让开发者自行维护，怎么维护？&lt;/p&gt;
&lt;p&gt;注释 2 中，官方告诉我们在这个方法中，不要去新建一个新的 ItemView，而是直接从旧的里面拿一个复用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;困惑2：&lt;/strong&gt;我又不知道怎么自己去维护 ViewHolder，那不新建一个 ItemView 又该如何使用，直接借助 Recycler？但 Recycler 不是只开放了 getViewForPosition()？本来内部在复用时就是自己调了这个方法，我们在这个方法内部走到开发者扩展自定义扩展的流程时再重新调一下？那不是就陷入嵌套循环里了？有什么意义或者应用场景么？&lt;/p&gt;
&lt;p&gt;最最困惑的一点，国内居然找不到任何一篇讲解如何使用这个自定义缓存的相关文章！？&lt;/p&gt;
&lt;p&gt;不清楚是由于他们文章的标题太过抽象没加入我的关键词过滤中，还是我关键词提取太烂，总之就是找不到任何一篇相关文章。所以，这小节先埋个坑，我打算后续抽时间自己来研究一下，到底应该如何使用自定义 RecyclerView 的缓存策略，到底都有哪些应用场景。&lt;/p&gt;
&lt;h4 id=&quot;setrecycledviewpool&quot;&gt;6.3 setRecycledViewPool()&lt;/h4&gt;
&lt;p&gt;最后一级缓存就是 RecyclerViewPool，这个容器有三个特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存到 RecyclerViewPool 中的 ViewHolder，携带的信息都会被重置，因此从这个容器中取 ViewHolder 去复用时，都会触发 &lt;code&gt;onBindViewHolder()&lt;/code&gt; 重新绑定数据。&lt;/li&gt;
&lt;li&gt;多个 RecyclerView 可共用同一个 RecyclerViewPool 容器。&lt;/li&gt;
&lt;li&gt;该容器以 Item 的 type 区分缓存，每种 type 的默认存储容量为 5。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般当我们需要修改这个缓存容器的大小，或者需要设置多个 RecyclerView 共用一个 RecyclerViewPool 时才需要调用到该方法。并且，官方在注释中也给出一种应用场景：使用 ViewPager 时各页面中的 RecyclerView 有相同的 Item 布局结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来举个例子，就不用官方给的例子了，我额外补充一种场景：界面上存在多行可分别左右滑动的列表控件，即每行是一个 RecyclerView，每行里的 Item 布局样式一致，这时候就可以让每一行的 RecyclerView 共用一个 RecyclerViewPool 缓存池了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-9e528ee638e837a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;多行可局部滑动.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上布局的实现是外层一个竖直方向的 RecyclerView，它的每一个 Item 都是占据一行的水平方向的 RecyclerView，也就是嵌套 RecyclerView 的方式，实现可上下滑动且每一行均可左右滑动的效果。&lt;/p&gt;
&lt;p&gt;这里的每一行的 RecyclerView 里的每个 Item 项的样式均一致，那么这种场景下，可以让每一行的 RecyclerView 都共用同一个 RecyclerViewPool 缓存池。这样的好处是，当某一行被移出屏幕时，可以将这一行的每个卡位都回收起来，供其他行使用，而不至于每一行每次都是重新创建。&lt;/p&gt;
&lt;p&gt;但有些&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外层 RecyclerView 缓存复用的应该仅仅是每一行的 RecyclerView 控件而已，不应该包括每一行 RecyclerView 内部的卡位控件，因为各行卡位的个数并不一定相同。&lt;/li&gt;
&lt;li&gt;对于外层 RecyclerView 来说，它的 Item 是每一行的 RecyclerView 控件，所以当某一行被移出屏幕时，它仅仅是将这一行的 RecyclerView 控件从它本身 remove 掉，并回收起来。因此，此时这一行的 RecyclerView 还是携带着它的卡位子 View 的，所以需要我们手动去将这些卡位回收、并从父控件上 remove 掉。&lt;/li&gt;
&lt;li&gt;这个操作可以在外层 RecyclerView 的 adapter 的 &lt;code&gt;onViewRecycled()&lt;/code&gt; 回调中进行，也可以在内层每个 RecyclerView 的 adapter 的 &lt;code&gt;onViewDetachedFromWindow()&lt;/code&gt; 回调中进行。&lt;/li&gt;
&lt;li&gt;移除并回收卡位可通过 &lt;code&gt;setAdapter(null)&lt;/code&gt; 配合 RecyclerView 本身的 &lt;code&gt;removeAllView()&lt;/code&gt; 或者 LayoutManager 的 &lt;code&gt;removeAllView()&lt;/code&gt; 实现 。或者直接使用 LinearLayoutManager 的 &lt;code&gt;setRecycleChildrenOnDetach()&lt;/code&gt; 功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;setrecyclerlistener&quot;&gt;6.4 setRecyclerListener()&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//RecyclerView$Recycler#
void dispatchViewRecycled(ViewHolder holder) {
    if (mRecyclerListener != null) {
        mRecyclerListener.onViewRecycled(holder);
    }
    if (mAdapter != null) {
        mAdapter.onViewRecycled(holder);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，这个方法设置的监听 Item 的回收，回调的时机跟 adapter 的 onViewRecycled() 一模一样，都是在 mCachedViews 容器满了之后，放入 RecyclerViewPool 之前被回调。&lt;/p&gt;
&lt;h3 id=&quot;itemanimator&quot;&gt;7. ItemAnimator&lt;/h3&gt;
&lt;p&gt;RecyclerView 是支持对每个 item 做各种各样动画的，那么什么时候才该去执行这些 item 动画呢？说白了，也就是 adapter 数据源发生变化的时候，那么变化的方式无外乎就是四种：add, remove, change, move。相对应的，也就是这些状态时的 item 动画。&lt;/p&gt;
&lt;p&gt;所以当要自定义实现 ItemAnimator 时，需要实现的方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);  
public abstract boolean animateDisappearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);
public abstract boolean animatePersistence(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);
public abstract boolean animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);
public abstract void runPendingAnimations();
public abstract void endAnimation(ViewHolder item);
public abstract void endAnimations();
public abstract boolean isRunning();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来，要实现一个自定义的 Item 好像很复杂，要实现这么多方法。网上这方面的文章已经非常多了，也都跟你说清了每个方法的含义是什么，在这里写些什么，甚至流程都帮你列出来了。&lt;/p&gt;
&lt;p&gt;但大伙会不会好奇，这帮牛人是咋这么清楚的呢？&lt;/p&gt;
&lt;p&gt;其实，Google 内部已经封装好了一个默认动画的实现，有时间大伙可以自己过一下源码，看看默认动画是怎么做的，理解清楚了后，举一反三下，其实也就懂了。&lt;/p&gt;
&lt;p&gt;我目前也不懂，但我就是带着这么一种想法，也是打算这么去做的。虽然跟着大神的文章，最后确实能实现想要的效果，但其实掌握并不是很牢，并不大清楚为什么需要这么写，只是因为大神说这里这么写，然后就这么写了。&lt;/p&gt;
&lt;p&gt;所以，有时间有精力，还是建议深入源码中去学习，自己梳理出来的知识终归是自己的。&lt;/p&gt;
&lt;h4 id=&quot;simpleitemanimator&quot;&gt;7.1 SimpleItemAnimator&lt;/h4&gt;
&lt;p&gt;当 adapter 数据源发生变化，通知了 RecyclerView 去刷新界面时，RecyclerView 会去通知 ItemAnimaotr 此时相应的动画行为。&lt;/p&gt;
&lt;p&gt;比如 add 了一个 Item，那么就会去触发 ItemAnimator 的 &lt;code&gt;animateAppearance()&lt;/code&gt; 方法，并将这个 ItemView 在刷新前后不同的信息，如默认携带的信息是 RecyclerView 内部类 ItemHolderInfo，这个类里有关于这个 Item 的坐标信息。&lt;/p&gt;
&lt;p&gt;那么，开发者就可以在这些回调方法里自行判断刷新前后的 Item 的不同信息来决定是否需要进行相对应的动画。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而 SimpleItemAnimator 其实就是帮忙处理这件事，也就是说，它在四个回调中，如 &lt;code&gt;animateAppearance()&lt;/code&gt; 中，根据 Item 前后的坐标信息来判断该 Item 需要进行的动画类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;animateAppearance()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo) {
    if (preLayoutInfo != null &amp;amp;&amp;amp; (preLayoutInfo.left != postLayoutInfo.left
        || preLayoutInfo.top != postLayoutInfo.top)) {
         // slide items in if before/after locations differ
         return animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top,
                postLayoutInfo.left, postLayoutInfo.top);
    } else {
         return animateAdd(viewHolder);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于 RecyclerView 回调了 &lt;code&gt;animateAppearance()&lt;/code&gt; 方法后，SimpleItemAnimator 内部对其进行的分类，根据参数判断，最终是要执行 &lt;code&gt;animateMove()&lt;/code&gt; 类型的动画，还是执行 &lt;code&gt;animateAdd()&lt;/code&gt; 类型的动画。&lt;/p&gt;
&lt;p&gt;同理，对于另外三个回调方法，SimpleItemAnimator 内部同样对其进行了封装处理，简单的通过刷新前后 Item 的坐标信息来进行动画类型的区分。&lt;/p&gt;
&lt;p&gt;所以，这个类并没有实现任何动画的逻辑，它只是将动画的准备工作做好，简化开发者开发。所以，如果想要自定义 ItemAnimator，其实没必要从零开始继承自 ItemAnimator 自己写，是可以借助 SimpleItemAnimator 这个类的。&lt;/p&gt;
&lt;h4 id=&quot;defaultitemanimator&quot;&gt;7.2 DefaultItemAnimator&lt;/h4&gt;
&lt;p&gt;RecyclerView 默认有提供 Item 的动画，而 SimpleItemAnimator 只是处理跟动画无关的准备工作，那么具体的默认动画的实现就是在 DefaultItemAnimator 这个类中实现的了。&lt;/p&gt;
&lt;p&gt;先看一下这个类的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-06de56724562ea79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DefaultItemAnimagtor结构.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它是继承自 SimpleItemAnimator 的，我们如果想要自定义实现一些 Item 动画，需要写的东西，大概就跟上图类似。&lt;/p&gt;
&lt;p&gt;想要自定义 Item 动画，真的可以来参考、借鉴这个类的实现，能学到的东西很多。&lt;/p&gt;
&lt;p&gt;我也还没深入去仔细学习，大概过了一眼，这里就大概说下：&lt;/p&gt;
&lt;p&gt;这个类用了很多集合来维护各种不同类型的动画，在四个 &lt;code&gt;animateXXX()&lt;/code&gt; 方法中通过集合记录相对应类型的动画和做了动画的初始化工作。&lt;/p&gt;
&lt;p&gt;然后在 &lt;code&gt;runPendingAnimations()&lt;/code&gt; 方法中，依次遍历这些集合，将记录的动画取出来执行，动画的实现方式是通过 &lt;code&gt;View.animate()&lt;/code&gt; 方式实现，这种方式的动画本质上是借助了 ValueAnimator 机制，在每帧的回调过程中手动调用 &lt;code&gt;setXXX()&lt;/code&gt; 来实现的动画效果。具体分析可参考我之前写的一篇文章：&lt;a href=&quot;https://www.jianshu.com/p/b43cf452afc1&quot;&gt;View.animate()动画ViewPropertyAnimator原理解析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大体上的流程原理就是这样，当然，这个类做的事肯定不止这些，还包括了集合的清理维护工作，动画的维护等等，所以很值得去借鉴学习一番。但这里就只给出大概的流程，本篇重点不在这里。&lt;/p&gt;
&lt;p&gt;下面就来列举下，默认实现的各类型的动画分别是什么：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;animateAdd&lt;/strong&gt; -&amp;gt; 透明度 0 ~ 1 的动画，默认动画时长 120 ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;animateChange&lt;/strong&gt; -&amp;gt; 涉及两个 ItemView，旧的跟新的，默认动画时长 250ms&lt;/p&gt;
&lt;p&gt;旧 ItemView：透明度从原有值 ~ 0，位置从原坐标移动到新 ItemView 坐标的动画组合&lt;/p&gt;
&lt;p&gt;新 ItemView：透明度从 0 ~ 1，位置从旧 ItemView 坐标移动到新坐标的动画组合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;animateMove&lt;/strong&gt; -&amp;gt; 从原坐标位置移动到新坐标位置的移动动画，默认动画时长 250 ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;animateRemove&lt;/strong&gt; -&amp;gt; 从原有透明度 ~ 0 的动画，默认动画时长 120 ms&lt;/p&gt;
&lt;p&gt;所以，RecyclerView 默认的 Item 动画其实也就透明度和移动动画两种，而且大多数情况下都只是单一的动画，只有 change 类型时才会是组合动画。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，可通过下列方式修改动画时长，这里将动画时长延长，方便查看效果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mRecyclerView.getItemAnimator().setAddDuration(1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-baf6b6217218ae9f.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;20180702_162126.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，动画基本就只有透明度动画跟移动动画两种。&lt;/p&gt;
&lt;p&gt;另外，只有通过 &lt;code&gt;notifyItemXXX()&lt;/code&gt; 方式更新数据源时才会触发动画行为，如果是通过 &lt;code&gt;notifyDataSetChange()&lt;/code&gt; 方式，则不会触发动画。&lt;/p&gt;
&lt;h3 id=&quot;itemdecoration&quot;&gt;8. ItemDecoration&lt;/h3&gt;
&lt;p&gt;RecyclerView 支持为每个 Item 之间自定义间隔样式，是要空段距离，还是要以分割线隔开，还是要唯美唯幻的边框，想长啥样都行，自己写得出来就可以了，它给我们提供了这个接口。&lt;/p&gt;
&lt;p&gt;本节就先介绍下系统内置的几种样式，内置里一共有三个类继承该类，分别是 DividerItemDecoration，ItemTouchHelper，FastScroller。前两个都是 public 权限，最后一个包权限，下面分别看看它们都有哪些效果，最后再来看看如何自定义。&lt;/p&gt;
&lt;h4 id=&quot;divideritemdecoration&quot;&gt;8.1 DividerItemDecoration&lt;/h4&gt;
&lt;p&gt;看一下这个类的注释：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * DividerItemDecoration is a {@link RecyclerView.ItemDecoration} that can be used as a divider
 * between items of a {@link LinearLayoutManager}. It supports both {@link #HORIZONTAL} and
 * {@link #VERTICAL} orientations.
 * &amp;lt;pre&amp;gt;
 *     mDividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(),
 *             mLayoutManager.getOrientation());
 *     recyclerView.addItemDecoration(mDividerItemDecoration);
 * &amp;lt;/pre&amp;gt;
 */
public class DividerItemDecoration extends RecyclerView.ItemDecoration {
    /**
     * Sets the {@link Drawable} for this divider.
     *
     * @param drawable Drawable that should be used as a divider.
     */
    public void setDrawable(@NonNull Drawable drawable) {
        if (drawable == null) {
            throw new IllegalArgumentException(&quot;Drawable cannot be null.&quot;);
        }
        mDivider = drawable;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;怎么用，类注释也给我们示例了，有点可惜的是，它只能用于 LinearLayoutManager 这种布局，而 GridLayoutManager 继承自 LinearLayoutManager，所以它也可以用，但需要注意的是，它只有一个方向会生效。来看看如何使用和效果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DividerItemDecoration itemDecoration = new DividerItemDecoration(mContext, LinearLayoutManager.HORIZONTAL);
itemDecoration.setDrawable(getResources().getDrawable(R.drawable.divider_space));
mRecyclerView.addItemDecoration(itemDecoration);

//R.drawable.divider_space
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;
    &amp;lt;size android:width=&quot;20dp&quot; android:height=&quot;20dp&quot;/&amp;gt;
&amp;lt;/shape&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在 xml 中写宽度为 20dp 的空隙，然后调用 &lt;code&gt;setDrawable()&lt;/code&gt; 应用，看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-02ae65a7f2cce81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;空隙示例.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就可以达到将 item 隔离开的效果了，中间这个空隙的样式你可以自己通过 xml 写，也可以直接使用图片，都可以，只要是 Drawable 类型的即可。&lt;/p&gt;
&lt;p&gt;虽然说，RecyclerView 不像 ListView 只要设置个属性就可以达到设置 Item 之间空隙的样式，但它也内置了基本的实现，其实也已经方便了我们的使用。&lt;/p&gt;
&lt;h4 id=&quot;itemtouchhelper&quot;&gt;8.2 &lt;em&gt;ItemTouchHelper&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;这是一个工具类，也是 Google 为了方便开发人员实现 item 的拖拽和移动等等效果所提供的一个辅助工具类。借助这个类可以很容易实现 item 的侧滑删除、长按拖拽等功能。&lt;/p&gt;
&lt;p&gt;由于这部分我没有研究过，日常也较少接触，所以暂时先从网上搜索一篇文章，以下的效果图来自大神的博客，会给出链接，侵权删。后续有接触相关需求时再自行来研究一番。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wuyuxing24/article/details/78985026&quot;&gt;推荐博客： ItemTouchHelper源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-470540d87bab3787.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;20180105202851329.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-36ecbcb6385c86cc.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;20180105202823469.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;fastscroller&quot;&gt;8.3 &lt;em&gt;FastScroller&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;这个类也是继承自 ItemDecoration，但它的类权限只是包权限，不开放给外部使用，稍微看了下注释，说是用来处理动画以及快速滑动相关的支持，具体原理是什么，如何生效，留待后续深入研究时再来分析。&lt;/p&gt;
&lt;h4 id=&quot;自定义itemdecoration&quot;&gt;8.4 自定义ItemDecoration&lt;/h4&gt;
&lt;p&gt;上面说过系统默认提供的 DividerItemDecoration 只支持用于 LinearLayoutManager，而如果用于 GridLayoutManager 时，只有一个方向会生效，那么下面我们就以 GridLayoutManager 为例，来看看，如何自定义写 ItemDecoration。&lt;/p&gt;
&lt;p&gt;用 GridLayoutManager 实现一个四列的布局，然后让除了四个边的 Item 外，内部的每个 Item 之间相互间隔 20 dp 的空隙。为了能更明显看出，将 20dp 的空隙用红色绘制出来。&lt;/p&gt;
&lt;p&gt;先来看下效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4 列布局 &amp;amp; 2 行布局&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-4c6b0f5f95f53602.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;20180619_200035.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyItemDecoration extends RecyclerView.ItemDecoration {
    private int spanCount;//几行或几列
    private int orientation;//方向
    private int itemSpace;//空隙大小
    
    private Rect mBounds = new Rect();
    private Paint mPaint;//用来将空隙绘制成红色的画笔

    public MyItemDecoration(GridLayoutManager gridLayoutManager) {
        spanCount = gridLayoutManager.getSpanCount();
        orientation = gridLayoutManager.getOrientation();
        initPaint();
    }

    private void initPaint() {
        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setColor(Color.RED);
    }

    public void setItemSpace(int space) {
        itemSpace = space;
    }

    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        c.save();
        final int childCount = parent.getChildCount();
        for (int i = 0; i &amp;lt; childCount; i++) {
            final View child = parent.getChildAt(i);
            parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds);
            c.drawRect(mBounds, mPaint);
        }
        c.restore();
    }

    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        //获取当前view的layoutPosition
        int itemPosition = parent.getChildLayoutPosition(view);
        //计算该View位于哪一行哪一列
        int positionOfGroup = itemPosition % spanCount;
        int itemGroup = itemPosition / spanCount;
        
        //根据不同方向进行不同处理，最终效果都要实现除四周的View 外，内部的View之间横竖都以相同空隙间隔开
        //实现方式，以水平方向为例：
        //每个view的left和bottom都设置相同间隙
        //去掉第1列的left，和最后一行的bottom，也就实现了除四周外内部view都以相同间隙空隔开
        if (orientation == LinearLayoutManager.HORIZONTAL) {
            outRect.set(itemSpace, 0, 0, itemSpace);
            if (itemGroup == 0) {
                outRect.left = 0;
            }
            if (positionOfGroup == (spanCount - 1)) {
                outRect.bottom = 0;
            }
        } else if (orientation == LinearLayoutManager.VERTICAL) {
            outRect.set(0, itemSpace, itemSpace, 0);
            if (itemGroup == 0) {
                outRect.top = 0;
            }
            if (positionOfGroup == (spanCount - 1)) {
                outRect.right = 0;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：由于 GridLayoutManager 会根据设置的 Orientation 方向，默认为 VERTICAL 数值方向，以及 RecyclerView 的宽高模式来决定是否自动将某一方向的空隙平均分配给各 Item，这点需要注意一下。&lt;/p&gt;
&lt;p&gt;以上的例子想说明，如果要自定义写 Iiem 间的空隙，那么关键点在于重写两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;getItemOffsets()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDraw()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第 1 个方法会携带很多参数，最重要的是 outRect 这个参数，它是一个 Rect 类型的对象，重写这个方法并设置了这个 outRect 的 left, top, right, bottom，就相当于设置了对应这个 view 的四周分别有多大的空隙。&lt;/p&gt;
&lt;p&gt;其他的参数是用来给我们辅助使用，如果不需要区分对待，每个 item 的四周都是同样的间隔空隙，那直接设置 outRect 即可。&lt;/p&gt;
&lt;p&gt;如果需要像上述例子那样，要求四周的 Item 的间隙要区别于内部 item 的间隙，那么就需要判断出这个 View 的位置，因此可以通过其他参数辅助配合实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onDraw()&lt;/code&gt; 这个方法就是用于绘制，注意这个方法参数只给了 RecyclerView，而绘制 item 的 Decoration 是针对于每个 item 而言的，所以内部需要通过遍历子 View 来对每个 item 进行绘制操作。&lt;/p&gt;
&lt;p&gt;当然，我这里写得很粗糙，考虑到性能优化方面，绘制过度方面等等因素，通常是需要使用到 canvas.clipRect()。这部分代码建议可以参考 DividerItemDecoration 内部的实现。&lt;/p&gt;
&lt;h3 id=&quot;onflinglistener&quot;&gt;9. &lt;em&gt;OnFlingListener&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;RecyclerView 是可滑动控件，在平常使用过程中，我们可能就是上滑，下滑，左边滑滑，右边滑滑，能够刷新更多列表即可，通常都没太过去注意到滑动的细节。&lt;/p&gt;
&lt;p&gt;但其实，滑动策略也是支持多样化的。&lt;/p&gt;
&lt;p&gt;比如，如果想要实现不管以多大的加速度滑动，滑多长距离，最终停下来时都系统有个 ItemView 是居中显示的效果。&lt;/p&gt;
&lt;p&gt;再比如，只希望翻页滑动，当手指滑动距离小于翻页时，自动滑回原位进行翻页等等。&lt;/p&gt;
&lt;p&gt;这些滑动策略其实就可以直接借助内置的两个类来实现：LinearSnapHelper 和 PagerSnapHelper&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ps：本来以为这种滑动策略也是支持由焦点触发的滑动行为的，最后测试时才发现，原来只支持手指触摸式的滑动行为。由于我是搞 Tv 应用开发的，Tv 应用没有触摸事件，只有遥控器事件，滑动是由于焦点的变化触发的滑动行为。而在 Tv 上，Item 居中的需求也非常常见，但利用这个是无法实现的。所以，我就先不打算深入了解这块了，后续有时间再来慢慢研究。附上鸿神公众号中的一篇文章，大伙看这篇就行了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/ef3a3b8d0a77&quot;&gt;Android中使用RecyclerView + SnapHelper实现类似ViewPager效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3513995-aafe6c4113148c23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;snaphelper&quot;&gt;9.1 &lt;em&gt;SnapHelper&lt;/em&gt;&lt;/h4&gt;
&lt;h4 id=&quot;linearsnaphelper&quot;&gt;9.2 &lt;em&gt;LinearSnapHelper&lt;/em&gt;&lt;/h4&gt;

&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Jul 2018 11:09:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9255335.html</dc:identifier>
</item>
<item>
<title>Mybatis学习系列(1) –– 入门简介 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9255153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9255153.html</guid>
<description>&lt;h2&gt;MyBatis简介&lt;/h2&gt;
&lt;p&gt;Mybatis是Apache的一个Java开开源项目，是一个支持动态Sql语句的持久层框架。Mybatis可以将Sql语句配置在XML文件中，避免将Sql语句硬编码在Java类中。与JDBC相比：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Mybatis通过参数映射方式，可以将参数灵活的配置在SQL语句中的配置文件中，避免在Java类中配置参数（JDBC）&lt;/li&gt;
&lt;li&gt;Mybatis通过输出映射机制，将结果集的检索自动映射成相应的Java对象，避免对结果集手工检索（JDBC）&lt;/li&gt;
&lt;li&gt;Mybatis可以通过Xml配置文件对数据库连接进行管理。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;MyBatis整体架构及运行流程&lt;/h2&gt;
&lt;p&gt;Mybatis整体构造由 数据源配置文件、Sql映射文件、会话工厂、会话、执行器和底层封装对象组成。&lt;/p&gt;
&lt;h3&gt;1.数据源配置文件&lt;/h3&gt;
&lt;p&gt;通过配置的方式将数据库的配置信息从应用程序中独立出来，由独立的模块管理和配置。Mybatis的数据源配置文件包含数据库驱动、数据库连接地址、用户名密码、事务管理等，还可以配置连接池的连接数、空闲时间等。&lt;/p&gt;
&lt;p&gt;一个SqlMapConfig.xml基本的配置信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 加载数据库属性文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;db.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;使用JDBC实务管理&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transactionManager&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;连接池 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.driver}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.url}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.Sql映射文件&lt;/h3&gt;
&lt;p&gt;Mybatis中所有数据库的操作都会基于该映射文件和配置的sql语句，在这个配置文件中可以配置任何类型的sql语句。框架会根据配置文件中的参数配置，完成对sql语句以及输入输出参数的映射配置。&lt;/p&gt;
&lt;p&gt;Mapper.xml配置文件大致如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper 
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.sl.dao.ProductDao&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 根据id查询user表
        resultType:返回值类型，一条数据库记录也就对应实体类的一个对象
        parameterType:参数类型，也就是查询条件的类型
     &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectProductById&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Product&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 这里和普通的sql 查询语句差不多，对于只有一个参数，后面的 #{id}表示占位符，里面不一定要写id,写啥都可以，但是不要空着，如果有多个参数则必须写pojo类里面的属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from products where id = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.会话工厂与会话&lt;/h3&gt;
&lt;p&gt;Mybatis中会话工厂SqlSessionFactory类可以通过加载资源文件，读取数据源配置SqlNapConfig.xml信息，从而产生一种可以与数据库交互的会话实例SqlSession，会话实例SqlSession根据Mapper.xml文件中配置的sql,对数据库进行操作。&lt;/p&gt;
&lt;h3&gt;4.运行流程&lt;/h3&gt;
&lt;p&gt;会话工厂SqlSessionFactory通过加载资源文件获取SqlMapConfig.xml配置文件信息，然后生成可以与数据库交互的会话实例SqlSession。会话实例可以根据Mapper配置文件中的Sql配置去执行相应的增删改查操作。在SqlSession会话实例内部，通过执行器Executor对数据库进行操作，Executor依靠封装对象Mappered Statement，它分装了从mapper.xml文件中读取的信息（sql语句，参数，结果集类型）。Mybatis通过执行器与Mappered Statement的结合实现与数据库的交互。&lt;/p&gt;
&lt;p&gt;执行流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201807/577318-20180702181255132-2135681101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;测试工程搭建&lt;/h2&gt;
&lt;p&gt; 1. 新建maven工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201807/577318-20180702181320571-1138935145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 添加依赖pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('13997c93-bdab-4cb9-bec6-799f0cbc6884')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_13997c93-bdab-4cb9-bec6-799f0cbc6884&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_13997c93-bdab-4cb9-bec6-799f0cbc6884&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('13997c93-bdab-4cb9-bec6-799f0cbc6884',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_13997c93-bdab-4cb9-bec6-799f0cbc6884&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;junit.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;junit.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mybatis.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.4.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mybatis.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mysql.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.32&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mysql.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;log4j.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.17&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;log4j.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 单元测试 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${junit.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Mybatis &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${mybatis.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mysql &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${mysql.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 日志处理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${log4j.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3.编写数据源配置文件SqlMapConfig.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6731439e-fa48-438a-9826-166ccac9064f')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_6731439e-fa48-438a-9826-166ccac9064f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6731439e-fa48-438a-9826-166ccac9064f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6731439e-fa48-438a-9826-166ccac9064f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6731439e-fa48-438a-9826-166ccac9064f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 加载配置文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;db.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; id属性必须和上面的defaut一致 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transactionManager&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象源 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.driver}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.url}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;—申明mapper文件 --&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; xml实现    注册productMapper.xml文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;mapper/productMapper.xml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;4.编写SQL映射配置文件productMapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('42b466f2-a92d-4f4c-bdc3-8b635d8da6c2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_42b466f2-a92d-4f4c-bdc3-8b635d8da6c2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_42b466f2-a92d-4f4c-bdc3-8b635d8da6c2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('42b466f2-a92d-4f4c-bdc3-8b635d8da6c2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_42b466f2-a92d-4f4c-bdc3-8b635d8da6c2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper 
    PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.sl.mapper.ProductMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectAllProduct&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.sl.po.Product&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from products
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;5.编写测试代码TestClient.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('00f5695c-aa2d-4586-add1-c0599d3a306d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_00f5695c-aa2d-4586-add1-c0599d3a306d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_00f5695c-aa2d-4586-add1-c0599d3a306d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('00f5695c-aa2d-4586-add1-c0599d3a306d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_00f5695c-aa2d-4586-add1-c0599d3a306d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用productMapper.xml配置文件&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClient {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义会话SqlSession&lt;/span&gt;
    SqlSession session =&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    
    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义mabatis全局配置文件&lt;/span&gt;
        String resource = &quot;SqlMapConfig.xml&quot;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载mybatis全局配置文件
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;InputStream inputStream = TestClient.class.getClassLoader().getResourceAsStream(resource);&lt;/span&gt;
&lt;span&gt;        
        InputStream inputStream &lt;/span&gt;=&lt;span&gt; Resources.getResourceAsStream(resource);
        SqlSessionFactoryBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder();
        SqlSessionFactory factory &lt;/span&gt;=&lt;span&gt; builder.build(inputStream);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据sqlSessionFactory产生会话sqlsession&lt;/span&gt;
        session =&lt;span&gt; factory.openSession();    
    }

    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询所有user表所有数据&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectAllUser() {
        String statement &lt;/span&gt;= &quot;com.sl.mapper.ProductMapper.selectAllProduct&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Product&amp;gt; listProduct =&lt;span&gt;session.selectList(statement);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Product product:listProduct)
        {
            System.out.println(product);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭会话&lt;/span&gt;
&lt;span&gt;        session.close();    
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a3e778d5-5ebe-4daf-8a10-9ffec14439bd')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a3e778d5-5ebe-4daf-8a10-9ffec14439bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a3e778d5-5ebe-4daf-8a10-9ffec14439bd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a3e778d5-5ebe-4daf-8a10-9ffec14439bd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a3e778d5-5ebe-4daf-8a10-9ffec14439bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Description;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal UnitPrice;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ImageUrl;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Boolean IsNew;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDescription(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getUnitPrice() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; UnitPrice;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUnitPrice(BigDecimal unitprice) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.UnitPrice =&lt;span&gt; unitprice;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getImageUrl() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setImageUrl(String imageurl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ImageUrl =&lt;span&gt; imageurl;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; getIsNew() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IsNew;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setIsNew(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isnew) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsNew =&lt;span&gt; isnew;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Product [id=&quot; + Id + &quot;, Name=&quot; + Name + &quot;, Description=&quot; +&lt;span&gt; Description
                &lt;/span&gt;+ &quot;, UnitPrice=&quot; + UnitPrice + &quot;, ImageUrl=&quot; + ImageUrl + &quot;, IsNew=&quot; + IsNew+ &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;6.运行测试用例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201807/577318-20180702181558003-1700599553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 02 Jul 2018 10:27:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9255153.html</dc:identifier>
</item>
</channel>
</rss>