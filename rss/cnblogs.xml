<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式和钩子函数 - 凝眸v</title>
<link>http://www.cnblogs.com/zj-blog/p/8998369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zj-blog/p/8998369.html</guid>
<description>&lt;p&gt;                                                                             &lt;span&gt;&lt;strong&gt;&lt;span&gt;模板模式和钩子函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.什么是模板模式?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构就能重新定义该算法的某些特定步骤。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;二.如何实现模板模式?&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public abstract class Hello{

   abstract void initialize();

   public final void HelloWorld(){

      initialize();
      if(isDelete()){
         System.out.println(&quot;删除&quot;);
      }
   }
  
  /**
   *钩子函数
   */ 
 public boolean isDelete(){

     return true;
  }
}
public abstract class Game {

   public  void initialize(){
        System.out.println(&quot;my name is Hello&quot;);
   }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;三.模板模式的实现要素?&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;准备一个抽象基类,将部分逻辑以具体方法的形式实现,然后声明一些抽象方法交由子类实现剩余逻辑,用钩子方法给予子类更大的灵活性。最后将方法汇总构成一个不可改变的模板方法。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;四.模板模式的应用场景?&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;      &lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;算法或操作遵循相似的逻辑,重构时(把相同的代码抽取到父类中),重要,复杂的算法,核心算法设计为模板。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;五.模板模式的优点和缺点?&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;封装性好,复用性好,屏蔽细节,便于维护这几大优点;不同的实现都需要不同的子类,导致类的数量太多。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 07:26:00 +0000</pubDate>
<dc:creator>凝眸v</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zj-blog/p/8998369.html</dc:identifier>
</item>
<item>
<title>redis主从，哨兵回忆手册 - intsmaze(刘洋)</title>
<link>http://www.cnblogs.com/intsmaze/p/6819091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/intsmaze/p/6819091.html</guid>
<description>&lt;h3&gt; &lt;span&gt;redis主从&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/758427/201705/758427-20170506230116586-1470781350.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　持久化的开启与主从集群是否生效无关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Slave Server同样是以&lt;span&gt;非阻塞的方式完成数据同步&lt;/span&gt;。在同步期间，如果有客户端提交查询请求，&lt;span&gt;Redis则返回同步之前的数据(注意初次同步则会阻塞)&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Replication的工作原理：&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/758427/201705/758427-20170506225638507-1670368491.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;如果Master和Slave之间的链接出现断连现象，Slave可以自动重连Master，但是在连接成功之后，一次完全同步将被自动执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;缺点主节点挂了，那么就只能提供读操作了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;h4&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;应用示例：&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;这里我们假设Master-Slave已经建立。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;19.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    #启动master服务器。
    [root@Stephen-PC redis]# redis-cli -p 6379
    redis 127.0.0.1:6379&amp;gt;
    #清空Master当前数据库中的所有Keys。
    redis 127.0.0.1:6379&amp;gt; flushdb
    OK
    #在Master中创建新的Keys作为测试数据。
    redis 127.0.0.1:6379&amp;gt; set mykey hello
    OK
    redis 127.0.0.1:6379&amp;gt; set mykey2 world
    OK
    #查看Master中存在哪些Keys。
    redis 127.0.0.1:6379&amp;gt; keys *
    1) &quot;mykey&quot;
    2) &quot;mykey2&quot;
    
    #启动slave服务器。
    [root@Stephen-PC redis]# redis-cli -p 6380
    #查看Slave中的Keys是否和Master中一致，从结果看，他们是相等的。
    redis 127.0.0.1:6380&amp;gt; keys *
    1) &quot;mykey&quot;
    2) &quot;mykey2&quot;
    
    #在Master中删除其中一个测试Key，并查看删除后的结果。
    redis 127.0.0.1:6379&amp;gt; del mykey2
    (integer) 1
    redis 127.0.0.1:6379&amp;gt; keys *
    1) &quot;mykey&quot;
    
    #在Slave中查看是否mykey2也已经在Slave中被删除。
    redis 127.0.0.1:6380&amp;gt; keys *
    1) &quot;mykey&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;哨兵模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;哨兵模式就是监控redis系统的运行情况，主要功能有两点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1，监控主数据库和从数据库是否正常运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，主数据库出现故障时，可以自动将从数据库转换为主数据库，实现自动切换。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;实现步骤&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　在其中一台从服务器(比如192.168.19.131)中配置sentinel.conf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vi sentinel.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sentinel monitor name(监控的主从集群的名称) 192.168.19.131 8089 1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;名称，ip,端口(主从集群中master的地址)，投票选举次数&lt;/span&gt;
sentinel down-after-milliseconds name 5000 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;默认1s检测一次，这里配置超时5000毫秒为宕机&lt;/span&gt;
sentinel failover-timeout name 900000&lt;span&gt;
sentinel parallel&lt;/span&gt;-syncs name 2&lt;span&gt;
sentinel can&lt;/span&gt;-&lt;span&gt;fallover name yes
port &lt;/span&gt;26379 &lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;/span&gt;&lt;span&gt;哨兵默认的端口&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;启动哨兵
&lt;/span&gt;/user/intsmaze/redis/bin/redis-server /user/intsmaze/redis/etc/sentinel.conf --sentinel &amp;amp;&lt;span&gt;
查看哨兵相关信息
&lt;/span&gt;/user/intsmaze/redis/bin/redis-cli -h 192.168.19.131 -p 26379&lt;span&gt; Info sentinell
关闭主服务器查看集群信息
&lt;/span&gt;/user/intsmaze/redis/bin/redis-cli -h 192.168.19.131 -p 8089 shutdonwn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　缺点：主节点宕机了，再切换节点时，中间有几秒无法提供服务，这几秒是用来切换的，且是无法解决的。这个时候只能在java代码中对redis的操作进行异常捕获，如果发现是宕机异常，则在catch中睡眠一秒，在重试几次即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;或者使用两个哨兵集群进行解决，每个集群一个主，几个从。使用keepalive进行漂移，如果某个主宕机了，则keepalive则将ip飘到另一个主节点上。不需要等待从节点变为主节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　Redis Sentinel是一个分布式系统，可以部署多个Sentinel实例来监控同一组Redis实例，它们通过Gossip协议来确定一个主实例宕机，通过Agreement协议来执行故障恢复和配置变更，一般在生产环境中部署多个实例来提高系统可用性，只要有一个Sentinel实例运行正常，就能保证被监控的Redis实例运行正常（类似Zookeeper，通过多个Zookeeper来提高系统可用性）；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;redis的主从读写&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　redis的主从读写，redis自己是无法做到的，即我们要在java客户端通过代码指定写操作请求master,读操作请求slave。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　jedis提供的连接池不支持主从读写的，只支持哨兵模式。就是连接池地址是哨兵，然后所有的读写请求都是走向master，只是做到了当主节点宕机，从升级为主后，jedis的连接池会自动更改当前master的地址。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;HA的关键在于避免单点故障及故障恢复&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;　　在Redis Cluster未发布之前，Redis一般以主/从方式部署（这里讨论的应用从实例主要用于备份，主实例提供读写，有不少应用是读写分离的，读写操作需要取不同的Redis实例，该方案也可用于此种应用，原理都是相通的，区别在于数据操作层如何封装），该方式要实现HA主要有如下几种方案： &lt;br/&gt;　　1，keepalived：通过keepalived的虚拟IP，提供主从的统一访问，在主出现问题时，通过keepalived运行脚本将从提升为主，待主恢复后先同步后自动变为主，该方案的好处是主从切换后，应用程序不需要知道(因为访问的虚拟IP不变)，坏处是引入keepalived增加部署复杂性； &lt;br/&gt;　　2，zookeeper：通过zookeeper来监控主从实例，维护最新有效的IP，应用通过zookeeper取得IP，对Redis进行访问； &lt;br/&gt;　　3，sentinel：通过Sentinel监控主从实例，自动进行故障恢复，该方案有个缺陷：因为主从实例地址(IP&amp;amp;amp;PORT)是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在Jedis2.2.2中新增了对Sentinel的支持，应用通过redis.clients.jedis.JedisSentinelPool.getResource()取得的Jedis实例会及时更新到新的主实例地址。 &lt;br/&gt;　　笔者所在的公司先使用了方案1一段时间后，发现keepalived在有些情况下会导致数据丢失，keepalived通过shell脚本进行主从切换，配置复杂，而且keepalived成为新的单点，后来选用了方案3，使用Redis官方解决方案；（方案2需要编写大量的监控代码，没有方案3简便，网上有人使用方案2读者可自行查看）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 06 May 2018 07:08:00 +0000</pubDate>
<dc:creator>intsmaze(刘洋)</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/intsmaze/p/6819091.html</dc:identifier>
</item>
<item>
<title>【图文详解】HDFS基本原理 - py小杰</title>
<link>http://www.cnblogs.com/52mm/p/p13.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52mm/p/p13.html</guid>
<description>&lt;p&gt;本文主要详述了HDFS的组成结构，客户端上传下载的过程，以及HDFS的高可用和联邦HDFS等内容。若有不当之处还请留言指出。&lt;/p&gt;
&lt;p&gt;当数据集大小超过一台独立的物理计算机的存储能力时，就有必要对它进行分区，并存储到若干台独立的计算机上。Hdfs是Hadoop中的大规模分布式文件存储系统。&lt;/p&gt;
&lt;h2 id=&quot;hdfs的特点&quot;&gt;HDFS的特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HDFS文件系统可存储超大文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）HDFS是一种文件系统，自身也有块（block）的概念，其文件块要比普通单一磁盘上文件系统大的多，hadoop1.0上默认是 64MB，2.0默认是128MB。与其他文件系统不同的是，HDFS中小于一个块大小的文件不会占据整个块的空间。&lt;/p&gt;
&lt;p&gt;2）HDFS上的块之所以设计的如此之大，其目的是为了最小化寻址开销。如果块设置得足够大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。&lt;/p&gt;
&lt;p&gt;3）HDFS文件的所有块并不需要存储在一个磁盘上，因此可以利用集群上任意一个磁盘进行存储，由于具备这种分布式存储的逻辑，所以可以存储超大的文件。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;HDFS同一时刻只允许一个客户端对文件进行追加写操作（不支持多个写入者的操作，也不支持在文件的任意位置修改），这样避免了复杂的并发管理功能，但也限制了系统性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行在普通廉价的机器上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Hadoop 的设计对硬件要求低，无需昂贵的高可用性机器上，因为在 HDFS 设计中充分考虑到了数据的可靠性、安全性和高可用性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HDFS适合存储大文件并为之提供高吞吐量的顺序读/写操作，不太适合大量随机读的应用场景，也不适合存大量小文件的应用场景。HDFS是为高吞吐量应用优化的，会以提高时间延迟为代价，因此不适合处理低时延的数据访问的应用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;hdfs体系架构&quot;&gt;HDFS体系架构&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HDFS 是一个主/从（Master/Slave）体系架构，由于分布式存储的性质，集群拥有两类节点 NameNode 和 DataNode。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;NameNode（名称节点）：系统中通常只有一个，中心服务器的角色，管理存储和检索多个 DataNode 的实际数据所需的所有元数据，响应客户请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;DataNode（数据节点）：系统中通常有多个，是文件系统中真正存储数据的地方，在NameNode 统一调度下进行数据块的创建、删除和复制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;namenode&quot;&gt;NameNode&lt;/h2&gt;
&lt;p&gt;NameNode负责整个分布式文件系统的元数据，包括文件目录树，文件到数据块Block的映射关系等。这些数据保存在内存里，同时这些数据还以两个文件形式永久保存在本地磁盘上：命名空间镜像文件（fsimage）和编辑日志文件（editlog）。fsimage是内存命名空间元数据在外存的镜像文件，editlog文件则记录着用户对文件的各种操作记录，当客户端对hdfs中的文件进行新增或者修改操作，操作记录首先被记入editlog文件中，当客户端操作成功后，相应的元数据会更新到内存meta.data中，防止发生意外导致丢失内存中的数据。fsimage和editlog两个文件结合可以构造出完整的内存数据。&lt;/p&gt;
&lt;p&gt;NameNdoe还负责对DataNode的状态监控。DataNode定期向NameNode发送心跳以及所存储的块的列表信息。NameNode可以知道每个DataNode上保存着哪些数据（Block信息），DataNode是否存活，并可以控制DataNode启动或是停止。若NameNode发现某个DataNode发生故障，会将其存储的数据在其他DataNode机器上增加相应的备份以维护数据副本（默认为3，可在配置文件中配置）保持不变。&lt;/p&gt;
&lt;p&gt;如果NaneNode服务器失效，集群将失去所有的数据。因为我们将无从知道哪些DataNode存储着哪些数据。因此NameNode的高可用，容错机制很重要。&lt;/p&gt;
&lt;h2 id=&quot;datanode&quot;&gt;DataNode&lt;/h2&gt;
&lt;p&gt;DataNode负责数据块的实际存储和读/写工作。在hadoop1.0时，DataNode的数据块默认大小为64M，2.0版本后，块的默认大小为128M。当客户端上传一个大文件时，HDFS会自动将其切割成固定大小的Block，每个块以多份的形式存储在集群上，默认为3份。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Datanode掉线判断&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;datanode进程死亡或者网络故障造成datanode无法与namenode通信，namenode不会立即把该节点判定为死亡，要经过一段时间，这段时间暂称作超时时长。HDFS默认的超时时长为10分钟+30秒。如果定义超时时间为timeout，则超时时长的计算公式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;timeout  = 2 * heartbeat.recheck.interval + 10 * dfs.heartbeat.interval
而默认的heartbeat.recheck.interval 大小为5分钟，dfs.heartbeat.interval默认为3秒。
需要注意的是hdfs-site.xml 配置文件中的heartbeat.recheck.interval的单位为毫秒，dfs.heartbeat.interval的单位为秒。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property&amp;gt;
        #NameNode向DataNode发起的请求，要求其发送心跳信息的时间间隔
        &amp;lt;name&amp;gt;heartbeat.recheck.interval&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;8000&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
        #DataNode发送心跳的时间间隔
        &amp;lt;name&amp;gt;dfs.heartbeat.interval&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;数据副本块数量与默认数量不同&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;property&amp;gt;
#DataNode默认60分钟向NameNode提交自己的Block信息
&amp;lt;name&amp;gt;dfs.blockreport.intervalMsec&amp;lt;/name&amp;gt;
&amp;lt;value&amp;gt;3600000&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一台DataNode经过10分30秒（默认）后没有给NameNode发送心跳信息，而被NameNode判断为死亡，NameNode会马上将其上的数据备份到集群中其他机器上。当这个DataNode节点排除故障后，重新回到集群中，该节点上还保存着原来那批数据，而默认的配置情况下，DataNode会每隔60分钟向NameNode发送一次Block信息，在这段时间内，集群中会有某些数据块多出一个备份。在NameNode收到该节点的Block信息后，它发现数据备份多了才会命令某些DataNode删除掉多余的备份数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;客户端上传文件&quot;&gt;客户端上传文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fSHFsSn.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤详解：&lt;/p&gt;
&lt;p&gt;1）向namenode请求上传文件&lt;/p&gt;
&lt;p&gt;2）namenode检查客户端要求上传的文件是否已存在，父目录是否存在&lt;/p&gt;
&lt;p&gt;3）namenode响应客户端是否可以上传文件&lt;/p&gt;
&lt;p&gt;4）若第3步获得可以上传的信息，客户端向namenode发出请求，询问第一块block该上传到哪里&lt;/p&gt;
&lt;p&gt;5）namenode查询datanode信息（忙碌情况，远近情况等）&lt;/p&gt;
&lt;p&gt;6）namenode返回3个datanode地址给客户端&lt;/p&gt;
&lt;p&gt;7）客户端请求与最近的一个datanode节点（假设为datanode1）建立传输通道，并告知其还要传给datanode2和datanode3。datanode1会请求与datanode2建立连接，datanode2会请求与datanode3建立连接。&lt;/p&gt;
&lt;p&gt;8）datanode3响应datanode2的连接请求，通道建立成功。同理，datanode2响应datanode1，datanode1响应客户端。&lt;/p&gt;
&lt;p&gt;9）客户端收到通道建立成功的消息后，开始向datanode1发送block1的数据，以一个个package（64k）为单位通过通道向datanode1写数据，datanode1收到数据会将其存在本地缓存中，一边向datanode2传数据，一边将缓存中的数据保存到磁盘上。&lt;/p&gt;
&lt;p&gt;10）客户端在传送数据时会有一个package的应答队列，datanode1每收到一个package后就向客户端发回消息（datanode1不用等待datandoe2发回应答信息才给客户端发送信息，客户端只保证datanode1收到了数据就行，后面的事它交给了datanode1）&lt;/p&gt;
&lt;p&gt;11）当一个block传输完成之后，客户端再次请求namenode上传第二个block&lt;/p&gt;
&lt;h2 id=&quot;namenode如何选择datanode&quot;&gt;NameNode如何选择DataNode&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fpBauN2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端在上传数据时，请求namenode告诉其应该往哪几个datanode上传副本。namenode需要综合考虑datanode的可靠性，写入带宽，读出带宽等因素。默认情况下，在运行客户端的那个节点上存放第1个副本，如果客户端运行在集群之外，则随机选择一个节点存放第1块，但namenode会尽量选择那些情况好的datanode（存储不太满，当时不太忙，带宽比较高）。第2个副本存放在与第1个副本所在机架不同的另一个机架上的datanode中（随机选择另一机架上的另一情况较好的datanode），第3个副本存在与第2个副本相同机架但不同datanode的另一个datanode上。&lt;/p&gt;
&lt;p&gt;所有有关块复制的决策统一由 NameNode 负责，NameNode 会周期性地接受集群中数据节点 DataNode 的心跳和块报告。一个心跳的到达表示这个数据节点是正常的。一个块报告包括该数据节点上所有块的列表。&lt;/p&gt;
&lt;h2 id=&quot;客户端下载文件&quot;&gt;客户端下载文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/e5fqmWu.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤详解：&lt;/p&gt;
&lt;p&gt;1）跟namenode通信，请求下载某个数据。&lt;/p&gt;
&lt;p&gt;2）namenode查询元数据信息以及block位置信息。&lt;/p&gt;
&lt;p&gt;3）将数据所在的datanode信息返回给客户端。&lt;/p&gt;
&lt;p&gt;4）客户端根据数据所在的datanode，挑选一台距离自己最近的datanode，并向其发出下载文件的请求（若所需数据不在一台datanode上保存，则分别向多台datanode发出请求）。&lt;/p&gt;
&lt;p&gt;5）datanode响应客户端请求，将数据返回给客户端。&lt;/p&gt;
&lt;p&gt;6）从多个datanode获得的数据不断在客户端追加，形成完整的数据&lt;/p&gt;
&lt;h2 id=&quot;namenode与secondary-namenode&quot;&gt;NameNode与Secondary NameNode&lt;/h2&gt;
&lt;p&gt;因为namenode上保存着整个hdfs集群上的所有元数据信息，如果namenode宕机，集群将失去所有数据，因此对namenode实现容错十分重要，Hadoop为此提供了两种机制。&lt;/p&gt;
&lt;p&gt;第一种是在配置文件里配置namenode的工作目录为多个，这样可以将元数据信息存到多块磁盘上，或是多台机器上，甚至可以将元数据存在远程挂载的网络文件系统中（NFS），可以通过配置使namenode在多个文件系统上实时保存元数据。这样一来，namenode的工作目录所在的磁盘损坏后，还有其他磁盘上的数据可用。&lt;/p&gt;
&lt;p&gt;第二种是运行一个辅助namenode，被称为secondary namenode（第二名称节点）。secondary namenode的职责并不是作为namenode的热备份机，其主要作用是定期从namenode拉取fsimage和editlog，并将两者合并成新的fsimage，将新的fsimage返回给namenade。这种方式，一方面可以避免namenode上的编辑日志过大，另一方面将合并操作放在secondary namenode上可以节省namenode的cpu时间和内存，减轻namenode的工作压力，让namenode更专注于自己的本职工作。secondary namenode中保存的fsimage数据总是会滞后于namenode内存中的元数据，所以在namenode宕机后，难免会有部分的数据丢失。（可以把NFS上的namenode元数据复制到secondary namenode上，使其成为新的namenode，并不损失任何数据）&lt;/p&gt;
&lt;h2 id=&quot;secondary-namenode的工作&quot;&gt;Secondary NameNode的工作&lt;/h2&gt;
&lt;p&gt;secondary namenode将namenode上积累的所有editlog下载到本地，并加载到内存进行merge，这个过程称为checkpoint。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/uPgwNg0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤详解：&lt;/p&gt;
&lt;p&gt;1）secondary namenode通知namenode要进行checkpoint了。（定时，或是namenode上的editlog数量达到一定规模）。&lt;/p&gt;
&lt;p&gt;2）namenode做准备。&lt;/p&gt;
&lt;p&gt;3）secondary namenode将namenode的editlogs下载到本地磁盘上。&lt;/p&gt;
&lt;p&gt;4）secondary namenode将editlogs和fsimage加载到内存中，进行合并产生新的fsimage。&lt;/p&gt;
&lt;p&gt;5）secondary namenode将新的fsimage传回给namenode（覆盖namenode上旧的fsimage文件），并将其保存到本地磁盘上覆盖掉旧的fsimage。&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a表示，hdfs上数据的更新修改等操作都会先写入编辑日志文件，再更新到内存里。&lt;/li&gt;
&lt;li&gt;secondary namenode节点只有在启动后，第一次进行checkpoint时才会将namenode的editlog和fsimage都下载到自己的本地磁盘，再进行合并。后期的checkpoint都只会下载editlog文件，而不会下载fsimage，因为自己磁盘上保存的fsimage和namenode上的是一样的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;namenode高可用high-availabilityha&quot;&gt;NameNode高可用（High Availability，HA）&lt;/h2&gt;
&lt;p&gt;即使将namenode内存中的元数据备份在多个文件系统中，并通过secondary namenode的checkpoint功能防止namenode的数据丢失，但依然无法实现namenode的高可用。namenode一旦失效，整个系统将无法提供服务，管理员通过冷启动的方式让新的namenode上线需要一段等待的时间（几十分钟，甚至更长）。新的namenode在响应服务前必须经历以下以下步骤：将元数据导入内存；重做编辑日志文件；接收到足够多的来自datanode的数据块报告并退出安全模式(数据块的位置信息不保存在元数据中，需要namenode启动时在datanode向其汇报的块信息中获取)。&lt;/p&gt;
&lt;p&gt;针对以上问题，hadoop的2.x版本提出了namenode的HA解决方案。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/Jzgq3LW.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）主控服务器由一主（Active NameNode，ANN）一从（Standby NameNode，SNN）两台服务器构成。&lt;/p&gt;
&lt;p&gt;2）ANN响应客户端请求，SNN作为ANN的热备份机，同步ANN保存的元数据，在ANN失效时转换成新的ANN，快速提供服务。&lt;/p&gt;
&lt;p&gt;3）ANN和SNN之间通过高可用的共享存储系统保持数据一致（ANN将数据写入共享存储系统，SNN一直监听共享系统，一旦数据发生改变就将其加载到自己内存中）&lt;/p&gt;
&lt;p&gt;4）datanode同时向ANN和SNN汇报心跳和block信息。&lt;/p&gt;
&lt;p&gt;5）故障转移控制器（Failover Contraller，FC），监控ANN和SNN的状态，并不断向ZK集群汇报心跳信息。&lt;/p&gt;
&lt;p&gt;6）ZK集群&quot;选举领导者&quot;，一旦发现ANN失效，就重新选举SNN作为新的领导者，FC通知其转变为新的ANN。Hadoop刚启动时，两台NameNode都是SNN，zk集群通过选举产生领导者作为ANN。&lt;/p&gt;
&lt;h2 id=&quot;namenode联盟联邦hdfs&quot;&gt;NameNode联盟（联邦HDFS）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/FB8CMXM.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）namenode的内存数据包括两块内容，命名空间和数据块池（在namenode联盟中这两块数据相加被称为命名空间卷）。&lt;/p&gt;
&lt;p&gt;2）命名空间中保存的内容包括文件或目录的拥有者，修改日期，以及文件被切分为哪几个块等信息，但不包括块到底是存储在哪些datanode中的信息（block位置信息）。&lt;/p&gt;
&lt;p&gt;3）数据块池中保存着block位置信息（namenode刚启动时并没有block位置信息，是由datanode向其发送的block块信息中获取的）&lt;/p&gt;
&lt;p&gt;4）datanode很好地支持水平扩展，但单一namenode受内存空间限制，使得HDFS中所能容纳的最大文件数量受到限制（一个大文件和一个小文件的元数据所占内存空间大小是基本相同，所以不适合存小文件，会很快占满namenode的内存）。&lt;/p&gt;
&lt;p&gt;5）单一namanode使得所有来自客户端的请求都由一台服务器响应，很容易达到其性能上线，无法实现性能上的水平扩展。&lt;/p&gt;
&lt;p&gt;6）单一namenode无法隔离来自不同客户的请求（比如本地实验时，对namenode的负载影响会导致正常用户的访问请求受到延迟等）&lt;/p&gt;
&lt;p&gt;由于单一namenode存在以上4，5，6所述的问题，hadoop2.0给出了namenode联盟的解决方案,实现对namenode的水平扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Sqq2Wv6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）将一个大的命名空间切割成若干子命名空间，每个namenode管理命名空间中的一部分（如一个namenode管理/user下的所有文件，另一个管理/test下的所有文件）。&lt;/p&gt;
&lt;p&gt;2）每个namenode单独管理自己的命名空间和数据块池（也可将所有数据块池抽离出来，由另外的服务器集群来担任此功能），两两之间不进行通信，一个namenode宕机不会影响其他namenode工作。&lt;/p&gt;
&lt;p&gt;3）所有datanode被所有namenode共享，还是担任存储数据的功能。每个数据块的信息保存在唯一的某个数据块池中。&lt;/p&gt;
&lt;p&gt;4）所有datanode都要注册每一个namenode，为每个namenode提供存储数据的服务。&lt;/p&gt;
&lt;p&gt;5）每个datanode向所有的namenode发送心跳和block信息，每个namenode再根据自己的子命名空间维护自己的数据块池。&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 05:40:00 +0000</pubDate>
<dc:creator>py小杰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52mm/p/p13.html</dc:identifier>
</item>
<item>
<title>给你的博客园图片添加标题 - morethink</title>
<link>http://www.cnblogs.com/morethink/p/8998015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morethink/p/8998015.html</guid>
<description>&lt;p&gt;一直以来都觉得在图片下面添加一个标题可以更加清晰的表示这张图片的含义，可是博客园原生并不支持这种渲染方式，再加上博客园可以自己写js来更改主题，于是通过搜索资料完成给博客园图片添加标题的功能。&lt;/p&gt;
&lt;p&gt;当我们如下书写markdown时：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode markdown&quot;&gt;
&lt;code class=&quot;sourceCode markdown&quot;&gt;![](https://images.morethink.cn/092017231747399.jpg &quot;TCP的三次握手和四次挥手&quot;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会被博客园渲染成&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;https://images.morethink.cn/092017231747399.jpg&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; title=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;TCP的三次握手和四次挥手&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;于是我就想通过在img标签后面动态添加一个带有&lt;code&gt;title&lt;/code&gt;的p标签来给博客园图片添加标题。&lt;/p&gt;
&lt;p&gt;将下面代码放入&lt;code&gt;页首Html代码&lt;/code&gt;代码中即可(需要申请js权限)。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 引入jQuery --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://cdn.bootcss.com/jquery/1.10.2/jquery.min.js&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(window).&lt;span class=&quot;at&quot;&gt;load&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//给每张图片添加标题,div.cnblogs_post_body是博客主体&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;div[id=cnblogs_post_body] img&quot;&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;each&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;attr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;title&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; boardp_style &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;style='display: block; text-align: center; color: #969696;padding: 10px;border-bottom: 1px solid #d9d9d9;margin: 0 auto;&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;width: &quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;width&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;px;&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;height: 28px;&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;'&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; boardp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;p &quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; boardp_style &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; title &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;/p&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;after&lt;/span&gt;(boardp)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;!-- 将img变为块级元素 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;style type=&quot;text/css&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&amp;gt;&lt;/span&gt;
    img &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; auto&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; block&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/style&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;markdown图片：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode markdown&quot;&gt;
&lt;code class=&quot;sourceCode markdown&quot;&gt;![](https://images.morethink.cn/092017231747399.jpg &quot;TCP的三次握手和四次挥手&quot;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/092017231747399.jpg&quot; title=&quot;TCP的三次握手和四次挥手&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 05:34:00 +0000</pubDate>
<dc:creator>morethink</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morethink/p/8998015.html</dc:identifier>
</item>
<item>
<title>解决记录：win10 无法安装VS2017，visual studio installer下载进度始终为0 - 梦在旅途</title>
<link>http://www.cnblogs.com/zuowj/p/8997919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuowj/p/8997919.html</guid>
<description>&lt;p&gt;问题描述：win10 下无法安装VS2017，visual studio installer下载进度始终为0，点击取消按钮后，也没有反应，visual studio installer也关闭不掉；&lt;/p&gt;
&lt;p&gt;具体问题详见 博问：&lt;a href=&quot;https://q.cnblogs.com/q/106027/&quot; target=&quot;_blank&quot;&gt;https://q.cnblogs.com/q/106027/&lt;/a&gt;          微软问题：&lt;a href=&quot;https://social.msdn.microsoft.com/Forums/zh-CN/baafa177-158d-4130-bc64-330b7b32a14c/win10-vs2017visual-studio-installer0?forum=vstudiozhchs&quot; target=&quot;_blank&quot;&gt;https://social.msdn.microsoft.com/Forums/zh-CN/baafa177-158d-4130-bc64-330b7b32a14c/win10-vs2017visual-studio-installer0?forum=vstudiozhchs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过查询C:\Users\admin\AppData\Local\Temp下日志（dd_bootstrapper_开头）：&lt;/p&gt;
&lt;blockquote readability=&quot;38&quot;&gt;
&lt;p&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: Beginning file download. File = https://aka.ms/vs/15/release/installer.&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: Download requested: https://aka.ms/vs/15/release/installer&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: Attempting download 'https://aka.ms/vs/15/release/installer' using engine 'WebClient'&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: WebClient error 'ConnectFailure' - proxy setting 'Default' - 'https://aka.ms/vs/15/release/installer'.&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: WebClient error 'ConnectFailure' - proxy setting 'DefaultCredentialsOrNoAutoProxy' - 'https://aka.ms/vs/15/release/installer'.&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: WebClient error 'ConnectFailure' - proxy setting 'NetworkCredentials' - 'https://aka.ms/vs/15/release/installer'.&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: WebClient error 'ConnectFailure' - proxy setting 'DirectAccess' - 'https://aka.ms/vs/15/release/installer'.&lt;br/&gt;&lt;span&gt;&lt;strong&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: WebClient failed in 'https://aka.ms/vs/15/release/installer' with '基础连接已经关闭: 无法连接到远程服务器。' - 'https://aka.ms/vs/15/release/installer'.&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: Download failed using WebClient engine. System.Net.WebException: 基础连接已经关闭: 无法连接到远程服务器。 ---&amp;gt; System.Net.Sockets.SocketException: 无法加载或初始化请求的服务提供程序。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;在 System.Net.Sockets.Socket..ctor(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;在 System.Net.ServicePoint.GetConnection(PooledStream PooledStream, Object owner, Boolean async, IPAddress&amp;amp; address, Socket&amp;amp; abortSocket, Socket&amp;amp; abortSocket6)&lt;br/&gt;在 System.Net.PooledStream.Activate(Object owningObject, Boolean async, GeneralAsyncDelegate asyncCallback)&lt;br/&gt;在 System.Net.Connection.CompleteStartConnection(Boolean async, HttpWebRequest httpWebRequest)&lt;br/&gt;--- 内部异常堆栈跟踪的结尾 ---&lt;br/&gt;在 System.Net.HttpWebRequest.GetResponse()&lt;br/&gt;在 Microsoft.VisualStudio.Setup.Download.WebClientEngine.GetWebResponse(Uri uri, DownloadContext downloadContext, DownloadSummary&amp;amp; downloadSummary)&lt;br/&gt;在 Microsoft.VisualStudio.Setup.Download.WebClientEngine.DownloadCore(Uri uri, Stream stream, ProgressUpdateCallback progress, CancellationToken cancellationToken, DownloadContext downloadContext)&lt;br/&gt;在 Microsoft.VisualStudio.Setup.Download.DownloadEngineBase.DownloadWithBitRate(Uri uri, Stream outputStream, ProgressUpdateCallback progress, CancellationToken cancellationToken, DownloadContext downloadContext)&lt;br/&gt;在 Microsoft.VisualStudio.Setup.Download.DownloadEngineBase.Download(Uri uri, Stream outputStream, ProgressUpdateCallback progress, CancellationToken cancellationToken, DownloadContext downloadContext)&lt;br/&gt;在 Microsoft.VisualStudio.Setup.Download.DownloadManager.DownloadWithRetry(IDownloadEngine[] engines, Uri uri, Stream outputStream, ProgressUpdateCallback progress, CancellationToken cancellationToken, DownloadContext downloadContext, Boolean verifySignature)&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:07: Sleeping 5000 milliseconds before retrying download.&lt;br/&gt;VisualStudio Bootstrapper:2018/5/6 10:05:12: Attempting download 'https://aka.ms/vs/15/release/installer' using engine 'Bits'&lt;br/&gt;&lt;strong&gt;&lt;span&gt;VisualStudio Bootstrapper:2018/5/6 10:07:12: Skipped BITS download engine: 检索 COM 类工厂中 CLSID 为 {4991D34B-80A1-4291-83B6-3328366B9097} 的组件失败，原因是出现以下错误: 80080005 服务器运行失败 (异常来自 HRESULT:0x80080005 (CO_E_SERVER_EXEC_FAILURE))。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;VisualStudio Bootstrapper:2018/5/6 10:07:12: Download failed using Bits engine. System.Runtime.InteropServices.COMException (0x80080005): 检索 COM 类工厂中 CLSID 为 {4991D34B-80A1-4291-83B6-3328366B9097} 的组件失败，原因是出现以下错误: 80080005 服务器运行失败 (异常来自 HRESULT:0x80080005 (CO_E_SERVER_EXEC_FAILURE))。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;在 Microsoft.VisualStudio.Setup.Download.Bits.BitsEngine.&amp;lt;&amp;gt;c.&amp;lt;.ctor&amp;gt;b__3_0()&lt;/strong&gt;&lt;br/&gt;在 System.Lazy`1.CreateValue()&lt;br/&gt;在 System.Lazy`1.LazyInitValue()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到该日志，原以为是我的电脑无法正常访问https://aka.ms/vs/15/release/installer，但实际经过手动下载，是可以正常快速下载的，所以排除了网络问题，在此感谢DUDU的积极回复，虽不是网络问题，但至少表现出对该事情的关心。&lt;/p&gt;
&lt;p&gt;既然不是网络问题，那肯定就是电脑环境有问题，从安装日志来看（红色标出的部份），应该是Download failed using Bits engine，而该失败可能与一些COM服务相关，按照这个思路，通过如下步骤就成功解决了问题。&lt;/p&gt;
&lt;p&gt;第一步：检查BITS服务及相关依赖服务是否正常开启，如果没开启则全部设为自动并启用（这里我确实有一些服务没有开启）&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Remote Procedure Call (RPC)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;COM+ Event System&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;System Event Notification Services&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Background Intelligent Transfer Service-----》这个就是BITS服务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Network Connections&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二步：如果开启了上述所有的服务仍然不能解决问题，则需要检查是否存在组件缺失，若存在则需要修复，如下：（我的组件没有缺失）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Windows+x，打开“命令提示符（管理员），执行以下命令：&lt;/p&gt;
&lt;p&gt;DISM/Online /Cleanup-image /Scanhealth&lt;br/&gt;DISM/Online /Cleanup-image /Restorehealth&lt;br/&gt;Sfc /scannow&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第三步：如果执行了第二步检查并修复了相关组件后还有问题，则需要检查Socket组件，必要时执行如下命令进行重置（我的就需要重置）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;键入“netsh winsock reset” ，然后按“Enter” 。&lt;/li&gt;
&lt;li&gt;键入“netsh int ip reset” ，然后按“Enter” 。&lt;/li&gt;
&lt;li&gt;键入“ipconfig /release” ，然后按“Enter” 。&lt;/li&gt;
&lt;li&gt;键入“ipconfig /renew”，然后按“Enter”。&lt;/li&gt;
&lt;li&gt;键入“ipconfig /flushdns”，然后按“Enter”。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;执行完上述三步后，重启电脑，至此，我的这个问题就成功解决了。办法总比问题多，大家多动脑多分析任何问题都不会被难倒的。&lt;/p&gt;
&lt;p&gt;之所以分享这个解决记录，是因为VS2017是大家学习.NET CORE的首要条件，而在WIN 10上安装VS2017也是很常见的，可能谁也会遇到我这样的问题，有了分享，大家解决问题就快多了。&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 05:02:00 +0000</pubDate>
<dc:creator>梦在旅途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuowj/p/8997919.html</dc:identifier>
</item>
<item>
<title>安装Emacs并设置racket环境 - 祈求者-</title>
<link>http://www.cnblogs.com/invoker-/p/8997881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/invoker-/p/8997881.html</guid>
<description>&lt;p&gt;最近在阅读&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A&quot;&gt;sicp&lt;/a&gt;这本书，书中的代码是使用&lt;code&gt;scheme&lt;/code&gt;实现的。之前阅读的时候是使用&lt;code&gt;Dr.Racket&lt;/code&gt;来完成写练习的，可我觉得与其这样，不如一步到位，使用&lt;code&gt;emacs+lisp&lt;/code&gt;解释器来的比较快。&lt;/p&gt;
&lt;h2 id=&quot;安装emacs&quot;&gt;安装emacs&lt;/h2&gt;
&lt;p&gt;直接点击官方教程&lt;a href=&quot;http://ergoemacs.org/emacs/which_emacs.html&quot;&gt;点我查看&lt;/a&gt;，上面讲解的十分清楚，基本上不同系统的安装方式大同小异，下载后点击运行，还是很简单的吧。&lt;/p&gt;
&lt;h2 id=&quot;安装lisp解释器&quot;&gt;安装lisp解释器&lt;/h2&gt;
&lt;p&gt;lisp有无数种实现的版本，这里我使用的是&lt;code&gt;Racket&lt;/code&gt;，因为我之前电脑上就有&lt;code&gt;Dr.Racket&lt;/code&gt;所以不用下载，如果你没有的话，可以点击&lt;a href=&quot;https://download.racket-lang.org/&quot;&gt;Racket下载地址&lt;/a&gt;，选择合适系统的版本进行下载，当然你也可以选择其他lisp方言的实现版本，例如&lt;a href=&quot;http://scheme.com/download&quot;&gt;Petite Chez Scheme下载地址&lt;/a&gt;。下载完解压即可。&lt;/p&gt;
&lt;p&gt;下载完毕后，你可以得到这样的一些程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132218/201805/1132218-20180506123221932-1773720532.png&quot; alt=&quot;Racket基本程序&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着设置将上图解释器所在的文件夹路径设置到系统路径中(windows=环境变量,mac/linux=&lt;code&gt;$path&lt;/code&gt;),接着在终端敲击&lt;code&gt;racket --version&lt;/code&gt; 来检查是否设置成功。如果出现以下信息，你就成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132218/201805/1132218-20180506123313043-1408892483.png&quot; alt=&quot;检查Racket是否成功设置&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装一些必要而有效的插件&quot;&gt;安装一些必要而有效的插件&lt;/h2&gt;
&lt;p&gt;我们需要安装简单的几个插件来帮助我们高效的编写和运行代码。&lt;/p&gt;
&lt;h3 id=&quot;设置插件源&quot;&gt;设置插件源&lt;/h3&gt;
&lt;p&gt;和linux安装软件类似，这里我们设置&lt;code&gt;MELPA&lt;/code&gt;的安装源，这样我们就可以一键安装代码了，十分方便。&lt;br/&gt;鉴于国外访问速度很慢，我们这里使用国内的&lt;a href=&quot;https://github.com/emacs-china/elpa&quot;&gt;镜像源&lt;/a&gt;，这里要感谢一直维护自由软件的人，否则这些工具的设置与配置哪里会有这么容易和便捷:)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;emacs&lt;/code&gt;中所有的配置都在&lt;code&gt;~/.emacs&lt;/code&gt;这个文件中，对于windows，就是在C盘的个人目录文件夹下。我们可以通过编辑这个文件来对emacs进行一些自定义的配置。打开.emacs文件，在文件的末尾加上以下配置，设置我们的插件安装源。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;
&lt;code class=&quot;sourceCode scheme&quot;&gt; &lt;span class=&quot;co&quot;&gt;;; melpa 安装源&lt;/span&gt;
(require 'package)
(add-to-list 'package-archives
             '(&lt;span class=&quot;st&quot;&gt;&quot;melpa&quot;&lt;/span&gt; . &lt;span class=&quot;st&quot;&gt;&quot;http://elpa.emacs-china.org/melpa/&quot;&lt;/span&gt;)
             t)
(package-initialize)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以方便的安装插件了。&lt;/p&gt;
&lt;h3 id=&quot;安装racket-mode&quot;&gt;安装Racket-mode&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Racket-mode&lt;/code&gt;很好用，执行代码，高亮，提示，反正我觉得该有的都OK，下面就进行安装。&lt;br/&gt;使用以下命令&lt;code&gt;M-x package-install &amp;lt;ret&amp;gt; racket-mode&lt;/code&gt;,M代表&lt;code&gt;alt&lt;/code&gt;组合键的意思，&lt;code&gt;ret&lt;/code&gt;代表回车，所以该命令实际上就是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;alt+x&lt;/code&gt;打开命令模式&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;package-install&lt;/code&gt; (可以用空格键/tab来提示)，回车&lt;/li&gt;
&lt;li&gt;再输入要安装的插件名&lt;code&gt;racket-mode&lt;/code&gt;,回车确认，等待安装完毕。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132218/201805/1132218-20180506123335258-2137710956.png&quot; alt=&quot;插件安装&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么样，很简单吧。&lt;/p&gt;
&lt;p&gt;安装完毕后，在配置文件&lt;code&gt;.emacs&lt;/code&gt;配置文件中增加以下代码的配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;
&lt;code class=&quot;sourceCode scheme&quot;&gt;&lt;span class=&quot;co&quot;&gt;;;racket配置,设置解释器,自动补全,代码执行等&lt;/span&gt;
(require 'racket-mode)
(setq racket-racket-program &lt;span class=&quot;st&quot;&gt;&quot;racket&quot;&lt;/span&gt;)
(setq racket-raco-program &lt;span class=&quot;st&quot;&gt;&quot;raco&quot;&lt;/span&gt;)
(add-hook 'racket-mode-hook
          (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; ()
            (define-key racket-mode-map (kbd &lt;span class=&quot;st&quot;&gt;&quot;C-x C-j&quot;&lt;/span&gt;) 'racket-run)))
(setq tab-always-indent 'complete) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;安装paredit&quot;&gt;安装ParEdit&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ParEdit&lt;/code&gt;是一款让你半结构化编辑lisp的插件，例如括号的自动补全，s-表达式的转移，提取等等，还是很方便的。&lt;br/&gt;同样使用&lt;code&gt;M-x package-install &amp;lt;ret&amp;gt; paredit-mode&lt;/code&gt; 进行安装即可。&lt;/p&gt;
&lt;p&gt;具体的使用方法不是本篇文章的重点，可以参考以下几篇文章&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;p&gt;全部设置完毕后，我们新建一个文件(&lt;code&gt;ctrl+x 回车 i 回车 输入文件名&lt;/code&gt;),输入以下代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;
&lt;code class=&quot;sourceCode scheme&quot;&gt;&lt;span class=&quot;co&quot;&gt;#! /usr/bin/env racket&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;#lang racket&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;(displayln &quot;Hello World!&quot;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着使用&lt;code&gt;F5&lt;/code&gt; 执行 S-表达式，成功的打印的出Hello World&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132218/201805/1132218-20180506123352042-50500396.png&quot; alt=&quot;Hello World&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，安装&lt;code&gt;Emacs&lt;/code&gt;并设置&lt;code&gt;racket&lt;/code&gt;环境就完毕啦&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Sun, 06 May 2018 04:35:00 +0000</pubDate>
<dc:creator>祈求者-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/invoker-/p/8997881.html</dc:identifier>
</item>
<item>
<title>Spring Cloud入门教程 - Zuul实现API网关和请求过滤 - 乾儿_Polaris</title>
<link>http://www.cnblogs.com/zxuqian/p/8997858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxuqian/p/8997858.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Zuul是Spring Cloud提供的api网关和过滤组件，它提供如下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;认证&lt;/li&gt;
&lt;li&gt;过滤&lt;/li&gt;
&lt;li&gt;压力测试&lt;/li&gt;
&lt;li&gt;Canary测试&lt;/li&gt;
&lt;li&gt;动态路由&lt;/li&gt;
&lt;li&gt;服务迁移&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;静态请求处理&lt;/li&gt;
&lt;li&gt;动态流量管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本教程中，我们将用zuul，把web端的请求&lt;code&gt;/product&lt;/code&gt;转发到对应的产品服务上，并且定义一个pre过滤器来验证是否经过了zuul的转发。&lt;/p&gt;
&lt;h2 id=&quot;基础环境&quot;&gt;基础环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;li&gt;Maven 3.3.9&lt;/li&gt;
&lt;li&gt;IntelliJ 2018.1&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;项目源码&quot;&gt;项目源码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zxuqian/spring-cloud/tree/spring-cloud-tutorial-zuul&quot;&gt;Gitee码云&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建zuul服务&quot;&gt;创建Zuul服务&lt;/h2&gt;
&lt;p&gt;在IntelliJ中创建一个maven项目：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cn.zxuqian&lt;/li&gt;
&lt;li&gt;apiGateway&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后在&lt;code&gt;pom.xml&lt;/code&gt;中添加如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;project&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;         xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;         xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;kw&quot;&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;cn.zxuqian&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;apiGateway&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0.1.RELEASE&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- name has changed, before: spring-cloud-starter-zuul --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-zuul&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;Finchley.M9&lt;span class=&quot;kw&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;type&amp;gt;&lt;/span&gt;pom&lt;span class=&quot;kw&quot;&gt;&amp;lt;/type&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;import&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;java.version&amp;gt;&lt;/span&gt;1.8&lt;span class=&quot;kw&quot;&gt;&amp;lt;/java.version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;


    &lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;repositories&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;id&amp;gt;&lt;/span&gt;spring-milestones&lt;span class=&quot;kw&quot;&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Spring Milestones&lt;span class=&quot;kw&quot;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;url&amp;gt;&lt;/span&gt;https://repo.spring.io/libs-milestone&lt;span class=&quot;kw&quot;&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;snapshots&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;false&lt;span class=&quot;kw&quot;&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/snapshots&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/repositories&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，Spring官网的教程给的zuul的artifactId为spring-cloud-starter-zuul，这个是旧版zuul的名字，在我们的&lt;code&gt;Finchley.M9&lt;/code&gt;版本中已经更名为&lt;code&gt;spring-cloud-starter-netflix-zuul&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;src/main/resources/bootstrap.yml&lt;/code&gt;文件，指定&lt;code&gt;spring.application.name&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;application:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; zuul-server&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建&lt;code&gt;cn.zxuqian.Application&lt;/code&gt;类：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package cn.zxuqian;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import cn.zxuqian.filters.PreFilter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.boot.SpringApplication;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.boot.autoconfigure.SpringBootApplication;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@EnableZuulProxy&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Application {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(Application.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; PreFilter &lt;span class=&quot;fu&quot;&gt;preFilter&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;PreFilter&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了&lt;code&gt;@EnableZuulProxy&lt;/code&gt;来指定使用zuul的反向代理，把我们的请求转发到对应的服务器上。然后启用了&lt;code&gt;eureka&lt;/code&gt;的服务发现。Zuul默认也会使用Ribbon做负载均衡，所以可以通过eureka发现已注册的服务。&lt;code&gt;PreFilter&lt;/code&gt;是一个预过滤器，用来在request请求被处理之前进行一些操作，它的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package cn.zxuqian.filters;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.netflix.zuul.ZuulFilter;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.netflix.zuul.context.RequestContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.netflix.zuul.exception.ZuulException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.slf4j.Logger;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.slf4j.LoggerFactory;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.servlet.http.HttpServletRequest;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PreFilter &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ZuulFilter {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Logger log = LoggerFactory.&lt;span class=&quot;fu&quot;&gt;getLogger&lt;/span&gt;(PreFilter.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;filterType&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;pre&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;filterOrder&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;shouldFilter&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ZuulException {
        RequestContext ctx = RequestContext.&lt;span class=&quot;fu&quot;&gt;getCurrentContext&lt;/span&gt;();
        HttpServletRequest request = ctx.&lt;span class=&quot;fu&quot;&gt;getRequest&lt;/span&gt;();

        log.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; 方式请求 &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, request.&lt;span class=&quot;fu&quot;&gt;getMethod&lt;/span&gt;(), request.&lt;span class=&quot;fu&quot;&gt;getRequestURL&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()));

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;filterType&lt;/code&gt; - Zuul内置的filter类型有四种，&lt;code&gt;pre&lt;/code&gt;, &lt;code&gt;route&lt;/code&gt;，&lt;code&gt;post&lt;/code&gt;，&lt;code&gt;error&lt;/code&gt;，分别代表请求处理前，处理时，处理后和出错后。&lt;br/&gt;&lt;code&gt;filterOrder&lt;/code&gt; - 指定了该过滤器执行的顺序。&lt;br/&gt;&lt;code&gt;shouldFilter&lt;/code&gt; - 是否开启此过滤器。&lt;br/&gt;&lt;code&gt;run&lt;/code&gt; - 过滤器的业务逻辑。这里只是简单的log了一下reqeust的请求方式和请求的路径。&lt;/p&gt;
&lt;p&gt;接下来，在我们的配置中心的git仓库中创建&lt;code&gt;zuul-server.yml&lt;/code&gt;文件，并添加如下配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8083
&lt;span class=&quot;fu&quot;&gt;zuul:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;routes:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;products:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;path:&lt;/span&gt; /product/**
      &lt;span class=&quot;fu&quot;&gt;serviceId:&lt;/span&gt; product-service&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里配置了zuul的端口为8083，然后映射所有&lt;code&gt;/product/&lt;/code&gt;的请求到我们的&lt;code&gt;product-service&lt;/code&gt;服务上。如果不配置&lt;code&gt;serviceId&lt;/code&gt;，那么&lt;code&gt;products&lt;/code&gt;这个Key就会默认作为ServiceId，而我们的例子中，ServiceId包括了&lt;code&gt;-&lt;/code&gt;，所以在下边显示指定了ServiceId。配置完成后提交到git。&lt;/p&gt;
&lt;h2 id=&quot;更新productservice&quot;&gt;更新productService&lt;/h2&gt;
&lt;p&gt;productService的uri做了一点改动，使其更符合rest风格：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/list&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productList&lt;/span&gt;() {
    log.&lt;span class=&quot;fu&quot;&gt;info&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Access to /products endpoint&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;外套，夹克，毛衣，T恤&quot;&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里&lt;code&gt;@RequestMapping&lt;/code&gt;匹配的路径改为了&lt;code&gt;/list&lt;/code&gt;，之前是&lt;code&gt;/products&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;更新web客户端&quot;&gt;更新web客户端&lt;/h2&gt;
&lt;p&gt;在我们的web客户端的&lt;code&gt;ProductService&lt;/code&gt;中添加一个新的方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productListZuul&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;restTemplate&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getForObject&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http://zuul-server/product/list&quot;&lt;/span&gt;, String.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次我们直接请求&lt;code&gt;zuul-server&lt;/code&gt;服务，然后由它把我们的请求反射代理到&lt;code&gt;product-service&lt;/code&gt;服务。最后在&lt;code&gt;ProductController&lt;/code&gt;中添加一个请求处理方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/product/list&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;productListZuul&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; productService.&lt;span class=&quot;fu&quot;&gt;productListZuul&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用来处理&lt;code&gt;/product/list&lt;/code&gt;请求，然后调用&lt;code&gt;ProductService&lt;/code&gt;类中的方法。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;mvn spring-boot:run&lt;/code&gt;启动&lt;code&gt;configServer&lt;/code&gt;，&lt;code&gt;registry&lt;/code&gt;, &lt;code&gt;zuulServer&lt;/code&gt;, &lt;code&gt;productService&lt;/code&gt;，&lt;code&gt;web&lt;/code&gt;这几个工程，然后启动第二个&lt;code&gt;productService&lt;/code&gt;，使用&lt;code&gt;SERVER_PORT=8082 spring-boot:run&lt;/code&gt;。&lt;br/&gt;访问几次&lt;code&gt;http://localhost:8080/product/list&lt;/code&gt;，然后除了会在浏览器看到返回的结果，我们还会在&lt;code&gt;zuulServer&lt;/code&gt;的命令行窗口中看到如下字样：&lt;/p&gt;
&lt;blockquote readability=&quot;1.5740740740741&quot;&gt;
&lt;p&gt;GET 方式请求 &lt;a href=&quot;http://xuqians-imac:8083/product/list&quot; class=&quot;uri&quot;&gt;http://xuqians-imac:8083/product/list&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在两个&lt;code&gt;productService&lt;/code&gt;的命令行窗口中，我们还会看到随机出现的&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Access to /products endpoint&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明&lt;code&gt;zuulServer&lt;/code&gt;也会自动进行负载均衡。&lt;/p&gt;
&lt;p&gt;欢迎访问我的博客&lt;a&gt;张旭乾的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大家有什么想法欢迎来讨论。&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 04:22:00 +0000</pubDate>
<dc:creator>乾儿_Polaris</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zxuqian/p/8997858.html</dc:identifier>
</item>
<item>
<title>MySQL/MariaDB中的事务和事务隔离级别 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8997814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8997814.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog1&quot;&gt;&lt;span&gt;1.事务特性&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog2&quot;&gt;&lt;span&gt;2.事务分类&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog2.1&quot;&gt;&lt;span&gt;2.1 扁平事务&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog2.2&quot;&gt;&lt;span&gt;2.2 带保存点的扁平事务&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog2.3&quot;&gt;&lt;span&gt;2.3 链式事务&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog2.4&quot;&gt;&lt;span&gt;2.4 嵌套事务&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog2.5&quot;&gt;&lt;span&gt;2.5 分布式事务&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog3&quot;&gt;&lt;span&gt;3.事务控制语句&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog4&quot;&gt;&lt;span&gt;4.显式事务的次数统计&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog5&quot;&gt;&lt;span&gt;5.一致性非锁定读(快照查询)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog6&quot;&gt;&lt;span&gt;6.一致性锁定读&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog7&quot;&gt;&lt;span&gt;7.事务隔离级别&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog7.1&quot;&gt;&lt;span&gt;7.1 设置和查看事务隔离级别&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog7.2&quot;&gt;&lt;span&gt;7.2 read uncommitted&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog7.3&quot;&gt;&lt;span&gt;7.3 read committed&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog7.4&quot;&gt;&lt;span&gt;7.4 repeatable read&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html#blog7.5&quot;&gt;&lt;span&gt;7.5 serializable&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;事务具有ACID特性：原子性(A,atomicity)、一致性(C,consistency)、隔离性(I,isolation)、持久性(D,durabulity)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;：事务内的所有操作要么都执行，要么都不执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;：事务开始和结束前后，数据都满足数据一致性约束，而不是经过事务控制之后数据变得不满足条件或业务规则。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：事务之间不能互影响，它们必须完全的各行其道，互不可见。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt;：事务完成后，该事务内涉及的数据必须持久性的写入磁盘保证其持久性。当然，这是从事务的角度来考虑的的持久性，从操作系统故障或硬件故障来说，这是不一定的。&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;扁平事务&lt;/li&gt;
&lt;li&gt;带保存点的扁平事务&lt;/li&gt;
&lt;li&gt;链事务&lt;/li&gt;
&lt;li&gt;嵌套事务&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-1-&quot;&gt;2.1 扁平事务&lt;/h2&gt;
&lt;p&gt;即最常见的事务。由begin开始，commit或rollback结束，中间的所有操作要么都回滚要么都提交。扁平事务在生产环境中占绝大多数使用情况。因此每一种数据库产品都支持扁平事务。&lt;/p&gt;
&lt;p&gt;扁平事务的缺点在于无法回滚或提交一部分，只能全部回滚或全部提交，所以就有了&quot;带有保存点&quot;的扁平事务。&lt;/p&gt;

&lt;h2 id=&quot;2-2-&quot;&gt;2.2 带有保存点的扁平事务&lt;/h2&gt;
&lt;p&gt;通过在事务内部的某个位置使用savepoint(SQL Server中称为检查点，即checkpoint)，将来可以在事务中回滚到此位置。&lt;/p&gt;
&lt;p&gt;MariaDB/MySQL中设置保存点的命令为:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;savepoint&lt;/span&gt; [savepoint_name]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回滚到指定保存点的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;rollback&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; savepoint_name&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除一个保存点的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;release&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;savepoint&lt;/span&gt; savepoint_name&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，&lt;strong&gt;&lt;span&gt;扁平事务也是有保存点的，只不过它只有一个隐式的保存点，且自动建立在事务开始的位置&lt;/span&gt;，&lt;/strong&gt;因此扁平事务只能回滚到事务开始处。&lt;/p&gt;

&lt;h2 id=&quot;2-3-&quot;&gt;2.3 链式事务&lt;/h2&gt;
&lt;p&gt;链式事务是保存点扁平事务的变种。它在一个事务提交的时候自动隐式的将上下文传给下一个事务，也就是说一个事务的提交和下一个事务的开始是原子性的，下一个事务可以看到上一个事务的处理结果。通俗地说，就是事务的提交和事务的开始是链接式下去的。&lt;/p&gt;
&lt;p&gt;这样的事务类型，在提交事务的时候，会释放要提交事务内所有的锁和要提交事务内所有的保存点。因此链式事务只能回滚到当前所在事务的保存点，而不能回滚到已提交的事务中的保存点。&lt;/p&gt;

&lt;h2 id=&quot;2-4-&quot;&gt;2.4 嵌套事务&lt;/h2&gt;
&lt;p&gt;嵌套事务由一个顶层事务控制所有的子事务。子事务的提交完成后不会真的提交，而是等到顶层事务提交才真正的提交。&lt;/p&gt;
&lt;p&gt;关于嵌套事务的机制，主要有以下3个结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回滚内部事务的同时会回滚到外部事务的起始点。&lt;/li&gt;
&lt;li&gt;事务提交时从内向外依次提交。&lt;/li&gt;
&lt;li&gt;回滚外部事务的同时会回滚所有事务，包括已提交的内部事务。因为只提交内部事务时没有真的提交。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管怎么样，最好少用嵌套事务。且MariaDB/MySQL不原生态支持嵌套事务(SQL Server支持)。&lt;/p&gt;

&lt;h2 id=&quot;2-5-&quot;&gt;2.5 分布式事务&lt;/h2&gt;
&lt;p&gt;将多个服务器上的事务(节点)组合形成一个遵循事务特性(acid)的分布式事务。&lt;/p&gt;
&lt;p&gt;例如在工行atm机转账到建行用户。工行atm机所在数据库是一个事务节点A，建行数据库是一个事务节点B，仅靠工行atm机是无法完成转账工作的，因为它控制不了建行的事务。所以它们组成一个分布式事务：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.atm机发出转账口令。&lt;/li&gt;
&lt;li&gt;2.atm机从工行用户减少N元。&lt;/li&gt;
&lt;li&gt;3.在建行用户增加N元。&lt;/li&gt;
&lt;li&gt;4.在atm机上返回转账成功或失败。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面涉及了两个事务节点，这些事务节点之间的事务必须同时具有acid属性，要么所有的事务都成功，要么所有的事务都失败，不能只成功atm机的事务，而建行的事务失败。&lt;/p&gt;
&lt;p&gt;MariaDB/MySQL的分布式事务使用两段式提交协议(2-phase commit,2PC)。最重要的是，MySQL 5.7.7之前，MySQL对分布式事务的支持一直都不完善(第一阶段提交后不会写binlog，导致宕机丢失日志)，这个问题持续时间长达数十年，直到MySQL 5.7.7，才完美支持分布式事务。相关内容可参考网上一篇文章：&lt;span&gt;&lt;a href=&quot;https://www.linuxidc.com/Linux/2016-02/128053.htm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.linuxidc.com/Linux/2016-02/128053.htm&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。遗憾的是，MariaDB至今(MariaDB 10.3.6)都没有解决这个问题。&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;code&gt;begin 和 start transaction&lt;/code&gt;表示显式开启一个事务。它们之间并没有什么区别，但是在存储过程中，begin会被识别成begin...end的语句块，所以存储过程只能使用start transaction来显式开启一个事务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commit 和 commit work&lt;/code&gt;用于提交一个事务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rollbac 和 rollback work&lt;/code&gt;用于回滚一个事务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;savepoint identifier&lt;/code&gt;表示在事务中创建一个保存点。一个事务中允许存在多个保存点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;release savepoint identifier&lt;/code&gt;表示删除一个保存点。当要删除的保存点不存在的时候会抛出异常。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rollback to savepoint&lt;/code&gt;表示回滚到指定的保存点，回滚到保存点后，该保存点之后的所有操纵都被回滚。注意，rollback to不会结束事务，只是回到某一个保存点的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set transaction&lt;/code&gt;用来设置事务的隔离级别。可设置的隔离级别有read uncommitted/read committed/repeatable read/serializable。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;commit与commit work以及rollback与rollback work作用是一样的。但是他们的作用却和变量completion_type的值有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180506104848672-2109792794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如将completion_type设置为1，进行测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; completion_type=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
mysql&amp;gt; begin;
mysql&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;insert &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; ttt &lt;span class=&quot;hljs-title&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;
mysql&amp;gt; commit work;
mysql&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;insert &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; ttt &lt;span class=&quot;hljs-title&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2000&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;
mysql&amp;gt; rollback;
mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id&amp;gt;=&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;;
+------+
| id   |
+------+
| &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; |
+------+
&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;row &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;0.00&lt;/span&gt; sec)&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;begin开始事务后，插入了值为1000的记录，commit work了一次，然后再插入了值为2000的记录后rollback，查询结果结果中只显示了1000，而没有2000，因为commit work提交后自动又开启了一个事务，使用rollback会回滚该事务。&lt;/p&gt;
&lt;p&gt;将completion_type设置为2，进行测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; completion_type=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;
mysql&amp;gt; begin;
mysql&amp;gt; insert &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;;
mysql&amp;gt; commit;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交后，再查询或者进行其他操作，结果提示已经和MariaDB/MySQL服务器断开连接了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;
ERROR &lt;span class=&quot;hljs-number&quot;&gt;2006&lt;/span&gt; (HY000): MySQL server has gone away
No connection. Trying to reconnect...
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;通过全局状态变量&lt;code&gt;com_commit&lt;/code&gt;和&lt;code&gt;com_rollback&lt;/code&gt;可以查看当前已经显式提交和显式回滚事务的次数。还可以看到回滚到保存点的次数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; show global status like &quot;%com_commit%&quot;;
&lt;span class=&quot;hljs-addition&quot;&gt;+---------------+-------+&lt;/span&gt;
| Variable_name | Value |
&lt;span class=&quot;hljs-addition&quot;&gt;+---------------+-------+&lt;/span&gt;
| Com_commit    | 14    |
&lt;span class=&quot;hljs-addition&quot;&gt;+---------------+-------+&lt;/span&gt;
mysql&amp;gt; show global status like &quot;%com_rollback%&quot;;
&lt;span class=&quot;hljs-addition&quot;&gt;+---------------------------+-------+&lt;/span&gt;
| Variable_name             | Value |
&lt;span class=&quot;hljs-addition&quot;&gt;+---------------------------+-------+&lt;/span&gt;
| Com_rollback              | 24    |
| Com_rollback_to_savepoint | 0     |
&lt;span class=&quot;hljs-addition&quot;&gt;+---------------------------+-------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;在innodb存储引擎中，存在一种数据查询方式：快照查询。因为查询的是快照数据，所以查询时不申请共享锁。&lt;/p&gt;
&lt;p&gt;当进行一致性非锁定读查询的时候，查询操作不会去等待记录上的独占锁释放，而是直接去读取快照数据。快照数据是通过undo段来实现的，因此它基本不会产生开销。显然，通过这种方式，可以极大的提高读并发性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201805/733013-20180506105838093-1299081173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;快照数据其实是&lt;span&gt;&lt;strong&gt;行版本数据&lt;/strong&gt;&lt;/span&gt;，一个行记录可能会存在多个行版本，并发时这种读取行版本的方式称为多版本并发控制(MVCC)。在隔离级别为read committed和repeatable read时，采取的查询方式就是一致性非锁定读方式。但是，不同的隔离级别下，读取行版本的方式是不一样的。在后面介绍对应的隔离级别时会作出说明。&lt;/p&gt;
&lt;p&gt;下面是在innodb默认的隔离级别是repeatable read下的实验，该隔离级别下，事务总是在开启的时候获取最新的行版本，并一直持有该版本直到事务结束。更多的&quot;一致性非锁定读&quot;见后文说明read committed和repeatable read部分。&lt;/p&gt;
&lt;p&gt;当前示例表ttt的记录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话1执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; begin;
mysql&amp;gt; update ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; begin;
mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。&lt;/p&gt;
&lt;p&gt;回到会话1提交事务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; commit;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再回到会话2中查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次去会话1更新该记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; begin;
mysql&amp;gt; update ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;
mysql&amp;gt; commit;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再回到会话2执行查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是repeatable read隔离级别下的一致性非锁定读的特性。&lt;/p&gt;
&lt;p&gt;当然，MySQL也支持一致性锁定读的方式。&lt;/p&gt;


&lt;p&gt;在隔离级别为read committed和repeatable read时，采取的查询方式就是一致性非锁定读方式。但是在某些情况下，需要人为的对读操作进行加锁。MySQL中对这种方式的支持是通过在select语句后加上&lt;code&gt;lock in share mode&lt;/code&gt;或者&lt;code&gt;for update&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;select ... from ... where ... lock in share mode;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select ...from ... where ... for update;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用lock in share mode会对select语句要查询的记录加上一个共享锁(S)，使用for update语句会对select语句要查询的记录加上独占锁(X)。&lt;/p&gt;
&lt;p&gt;另外，对于一致性非锁定读操作，即使要查询的记录已经被for update加上了独占锁，也一样可以读取，就和纯粹的update加的锁一样，只不过此时读取的是快照数据而已。&lt;/p&gt;


&lt;p&gt;SQL标准定义了4中隔离级别：read uncommitted、read committed、repeatable read、serializable。&lt;/p&gt;
&lt;p&gt;MariaDB/MySQL也支持这4种隔离级别。但是要注意的是，MySQL中实现的隔离级别和SQL Server实现的隔离级别在同级别上有些差别。在后面有必要说明地方会给出它们的差异之处。&lt;/p&gt;
&lt;p&gt;MariaDB/MySQL中默认的隔离级别是repeatable read，SQL Server和oracle的默认隔离级别都是read committed。&lt;/p&gt;
&lt;p&gt;事务特性(ACID)中的隔离性(I,isolation)就是隔离级别，它通过锁来实现。也就是说，&lt;span&gt;&lt;strong&gt;设置不同的隔离级别，其本质只是控制不同的锁行为&lt;/strong&gt;&lt;/span&gt;。例如操作是否申请锁，什么时候申请锁，申请的锁是立刻释放还是持久持有直到事务结束才释放等。&lt;/p&gt;

&lt;h2 id=&quot;7-1-&quot;&gt;7.1 设置和查看事务隔离级别&lt;/h2&gt;
&lt;p&gt;隔离级别是基于会话设置的，当然也可以基于全局进行设置，设置为全局时，不会影响当前会话的级别。设置的方法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;isolation&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;level&lt;/span&gt; {type}
type:
    &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt; uncommitted | &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt; committed | repeatable &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;serializable&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者直接修改变量值也可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; @@&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt;.tx_isolation = &lt;span class=&quot;hljs-string&quot;&gt;'read-uncommitted'&lt;/span&gt; | &lt;span class=&quot;hljs-string&quot;&gt;'read-committed'&lt;/span&gt; | &lt;span class=&quot;hljs-string&quot;&gt;'repeatable-read'&lt;/span&gt; | &lt;span class=&quot;hljs-string&quot;&gt;'serializable'&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; @@&lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt;.tx_isolation = &lt;span class=&quot;hljs-string&quot;&gt;'read-uncommitted'&lt;/span&gt; | &lt;span class=&quot;hljs-string&quot;&gt;'read-committed'&lt;/span&gt; | &lt;span class=&quot;hljs-string&quot;&gt;'repeatable-read'&lt;/span&gt; | &lt;span class=&quot;hljs-string&quot;&gt;'serializable'&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看当前会话的隔离级别方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; select @&lt;span class=&quot;hljs-annotation&quot;&gt;@tx&lt;/span&gt;_isolation;
mysql&amp;gt; select @&lt;span class=&quot;hljs-annotation&quot;&gt;@global&lt;/span&gt;.tx_isolation;
mysql&amp;gt; select @&lt;span class=&quot;hljs-annotation&quot;&gt;@tx&lt;/span&gt;_isolation;select @&lt;span class=&quot;hljs-annotation&quot;&gt;@global&lt;/span&gt;.tx_isolation;
+-----------------+
| @&lt;span class=&quot;hljs-annotation&quot;&gt;@tx&lt;/span&gt;_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
+-----------------------+
| @&lt;span class=&quot;hljs-annotation&quot;&gt;@global&lt;/span&gt;.tx_isolation |
+-----------------------+
| REPEATABLE-READ       |
+-----------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，事务隔离级别的设置只需在需要的一端设置，不用在两边会话都设置。例如想要让会话2的查询加锁，则只需在会话2上设置serializable，在会话1设置的serializable对会话2是没有影响的，这和SQL Server中一样。但是，MariaDB/MySQL除了serializable隔离级别，其他的隔离级别都默认会读取旧的行版本，所以查询永远不会造成阻塞。而SQL Server中只有基于快照的两种隔离级别才会读取行版本，所以在4种标准的隔离级别下，如果查询加的S锁被阻塞，查询会进入锁等待。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在MariaDB/MySQL中不会出现更新丢失的问题，因为独占锁一直持有直到事务结束&lt;/strong&gt;&lt;/span&gt;。当1个会话开启事务A修改某记录，另一个会话也开启事务B修改该记录，该修改被阻塞，当事务A提交后，事务B中的更新立刻执行成功，但是执行成功后查询却发现数据并没有随着事务B的想法而改变，因为这时候事务B更新的那条记录已经不是原来的记录了。但是事务A回滚的话，事务B是可以正常更新的，但这没有丢失更新。&lt;/p&gt;

&lt;h2 id=&quot;7-2-read-uncommitted&quot;&gt;7.2 read uncommitted&lt;/h2&gt;
&lt;p&gt;该级别称为未提交读，即允许读取未提交的数据。&lt;/p&gt;
&lt;p&gt;在该隔离级别下，读数据的时候不会申请读锁，所以也不会出现查询被阻塞的情况。&lt;/p&gt;
&lt;p&gt;在会话1执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; ttt(id &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果会话1的隔离级别不是默认的，那么在执行update的过程中，可能会遇到以下错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ERROR 1665 (HY000): Cannot &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;execute&lt;/span&gt; statement: impossible &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;write&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;log&lt;/span&gt; since BINLOG_FORMAT = STATEMENT &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;least&lt;/span&gt; one &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; uses a storage &lt;span class=&quot;hljs-keyword&quot;&gt;engine&lt;/span&gt; limited &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt;-based logging. &lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; limited &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt;-logging &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;isolation&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;READ&lt;/span&gt; COMMITTED &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;READ&lt;/span&gt; UNCOMMITTED.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是read committed和read uncommitted两个隔离级别只允许row格式的二进制日志记录格式。而当前的二进制日志格式记录方式为statement时就会报错。要解决这个问题，只要将格式设置为row或者mixed即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; @@&lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt;.binlog_format=&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;isolation&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt; uncommitted;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
+
| id   |
+
|   10 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现查询的结果是update后的数据，但是这个数据是会话1未提交的数据。这是&lt;span&gt;&lt;strong&gt;脏读&lt;/strong&gt;&lt;/span&gt;的问题，即读取了未提交的脏数据。&lt;/p&gt;
&lt;p&gt;如果此时会话1进行了回滚操作，那么会话2上查询的结果又变成了id=1。&lt;/p&gt;
&lt;p&gt;在会话1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;rollback&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2上查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是&lt;span&gt;&lt;strong&gt;读不一致&lt;/strong&gt;&lt;/span&gt;问题。即同一个会话中对同一条记录的读取结果不一致。&lt;/p&gt;
&lt;p&gt;read uncommitted一般不会在生产环境中使用，因为问题太多，会导致&lt;span&gt;&lt;strong&gt;脏读、丢失的更新、幻影读、读不一致&lt;/strong&gt;&lt;/span&gt;的问题。但由于不申请读锁，从理论上来说，它的并发性是最佳的。所以在某些特殊情况下还是会考虑使用该级别。&lt;/p&gt;
&lt;p&gt;要解决脏读、读不一致问题，只需在查询记录的时候加上共享锁即可。这样在其他事务更新数据的时候就无法查询到更新前的记录。这就是read commmitted隔离级别。&lt;/p&gt;

&lt;h2 id=&quot;7-3-read-committed&quot;&gt;7.3 read committed&lt;/h2&gt;
&lt;p&gt;对于熟悉SQL Server的人来说，在说明这个隔离级别之前，必须先给个提醒：MariaDB/MySQL中的提交读和SQL Server中的提交读完全不一样，&lt;span&gt;&lt;strong&gt;MariaDB/MySQL中该级别基本类似于SQL Server中基于快照的提交读&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在SQL Server中，提交读的查询会申请共享锁，并且在查询结束的一刻立即释放共享锁，如果要查询的记录正好被独占锁锁住，则会进入锁等待，而没有被独占锁锁住的记录则可以正常查询。SQL Server中基于快照的提交读实现的是语句级的事务一致性，每执行一次操作事务序列号加1，并且每次查询的结果都是最新提交的行版本快照。&lt;/p&gt;
&lt;p&gt;也就是说，MariaDB/MySQL中read committed级别总是会读取最新提交的行版本。这在MySQL的innodb中算是一个术语:&quot;&lt;span&gt;&lt;strong&gt;一致性非锁定读&lt;/strong&gt;&lt;/span&gt;&quot;，即只读取快照数据，不加共享锁。这在前文已经说明过。&lt;/p&gt;
&lt;p&gt;MariaDB/MySQL中的read committed隔离级别下，除非是要检查外键约束或者唯一性约束需要用到&lt;span&gt;&lt;strong&gt;gap lock算法&lt;/strong&gt;&lt;/span&gt;，其他时候都不会用到。也就是说在此隔离级别下，一般来说只会对行进行锁定，不会锁定范围，所以会导致&lt;span&gt;&lt;strong&gt;幻影读&lt;/strong&gt;&lt;/span&gt;问题。&lt;/p&gt;
&lt;p&gt;这里要演示的就是在该级别下，会不断的读取最新提交的行版本数据。&lt;/p&gt;
&lt;p&gt;当前示例表ttt的记录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话1中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; @@&lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt;.tx_isolation=&lt;span class=&quot;hljs-string&quot;&gt;'read-committed'&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会话2中查询得到的结果为id=1，因为查询的是最新提交的快照数据，而最新提交的快照数据就是id=1。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+
| id   |
+
|    1 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在将会话1中的事务提交。&lt;/p&gt;
&lt;p&gt;在会话1中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2中查询记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
+
| id   |
+
|  100 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果为id=100，因为这个值是最新提交的。&lt;/p&gt;
&lt;p&gt;再次在会话1中修改该值并提交事务。&lt;/p&gt;
&lt;p&gt;在会话1中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
+
| id   |
+
| 1000 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现结果变成了1000，因为1000是最新提交的数据。&lt;/p&gt;
&lt;p&gt;read committed隔离级别的行版本读取特性，在和repeatable read隔离级别比较后就很容易理解。&lt;/p&gt;

&lt;h2 id=&quot;7-4-repeatable-read&quot;&gt;7.4 repeatable read&lt;/h2&gt;
&lt;p&gt;同样是和上面一样的废话，对于熟悉SQL Server的人来说，在说明这个隔离级别之前，必须先给个提醒：MariaDB/MySQL中的重复读和SQL Server中的重复读完全不一样，&lt;span&gt;&lt;strong&gt;MariaDB/MySQL中该级别基本类似于SQL Server中快照隔离级别&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在SQL Server中，重复读的查询会申请共享锁，并且在查询结束的一刻不释放共享锁，而是持有到事务结束。所以会造成比较严重的读写并发问题。SQL Server中快照隔离级别实现的是事务级的事务一致性，每次事务开启的时候获取最新的已提交行版本，只要事务不结束，读取的记录将一直是该行版本中的数据，不管其他事务是否已经提交过对应的数据了。但是SQL Server中的快照隔离会有更新冲突：当检测到两边都想要更新同一记录时，会检测出更新冲突，这样会提前结束事务(进行的是回滚操作)而不用再显式地commit或者rollback。&lt;/p&gt;
&lt;p&gt;也就是说，MariaDB/MySQL中repeatable read级别&lt;strong&gt;&lt;span&gt;总是会在事务开启的时候读取最新提交的行版本，并将该行版本一直持有到事务结束&lt;/span&gt;。&lt;/strong&gt;但是MySQL中的repeatable read级别下不会像SQL Server一样出现更新冲突的问题。&lt;/p&gt;
&lt;p&gt;前文说过read committed隔离级别下，读取数据时总是会去获取最新已提交的行版本。这是这两个隔离级别在&quot;一致性非锁定读&quot;上的区别。&lt;/p&gt;
&lt;p&gt;另外，MariaDB/MySQL中的repeatable read的加锁方式是&lt;span&gt;&lt;strong&gt;next-key lock算法&lt;/strong&gt;&lt;/span&gt;，它会进行范围锁定。这就避免了幻影读的问题(官方手册上说无法避免)。在标准SQL中定义的隔离级别中，需要达到serializable级别才能避免幻影读问题，也就是说MariaDB/MySQL中的repeatable read隔离级别已经达到了其他数据库产品(如SQL Server)的serializable级别，而且SQL Server中的serializable加范围锁时，在有索引的时候式锁范围比较不可控(你不知道范围锁锁住哪些具体的范围)，而在MySQL中是可以判断锁定范围的(见&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8995475.html#blog4.3&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;innodb锁算法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;这里要演示的就是在该级别下，读取的行版本数据是不随提交而改变的。&lt;/p&gt;
&lt;p&gt;当前示例表ttt的记录如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from ttt;
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
| id   |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
|    1 |
|    2 |
&lt;span class=&quot;hljs-addition&quot;&gt;+------+&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话1执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在会话2中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; @@&lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt;.tx_isolation=&lt;span class=&quot;hljs-string&quot;&gt;'repeatable-read'&lt;/span&gt;;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
+
| id   |
+
|    1 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询的结果和预期的一样，来自开启事务前最新提交的行版本数据。&lt;/p&gt;
&lt;p&gt;回到会话1提交事务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再回到会话2中查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
+
| id   |
+
|    1 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次去会话1更新该记录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;begin&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt; ttt &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;where&lt;/span&gt; id=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt;;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再回到会话2执行查询：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; ttt;&lt;/span&gt;
+
| id   |
+
|    1 |
|    2 |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现结果根本就不会改变，因为会话2开启事务时获取的行版本的id=1，所以之后读取的一直都是id=1所在的行版本。&lt;/p&gt;

&lt;h2 id=&quot;7-5-serializable&quot;&gt;7.5 serializable&lt;/h2&gt;
&lt;p&gt;在SQL Server中，serializable隔离级别会将查询申请的共享锁持有到事务结束，且申请的锁是范围锁，范围锁的情况根据表有无索引而不同：无索引时锁定整个表，有索引时锁定某些范围，至于锁定哪些具体的范围我发现是不可控的(至少我无法推测和计算)。这样就避免了幻影读的问题。&lt;/p&gt;
&lt;p&gt;这种问题在MariaDB/MySQL中的repeatable read级别就已经实现了，MariaDB/MySQL中的next-key锁算法在加范围锁时也分有无索引：无索引时加锁整个表(实际上不是表而是无穷大区间的行记录)，有索引时加锁部分可控的范围。&lt;/p&gt;
&lt;p&gt;MariaDB/MySQL中的serializable其实类似于repeatable read，只不过所有的select语句会自动在后面加上&lt;code&gt;lock in share mode&lt;/code&gt;。也就是说会对所有的读进行加锁，而不是读取行版本的快照数据，也就不再支持&quot;一致性非锁定读&quot;。这样就实现了串行化的事务隔离：每一个事务必须等待前一个事务(哪怕是只有查询的事务)结束后才能进行哪怕只是查询的操作。&lt;/p&gt;
&lt;p&gt;这个隔离级别对并发性来说，显然是有点太严格了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8997814.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8997814.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 04:04:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8997814.html</dc:identifier>
</item>
<item>
<title>JS基础：this的指向以及call、apply的作用 - 沉江、小鱼</title>
<link>http://www.cnblogs.com/blog-cxj2017522/p/8997800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog-cxj2017522/p/8997800.html</guid>
<description>&lt;p class=&quot;title&quot;&gt;this 的指向&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;25.5&quot;&gt;
&lt;p&gt;　　在具体的实际应用中，this 的指向无法在函数定义时确定，而是在函数执行的时候才确定的，根据执行时的环境大致可以分为以下3种：&lt;/p&gt;
&lt;p&gt;1、当函数作为普通函数调用时，this 指向全局对象&lt;/p&gt;
&lt;p&gt;2、当函数作为对象的方法调用时，this 指向该对象&lt;/p&gt;
&lt;p&gt;3、当函数作为构造器调用时，this 指向新创建的对象&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.name = 'myname'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}
getName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出myname&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; boy =&lt;span&gt; {
    name: &lt;/span&gt;'Bob'&lt;span&gt;,
    getName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}
boy.getName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Bob&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例三：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Boy(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boy1 = &lt;span&gt;new&lt;/span&gt; Boy('Bob'&lt;span&gt;);
console.log(boy1.name); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Bob&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于示例三，还有一种特殊情况，就是当构造函数通过 &quot;return&quot; 返回的是一个对象的时候，此次运算的最终结果返回的就是这个对象，而不是新创建的对象，因此 this 在这种情况下并没有什么用。&lt;/p&gt;
&lt;p&gt;示例四：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Boy(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { &lt;span&gt;//&lt;span&gt;返回一个对象&lt;/span&gt;&lt;/span&gt;
        name: &lt;/span&gt;'Jack'&lt;span&gt;
    }
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boy1 = &lt;span&gt;new&lt;/span&gt; Boy('Bob'&lt;span&gt;);
console.log(boy1.name); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Jack&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例五：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Boy(name) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回非对象&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boy1 = &lt;span&gt;new&lt;/span&gt; Boy('Bob'&lt;span&gt;);
console.log(boy1.name); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Bob&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;title&quot;&gt;call 和 apply 的作用&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;28&quot;&gt;
&lt;p&gt;　　apply 接受两个参数，第一个参数指定了函数体内 this 的指向，第二个参数是一个数组或类数组，用于传递被调用函数的参数列表。&lt;/p&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getInfo() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name+' like '+arguments[0]+' and '+arguments[1&lt;span&gt;]);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boy1 =&lt;span&gt; {
    name: &lt;/span&gt;'Bob'&lt;span&gt;,
    age: &lt;/span&gt;12&lt;span&gt;
}
getInfo.apply(boy1,[&lt;/span&gt;'sing','swimming']); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Bob like sing and swimming&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　call 传入参数的数量是不固定的，跟 apply 相同的是，第一个参数也是用于指定函数体内 this 的指向，从第二个参数开始往后，每个参数被依次传入被调用函数。&lt;/p&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getInfo() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name+' like '+arguments[0]+' and '+arguments[1&lt;span&gt;]);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boy1 =&lt;span&gt; {
    name: &lt;/span&gt;'Bob'&lt;span&gt;,
    age: &lt;/span&gt;12&lt;span&gt;
}
getInfo.call(boy1,&lt;/span&gt;'sing','shopping'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Bob like sing and shopping&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此外，大部分高级浏览器还实现了 bind 方法，它与 call 和 apply 的区别在于 bind 只是改变函数内部 this 的指向，但不会立即执行，你需要显示调用它。&lt;/p&gt;
&lt;p&gt;示例三：模拟浏览器的 bind 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Function.prototype.bind = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.apply(obj,arguments);
    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    name: &lt;/span&gt;'Bob'&lt;span&gt;,
    age: &lt;/span&gt;12&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; func = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name+' like '+arguments[0]+' and '+arguments[1&lt;span&gt;]);
}.bind(obj);
func(&lt;/span&gt;'sing','shopping');
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;title&quot;&gt;丢失的 this&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;19.5&quot;&gt;
&lt;p&gt;　　在某些情况下会丢失 this 的指向，此时，我们就需要借助 call、apply 和 bind 来改变 this 的指向问题。&lt;/p&gt;
&lt;p&gt;示例一：当 &quot;getName&quot; 方法作为 &quot;boy&quot; 对象的属性调用时，this 指向 &quot;boy&quot; 对象，当另外一个变量引用 &quot;getName&quot; 方法时，因为它是作为普通函数调用，所以 this 指向全局对象window&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; boy =&lt;span&gt; {
    name: &lt;/span&gt;'Bob'&lt;span&gt;,
    getName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}
boy.getName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出Bob&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; getBoyName =&lt;span&gt; boy.getName;
getBoyName(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出undefind&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：即使在函数内部定义的函数，如果它作为普通对象调用，this 同样指向 window 对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; boy1 =&lt;span&gt; {
    name: &lt;/span&gt;'Bob'&lt;span&gt;,
    age: &lt;/span&gt;12&lt;span&gt;,
    getInfo: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAge() {
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age);
        }
        getAge();
    }
}
boy1.getInfo(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Bob&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefind&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Sun, 06 May 2018 04:01:00 +0000</pubDate>
<dc:creator>沉江、小鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog-cxj2017522/p/8997800.html</dc:identifier>
</item>
<item>
<title>使用 JMeter 进行压力测试 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/8971531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/8971531.html</guid>
<description>&lt;h2 id=&quot;一.前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;压力测试是每一个Web应用程序上线之前都需要做的一个测试，他可以帮助我们发现系统中的瓶颈问题，减少发布到生产环境后出问题的几率；预估系统的承载能力，使我们能根据其做出一些应对措施。所以压力测试是一个非常重要的步骤，下面我带大家来使用一款压力测试工具JMeter。&lt;/p&gt;
&lt;h2 id=&quot;二.关于jmeter&quot;&gt;二.关于JMeter&lt;/h2&gt;
&lt;p&gt;Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。&lt;br/&gt;Apache jmeter 可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，java 对象，数据库和查询，FTP服务器等等）的性能进行测试。它可以用于对服务器、网络或对象模拟繁重的负载来测试它们的强度或分析不同压力类型下的整体性能。你可以使用它做性能的图形分析或在大并发负载测试你的服务器/脚本/对象。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://jmeter.apache.org/download_jmeter.cgi&quot; class=&quot;uri&quot;&gt;http://jmeter.apache.org/download_jmeter.cgi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里我选用了 4.0 版本的二进制包：&lt;a href=&quot;http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip&quot; class=&quot;uri&quot;&gt;http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-4.0.zip&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5322580645161&quot;&gt;
&lt;p&gt;更多内容介绍 &lt;a href=&quot;https://baike.baidu.com/item/Jmeter/3104456&quot; class=&quot;uri&quot;&gt;https://baike.baidu.com/item/Jmeter/3104456&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三.准备工作&quot;&gt;三.准备工作&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为JMeter是使用JAVA写的，所以使用JMeter之前，先安装JAVA环境，本文就不讲不如安装JAVA环境了。.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JAVA环境变量配置:&lt;a href=&quot;https://jingyan.baidu.com/article/fd8044fa2c22f15031137a2a.html&quot; class=&quot;uri&quot;&gt;https://jingyan.baidu.com/article/fd8044fa2c22f15031137a2a.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压下载的二进制包，进入bin目录，使用&lt;code&gt;jmeter.bat&lt;/code&gt;启动程序。&lt;/p&gt;
&lt;p&gt;启动之后会有两个窗口，一个cmd窗口，一个JMeter的 GUI。前面&lt;strong&gt;不要忽略&lt;/strong&gt;CMD窗口的提示信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429182446546-1074951655.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JMeter:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429182511445-1603366546.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cmd窗口的提示信息&quot;&gt;CMD窗口的提示信息&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;================================================================================
Don't use GUI mode for load testing !, only for Test creation and Test debugging.
For load testing, use NON GUI Mode:
   jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]
&amp;amp; increase Java Heap to meet your test requirements:
   Modify current env variable HEAP=&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m&quot; in the jmeter batch file
Check : https://jmeter.apache.org/usermanual/best-practices.html
================================================================================&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的意思就是：不要使用GUI运行压力测试，GUI仅用于压力测试的创建和调试；执行压力测试请不要使用GUI。使用下面的命令来执行测试：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且修改JMeter批处理文件的环境变量：&lt;code&gt;HEAP=&quot;-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;更改语言为中文&quot;&gt;更改语言为中文&lt;/h3&gt;
&lt;p&gt;官方默认为我们提供了简体中文。通过 【Options】-&amp;gt;【Choose Language】变更为简体中文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429183255514-2033730042.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.创建测试&quot;&gt;四.创建测试&lt;/h2&gt;
&lt;h3 id=&quot;创建线程组&quot;&gt;1.创建线程组&lt;/h3&gt;
&lt;p&gt;在“测试计划”上右键 【添加】--&amp;gt;【Threads(Users)】--&amp;gt;【线程组】。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429184947149-2117252461.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置线程数和循环次数。我这里设置线程数为500，循环一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429185411556-710704956.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置元件&quot;&gt;2.配置元件&lt;/h3&gt;
&lt;p&gt;在我们刚刚创建的线程组上右键 【添加】--&amp;gt;【配置元件】--&amp;gt;【HTTP请求默认值】。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429185539424-1104651080.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置我们需要进行测试的程序协议、地址和端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429185907741-859427144.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当所有的接口测试的访问域名和端口都一样时，可以使用该元件，一旦服务器地址变更，只需要修改请求默认值即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;构造http请求&quot;&gt;3.构造HTTP请求&lt;/h3&gt;
&lt;p&gt;在“线程组”右键 【添加-】-&amp;gt;【samlper】--&amp;gt;【HTTP 请求】设置我们需要测试的API的请求路径和数据。我这里是用的json&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180429201416944-2060347522.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加http请求头&quot;&gt;4.添加HTTP请求头&lt;/h3&gt;
&lt;p&gt;在我们刚刚创建的线程组上右键 【添加】--&amp;gt;【配置元件】--&amp;gt;【HTTP信息头管理器】。&lt;/p&gt;
&lt;p&gt;因为我要传输的数据为json，所以设置一个 &lt;code&gt;Content-Type:application/json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201805/668104-20180505141719591-1926998849.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加断言&quot;&gt;5.添加断言&lt;/h3&gt;
&lt;p&gt;在我们刚刚创建的线程组上右键 【添加】--&amp;gt;【断言】--&amp;gt;【响应断言】。&lt;/p&gt;
&lt;p&gt;根据响应的数据来判断请求是否正常。我在这里只判断的响应代码是否为200。还可以配置错误信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201805/668104-20180505141843551-1345786493.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加察看结果树&quot;&gt;6.添加察看结果树&lt;/h3&gt;
&lt;p&gt;在我们刚刚创建的线程组上右键 【添加】--&amp;gt;【监听器】--&amp;gt;【察看结果树】。&lt;/p&gt;
&lt;p&gt;直接添加，然后点击&lt;code&gt;运行&lt;/code&gt;按钮就可以看到结果了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201805/668104-20180505142108497-713212179.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加summary-report&quot;&gt;7.添加Summary Report&lt;/h3&gt;
&lt;p&gt;在我们刚刚创建的线程组上右键 【添加】--&amp;gt;【监听器】--&amp;gt;【Summary Report】。&lt;/p&gt;
&lt;p&gt;直接添加，然后点击&lt;code&gt;运行&lt;/code&gt;按钮就可以看到结果了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201805/668104-20180505143855300-678010921.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为了不引起不必要的争论，隐藏了TPS。此数据不具备任何价值，仅仅为文章演示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;测试计划创建完成&quot;&gt;8.测试计划创建完成&lt;/h3&gt;
&lt;p&gt;记得点保存。&lt;/p&gt;
&lt;h2 id=&quot;五.执行测试计划&quot;&gt;五.执行测试计划&lt;/h2&gt;
&lt;p&gt;前面我们说过，执行测试计划不能用GUI，需要用命令行来执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201805/668104-20180505142733531-35292771.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里执行的命令为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;testplan/RedisLock.jmx&lt;/code&gt; 为测试计划文件路径&lt;br/&gt;&lt;code&gt;testplan/result/result.txt&lt;/code&gt; 为测试结果文件路径&lt;br/&gt;&lt;code&gt;testplan/webreport&lt;/code&gt; 为web报告保存路径。&lt;/p&gt;
&lt;p&gt;Web报告如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201805/668104-20180505143000759-389642924.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六.写在最后&quot;&gt;六.写在最后&lt;/h2&gt;
&lt;p&gt;线程数量和循环次数将会影响最终的测试报告,请大家多多测试。&lt;/p&gt;
</description>
<pubDate>Sun, 06 May 2018 03:59:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/8971531.html</dc:identifier>
</item>
</channel>
</rss>