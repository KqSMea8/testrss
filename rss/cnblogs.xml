<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>通过 UI 管理 docker - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/9238796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/9238796.html</guid>
<description>&lt;p&gt;&lt;span&gt;Docker 正在被用在越来越多的场景中，对于不太习惯命令行工具的朋友来说，docker cli 用起来可能会比较吃力。本文笔者将介绍一个功能强大的 docker web 客户端：&lt;span&gt;&lt;strong&gt;portainer&lt;/strong&gt;&lt;/span&gt;(岸吊，参考下面插图)。按照 portainer 官方的说法，它可以让我们通过 UI 轻松的管理 docker 主机和 docker swarm 集群。说明：本文的演示环境为 ubuntu 16.04。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628145952657-769376336.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;就像我们通过容器来运行应用一样，运行一个容器就行了，非常简单：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker run -d -p &lt;span&gt;9000&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt; -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后在浏览器中通过 9000 端口访问 protainer 站点就可以了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置管理员信息&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;第一次访问 portainer 时需要设置管理员的账号信息，我们把管理员账号命名为 admin 并设置密码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150152934-868051380.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;选择 portainer 管理的对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;简单起见我们先配置 portainer 管理本机的 docker，选择下图中的 &quot;Local&quot; 并点击 &quot;connect&quot; 按钮：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150248969-602479751.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单的安装和配置之后我们就进入了 portainer 的 dashboard 界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150405118-588004249.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;387&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Portainer 的界面设计非常简洁，主菜单几乎就是 docker 主要功能的一一对应。接下来，我们将通过 App Templates 菜单来创建容器一个容器，并通过该容器来介绍一些 portainer 中比较常用的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择左侧的 App Templates 菜单，然后选择创建一个运行在 nginx 容器中的应用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150541368-1836586306.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在容器属性的配置界面中，指定容器的名称为 webdemo，然后在高级选项中设置把宿主机的 80 端口映射到容器中的 80 端口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150636853-324745175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后点击 &quot;Deploy the container&quot; 按钮开始创建容器。容器创建完成后会显示在 Containers 界面中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150727687-1796239643.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;233&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个管理界面上，我们可以选取一个或多个容器进行操作，比如 start、stop、kill、restart、pause、resume 和 remove，当然还可以通过 &quot;Add container&quot; 按钮添加新的容器。下面我们点击红框中的容器名称 &quot;webdemo&quot; 进入到容器详情界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150821795-581954266.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个界面中显示了单个容器的详情以及可以对这个容器执行的操作。最上方是针对容器的操作，接下来是容器的状态，然后是 &quot;Access control&quot;、&quot;Create image&quot;、&quot;Container details&quot;、&quot;Volumes&quot; 和 &quot;Connected networks&quot;，为了显示方便，笔者把下面的类别都折叠了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在容器状态区域，需要关注下红框中的 Status、Logs、Console 和 Inspect，这些都是我们平时比较关心的内容。下面点击它们分别查看对应的视图。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;Container statistics 视图&lt;/strong&gt;实时的显示容器占用的资源信息，需要注意的是相关的数据没有被持久化，显示的内容总是每次打开这个视图后的数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628150913169-1272978470.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;容器日志视图&lt;/strong&gt;显示容器中的日志输出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628151001314-467896299.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&lt;strong&gt;控制台视图&lt;/strong&gt;我们可以在容器中执行命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628151046039-1202685000.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Inspect 视图&lt;/strong&gt;则为我们展示容器的详细信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628151132310-699701468.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Portainer 并不是只能管理自己创建的容器，我们通过命令行创建的容器也会被 portainer 发现并管理。比如我们到宿主机的控制台上创建一个名为 mycon 的容器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker run --&lt;span&gt;rm&lt;/span&gt; -&lt;span&gt;id&lt;/span&gt; --name mycon ubuntu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后在 portainer 的容器列表界面中刷新一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628151227585-1835891666.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mycon 容器已经出现在容器列表中了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过菜单中的 Images、Networks 和 Volumes 项可以分别管理容器镜像、network 和数据卷：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201806/952033-20180628151351223-1281368095.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些差别多就是平时使用比较频繁的功能了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了管理单机模式的 docker，portainer 还可以管理 docker swarm 集群。具体的用法并不复杂，这里就不再赘述了，有兴趣的朋友可以参考&lt;a href=&quot;https://media-glass.es/portainer-the-ui-for-docker-d067f6335f23&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/portainer/portainer&quot; target=&quot;_blank&quot;&gt;Portainer github&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://hub.docker.com/r/portainer/portainer/&quot; target=&quot;_blank&quot;&gt;Portainer dockerhub&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://www.howtoforge.com/tutorial/ubuntu-docker-portainer/&quot; target=&quot;_blank&quot;&gt;How to Manage Docker Containers using Portainer on Ubuntu&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://media-glass.es/portainer-the-ui-for-docker-d067f6335f23&quot; target=&quot;_blank&quot;&gt;Portainer, a UI for Docker&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 07:23:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/9238796.html</dc:identifier>
</item>
<item>
<title>dnsmasq详解&amp;手册 - sunsky303</title>
<link>http://www.cnblogs.com/sunsky303/p/9238669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunsky303/p/9238669.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/420532/201806/420532-20180628142831647-1678354472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Dnsmasq为小型网络提供网络基础设施：DNS，DHCP，路由器通告和网络引导。它被设计为轻量级且占用空间小，适用于资源受限的路由器和防火墙。它还被广泛用于智能手机和便携式热点的共享，并支持虚拟化框架中的虚拟网络。支持的平台包括Linux（带有glibc和uclibc），Android，* BSD和Mac OS X. Dnsmasq包含在大多数Linux发行版以及FreeBSD，OpenBSD和NetBSD的端口系统中。Dnsmasq提供完整的IPv6支持。&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171116163327738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lib3JnaXRl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Dnsmasq原理：&lt;/p&gt;
&lt;p&gt;•本机APP访问主机的/etc/resolv.conf获取DNSServer，该文件指向的DNSServer为Dnsmasq。&lt;/p&gt;
&lt;p&gt;•本地局域网中的主机可以直接访问Dnsmasq，即在这些主机中/etc/resolv.conf指向了Dnsmasq。&lt;/p&gt;
&lt;p&gt;•Dnsmasq需要通过上游DNS来进行域名解析，上游DNS可以配置在/etc/resolv.dnsmasq.conf中，该文件需要在Dnsmasq的配置文件/etc/dnsmasq.conf中指定。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;DNS子系统为网络提供本地DNS服务器，将所有查询类型转发到上游递归DNS服务器并缓存常用记录类型（A，AAAA，CNAME和PTR，以及启用DNSSEC时的DNSKEY和DS）。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;本地DNS名称可通过读取/ etc / hosts，通过从DHCP子系统导入名称或配置各种有用的记录类型来定义。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上游服务器可以用各种方便的方式进行配置，包括动态配置，这些配置会随着移动上游网络而发生变化。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;权威DNS模式允许本地DNS名称可以导出到全球DNS中的区域。&lt;/span&gt;&lt;span&gt;Dnsmasq充当此区域的权威服务器，并且还根据需要为该区域的辅助区域提供区域传输。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以对来自上游名称服务器的DNS答复执行DNSSEC验证，从而提供针对欺骗和缓存中毒的安全性。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指定的子域可以定向到它们自己的上游DNS服务器，从而使VPN配置变得容易。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持国际化域名。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;DHCP子系统支持DHCPv4，DHCPv6，BOOTP和PXE。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持静态和动态DHCP租约，以及DHCPv6中的无状态模式。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;PXE系统是一个完整的PXE服务器，支持网络引导菜单和多种体系结构支持。&lt;/span&gt;&lt;span&gt;它包括代理模式，PXE系统与另一台DHCP服务器协同工作。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有一个内置的只读TFTP服务器来支持网络启动。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过DHCP配置的计算机的名称会自动包含在DNS中，并且名称可以由每台计算机指定，或者通过在dnsmasq配置文件中将名称与MAC地址或UID关联来集中进行。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;路由器通告子系统为IPv6主机提供基本的自动配置。&lt;/span&gt;&lt;span&gt;它可以单独使用或与DHCPv6结合使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;M和O位是可配置的，以控制主机使用DHCPv6。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;路由器通告可以包含RDNSS选项。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有一种方式使用来自DHCPv4配置的名称信息来为自动配置的IPv6地址提供DNS条目，否则这些地址将是匿名的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;为了更加紧凑，编译时可能会省略未使用的特性。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;获取代码。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在这里&lt;/span&gt;&lt;a href=&quot;http://www.thekelleys.org.uk/dnsmasq/&quot;&gt;&lt;span&gt;下载&lt;/span&gt;&lt;/a&gt;&lt;span&gt; dnsmasq。&lt;/span&gt;&lt;span&gt;tarball包含这个文档，源代码和&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html&quot;&gt;&lt;span&gt;联机帮助页&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;还有一个&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://www.thekelleys.org.uk/dnsmasq/CHANGELOG&quot;&gt;&lt;span&gt;CHANGELOG&lt;/span&gt;&lt;/a&gt;&lt;span&gt;和一个&lt;/span&gt;&lt;a href=&quot;http://www.thekelleys.org.uk/dnsmasq/docs/FAQ&quot;&gt;&lt;span&gt;常见问题&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Dnsmasq有一个git仓库，其中包含版本2的完整版本历史和2.60版本的开发历史。&lt;/span&gt;&lt;span&gt;您可以 &lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://thekelleys.org.uk/gitweb/?p=dnsmasq.git;a=summary&quot;&gt;&lt;span&gt;浏览&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 回购站，或者使用git协议通过命令获取副本&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;tt&gt;git clone git：//thekelleys.org.uk/dnsmasq.git &lt;/tt&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;要么&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;tt&gt;git clone http://thekelleys.org.uk/git/dnsmasq.git &lt;/tt&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Dnsmasq根据您的判断在GPL第2版或第3版下发布。&lt;/span&gt;&lt;span&gt;有关详细信息，请参阅发行版中的COPYING和COPYING-v3文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&quot;brush:bash;toolbar:false&quot;&gt;
#############################################################################
#
#        DNS 选项
#
##############################################################################
# 不加载本地的 /etc/hosts 文件
#no-hosts
# 添加读取额外的 hosts 文件路径，可以多次指定。如果指定为目录，则读取目录中的所有文件。
#addn-hosts=/etc/hosts
# 读取目录中的所有文件，文件更新将自动读取
#hostsdir=&amp;lt;path&amp;gt;
# 例如，/etc/hosts中的os01将扩展成os01.example.com
#expand-hosts

##############################################################################
# 缓存时间设置，一般不需要设置
# 本地 hosts 文件的缓存时间，通常不要求缓存本地，这样更改hosts文件后就即时生效。
#local-ttl=3600
# 同 local-ttl 仅影响 DHCP 租约
#dhcp-ttl=&amp;lt;time&amp;gt;
# 对于上游返回的值没有ttl时，dnsmasq给一个默认的ttl，一般不需要设置，
#neg-ttl=&amp;lt;time&amp;gt;
# 指定返回给客户端的ttl时间，一般不需要设置
#max-ttl=&amp;lt;time&amp;gt;
# 设置在缓存中的条目的最大 TTL。
#max-cache-ttl=&amp;lt;time&amp;gt;
# 不需要设置，除非你知道你在做什么。
#min-cache-ttl=&amp;lt;time&amp;gt;
# 一般不需要设置
#auth-ttl=&amp;lt;time&amp;gt;

##############################################################################
# 记录dns查询日志
#log-queries
# 设置日志记录器，‘-‘ 为 stderr，也可以是文件路径。默认为：DAEMON，调试时使用 LOCAL0。
#log-facility=&amp;lt;facility&amp;gt;
#log-facility=/var/log/dnsmasq/dnsmasq.log
# 异步log，缓解阻塞，提高性能。默认为5，最大100。
#log-async[=&amp;lt;lines&amp;gt;]
#log-async=50

##############################################################################
# 指定用户和组
#user=nobody
#group=nobody

##############################################################################
# 指定DNS的端口，默认53，设置 port=0 将完全禁用 DNS 功能，仅使用 DHCP/TFTP
#port=53
# 指定 EDNS.0 UDP 包的最大尺寸，默认为 RFC5625 推荐的 edns-packet-max=4096
#edns-packet-max=&amp;lt;size&amp;gt;
# 指定向上游查询的 UDP 端口，默认是随机端口，指定后降低安全性、加快速度、减少资源消耗。
# 设置为 0 有操作系统分配。
query-port=53535
# 指定向上游查询的 UDP 端口范围，方便防火墙设置。
#min-port=&amp;lt;port&amp;gt;
#max-port=&amp;lt;port&amp;gt;
# 指定接口，指定后同时附加 lo 接口，可以使用‘*‘通配符
#interface=wlp2s0
# 指定排除的接口，排除高优先级，可以使用‘*‘通配符
#except-interface=
# 启用 DNS 验证模式
#auth-server=&amp;lt;domain&amp;gt;,&amp;lt;interface&amp;gt;|&amp;lt;ip-address&amp;gt;
# 仅接收同一子网的 DNS 请求，仅在未指定 interface、except-interface、listen-address 
# 或者 auth-server 时有效。
#local-service
# 指定不提供 DHCP 或 TFTP 服务的接口，仅提供 DNS 服务
#no-dhcp-interface=enp3s0
# 指定IP地址，可以多次指定。下面两行跟指定接口的作用类似。
#listen-address=192.168.10.254
#listen-address=127.0.0.1
# 绑定接口，开启此项将仅监听指定的接口。
#bind-interfaces
# 对于新添加的接口也进行绑定。
#bind-dynamic

##############################################################################
# 如果 hosts 中的主机有多个 IP 地址，仅返回对应子网的 IP 地址。
#localise-queries
# 如果反向查找的是私有地址例如192.168.X.X，仅从 hosts 文件查找，不再转发到上游服务器
#bogus-priv
# 对于任何被解析到此IP的域名，使其解析失效，可以多次指定
#bogus-nxdomain=64.94.110.11
# 忽略指定的 DNS 响应服务器地址，例如 1.1.1.1 为伪造的 dns 服务器并且响应速度非常快，
# 指定 ignore-address=1.1.1.1 可以忽略它的响应信息，从而等待正确的响应结果。
#ignore-address=&amp;lt;ipaddr&amp;gt;
#filterwin2k

##############################################################################
# 指定 resolv-file 文件路径，默认/etc/resolv.conf
#resolv-file=/etc/resolv.conf
# 不读取 resolv-file 来确定上游服务器
#no-resolv
# 在编译时需要启用 DBus 支持。
#enable-dbus[=&amp;lt;service-name&amp;gt;]
# 严格按照resolv.conf中的顺序进行查找
#strict-order
# 向所有上有服务器发送查询，而不是一个。
#all-servers
#dns-loop-detect

##############################################################################
# 这项安全设置是拒绝解析包含私有 IP 地址的域名，
# 这些IP地址包括如下私有地址范围：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16。
# 其初衷是要防止类似上游DNS服务器故意将某些域名解析成特定私有内网IP而劫持用户这样的安全攻击。
# 直接在配置文件中注销 stop-dns-rebind 配置项从而禁用该功能。
# 这个方法确实可以一劳永逸的解决解析内网 IP 地址的问题，但是我们也失去了这项安全保护的特性，
# 所以在这里我不推荐这个办法。
# 使用 rebind-domain-ok 进行特定配置，顾名思义该配置项可以有选择的忽略域名的 rebind 行为
#stop-dns-rebind
#rebind-localhost-ok
#rebind-domain-ok=[&amp;lt;domain&amp;gt;]|[[/&amp;lt;domain&amp;gt;/[&amp;lt;domain&amp;gt;/]
#rebind-domain-ok=/.dinghuangjie.com/.dhj.com/.harlinsu.com/.example.com/.test.com/.esderive.com/

##############################################################################
# 也不要检测 /etc/resolv.conf 的变化
#no-poll
# 重启后清空缓存
#clear-on-reload
# 完整的域名才向上游服务器查找，如果仅仅是主机名仅查找hosts文件
#domain-needed

##############################################################################
# IP地址转换
#alias=[&amp;lt;old-ip&amp;gt;]|[&amp;lt;start-ip&amp;gt;-&amp;lt;end-ip&amp;gt;],&amp;lt;new-ip&amp;gt;[,&amp;lt;mask&amp;gt;]
##############################################################################
#local=[/[&amp;lt;domain&amp;gt;]/[domain/]][&amp;lt;ipaddr&amp;gt;[#&amp;lt;port&amp;gt;][@&amp;lt;source-ip&amp;gt;|&amp;lt;interface&amp;gt;[#&amp;lt;port&amp;gt;]]
#server=[/[&amp;lt;domain&amp;gt;]/[domain/]][&amp;lt;ipaddr&amp;gt;[#&amp;lt;port&amp;gt;][@&amp;lt;source-ip&amp;gt;|&amp;lt;interface&amp;gt;[#&amp;lt;port&amp;gt;]]
#server=/example.com/192.168.10.252
#rev-server=&amp;lt;ip-address&amp;gt;/&amp;lt;prefix-len&amp;gt;,&amp;lt;ipaddr&amp;gt;[#&amp;lt;port&amp;gt;][@&amp;lt;source-ip&amp;gt;|&amp;lt;interface&amp;gt;[#&amp;lt;port&amp;gt;]]

# 将任何属于 &amp;lt;domain&amp;gt; 域名解析成指定的 &amp;lt;ipaddr&amp;gt; 地址。
# 也就是将 &amp;lt;domain&amp;gt; 及其所有子域名解析成指定的 &amp;lt;ipaddr&amp;gt; IPv4 或者 IPv6 地址，
# 通常用于屏蔽特定的域名。
# 一次只能指定一个 IPv4 或者 IPv6 地址，
# 要同时返回 IPv4 和IPv6 地址，请多次指定 address= 选项。
# 注意： /etc/hosts 以及 DHCP 租约将覆盖此项设置。
#address=/&amp;lt;domain&amp;gt;/[domain/][&amp;lt;ipaddr&amp;gt;]

#ipset=/&amp;lt;domain&amp;gt;/[domain/]&amp;lt;ipset&amp;gt;[,&amp;lt;ipset&amp;gt;]
#mx-host=&amp;lt;mx name&amp;gt;[[,&amp;lt;hostname&amp;gt;],&amp;lt;preference&amp;gt;]
#mx-target=&amp;lt;hostname&amp;gt;

# SRV 记录
#srv-host=&amp;lt;_service&amp;gt;.&amp;lt;_prot&amp;gt;.[&amp;lt;domain&amp;gt;],[&amp;lt;target&amp;gt;[,&amp;lt;port&amp;gt;[,&amp;lt;priority&amp;gt;[,&amp;lt;weight&amp;gt;]]]]

# A, AAAA 和 PTR 记录 
#host-record=&amp;lt;name&amp;gt;[,&amp;lt;name&amp;gt;....],[&amp;lt;IPv4-address&amp;gt;],[&amp;lt;IPv6-address&amp;gt;][,&amp;lt;TTL&amp;gt;]

# TXT 记录
#txt-record=&amp;lt;name&amp;gt;[[,&amp;lt;text&amp;gt;],&amp;lt;text&amp;gt;]

# PTR 记录 
#ptr-record=&amp;lt;name&amp;gt;[,&amp;lt;target&amp;gt;]

#naptr-record=&amp;lt;name&amp;gt;,&amp;lt;order&amp;gt;,&amp;lt;preference&amp;gt;,&amp;lt;flags&amp;gt;,&amp;lt;service&amp;gt;,&amp;lt;regexp&amp;gt;[,&amp;lt;replacement&amp;gt;]

# CNAME 别名记录
#cname=&amp;lt;cname&amp;gt;,&amp;lt;target&amp;gt;[,&amp;lt;TTL&amp;gt;]


#dns-rr=&amp;lt;name&amp;gt;,&amp;lt;RR-number&amp;gt;,[&amp;lt;hex data&amp;gt;]
#interface-name=&amp;lt;name&amp;gt;,&amp;lt;interface&amp;gt;[/4|/6]
#synth-domain=&amp;lt;domain&amp;gt;,&amp;lt;address range&amp;gt;[,&amp;lt;prefix&amp;gt;]
#add-mac[=base64|text]
#add-cpe-id=&amp;lt;string&amp;gt;
#add-subnet[[=[&amp;lt;IPv4 address&amp;gt;/]&amp;lt;IPv4 prefix length&amp;gt;][,[&amp;lt;IPv6 address&amp;gt;/]&amp;lt;IPv6 prefix length&amp;gt;]]
##############################################################################

##############################################################################
# 缓存条数，默认为150条，cache-size=0 禁用缓存。
cache-size=1000
# 不缓存未知域名缓存，默认情况下dnsmasq缓存未知域名并直接返回为客户端。
#no-negcache
# 指定DNS同属查询转发数量
dns-forward-max=1000

# 启用连接跟踪，读取 Linux 入栈 DNS 查询请求的连接跟踪标记，
# 并且将上游返回的响应信息设置同样的标记。
# 用于带宽控制和防火墙部署。
# 此选项必须在编译时启用 conntrack 支持，并且内核正确配置并加载 conntrack。
# 此选项不能与 query-port 同时使用。
#conntrack


##############################################################################
#
#        DHCP 选项
#
##############################################################################
# 设置 DHCP 地址池，同时启用 DHCP 功能。
# IPv4 &amp;lt;mode&amp;gt; 可指定为 static|proxy ，当 &amp;lt;mode&amp;gt; 指定为 static 时，
# 需用 dhcp-host 手动分配地址池中的 IP 地址。
# 当 &amp;lt;mode&amp;gt; 指定为 proxy 时，为指定的地址池提供 DHCP 代理。
#dhcp-range=[tag:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;],][set:&amp;lt;tag&amp;gt;,]&amp;lt;start-addr&amp;gt;[,&amp;lt;end-addr&amp;gt;][,&amp;lt;mode&amp;gt;][,&amp;lt;netmask&amp;gt;[,&amp;lt;broadcast&amp;gt;]][,&amp;lt;lease time&amp;gt;]
#dhcp-range=172.16.0.2,172.16.0.250,255.255.255.0,1h
#dhcp-range=192.168.10.150,192.168.10.180,static,255.255.255.0,1h

# 根据 MAC 地址或 id 固定分配客户端的 IP 地址、主机名、租期。
# IPv4 下指定 id:* 将忽略 DHCP 客户端的 ID ，仅根据 MAC 来进行 IP 地址分配。
# 在读取 /etc/hosts 的情况，也可以根据 /etc/hosts 中的主机名分配对应 IP 地址。
# 指定 ignore 将忽略指定客户端得 DHCP 请求。
#dhcp-host=[&amp;lt;hwaddr&amp;gt;][,id:&amp;lt;client_id&amp;gt;|*][,set:&amp;lt;tag&amp;gt;][,&amp;lt;ipaddr&amp;gt;][,&amp;lt;hostname&amp;gt;][,&amp;lt;lease_time&amp;gt;][,ignore]
#dhcp-hostsfile=&amp;lt;path&amp;gt;
#dhcp-hostsdir=&amp;lt;path&amp;gt;
# 读取 /etc/ethers 文件 与使用 dhcp-host 的作用相同。IPv6 无效。
#read-ethers

# 指定给 DHCP 客户端的选项信息，
# 默认情况下 dnsmasq 将发送：子网掩码、广播地址、DNS 服务器地址、网关地址、域等信息。
# 指定此选项也可覆盖这些默认值并且设置其他选项值。
# 重要：可以使用 option:&amp;lt;option-name&amp;gt;或者 option号 来指定。
# &amp;lt;option-name&amp;gt; 和 option号的对应关系可使用命令：
# dnsmasq --help dhcp 以及 dnsmasq --help dhcp6 查看，这点很重要。
# 例如设置网关参数，既可以使用 dhcp-option=3,192.168.4.4 也可以使用 dhcp-option = option:router,192.168.4.4。
# 0.0.0.0 意味着当前运行 dnsmasq 的主机地址。
# 如果指定了多个 tag:&amp;lt;tag&amp;gt; 必须同时匹配才行。
# [encap:&amp;lt;opt&amp;gt;,][vi-encap:&amp;lt;enterprise&amp;gt;,][vendor:[&amp;lt;vendor-class&amp;gt;],] 有待继续研究。
#dhcp-option=[tag:&amp;lt;tag&amp;gt;,[tag:&amp;lt;tag&amp;gt;,]][encap:&amp;lt;opt&amp;gt;,][vi-encap:&amp;lt;enterprise&amp;gt;,][vendor:[&amp;lt;vendor-class&amp;gt;],][&amp;lt;opt&amp;gt;|option:&amp;lt;opt-name&amp;gt;|option6:&amp;lt;opt&amp;gt;|option6:&amp;lt;opt-name&amp;gt;],[&amp;lt;value&amp;gt;[,&amp;lt;value&amp;gt;]]
#dhcp-option-force=[tag:&amp;lt;tag&amp;gt;,[tag:&amp;lt;tag&amp;gt;,]][encap:&amp;lt;opt&amp;gt;,][vi-encap:&amp;lt;enterprise&amp;gt;,][vendor:[&amp;lt;vendor-class&amp;gt;],]&amp;lt;opt&amp;gt;,[&amp;lt;value&amp;gt;[,&amp;lt;value&amp;gt;]]
#dhcp-optsfile=&amp;lt;path&amp;gt;
#dhcp-optsdir=&amp;lt;path&amp;gt;
#dhcp-option=3,1.2.3.4
#dhcp-option=option:router,1.2.3.4
#dhcp-option=option:router,192.168.10.254
#dhcp-option=option:dns-server,192.168.10.254,221.12.1.227,221.12.33.227

##############################################################################
# (IPv4 only) 禁用重用服务器名称和文件字段作为额外的 dhcp-option 选项。
# 一般情况下 dnsmasq 从 dhcp-boot 移出启动服务器和文件信息到 dhcp-option 选项中。
# 这使得在 dhcp-option 选项封包中有额外的选项空间可用，但是会使老的客户端混淆。
# 此选项将强制使用简单并安全的方式来避免此类情况。可以认为是一个兼容性选项。
#dhcp-no-override

##############################################################################
# 配置 DHCP 中继。
# &amp;lt;local address&amp;gt; 是运行 dnsmasq 的接口的 IP 地址。
# 所有在 &amp;lt;local address&amp;gt; 接口上接收到的 DHCP 请求将中继到 &amp;lt;server address&amp;gt; 指定的远程 DHCP 服务器。
# 可以多次配置此选项，使用同一个 &amp;lt;local address&amp;gt; 转发到多个不同的 &amp;lt;server address&amp;gt; 指定的远程 DHCP 服务器。
# &amp;lt;server address&amp;gt; 仅允许使用 IP 地址，不能使用域名等其他格式。
# 如果是 DHCPv6，&amp;lt;server address&amp;gt; 可以是 ALL_SERVERS 的多播地址 ff05::1:3 。
# 在这种情况下必须指定接口 &amp;lt;interface&amp;gt; ，不能使用通配符，用于直接多播到对应的 DHCP 服务器所在的接口。
# &amp;lt;interface&amp;gt; 指定了仅允许接收从 &amp;lt;interface&amp;gt; 接口的 DHCP 服务器相应信息。
#dhcp-relay=&amp;lt;local address&amp;gt;,&amp;lt;server address&amp;gt;[,&amp;lt;interface&amp;gt;]

##############################################################################
# 设置标签
#dhcp-vendorclass=set:&amp;lt;tag&amp;gt;,[enterprise:&amp;lt;IANA-enterprise number&amp;gt;,]&amp;lt;vendor-class&amp;gt;
#dhcp-userclass=set:&amp;lt;tag&amp;gt;,&amp;lt;user-class&amp;gt;
#dhcp-mac=set:&amp;lt;tag&amp;gt;,&amp;lt;MAC address&amp;gt;
#dhcp-circuitid=set:&amp;lt;tag&amp;gt;,&amp;lt;circuit-id&amp;gt;
#dhcp-remoteid=set:&amp;lt;tag&amp;gt;,&amp;lt;remote-id&amp;gt;
#dhcp-subscrid=set:&amp;lt;tag&amp;gt;,&amp;lt;subscriber-id&amp;gt;
#dhcp-match=set:&amp;lt;tag&amp;gt;,&amp;lt;option number&amp;gt;|option:&amp;lt;option name&amp;gt;|vi-encap:&amp;lt;enterprise&amp;gt;[,&amp;lt;value&amp;gt;]
#tag-if=set:&amp;lt;tag&amp;gt;[,set:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;]]]

#dhcp-proxy[=&amp;lt;ip addr&amp;gt;]......

##############################################################################
# 不分配匹配这些 tag:&amp;lt;tag&amp;gt; 的 DHCP 请求。
#dhcp-ignore=tag:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;]
#dhcp-ignore-names[=tag:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;]]
#dhcp-generate-names=tag:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;]
# IPv4 only 使用广播与匹配 tag:&amp;lt;tag&amp;gt; 的客户端通信。一般用于兼容老的 BOOT 客户端。
#dhcp-broadcast[=tag:&amp;lt;tag&amp;gt;[,tag:&amp;lt;tag&amp;gt;]] 

##############################################################################
# IPv4 only 设置 DHCP 服务器返回的 BOOTP 选项，
# &amp;lt;servername&amp;gt; &amp;lt;server address&amp;gt; 可选，
# 如果未设置服务器名称将设为空，服务器地址设为 dnsmasq 的 IP 地址。
# 如果指定了多个 tag:&amp;lt;tag&amp;gt; 必须同时匹配才行。
# 如果指定 &amp;lt;tftp_servername&amp;gt; 将按照 /etc/hosts 中对应的 IP 地址进行轮询负载均衡。  
#dhcp-boot=[tag:&amp;lt;tag&amp;gt;,]&amp;lt;filename&amp;gt;,[&amp;lt;servername&amp;gt;[,&amp;lt;server address&amp;gt;|&amp;lt;tftp_servername&amp;gt;]]
# 根据不同的类型使用不同的选项。
# 使用示例：
#        dhcp-match=set:EFI_x86-64,option:client-arch,9
#        dhcp-boot=tag:EFI_x86-64,uefi/grubx64.efi
#        #dhcp-match=set:EFI_Xscale,option:client-arch,8
#        #dhcp-boot=tag:EFI_Xscale,uefi/grubx64.efi
#        #dhcp-match=set:EFI_BC,option:client-arch,7
#        #dhcp-boot=tag:EFI_BC,uefi/grubx64.efi
#        #dhcp-match=set:EFI_IA32,option:client-arch,6
#        #dhcp-boot=tag:EFI_IA32,uefi/grubx64.efi
#        #dhcp-match=set:Intel_Lean_Client,option:client-arch,5
#        #dhcp-boot=tag:Intel_Lean_Client,uefi/grubx64.efi
#        #dhcp-match=set:Arc_x86,option:client-arch,4
#        #dhcp-boot=tag:Arc_x86,uefi/grubx64.efi
#        #dhcp-match=set:DEC_Alpha,option:client-arch,3
#        #dhcp-boot=tag:DEC_Alpha,uefi/grubx64.efi
#        #dhcp-match=set:EFI_Itanium,option:client-arch,2
#        #dhcp-boot=tag:EFI_Itanium,uefi/grubx64.efi
#        #dhcp-match=set:NEC/PC98,option:client-arch,1
#        #dhcp-boot=tag:NEC/PC98,uefi/grubx64.efi
#        dhcp-match=set:Intel_x86PC,option:client-arch,0
#        dhcp-boot=tag:Intel_x86PC,pxelinux.0

##############################################################################
# DHCP 使用客户端的 MAC 地址的哈希值为客户端分配 IP 地址，
# 通常情况下即使客户端使自己的租约到期，客户端的 IP 地址仍将长期保持稳定。
# 在默认模式下，IP 地址是随机分配的。
# 启用 dhcp-sequential-ip 选项将按顺序分配 IP 地址。
# 在顺序分配模式下，客户端使租约到期更像是仅仅移动一下 IP 地址。
# 在通常情况下不建议使用这种方式。
#dhcp-sequential-ip

##############################################################################
# 多数情况下我们使用 PXE，只是简单的允许 PXE 客户端获取 IP 地址，
# 然后 PXE 客户端下载 dhcp-boot 选项指定的文件并执行，也就是 BOOTP 的方式。
# 然而在有适当配置的 DHCP 服务器支持的情况下，PXE 系统能够实现更复杂的功能。
# pxe-service 选项可指定 PXE 环境的启动菜单。
# 为不同的类型系统设定不同的启动菜单，并且覆盖 dhcp-boot 选项。
# &amp;lt;CSA&amp;gt; 为客户端系统类型：x86PC, PC98, IA64_EFI, Alpha, Arc_x86, Intel_Lean_Client, 
# IA32_EFI, X86-64_EFI, Xscale_EFI, BC_EFI, ARM32_EFI 和 ARM64_EFI，其他类型可能为一个整数。
# &amp;lt;basename&amp;gt; 引导 PXE 客户端使用 tftp 从 &amp;lt;server address&amp;gt; 或者 &amp;lt;server_name&amp;gt; 下载文件。
#     注意：&quot;layer&quot; 后缀 (通常是 &quot;.0&quot;) 由 PXE 提供，也就是 PXE 客户端默认在文件名附加 .0 后缀。
#     示例：pxe-service=x86PC, &quot;Install Linux&quot;, pxelinux         （读取 pxelinux.0 文件并执行）
#           pxe-service=x86PC, &quot;Install Linux&quot;, pxelinux, 1.2.3.4（不适用于老的PXE）
#     &amp;lt;bootservicetype&amp;gt; 整数，PXE 客户端将通过广播或者通过 &amp;lt;server address&amp;gt; 
#           或者 &amp;lt;server_name&amp;gt; 搜索对应类型的适合的启动服务。。
#     示例：pxe-service=x86PC, &quot;Install windows from RIS server&quot;, 1
#           pxe-service=x86PC, &quot;Install windows from RIS server&quot;, 1, 1.2.3.4
#     未指定 &amp;lt;basename&amp;gt;、&amp;lt;bootservicetype&amp;gt; 或者 &amp;lt;bootservicetype&amp;gt; 为 “0”，将从本地启动。
#     示例：pxe-service=x86PC, &quot;Boot from local disk&quot;
#           pxe-service=x86PC, &quot;Boot from local disk&quot;, 0
# 如果指定 &amp;lt;server_name&amp;gt; 将按照 /etc/hosts 中对应的 IP 地址进行轮询负载均衡。  
#pxe-service=[tag:&amp;lt;tag&amp;gt;,]&amp;lt;CSA&amp;gt;,&amp;lt;menu text&amp;gt;[,&amp;lt;basename&amp;gt;|&amp;lt;bootservicetype&amp;gt;][,&amp;lt;server address&amp;gt;|&amp;lt;server_name&amp;gt;]
# 在 PXE 启动后弹出提示，&amp;lt;prompt&amp;gt; 为提示内容，&amp;lt;timeout&amp;gt; 为超时时间，为 0 则立即执行。
# 如果未指定此选项，在有多个启动选项的情况下等待用户选择，不会超时。
#pxe-prompt=[tag:&amp;lt;tag&amp;gt;,]&amp;lt;prompt&amp;gt;[,&amp;lt;timeout&amp;gt;]
# 根据不同的类型使用不同的菜单，使用示例：
#        #pxe-prompt=&quot;What system shall I netboot?&quot;, 120
#        # or with timeout before first available action is taken:
#        pxe-prompt=&quot;Press F8 or Enter key for menu.&quot;, 60
#        pxe-service=x86PC, &quot;Now in x86PC (BIOS mode), boot from local&quot;, 0
#        pxe-service=x86PC, &quot;Now in x86PC (BIOS mode)&quot;, pxelinux
#        pxe-service=PC98, &quot;Now in PC98 mode&quot;, PC98
#        pxe-service=IA64_EFI, &quot;Now in IA64_EFI mode&quot;, IA64_EFI
#        pxe-service=Alpha, &quot;Now in Alpha mode&quot;, Alpha
#        pxe-service=Arc_x86, &quot;Now in Arc_x86 mode&quot;, Arc_x86
#        pxe-service=Intel_Lean_Client, &quot;Now in Intel_Lean_Client mode&quot;, Intel_Lean_Client
#        pxe-service=IA32_EFI, &quot;Now in IA32_EFI mode&quot;, IA32_EFI
#        pxe-service=X86-64_EFI, &quot;Now in X86-64_EFI (UEFI mode), boot from local&quot;, 0
#        pxe-service=X86-64_EFI, &quot;Now in X86-64_EFI (UEFI mode)&quot;, grub/grub-x86_64.efi
#        pxe-service=Xscale_EFI, &quot;Now in Xscale_EFI mode&quot;, Xscale_EFI
#        pxe-service=BC_EFI, &quot;Now in BC_EFI mode&quot;, BC_EFI
#        # CentOS7 系统不支持下列两个选项
#        #pxe-service=ARM32_EFI,&quot;Now in ARM32_EFI mode&quot;,ARM32_EFI
#        #pxe-service=ARM64_EFI,&quot;Now in ARM64_EFI mode&quot;,ARM64_EFI

##############################################################################
# 默认为150，即最多分配150个ip地址出去，最大1000个ip
#dhcp-lease-max=150
# (IPv4 only) 指定DHCP端口，默认为67和68。如果不指定则为1067和1068，单指定一个，第二个加1
#dhcp-alternate-port[=&amp;lt;server port&amp;gt;[,&amp;lt;client port&amp;gt;]]
# 谨慎使用此选项，避免 IP 地址浪费。(IPv4 only) 允许动态分配 IP 地址给 BOOTP 客户端。
# 注意：BOOTP 客户端获取的 IP 地址是永久的，将无法再次分配给其他客户端。
#bootp-dynamic[=&amp;lt;network-id&amp;gt;[,&amp;lt;network-id&amp;gt;]]
# 谨慎使用此选项。
# 默认情况下 DHCP 服务器使用 ping 的方式进行确保 IP 未被使用的情况下将 IP 地址分配出去。
# 启用此选项将不使用 ping 进行确认。
#no-ping

##############################################################################
# 记录额外的 dhcp 日志，记录所有发送给 DHCP 客户端的选项（option）以及标签（tag）信息
#log-dhcp
# 禁止记录日常操作日志，错误日志仍然记录。启用 log-dhcp 将覆盖下列选项。
#quiet-dhcp
#quiet-dhcp6
#quiet-ra

# 修改 DHCP 默认租约文件路径，默认情况下无需修改
#dhcp-leasefile=/var/lib/dnsmasq/dnsmasq.leases
# (IPv6 only)
#dhcp-duid=&amp;lt;enterprise-id&amp;gt;,&amp;lt;uid&amp;gt;

##############################################################################
#dhcp-script=&amp;lt;path&amp;gt;
#dhcp-luascript=&amp;lt;path&amp;gt;
#dhcp-scriptuser=root
#script-arp
#leasefile-ro

#bridge-interface=&amp;lt;interface&amp;gt;,&amp;lt;alias&amp;gt;[,&amp;lt;alias&amp;gt;]

##############################################################################
# 给 DHCP 服务器指定 domain 域名信息，也可以给对应的 IP 地址池指定域名。
#     直接指定域名
#     示例：domain=thekelleys.org.uk
#     子网对应的域名
#     示例：domain=wireless.thekelleys.org.uk,192.168.2.0/24
#     ip范围对应的域名
#     示例：domain=reserved.thekelleys.org.uk,192.68.3.100,192.168.3.200
#domain=&amp;lt;domain&amp;gt;[,&amp;lt;address range&amp;gt;[,local]]
# 在默认情况下 dnsmasq 插入普通的客户端主机名到 DNS 中。
# 在这种情况下主机名必须唯一，即使两个客户端具有不同的域名后缀。
# 如果第二个客户端使用了相同的主机名，DNS 查询将自动更新为第二个客户端的 IP 地址。
# 如果设置了 dhcp-fqdn 选项，普通的主机名将不再插入到 DNS 中去，
# 仅允许合格的具有域名后缀的主机名插入到 DNS 服务器中。
# 指定此选项需同时指定不含 &amp;lt;address range&amp;gt; 地址范围的 domain 选项。
#dhcp-fqdn
# 通常情况下分配 DHCP 租约后，dnsmasq 设置 FQDN 选项告诉客户端不要尝试 DDNS 更新主机名与 IP 地址。
# 这是因为  name-IP 已自动添加到 dnsmasq 的 DNS 视图中的。
# 设置此选项将允许客户端 DDNS 更新，
# 在 windows 下允许客户端更新 windows AD 服务器是非常有用的。
# 参看  RFC 4702 。
#dhcp-client-update

#enable-ra
#ra-param=&amp;lt;interface&amp;gt;,[high|low],[[&amp;lt;ra-interval&amp;gt;],&amp;lt;router lifetime&amp;gt;]


##############################################################################
#
#        TFTP 选项
#
##############################################################################
# 对于绝大多数的配置，仅需指定 enable-tftp 和 tftp-root 选项即可。
# 是否启用内置的 tftp 服务器，可以指定多个逗号分隔的网络接口
#enable-tftp[=&amp;lt;interface&amp;gt;[,&amp;lt;interface&amp;gt;]]
#enable-tftp
#enable-tftp=enp3s0,lo
# 指定 tftp 的根目录，也就是寻找传输文件时使用的相对路径，可以附加接口，
#tftp-root=&amp;lt;directory&amp;gt;[,&amp;lt;interface&amp;gt;]
#tftp-root=/var/lib/tftpboot/
# 如果取消注释，那么即使指定的 tftp-root 无法访问，仍然启动 tftp 服务。
#tftp-no-fail
# 附加客户端的 IP 地址作为文件路径。此选项仅在正确设置了 tftp-root 的情况下可用，
# 示例：如果 tftp-root=/tftp，客户端为 192.168.1.15 请求 myfile.txt 文件时，
# 将优先请求 /tftp/192.168.1.15/myfile.txt 文件， 其次是 /tftp/myfile.txt 文件。
# 感觉没什么用。
#tftp-unique-root
# 启用安全模式，启用此选项，仅允许 tftp 进程访问属主为自己的文件。
# 不启用此选项，允许访问所有 tftp 进程属主可读取的文件。
# 如果 dnsmasq 是以 root 用户运行，tftp-secure 选项将允许访问全局可读的文件。
# 一般情况下不推荐以 root 用户运行 dnsmasq。
# 在指定了 tftp-root 的情况下并不是很重要。
#tftp-secure
# 将所有文件请求转换为小写。对于 Windows 客户端来说非常有用，建议开启此项。
# 注意：dnsmasq 的 TFTP 服务器总是将文件路径中的“\”转换为“/”。
#tftp-lowercase
# 允许最大的连接数，默认为 50 。
# 如果将连接数设置的很大，需注意每个进程的最大文件描述符限制，详见文档手册。
#tftp-max=&amp;lt;connections&amp;gt;
#tftp-max=50
# 设置传输时的 MTU 值，建议不设置或按需设置。
# 如果设定的值大于网络接口的 MTU 值，将按照网络接口的 MTU 值自动分片传输（不推荐）。
#tftp-mtu=&amp;lt;mtu size&amp;gt;
# 停止 tftp 服务器与客户端协商 &quot;blocksize&quot; 选项。启用后，防止一些古怪的客户端出问题。
#tftp-no-blocksize
# 指定 tftp 的连接端口的范围，方便防火墙部署。
# tftp 侦听在 69/udp ，连接端口默认是由系统自动分配的，
# 非 root 用户运行时指定的连接端口号需大于 1025 最大 65535。
#tftp-port-range=&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;
###############################################################################
#conf-dir=&amp;lt;directory&amp;gt;[,&amp;lt;file-extension&amp;gt;......]
#conf-file=/etc/dnsmasq.more.conf
conf-dir=/etc/dnsmasq.d
#servers-file=&amp;lt;file&amp;gt;
&lt;/pre&gt;

&lt;h2&gt; &lt;/h2&gt;
</description>
<pubDate>Thu, 28 Jun 2018 06:56:00 +0000</pubDate>
<dc:creator>sunsky303</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunsky303/p/9238669.html</dc:identifier>
</item>
<item>
<title>sql server 索引阐述系列四 表的B-Tree组织 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9238470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9238470.html</guid>
<description>&lt;h3&gt;一.概述　　&lt;/h3&gt;
&lt;p&gt;　　说到B-tree组织，就是指索引，它可以提供了对数据的快速访问。索引使数据以一种特定的方式组织起来，使查询操作具有最佳性能。当数据表量变得越来越大，索引就变得十分明显，可以利用索引查找快速满足条件的数据行。某些情况还可以利用索引帮助对数据进行排序，组合，分组，筛选。&lt;/p&gt;
&lt;p&gt; 　　一个B-tree，根是唯一的遍历的起点。中间页 层次数是根据表的行数以及索引行的大小而变化。索引中的底层节点称为叶节点。叶节点它容纳了一行或多行具有指定键值的记录，对于聚集或非聚集，叶节点都是按照键值的顺序组成，对于复合索引就是若干键值的组合。&lt;/p&gt;
&lt;p&gt;　　1.聚集索引&lt;/p&gt;
&lt;p&gt;　　在聚集索引的叶节点里不仅包含了索引键，还包含了数据页。也就是说数据本身也是聚集索引的一部分。聚集索引基于键值联系使表中的数据有序。决定哪个键值作为聚集键是重要因素，当遍历到叶级别时，可以获取数据本身，而不是简单地得到一个指向数据的指针（非聚集索引数据未覆盖）。聚集索引在 sys.partitions区中有一行，其中，索引使用每个分区的&lt;strong&gt; index_id = 1&lt;/strong&gt;，默认情况下，聚集索引是单个分区。如果聚集索引有四个分区，就有四个 B-tree 结构，每个分区中有一个 B-tree结构，关于分区在sql server 分区(上)中有讲到。由于数据页链只能按一种方式排序，因此表只有一个聚集索引，一般情况查询优化器非常倾向于采用聚集索引，因为可以直接在叶级别找到数据。  查询优化器也只需要在某一段范围的数据页，进行扫描。聚集索引结构按物理顺序存储不是磁盘上的顺序，聚集索引的排序顺序仅是表数据链在逻辑上有序的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628140849486-1382705269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.非聚集索引&lt;/p&gt;
&lt;p&gt;　　非聚集索引与聚集索引有一个相似的 B -tree索引结构。不同的是，非聚集索引不影响数据行的顺序。什么意思呢，就是说非聚集索引，叶级别不包含全部的数据，只包含了键值以及，在每个叶节点中的索引行包含了一个书签(bookmark)，书签在聚集索引里就是相应的数据行的聚集索引键，在堆里就是行标识符RID，该书签告诉sql server可以在哪里找到与索引键相应的数据行。&lt;br/&gt;理解了非聚集索引叶节点不包含全部数据时，就知道非聚集索引的存在并不影响数据分页的组织，因此每张表上最多249个非聚集索引。&lt;br/&gt;非聚集索引在 sys.partitions 区中有一行, 非聚集索引标识 &lt;strong&gt;index_id &amp;gt;1&lt;/strong&gt;。默认情况下，一个非聚集索引一个分区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141046659-986469673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二. 缺少索引与索引查找的区别&lt;/h3&gt;
&lt;p&gt; 　　在简单介绍了索引原理后，我们来直观感觉下索引在查询时的重要性。下面演示一个product表，表中的数据有12236142条，如果用户根据表中的型号(model)来搜索。下面来看看缺少索引（没有使用到索引），以及索引查找（就是应用到了索引功能）。二者的区别&lt;/p&gt;
&lt;p&gt;　　2.1 缺少索引的演示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询型号model 值STI5203 在全表中有三条&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; Model &lt;span&gt;FROM&lt;/span&gt; dbo.Product &lt;span&gt;WHERE&lt;/span&gt; Model&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;STI5203&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图下告诉我们缺少索引，如果加了索引将提高性能&lt;span&gt;99.94%&lt;/span&gt;， 该查询扫描计数5 (扫描了&lt;span&gt;5个区&lt;/span&gt;)，逻辑读取次数为&lt;span&gt;69951次&lt;/span&gt;(一次一页)，耗时&lt;span&gt;954&lt;/span&gt;毫秒。&lt;br/&gt;执行计划告诉我们是索引扫描也叫缺少索引，索引名是ixUpByMemberID，注意索引扫描不是索引查找，索引扫描是说把索引组织上的页全部扫描了一遍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141351592-1700336953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141359214-1394911379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再通过下图我们清楚知道，ixUpByMemberID有5个区。5个区加起来的data_pages总页数是69730。上图逻辑读取是69951。相当于把索引中的页全部扫描了一遍。也可说是把12236142条数据全扫描了一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141440030-1975830267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在锁的介绍中我们知道，锁越多，发生阻塞和死锁的几率就越大。&lt;br/&gt;　　通过下图，对于page资源来说，就有IS锁(意向共享锁)上1000个。IS锁与X排它锁又不兼容，此时多用户在修改，删除表中数据时，将会发生阻塞或死锁的影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141525714-1183355430.png&quot; alt=&quot;&quot; width=&quot;810&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141539771-685467599.png&quot; alt=&quot;&quot; width=&quot;884&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141555238-422064638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　总结：如果在生产环境，面对大数据表，条件查询很频繁，又缺失索引，系统整体性能将会被拖垮。&lt;/p&gt;
&lt;p&gt; 　　2.2 查询索引查找的演示&lt;/p&gt;
&lt;p&gt;　　用户根据model查询，缺少了一个索引，在给model建立索引后，再来看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询型号model 值STI5203 在全表中有三条&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; Model &lt;span&gt;FROM&lt;/span&gt; dbo.Product &lt;span&gt;WHERE&lt;/span&gt; Model&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;STI5203&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图的执行计划告诉我们是索引查找，也就是索引使用上了，该索引名叫ix_mdoel. 扫描计数&lt;span&gt;1 个区&lt;/span&gt;，逻辑读取次数为&lt;span&gt;4次&lt;/span&gt;，耗时&lt;span&gt;0毫秒&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141850199-736162570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141906524-857431221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再来看下索引查找的锁状态，下图告诉我们，只有锁往了一个&lt;span lang=&quot;EN-US&quot;&gt;page资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628141920875-620161336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　总结：在大表上，合理使用了索引查找后，不但查询响应时间变快了，而且没有了大量的锁，相应的在其它page页上的修改，删除应不会受到影响。&lt;/p&gt;
&lt;h3&gt;三. B-tree组织存储空间的影响&lt;/h3&gt;
&lt;p&gt;　　我们知道了对于聚集索引，它的叶子层就是数据本身，但当一个表有多个非聚集索引时，就需要对数据库存储空间加倍来支持这些索引的存储，所以从占用存储空间来说，在建非聚集索引时需要好好规划。下面是来自生产环境的一个表，有聚集索引和四个非聚集索引，来看看索引存储空间&lt;br/&gt;在index_id=1的聚集索引中占用的空间total_pages是1448806页，也就是表的数据本身。 而非聚集索引占用空间total_pages是2180034页， 非聚集索引占用空间比表数据本身大了1.5倍。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180628142244481-565663768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;树&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 06:55:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9238470.html</dc:identifier>
</item>
<item>
<title>CDN边缘节点容器调度实践（上） - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/9238605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/9238605.html</guid>
<description>&lt;p&gt;又拍云容器云是基于 Docker 的分布式计算资源网，节点分散在全国各地及海外，提供电信、联通、移动和多线网络，融合微服务、DevOps 理念，满足精益开发、运维一体化，大幅降低分布式计算资源构建复杂度，大幅降低使用成本。&lt;/p&gt;
&lt;p&gt;上文是对容器云的简介，又拍云容器云是一个基于 Docker 的边缘容器网络。&lt;/p&gt;
&lt;p&gt;过去，又拍云数据中心用的是基于 Mesos 的容器调度平台。它把数据中心的 CPU、内存、磁盘等抽象成一个资源池，Mesos 官方称之为分布式系统内核。&lt;/p&gt;

&lt;h2&gt;Mesos架构&lt;/h2&gt;
&lt;p&gt;下图是 Mesos 容器调度平台的架构图。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-e61128d388b7b01d15e0993711b2ca95_hd.jpg&quot; alt=&quot;&quot; width=&quot;546&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;546&quot; data-rawheight=&quot;245&quot; data-original=&quot;https://pic1.zhimg.com/v2-e61128d388b7b01d15e0993711b2ca95_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e61128d388b7b01d15e0993711b2ca95_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ Mesos 架构&lt;/p&gt;
&lt;p&gt;Mesos 调度平台相当于数据中心的 Master，同时在每个节点上都有一个 Agent。当每个Agent 启动后会向 Mesos 注册，Agent 携带的资源信息，让 Mesos 决定每个框架的资源数量。当框架收到资源后，再根据需求调度资源。&lt;/p&gt;
&lt;p&gt;Mesos Master 调度机制后面是 framework，通过 framework 可以满足数据中心的容器调度。&lt;/p&gt;

&lt;h2&gt;边缘容器调度方案概述&lt;/h2&gt;
&lt;p&gt;下面我们简要介绍下又拍云的边缘容器调度方案。又拍云边缘节点容器调度方案需要有一个部署在数据中心的 Master，负责集中调度统一管理。而 Agent 则部署在全国各个边缘节点上，每个节点的每台机器上都会有一个 Agent，负责采集数据，管理 Docker。在边缘运行长期服务，支持故障恢复。同一个节点的一批机器会组成一个集群。另外，因为又拍云有不同需求的客户，所以边缘节点需要部署多种功能，功能部署时要完成容器网络的隔离，还会有一些负载均衡和定制化的需求。&lt;/p&gt;
&lt;p&gt;版本 1 实现了调度策略最基本的功能&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-c34aaccd7d644c1c84d57cf25c270d4e_hd.jpg&quot; alt=&quot;&quot; width=&quot;562&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;562&quot; data-rawheight=&quot;372&quot; data-original=&quot;https://pic2.zhimg.com/v2-c34aaccd7d644c1c84d57cf25c270d4e_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c34aaccd7d644c1c84d57cf25c270d4e_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 版本1&lt;/p&gt;
&lt;p&gt;上图是最基础的版本1 Master—Agent 架构。最上面是 Hancock （又拍云内部项目名称），它本身就是 Master，App 的拥有者可以通过 API 接口接入，部署任务、创建 Docker 项目到边缘节点。&lt;/p&gt;
&lt;p&gt;这两个虚线的框分别表示两个不同的节点，每个节点上数量不等的机器会组成一个小集群，每个机器上会部署一个 Agent， Agent 会负责创建各个 Docker 的 Task，容器服务的用户(App user ) 直接会去边缘节点访问容器服务。&lt;/p&gt;
&lt;p&gt;Agent 启动后会上报消息到 Master， 而 Master 会根据用户的请求和上报的消息下发指定给 Agent 。由于边缘节点和数据中心的网络可能处于不稳定的状态，在处理数据的时候会出现超时、延迟等问题，同步操作可能会导致用户的请求一直得不到响应，最终导致信息丢失等问题，因此 Master 与 Agent 的数据交互、消息处理都是异步进行的。这种情况下，用户只要把请求提交到 Hancock Master 上，这个任务就会分发到所有的边缘节点。&lt;/p&gt;
&lt;p&gt;下面是 Master-Agent 消息介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上报消息 Agent -&amp;gt; Master&lt;/li&gt;
&lt;li&gt;下发指令 Master -&amp;gt; Agent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Resource 消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-c0698bf9cba4cbe6fe00406feabccce0_hd.jpg&quot; alt=&quot;&quot; width=&quot;612&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;612&quot; data-rawheight=&quot;279&quot; data-original=&quot;https://pic4.zhimg.com/v2-c0698bf9cba4cbe6fe00406feabccce0_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c0698bf9cba4cbe6fe00406feabccce0_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当 Agent 启动时会携带 Resource 消息 ，当携带资源信息发生变更时，会更新一次 Resource 消息 。如图所示，Agent 通过节点名和主机名来唯一表示一台边缘设备，设备的资源信包括，网络信息（包括运营商信息、宽带信息），CPU， 内存， 磁盘，可用端口信息等，其中端口段的分配是因为有个摄像头的用户一个服务需要用到几千个端口，这种情况就不再适合逐个端口进行随机或者指定分配，这样维护成本会变得很高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Offer 消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-5fe6496c31a85d5775a44ea775e2d07e_hd.jpg&quot; alt=&quot;&quot; width=&quot;618&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;618&quot; data-rawheight=&quot;247&quot; data-original=&quot;https://pic2.zhimg.com/v2-5fe6496c31a85d5775a44ea775e2d07e_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5fe6496c31a85d5775a44ea775e2d07e_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Agent 会定时上报 Offer 消息上报给 Master，会发送机器的 load 和当前网络状况的使用情况、CPU、Memory、Disk等使用情况信息，以此维持 Master 与 Agent 之间的联系。&lt;/p&gt;
&lt;p&gt;一般来说，Master 可以计算出 CPU、Memory、Disk 的使用情况。但是 load 和网络状况，Master 是无法知晓的，所以每隔一段时间就要上报，以供 Master 合理的调度 Docker 机器，比如不应该再安排服务部署到 load 较高的机器上。上述就是 offer 的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-4bb694dab5c91254107d7f6fa4730515_hd.jpg&quot; alt=&quot;&quot; width=&quot;622&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;622&quot; data-rawheight=&quot;215&quot; data-original=&quot;https://pic2.zhimg.com/v2-4bb694dab5c91254107d7f6fa4730515_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4bb694dab5c91254107d7f6fa4730515_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;负责提供实例的状态变更，Docker 实例运行成功失败等信息， 由 Agent 实时上报给 Master， 包含任务的状态信息和相关描述。方便 Master 进行故障恢复等操作。&lt;/p&gt;
&lt;p&gt;Containers 消息&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-0585251cfced305995b58f68b5e16451_hd.jpg&quot; alt=&quot;&quot; width=&quot;624&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;624&quot; data-rawheight=&quot;141&quot; data-original=&quot;https://pic4.zhimg.com/v2-0585251cfced305995b58f68b5e16451_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-0585251cfced305995b58f68b5e16451_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;负责提供机器容器列表， 防止有僵尸任务和任务遗漏， 由 Agent 定时上报给 Master， Master 负责检查。&lt;/p&gt;
&lt;p&gt;Master 到 Agent 的指令下发过程中，主要包括两个类下发指令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例的创建，如增删改查，把客户增删改查请求转变为对容器的操作&lt;/li&gt;
&lt;li&gt;镜像操作，如镜像拉取，镜像查询。比如 Docker 镜像很大的时候，在边缘节点拉取镜像可能会超时。所以我们设置了一个单独的镜像操作，保证在创建容器前，可以预先异步提交拉取命令。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-b37a03131b4a9085f9e5b123ae8aab43_hd.jpg&quot; alt=&quot;&quot; width=&quot;473&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;473&quot; data-rawheight=&quot;418&quot; data-original=&quot;https://pic4.zhimg.com/v2-b37a03131b4a9085f9e5b123ae8aab43_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b37a03131b4a9085f9e5b123ae8aab43_b.jpg&quot;/&gt;△ 处理流程&lt;/p&gt;
&lt;p&gt;上图是消息处理流程，当 Agent 启动时上报 Resource、Offer、Container 等定时消息。其中 offer 消息频率最高， 一旦一段时间没有受到 Offer 消息， Master 会尝试迁移这个 Agent 对应机器上的所有容器实例。&lt;/p&gt;
&lt;p&gt;上述版本 1 的架构实现了调度策略最基本的功能。当 Master 收到各个集群中 Agent 上报的资源时，通过自定义策略来完成任务调度。一般来说是寻找满足条件的（Node Cpu Mem Disk Port 等）机器。再选择根据带宽、load 等指标，进行权重估算，在估算出权重的前提下进行随机调度。在权重类似的情况下，每次调度尽可能让同一服务的各个实例分布到节点的不同机器，保证在某台机器崩溃的情况下，其他实例正常运行保证高可用。&lt;/p&gt;

&lt;h2&gt;版本 2 增加 calico，负责网络控制和访问限制&lt;/h2&gt;
&lt;p&gt;在版本 1 中，Master 和 Agent 已经完成了两者之间的消息交互。App 拥有者可以创建服务，并且在边缘机器上创建 Task。&lt;/p&gt;
&lt;p&gt;但我们不希望客户的服务混杂在一起，希望可以隔离不同所有者的容器网络， 可以完成一些访问控制的功能。又拍云使用了 calico 的方案，它是基于 BGP 的路由协议的三层通信模型，不需要额外报文封装。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-9944f7bd00dbada9a7423c47a0467afa_hd.jpg&quot; alt=&quot;&quot; width=&quot;390&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;390&quot; data-rawheight=&quot;223&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9944f7bd00dbada9a7423c47a0467afa_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 容器网络（图片来自网络）&lt;/p&gt;
&lt;p&gt;如图所示，其中 calico BGP client 负责每个节点和集群其他节点建立 BGP Peer 连接，增长趋势是 O(n^2)，它并不适合大规模的集群网络， 解决方法是 Route Reflector，选择一部分节点作为 Global BGP Peer，由它们互联来交换路由信息。而又拍云每个边缘集群都是小规模集群网络，O(n^2) 的增长是可以接受的，并不需要 Route Reflector 的机制。&lt;/p&gt;
&lt;p&gt;其中 Felix 负责节点网络相关配置。由它负责配置路由表、iptables 表项等。以便完成访问控制和隔离的功能。&lt;/p&gt;
&lt;p&gt;另外，集群中还会有一个分布式的 kv 数据库—— etcd，负责保存网络元数据。&lt;/p&gt;

&lt;p&gt;calico 的优点： 三层互联，不需要报文封装。访问控制， 满足隔离网络， 隔离容器。&lt;/p&gt;
&lt;p&gt;calico 的缺点： 网络规模限制， iptables 和路由表项限制。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-612cb94024978469b8d15f7f873372c6_hd.jpg&quot; alt=&quot;&quot; width=&quot;563&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;563&quot; data-rawheight=&quot;364&quot; data-original=&quot;https://pic1.zhimg.com/v2-612cb94024978469b8d15f7f873372c6_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-612cb94024978469b8d15f7f873372c6_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 版本2&lt;/p&gt;
&lt;p&gt;在我们的场景下，它很好的满足了需求。加上 calico 方案，版本 2 的架构如上图所示。&lt;/p&gt;

&lt;p&gt;对内容感兴趣的小伙伴，欢迎关注下我们，《CDN边缘节点容器调度实践（下）》将于明天推送。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 06:44:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/9238605.html</dc:identifier>
</item>
<item>
<title>ExceptionLess  ASP.NET MVC  异常日志框架 - KiSs_小白</title>
<link>http://www.cnblogs.com/xiaobai123/p/9238415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobai123/p/9238415.html</guid>
<description>&lt;p&gt;Exceptionless&lt;/p&gt;
&lt;p&gt;      一个开源的实时的日志收集框架，它可以应用在基于 ASP.NET，ASP.NET Core，Web API，Web Forms，WPF，Console，ASP.NET MVC 等技术开发的应用程序中，并且提供了REST接口可以应用在 Javascript，Node.js 中。它将日志收集变得简单易用并且不需要了解太多的相关技术细节及配置。&lt;/p&gt;
&lt;p&gt;ExceptionLess官网：&lt;a href=&quot;http://exceptionless.com/&quot;&gt;http://exceptionless.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/exceptionless/Exceptionless&quot;&gt;https://github.com/exceptionless/Exceptionless&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;1 官方创建账号&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;11&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628131129933-658369847.png&quot; alt=&quot;11&quot; width=&quot;400&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;2 创建项目&lt;/h2&gt;
&lt;p&gt;如果托管在&lt;a href=&quot;http://exceptionless.com/&quot;&gt;http://exceptionless.com/&lt;/a&gt;这个上面,大于一个项目是需要收费的。   &lt;/p&gt;
&lt;p&gt;可以自己部署一套源码放到IIS上面  &lt;/p&gt;
&lt;p&gt;大家可以参考&lt;/p&gt;
&lt;p&gt; https://www.cnblogs.com/uptothesky/p/5864863.html&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628131237161-681901652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628131353337-1650196025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3 ApiKey&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;111&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628133215538-446402444.png&quot; alt=&quot;11&quot; width=&quot;600&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;








&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;4 Visual Studio 新建立一个ASP.NET MVC项目&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628133816669-867165085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;5 Web.Config中找到exceptionless节点，apikey属性值设置为官方给你的key&lt;/h2&gt;
&lt;pre&gt;
&lt;a href=&quot;http://nuget.org/packages/Exceptionless.Mvc&quot;&gt;Install-Package Exceptionless.Mvc&lt;/a&gt; 成功以后  如下代码会自动加入到web.config
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;configSections&amp;gt;
    &amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exceptionless&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exceptionless.ExceptionlessSection, Exceptionless&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;   自动加入1
  &amp;lt;/configSections&amp;gt;
  &amp;lt;appSettings&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webpages:Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.0.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webpages:Enabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClientValidationEnabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UnobtrusiveJavaScriptEnabled&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProjectName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HelloWord&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
  &amp;lt;/appSettings&amp;gt;
  &amp;lt;exceptionless apiKey=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ducXJBe0wLD1yq6IhjGJwyCNnakual1Q7lQFGi1H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt; 自动加入2 将key跟环成你自己的就行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完毕  看看效果如何&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Your application description page.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult About()
        {
            ViewBag.Message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your application description page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your application description page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;F5 运行项目&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628134854071-400289582.png&quot; alt=&quot;1&quot; width=&quot;400&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后刷新 https://be.exceptionless.io/dashboard&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628134832104-233227712.png&quot; alt=&quot;1&quot; width=&quot;704&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6 集成Logger 日志 统计&lt;/h2&gt;
&lt;p&gt;创建ExceptionLessLog类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Exceptionless;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Exceptionless.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.VisualBasic.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; HelloWord.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionLessLog:Log
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 跟踪
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Trace(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Trace).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 调试
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Debug(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Debug).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Info(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Info).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 警告
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Warn(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Warn).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Error).AddTags(tags).Submit();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 首页
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户登录了111111
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            ExceptionLessLog.Info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户登录了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Your application description page.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult About()
        {
            ViewBag.Message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your application description page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            ExceptionLessLog.Debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your application description page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Your contact page.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ActionResult Contact(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            ViewBag.Message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your contact page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            ExceptionLessLog.Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your contact page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img title=&quot;2&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628140035402-555864564.png&quot; alt=&quot;2&quot; width=&quot;488&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到一些项目和日志的基本信息，比如Event Type，Level以及标签Tags&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628140333453-1938127246.png&quot; alt=&quot;1&quot; width=&quot;800&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;7 ControllerName/actionName 注解&lt;/h2&gt;
&lt;p&gt;原理：根据swagger一样  根据xml方式获取方法注解&lt;/p&gt;
&lt;p&gt;先右键项目 &lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;11&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628140934078-265043081.png&quot; alt=&quot;11&quot; width=&quot;600&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在web.config 加入  value=&quot;你自己创建的项目名称&quot;&lt;/p&gt;
&lt;p&gt;&amp;lt;add key=&quot;ProjectName&quot; value=&quot;HelloWord&quot;/&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyActionFilter : ActionFilterAttribute
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 方法执行后进行的操作
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filterContext&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuted(ActionExecutedContext filterContext)
        {
           
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; con = filterContext.Controller &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Controller;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName =&lt;span&gt; filterContext.ActionDescriptor.ControllerDescriptor.ControllerName;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName =&lt;span&gt; filterContext.ActionDescriptor.ActionName;


            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proejctName = ConfigurationManager.AppSettings[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProjectName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到包含注释的xml文档&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; xml = XDocument.Load(con.Server.MapPath(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;~/bin/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + proejctName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.XML&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到方法上的注释
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到方法上的注释没有参数的方法没有(括号&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; summary = (&lt;span&gt;from&lt;/span&gt; member &lt;span&gt;in&lt;/span&gt; xml.Elements(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Elements(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;members&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Elements(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;member&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; member.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value.ToString().Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + controllerName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Controller.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + actionName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;select&lt;/span&gt; member.Element(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value).FirstOrDefault() ??&lt;span&gt;
                         (&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; member &lt;span&gt;in&lt;/span&gt; xml.Elements(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Elements(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;members&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Elements(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;member&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; member.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value.ToString().Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + controllerName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Controller.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + actionName) &lt;span&gt;select&lt;/span&gt; member.Element(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value).FirstOrDefault();

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; des = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controllerName}/{actionName}/{summary}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            ExceptionlessClient.Default.CreateFeatureUsage(des).AddTags(summary).Submit();

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后添加这个  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FilterConfig
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterGlobalFilters(GlobalFilterCollection filters)
        {
            filters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HandleErrorAttribute());
            filters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyActionFilter());  //添加此处代码
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样Exceptionless就能很直观看到了&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;2&quot; src=&quot;https://images2018.cnblogs.com/blog/517088/201806/517088-20180628140035402-555864564.png&quot; alt=&quot;2&quot; width=&quot;488&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 06:12:00 +0000</pubDate>
<dc:creator>KiSs_小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobai123/p/9238415.html</dc:identifier>
</item>
<item>
<title>windows平台下实现高可用性和可扩展性-ARR和HLB - tianyamoon</title>
<link>http://www.cnblogs.com/tianyamoon/p/9237952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianyamoon/p/9237952.html</guid>
<description>&lt;p class=&quot;x-hidden-focus&quot;&gt;本文档提供了关于如何将应用程序请求路由(ARR)与硬件负载均衡器一起使用以实现高可用性和可伸缩性的说明性指导。本文采用F5大IP负载均衡器来说明ARR与硬件负载平衡器之间的工作关系。&lt;/p&gt;
&lt;p&gt;IIS7.0及以上版本的Microsoft Application Request Routing(ARR)是一个基于代理的路由模块，它基于HTTP报头、服务器变量和负载平衡算法将HTTP请求转发到内容服务器。下图显示了典型的ARR部署：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/21899/201806/21899-20180628101655711-1247768113.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然ARR为内容服务器(Content server)提供了高可用性和可伸缩性，但总体部署并不是高度可用或可伸缩的，因为：&lt;/p&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;为了克服这些挑战，管理员可以考虑使用多个具有硬件负载均衡器的ARR服务器，例如F5大IP。ARR可以在主动/被动模式下部署，以实现高可用性，也可以在主动/主动模式下实现高可用性和可伸缩性。本白皮书描述了如何将ARR和F5大IP一起部署，以便在实现总体高可用性和可伸缩性的同时启用核心ARR方案。&lt;/p&gt;

&lt;p id=&quot;trans_yiwen_easy&quot;&gt;ARR是作为IIS之上的一个模块构建的，它的目的是在第7层(应用程序)做出路由决策。更准确地说，ARR依赖另一个IIS模块URL重写来检查传入的HTTP请求头和服务器变量来做出路由决策。根据这种设计，管理员可以根据应用程序级别的信息编写智能路由规则，例如：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li id=&quot;trans_yiwen_easy&quot;&gt;主机名(HTTP_HOST)：根据主机名将通信量路由到不同的内容服务器。&lt;/li&gt;
&lt;li&gt;请求资源(URL)：基于文件扩展名，确定请求的资源是用于静态内容还是用于动态内容，并相应地路由请求。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;客户端信息(HTTP_USER_Agent)：根据浏览器类型和版本，将请求路由到适当的内容服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;自定义标头(由应用程序设置为Cookie)：根据应用程序设置的cookie信息(如用户首选项或用户ID)路由通信量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;trans_yiwen_easy&quot;&gt;以上只是一些例子。有关HTTP头和服务器变量的完整列表，请参阅附录A。&lt;/p&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;F5 BIG-IP的第3层和第4层的功能赞扬了ARR在基于第7层(如HTTP报头和服务器变量)进行路由决策方面的优势。同时，ARR不为自己提供容错部署特性，必须依靠其他互补技术和解决方案来实现ARR层的高可用性，如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/21899/201806/21899-20180628112859130-1610983405.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;场景1：基于http的路由和负载平衡&lt;/h2&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;基于HTTP的路由和负载平衡方案支持三层部署体系结构，其中包括： &lt;/p&gt;
&lt;p&gt; 下图说明了3层部署：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/21899/201806/21899-20180628113418492-284931032.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;尽管上面的示例显示了将静态内容与动态内容区分开来的路由规则，但另一个常见的场景是将表示请求与Web服务请求区分开来。&lt;/p&gt;
&lt;h3&gt;选项1：Active/Passive&lt;/h3&gt;
&lt;p&gt; 在主动/被动模式下，通常有两个ARR服务器，其中一个服务器处理请求，而另一个服务器作为故障转移服务器。如上所述，虽然此配置通过删除单个故障点来实现高可用性，但它并不是一个扩展解决方案，因为内容服务器的总容量受到一个ARR服务器的最大容量的限制。&lt;/p&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;在此设置中，由于两个ARR服务器的配置方式相同，因此使用了共享配置。F5 BIG-IP被配置为将所有请求路由到主动ARR服务器，并且只在必要时将请求路由到被动ARR服务器。&lt;/p&gt;

&lt;p id=&quot;trans_yiwen_easy&quot;&gt;除了ARR中的主机名关联特性外，不存在两个ARR服务器之间必须共享的运行时状态信息。因此，对于这种情况，无论是在ARR服务器上还是在F5 BIG-IP上都不需要特殊的配置。即使您使用ARR中的服务器关联特性，当F5 BIG-IP将请求路由到以前被动但现在主动的服务器时，也会通过请求头中的cookie向被动服务器提供亲缘关系状态信息。&lt;/p&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;这个场景在ARR版本1版本中完全支持。&lt;/p&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;ARR配置&lt;/p&gt;
&lt;p&gt;步骤1：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在两个ARR服务器上启用共享配置。按照本文档中的步骤在IIS中设置共享配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;步骤2：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用arr配置3层部署架构。按照本文档中的步骤在3层部署体系结构中配置ARR。&lt;/li&gt;
&lt;li&gt;在更高层次上，上面的文档描述了：
&lt;ul&gt;&lt;li&gt;如何使ARR服务器上的静态内容可用。&lt;/li&gt;
&lt;li&gt;如何为静态内容编写URL重写规则，以便直接从ARR服务器为它们服务。&lt;/li&gt;
&lt;li&gt;如何为动态内容编写URL重写规则，以便将它们转发到应用程序服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;f5-big-ip-configuration-1&quot; class=&quot;heading-with-anchor&quot;&gt;F5 BIG-IP 配置&lt;/h4&gt;
&lt;p id=&quot;trans_yiwen_easy&quot;&gt;在这种情况下，所有可用的ARR服务器都被认为是活动的，并且是负载均衡通信量的候选服务器。使用BIG-IP LTM来确定ARR前端的健康和性能，并将流量引导到性能最好的前端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤1：配置ARR服务器池&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在“Local Traffic”部分，单击“pool”。然后单击Create按钮创建一个池。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-0&quot;&gt;任何唯一的名称都适用于池;&lt;span class=&quot;transSent highlight&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-1&quot;&gt;这个例子使用ARR_Pool。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-2&quot;&gt;对于健康监视器，您可以使用定制的HTTP监视器或默认的HTTP监视器。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-3&quot;&gt;-你可以把负载平衡方法设置为循环。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-4&quot;&gt;在这个场景中，由于只有一个主动和被动的ARR服务器，所以不使用负载平衡。&lt;span class=&quot;transSent highlight&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-5&quot;&gt;-一定要启用优先级组激活。这会配置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; BIG-IP &lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-6&quot;&gt;以最高优先级的值将流量发送到服务器（s）。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-7&quot;&gt;当这些服务器（s）不可用时，大ip将流量发送到ARR服务器，并获得下一个最高优先级值。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-8&quot;&gt;在这个场景中，10.0.1的ARR服务器的优先级值为1，10.0.0.2的优先级值为2。&lt;span class=&quot;transSent&quot; data-v-4c8ee738=&quot;&quot; data-group=&quot;0-9&quot;&gt;所有的流量将被发送到10.0.2，直到它下降，然后流量将被发送到10.0.1。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image19.jpg&quot; data-linktype=&quot;relative-path&quot;&gt;&lt;img src=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image20.jpg&quot; alt=&quot;&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;步骤2：配置虚拟服务器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在“本地流量”部分，单击“虚拟服务器”。然后单击Create按钮创建虚拟服务器。&lt;/li&gt;
&lt;li&gt;任何唯一的名称都适用于虚拟服务器；示例使用arr_vs.-对于目标，可以使用用户指向浏览器的IP地址。在这种情况下，我们使用。对于服务端口，我们使用‘80’。-对于虚拟服务器类型部分，您有几个选项。因为您依赖于arr来路由，所以可以选择PerformanceHTTP，这是为最佳性能而设计的。-对于默认池，选择在步骤1中创建的池。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image21.jpg&quot; data-linktype=&quot;relative-path&quot;&gt;&lt;img src=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image22.jpg&quot; alt=&quot;&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此时，您应该能够连接到此VirtualServer，该服务器将被发送到适当的ARR服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;option-2-activeactive-in-arr&quot; class=&quot;heading-with-anchor&quot;&gt;备选案文2：积极/活跃在ARR中&lt;/h3&gt;
&lt;p&gt;在活动/活动模式下，可以有两个或多个ARR服务器。这种配置实现了高可用性和可伸缩性，与仅实现高可用性的活动/传递模式不同。由于多个ARR服务器的配置方式相同，因此使用了共享配置。F5大IP被配置为将传入请求加载到所有可用和健康的ARR服务器，而ARR服务器反过来将请求转发给内容服务器。&lt;/p&gt;
&lt;p&gt;如前所述，主机名和内容服务器之间亲合映射的运行时状态信息存储在arr服务器实例中的内存中。为了在多个ARR服务器之间共享此信息，使用Microsoft外部IIS缓存。有关外部缓存的详细信息，请参阅&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/using-multiple-instances-of-application-request-routing-arr-servers&quot; data-linktype=&quot;relative-path&quot;&gt;这&lt;/a&gt;文件。&lt;/p&gt;
&lt;h4 id=&quot;arr-configuration-3&quot; class=&quot;heading-with-anchor&quot;&gt;ARR组态&lt;/h4&gt;
&lt;p&gt;主动/主动的ARR结构与主动/被动的ARR结构相同。主要区别在于F5是如何配置的。&lt;/p&gt;
&lt;p&gt;步骤1：在两个ARR服务器上启用共享配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按照下面的步骤&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/manage/managing-your-configuration-settings/shared-configuration_264&quot; data-linktype=&quot;relative-path&quot;&gt;这&lt;/a&gt;要在IIS中设置共享配置的文档。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;步骤2：使用arr配置3层部署架构。&lt;/p&gt;
&lt;p&gt;步骤3：启用和配置外部缓存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按照下面的步骤&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/using-multiple-instances-of-application-request-routing-arr-servers&quot; data-linktype=&quot;relative-path&quot;&gt;这&lt;/a&gt;文档以启用和配置外部缓存以与arr一起使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;f5-big-ip-configuration-3&quot; class=&quot;heading-with-anchor&quot;&gt;F5大IP配置&lt;/h4&gt;
&lt;p&gt;在这种情况下，所有可用的ARR服务器都被认为是活动的，并且是负载均衡通信量的候选服务器。使用大ip ltm来确定arr前端的健康和性能，并将流量引导到性能最好的前端。&lt;/p&gt;
&lt;p&gt;步骤1：配置ARR服务器池。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在“本地交通”部分，单击“池”。然后单击Create按钮创建一个池。&lt;/li&gt;
&lt;li&gt;任何唯一的名称都适用于池；示例使用arr_Pool。-对于HealthMonitor，您可以使用自定义HTTP监视器或默认HTTP监视器。-由于您有多个ARR服务器来分发通信量，所以需要选择最适合您的需要的负载平衡方法。假设所有arr服务器都具有相似的硬件特性，则动态负载平衡方法(如最快、可观察或预测)将为您提供基于性能的分发。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image23.jpg&quot; data-linktype=&quot;relative-path&quot;&gt;&lt;img src=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image24.jpg&quot; alt=&quot;&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;步骤2：配置虚拟服务器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在“本地流量”部分，单击“虚拟服务器”。然后单击Create按钮创建虚拟服务器。&lt;/li&gt;
&lt;li&gt;任何唯一的名称都适用于虚拟服务器；示例使用arr_vs.-对于目标，可以使用用户指向浏览器的IP地址。在这种情况下，我们使用。对于服务端口，我们使用‘80’。-对于虚拟服务器类型部分，您有几个选项。因为您依赖于arr来路由，所以可以选择PerformanceHTTP，这是为最佳性能而设计的。-对于默认池，选择在步骤1中创建的池。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image25.jpg&quot; data-linktype=&quot;relative-path&quot;&gt;&lt;img src=&quot;https://docs.microsoft.com/en-us/iis/extensions/configuring-application-request-routing-arr/achieving-high-availability-and-scalability-arr-and-hardware-load-balancer/_static/image26.jpg&quot; alt=&quot;&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;summary&quot; class=&quot;heading-with-anchor&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在本白皮书中，回顾了两种主要的ARR场景，通过部署多个ARR服务器和使用F5大IP来实现高可用性和可伸缩性。&lt;/p&gt;
&lt;h2 id=&quot;appendix&quot; class=&quot;heading-with-anchor&quot;&gt;附录&lt;/h2&gt;

&lt;h3 id=&quot;appendix-a-all-available-http-headers-and-server-variables-for-writing-routing-decision-rules&quot; class=&quot;heading-with-anchor&quot;&gt;附录A：用于编写路由决策规则的所有可用HTTP头和服务器变量。&lt;/h3&gt;

</description>
<pubDate>Thu, 28 Jun 2018 05:54:00 +0000</pubDate>
<dc:creator>tianyamoon</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianyamoon/p/9237952.html</dc:identifier>
</item>
<item>
<title>（10）学习笔记 ） ASP.NET CORE微服务 Micro-Service ---- Ocelot+Identity Server - 情话布墨</title>
<link>http://www.cnblogs.com/qhbm/p/9238179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qhbm/p/9238179.html</guid>
<description>&lt;p&gt;用 JWT 机制实现验证的原理如下图：  认证服务器负责颁发 Token（相当于 JWT 值）和校验 Token 的合法性。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953915/201806/953915-20180628102243203-620623429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953915/201806/953915-20180628102309258-1476512321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;一、 相关概念&lt;/h2&gt;
&lt;p&gt;API 资源（API Resource）：微博服务器接口、斗鱼弹幕服务器接口、斗鱼直播接口就是API 资源。&lt;/p&gt;
&lt;p&gt;客户端（Client）：Client 就是官方微博 android 客户端、官方微博 ios 客户端、第三方微博客户端、微博助手等。&lt;/p&gt;
&lt;p&gt;身份资源（Identity Resource）：就是用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953915/201806/953915-20180628102329252-2093649375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个用户可能使用多个客户端访问服务器；一个客户端也可能服务多个用户。封禁了一个客户端，所有用户都不能使用这个这个客户端访问服务器，但是可以使用其他客户端访问；封禁了一个用户，这个用户在所有设备上都不能访问，但是不影响其他用户。&lt;/p&gt;
&lt;h2&gt;二、 搭建 identity server 认证服务器&lt;/h2&gt;
&lt;p&gt;新建一个空的 web 项目 ID4.IdServer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Nuget - 》 Install-Package IdentityServer4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先编写一个提供应用列表、账号列表的 Config 类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ID4.IdServer
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Config
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回应用列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApiResources()
        {
            List&lt;/span&gt;&amp;lt;ApiResource&amp;gt; resources = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ApiResource&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApiResource第一个参数是应用的名字，第二个参数是描述&lt;/span&gt;
            resources.Add(&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MsgAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息服务API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            resources.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;产品API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resources;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回账号列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;         
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            List&lt;/span&gt;&amp;lt;Client&amp;gt; clients = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Client&amp;gt;&lt;span&gt;();
            clients.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
            {
                ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientPC1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;API账号、客户端Id&lt;/span&gt;
                AllowedGrantTypes =&lt;span&gt; GrantTypes.ClientCredentials,
                ClientSecrets &lt;/span&gt;=&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.Sha256())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秘钥&lt;/span&gt;
&lt;span&gt;                },
                AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MsgAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个账号支持访问哪些应用&lt;/span&gt;
&lt;span&gt;            });
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clients;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果允许在数据库中配置账号等信息，那么可以从数据库中读取然后返回这些内容。疑问待解。&lt;/p&gt;
&lt;p&gt;修改Startup.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddIdentityServer()
        .AddDeveloperSigningCredential()
        .AddInMemoryApiResources(Config.GetApiResources())
        .AddInMemoryClients(Config.GetClients());
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseIdentityServer();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在 9500 端口启动&lt;/p&gt;
&lt;p&gt; 在 postman 里发出请求，获取 token http://localhost:9500/connect/token，发 Post 请求，表单请求内容（注意不是报文头）：&lt;/p&gt;
&lt;p&gt;client_id=clientPC1   client_secret=123321   grant_type=client_credentials&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953915/201806/953915-20180628103257680-624257103.gif&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;把返回的 access_token 留下来后面用（注意有有效期）。  注意，其实不应该让客户端直接去申请 token，这只是咱演示，后面讲解正确做法。&lt;/p&gt;
&lt;h2&gt;三、搭建 &lt;strong&gt;Ocelot&lt;/strong&gt; 服务器项目&lt;/h2&gt;
&lt;p&gt;空 Web 项目，项目名 ID4.Ocelot1&lt;/p&gt;
&lt;p&gt;nuget 安装 IdentityServer4、Ocelot&lt;/p&gt;
&lt;p&gt;编写配置文件 Ocelot.json（注意设置【如果较新则】）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/MsgService/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MsgService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoadBalancerOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RoundRobin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            },
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UseServiceDiscovery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;AuthenticationOptions&quot;: {
                &quot;AuthenticationProviderKey&quot;: &quot;&lt;span&gt;MsgKey&lt;/span&gt;&quot;,
                &quot;AllowedScopes&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;: []
            }&lt;/span&gt;
        },
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ProductService/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LoadBalancerOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RoundRobin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            },
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UseServiceDiscovery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;AuthenticationOptions&quot;: {
                &quot;AuthenticationProviderKey&quot;: &quot;&lt;span&gt;ProductKey&lt;/span&gt;&quot;,
                &quot;AllowedScopes&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;: []
            }&lt;/span&gt;
        }
    ],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GlobalConfiguration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ServiceDiscoveryProvider&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;8500&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 把/MsgService 访问的都转给消息后端服务器（使用Consul进行服务发现）。也可以把Identity Server配置到Ocelot，但是我们不做，后边会讲为什么不放。&lt;/p&gt;
&lt;p&gt;Program.cs 的 CreateWebHostBuilder 中加载 Ocelot.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
.ConfigureAppConfiguration((hostingContext, builder) =&amp;gt;&lt;span&gt;
{
         builder.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ocelot.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改 Startup.cs 让 Ocelot 能够访问 Identity Server 进行 Token 的验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.AccessTokenValidation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Ocelot.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Ocelot.Middleware;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ID4.Ocelot1
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定Identity Server的信息&lt;/span&gt;
&lt;span&gt;            Action&amp;lt;IdentityServerAuthenticationOptions&amp;gt; isaOptMsg = o =&amp;gt;
            {
                o.Authority = &quot;http://localhost:9500&quot;;
                o.ApiName = &quot;MsgAPI&quot;;//要连接的应用的名字
                o.RequireHttpsMetadata = false;
                o.SupportedTokens = SupportedTokens.Both;
                o.ApiSecret = &quot;123321&quot;;//秘钥
&lt;/span&gt;&lt;span&gt;&lt;span&gt;            };&lt;/span&gt;
            &lt;span&gt;Action&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;IdentityServerAuthenticationOptions&amp;gt; isaOptProduct = o =&amp;gt;
            {
                o.Authority = &quot;http://localhost:9500&quot;;
                o.ApiName = &quot;ProductAPI&quot;;//要连接的应用的名字
                o.RequireHttpsMetadata = false;
                o.SupportedTokens = SupportedTokens.Both;
                o.ApiSecret = &quot;123321&quot;;//秘钥            
&lt;/span&gt;&lt;span&gt;&lt;span&gt;            };&lt;/span&gt;
            services.AddAuthentication()
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对配置文件中使用ChatKey配置了AuthenticationProviderKey=MsgKey
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;的路由规则使用如下的验证方式&lt;/span&gt;
                .AddIdentityServerAuthentication(&lt;span&gt;&quot;&lt;span&gt;MsgKey&lt;/span&gt;&quot;, isaOptMsg&lt;/span&gt;).AddIdentityServerAuthentication(&lt;span&gt;&quot;&lt;span&gt;ProductKey&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;, isaOptProduct&lt;/span&gt;); services.AddOcelot();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.         &lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();

            }
            app.UseOcelot().Wait();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然我们可以让不同的服务采用不同的Identity Server。&lt;/p&gt;
&lt;p&gt;启动 Ocelot 服务器，然后向 ocelot 请求/MsgService/SMS/Send_MI（报文体还是要传 json 数据），在请求头（不是报文体）里加上：&lt;/p&gt;
&lt;p&gt;Authorization=&quot;Bearer &quot;+上面 identityserver 返回的 accesstoken&lt;/p&gt;
&lt;p&gt; 如果返回 401，那就是认证错误。&lt;/p&gt;
&lt;p&gt; Ocelot 会把 Authorization 值传递给后端服务器，这样在后端服务器可以用 IJwtDecoder 的这个不传递 key 的重载方法 IDictionary&amp;lt;string, object&amp;gt; DecodeToObject(string token)，就可以在不验证的情况下获取 client_id 等信息。&lt;/p&gt;
&lt;p&gt; 也可以把 Identity Server 通过 Consul 进行服务治理。&lt;/p&gt;
&lt;p&gt; Ocelot+Identity Server 实现了接口的权限验证，各个业务系统不需要再去做验证。&lt;/p&gt;
&lt;h3&gt;四、不能让客户端请求 &lt;strong&gt;token&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;上面是让客户端去请求 token，如果项目中这么搞的话，就把 client_id 特别是 secret 泄露给普通用户的。&lt;/p&gt;
&lt;p&gt;正确的做法应该是，开发一个 token 服务，由这个服务来向 identity Server 请求 token，客户端向 token 服务发请求，把 client_id、secret 藏到这个 token 服务器上。当然这个服务器也要经过 Ocelot 转发。&lt;/p&gt;
&lt;h3&gt;五、用户名密码登录&lt;/h3&gt;
&lt;p&gt;如果 Api 和用户名、密码无关（比如系统内部之间 API 的调用），那么上面那样做就可以了，但是有时候需要用户身份验证的（比如 Android 客户端）。也就是在请求 token 的时候还要验证用户名密码，在服务中还可以获取登录用户信息。&lt;/p&gt;
&lt;p&gt;修改的地方：&lt;/p&gt;
&lt;h3&gt;1、 ID4.IdServer 项目中增加类 ProfileService.cs&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.Services;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ID4.IdServer
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProfileService : IProfileService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims = context.Subject.Claims.ToList(); context.IssuedClaims =&lt;span&gt; claims.ToList();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task IsActiveAsync(IsActiveContext context)
        {
            context.IsActive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;增加类 ResourceOwnerPasswordValidator.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.Models;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.Validation;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Security.Claims;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ID4.IdServer
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据context.UserName和context.Password与数据库的数据做校验，判断是否合法&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (context.UserName == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yzk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; context.Password == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GrantValidationResult(&lt;br/&gt;　　　　　　　　　 subject: context.UserName, &lt;br/&gt;　　　　　　　　　 authenticationMethod: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;br/&gt;　　　　　　　　　 claims: &lt;span&gt;new&lt;/span&gt; Claim[] { &lt;br/&gt;　　　　　　　　　 &lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, context.UserName), &lt;br/&gt;&lt;span&gt;　　　　　　　　　 new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;br/&gt;&lt;span&gt;　　　　　　　　　 new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RealName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;br/&gt;&lt;span&gt;　　　　　　　　　 new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qq@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证失败&lt;/span&gt;
                context.Result = &lt;span&gt;new&lt;/span&gt; GrantValidationResult(TokenRequestErrors.InvalidGrant, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;invalid custom credential&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然这里的用户名密码是写死的，可以在项目中连接自己的用户数据库进行验证。claims 中可以放入多组用户的信息，这些信息都可以在业务系统中获取到。&lt;/p&gt;
&lt;p&gt;Config.cs&lt;/p&gt;
&lt;p&gt;修改一下，主要是把GetClients中的AllowedGrantTypes属性值改为GrantTypes.ResourceOwnerPassword，&lt;/p&gt;
&lt;p&gt;并且在AllowedScopes中加入&lt;/p&gt;
&lt;p&gt;IdentityServerConstants.StandardScopes.OpenId, //必须要添加，否则报forbidden错误                  &lt;/p&gt;
&lt;p&gt;IdentityServerConstants.StandardScopes.Profile&lt;/p&gt;
&lt;p&gt;修改后的 Config.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; IdentityServer4.Models;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ID4.IdServer
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Config
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回应用列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;         
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;        
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApiResources()
        {
            List&lt;/span&gt;&amp;lt;ApiResource&amp;gt; resources = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ApiResource&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApiResource第一个参数是应用的名字，第二个参数是描述&lt;/span&gt;
            resources.Add(&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MsgAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息服务API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            resources.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;产品API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resources;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回客户端账号列表
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;        
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;   
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            List&lt;/span&gt;&amp;lt;Client&amp;gt; clients = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Client&amp;gt;(); clients.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
            {
                ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientPC1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;API账号、客户端Id&lt;/span&gt;
                AllowedGrantTypes =&lt;span&gt; GrantTypes.ResourceOwnerPassword,
                ClientSecrets &lt;/span&gt;=&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.Sha256())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秘钥&lt;/span&gt;
&lt;span&gt;                },
                AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MsgAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProductAPI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,IdentityServerConstants.StandardScopes.OpenId, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须要添加，否则报forbidden错误&lt;/span&gt;
&lt;span&gt;                     IdentityServerConstants.StandardScopes.Profile
                }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个账号支持访问哪些应用&lt;/span&gt;
            }); &lt;span&gt;return&lt;/span&gt;&lt;span&gt; clients;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Startup.cs 的 ConfigureServices 修改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; idResources = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
    {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; IdentityResources.OpenId(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须要添加，否则报无效的 scope 错误               &lt;/span&gt;
            &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile()
    };
    services.AddIdentityServer()
            .AddDeveloperSigningCredential()
            &lt;span&gt;.AddInMemoryIdentityResources(idResources)&lt;/span&gt;
            .AddInMemoryApiResources(Config.GetApiResources())
            .AddInMemoryClients(Config.GetClients())&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            &lt;span&gt;.AddResourceOwnerValidator&amp;lt;ResourceOwnerPasswordValidator&amp;gt;()
            .AddProfileService&amp;lt;ProfileService&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 主要是增加了 AddInMemoryIdentityResources 、 AddResourceOwnerValidator 、AddProfileService&lt;/p&gt;
&lt;h3&gt;2、 修改业务系统&lt;/h3&gt;
&lt;p&gt;以 MsgService 为例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Nuget -&amp;gt; Install-Package IdentityServer4.AccessTokenValidation
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后 Startup.cs 的 ConfigureServices 中增加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
services.AddAuthentication(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
   .AddIdentityServerAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
   {
       options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:9500&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;identity server 地址             &lt;/span&gt;
       options.RequireHttpsMetadata = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
   });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Startup.cs 的 Configure 中增加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
app.UseAuthentication();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、 请求 token 把报文头中的 grant_type 值改为 password，报文头增加 username、password 为用户名、密码。&lt;br clear=&quot;all&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953915/201806/953915-20180628122752232-586925698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;像之前一样用返回的 access_token传递给请求的Authorization 中，在业务系统的 User中就可以获取到 ResourceOwnerPasswordValidator 中为用户设置的 claims 等信息了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send_MI(&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt; model)
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; name = &lt;span&gt;this&lt;/span&gt;.User.Identity.Name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取的就是&quot;Name&quot;这个特殊的 Claims 的值&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; userId = &lt;span&gt;this&lt;/span&gt;.User.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value; &lt;br/&gt;&lt;span&gt;　　 string&lt;/span&gt; realName = &lt;span&gt;this&lt;/span&gt;.User.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RealName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value; &lt;br/&gt;&lt;span&gt;　　 string&lt;/span&gt; email = &lt;span&gt;this&lt;/span&gt;.User.FindFirst(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Value;
    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name={name},userId={userId},realName={realName},email={email}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;通过小米短信接口向{model.phoneNum}发送短信{model.msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、 独立登录服务器解决上面提到的“不能让客户端接触到 client_id、secret 的问题”&lt;/h3&gt;
&lt;p&gt; 开发一个服务应用 LoginService&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestTokenParam
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; username { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; LoginService.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginController : ControllerBase
    {
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; RequestToken(RequestTokenParam model)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; dict = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clientPC1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client_secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grant_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; model.username;
            dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; model.password;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由登录服务器向IdentityServer发请求获取Token&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (HttpClient http = &lt;span&gt;new&lt;/span&gt; HttpClient()) &lt;br/&gt;　          　　&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormUrlEncodedContent(dict))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:9500/connect/token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, content); &lt;br/&gt;&lt;span&gt;　　　　　　　　　 string&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; msg.Content.ReadAsStringAsync(); &lt;br/&gt;&lt;span&gt;　　　　　　　　   return&lt;/span&gt; Content(result, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样客户端只要向 LoginService 的 /api/Login/ 发请求带上 json 报文体&lt;/p&gt;
&lt;p&gt;{username:&quot;yzk&quot;,password:&quot;123&quot;}即可。客户端就不知道 client_secret 这些机密信息了。&lt;/p&gt;
&lt;p&gt; 把 LoginService 配置到 Ocelot 中。&lt;/p&gt;
&lt;p&gt;参考文章：https://www.cnblogs.com/jaycewu/p/7791102.html &lt;/p&gt;

&lt;p&gt;注：此文章是我看杨中科老师的&lt;a&gt;.Net Core微服务第二版和&lt;/a&gt;&lt;a&gt;.Net Core微服务第二版课件整理出来的&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 05:03:00 +0000</pubDate>
<dc:creator>情话布墨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qhbm/p/9238179.html</dc:identifier>
</item>
<item>
<title>python3csv与xlsx文件操作模块（csv、xlsxwriter） - Py.qi</title>
<link>http://www.cnblogs.com/zhangxinqi/p/9231801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinqi/p/9231801.html</guid>
<description>&lt;h2&gt;一、csv模块实现csv文件操作&lt;/h2&gt;
&lt;h3&gt;1、CSV介绍&lt;/h3&gt;
&lt;p&gt;CSV，全称为Comma-Separated Values,它以逗号分隔值，其文件以纯文本形式存储表格数据，该文件是一个字符序列，可以由任意数目的记录组成，每条记录有字段组成，字段间分隔符是逗号或制表符，相当于结构化的纯文本形式，它比Excel文件更简洁，用来存储数据比较方便&lt;/p&gt;
&lt;h3&gt;2、CSV常用类与方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;csv.reader(csvfile,dialect='excel',**fmtparams)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遍历CSV文件对象并返回，csvfiel可以是任何支持迭代器协议的对象，如果csvfile是一个文件对象，它需要指定newline=''&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;csv.writer(csvfile,dialect='excel',**fmtparams)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写入数据到csv文件中，csvfile可以是具有写入方法的任何对象，如果csvfiel是一个文件对象，应该用newline=''指定换行符(unix上位'\n'，windows上位'\r\n')&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/27 11:44&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : csv_file1.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv
iterable&lt;/span&gt;=[[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20,8998,20180627],[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20,8998,20180627],[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20,8998,20180627&lt;span&gt;]]

with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;csvfile.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,newline=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;) as csvf:
    spanwriter&lt;/span&gt;=csv.writer(csvf,dialect=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;excel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建writer对象&lt;/span&gt;
    spanwriter.writerow([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用writer的方法writerow写入到文件&lt;/span&gt;
    spanwriter.writerows(iterable)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;迭代写入数据&lt;/span&gt;
&lt;span&gt;
with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;csvfile.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,newline=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;) as csvf:
    spamreader&lt;/span&gt;=csv.reader(csvf)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建reader对象&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; spamreader:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.join(i))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定分隔符，读取csv文件数据&lt;/span&gt;


&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;id    name    age    salary    date
&lt;/span&gt;1    zs    20    8998    20180627
1    zs    20    8998    20180627
1    zs    20    8998    20180627
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;class &lt;code class=&quot;descclassname&quot;&gt;csv.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;DictReader&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;以字典的形式读取csv文件的行，fileldnames参数指定键，restkey指定默认key，restval指定默认value，dialect指定方言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;sig-paren&quot;&gt;class &lt;code class=&quot;descclassname&quot;&gt;csv.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;DictWriter&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;span class=&quot;sig-paren&quot;&gt;创建一个字典形式的csv操作对象，f为写入的文件，fieldnames为制定key，restval制定默认value，extrasaction表示，如果在使用writerow()方法写入数据的字典中字段名找不到的键，则此参数将执行操作，如果设置为saise则会引发valueError，如果设置为ignore则字典中的额外值将被忽略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;strong&gt;reader对象，DictReader实例和reader()对象具有的方法和属性&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvreader.__next__()：迭代读取对象的下一行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvreader.dialect：解析器使用的方言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvreader.line_num：从源迭代器读取的行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvreader.fieldnames：如果在创建对象时为作为参数传递，则在首次访问文件或读取第一条记录是初始化此属性，此属性只适用于DictReader对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;sig-paren&quot;&gt;writer对象，DictWriter和writer()实例对象具有的方法和属性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvwriter.writerow()：将行参数写入到文件对象，根据当前的方言格式化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvwriter.writerows(row)：将row中的所有元素，行对象的迭代写入到文件对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;csvwriter.dialect：解析器使用的方言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sig-paren&quot;&gt;DictWriter.writeheader()：写入一行字段名,只适用于DictWriter对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/27 12:13&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : csv_file2.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas

iter&lt;/span&gt;=&lt;span&gt;[
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wanwu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:23,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:20180627&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhaoliu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:24,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:20180627&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:4,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tianqi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:25,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:20180627&lt;span&gt;}
]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入文件&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;names.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,newline=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;) as csvf:
    fieldnames&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    writer&lt;/span&gt;=csv.DictWriter(csvf,fieldnames=&lt;span&gt;fieldnames)
    writer.writeheader()
    writer.writerow({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lisii&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:22,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:20180627&lt;span&gt;})
    writer.writerows(iter)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取文件&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;names.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as csvf:
    reader&lt;/span&gt;=csv.DictReader(csvf,fieldnames=&lt;span&gt;fieldnames)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reader:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],i[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],i[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],i[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;也可以使用pandas模块来读取csv文件&lt;/span&gt;
df=pandas.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;names.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;id name age date
&lt;/span&gt;1 lisii 22 20180627
2 wanwu 23 20180627
3 zhaoliu 24 20180627
4 tianqi 25 20180627&lt;span&gt;

   id     name  age      date
0   &lt;/span&gt;1    lisii   22  20180627
1   2    wanwu   23  20180627
2   3  zhaoliu   24  20180627
3   4   tianqi   25  20180627
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、xlsxwriter模块，实现Excel文件操作&lt;/h2&gt;
&lt;p&gt;Excel 是当今最流行的电子表格处理软件，支持丰富的计算函数及图表，在系统运营方&lt;/p&gt;
&lt;p&gt;面广泛用于运营数据报表，比如业务质量、资源利用、安全扫描等报表，时也是应用系统&lt;br/&gt;常见的文件导出格式, 以便数据使用人员做进一步加工处理。&lt;br/&gt;利用 Python 操作Excel 的模块 XlsxWriter（https: // xlsxwriter.readthedocs.org），可以操作多个工作表的文字、数字、公式、图表等。XlsxWriter 模块具有以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;100 % 兼容的 Excel XLSX 文件，支持 Excel 2003、Excel 2007 等版本；&lt;/li&gt;
&lt;li&gt;支持所有 Excel 单元格数据格式；&lt;/li&gt;
&lt;li&gt;单元格合并、批注、自动筛选、丰富多格式字符串等；&lt;/li&gt;
&lt;li&gt;支持工作表 PNG、JPEG 图像，自定义图表；&lt;/li&gt;
&lt;li&gt;内存优化模式支持写入大文件。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1、Xlsx Writer模块的安装&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; pip install XlsxWriter #pip 安装方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; easy_install XlsxWriter #easy_install 安装方法&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码安装方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; curl -O -L http://github.com/jmcnamara/XlsxWriter/archive/master.tar.gz&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; tar zxvf master.tar.gz&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; cd XlsxWriter-master/&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sudo python setup.py install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单示例，创建一个Excel文件，插入文字、数字，计算公式和图片，设置单元格格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/27 14:00&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : xlsxWriter_f1.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter

workbook&lt;/span&gt;=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;demo.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个Excel文件&lt;/span&gt;
worksheet=workbook.add_worksheet() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个工作表对象&lt;/span&gt;
worksheet.set_column(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A:A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置第一列A宽度为20像素&lt;/span&gt;
bold=workbook.add_format({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:True}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个加粗的格式对象&lt;/span&gt;
worksheet.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HELLO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;A1单元格写入HELLO&lt;/span&gt;
worksheet.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,bold) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;A2写入world并引用加粗格式对象bold&lt;/span&gt;
worksheet.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中文测试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,bold)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;B2写入中文引用加粗格式bold&lt;/span&gt;
worksheet.write(2,0,32) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用行列表示法写入数字32与35.5&lt;/span&gt;
worksheet.write(3,0,35.5) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;行列表示法的单元格下标以0作为起始值，‘3,0’等价与A3&lt;/span&gt;
worksheet.write(4,0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=SUM(A3:A4)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求和A3:A4&lt;/span&gt;
worksheet.insert_image(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;14.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在B5插入图片&lt;/span&gt;
workbook.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、Xlsx Writer模块常用方法&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;（1）Workbook 类&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Workbook 类定义：Workbook(filename[, options])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该类实现创建一个 XlsxWriter 的 Workbook对象。Workbook 类代表整个电子表格文件，并且存储在磁盘上。参数 filename（String 类型）为创建的 Excel 文件存储路径；参数 options（Dict 类型）为可选的 Workbook 参数，一般作为初始化工作表内容格式，例如值为 {'strings_to_numbers': True} 表示使用 worksheet.write() 方法时激活字符串转换数字。&lt;/p&gt;
&lt;p&gt;add_worksheet([sheetname])方法，作用是添加一个新的工作表，参数 sheetname（String 类型）为可选的工作表名称，默认为 Sheet1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加一个新工作表名称为data&lt;/span&gt;
worksheet=workbook.add_worksheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;add_format([properties]) 方法，作用是在工作表中创建一个新的格式对象来格式化单元格。参数 properties（dict 类型）为指定一个格式属性的字典，例如设置一个加粗的格式对象，workbook.add_format({'bold': True})&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter

workfile&lt;/span&gt;=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建Excel文件&lt;/span&gt;
worksheet=workfile.add_worksheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sh1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建工作表&lt;/span&gt;
format=workfile.add_format({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bg_color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font_size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font_color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yellow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义格式对象，背景为红色，字体大小18，字体颜色黄色&lt;/span&gt;
worksheet.set_column(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A:A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置A列宽度为20像素&lt;/span&gt;
worksheet.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,format)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入文件并应用格式&lt;/span&gt;
workfile.close()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多格式化方法见&lt;a href=&quot;http://xlsxwriter.readthedocs.io/format.html#format&quot; target=&quot;_blank&quot;&gt;http://xlsxwriter.readthedocs.io/format.html#format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;add_chart（options）方法，作用是在工作表中创建一个图表对象，内部是通过 insert_chart() 方法来实现，参数 options（dict 类型）为图表指定一个字典属性，例如设置一个线条类型的图表对象，代码为 chart = workbook.add_chart({'type': 'line'})&lt;/p&gt;
&lt;p&gt;close() 方法，作用是关闭工作表文件，如 workbook.close()&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;（2）Worksheet 类&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Worksheet 类代表了一个 Excel 工作表，是 XlsxWriter 模块操作 Excel 内容最核心的一个类，例如将数据写入单元格或工作表格式布局等。Worksheet 对象不能直接实例化，取而代之的是通过 Workbook 对象调用 add_worksheet() 方法来创建。Worksheet 类提供了非常丰富的操作 Excel 内容的方法，其中几个常用的方法如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;write(row, col, *args) 方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;作用是写普通数据到工作表的单元格，参数 row 为行坐标，col 为列坐标，坐标索引起始值为 0；* args 无名字参数为数据内容，可以为数字、公式、字符串或格式对象。为了简化不同数据类型的写入过程，write 方法已经作为其他更加具体数据类型方法的别名，包括：&lt;/p&gt;
&lt;p&gt;write_string() 写入字符串类型数据，如：worksheet.write_string(0, 0, 'Your text here')&lt;/p&gt;
&lt;p&gt;write_number() 写入数字类型数据，如：worksheet.write_number('A2', 2.3451)&lt;/p&gt;
&lt;p&gt;write_blank() 写入空类型数据，如：worksheet.write('A2', None)&lt;/p&gt;
&lt;p&gt;write_formula() 写入公式类型数据，如：worksheet.write_formula(2, 0, '=SUM(B1:B5)')&lt;/p&gt;
&lt;p&gt;write_datetime() 写入日期类型数据，如：worksheet.write_datetime(7, 0, datetime.datetime.strptime('2013-01-23','%Y-%m-%d'),workbook.add_format({'num_format': 'yyyy-mm-dd'}))&lt;/p&gt;
&lt;p&gt;write_boolean() 写入逻辑类型数据，如：worksheet.write_boolean(0, 0, True)；&lt;/p&gt;
&lt;p&gt;write_url() 写入超链接类型数据，如：worksheet.write_url('A1', 'ftp://www.python.org/')&lt;/p&gt;
&lt;p&gt;下面通过具体的示例来观察别名write方法与数据类型方法的对应关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter
workbook&lt;/span&gt;=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test1.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
worksheet&lt;/span&gt;=workbook.add_worksheet(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中文&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
worksheet.write(0,0,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入字符串&lt;/span&gt;
worksheet.write(1,0,2&lt;span&gt;)
worksheet.write(&lt;/span&gt;2,0,3.001)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入数字&lt;/span&gt;
worksheet.write(3,0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=SIN(PI()/4)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入公式&lt;/span&gt;
worksheet.write(4,0,&lt;span&gt;''&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入空&lt;/span&gt;
worksheet.write(5,0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入url&lt;/span&gt;
workbook.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;set_row（row, height, cell_format, options）方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;作用是设置行单元格的属性。参数row（int 类型）指定行位置，起始下标为 0 ；参数 height（float 类型）设置行高，单位像素；参数 cell_format（format 类型）指定格式对象；参数 options（dict 类型）设置行 hidden（隐藏）、level（组合分级）、collapsed（折叠）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
worksheet.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在A1写入字符串&lt;/span&gt;
cell_format=workbook.add_format({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:True}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义加粗的格式对象&lt;/span&gt;
worksheet.set_row(0,40,cell_format)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置第1行单元格高度为40像素，且引用加粗格式对象&lt;/span&gt;
worksheet.set_row(1,None,None,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hidden&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:True})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏第2行单元格&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;set_column（first_col, last_col, width, cell_format, options）方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;作用为设置一列或多列单元格属性。参数 first_col（int 类型）指定开始列位置，起始下标为 0 ；参数 last_col（int 类型）指定结束列位置，起始下标为 0，可以设置成与 first_col 一样；参数width（float 类型）设置列宽；参数 cell_format（Format 类型）指定格式对象；参数options（dict 类型）设置行 hidden（隐藏）、level（组合分级）、collapsed（折叠）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter
workbook&lt;/span&gt;=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test2.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
worksheet&lt;/span&gt;=workbook.add_worksheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
worksheet.write(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
cell_format&lt;/span&gt;=workbook.add_format({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:True})
worksheet.set_column(0,&lt;/span&gt;1,10,cell_format)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置0到1即A到B列单元格宽度为10像素，且引用加粗格式对象&lt;/span&gt;
worksheet.set_column(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,20)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置C到D列单元格宽度为20像素&lt;/span&gt;
worksheet.set_column(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:G&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,None,None,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hidden&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐藏E到G列单元格&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;insert_image(row, col, image[, options]) 方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用是插入图片到指定单元格，支持PNG、JPEG、BMP 等图片格式。参数 row 为行坐标，col 为列坐标，坐标索引起始值为 0 ；参数 image（string 类型）为图片路径；参数 options（dict 类型）为可选参数，作用是指定图片的位置、比例、链接 URL 等信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter
workbook&lt;/span&gt;=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test3.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
worksheet&lt;/span&gt;=workbook.add_worksheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在B5单元格插入22.jpg图片，图片超链接为http://python.org&lt;/span&gt;
worksheet.insert_image(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:/22.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://python.org&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
workbook.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;（3）Chart 类&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Chart 类实现在 XlsxWriter 模块中图表组件的基类，支持的图表类型包括面积、条形图、柱形图、折线图、饼图、散点图、股票和雷达等，一个图表对象是通过 Workbook（工作簿）的 add_chart 方法创建，通过 {type, ' 图表类型 '} 字典参数指定图表的类型，语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chart =workbook.add_chart({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个column柱形图表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多图表类型说明：&lt;/p&gt;
&lt;p&gt;area：创建一个面积样式的图表&lt;/p&gt;
&lt;p&gt;bar：创建一个条形样式的图表&lt;/p&gt;
&lt;p&gt;column：创建一个柱形样式的图表&lt;/p&gt;
&lt;p&gt;line：创建一个线条样式的图表&lt;/p&gt;
&lt;p&gt;pie：创建一个饼图样式的图表&lt;/p&gt;
&lt;p&gt;scatter：创建一个散点样式的图表&lt;/p&gt;
&lt;p&gt;stock：创建一个股票样式的图表&lt;/p&gt;
&lt;p&gt;radar：创建一个雷达样式的图表&lt;/p&gt;
&lt;p&gt;然后再通过 Worksheet（工作表）的 insert_chart() 方法插入到指定位置，语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
worksheet.insert_chart(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, chart)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在 A7 单元格插入图表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面介绍 chart 类的几个常用方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;chart.add_series(options) 方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用为添加一个数据系列到图表，参数 options(dict类型) 设置图表系列选项的字典，操作示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chart.add_series({
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categories&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$A$1:$A$5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$B$1:$B$5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;add_series 方法，最常用的三个选项为 categories、values、line，其中 categories 作用是设置图表类别标签范围；values 为设置图表数据范围；line 为设置图表线条属性，包括颜色、宽度等。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;其他常用方法及示例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set_x_axis(options) 方法：&lt;/strong&gt;设置图表 X 轴选项，示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chart.set_x_axis({
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Earnings per Quarter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置 X 轴标题名称&lt;/span&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name_font&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 14, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: True},    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置 X 轴标题字体属性&lt;/span&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_font&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;italic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: True },         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置 X 轴数字字体属性&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;set_size(options) 方法：&lt;/strong&gt;设置图表大小，如：chart.set_size({'width':720,'height':576})，其中width为宽度，height为高度&lt;br/&gt;&lt;strong&gt;set_title(options) 方法：&lt;/strong&gt;设置图表标题，如：chart.set_title({'name':'Year End Results'})&lt;br/&gt;&lt;strong&gt;set_style(style_id) 方法：&lt;/strong&gt;设置图表样式，style_id 为不同数字则代表不同样式，如chart.set_style(37)&lt;br/&gt;&lt;strong&gt;set_table(options) 方法：&lt;/strong&gt;设置 X 轴为数据表格形式，如 chart.set_table()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;96&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/28 9:31&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : chart_writer.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建数据表&lt;/span&gt;
workbook=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
worksheet&lt;/span&gt;=&lt;span&gt;workbook.add_worksheet()
title&lt;/span&gt;=[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;部门名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;一月份&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;二月份&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;三月份&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;四月份&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;五月份&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平均值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
department&lt;/span&gt;=[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;技术部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;市场部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;财务部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工程部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;安全部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
data&lt;/span&gt;=&lt;span&gt;[
    [&lt;/span&gt;123,135,145,159,168&lt;span&gt;],
    [&lt;/span&gt;88,99,105,112,146&lt;span&gt;],
    [&lt;/span&gt;78,75,71,68,89&lt;span&gt;],
    [&lt;/span&gt;110,123,159,189,201&lt;span&gt;],
    [&lt;/span&gt;98,156,198,175,58&lt;span&gt;],
]
format&lt;/span&gt;=workbook.add_format({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:True,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bg_color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#cccccc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
format_val&lt;/span&gt;=workbook.add_format({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;align&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
worksheet.set_row(0,&lt;/span&gt;20&lt;span&gt;)
worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A:F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,10&lt;span&gt;)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,title,format)
worksheet.write_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,department,format)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,data[0],format_val)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[1&lt;span&gt;],format_val)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[2&lt;span&gt;],format_val)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[3&lt;span&gt;],format_val)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[4&lt;span&gt;],format_val)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建图表&lt;/span&gt;
chart=workbook.add_chart({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;图表数据插入函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; chart_series(cur_row):
    worksheet.write_formula(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=AVERAGE(B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,format_val)
    chart.add_series({
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categories&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$B$1:$F$1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:$F$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;cur_row,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$A$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;cur_row
    })
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环插入数据&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2,7&lt;span&gt;):
    chart_series(str(i))
chart.set_size({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:677,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:380}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置图表宽和高&lt;/span&gt;
chart.set_title({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;业绩表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置图表标题&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;chart.set_table()  #设置图表table样式&lt;/span&gt;
worksheet.insert_chart(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,chart) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;图表插入到工作表中&lt;/span&gt;
workbook.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、定制自动化业务流量报表周报&lt;/h3&gt;
&lt;p&gt;通过XlsxWriter模块将流量数据写入Excel文档，同时自动计算各频道周平均流量，在生成数据图表，具体是通过workbook.add_chart({'tyep':'column'})方法指定图表类型为柱形，使用write_row,write_column方法分别以行，列方式写入数据，使用add_format()方法定制表头，表体的显示风格，使用add_series()方法将数据添加到图表，同时使用chart.set_size，set_title，set_y_axis设置图表的大小及标题属性，最后通过insert_chart方法将图表插入工作表中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlsxwriter

workbook&lt;/span&gt;=xlsxwriter.Workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test4.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个Excel文件&lt;/span&gt;
worksheet=workbook.add_worksheet()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个工作表对象&lt;/span&gt;
chart=workbook.add_chart({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建柱形图表&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;定义数据表头列表&lt;/span&gt;
title=[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;业务名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期一&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期二&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期五&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期六&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;星期日&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平局流量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
buname&lt;/span&gt;=[u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;业务官网&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;新闻中心&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;购物频道&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;体育频道&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;亲子频道&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义频道名称&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;定义5个频道一周7天的数据列表&lt;/span&gt;
data=&lt;span&gt;[
    [&lt;/span&gt;150,152,158,149,155,145,148&lt;span&gt;],
    [&lt;/span&gt;88,89,95,93,98,100,99&lt;span&gt;],
    [&lt;/span&gt;210,200,158,178,170,198,195&lt;span&gt;],
    [&lt;/span&gt;75,77,78,78,74,70,79&lt;span&gt;],
    [&lt;/span&gt;88,77,87,90,93,88,84&lt;span&gt;],
]

format&lt;/span&gt;=workbook.add_format()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义format格式对象&lt;/span&gt;
format.set_border(1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义format对象单元格边框加粗1像素的格式&lt;/span&gt;
&lt;span&gt;
format_title&lt;/span&gt;=workbook.add_format() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义title格式对象&lt;/span&gt;
format_title.set_border(1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义title格式&lt;/span&gt;
format_title.set_bg_color(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#cccccc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义title对象背景颜色&lt;/span&gt;
format_title.set_align(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义title剧中对齐&lt;/span&gt;
&lt;span&gt;format_title.set_bold()

format_ave&lt;/span&gt;=workbook.add_format() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义format_ave格式对象&lt;/span&gt;
format_ave.set_border(1&lt;span&gt;)
format_ave.set_num_format(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义数字类别显示格式&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;下面分别以行或列写入方式将标题，业务名称，流量数据写入起初单元格，同时引用不同格式对象&lt;/span&gt;
worksheet.write_row(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,title,format_title)
worksheet.write_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,buname,format)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,data[0],format)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[1&lt;span&gt;],format)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[2&lt;span&gt;],format)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[3&lt;span&gt;],format)
worksheet.write_row(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data[4&lt;span&gt;],format)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义图表数据系列函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; chart_series(cur_row):
    worksheet.write_formula(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=AVERAGE(B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:H&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,format_ave)
    chart.add_series(
        {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;categories&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$B$1:$H$1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$B$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+cur_row+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:$H$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;cur_row,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'line':{'color':'black'},&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=Sheet1!$A$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;cur_row,
        }
    )

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; range(2,7&lt;span&gt;):
    chart_series(str(row))


chart.set_table()    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置X轴表格格式&lt;/span&gt;
chart.set_style(30)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置图表样式&lt;/span&gt;
chart.set_size({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:677,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:380&lt;span&gt;})
chart.set_title({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;业务流量周报图表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
chart.set_y_axis({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mb/s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})

worksheet.insert_chart(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,chart)
workbook.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1134117/201806/1134117-20180628001416957-1151778636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; XlsxWriter官网：&lt;a href=&quot;https://xlsxwriter.readthedocs.io/index.html&quot; target=&quot;_blank&quot;&gt;https://xlsxwriter.readthedocs.io/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 04:35:00 +0000</pubDate>
<dc:creator>Py.qi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxinqi/p/9231801.html</dc:identifier>
</item>
<item>
<title>ZooKeeper系列(6)：ZooKeeper的伸缩性和Observer角色 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9238123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9238123.html</guid>
<description>&lt;p&gt;&lt;strong&gt;ZooKeeper系列文章：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7576137.html#zk&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/f-ck-need-u/p/7576137.html#zk&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;在比较老的ZooKeeper版本中，只有两种角色：leader和follower。后来引入了一种新角色Observer，Observer角色除了不能投票(以及和投票相关的能力)外，其它和follower功能一样。&lt;/p&gt;
&lt;p&gt;所以，在ZooKeeper中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;投票角色：leader、follower。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;无票角色：observer。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ZooKeeper集群中的每个server都能为客户端提供读、写服务。&lt;/p&gt;
&lt;p&gt;对于客户端的读请求，server会直接从它本地的内存数据库中取出数据返回给客户端，这个过程不涉及其它任何操作，也不会联系leader。&lt;/p&gt;
&lt;p&gt;对于客户端的写请求，因为写操作会修改znode的数据、状态，所以必须要在ZooKeeper集群中进行协调。处理过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收到写请求的那个server，首先将写请求&lt;strong&gt;发送给leader&lt;/strong&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;leader收到来自follower(或observer)的写请求后，首先计算这次写操作之后的状态，然后将这个写请求&lt;strong&gt;转换成带有各种状态的事务&lt;/strong&gt;(如版本号、zxid等等)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;leader将这个事务以提议的方式&lt;strong&gt;广播&lt;/strong&gt;出去(即发送proposal)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;所有follower收到proposal后，对这个提议进行投票，投票完成后返回ack给leader。follower的投票只有两种方式：(1)确认这次提议表示同意；(2)丢弃这次提议表示不同意。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;leader收集投票结果，只要投票数量达到了&lt;strong&gt;大多数的要求&lt;/strong&gt;(例如，5个节点的集群，3个或3个以上的节点才算大多数)，这次提议就通过。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;提议通过后，leader向所有server发送一个提交通知。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;所有节点将这次事务写入事务日志，并进行提交。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;提交后，收到写请求的那个server向客户端返回成功信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是ZooKeeper集群处理写请求过程的一个简图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201806/733013-20180628114708778-37091606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当ZooKeeper集群中follower的数量很多时，投票过程会成为一个性能瓶颈，为了解决投票造成的压力，于是出现了observer角色。&lt;/p&gt;
&lt;p&gt;observer角色不参与投票，它只是投票结果的&quot;听众&quot;，除此之外，它和follower完全一样，例如能接受读、写请求。就这一个特点，让整个ZooKeeper集群性能大大改善。&lt;/p&gt;
&lt;p&gt;和follower一样，当observer收到客户端的读请求时，会直接从内存数据库中取出数据返回给客户端。&lt;/p&gt;
&lt;p&gt;对于写请求，当写请求发送到某server上后，无论这个节点是follower还是observer，都会将它发送给leader。然后leader组织投票过程，所有server都收到这个proposal(包括observer，因为proposal是广播出去的)，但是leader和follower以及observer通过配置文件，都知道自己是不是observer以及谁是observer。自己是observer的server不参与投票。当leader收集完投票后，将那些observer的server去掉，在剩下的server中计算大多数，如果投票结果达到了大多数，这次写事务就成功，于是leader通知所有的节点(包括observer)，让它们将事务写入事务日志，并提交。&lt;/p&gt;


&lt;p&gt;observer角色除了减轻了投票的压力，还带来了几个额外的优点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.提高了伸缩性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;伸缩性指的是通过添加服务器来负载请求，从而提高整个集群处理请求的能力。也就是&quot;一头牛拉不动了，找更多牛来拉&quot;。&lt;/p&gt;
&lt;p&gt;在出现Observer之前，ZooKeeper集群的伸缩性由follower来实现。虽然对于读写操作来说，follower是&quot;无状态&quot;的，这使得添加新的follower到集群(或者从集群中减少follower)很方便，能提高ZooKeeper集群负载能力。但是，对于投票来说，follower是有状态的，增、减follower的数量，都直接影响投票结果，特别是follower的数量越多，投票过程的性能就越差。&lt;/p&gt;
&lt;p&gt;而observer无论是读写请求还是投票，都是无状态的，增、减observer的数量不会影响投票结果。这样就可以让一部分server作为follower参与投票，另一部分作为observer单纯地提供读写服务。这使得ZooKeeper的伸缩性大大提高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.部署跨地区的ZooKeeper数据中心更方便。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;observer能直接从本地内存数据库中取出数据来响应读请求，所以提高了读的吞吐量。对于写请求，虽然它要发送给leader并接受leader的通知，但相比于投票过程中传递的信息，它的数据量很小，所以即使在广域网也能有很好的性能。&lt;/p&gt;
&lt;p&gt;实际上，很多跨机房、跨地区的数据中心就是通过observer来实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201806/733013-20180628112327420-1117288279.png&quot;/&gt;&lt;/p&gt;


&lt;p&gt;要配置observer，只需稍微修改一下配置文件即可。&lt;/p&gt;
&lt;p&gt;首先，在想要成为observer的配置文件中，加上下面一行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;ot&quot;&gt;peerType=&lt;/span&gt;observer&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示这个server以observer角色运行，即不参与投票。&lt;/p&gt;
&lt;p&gt;再在所有 server的配置文件中，修改&lt;code&gt;server.X&lt;/code&gt;配置项，在那些observer的节点上加上&lt;code&gt;:observer&lt;/code&gt;后缀。&lt;/p&gt;
&lt;p&gt;例如，server.1对应的server要作为observer：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;server.1&lt;/span&gt;=IP:2181:3181:observer&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样配置后，ZooKeeper集群中的所有服务器节点都知道哪些节点扮演的是observer角色。&lt;/p&gt;
</description>
<pubDate>Thu, 28 Jun 2018 04:34:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9238123.html</dc:identifier>
</item>
<item>
<title>libui-node体验笔记 - cczw</title>
<link>http://www.cnblogs.com/cczw/p/9238089.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cczw/p/9238089.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/parro-it/libui-node&quot;&gt;libui-node&lt;/a&gt;是基于&lt;a href=&quot;https://github.com/andlabs/libui&quot;&gt;libui&lt;/a&gt;库的node封装.&lt;strong&gt;libui&lt;/strong&gt;库是一个简便的将本地原生的GUI封装的C语言库，并支持各平台（Mac,Linux,windows）。官网提供了第三方封装文档，开发者可以方便的实现自己语言的封装。目前市面上有基于swift,kotlin,python,php,node，lua.... 各种第三方语言的封装库，这里只介绍node封装库的使用方法。&lt;/p&gt;
&lt;h4 id=&quot;对比electron&quot;&gt;对比electron&lt;/h4&gt;
&lt;p&gt;与&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;electron&lt;/a&gt;比较起来，github上的数据比较起来得可怜的很。 社区也基本没啥活跃。 个人也比较喜欢electron完全web化的任性开发。&lt;br/&gt;就目前看起来libui-node的主打卖点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持各种开发语言&lt;/li&gt;
&lt;li&gt;原生Ui渲染&lt;/li&gt;
&lt;li&gt;打包较小（helloworld代码40M，比electron的100M小不少）&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;libui-node&lt;/td&gt;
&lt;td&gt;1391&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;Jun 19, 2018&lt;/td&gt;
&lt;td&gt;May 21, 2016&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;electron&lt;/td&gt;
&lt;td&gt;61773&lt;/td&gt;
&lt;td&gt;8086&lt;/td&gt;
&lt;td&gt;1195&lt;/td&gt;
&lt;td&gt;Jun 27, 2018&lt;/td&gt;
&lt;td&gt;Apr 12, 2013&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;环境要求&quot;&gt;环境要求&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If they are not provided by default in your distribution:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;macOS&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;node安装&quot;&gt;node安装&lt;/h3&gt;
&lt;p&gt;命令行下运行node命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install -save libui-node&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.3410404624277&quot;&gt;
&lt;p&gt;对应平台的libui二进制库会被自动下载安装，如果报错可能是因为本地的npm库比较老，可以更新npm.其他错误可以看看&lt;a href=&quot;https://github.com/nodejs/node-gyp/issues/972&quot;&gt;this node-gyp issue&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;运行示例&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;下载线上的git库，其中docs为文档目录，examples为示例目录，运行示例看是否可正常运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#在根目录下先执行安装
npm install
#直接运行control gallery示例
npm start
#运行core api示例
npm run start-core
#运行指定的示例文件
node &amp;lt;path to example file&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;详细的文档查看git源码目录下的docs目录，下面做一个简单的例子&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建立一个工程目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;mkdir test
cd test
npm install --save libui-node&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;新建一个index.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;const libui = require('libui-node');

const menu = new libui.UiMenu('File');
menu.appendQuitItem();

const win = libui.UiWindow('test', 400, 300, true);

var widget = new libui.UiLabel();
widget.text = '呵呵呵呵';
win.setChild(widget);

win.onClosing(()=&amp;gt;{
    win.close();
    libui.stopLoop();
});

libui.onShouldQuit(() =&amp;gt; {
    win.close();
    libui.stopLoop();
});

win.show();
libui.startLoop();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;测试运行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;node index.js&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这些示例都源码的方式在node环境下执行，如果想打包的话那么就需要用到 &lt;a href=&quot;https://github.com/mimecorg/launchui-packager&quot;&gt;launchui-packager&lt;/a&gt; 一个基于&lt;a href=&quot;https://github.com/mimecorg/launchui&quot;&gt;LaunchUI&lt;/a&gt;的跨平台打包器。&lt;/p&gt;
&lt;h3 id=&quot;安装-1&quot;&gt;安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;npm install --g launchui-packager&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;打包命令&quot;&gt;打包命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;第一次执行的时候会下载对应平台的依赖包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;launchui-packager &amp;lt;name&amp;gt; &amp;lt;version&amp;gt; &amp;lt;entry&amp;gt; [options...]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;比如上面做的开发中的示例可以如此打包：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;#在工程目录下执行
launchui-packager hello 1.0.0 index.js --out output &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参数介绍&quot;&gt;参数介绍&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;name&amp;gt; 应用名称
&amp;lt;version&amp;gt; 应用版本号
&amp;lt;entry&amp;gt; 应用的启动脚本，将被拷贝到最终包的 app/main.js&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置介绍-options&quot;&gt;配置介绍 options&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;--out &amp;lt;path&amp;gt; 生成包的输出目录，默认当前目录
--platform &amp;lt;platform&amp;gt; 目标平台，支持win32, darwin (OS X) and linux. 默认当前平台一致（process.platform）
--arch &amp;lt;arch&amp;gt; 包的架构，支持x64 (全平台支持) and ia32 (win32/linux),默认当前平台一致（process.arch）
--overwrite 是否覆盖之前生成的包或目录，默认不覆盖
--pack &amp;lt;format&amp;gt; 定义打包的格式，目前只支持zip格式，默认生成应用目录不打包
--launchui-version &amp;lt;version&amp;gt; 定义下载的launchui版本，默认使用当前系统已有的
--launchui-cache &amp;lt;path&amp;gt; 定义launchui下载路径，默认~/.launchui
--company &amp;lt;company&amp;gt; 公司名称，对应Windows下的CompanyName 属性设置
--copyright &amp;lt;copyright&amp;gt; 应用的版权信息，对应 windows下的LegalCopyright属性 和 Mac OS X下的 NSHumanReadableCopyright
--identifier &amp;lt;identifier&amp;gt; 应用的bundle identifie，对应Mac OS X下的CFBundleIdentifier
--category &amp;lt;category&amp;gt; 应用的category，对应Mac OS X 下的LSApplicationCategoryType
--icon &amp;lt;path&amp;gt; 应用的图标路径，windows下使用.ico，Mac OS X下使用.icns后缀
--license &amp;lt;path&amp;gt; 应用的license文件，将被拷贝到应用的根目录下
--dir &amp;lt;path&amp;gt; 应用额外需要打包的文件目录，将作为子目录被打包到应用的app目录下
--files &amp;lt;pattern,...&amp;gt;  定义dir定义的文件目录中拷贝文件的匹配规则，可以参考glob文档，多个规则可以使用数组。默认**，代表拷贝dir目录下的所有文件&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出&quot;&gt;输出&lt;/h4&gt;
&lt;p&gt;将生成一个名称为 &lt;strong&gt;&amp;lt;name&amp;gt;-v&amp;lt;version&amp;gt;-&amp;lt;platform&amp;gt;-&amp;lt;arch&amp;gt;&lt;/strong&gt; 目录，比如：&lt;strong&gt;MyApp-v1.0.0-win32-ia32&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;api方式&quot;&gt;api方式&lt;/h4&gt;
&lt;p&gt;除了使用上面命令行的方式也可以使用api的方式进行打包，比如再用自动化工具的时候，跟上面的参数大同小异：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const packager = require( 'launchui-packager' );
packager( {
  name: 'MyApp',
  version: '1.0.0',
  entry: './dist/main.js',
  out: './packages'
  .....
}, function ( err, outPath ) {
  // outPath will be the path of the created package directory or file
} );&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Jun 2018 04:17:00 +0000</pubDate>
<dc:creator>cczw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cczw/p/9238089.html</dc:identifier>
</item>
</channel>
</rss>