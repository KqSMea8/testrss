<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Golang学习--TOML配置处理 - 疯狂的原始人</title>
<link>http://www.cnblogs.com/CraryPrimitiveMan/p/7928647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CraryPrimitiveMan/p/7928647.html</guid>
<description>&lt;p&gt;上一篇文章中我们学会了使用包管理工具，这样我们就可以很方便的使用包管理工具来管理我们依赖的包。&lt;/p&gt;
&lt;h2 id=&quot;配置工具的选择&quot;&gt;配置工具的选择&lt;/h2&gt;
&lt;p&gt;但我们又遇到了一个问题，一个项目通常是有很多配置的，比如PHP的php.ini文件、Nginx的server.conf文件，那么Golang的项目又适合使用怎样的配置文件呢？&lt;/p&gt;
&lt;p&gt;其实现在我们有很多选择，比如 JSON文件、INI文件、YAML文件和TOML文件等等。&lt;/p&gt;
&lt;p&gt;其中这些文件，对应的Golang处理库如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://godoc.org/encoding/json&quot;&gt;encoding/json&lt;/a&gt; -- 标准库中的包，可以处理JSON配置文件，缺点是不能加注释&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/go-gcfg/gcfg&quot;&gt;gcfg&lt;/a&gt; -- 处理INI配置文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/BurntSushi/toml&quot;&gt;toml&lt;/a&gt; -- 处理TOML配置文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/spf13/viper&quot;&gt;viper&lt;/a&gt; -- 处理JSON, TOML, YAML, HCL以及Java properties配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实关于怎么选择可以看看stackoverflow上的问题&lt;a href=&quot;https://stackoverflow.com/questions/16465705/how-to-handle-configuration-in-go&quot;&gt;How to handle configuration in Go&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;toml的使用&quot;&gt;toml的使用&lt;/h2&gt;
&lt;p&gt;我根据自己的喜好选了toml，下面就来说下toml。&lt;/p&gt;
&lt;p&gt;先来看一个TOML文件的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# This is a TOML document.

title = &quot;TOML Example&quot;

[owner]
name = &quot;Tom Preston-Werner&quot;
dob = 1979-05-27T07:32:00-08:00 # First class dates

[database]
server = &quot;192.168.1.1&quot;
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  # Indentation (tabs and/or spaces) is allowed but not required
  [servers.alpha]
  ip = &quot;10.0.0.1&quot;
  dc = &quot;eqdc10&quot;

  [servers.beta]
  ip = &quot;10.0.0.2&quot;
  dc = &quot;eqdc10&quot;

[clients]
data = [ [&quot;gamma&quot;, &quot;delta&quot;], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  &quot;alpha&quot;,
  &quot;omega&quot;
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以看到这里的格式非常灵活，可以是数字、字符串、布尔等简单类型，也可以是数组、map等等复杂的类型。&lt;/p&gt;
&lt;p&gt;关于具体的TOML语言的解说大家查看文档 &lt;a href=&quot;https://github.com/toml-lang/toml&quot;&gt;toml-lang/toml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我们再来说一下，具体的Golang代码中如何使用&lt;/p&gt;
&lt;p&gt;我们基于上面的配置文件来定义Golang中配置的struct，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type tomlConfig struct {
    Title string
    Owner ownerInfo
    DB database `toml:&quot;database&quot;`
    Servers map[string]server
    Clients clients
}

type ownerInfo struct {
    Name string
    Org string `toml:&quot;organization&quot;`
    Bio string
    DOB time.Time
}

type database struct {
    Server string
    Ports []int
    ConnMax int `toml:&quot;connection_max&quot;`
    Enabled bool
}

type server struct {
    IP string
    DC string
}

type clients struct {
    Data [][]interface{}
    Hosts []string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一些都定义好之后，我们只需要将文件配置中的内容转成Golang中可用的struct实例即可，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var config tomlConfig
filePath := &quot;/your/path/config.toml&quot;
if _, err := toml.DecodeFile(filePath, &amp;amp;config); err != nil {
    panic(err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们拿到的config就是拥有TOML文件内容的tomlConfig的实例，可以直接使用。&lt;/p&gt;
&lt;h2 id=&quot;配置的单例模式&quot;&gt;配置的单例模式&lt;/h2&gt;
&lt;p&gt;通常来说，在一个项目中，配置文件只需要解析一次，所以可以使用单例模式包一下config的解析。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package config

var (
    cfg * tomlConfig
    once sync.Once
)

func Config() *tomlConfig {
    once.Do(func() {
        filePath, err := filepath.Abs(&quot;./ch3/config.toml&quot;)
        if err != nil {
            panic(err)
        }
        fmt.Printf(&quot;parse toml file once. filePath: %s\n&quot;, filePath)
        if _ , err := toml.DecodeFile(filePath, &amp;amp;cfg); err != nil {
            panic(err)
        }
    })
    return cfg
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用了sync.Once的Do方法，Do方法当且仅当第一次被调用时才执行函数。&lt;/p&gt;
&lt;p&gt;如果once.Do(f)被多次调用，只有第一次调用会执行f，即使f每次调用Do 提供的f值不同。需要给每个要执行仅一次的函数都建立一个Once类型的实例。&lt;/p&gt;
&lt;p&gt;这样我们就保证了tomlConfig对象是一个单例模式，只需要解析一次，可以在任何地方调用。调用例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 配置中DB的IP
fmt.Println(config.Config().DB.Server)
// 配置中Owner的名字
fmt.Println(config.Config().Owner.Name)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置的更新&quot;&gt;配置的更新&lt;/h2&gt;
&lt;p&gt;如果我们的项目是一个常驻的项目（比如http server），我们会希望能够提供更新配置的功能，平滑的替换掉配置，不需要重启项目。&lt;/p&gt;
&lt;p&gt;其实思路很想简单，我们只需要起一个协程，监视我们定义好的信号，如果接收到信号就重新加载配置。&lt;/p&gt;
&lt;p&gt;下面我们来写下，更新配置的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    s := make(chan os.Signal, 1)
    signal.Notify(s, syscall.SIGUSR1)
    go func() {
        for {
            &amp;lt;-s
            config.ReloadConfig()
            log.Println(&quot;Reloaded config&quot;)
        }
    }()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们监视了syscall.SIGUSR1信号，其值是30，接收到信号就执行config.ReloadConfig()方法。&lt;/p&gt;
&lt;p&gt;再来看下config中方法变动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Config() *tomlConfig {
    once.Do(ReloadConfig)
    cfgLock.RLock()
    defer cfgLock.RUnlock()
    return cfg
}

func ReloadConfig() {
    filePath, err := filepath.Abs(&quot;./ch3/config.toml&quot;)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;parse toml file once. filePath: %s\n&quot;, filePath)
    config := new(tomlConfig)
    if _ , err := toml.DecodeFile(filePath, config); err != nil {
        panic(err)
    }
    cfgLock.Lock()
    defer cfgLock.Unlock()
    cfg = config
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来加载配置的代码放到ReloadConfig方法中去了，还在给变量cfg赋值的时候加了读写锁，以保证安全。在Config方法中获取cfg的时候加了读锁，防止在读的时候，也在写入，导致配置错乱。&lt;/p&gt;
&lt;p&gt;启动server之后，可以通过如下shell命令更新配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kill -30 6666&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的6666是go server的进程号。执行这条命令之后，会向go server发送syscall.SIGUSR1的信号，从而触发更新配置的动作。&lt;/p&gt;
&lt;h2 id=&quot;posix信号&quot;&gt;POSIX信号&lt;/h2&gt;
&lt;p&gt;这边顺便列一下POSIX中定义的信号：&lt;/p&gt;
&lt;p&gt;Linux 使用34-64信号用作实时系统中。&lt;/p&gt;
&lt;p&gt;命令 man 7 signal 提供了官方的信号介绍。&lt;/p&gt;
&lt;h4 id=&quot;在posix.1-1990标准中定义的信号列表&quot;&gt;在POSIX.1-1990标准中定义的信号列表：&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGHUP&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;终端控制进程结束(终端连接断开)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;用户发送INTR字符(Ctrl+C)触发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGQUIT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;用户发送QUIT字符(Ctrl+/)触发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGILL&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;非法指令(程序错误、试图执行数据段、栈溢出等)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGABRT&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;调用abort函数触发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGFPE&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;算术运行错误(浮点运算错误、除数为零等)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGKILL&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;无条件结束程序(不能被捕获、阻塞或忽略)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;SIGSEGV&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGPIPE&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SIGALRM&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;时钟定时信号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGTERM&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;结束程序(可以被捕获、阻塞或忽略)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SIGUSR1&lt;/td&gt;
&lt;td&gt;30,10,16&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;用户保留&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SIGUSR2&lt;/td&gt;
&lt;td&gt;31,12,17&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;用户保留&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGCHLD&lt;/td&gt;
&lt;td&gt;20,17,18&lt;/td&gt;
&lt;td&gt;Ign&lt;/td&gt;
&lt;td&gt;子进程结束(由父进程接收)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGCONT&lt;/td&gt;
&lt;td&gt;19,18,25&lt;/td&gt;
&lt;td&gt;Cont&lt;/td&gt;
&lt;td&gt;继续执行已经停止的进程(不能被阻塞)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGSTOP&lt;/td&gt;
&lt;td&gt;17,19,23&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;停止进程(不能被捕获、阻塞或忽略)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGTSTP&lt;/td&gt;
&lt;td&gt;18,20,24&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;停止进程(可以被捕获、阻塞或忽略)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGTTIN&lt;/td&gt;
&lt;td&gt;21,21,26&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;后台程序从终端中读取数据时触发&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGTTOU&lt;/td&gt;
&lt;td&gt;22,22,27&lt;/td&gt;
&lt;td&gt;Stop&lt;/td&gt;
&lt;td&gt;后台程序向终端中写数据时触发&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;在susv2和posix.1-2001标准中的信号列表&quot;&gt;在SUSv2和POSIX.1-2001标准中的信号列表:&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGTRAP&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;Trap指令触发(如断点，在调试器中使用)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGBUS&lt;/td&gt;
&lt;td&gt;0,7,10&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;非法地址(内存地址对齐错误)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGPOLL&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;Pollable event (Sys V). Synonym for SIGIO&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGPROF&lt;/td&gt;
&lt;td&gt;27,27,29&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;性能时钟信号(包含系统调用时间和进程占用CPU的时间)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGSYS&lt;/td&gt;
&lt;td&gt;12,31,12&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;无效的系统调用(SVr4)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGURG&lt;/td&gt;
&lt;td&gt;16,23,21&lt;/td&gt;
&lt;td&gt;Ign&lt;/td&gt;
&lt;td&gt;有紧急数据到达Socket(4.2BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGVTALRM&lt;/td&gt;
&lt;td&gt;26,26,28&lt;/td&gt;
&lt;td&gt;Term&lt;/td&gt;
&lt;td&gt;虚拟时钟信号(进程占用CPU的时间)(4.2BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGXCPU&lt;/td&gt;
&lt;td&gt;24,24,30&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;超过CPU时间资源限制(4.2BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SIGXFSZ&lt;/td&gt;
&lt;td&gt;25,25,31&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td&gt;超过文件大小资源限制(4.2BSD)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;代码可参考：&lt;a href=&quot;https://github.com/CraryPrimitiveMan/go-in-action/tree/master/ch3&quot; class=&quot;uri&quot;&gt;https://github.com/CraryPrimitiveMan/go-in-action/tree/master/ch3&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.ralch.com/tutorial/design-patterns/golang-singleton/&quot;&gt;Design Patterns in Golang: Singleton&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://openmymind.net/Golang-Hot-Configuration-Reload/&quot;&gt;Golang hot configuration reload&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jkkkk/p/6180016.html&quot;&gt;Golang中的信号处理&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 07:43:00 +0000</pubDate>
<dc:creator>疯狂的原始人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CraryPrimitiveMan/p/7928647.html</dc:identifier>
</item>
<item>
<title>从开源项目看 Python 单元测试 - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/ut-in-open-source.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/ut-in-open-source.html</guid>
<description>&lt;p&gt;我觉得以前在我开发程序的时候，除了文档，可能单元测试是另外一个让我希望别人都写，但是自己又一点都不想写的东西。但是，随着开发程序的增多，以及自己对 Bug 的修改的增多，我发现，UT 在很大程度上是对我有利的，虽然带来的结果就是可能我的 Dev 时间会增加 20-40% 左右，但是，相比较于一段时间之后突然冒出来一个 Bug，让你摸不着头脑；或者说突然一个接一个的 Bug 在你转测试之后提过来，写 UT 的幸福感和自豪感明显是更高的。&lt;/p&gt;
&lt;p&gt;就我目前而言，我认为写单元测试有这么几个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;帮助减小代码的耦合度，这样你才能更容易得编写 UT&lt;/li&gt;
&lt;li&gt;理清代码的模块依赖，这样你才能在 UT 中知道哪些东西要 Mock，哪些东西要 Stub&lt;/li&gt;
&lt;li&gt;保持接口的干净和明朗，UT 就是针对接口编程，Input 和 Ouput 都需要明确&lt;/li&gt;
&lt;li&gt;UT 是一个自诠释的文档，别人可以通过你的 UT 来学习你的接口使用方式&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我需要提出一点的就是，一般而言，我很难做到 Test First，也就是所谓的先完成 UT 代码的编写，然后再写实现代码。当然，这不是说不行，就以目前的经历来说，这做法欠妥，一个很重要的原因是项目周期的把控，如果你 UT First，万一后面你时间不够实现 Logical Code 了怎么办？光有 UT 并不能让你的整个 Project 跑起来。所以，一般来说，我经历的大部分项目都是先 Run 起来，然后再通过 UT 保证目前的功能是正常的，并且可以保证在以后的维护和更新中，功能的正确性不会被破坏。&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;测试方法&lt;/h2&gt;
&lt;p&gt;学过完善的软件工程体系的同学都知道，软件测试是软件工程中非常重要的一环，甚至于可以说对于一个 Project，测试人员的参与度比 Developer 的高多了，我刚毕业那会，测试人员的参与度可以说是贯穿了全流程，从需求的提出到验收发布，这整个流程都有测试人员的参与，而 Developer，可能参与到&lt;strong&gt;&quot;转测试&quot;&lt;/strong&gt;环境就差不多完了，所以测试工程也是一项非常复杂的学科。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;测试覆盖&lt;/h3&gt;
&lt;p&gt;因为测试非常复杂，所以也是有很多方法论和实践的。就拿 UT 来说，对于代码我们可以有几个不同的测试角度。例如覆盖角度来说，我们就有语句覆盖，分支覆盖，条件覆盖，路径覆盖和循环覆盖；测试内容来说，我们又会分模块测试，数据结构测试，路径测试，错误处理测试和边界测试等等。对于这么多测试，其实我发现大部分开源项目都没有很严格得遵守这些理论，因为可能说随便一条理论在实践中都能让人抓狂。&lt;/p&gt;
&lt;p&gt;其实在我见过的几个流行的开源项目中，基本上都是以语句覆盖为目标进行的，并且并不能达到 100%，所以更多得是以主要功能是正常的为目标进行 UT 测试的。以下是部分开源项目的测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201712/469840-20171223151956178-99645752.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;除此之外，对于 UT 的增加是在 issue 的基础上建立的，也就说当有用户提了一个 issue 之后，Maintener 觉得这个 issue 是个问题，并且会影响到我这个项目，那么就会开发开发相应的 patch fix 它，并且补上 UT，这种情况也是比较常见，这样的话，渐渐地 UT 的覆盖率也就慢慢上去了。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;测试方法&lt;/h3&gt;
&lt;p&gt;在测试中，我们的代码可能会有很多依赖，例如模块依赖，组件依赖等等，为了解决这些依赖，我们总要有一些方法来处理，这里就有两项经常使用的技术：Stub 和 Mock。&lt;/p&gt;
&lt;p&gt;我以前喜欢说讲一个对象 Mock 掉，意思就是讲一个对象用自定义的模拟类替换掉，从而让我们可以自定义类的行为和输出，但是，我发现这其实在测试中是 Stub，所谓的 Stub 就是模拟测试代码调用的模块和组件，从而自定义被调用后的行为和输出；而相比之下，Mock 的功能是验证模板或者组件有没有被调用，很常见的例子就是邮件发送服务有没有被调用，有没有输出日志内容等等。关于 Stub 和 Mock 更多的内容介绍我推荐 Martin Folwer 的这篇文章：&lt;a href=&quot;https://martinfowler.com/articles/mocksArentStubs.html&quot;&gt;Mocks Aren't Stubs&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;测试工具&lt;/h2&gt;
&lt;p&gt;在 Python 中，自身就带了类 XUnit 的 unittest 框架，使用也很简单，例如下面就是一个很简单的测试用例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201712/469840-20171223151958600-1751298871.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;其实使用起来已经很简单了，但是 Python 的小伙伴还是嫌他又啰嗦又慢，所以你会发现 pytest 这个库很受欢迎。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;pytest&lt;/h3&gt;
&lt;p&gt;pytest 作为一个单元测试框架，使用方法有多种，既可以和 python 自带的 unittest 类似，又可以很简单得就一个函数来写 UT；不仅开发效率会更高，而且执行效率也可以更高，其他优点就不啰嗦介绍了，官网里面都罗列了：&lt;a href=&quot;https://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;至于有多简单方便，你将下面这段代码保存到 &lt;code&gt;test_sample.py&lt;/code&gt; 文件中，然后在对应的目录路径下执行 &lt;code&gt;pytest&lt;/code&gt; 命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201712/469840-20171223151956100-707523850.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;执行之后你应该会发现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201712/469840-20171223151959162-1342161531.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;对，你会发现，就这么简单得执行起来了。但是，很多同学还是不满于此，因为很多 Python 项目不仅仅适应于一个版本的 Python，所以就会有多一个 Python 版本的测试（Python 的又一坑，2.6/2.7/3.x/3.5 不兼容）。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;tox&lt;/h3&gt;
&lt;p&gt;为了满足一个 Python 项目可以在多个 Python 版本中可以正常运行，很多人会使用 tox 进行不同环境下的兼容性测试，所以 tox 的功能就是环境管理和测试运行。关于 tox 的更多功能使用和细则可以参考一下 tox 官网：&lt;a href=&quot;https://tox.readthedocs.io/en/latest/&quot;&gt;Tox&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;tox 一般都会有一个 tox.ini 文件，例如一个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201712/469840-20171223151956428-1442472197.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后执行 &lt;code&gt;tox&lt;/code&gt; 命令行工具就可以了，它就会找你机器上的各种环境，然后测试起来，最后的结果就有点类似于：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201712/469840-20171223151959646-618480871.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;单元测试是一种习惯，也是一种责任。通过单元测试，我们可以告诉别人我的代码是 Work 的，同时也给别人一种信任感，可以让别人相信你写的代码。同时，编写单元测试也是一项比较繁琐的事情，我们要处理依赖，考虑 Test Case，但是，这些过程都可以帮助我们更好得思考我们的项目和软件，从而让软件的结构和代码的质量提升一个台阶。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 07:20:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/ut-in-open-source.html</dc:identifier>
</item>
<item>
<title>【quickhybrid】如何实现一个Hybrid框架 - 撒网要见鱼</title>
<link>http://www.cnblogs.com/dailc/p/8093450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dailc/p/8093450.html</guid>
<description>&lt;h2 id=&quot;章节目录&quot;&gt;章节目录&lt;/h2&gt;
&lt;h2 id=&quot;一些感慨&quot;&gt;一些感慨&lt;/h2&gt;
&lt;p&gt;踏入前端领域满打满算也两年多了。到现在，主要方向已经是由&lt;code&gt;Android&lt;/code&gt;原生转到了偏前端领域。&lt;/p&gt;
&lt;p&gt;期间，不提自己的技术进步、视野拓宽，最大的产出之一应该就是从0开始构建了一个&lt;code&gt;Hybrid&lt;/code&gt;框架了。&lt;/p&gt;
&lt;p&gt;正值最近开始进行技术梳理，因此就准备写一系列文章沉淀起来。&lt;/p&gt;
&lt;h2 id=&quot;本系列包含的内容清单&quot;&gt;本系列包含的内容清单&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Hybrid框架的原理以及架构系列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JavaScript部分的原理以及源码系列（包括部分API的多容器的兼容）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Android部分的原理以及源码系列（仅覆盖核心实现以及API部分，不包含实际业务代码）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;iOS部分的部分原理（一些坑会特别提出，理论上根据原理应该可以还原出）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于本人没写过iOS应用，因此目前没有直接提供源码，后续有时间可以考虑进一步提供&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么样的hybrid框架&quot;&gt;什么样的&lt;code&gt;Hybrid&lt;/code&gt;框架？&lt;/h2&gt;
&lt;p&gt;核心宗旨：&lt;strong&gt;&lt;code&gt;H5&lt;/code&gt;页面基于该框架可以替代&lt;code&gt;80%&lt;/code&gt;以上的原生业务页面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更详细一点：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;适用于需要开发大量项目级APP的场景&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不是用于完全替代原生开发，而是替代里面的&lt;code&gt;80%&lt;/code&gt;原生业务页面（模式是： 原生部分 + H5部分）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;框架人员至少需要一名&lt;code&gt;Android&lt;/code&gt;原生，一名&lt;code&gt;iOS&lt;/code&gt;原生，一名&lt;code&gt;前端架构&lt;/code&gt;（如果全栈，可以考虑合一）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;部分API（如&lt;code&gt;UI&lt;/code&gt;显示类）考虑到了&lt;code&gt;H5&lt;/code&gt;的兼容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;并没有做到产品级别的优化（需求优先级别较低）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之所以不基于第三方框架而是自己重新实现，是由具体的环境与需求决定的。譬如要求自己必须完全掌握源码，某些功能必须通过特定安全检测等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，本系列不与任何市面上的其他框架进行比较，仅是自己的经验总结。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;此框架是否有实践经验&quot;&gt;此框架是否有实践经验？&lt;/h2&gt;
&lt;p&gt;此框架不是平地起高楼而来的，而是在接近两年的项目实战中慢慢演化出的，内部已经迭代过多个版本&lt;/p&gt;
&lt;p&gt;另外，它已经在一个项目型公司全面推广使用了。（&lt;code&gt;N+&lt;/code&gt;级别）&lt;/p&gt;
&lt;p&gt;这里要说明下：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;实际项目中，Hybrid框架仅仅是其中的一部分，还会包括一些原生通用组件，业务模块等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;但是本系列仅止步于Hybrid框架（处于诸多因素考虑，包括核心实现以及API实现）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何应用与自己的项目中&quot;&gt;如何应用与自己的项目中？&lt;/h2&gt;
&lt;p&gt;最后的源码部分仅提供核心实现以及API部分，对于一些简单项目来说，其实也就够用了，&lt;br/&gt;但是如果功能较复杂的，肯定需要进一步封装自己的原生功能。&lt;/p&gt;
&lt;p&gt;实际上推荐使用以下人员配置：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一名资深&lt;code&gt;Android&lt;/code&gt;原生（负责&lt;code&gt;Android&lt;/code&gt;容器）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一名资深&lt;code&gt;iOS&lt;/code&gt;原生（负责&lt;code&gt;iOS&lt;/code&gt;容器）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一名资深前端（前端部分不要小觑，要配合排查问题的）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;总架构（推荐是以上三人中的一人担任，譬如本系列是由前端来统一架构的-但前提是必须懂点原生原理，否则抓瞎）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为每一个人精力有限，所以除非特别厉害和全能，否则不建议一人担任两职&lt;br/&gt;（譬如像我转入前端后，以前的Android就遗忘的很快，但是如果重点兼顾Android，前端水准肯定无法快速提升）&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;N+&lt;/code&gt;项目时的模式大致如下：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;三名框架人员负责核心框架容器部分(框架还需要提供一些通用模块与组件)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;各个业务线的APP中可以专门分配不同的原生人员负责打包APP（1对N，协助排查各自可能的业务问题）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每一个APP中可以有若干&lt;code&gt;H5&lt;/code&gt;业务开发人员(由不同的复杂度而定，主要业务都是线上的H5形式)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;三名对于的框架人员负责处理过滤后的真正框架BUG（由业务负责人过滤）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，以上是最小配置。（譬如可以分配更多的框架人员，优化提升等）&lt;/p&gt;
&lt;p&gt;最后，以上是实际的经验总结，仅做参考。&lt;/p&gt;
&lt;h2 id=&quot;框架更新与迭代&quot;&gt;框架更新与迭代&lt;/h2&gt;
&lt;p&gt;实际上不同框架的更新迭代方式都是不一样的，比如本系列中就是基于需求迭代&lt;/p&gt;
&lt;p&gt;也就是说遇到问题才修复，优化，累积一段时间后开始考虑下一代的优化提升（迫于投入的窘迫性）&lt;/p&gt;
&lt;p&gt;一般来说，整体的交互架构以及API是由对于的负责人规划的，然后安排给对于的容器实现&lt;/p&gt;
&lt;p&gt;版本号的化仍然是以下经典形式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;大版本.小版本.修正版&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;譬如本框架在两年内迭代了&lt;code&gt;多&lt;/code&gt;个大版本（涉及到底层），&lt;br/&gt;使用起来变化较大就会变动小版本，&lt;br/&gt;平时个别API新增和修复是修正版&lt;/p&gt;
&lt;p&gt;这里因人而异，比如有的喜欢将API新增也变为小版本更新&lt;/p&gt;
&lt;h2 id=&quot;借鉴与不足&quot;&gt;借鉴与不足&lt;/h2&gt;
&lt;p&gt;本框架中在实现是吸取了不少市面上已有框架的经验，譬如：&lt;/p&gt;
&lt;ul readability=&quot;1.2391304347826&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;钉钉（API设计上，可惜无法看到它底层实现...）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;phonegap,html5+,apicloud,appcan等都有接触过（但参考的不多）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.47826086956522&quot;&gt;
&lt;p&gt;一些&lt;code&gt;github&lt;/code&gt;开源库，譬如&lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot;&gt;marcuswestin/WebViewJavascriptBridge&lt;/a&gt;等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，在文章总结时，参考了一些博文，包括我以前写的文章（会在参考来源中）&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;github&lt;/code&gt;上这个框架的实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/quickhybrid/quickhybrid&quot;&gt;quickhybrid/quickhybrid&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 07:01:00 +0000</pubDate>
<dc:creator>撒网要见鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dailc/p/8093450.html</dc:identifier>
</item>
<item>
<title>编码综述-《大型网站技术原理：基本原理》 - 初开</title>
<link>http://www.cnblogs.com/wchukai/p/8093205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wchukai/p/8093205.html</guid>
<description>&lt;p&gt;在本章节，我们将从编码的概念开始，谈谈常见的一些编码类型,再接着谈谈信息论中两个最重要的编码过程-压缩和加密，分析它们在网站中的应用，最后深入理解在分布式系统中的编码过程-序列化。&lt;/p&gt;
&lt;p&gt;对信息论有足够理解的朋友可以快速略过前4节，阅读后面的序列化及思考部分。&lt;/p&gt;

&lt;p&gt;让我们回到数百年前的古代，在那个时候可没有电话，如果有人想给远方的朋友传个信，那就只能修书一封，飞鸽传书了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9xxqAcGcyAAC4pnGpP0I318.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们分析下这个过程中，某人将想说的话（语言），写到（存储到）纸上（文字），然后飞鸽传书（传输）。古代识字率比较低，万一朋友不识字，还得请隔壁的教书先生念信，将文字表述为语言。&lt;/p&gt;
&lt;p&gt;在这个场景中，我们看到了一句话经历了语言到文字，然后文字再到语言的转化，这个过程在信息论中被称为编码。因此，&lt;strong&gt;广义上的编码是信息在不同形式下的表示和转换的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9x0-Ad5yAAAAxk8g3M3I384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编码有两个重要的组成部分，一是多种表现形式，比如语言和文字，二是不同编码形式间的对应关系，比如“编码”读作“[biān mǎ]”，写作“编码”。而编码的主要应用场景是传输和存储。特别的，逆向的编码过程我们称为解码。&lt;/p&gt;
&lt;p&gt;当然，编码本身是一个大主题，我们今天谈到的编码，将是狭义上的编码，&lt;strong&gt;指计算机中，特别是软件开发中，不同数据格式的表示和转化过程。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;h2--&quot;&gt;（一） 数制与二进制&lt;/h2&gt;
&lt;p&gt;现代计算机通常是基于二进制的，用0和1表状态，二进制属于进位计数制一种，另一种十六进制也在计算机中经常使用，而生活中常用的是十进制。&lt;/p&gt;
&lt;p&gt;之所以使用二进制，是因为电子计算机利用的是通电、断电（或高电平、低电平）两种状态。这两种状态可以表示为1/0，正好与二进制相对应，一个状态表示一个二进制位,单位称为bit，然后便可以编码表示任一数字，比如7=111。&lt;/p&gt;
&lt;p&gt;再进一步，如果让第一位表示符号，即正负，那么负数就可以编码了；如果约定前n位表整数位，后m位表小数位，这就是浮点数了。当然在实际中，负数我们是通过补码的方式表示，浮点也有单精度和双精度之分，本文不做进一步阐述。&lt;/p&gt;
&lt;p&gt;另一方面，0、1也与布尔代数理论中的两种逻辑值“True”、“False”对应，再结合逻辑电路，这就为计算机提供了逻辑基础。&lt;/p&gt;
&lt;p&gt;Niklaus Wirth写过一本书《算法 + 数据结构 = 程序》，那么在这里，&lt;strong&gt;逻辑运算+数值编码=现代计算机&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（二） 字符编码&lt;/h2&gt;
&lt;p&gt;光有数字的编码是不够的,在过去的几千年，人类留下来的历史的信息大多是靠文字记录，数字从0到9不过10个，而汉字则以十万计，还不包括一些繁体和变体，其他语言文字就更别说了。因此，在计算机中，我们也需要一种特定的编码规则来表示文字。&lt;/p&gt;
&lt;h3 id=&quot;h3-1-ascii-&quot;&gt;1.ASCII码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ASCII码是英语字符与二进制位的对应的编码机制&lt;/strong&gt;，采用8个二进制位来表示一个字符（8bit），8bit可以表示从0000000到11111111的数字，共256位。而英文大小写共52个，再加上数字字符，空格，换行的特殊符号，8bit完全足够了。而实际上ASCII码只规定了128个字符的编码,只用了8bit的后7位，第一位统一为0。这就有了另一个单位字节(byte),即1byte占8bit。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-ascii-&quot;&gt;2.非ASCII码&lt;/h3&gt;
&lt;p&gt;随着计算机的推广，其他国家有自己的语言和文字，它们也需要在计算机中表示，ASCII只用了后7位，所以最开始一些欧洲的语言比如法语，通过扩展ASCII码到8位来表示对应语言的字符，这个字符集便是ISO-8859-1。&lt;/p&gt;
&lt;p&gt;ISO-8859-1容量还是256位，其他语言的文字，比如数以万计的汉字就无法加入了，因此1981年中国推出了汉字字符编码GB2312，为了兼容ASCII，英文字母还是用1byte表示，汉字则用两个字节表示。&lt;/p&gt;
&lt;p&gt;既然汉字有对应编码了，还有日，韩等诸多文字也得编码。再者，如果我们用汉字写邮件发往英文地区，也会有编码不同无法识别的问题，这些就需要一个统一的解决方案了。&lt;/p&gt;
&lt;h3 id=&quot;h3-3-unicode-&quot;&gt;3.Unicode字符集&lt;/h3&gt;
&lt;p&gt;不同国家使用不同编码自然就会导致信息沟通的困难，我们自然就想到了需要一个统一的标准来编码这个世界上所有的字符，于是Unicode就诞生了。&lt;/p&gt;
&lt;p&gt;Unicode之所被称为字符集，因为它并不是一种编码规则，仅仅只规定了字符与数值的对应关系-码点（Code Point），但没有规定具体实现，比如用几个字节存储。&lt;/p&gt;
&lt;p&gt;常见的实现有如下几种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UTF-8，可变长度编码，对ASCII码在内的字符使用单字节，对汉字等字符用3字节。&lt;/li&gt;
&lt;li&gt;UTF-16，统一用2字节编码。&lt;/li&gt;
&lt;li&gt;UTF-32，统一用4字节编码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，国外的网站普遍用ISO-8859-1，国内通常使用GBK，面向国际的网站通常基于UTF-8。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码的兼容性&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本小节我们谈到了多种字符编码，很多编码都只适用于特定语言，最后UNICODE的出现才统一编码标准，这里就体现了编码需要考虑的第一个方面-&lt;strong&gt;兼容性&lt;/strong&gt;，在制定编码时需要评估跨语言，跨系统的场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（三）文件编码&lt;/h2&gt;
&lt;p&gt;在计算机中普遍数据的存储方式是通过文件存放的，所以，&lt;strong&gt;各种格式的文件本身就是一种编码方式&lt;/strong&gt;，一般来说我们可以通过后缀名来区分，比如&lt;em&gt;.txt，&lt;/em&gt;.doc，*.gif等等，当然后缀是可以被篡改，严格一点可以根据文件头信息来分别。&lt;/p&gt;
&lt;p&gt;常见的文件类型比如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文本文件(*.txt)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文本文件都是以2.2节谈到字符编码方式存储的，在Windows下，用记事本打开txt文件，点击文件-&amp;gt;另存为，可以看到可选的编码方式，默认是ANSI（这是一种Windows用来兼容不同语言的编码方式），也可以改为Unicode等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;音频文件(*.mp3)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在生活中，我们通常用MP3来指代音频文件，实际上MP3只是音频文件的一种编码方式，常见的音频编码类型有MP3、WMA、OGG…，它们在音质，存储，兼容性等方面各有所长。&lt;/p&gt;
&lt;p&gt;其他还有视频文件，压缩文件等等，在计算机中，每一种文件的格式都是一种编码格式。&lt;/p&gt;

&lt;h2 id=&quot;h2--&quot;&gt;（一）游程编码&lt;/h2&gt;
&lt;p&gt;考虑到这么一段大写的数据AAABBB，长度为6。&lt;/p&gt;
&lt;p&gt;如果我们定义一种编码机制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AAA=A3
BBB=B3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么上面的数据可以表示为A3B3，长度仅为4。同样的编码，再给这一段信息D3C3，你也能轻松转义成DDDCCC。我们可以看到后一种表示方式的长度更小。这种编码方式叫游程编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将数据通过特定的编码方式减少数据包大小的机制我们称之为压缩&lt;/strong&gt;，编码机制即指压缩算法，而上面的AAA=A3这一对应关系，称之为字典，它的解码过程自然是解压了。&lt;/p&gt;
&lt;p&gt;在信息论中，压缩被称为信源编码，这是一种对输入信息进行编码，优化信息和压缩信息的编码方式。&lt;/p&gt;
&lt;p&gt;我们对比下编码与压缩：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9x5-AYtHEAACNo82uYFw483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2--huffman-&quot;&gt;（二） Huffman算法&lt;/h2&gt;
&lt;p&gt;我们再定义一个字典,用01来编码字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AA=0
BB=1
CC=01
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么就有如下编码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AACCCC=00101
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们换一种编码方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AA=0
BB=01
CC=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么就有&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AACCCC=011
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为CC出现了两次，如果我们用较短的编码来表示出现频率高的字符，就可以得到更好的&lt;strong&gt;压缩比&lt;/strong&gt;（压缩前后数据大小的比例）。&lt;/p&gt;
&lt;p&gt;那么，如何计算出这样一个字典？这就有了非常经典的压缩算法-霍夫曼编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Huffman算法是一种依据字符出现频率来计算最优压缩字典的算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法摘要如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将信源符号按照概率大小从大到小排列；&lt;/li&gt;
&lt;li&gt;把概率最小的两个信源符号分成一组，其中，上面一个编码为0，下面一个编码为1，并将这两个符号的概率加起来，其结果再与尚未处理过的符号重新按照大小排序；&lt;/li&gt;
&lt;li&gt;重复步骤2，直到所有的信源符号都处理完毕；&lt;/li&gt;
&lt;li&gt;从右至左按照编码路径返回，即可得到各个码字。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比如以下频率&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150620143635172&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编码可表示为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150620143717070&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他压缩算法还有LZ77，以及基于类似原理的一些变种算法，本文不再阐述。&lt;/p&gt;
&lt;p&gt;在基于这些压缩算法的常见程序有gzip，winrar，7z等等，我们将在3.3节介绍压缩的应用场景。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（三） 有损压缩&lt;/h2&gt;
&lt;p&gt;如下是两张图片，都是通过一张图处理得来的，它们的色彩，清晰度可有差异？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/01/cHx_F1oagcuAQqJWAABsJh73FeI941.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;肉眼是很难看出，实际上右图的像素比左图少5%，并通过放大到同等大小的。&lt;/p&gt;
&lt;p&gt;上一节谈到的Huffman算法是一种无损压缩算法，也就是说，压缩后的数据可以通过逆向过程，解压还原出原数据的。&lt;/p&gt;
&lt;p&gt;而像图片这种允许一部分数据丢失但不影响效果的场景，我们就可以用有损压缩的算法降低文件大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有损压缩&lt;/strong&gt;是利用了人类视觉，听觉等方面不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原数据，但可以获得更大的压缩比。因此，常见的有损压缩往往应用在图片，音频，视频等文件编码上。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（四）压缩的应用&lt;/h2&gt;
&lt;p&gt;最后，我们谈谈压缩的一些应用场景。&lt;/p&gt;
&lt;p&gt;谈编码的概念时，介绍了编码是用在传输和存储中的，我们就从这两个角度谈谈压缩的应用。&lt;/p&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1.传输&lt;/h3&gt;
&lt;p&gt;在前端部分，诸如Nginx，Tomcat等Web服务器都可以配置gzip压缩，浏览器在发送请求时通过添加&lt;code&gt;Accept-Encoding: gzip;&lt;/code&gt;请求头，从而实现各类资源的压缩传输。&lt;/p&gt;
&lt;p&gt;文件压缩也是常用场景，我们曾遇到过由于图片没有压缩，导致一个网页需要传输上百M数据的问题，严重影响用户体验。&lt;/p&gt;
&lt;p&gt;在后端的各类分布式系统中，通常会根据特定的数据格式自定义压缩规则,我们会在第5节谈谈序列化的例子。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2.存储&lt;/h3&gt;
&lt;p&gt;在数据库和日志系统中都提供了压缩功能，比如MySQL就提供了压缩表选项，可以在建表时进行配置。腾讯的TMySQL和阿里的AliSQL等还提供针对列压缩的特性，为blob/text等大字段进行灵活的压缩配置。&lt;/p&gt;
&lt;p&gt;在分布式文件系统中，文件的压缩应用就广泛了，像用户上传的图片，很多网站都会进行统一的格式转换，针对不同的场景，压缩到不同的分辨率，比如缩略图就是通过高压缩比的有损压缩而来。特别的，HDFS（Hadoop Distributed File System）还提供了合并压缩存储的方案，我们会在本书第二部分，分布式文件系统一文中谈谈这个话题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码的效率&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们知道，衡量算法复杂度分为时间复杂度和空间复杂度，其实说的是算法的效率从空间和时间两个方面来衡量。而压缩正是提高了编码的空间效率，因此，效率是编码需要考虑的第二个方面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回到本文开头谈到了寄信场景，假设我们寄的不是家书，而是一名将军要下达给部队的命令函，那这封信就不能白纸黑字的写清楚了，万一信使被抓就泄密了，我们需要做一些加密的手段。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（一） 密码本&lt;/h2&gt;
&lt;p&gt;密码本是最古老的保密方式之一，在北宋的军事著作《武经总要》记载着一种名为“字验”的加密手段。&lt;/p&gt;
&lt;p&gt;他们收集了军队中常用的40种战斗情况，如请弓、请粮料、都将病等等，然后战前约定一首五言律诗编码，五言律诗共8行，每行5字，正好40字，每个字对应一种战斗情况。这样传令时只需传一个字就可以完成通讯了。&lt;/p&gt;
&lt;p&gt;如王维的使至塞上:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;单车欲问边，属国过居延。
征蓬出汉塞，归雁入胡天。
大漠孤烟直，长河落日圆。
萧关逢候骑，都护在燕然。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9yJKAOPTyAAEhvp92Yyo445.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（二） 对称加密&lt;/h2&gt;
&lt;p&gt;回到计算机中，我们为文本消息定义一种编码，称为字符x+5，每个字符用它后面的第5个字符代替，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A-&amp;gt;F
B-&amp;gt;G
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种方式，只要x+5这个规则不被破解，就起到了加密作用，而接收者只需要知道x+5的值，就可以解码出x的值。由于加密和解密都用到了同一个密钥，所以这个方式我们称为&lt;strong&gt;对称加密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，实际应用中的加密算法比这个复杂的多，通常密钥长度在几十到数百位不等。&lt;strong&gt;常见的对称加密算法有DES、IDEA、RC等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们对比下编码与加密：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9x96ASbPeAABzmOMYS8k268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（三）非对称加密&lt;/h2&gt;
&lt;p&gt;由于对称加密只有一个密钥，一旦公开所有人都可以解密信息，在多方传输中存在安全风险。因此也就有了非对称加密，这种方式将加密密钥（公钥）和解密密钥（私钥）分开，任何发信人都可以用公钥发送加密信息，但只有收信人有私钥解密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9yBiAEXy5AABecXjmStA853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上有这么一段形象的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;非对称加密算法就是别人想要发信息给你。你先造一个保险箱。保险箱关上是不用钥匙的。把这个保险箱开着递给别人。别人发信息就把信息放进去然后“砰”一下关上还给你。只有你有钥匙信息可以查看信息，除非别人有其它方式破解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们来简单描述下非对称加密算法RSA的编解码过程。&lt;/p&gt;
&lt;p&gt;RSA基于这样一个事实，将两个大素数相乘是很容易，但从结果中分解出它们则非常耗时。选取大素数可长达数千位，当然这样的素数选取出来也不容易，通常是用Miller Rabin等素数测试算法来检测素数，会存在一定的误判。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.随机选取相同的两个大素数相乘，我们这里用A=37，B=23两个小素数代替。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;N=A×B
T=(A-1)×(B-1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;N=37×23=851
T=(37-1)×(23-1)=36×22=792
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如选E（公钥）=5&lt;/p&gt;
&lt;p&gt;则&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D×5 mod 792=1
D(私钥)=317
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如 M（明文）=7&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C（密文）=7^5 mod 851 = 638
M（明文）=638^317 mod 851 =7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h2--hash&quot;&gt;（四） 安全Hash&lt;/h2&gt;
&lt;p&gt;Hash函数是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，可以充当原数据的映射，用于快速查找和校验。&lt;/p&gt;
&lt;p&gt;一般情况下由于输出Hash值的空间通常远小于输入的空间，不同的输入可能会计算出相同的Hash值，所以无法从Hash来唯一的确定输入值，会出现值冲突，难以求逆。但是，通过精心设计的Hash算法，如&lt;strong&gt;MD5&lt;/strong&gt;，&lt;strong&gt;SHA&lt;/strong&gt;，其值域极大，在现有计算机条件实现了无冲突，同时求逆也更加不可能。因此，对于一些无需解密的数据，这些安全Hash算法就能用来充当加密工具。&lt;/p&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1.彩虹表&lt;/h3&gt;
&lt;p&gt;虽然Hash本身不可逆，但并非不可破解，如字符串123456，我们用MD5算法计算出它的Hash值为7e8feb2276322ecddd4423b649dfd4d9，这样，只要看到是这段hash值的地方，我们就可以认为这段数据是123456。这就有了一种暴力破解方式-彩虹表。&lt;/p&gt;
&lt;p&gt;彩虹表是预先将数以百亿级的各种字符串，特别是有规律的字符串的Hash计算出来，整个表的大小通常在数百G以上，然后通过碰撞的方式破解Hash值。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2.加盐&lt;/h3&gt;
&lt;p&gt;既然一般字符串的Hash表是可以被计算的，我们可以通过往输入项里面加一段信息,我们称之为盐(salt)，比如123456改为salt123456,然后再计算Hash值。之后每次查询的时候，都在输入项前面加上salt，然后再查询，只要不被人知道盐值，用普通的彩虹表是无法破解信息的。&lt;/p&gt;
&lt;h3 id=&quot;h3-3-hash&quot;&gt;3.慢Hash&lt;/h3&gt;
&lt;p&gt;前面谈到各种加密方式并非无法破解，只是以现有计算机的运算能可能需要十几甚至上百年的时间。这就有了密码学领域的另一个通识，就是加密方式并非要做到绝对无法破解，很多信息是有时效性的，只需要在一定年限内无法破解，过期之后的价值就不大了，这也是很多国家机密会设置保密期的原因。&lt;/p&gt;
&lt;p&gt;因此，就有了另一种对抗破解的方式-慢Hash，慢哈希是指执行这个哈希函数非常慢，这样暴力破解需要枚举遍历所有可能结果时，就需要花上非常非常长的时间。由于慢Hash耗计算量，我们往往会把这些计算量转嫁到客户端，让客户端计算完Hash传给服务端校验。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（五）加密的应用&lt;/h2&gt;
&lt;p&gt;我们也从传输和存储方面谈谈加密的应用。&lt;/p&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1. 传输&lt;/h3&gt;
&lt;p&gt;常见的加密传输有HTTPS，SSH等协议，它们往往是非对称加密与对称加密算法相结合制定的,我们会在第二章通信协议中进一步谈谈HTTPS的内容。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2. 存储&lt;/h3&gt;
&lt;p&gt;存储方面最重要是密码存储了，通常基于安全Hash,附加加盐、慢hash等手段进行复杂的加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码的安全性&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在这一节，我们谈到了多种加密方式，这些方式都是为了保证数据在存储和传输过程中的安全，那么加密自然就是体现了编码的&lt;strong&gt;安全性&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在现在的分布式系统中，特别是以微服务为代表的分布式服务技术，序列化是其中的关键技术点之一。&lt;/p&gt;
&lt;p&gt;在深入理解序列化之前，我们先来准确描述下它的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列化是将数据结构或对象转换为可存储（如在文件或内存缓冲区）或传输（如通过网络）的格式并稍后重建（可能在不同的计算机中）的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据结构和对象这个不用解释，但可存储或传输的格式最常见的自然是字节了，除此之外还有基于字符串的JSON。&lt;br/&gt;比如，有这么一个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Person {
    String name=&quot;Jim&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以用JSON表示为&lt;code&gt;{ name:&quot;Jim&quot;}&lt;/code&gt;。因此，一些JSON框架，比如Java中的FastJson，也可以归类到序列化框架之中。至于重建的过程便是反序列化了。&lt;/p&gt;
&lt;p&gt;我们对比下编码的概念：编码是信息在不同形式下的表示和转换的过程。在这里，数据结构、对象、字节、json是不是信息的表示方式？反序列化是不是对应解码？序列化的过程是不是一个编码过程？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9yEWALd06AABV1CzuN84843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理解这一点，我们就可以回答出，&lt;strong&gt;序列化的本质是编码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然这样，我们就可以从编码的角度来分析序列化了。前面的文章，我们从字符集中谈到编码的兼容性，从压缩中谈到编码的效率，从加密中谈到编码的安全性，那边这里我们就从这三个方面谈谈序列化。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（一） 序列化的兼容性&lt;/h2&gt;
&lt;p&gt;序列化的兼容性有这么三个方面。&lt;/p&gt;
&lt;h3 id=&quot;h3-1-&quot;&gt;1. 语言及平台的兼容性&lt;/h3&gt;
&lt;p&gt;开发语言有JAVA，C++等等很多种，如果涉及到多语言应用之间的交互，那么序列化框架必须有多种语言的实现版本。当然，如果一个公司的内部应用全是用同一语言开发的，自然就无需引入这种兼容性。&lt;/p&gt;
&lt;p&gt;平台方面，比如浏览器和服务器这两个平台，常见JSON格式就能很好的兼容二者，所以我们往往提供基于JSON的API。&lt;/p&gt;
&lt;h3 id=&quot;h3-2-&quot;&gt;2. 复杂对象兼容性&lt;/h3&gt;
&lt;p&gt;以JAVA为例，JAVA的复杂对象场景包括&lt;strong&gt;继承、组合、泛型、循环依赖&lt;/strong&gt;等等。&lt;/p&gt;
&lt;p&gt;以循环依赖为例，循环依赖是指两个以上对象相互引用，如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class A {
    B b;
}
class B {
    A a;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦它们相互引用，一些序列化框架在序列化时，序列化A发现里面包含B，然后又序列化B，发现B又包含A，又序列化A…，这样就出现死循环了。&lt;/p&gt;
&lt;p&gt;通常在一些JSON序列化框架中会遇到这种问题，JSON格式本身也难以体现循环依赖关系。&lt;/p&gt;
&lt;p&gt;现实场景往往更复杂，我们就遇到过一个接口包含数百个对象，上千字段，各种继承、泛型，在测试时，四五种序列化框架，仅一种能应对这种复杂场景。&lt;/p&gt;
&lt;p&gt;着重提一句，兼容性是一个序列化框架最重要的指标，没有之一，必要的时候我们可以牺牲效率，但序列化本身不能出错，特别是核心流程上，因为序列化一旦出错，整个业务逻辑就直接崩溃了。&lt;/p&gt;
&lt;h3 id=&quot;h3-3-&quot;&gt;3. 数据结构不一致的兼容性&lt;/h3&gt;
&lt;p&gt;序列化的场景通常是用于不同服务器间的数据传输，在JAVA中，我们会通过jar的方式，让client和server引入同一个类。&lt;/p&gt;
&lt;p&gt;如果有一天因为业务需要，要在某个类中增减字段，但我们无法做到client和server同时升级，这样，client和server的序列化结构就不一致了，一些依赖字段顺序的序列化框架这时就往往会出现问题，所以，能够兼容这种不一致场景也是评估一个序列化框架&lt;br/&gt;的指标之一。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（二）序列化的效率&lt;/h2&gt;
&lt;p&gt;我们谈效率无非就是时间和空间。&lt;/p&gt;
&lt;p&gt;序列化的时间效率自然就是序列化与反序列化的耗时，在不考虑硬件的场景下，通常取决于语言效率，数据量等等。比如在JAVA，基于反射的方法调用和普通调用是有性能差异的，而序列化往往基于反射操作，因此对这一块进行优化就能提升一定的效率。&lt;/p&gt;
&lt;p&gt;空间效率通常就是压缩了，比如一个boolean值True，将它序列化成&lt;code&gt;True&lt;/code&gt;,和序列化成&lt;code&gt;T&lt;/code&gt;，两者之间长度是不一样的，很多序列化框架就是通过这种自定义的压缩字典来处理数据。&lt;/p&gt;
&lt;h2 id=&quot;h2--&quot;&gt;（三） 序列化的安全性&lt;/h2&gt;
&lt;p&gt;序列化通常是用于传输场景，传输的安全性在内网下基本是无需考虑的，对于提供出去的外网服务，比如与客户端APP的通信，其安全性往往是基于传输协议本身来实现的，比如基于HTTPS来传输。&lt;/p&gt;
&lt;p&gt;另一个安全风险来自于注入攻击，注入攻击往往是因为本应用来查询或保存的字符串被当成命令代码执行了。特别是基于JSON的序列化框架，由于JSON本身是基于字符串的，如果里面的字符串被当作代码执行了，就会产生比较严重的后果。&lt;/p&gt;

&lt;p&gt;我们从了解编码是信息的转换过程开始，从兼容性、效率及安全性三个方面分析了编码的原理。然后，谈到了分布式系统中的序列化，而序列化的本质是编码，因此，也从同样的三个方面分析了序列化。&lt;/p&gt;
&lt;p&gt;那么，我们可以进一步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.如果给你某种压缩或加密机制，你会如何分析?&lt;/li&gt;
&lt;li&gt;2.如果让你制定一种新的编码机制，你会考虑哪些问题？&lt;/li&gt;
&lt;li&gt;3.如果给你统一场景下的多种编码机制，你会如何比较和选择？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再进一步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.对于解决同一问题的多个框架，你会如何比较？&lt;/li&gt;
&lt;li&gt;2.对于任意一个程序，你会如何分析？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还再进一步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.对于在生活中遇到的任何一个事物，比如一个饮水杯，你会如何分析和评价它的价值？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;兼容性：这个杯子是否耐冷，耐热，抗摔。&lt;/li&gt;
&lt;li&gt;效率：这个杯子相比其他产品能带来哪方面的效率提示提升？&lt;/li&gt;
&lt;li&gt;安全性：这个杯子材料是否有毒害物质，有没有异味？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回答完这些问题，感觉像是造了一把锤子,然后所有的东西当钉子,但这并不是我的初衷，回到本书的序中写到的，&lt;strong&gt;这本书真正要写的是我对第一性原理，结构化思维，系统思维这些的思维方式的应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然讲了底层的逻辑思维了，其实本文最底层的逻辑是用到了逻辑思维的两种方式-&lt;strong&gt;归纳和演绎&lt;/strong&gt;。我们从字符，压缩，加密的编码中归纳出了一套分析编码的结构，然后演绎出序列化的第一性原理是编码，用编码的结构去分析了序列化，框架，甚至现实生活中的产品，最后完成了这一篇系统化的文章。&lt;/p&gt;
&lt;p&gt;附本文的导图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.wchukai.com/group1/M00/00/02/cHx_F1o9y3KADWelAAFrvQQ5QkI572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是编码的相关内容，我们会在后面的协议，服务化框架等文章里面将本章内容关联起来，进一步完善整个编码的知识体系。&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&quot;https://wchukai.com/&quot;&gt;初开&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发表于：&lt;a href=&quot;http://www.cnblogs.com/wchukai&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文基于 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh&quot;&gt;知识共享-署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt;许可协议发布，转载必须保留署名及链接。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 05:15:00 +0000</pubDate>
<dc:creator>初开</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wchukai/p/8093205.html</dc:identifier>
</item>
<item>
<title>记一次高并发场景下.net监控程序数据上报的性能调优 - 凌晨三点半</title>
<link>http://www.cnblogs.com/vveiliang/p/8093164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vveiliang/p/8093164.html</guid>
<description>&lt;p&gt;    最近在和小伙伴们做充电与通信程序的架构迁移。迁移前的架构是，通信程序负责接收来自充电集控设备的数据实时数据，通过Thrift调用后端的充电服务，充电服务收到响应后放到进程的Queue中，然后在管理线程的调度下，启动多线程进程数据处理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124716084-1329415224.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124716787-773114848.png&quot; alt=&quot;Image&quot; width=&quot;510&quot; height=&quot;227&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    随着业务规模的不断扩大和对系统可用性的逐步提高。现在这个架构存在很多的问题，比如：&lt;/p&gt;
&lt;p&gt;1.充电服务重启，可能会丢数据。&lt;/p&gt;
&lt;p&gt;2.充电服务重启会波及影响通信服务。&lt;/p&gt;
&lt;p&gt;3.充电服务与通信服务面对的需求和变化是不一样，强依赖的架构带来很多的问题。&lt;/p&gt;
&lt;p&gt;    为了解决上述的这些问题，项目组决定借助Kafka对程序进行改造 。总体思路是，通信服务收到数据后，把数据存储到kafka，然后通过一个异步任务处理框架实时消费Kafka数据，并调用业务插件处理。&lt;/p&gt;
&lt;p&gt;    通过上面思路我们可以看到，系统整体架构仅是引入了一个MQ中间件，业务逻辑并没有发生本质的变化。但是在实际的压测中，却发现新架构下的程序性能比原来要慢很多。顺便说一下，压测场景是模拟10万充电终端离网上下线，短时间内会生成大约32万的消息量，遥信：10万，遥测：10万，电量10万，其他：2万。&lt;/p&gt;
&lt;p&gt;    通过ANTS分析相关进程，发现MonitorDataUploader.AddToLocalCache方法占用了78%左右的CPU。此方法不是业务方法，是为了监控程序的运行情况而加入的埋点监控。通过进一步分析看，在30多万消息量下，会产生约1000万甚至更高的监控消息。在如此高的并发下，这部分程序存在很严重的性能问题，导致系统的资源占用很高，系统运行变慢。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124717834-1860932491.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124718834-16922608.png&quot; alt=&quot;Image&quot; width=&quot;572&quot; height=&quot;255&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    OK。既然问题已经清楚，那就开始优化吧。虽然可以把监控埋点屏蔽，临时解决程序的性能问题。但是，这对一个互联网应用来说是要不得的。没有监控，系统的运行健康状况就一无所知，这对一个SLA要求99.95%的系统来说，是不现实的。所以，必须全力优化监控程序在上报海量监控日志上的性能问题。&lt;/p&gt;
&lt;p&gt;    为了便于验证问题，写了一个模拟程序.通过模拟程序，很容易的再现了CPU占用很高的情况。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124719834-1817327265.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124720803-1385184119.png&quot; alt=&quot;Image&quot; width=&quot;549&quot; height=&quot;288&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124721678-1252924737.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124722365-714153415.png&quot; alt=&quot;Image&quot; width=&quot;403&quot; height=&quot;297&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    代码实现中，监控消息的存储是通过BlockingCollection存储的，并且设置了Collection大小为1000万。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;var cache = new BlockingCollection&amp;lt;MonitorData&amp;gt;(boundedCapacity);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124722943-303137710.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124723584-228044296.png&quot; alt=&quot;Image&quot; width=&quot;566&quot; height=&quot;273&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    通过阅读BlockingCollection 的说明，可以看到空构造函数可以不设置Collection的上限。看到这个解释，怀疑是限制了上线的Collection存在性能问题。与是把代码中对BlockingCollection 的构造改成空构造，再次测试。测试结果大出意料，性能表现有了非常好的提升。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124724350-1886324772.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124725240-1787664380.png&quot; alt=&quot;Image&quot; width=&quot;412&quot; height=&quot;279&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    为了进一步验证问题，把对BlockingCollection 的构造改了限制大小，并设置上线为1个亿。测试时消息总量为5000万，验证一下是否是BlockingCollection 达到上限后，引起的严重性能问题。通过测试数据看，CPU消耗与不限制时基本一致。通过此可以确定，BlockingCollection 在设置了容量上限后，如果消息超过容量，性能将会非常差。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124725725-726874421.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124726334-524900011.png&quot; alt=&quot;Image&quot; width=&quot;423&quot; height=&quot;311&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    通过上面的调优，在发送5000万监控消息的情况下，程序的CPU在60% 左右持续30s左右。虽然性能有所改善，但是还不是很尽如人意。 有没有更好的解决方案呢?通过不算的思考和尝试，终于找到了一个更好的解决方案：基于双缓存+线程级多桶式Collection。此种模式下性能表现如下，CPU平均在30%左右，持续时间在15s左右。性能又有近一倍的提升。具体实现方案下次再分享。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124726896-2043529378.png&quot;&gt;&lt;img title=&quot;Image&quot; src=&quot;http://images2017.cnblogs.com/blog/850196/201712/850196-20171223124727615-1214309484.png&quot; alt=&quot;Image&quot; width=&quot;429&quot; height=&quot;310&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Dec 2017 04:48:00 +0000</pubDate>
<dc:creator>凌晨三点半</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vveiliang/p/8093164.html</dc:identifier>
</item>
<item>
<title>python爬虫:使用Selenium模拟浏览器行为 - 十月狐狸</title>
<link>http://www.cnblogs.com/sesshoumaru/p/python-selenium-webdriver.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sesshoumaru/p/python-selenium-webdriver.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前几天有位微信读者问我一个爬虫的问题，就是在爬去百度贴吧首页的热门动态下面的图片的时候，爬取的图片总是爬取不完整，比首页看到的少。原因他也大概分析了下，就是后面的图片是动态加载的。他的问题就是这部分动态加载的图片该怎么爬取到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;他的代码比较简单，主要有以下的步骤：使用&lt;code&gt;BeautifulSoup&lt;/code&gt;库，打开百度贴吧的首页地址，再解析得到&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;new_list&lt;/code&gt;标签底下的&lt;code&gt;img&lt;/code&gt;标签，最后将&lt;code&gt;img&lt;/code&gt;标签的图片保存下来。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;headers &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
    &lt;span class=&quot;st&quot;&gt;'User-Agent'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36'&lt;/span&gt;
}

data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;requests.get(&lt;span class=&quot;st&quot;&gt;&quot;https://tieba.baidu.com/index.html&quot;&lt;/span&gt;,headers&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;headers)
html&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;BeautifulSoup(data.text,&lt;span class=&quot;st&quot;&gt;'lxml'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面提到过，有部分图片是动态加载的，那么首先我们得弄清楚，这部分图片是怎么动态加载的。在浏览器中打开百度贴吧的首页，可以明显的看到，在往下滚动滚动条的时候，当滚动到底部的时候，滚动条缩短了，并向上移动了一段距离。这个现象也正是有&lt;code&gt;DOM&lt;/code&gt;元素动态的添加到了&lt;code&gt;html&lt;/code&gt;文档的一个表现。动态加载数据无非就是&lt;code&gt;ajax&lt;/code&gt;请求，而&lt;code&gt;ajax&lt;/code&gt;本质上就是&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求(简称&lt;code&gt;xhr&lt;/code&gt;)。在谷歌浏览器中，我们可以通过开发者工具的&lt;code&gt;network&lt;/code&gt;面板来监测xhr请求。&lt;/p&gt;
&lt;p&gt;刚打开首页时的&lt;code&gt;xhr&lt;/code&gt;请求，这里的请求都和要爬取的图片无关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/232931/201712/232931-20171223094247287-1378486325.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;滚动条向下第1次滚动到底部，这里请求的是第&lt;code&gt;20-40&lt;/code&gt;条热门动态，包含要爬取图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/232931/201712/232931-20171223094308084-1806709166.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;滚动条向下第2次滚动到底部，这里请求的是第&lt;code&gt;40-60&lt;/code&gt;条热门动态，包含要爬取图片。并且返回的的&lt;code&gt;has_more:false&lt;/code&gt;表明没有跟多数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/232931/201712/232931-20171223094323928-1513051025.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;滚动条向下第3次滚动到底部，再无&lt;code&gt;xhr&lt;/code&gt;请求。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;根据上面的分析，我们已经明白，单纯使用&lt;code&gt;BeautifulSoup&lt;/code&gt;进行爬虫的时候，只能爬取到&lt;code&gt;1-20&lt;/code&gt;条热门动态里面的图片。为了爬取到完整的热门动态里面的图片，我们则需要模拟浏览器的滚动条滚动，让网页去触发&lt;code&gt;xhr&lt;/code&gt;请求更多的热门动态。&lt;/p&gt;
&lt;p&gt;在python中，如果需要模拟浏览器的行为，可以使用&lt;code&gt;selenium&lt;/code&gt;库。&lt;code&gt;selenium&lt;/code&gt;库是一个自动化测试框架，可以用来模拟测试浏览器的各种行为，这里我们使用它来模拟浏览器打开百度贴吧的首页，并模拟滚动条向下滚动到底部的操作。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip install selenium&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;下载浏览器驱动&quot;&gt;下载浏览器驱动&lt;/h3&gt;
&lt;p&gt;对照自己电脑安装的浏览器和对应的版本，分别从上面的地址下载驱动文件，也可以从我的github项目中统一下载以上几个驱动(地址:&lt;a href=&quot;https://github.com/Sesshoumaru/attachments/tree/master/Selenium%20WebDriver&quot;&gt;https://github.com/Sesshoumaru/attachments/tree/master/Selenium%20WebDriver&lt;/a&gt;)。下载解压后，将所在的目录添加系统的环境变量中。当然你也可以将下载下来的驱动放到python安装目录的&lt;code&gt;lib&lt;/code&gt;目录中，因为它本身已经存在于环境变量（我就是这么干的）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/232931/201712/232931-20171223094335678-997614803.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用python代码模拟浏览器行为&quot;&gt;使用python代码模拟浏览器行为&lt;/h3&gt;
&lt;p&gt;要使用&lt;code&gt;selenium&lt;/code&gt;先需要定义一个具体&lt;code&gt;browser&lt;/code&gt;对象，这里就定义的时候就看你电脑安装的具体浏览器和安装的哪个浏览器的驱动。这里以火狐浏览器为例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; webdriver
browser &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; webdriver.Firefox()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再模拟打开贴吧首页：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;browser.get(&lt;span class=&quot;st&quot;&gt;&quot;https://tieba.baidu.com/index.html&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再模拟滚动条滚动到底部&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;):
    browser.execute_script(&lt;span class=&quot;st&quot;&gt;'window.scrollTo(0, document.body.scrollHeight)'&lt;/span&gt;)
    time.sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后再使用&lt;code&gt;BeautifulSoup&lt;/code&gt;，解析图片标签：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;html &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BeautifulSoup(browser.page_source, &lt;span class=&quot;st&quot;&gt;&quot;lxml&quot;&lt;/span&gt;)
imgs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; html.select(&lt;span class=&quot;st&quot;&gt;&quot;#new_list li img&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;几个注意点&quot;&gt;几个注意点&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;必须安装浏览器和浏览器驱动，并且浏览器和浏览器驱动要配到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;即如果使用谷歌浏览器模拟网页行为，则需要下载谷歌浏览器驱动；
如果使用火狐浏览器模拟网页行为，则需要下载火狐浏览器驱动&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器驱动所在的目录要在环境变量中，或者定义浏览器&lt;code&gt;browser&lt;/code&gt;的时候指定驱动的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;selenium更多用法&quot;&gt;selenium更多用法&lt;/h2&gt;
&lt;h3 id=&quot;查找元素&quot;&gt;查找元素&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; webdriver

browser &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; webdriver.Firefox()
browser.get(&lt;span class=&quot;st&quot;&gt;&quot;https://tieba.baidu.com/index.html&quot;&lt;/span&gt;)

new_list &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element_by_id(&lt;span class=&quot;st&quot;&gt;'new_list'&lt;/span&gt;)
user_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element_by_name (&lt;span class=&quot;st&quot;&gt;'user_name'&lt;/span&gt;)
active &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element_by_class_name  (&lt;span class=&quot;st&quot;&gt;'active'&lt;/span&gt;)
p &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element_by_tag_name (&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# find_element_by_name 通过name查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_element_by_xpath 通过xpath查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_element_by_link_text 通过链接查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_element_by_partial_link_text 通过部分链接查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_element_by_tag_name 通过标签名称查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_element_by_class_name 通过类名查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_element_by_css_selector 通过css选择武器查找单个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_name 通过name查找多个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_xpath 通过xpath查找多个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_link_text 通过链接查找多个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_partial_link_text 通过部分链接查找多个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_tag_name 通过标签名称查找多个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_class_name 通过类名查找多个元素&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# find_elements_by_css_selector 通过css选择武器查找多个元素&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;获取元素信息&quot;&gt;获取元素信息&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;btn_more &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element_by_id(&lt;span class=&quot;st&quot;&gt;'btn_more'&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(btn_more.get_attribute(&lt;span class=&quot;st&quot;&gt;'class'&lt;/span&gt;)) &lt;span class=&quot;co&quot;&gt;# 获取属性&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(btn_more.get_attribute(&lt;span class=&quot;st&quot;&gt;'href'&lt;/span&gt;)) &lt;span class=&quot;co&quot;&gt;# 获取属性&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(btn_more.text) &lt;span class=&quot;co&quot;&gt;# 获取文本值&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;元素交互操作&quot;&gt;元素交互操作&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;btn_more &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element_by_id(&lt;span class=&quot;st&quot;&gt;'btn_more'&lt;/span&gt;)
btn_more.click() &lt;span class=&quot;co&quot;&gt;# 模拟点击,可以模拟点击加载更多&lt;/span&gt;

input_search &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; browser.find_element(By.ID,&lt;span class=&quot;st&quot;&gt;'q'&lt;/span&gt;)
input_search.clear() &lt;span class=&quot;co&quot;&gt;# 清空输入&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;执行javascript&quot;&gt;执行JavaScript&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 执行JavaScript脚本&lt;/span&gt;
browser.execute_script(&lt;span class=&quot;st&quot;&gt;'window.scrollTo(0, document.body.scrollHeight)'&lt;/span&gt;)
browser.execute_script(&lt;span class=&quot;st&quot;&gt;'alert(&quot;To Bottom&quot;)'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 23 Dec 2017 01:48:00 +0000</pubDate>
<dc:creator>十月狐狸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sesshoumaru/p/python-selenium-webdriver.html</dc:identifier>
</item>
<item>
<title>帅案之上——作为开发者的远见与卓识 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8088163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8088163.html</guid>
<description>&lt;p&gt;一周以来有关“欧建新”的话题在网络上不断发酵，愈演愈烈。有的人说是不惑之年的彷徨，也有人认为是国内IT从业人员的悲凉。今日又有传言南京途牛旅游突然裁员，遭到裁员的人员主要是各部门的开发人员。看来，真正的严冬才刚刚开始。如何度过一个又一个寒冬并生存下来，我们聊聊。&lt;/p&gt;
&lt;p&gt;一、未来五年的机会在哪里&lt;/p&gt;
&lt;p&gt;中国的“速度”举世瞩目，到底如何辉煌不需要我在这里吹嘘。但是就我切身体会而言，与其用“中国速度”不如用“中国波动”来形容国内经济变化的波诡云谲来的更加贴切。观察自80年代改革开放以来，国内经济每逢重大变革无一不是伴随着一批人的青云直上和另一批人的黯然离场。时至今日，这种波动也愈发剧烈。如果以前我们还可以用下一个十年来总结未来中国经济发展走向的话，如今只能用未来五年甚至三年来作为判断的跨度。毫无疑问，时代的宠儿——“互联网”已经在所谓“互联网+”的本轮浪潮中走进了它的巅峰时刻。&lt;/p&gt;
&lt;p&gt;水满自溢，月满而亏。无论是哪种形式的“互联网”经济都很难延续曾经的辉煌。下一轮IT业的浪潮或许将体现在人工智能和工业4.0等领域。这里我有意避免提及当下势头正劲的“机器学习”，因为“机器学习”类似自然科学中的基础理论，它的价值必须要同生产力相结合才能得以体现。就目前来看最大的可能就是工业4.0概念——也正是中国要从制造业大国转型为制造业强国的关键。&lt;/p&gt;
&lt;p&gt;根据以上的宏观判断，我个人的想法是以C/C++为代表的底层开发语言或以Python为代表的时尚新贵将异军突起。&lt;/p&gt;
&lt;p&gt;二、学会下蹲与起跳&lt;/p&gt;
&lt;p&gt;人生也好，事业也罢。就如同行走在路上的旅人，脚下的路并非只是康庄大道，绝美与壮丽伴随艰辛与崎岖。以前总是听到说三十岁以后就不适合继续从事开发，后来又说四十岁就必须转行做管理。我想，以上论点的正确与否暂且不论，作为一个独立的个体首先应该具备独立思考的能力。如果希望自己能在开发者的道路上不断前进，应该明白如何下蹲以及何时起跳。&lt;/p&gt;
&lt;p&gt;在大部分的开发任务中，客户总是希望你能够快速的完成任务，快速的解决故障，快速的修改需求。在此我们不谈具体的开发手段——例如迭代开发或敏捷开发——从自身出发如何有效分析需求，对于开发中暂时无法确定的方案如何预留出空间亦或通过合理的结构降低模块耦合。都是我们需要通过不断练习才能获得的技能。&lt;/p&gt;
&lt;p&gt;此外，我们还应该善于利用时间：阅读开源框架或深入系统的学习某些方面的知识并至少应该掌握2至3种主流开发语言。因为只有当你的自身储备足够丰富的时候，身边的“机会”才能如同水中的石头逐渐显露出来。&lt;/p&gt;
&lt;p&gt;掌握节奏，为下一次起跳做足功课。诚然“下蹲”不是我们的目的，但是要想“跳”的更高你必须有所准备，否则再多的尝试也不过是原地蹦跶。&lt;/p&gt;
&lt;p&gt;三、静水流深&lt;/p&gt;
&lt;p&gt;你为什么要做一个开发者？如果你觉得这个问题不好回答让我换个问法：是什么吸引你来到这个行业？&lt;/p&gt;
&lt;p&gt;先谈谈我对这个问题的理解。之所以是理解而不说是答案主要是因为我自己能给出的回答都不止一个。但是如果今天只能留下一种回答的话，我想应该是：开发工作能够给予我的心流体验是其它所不能比拟的。也正是如此，我才会在本已而立的年龄毅然转行并通过学习一步步实现着核心竞争力的锻造。&lt;/p&gt;
&lt;p&gt;我们行走在各自的人生轨道上，大部分人都或多或少有着自己的目标与追求。人人都向往成功，但现实是——我们之中或许只有极少数的人能真正做到成功，甚至恐怕有些人一出生就注定只能平凡度日。我们会经历苦痛，也会品尝到挫折，如果这些都未曾将你击倒请不要迷失在眼前的繁华中。&lt;/p&gt;

&lt;p&gt;后记：今天是12月22日——冬至。回家后同父母下楼烧了些纸钱。望着眼前的四丛火焰摇曳着，眼角突然就湿润了。泛着红光的纸屑被风吹到很远的地方，似乎也从我的心中抽走了些东西，是什么呢...&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 16:34:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8088163.html</dc:identifier>
</item>
<item>
<title>读研以来的一些感想：名校好在哪里？ - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8088158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8088158.html</guid>
<description>&lt;p&gt;读研半年以来，逐渐了解了学校对学生的培养是怎么样的，同时我把现在的学校做的一些举措跟我本科的学校做了下对比，顿时感慨良多：名校与普通学校的对学生的培养真的非常不一样。我本科是普通一本，研究生读的是一所很不错的985。读研以来，身边发生的一些事，见过的一些人，都让我深深地感受到，名校与普通学校对学生的培养，是全方位的不一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.对学生的要求不一样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举两个身边的两件事说明一下。第一件事是图书馆借书还书的规定，我本科学校对于逾期还书的同学的处理是交钱，一天好像2毛，这也是全国众多图书馆对于逾期还书读者的一些惩罚手段。而现在的学校，对于处理逾期还书的读者的做法就是，做题！逾期30天的，做50题，逾期60天的，做100题，反正就是逾期越久做题越多。还有逾期多次的，直接取消借书资格。我对于这种处理是相当服气的，有一次我逾期了，我以为也只是交几块钱就算完事了。但却被告知要做50题，不做完没法继续借书，而且要达到一定准确率，当然啦，做的题都是一些图书馆的管理规定题，就是让你好好记住以后别忘记还书了。我硬生生地做了半个小时，非常痛苦，也下定决心以后不再逾期还书了。&lt;/p&gt;
&lt;p&gt;第二件事是现在的学校采取了一个很有意思的规定，就是每个学生都要修够一定的公益时才能毕业。什么是公益时？就是去参加一些自愿活动和公益活动，然后就会获得相应的公益时，换言之，每个学生要在他的学习之余抽出时间做一下对他人对社会有贡献事情，比如帮人家修修电脑啊，当一下一些活动的工作人员啊，去看望老奶奶啊等等。这个规定我觉得是真的棒，在大学里学习，学的不仅是知识，还有要学正确的价值观，懂得怎么回报社会，感激他人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.学习氛围一级棒&lt;/strong&gt;&lt;br/&gt;也举两件事来说明一下。&lt;/p&gt;
&lt;p&gt;第一件事就是实验室氛围。我们实验室的同学还是很努力的，每天都会搞到很晚，没有人打游戏没有人看电影偷懒，感觉都很自觉。不知道其他实验室氛围如何，反正我对我的实验室氛围很满意，跟一群勤奋的家伙一起学习工作，想要不落后他们，最好的办法就跟紧他们的脚步！&lt;/p&gt;
&lt;p&gt;第二件事就是学生的积极性。尤其是本科生，对于实践和学习非常热衷。很多大二大三的学生都已经加入实验室做一些研究了，这让我一个研一师兄脸红不已。我想想我大二大三在干嘛？LOL啊！差距差距。。。上段时间我的项目需要招募一些本科生做一些开发，就随意发了个消息到大三级群来招募队员，当时也没说有什么福利。没想到的是，还是有很多学生第一时间联系我了，要求加入项目组。我就纳闷了，你们怎么这么积极参加这些东西？他们说想积累一些项目经验，为以后找工作多做准备。他们平时课程很多，但是总能挤出时间完成我分配给他们的任务，他们还有时间搞搞自己的APP，打打比赛，这种积极性我确实佩服。那我本科学校没有这种同学吗？肯定有，但是非常少，而这边却是一大堆学生都这么优秀，真的厉害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.有钱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;名校就是有钱，而且就是比你普通学校有钱得多！服务器就买最贵的，我们所就有3台18W 的TITAN X*8的服务器，跑深度学习爽的飞起。重要的是，我们用的人并不多，不需要抢来抢去，人均3个TITAN X GPU吧，想想都开心。当然，老师也经常向我们强调，这些资源都是他们很努力才争取回来的，让我们好好搞尽快出成果。哈哈，当然，有好的设备，学习和研究都会顺利很多。除了设备方面，生活方面都显得比较土豪，什么发月饼啊发汤圆啊发饺子啊，虽然都不是值钱的东西，但是发了总会让学生开心一阵子。这些我本科学校都没见到（手动微笑）。&lt;/p&gt;
&lt;p&gt;还有就是讲座，学院经常请到一些很牛的人过来做演讲，比如什么院士啊，CEO啊，微软经理啊等等，一开始还是很有兴趣经常去听，但是讲座确实太多，到后来我都懒得去了，只挑最感兴趣的讲座去听一下。然后回想一下，我本科四年居然没听过讲座哈哈！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.一些我认为差别不大的地方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读研之前，我以为名校老师讲课都很认真，很厉害，很想在课堂中一睹大咖们的风采。其实啊，名校老师的学术背景会比较强，但是讲课好不好或者认不认真讲就一回事了。反正我觉得能把课讲好的老师并不多，这还是有点失望的。当然啦，他们对考核会更严格一些，也许跟现在上的是研究生课程有关？&lt;/p&gt;
&lt;p&gt;这些都是我读研以来对学校教育的一些感想，总体感觉就是，好的平台给你了，起不起飞就看自己了。不能起飞，就给自己响亮的两个耳光吧！共勉！&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 16:31:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8088158.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——2. 当构造方法参数过多时使用builder模式 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8087978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8087978.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。请考虑一个代表包装食品上的营养成分标签的例子。这些标签有几个必需的属性——每次建议的摄入量，每罐的份量和每份卡路里 ，以及超过20个可选的属性——总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品都有非零值，只有少数几个可选属性。&lt;/p&gt;
&lt;p&gt;应该为这样的类编写什么样的构造方法或静态工厂？传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式，在这种模式中，只提供了一个只所需参数的构造函数，另一个只有一个可选参数，第三个有两个可选参数，等等，最终在构造函数中包含所有可选参数。这就是它在实践中的样子。为了简便起见，只显示了四个可选属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Telescoping constructor pattern - does not scale well!

public class NutritionFacts {
    private final int servingSize;  // (mL)            required
    private final int servings;     // (per container) required
    private final int calories;     // (per serving)   optional
    private final int fat;          // (g/serving)     optional
    private final int sodium;       // (mg/serving)    optional
    private final int carbohydrate; // (g/serving)     optional

    public NutritionFacts(int servingSize, int servings) {
        this(servingSize, servings, 0);
    }

    public NutritionFacts(int servingSize, int servings,
            int calories) {
        this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings,
            int calories, int fat) {
        this(servingSize, servings, calories, fat, 0);
    }

    public NutritionFacts(int servingSize, int servings,
            int calories, int fat, int sodium) {
        this(servingSize, servings, calories, fat, sodium, 0);
    }

    public NutritionFacts(int servingSize, int servings,
           int calories, int fat, int sodium, int carbohydrate) {
        this.servingSize  = servingSize;
        this.servings     = servings;
        this.calories     = calories;
        this.fat          = fat;
        this.sodium       = sodium;
        this.carbohydrate = carbohydrate;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为&lt;code&gt;fat&lt;/code&gt;属性传递了0值。 『只有』六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它会很快失控。&lt;/p&gt;
&lt;p&gt;简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。读者不知道这些值是什么意思，并且必须仔细地计算参数才能找到答案。一长串相同类型的参数可能会导致一些细微的bug。如果客户端意外地反转了两个这样的参数，编译器并不会抱怨，但是程序在运行时会出现错误行为(条目51)。&lt;/p&gt;
&lt;p&gt;当在构造方法中遇到许多可选参数时，另一种选择是JavaBeans模式，在这种模式中，调用一个无参数的构造函数来创建对象，然后调用setter方法来设置每个必需的参数和可选参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// JavaBeans Pattern - allows inconsistency, mandates mutability

public class NutritionFacts {
    // Parameters initialized to default values (if any)
    private int servingSize  = -1; // Required; no default value
    private int servings     = -1; // Required; no default value
    private int calories     = 0;
    private int fat          = 0;
    private int sodium       = 0;
    private int carbohydrate = 0;

    public NutritionFacts() { }

    // Setters
    public void setServingSize(int val)  { servingSize = val; }
    public void setServings(int val)    { servings = val; }
    public void setCalories(int val)    { calories = val; }
    public void setFat(int val)         { fat = val; }
    public void setSodium(int val)      { sodium = val; }
    public void setCarbohydrate(int val) { carbohydrate = val; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setServingSize(240);
cocaCola.setServings(8);
cocaCola.setCalories(100);
cocaCola.setSodium(35);
cocaCola.setCarbohydrate(27);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不幸的是，JavaBeans模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中JavaBean可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含bug的代码大相径庭的错误，因此很难调试。一个相关的缺点是，JavaBeans模式排除了让类不可变的可能性(条目17)，并且需要在程序员的部分增加工作以确保线程安全。&lt;/p&gt;
&lt;p&gt;当它的构造完成时，手动“冻结”对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员在使用对象之前调用&lt;code&gt;freeze&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和javabean模式的可读性。 它是Builder模式[Gamma95]的一种形式。客户端不直接调用所需的对象，而是调用构造方法(或静态工厂)，并使用所有必需的参数，并获得一个builder对象。然后，客户端调用builder对象的&lt;code&gt;setter&lt;/code&gt;相似方法来设置每个可选参数。最后，客户端调用一个无参的&lt;code&gt;build&lt;/code&gt;方法来生成对象，该对象通常是不可变的。Builder通常是它所构建的类的一个静态成员类(条目24)。以下是它在实践中的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Builder Pattern

public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;

        // Optional parameters - initialized to default values
        private int calories      = 0;
        private int fat           = 0;
        private int sodium        = 0;
        private int carbohydrate  = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings    = servings;
        }

        public Builder calories(int val) { 
            calories = val;      
            return this;
        }

        public Builder fat(int val) { 
           fat = val;           
           return this;
        }

        public Builder sodium(int val) { 
           sodium = val;        
           return this; 
        }

        public Builder carbohydrate(int val) { 
           carbohydrate = val;  
           return this; 
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize  = builder.servingSize;
        servings     = builder.servings;
        calories     = builder.calories;
        fat          = builder.fat;
        sodium       = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NutritionFacts&lt;/code&gt;类是不可变的，所有的参数默认值都在一个地方。builder的setter方法返回builder本身，这样调用就可以被链接起来，从而生成一个流畅的API。下面是客户端代码的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
    .calories(100).sodium(35).carbohydrate(27).build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个客户端代码很容易编写，更重要的是易于阅读。 Builder模式模拟Python和Scala中的命名可选参数。&lt;/p&gt;
&lt;p&gt;为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查builder的构造方法和方法中的参数有效性。 在&lt;code&gt;build&lt;/code&gt;方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从builder复制参数后对对象属性进行检查（条目 50）。 如果检查失败，则抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常（条目 72），其详细消息指示哪些参数无效（条目 75）。&lt;/p&gt;
&lt;p&gt;Builder模式非常适合类层次结构。 使用平行层次的builder，每个嵌套在相应的类中。 抽象类有抽象的builder; 具体的类有具体的builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Builder pattern for class hierarchies

import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;

public abstract class Pizza {
    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}
    final Set&amp;lt;Topping&amp;gt; toppings;
    
    abstract static class Builder&amp;lt;T extends Builder&amp;lt;T&amp;gt;&amp;gt; {
        EnumSet&amp;lt;Topping&amp;gt; toppings = EnumSet.noneOf(Topping.class);

        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }
        
        abstract Pizza build();
        
        // Subclasses must override this method to return &quot;this&quot;
        protected abstract T self();
    }

    Pizza(Builder&amp;lt;?&amp;gt; builder) {
        toppings = builder.toppings.clone(); // See Item 50
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，&lt;code&gt;Pizza.Builder&lt;/code&gt;是一个带有递归类型参数（ recursive type parameter）（条目 30）的泛型类型。 这与抽象的&lt;code&gt;self&lt;/code&gt;方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）的习惯用法。&lt;/p&gt;
&lt;p&gt;这里有两个具体的&lt;code&gt;Pizza&lt;/code&gt;的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Objects;

public class NyPizza extends Pizza {
    public enum Size { SMALL, MEDIUM, LARGE }
    private final Size size;

    public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; {
        private final Size size;

        public Builder(Size size) {
            this.size = Objects.requireNonNull(size);
        }

        @Override public NyPizza build() {
            return new NyPizza(this);
        }

        @Override protected Builder self() {
            return this;
        }
    }

    private NyPizza(Builder builder) {
        super(builder);
        size = builder.size;
    }
}

public class Calzone extends Pizza {
    private final boolean sauceInside;
    
    public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; {
        private boolean sauceInside = false; // Default

        public Builder sauceInside() {
            sauceInside = true;
            return this;
        }
        
        @Override public Calzone build() {
            return new Calzone(this);
        }
        
        @Override protected Builder self() {
            return this; 
        }
    }
    
    private Calzone(Builder builder) {
        super(builder);
        sauceInside = builder.sauceInside;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，每个子类builder中的&lt;code&gt;build&lt;/code&gt;方法被声明为返回正确的子类：&lt;code&gt;NyPizza.Builder&lt;/code&gt;的&lt;code&gt;build&lt;/code&gt;方法返回&lt;code&gt;NyPizza&lt;/code&gt;，而&lt;code&gt;Calzone.Builder&lt;/code&gt;中的&lt;code&gt;build&lt;/code&gt;方法返回&lt;code&gt;Calzone&lt;/code&gt;。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型( covariant return typing)。 它允许客户端使用这些builder，而不需要强制转换。&lt;/p&gt;
&lt;p&gt;这些“分层builder”的客户端代码基本上与简单的&lt;code&gt;NutritionFacts&lt;/code&gt; builder的代码相同。为了简洁起见,下面显示的示例客户端代码假设枚举常量的静态导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NyPizza pizza = new NyPizza.Builder(SMALL)
        .addTopping(SAUSAGE).addTopping(ONION).build();
Calzone calzone = new Calzone.Builder()
        .addTopping(HAM).sauceInside().build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;builder对构造方法的一个微小的优势是，builder可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder可以将传递给多个调用的参数聚合到单个属性中，如前面的&lt;code&gt;addTopping&lt;/code&gt;方法所演示的那样。&lt;/p&gt;
&lt;p&gt;Builder模式非常灵活。 单个builder可以重复使用来构建多个对象。 builder的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。&lt;/p&gt;
&lt;p&gt;Builder模式也有缺点。为了创建对象，首先必须创建它的builder。虽然创建这个builder的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，如果希望在将来添加更多的参数。但是，如果从构造方法或静态工厂开始，并切换到builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个builder。&lt;/p&gt;
&lt;p&gt;总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder比JavaBeans更安全。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 15:23:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8087978.html</dc:identifier>
</item>
<item>
<title>更便捷的css处理方式-postcss - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/8059939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/8059939.html</guid>
<description>&lt;p&gt;一般来说介绍一个东西都是要从是什么，怎么用的顺序来讲。我感觉这样很容易让大家失去兴趣，先看一下postcss能做点什么，有兴趣的话再往下看，否则可能没有耐心看下去。让我们开始吧&lt;/p&gt;
&lt;h2 id=&quot;postcss能做什么&quot;&gt;postcss能做什么&lt;/h2&gt;
&lt;h3 id=&quot;补全css属性浏览器前缀&quot;&gt;补全css属性浏览器前缀&lt;/h3&gt;
&lt;p&gt;手写的代码可以是这样的:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.div&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;postcss可以转换之后成了这样:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.div&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -webkit-box&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -ms-flexbox&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;检查css语法&quot;&gt;检查css语法&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;    body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; #f0&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会有以下提示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;src/er.css
 2:12  ✖  Unexpected invalid hex color &quot;#f0&quot;   color-no-invalid-hex



[18:27:28] 'css-lint' errored after 98 ms
[18:27:28] Error in plugin 'gulp-stylelint'
Message:
    Failed with 1 error&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拥抱下个版本规范的css-即css4&quot;&gt;拥抱下个版本规范的css 即css4&lt;/h3&gt;
&lt;p&gt;对于下个规范的css而言，变量，方法等功能的都会增加上去，你可以这样来定义一个变量：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;dv&quot;&gt;:root&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;--red:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#d33&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
  a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt; 
      &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; var(--red)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然直接在现有浏览器上是跑不通的，就正如es2015刚开始一样，我们需要一个转化器来将其转成当前可用规范。postcss的插件就可以做到。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;a&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;#d33&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了上面之外还有其他很多功能，postcss及其插件都能提供。&lt;/p&gt;
&lt;h2 id=&quot;什么是postcss&quot;&gt;什么是postcss&lt;/h2&gt;
&lt;p&gt;现在让我们回到最基本的问题，postcss是什么。&lt;br/&gt;援引官网的定义，一种使用js来转化css的工具(A tool for transforming CSS with JavaScript)。其实我们更多的时候提到postcss是有两个含义的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;postcss本身，也就是我们npm install时的安装部分&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;基于postCss的丰富插件系统。&lt;br/&gt;上文那些功能，都是基于postcss的插件提供的功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;postcss本身并不直接用于处理样式，只有配合它的插件，才能完成相关的编译工作。&lt;/p&gt;
&lt;h4 id=&quot;postcss不是预编译语言的替代品&quot;&gt;postcss不是预编译语言的替代品&lt;/h4&gt;
&lt;p&gt;我想你脑海里一直在复现两个名词，less/sass，开始的时候我也一样，认为postcss跟二者一样是一种css预编译语言或者起到类似作用的一种语言。postcss不是要取代哪一个，更多的是提供的一种补充，完全可以是互补的概念。&lt;br/&gt;作为一个是使用js将css转化为AST然后进行处理的工具，完全不是预处理语言的替代品，postcss处理的必须是css文件，所以完全可以和预编译语言结合，使用预编译语言转化为css之后然后进行处理。&lt;br/&gt;我一直认为两者不是互斥的关系，完全可以互补使用。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要postcss&quot;&gt;为什么需要postcss&lt;/h2&gt;
&lt;p&gt;大家可能有这么个疑问既然两者不互相冲突，目前我使用less/sass 也很容易满足我的需求，为什么要使用新的东西呢。我认为主要原因是其提供的丰富的插件功能，可以工作更加的简单化，便捷化，一句话，你只需要编写基本的css，其他的功能交给postcss就好。做了简单的对比可能更加清晰明了。&lt;/p&gt;
&lt;h4 id=&quot;实现给css属性加上浏览器前缀的功能&quot;&gt;实现给css属性加上浏览器前缀的功能&lt;/h4&gt;
&lt;p&gt;对比一下less和postcss的实现：&lt;/p&gt;
&lt;p&gt;1、 对于less而言，肯定是写一个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.flex-block&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -ms-flexbox&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -webkit-flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.flex-block()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、使用postcss&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要编译的时候使用autoprefixer处理就好。&lt;br/&gt;可能一个属性的效果不是特别明显，要是有很多个属性需要处理呢?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.flex-block&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -ms-flexbox&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -webkit-flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.transform&lt;/span&gt;()&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;//仅仅是举例子&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.ccc&lt;/span&gt;()&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.flex-block()&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.transform()&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.ccc()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候postcss还是只需要如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;transform:&lt;/span&gt;rotate(&lt;span class=&quot;dt&quot;&gt;7deg&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候就能看出来postcss的便捷性了，我一直认为可以抽象公共化的东西完全没有必要去重复的去手动开发。&lt;/p&gt;
&lt;h2 id=&quot;postcss工作原理&quot;&gt;postcss工作原理&lt;/h2&gt;
&lt;p&gt;postcss本身是一个node模块，可以将css文件解析为抽象语法树(AST)，将该树在多个插件方法传递，然后将AST转换为字符串返回，该字符串可以输出到目标文件中。传递过程中的插件可以选择是否改变该语法树，上诉改变可以通过sourcemap来记录。如下面的流程所示(借用w3cplus的一张图)：&lt;br/&gt;&lt;img src=&quot;https://www.w3cplus.com/sites/default/files/blogs/2017/1707/figure-18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这里我们更应该关联起来的是babel，看一下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将未来规范的转化为当前规范的转义器&lt;/li&gt;
&lt;li&gt;实现相同，都是将源文件解析为AST然后经由插件处理。&lt;/li&gt;
&lt;li&gt;丰富的插件，满足不同的需求&lt;/li&gt;
&lt;li&gt;支持自定义插件的开发&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;当前工作流中引入postcss&quot;&gt;当前工作流中引入postcss&lt;/h4&gt;
&lt;p&gt;大家可能会有这种想法，又是一种新的工具，我当前的开发框架中岂不是要大动。其实这种担心是没必要的。postcss是很容易引入当前的工作流中的。无论是webpack还是gulp，都有比较方便的方式。&lt;a href=&quot;https://github.com/postcss/postcss#usage&quot;&gt;官方有详细的介绍文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;原先很早就看到postCss，当时太年轻认为是less的一种替代品罢了，所以一直没有去关注。了解之后感觉真的不错，至于如何使用这里就不去演示了，有兴趣的可以查看下&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/postcss/tree/master/&quot;&gt;我的简单示例&lt;/a&gt;希望更多的人使用。&lt;/p&gt;
&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/&quot; class=&quot;uri&quot;&gt;http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/&quot; class=&quot;uri&quot;&gt;http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 14:08:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/8059939.html</dc:identifier>
</item>
</channel>
</rss>