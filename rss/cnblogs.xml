<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>微信亿级用户异常检测框架的设计与实践 - 云加社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8351385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8351385.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;
&lt;blockquote readability=&quot;8.2058823529412&quot;&gt;
&lt;p&gt;作者：青原行思（微信安全）&lt;/p&gt;
&lt;p&gt;作者：李琦、元东、苗园莉（清华大学深圳研究生院）&lt;/p&gt;
&lt;p&gt;编辑：小智&lt;/p&gt;
&lt;p&gt;由 &lt;a class=&quot;author-name&quot; href=&quot;https://cloud.tencent.com/developer/user/1054460&quot;&gt;腾讯大讲堂&lt;/a&gt; 发布在云+社区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;月活用户越高的互联网产品，被黑产盯上的可能性就越大。在微信的安全生态里，正是有网络黑产的层出不穷，变化多端，才有了微信安全的不断进化。本文将带你一窥究竟，微信是怎么做异常检测框架的？&lt;/p&gt;
&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;p&gt;如何在大规模数据下检测异常用户一直是学术界和工业界研究的重点，而在微信安全的实际生态中，一方面，黑产作恶手段多变，为了捕捉黑产多变的恶意模式，若采用有监督的方法模型可能需要频繁更新，维护成本较高；另一方面，通过对恶意帐号进行分析，我们发现恶意用户往往呈现一定的“聚集性”特征，因此这里需要更多地依赖无监督或半监督的手段对恶意用户进行检测。然而，微信每日活跃帐号数基本在亿级别，如何在有限的计算资源下从亿级别帐号中找出可疑帐号给聚类方案的设计带来了不小的挑战，而本文则是为了解决这一问题的一个小小的尝试。&lt;/p&gt;
&lt;h2&gt;异常检测框架设计目标及核心思路&lt;/h2&gt;
&lt;p&gt;设计目标为了满足在实际场景检测异常用户的要求，在设计初期，我们提出如下设计目标：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;主要用于检测恶意帐号可能存在的环境聚集和属性聚集；&lt;/li&gt;
&lt;li&gt;方案需要易于融合现有画像信息等其他辅助信息；&lt;/li&gt;
&lt;li&gt;方案需要具有较强的可扩展性，可直接用于亿级别用户基数下的异常检测。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;核心思路&lt;/h2&gt;
&lt;p&gt;通常基于聚类的异常用户检测思路是根据用户特征计算节点之间的相似度，并基于节点间相似度构建节点相似度连接图，接着在得到的图上做聚类，以发现恶意群体。然而，简单的分析就会发现上述方案在实际应用场景下并不现实，若要对亿级别用户两两间计算相似度，其时间复杂度和空间消耗基本上是不可接受的。为了解决这一问题，可将整个用户空间划分为若干子空间，子空间内用户相似度较高，而子空间之间用户之间的相似度则较低，这样我们就只需要在每个用户子空间上计算节点相似度，避免相似度较低的节点对之间的相似度计算 (这些边对最终聚类结果影响较低)，这样就能大大地降低计算所需的时间和空间开销。&lt;/p&gt;
&lt;p&gt;基于这一想法，同时考虑到恶意用户自然形成的环境聚集和属性聚集，我们可以根据环境以及用户属性对整个用户空间进行划分，只在这些子空间上计算节点之间的相似度，并基于得到的用户相似度图挖掘恶意用户群体。此外，直观上来分析，如果两个用户聚集的维度越“可疑”，则该维度对恶意聚集的贡献度应该越高，例如，如果两个用户同在一个“可疑”的 IP 下，相比一个正常的 IP 而言，他们之间存在恶意聚集的可能性更高。基于这一直觉，为了在每个用户子空间内计算用户对之间的相似度，可根据用户聚集维度的可疑度给每个维度赋予不同的权值，使用所有聚集维度的权值的加权和作为用户间的相似度度量。&lt;/p&gt;
&lt;p&gt;注：依据上述思路，需要在属性划分后的子空间计算两两用户之间的相似度，然而实际数据中特定属性值下的子空间会非常大，出于计算时间和空间开销的考虑，实际实现上我们会将特别大的 group 按照一定大小 (如 5000) 进行拆分，在拆分后的子空间计算节点相似度。(实际实验结果表明这种近似并不会对结果造成较大影响)&lt;/p&gt;
&lt;h2&gt;异常检测框架设计方案&lt;/h2&gt;
&lt;p&gt;基于上述思路，异常检测方案需要解决如下几个问题：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;如何根据用户特征 / 使用怎样的特征将整个用户空间划分为若干子空间？&lt;/li&gt;
&lt;li&gt;如何衡量用户特征是否“可疑”？&lt;/li&gt;
&lt;li&gt;如何根据构建得到的用户相似度关系图找出异常用户群体?&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决以上三个问题，经过多轮的实验和迭代，我们形成了一个较为通用的异常检测方案，具体异常检测方案框架图如图 1 所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/vm5fbkm3pf.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 1 异常用户检测框架&lt;/p&gt;
&lt;p&gt;如图 1 所示，首先，用户空间划分模块根据“划分属性”将整个用户空间划分为若干子空间，后续节点间相似度的计算均在这些子空间内部进行；恶意属性检测模块则根据输入数据自动自适应地识别用户特征中的“可疑”值；用户空间划分和恶意属性检测完成后，在每个用户子空间上，用户相似度计算模块基于恶意属性检测得到的恶意属性库和相应的权重策略计算用户之间两两之间的相似度，对于每个特征以及其对应的不同的可疑程度，权重策略模块会为其分配相应的权重值，用户间边的权重即为节点所有聚集项权重的加权和，为了避免建边可能带来的巨大空间开销，方案仅会保留权值大于一定阈值的边；得到上一步构建得到的用户相似度关系图后，可使用常用的图聚类算法进行聚类，得到可疑的恶意用户群体。&lt;/p&gt;
&lt;p&gt;用户空间划分&lt;/p&gt;
&lt;p&gt;为了进行节点间相似度的计算，首先需要将整个用户空间划分到不同的子空间中去，那么这些用于划分的属性该如何选取呢？经过一系列的实验和分析，我们将用户特征划分为以下两类：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;核心特征：核心特征指黑产帐号若要避免聚集，需要付出较大的成本的特征，主要包括一些环境特征；&lt;/li&gt;
&lt;li&gt;支撑特征：支撑特征指黑产帐号若要避免聚集，改变所需成本较小的特征。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不难发现，对于上述核心特征，黑产规避的成本较大，所以在具体的划分属性的选取上，我们使用核心特征对用户空间进行划分，并在划分得到的子空间上计算节点对之间的相似度。在子空间上计算节点之间的相似度时，我们引入支撑特征进行补充，使用核心特征和支撑特征同时计算用户之间的相似度，以提高恶意判断的准确率和覆盖率。&lt;/p&gt;
&lt;h2&gt;何为“可疑”&lt;/h2&gt;
&lt;h3&gt;可疑属性提取&lt;/h3&gt;
&lt;p&gt;在确定划分属性后，一个更为重要的问题是如何确定哪些用户属性值是可疑的？这里我们主要对用户脱敏后的登录环境信息进行分析，依赖微信安全中心积累多年的环境画像数据，通过对用户属性值的出现频次、分布等维度进行分析，提取出一些可疑的属性值。&lt;/p&gt;
&lt;h3&gt;多粒度的可疑属性识别&lt;/h3&gt;
&lt;p&gt;在进行养号识别的实验过程中，我们发现，单纯依靠若干天登录数据的局部信息进行养号检测往往无法达到较高的覆盖率。为了解决这一问题，在可疑属性提取过程中，我们会融合安全中心现有的环境画像信息以及反垃圾数据等全局信息辅助进行判断，局部信息和全局信息的融合有以下两个好处：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;融合局部信息和全局信息，可增大可疑属性判断的置信度和覆盖度，提高算法覆盖率；&lt;/li&gt;
&lt;li&gt;增加了用户相似度计算设计上的灵活度，如若特定帐号与已封号帐号有边相连，可通过赋予该边额外的权重来加大对已知恶意用户同环境帐号的打击。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;恶意用户识别&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/tm46bs91v5.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/o3z48cjkri.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/k73ctcz79d.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/iwee1gclo2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将超过一定阈值的用户视为恶意用户，其中，阈值可根据不同阈值得到的算法的准确率和覆盖率选取一个合适的阈值。&lt;/p&gt;
&lt;p&gt;另，处于性能和可扩展考虑，我们使用 Connected Components 算法来识别可疑的用户团体，同时，得到恶意团体后我们会对团体进行分析，提取在团体维度存在聚集性的属性值，以增强模型的可解释性。&lt;/p&gt;
&lt;h2&gt;从百万到亿——异常检测框架性能优化之路&lt;/h2&gt;
&lt;p&gt;初步实验时，我们随机抽取了百万左右的用户进行实验，为了将所提方案扩展到全量亿级别用户上，挖掘可疑的用户群体，我们做了如下优化：&lt;/p&gt;
&lt;h2&gt;Spark 性能优化&lt;/h2&gt;
&lt;p&gt;在基于 Spark 框架实现上述异常检测框架的过程中，我们也碰到了 Spark 大数据处理中常见的问题 ------ 数据倾斜。分析上述异常检测方案不难发现，方案实现中会涉及大量的 groupByKey,aggregateByKey,reduceByKey 等聚合操作，为了规避聚合操作中数据倾斜对 Spark 性能的影响，实际实现中我们主要引入了以下两个策略：两阶段聚合和三阶段自适应聚合。&lt;/p&gt;
&lt;h2&gt;两阶段聚合&lt;/h2&gt;
&lt;p&gt;如图 3 所示，两阶段聚合将聚合操作分为两个阶段：局部聚合和全局聚合。第一次是局部聚合，先给每个 key 都打上一个随机数，比如 10 以内的随机数，此时原先一样的 key 就变成不一样的了，比如 (hello, 1) (hello, 1) (hello, 1) (hello, 1) 就会变成 (1_hello, 1) (1_hello, 1) (2_hello, 1) (2_hello, 1)。接着对打上随机数后的数据，执行 reduceByKey 等聚合操作，进行局部聚合，得到局部聚合结果 (1_hello, 2) (2_hello, 2)。然后将各个 key 的前缀给去掉，得到 (hello,2)，(hello,2)，再次进行全局聚合操作，即可得到最终结果 (hello, 4)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/rlofn0alrg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 3 两阶段聚合&lt;/p&gt;
&lt;h2&gt; 三阶段自适应聚合&lt;/h2&gt;
&lt;p&gt;用户空间划分阶段我们需要将整个用户空间根据划分属性划分为若干个子区间，实际实验时我们发现在亿级别数据下，使用两阶段聚合，也会出现特定 key 下的数据量特别大的情况，导致 Spark 频繁 GC，程序运行速度极其缓慢，甚至根本无法得到聚合后的结果。为了解决这一问题，注意到通过划分属性进行划分后，仍然会将特别大的 group 按照一定大小进行切割，那么直接在聚合过程中融合这一步骤不就可以了么，这样就能解决特定属性值下数据特别多的情形，也能极大地提升算法运行效率。&lt;/p&gt;
&lt;h2&gt;三阶段自适应聚合分为以下四个阶段：&lt;/h2&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;随机局部聚合：设定一个较大的数（如 100），参照两阶段聚合第一阶段操作给每个 key 打上一个随机数，对打上随机数后的 key 进行聚合操作；&lt;/li&gt;
&lt;li&gt;自适应局部聚合：经过随机局部聚合后，可获取每个随机 key 下的记录条数，通过单个随机 key 下的记录条数，我们可以对原 key 下的数据条数进行估算，并自适应地调整第二次局部聚合时每个原始 key 使用的随机数值；&lt;/li&gt;
&lt;li&gt;第二轮随机局部聚合；根据自适应计算得到的随机数继续给每个 key 打上随机数，注意此时不同 key 使用的随机数值可能是不同的，并对打上随机数后的 key 进行第二轮局部聚合；&lt;/li&gt;
&lt;li&gt;全局聚合：经过第二轮随机局部聚合后，若特定 key 下记录数超过设定阈值 (如 5000)，则保留该结果，不再进行该阶段全局聚合；否则，则将随机 key 还原为原始 key 值，进行最后一阶段的全局聚合。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Faster, Faster, Faster&lt;/h2&gt;
&lt;p&gt;经过以上调优后，程序运行速度大致提升了 10 倍左右。然而，在实验中我们发现当对亿级别用户进行相似度计算并将边按阈值过滤后，得到的边数仍然在百亿级别，占用内存空间超过 2T。那么我们有没有可能减小这一内存占用呢？答案是肯定的。通过对整个异常用户检测流程进行细致的分析，我们发现我们并不需要对子空间内所有用户对进行相似度计算，通过前期实验我们发现当用户可疑度超过 0.7 时，基本就可以判定该用户是恶意用户。根据用户可疑度计算公式反推，当节点关联边的权重超过 18.2 时，其在最后结果中的权值就会超过 0.7，基于这一想法，我们引入了动态 Dropping 策略。&lt;/p&gt;
&lt;h2&gt;动态 Dropping 策略&lt;/h2&gt;
&lt;p&gt;引入 HashMap 保存当前子空间每个节点的累计权重值，初始化为 0.0；按照原始算法依次遍历子空间下的节点对，若节点对两个节点累计权重值均超过阈值（18.2），则跳过该节点对权值计算，否则则根据原始算法计算节点对权重，并累加到 HashMap 中，更新关联节点的累积权重值。引入动态 Dropping 策略后，对于较大的用户子空间，程序会跳过超过 90% 的节点对的相似度计算，极大地减少了计算量；同时，亿级别用户相似度计算生成的边的内存占用从原来超过 2T 降到 50G 左右，也极大地降低了程序所需内存占用。&lt;/p&gt;
&lt;h2&gt;图划分策略&lt;/h2&gt;
&lt;p&gt;通过相似度计算得到的用户相似度关系图节点分布是极不均匀的，大部分节点度数较小，少部分节点度数较大，对于这种分布存在严重倾斜的网络图，图划分策略的选择对图算法性能具有极大影响。为了解决这一问题，我们使用 EuroSys 2015 Best Paper 提出的图划分算法 HybridCut 对用户相似度关系图进行划分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1054460/yfnin2keph.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 4 HybridCut 图划分算法&lt;/p&gt;
&lt;p&gt;如图 4 所示，HybridCut 图划分算法根据节点度数的不同选取差异化的处理策略，对于度数较低的节点，如节点 2,3,4,5,6，为了保证局部性，算法会将其集中放置在一起，而对于度数较高的节点，如 1，为了充分利用图计算框架并行计算的能力，算法会将其对应的边摊放到各个机器上。通过按节点度数对节点进行差异化的处理，HybridCut 算法在局部性和算法并行性上达到了较好的均衡。以上仅对 HybridCut 算法基本思路进行粗略的介绍，更多算法细节请参阅论文 PowerLyra: Differentiated Graph Computation and Partitioning on Skewed Graphs。&lt;/p&gt;
&lt;h2&gt;总结和讨论&lt;/h2&gt;
&lt;p&gt;优点与不足&lt;/p&gt;
&lt;h3&gt; 优点&lt;/h3&gt;
&lt;p&gt;上述异常用户检测框架具有如下优点：&lt;/p&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;能够较好地检测恶意用户可能存在的环境聚集和属性聚集，且具有较高的准确率和覆盖率；&lt;/li&gt;
&lt;li&gt;能够自然地融合画像信息以及反垃圾信息，通过融合不同粒度的信息，可提高算法的覆盖率，同时也给算法提供了更大的设计空间，可以按需选择使用的特征或信息；&lt;/li&gt;
&lt;li&gt;良好的扩展性，可直接扩展到亿级别用户进行恶意用户检测，且算法具有较高的运行效率。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; 不足&lt;/h3&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;无法对非环境和属性聚集的恶意用户进行检测 (当然，这也不在方案的设计目标里)，无法处理恶意用户使用外挂等手段绕过环境和属性聚集检测的情况；&lt;/li&gt;
&lt;li&gt;上述方案权重策略部分需要人工指定权重，这无疑增加了人工调参的工作量，若黑产恶意模式或使用特征发生较大的变更，则可能需要对权重重新进行调整，维护成本较高。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; Next...&lt;/h3&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;探索自动化的权重生成策略，以应对可能的特征或黑产模式变更；&lt;/li&gt;
&lt;li&gt;是否可以根据聚类过程中的信息生成规则，用于实时恶意打击；&lt;/li&gt;
&lt;li&gt;上述方案比较适合用来检测恶意用户可能存在的环境聚集和属性聚集，对于非环境和属性聚集的恶意类型则显得无能为力了 (一种可能的方案是将连续属性离散化，不过这样太不优雅了！)，因此后续我们会尝试从行为维度对用户行为进行分析，并构建相应的打击模型。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;ol class=&quot;ol-level-0&quot;&gt;&lt;li&gt;Chen R, Shi J, Chen Y, et al. PowerLyra: differentiated graph computation and partitioning on skewed graphs[C]// Tenth European Conference on Computer Systems. ACM, 2015:1.&lt;/li&gt;
&lt;li&gt;Spark 性能优化指南——高级篇 https://tech.meituan.com/spark-tuning-pro.html&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;相关阅读&lt;/h2&gt;


&lt;hr/&gt;&lt;p&gt;此文已由作者授权云加社区发布，转载请注明&lt;a href=&quot;https://cloud.tencent.com/developer/article/1028442&quot; target=&quot;_blank&quot;&gt;原文出处&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 07:17:00 +0000</pubDate>
<dc:creator>云加社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8351385.html</dc:identifier>
</item>
<item>
<title>ArcGIS中实现指定面积蜂窝（正六边形）方法 - whgiser</title>
<link>http://www.cnblogs.com/giserliu/p/8351378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/giserliu/p/8351378.html</guid>
<description>&lt;p&gt;　　本篇博文为博主（whgiser）原创，转载请注明。&lt;/p&gt;
&lt;p&gt;　　空间聚集研究中，地理尺度大多数都是基于格网构建的，只需fishnet下就行了。也常有使用社区、交通小区（TZ）作为研究单元的。直到发现蜂窝网络做出的炫酷效果，迫不及待想试一下。六边形可以说其集合描述非常完美，但Arcgis并没有提供直接的工具生成正六边形。&lt;/p&gt;
&lt;p&gt;　　受&lt;a href=&quot;http://blog.csdn.net/allenlu2008/article/details/50996972&quot; target=&quot;_blank&quot;&gt;博文&lt;/a&gt;启发，该博文阐述了利用泰森多边形方法生成蜂窝，但是文章中没讲具体如何去算长度，只是基于大概绘制的，并且提到fishnet宽高比为1.5，其实是不精确的，画出来的并不是严格意义上的正六边形。经推理，假设需求的蜂窝单元为**平方公里或公顷，根据几何推导，可准确计算各个参数的值，从而能绘制出准确的蜂窝网络。具体推导如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/679933/201801/679933-20180125142313365-2127318571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　现在实践检验下。假设现在需要生成1平方公里的蜂窝网络，按如上推导，其各个参数计算如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
area = 1000000 &lt;span&gt;## &lt;/span&gt;&lt;span&gt;面积&lt;/span&gt;
l = np.sqrt((2*area)/(3*np.sqrt(3))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#蜂窝边长&lt;/span&gt;
cellWidth = 3*l &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 渔网宽度&lt;/span&gt;
cellHeight = (np.sqrt(3))*l &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 渔网高度&lt;/span&gt;
deltaX = 1.5 * l &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 横向偏移&lt;/span&gt;
deltaY = (np.sqrt(3)/2)*l &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 纵向偏移&lt;/span&gt;
&lt;span&gt;
【&lt;strong&gt;out&lt;/strong&gt;】
area:&lt;/span&gt;1000000&lt;span&gt;  
l: &lt;/span&gt;620.403239&lt;span&gt; 
cellWidth: &lt;/span&gt;1861.209718&lt;span&gt; 
cellHeight: &lt;/span&gt;1074.569932&lt;span&gt; 
deltaX: &lt;/span&gt;930.604859&lt;span&gt;  
deltaY: &lt;/span&gt;537.284966
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　接下来介绍在Arcgis中的实现，分三步走。&lt;/p&gt;
&lt;p&gt;　　第一步，生成 fishnet。设置模板范围为研究对象，像元宽度和高度值设置为cellWidth 和 cellHeight，注意勾选创建标注点，设置运行环境即可。&lt;/p&gt;
&lt;p&gt;　　第二步，复制上一步生成的点文件，打开编辑，设置移动距离X = deltaX，Y=deltaY，对点进行偏移。然后将偏移后的点和第一步生成的点进行合并。至此，已完成前期所有工作。内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/679933/201801/679933-20180125150617037-480973014.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　第三步，运用泰森多边形工具，生成网络，删去周边不需要的多边形，即可得到结果。经面积验证，基本上为1平方公里，会有很小的精度误差，这是由于计算过程中精度损失，可忽略不计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/679933/201801/679933-20180125150837662-810413350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在自己动手实现蜂窝网络过后，发现还是满有意思的操作。另外，如果不想这么麻烦去算的话，推荐一个直接生成的工具&lt;a href=&quot;http://tools.crwr.utexas.edu/Hexagon/hexagon.html&quot; target=&quot;_blank&quot;&gt;Create Hexagon Tessellation&lt;/a&gt;，适用于Arcgis 10.2版本。&lt;/p&gt;

</description>
<pubDate>Thu, 25 Jan 2018 07:15:00 +0000</pubDate>
<dc:creator>whgiser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/giserliu/p/8351378.html</dc:identifier>
</item>
<item>
<title>Android回顾系列——之HttpUrlConnect的使用 - 爱弹唱的码农</title>
<link>http://www.cnblogs.com/xykjlcx/p/8350934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xykjlcx/p/8350934.html</guid>
<description>&lt;p&gt;　　最近准备一个关于Android的比赛。由于赛项要求，不得使用第三方工具、框架；故最近来温习一下Google官方提供的原始API的使用。&lt;/p&gt;
&lt;p&gt;　　说实话，用惯了第三方的库，再回过头来用原生的api的确令人觉得麻烦，不过也不能仅仅依赖于各种层出不穷的框架和库，掌握相对底层的核心点，才是竞争力的来源。并且用了第三方的库之后再来看原生，不经意间就会有好的思路产生。&lt;/p&gt;
&lt;p&gt;　　那么，今天就来简单介绍一下HttpUrlConnect的基本使用，和笔者自己做的一个小的工具类封装。&lt;/p&gt;
&lt;h2&gt;先来学习原生的使用：&lt;/h2&gt;
&lt;p&gt;　　Ps:  解释以注释形式写在代码中&lt;/p&gt;
&lt;p&gt;　　* GET请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口地址&lt;/span&gt;
                String url_path = &quot;http://223.111.182.5:8080/logistics/goods/myOffer&quot;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用该地址创建一个 URL 对象&lt;/span&gt;
                    URL url = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(url_path);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用创建的URL对象的openConnection()方法创建一个HttpURLConnection对象&lt;/span&gt;
                    HttpURLConnection httpURLConnection =&lt;span&gt; (HttpURLConnection)url.openConnection();
                    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                     * 设置HttpURLConnection对象的参数
                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置请求方法为 GET 请求&lt;/span&gt;
                    httpURLConnection.setRequestMethod(&quot;GET&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用输入流&lt;/span&gt;
                    httpURLConnection.setDoInput(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;GET 方式，不需要使用输出流&lt;/span&gt;
                    httpURLConnection.setDoOutput(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置超时&lt;/span&gt;
                    httpURLConnection.setConnectTimeout(10000&lt;span&gt;);
                    httpURLConnection.setReadTimeout(&lt;/span&gt;1000&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接&lt;/span&gt;
&lt;span&gt;                    httpURLConnection.connect();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还有很多参数设置 请自行查阅

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接后，创建一个输入流来读取response&lt;/span&gt;
                    BufferedReader bufferedReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(httpURLConnection.getInputStream(),&quot;utf-8&quot;&lt;span&gt;));
                    String line &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
                    StringBuilder stringBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                    String response &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次读取一行，若非空则添加至 stringBuilder&lt;/span&gt;
                    &lt;span&gt;while&lt;/span&gt;((line = bufferedReader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        stringBuilder.append(line);
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取所有的数据后，赋值给 response&lt;/span&gt;
                    response =&lt;span&gt; stringBuilder.toString().trim();
                    Utils.log(&lt;/span&gt;&quot; 打印响应 &quot; +&lt;span&gt; response);
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String finalResponse =&lt;span&gt; response;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切换到ui线程更新ui&lt;/span&gt;
                    runOnUiThread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                        @Override
                        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                            result.setText(finalResponse);
                        }
                    });
                    bufferedReader.close();
                    httpURLConnection.disconnect();
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
                    e.printStackTrace();
                }
            }
        }).start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　* POST请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建HttpURLConnection变量&lt;/span&gt;
            HttpURLConnection httpURLConnection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建PrintWriter变量，用于向HttpURLConnection写入请求参数&lt;/span&gt;
            PrintWriter printWriter = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建BufferedReader，来接收相应数据流&lt;/span&gt;
            BufferedReader bufferedReader = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义缓冲&lt;/span&gt;
            StringBuilder stringBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义line读取一行数据&lt;/span&gt;
            String line = &quot;&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义接口地址&lt;/span&gt;
            String url_path = &quot;http://xxx.xxx.xxx.xxx:8080/logistics/goods/bidCount&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟参数&lt;/span&gt;
            String para = &quot;goodId=14&quot;&lt;span&gt;;
            String response &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    URL url &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(url_path.equals(&quot;&quot;&lt;span&gt;)){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用接口地址初始化URL对象&lt;/span&gt;
                    url = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(url_path);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用URL对象创建HttpURLConnection对象&lt;/span&gt;
                    httpURLConnection =&lt;span&gt; (HttpURLConnection) url.openConnection();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置相应参数&lt;/span&gt;
                    httpURLConnection.setDoInput(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    httpURLConnection.setDoOutput(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以创建输出流，将请求参数写入&lt;/span&gt;
                    httpURLConnection.setRequestMethod(&quot;POST&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求方式为POST
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将请求参数写入连接的输出流&lt;/span&gt;
                    printWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintWriter(httpURLConnection.getOutputStream());
                    printWriter.print(para);
                    printWriter.flush();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取响应结果&lt;/span&gt;
                    bufferedReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(httpURLConnection.getInputStream(),&quot;utf-8&quot;&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((line = bufferedReader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        stringBuilder.append(line);
                    }
                    response &lt;/span&gt;=&lt;span&gt; stringBuilder.toString().trim();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切换主线程更新ui&lt;/span&gt;
                    runOnUiThread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                        @Override
                        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                            result.setText(response);
                        }
                    });
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
                    e.printStackTrace();
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                         * 关闭连接/流
                         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;(printWriter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                            printWriter.close();
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bufferedReader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                            bufferedReader.close();
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(httpURLConnection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                            httpURLConnection.disconnect();
                        }
                    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
                        e.printStackTrace();
                    }
                }
            }
        }).start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 下面贴一个自己写的一个Post请求工具类：&lt;/h3&gt;
&lt;p&gt;　　Ps：为什么不封装的更完善些呢？比如支持支持Get请求、支持自定义Http头部各参数设置，异步消息部分采用Handle或AsynTask。其实刚刚说的这些包括还没有想到的，都可以添加上去，只是笔者时间紧迫，所以以下的工具类只提供Post方式的请求。&lt;/p&gt;
&lt;p&gt;　　工具类支持：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　自定义参数(传参时，只要传入相对应的map)&lt;/li&gt;
&lt;li&gt;　　支持接口回调，在回调方法内写结果处理逻辑&lt;/li&gt;
&lt;li&gt;　　简单的线程控制，开发者不需要手动实现线程切换&lt;/li&gt;
&lt;li&gt;　　简单易用的API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　下面贴工具类代码，和简单的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 作者：LiChangXin
 * Created by haiyang on 2018/1/25.
 * 简介：
 * 1.自定义参数(传参时，只要传入相对应的map)
 * 2.支持接口回调，在回调方法内写结果处理逻辑
 * 3.简单的线程控制，开发者不需要手动实现线程切换
 * 4.简单易用的API
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XykjHttpPost &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过构造函数
     * 赋值：
     * url - 接口地址
     * form - 请求参数(map)
     * xykjHttpCall - 回调接口
     * mactivity - 基于activity的runOnUiThread()方法的线程控制
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String url = &quot;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt; form;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; XykjHttpCall xykjHttpCall = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Activity mactivity;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面这些 与之前的例子相同&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; HttpURLConnection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; PrintWriter pw = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; BufferedReader bufferedReader = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String line = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; StringBuilder response_cache = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String response = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String parameter = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; XykjHttpPost(XykjHttpCall xykjHttpCall,String url_p, Map&amp;lt;String,String&amp;gt;&lt;span&gt; form_p,
                        Activity activity){
        url &lt;/span&gt;=&lt;span&gt; url_p;
        form &lt;/span&gt;=&lt;span&gt; form_p;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xykjHttpCall =&lt;span&gt; xykjHttpCall;
        mactivity &lt;/span&gt;=&lt;span&gt; activity;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        Utils.log(&lt;/span&gt;&quot;XYKJHTTPPOST : &quot; + &quot;Thread@run() 方法开始执行&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(url.equals(&quot;&quot;) || url == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若url为空，结束执行&lt;/span&gt;
                Utils.log(&quot;XYKJHTTPPOST : &quot; + &quot;无请求参数&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            URL url_path &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(url.trim());
            connection &lt;/span&gt;=&lt;span&gt; (HttpURLConnection) url_path.openConnection();
            connection.setDoOutput(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            connection.setDoInput(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            connection.setUseCaches(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            connection.setRequestMethod(&lt;/span&gt;&quot;POST&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取连接&lt;/span&gt;
&lt;span&gt;            connection.connect();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!form.isEmpty() &amp;amp;&amp;amp; form != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取连接输出流，并写入表单参数&lt;/span&gt;
                pw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintWriter(connection.getOutputStream());
                parameter &lt;/span&gt;=&lt;span&gt; formDataConnect(form);
                pw.print(parameter);
                pw.flush();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取响应 输入流&lt;/span&gt;
            bufferedReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(connection.getInputStream()));
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((line = bufferedReader.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                response_cache.append(line);
            }
            response &lt;/span&gt;=&lt;span&gt; response_cache.toString().trim();
            Utils.log(&lt;/span&gt;&quot;XYKJHTTPPOST : RESPONSE -&amp;gt; &quot; +&lt;span&gt; response);
            mactivity.runOnUiThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(response != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !response.equals(&quot;&quot;&lt;span&gt;)){
                        xykjHttpCall.success(response);
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        xykjHttpCall.error(&lt;/span&gt;&quot;Response为空&quot;&lt;span&gt;);
                    }
                }
            });
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            mactivity.runOnUiThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    xykjHttpCall.error(&lt;/span&gt;&quot;XYKJHTTPPOST : 网络请求/解析异常&quot;&lt;span&gt;);
                }
            });
            Utils.log(&lt;/span&gt;&quot;XYKJHTTPPOST : 网络请求/解析异常&quot;&lt;span&gt;);
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pw != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    pw.close();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bufferedReader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    bufferedReader.close();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    connection.disconnect();
                }
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
                mactivity.runOnUiThread(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        xykjHttpCall.error(&lt;/span&gt;&quot;XYKJHTTPPOST : 关闭连接/流异常&quot;&lt;span&gt;);
                    }
                });
                Utils.log(&lt;/span&gt;&quot;XYKJHTTPPOST : 关闭连接/流异常&quot;&lt;span&gt;);
                e.printStackTrace();
            }
        }
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 参数转换函数
     * map -&amp;gt; http[post] 参数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; form_data
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String formDataConnect(Map&amp;lt;String,String&amp;gt;&lt;span&gt; form_data){
        StringBuilder url_form &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历map，按照url参数形式拼接&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String key:form_data.keySet()){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(url_form.length() != 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从第二个参数开始，每个参数key、value前添加 &amp;amp; 符号&lt;/span&gt;
                url_form.append(&quot;&amp;amp;&quot;&lt;span&gt;);
            }
            url_form.append(key).append(&lt;/span&gt;&quot;=&quot;&lt;span&gt;).append(form_data.get(key));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; url_form.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *  定义回调接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; XykjHttpCall {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; success(String response);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; error(String error_message);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 线程启动
     * 执行请求
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; request(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.start();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; * 使用方法：&lt;/p&gt;
&lt;p&gt;　　先上业务场景，是一个用户的登录操作，收集 手机号码和密码 后进行post请求验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1128805/201801/1128805-20180125142255803-1216074588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1128805/201801/1128805-20180125142843725-372007129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后&lt;strong&gt;调用该对象的request()方法&lt;/strong&gt;，即可启动post请求。&lt;/p&gt;
&lt;p&gt; * 效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1128805/201801/1128805-20180125143001334-1994488554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 Ok，今天的营养目标达成。&lt;/p&gt;
&lt;p&gt;　　有什么问题或者有好的想法的可以在评论里留言，笔者会在第一时间解答。&lt;/p&gt;
&lt;p&gt;　　未来的话，如果笔者继续搞Android，会慢慢来丰富这个工具类，届时会开源到Github上，虽然水平一般，但开源精神还是可赞的嘛😀&lt;/p&gt;

</description>
<pubDate>Thu, 25 Jan 2018 06:32:00 +0000</pubDate>
<dc:creator>爱弹唱的码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xykjlcx/p/8350934.html</dc:identifier>
</item>
<item>
<title>input事件中文触发多次问题研究 - 走在起点</title>
<link>http://www.cnblogs.com/mopagunda/p/8343031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mopagunda/p/8343031.html</guid>
<description>&lt;p&gt;　　我们在网页中经常会遇到实时搜索的情况，或者其他类似需要input实时响应的问题，一般情况下，我们是利用input和propertychange事件来监听input内容的变化来响应，但是有一个问题就是当输入汉字的时候，可能我们要输入 ‘实时’ 的时候，我们的input框中会出现 'shishi'直到我们的空格才会变成 '实时',这也就意味着我们依次响应了 's','sh','shi','shis','shish','shishi','实时'，前面的结果明显不是我们需要的 ，造成了我们很多次无用的提交，如果是接口请求，那更要命，多发了好多次请求。&lt;/p&gt;
&lt;p&gt;　　最早之前有一个稍微能改善的解决方案就是配合一个定时器延时执行，这样能减少请求次数，但是这个减少是不分情况的减少 ，还是治标不治本。&lt;/p&gt;
&lt;p&gt;　　今天偶然看到几个事件，发现可以完美解决这种问题。我们来看一下这几个事件&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;code&gt;&lt;span&gt;compositionstart ， &lt;strong&gt;&lt;code&gt;compositionupdate&lt;/code&gt;&lt;/strong&gt; ，&lt;strong&gt;&lt;code&gt;compositionend&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;　  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  &lt;span&gt;compositionstart 官方解释&lt;/span&gt; &lt;span&gt;： 触发于一段文字的输入之前（类似于 &lt;code&gt;keydown&lt;/code&gt; 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词），通俗点，假如我们要输入一段中文，当我们按下第一个字母的时候触发 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　相应的compositionupdate在我们中文开始输入到结束完成的每一次keyup触发。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　而compositionend则在我们完成当前中文的输入触发 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　正题来了，通过上面的事件我们就可以完美的解决中文输入的响应问题了，从compositionstart触发开始，意味着中文输入的开始且还没完成，所以此时我们不需要做出响应，在compositionend触发时，表示中文输入完成，这时我们可以做相应事件的处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　所以我们可以设置一个变量，或者给input定义一个属性，在&lt;span&gt;compositionstart到compositionend之间对input事件不做出响应&lt;/span&gt;。看以下代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$('input'&lt;span&gt;).on({
    input : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){        
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flag =&lt;span&gt; e.target.isNeedPrevent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag)  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;     
        response() 
    },
    compositionstart : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.isNeedPrevent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ;
    },
    compositionend : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.isNeedPrevent &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;        
    }
})
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; response(){
    $(&lt;/span&gt;'div').append('&amp;lt;p&amp;gt;事 件触发&amp;lt;/p&amp;gt;'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们通过compositionstart，compositionend事件来设置flag，判断是否正在进行输入中文以控制input事件的响应，看上去没有问题，但实际执行时会发现在&lt;span&gt;谷歌浏览器中input执行顺序要先于compositionend&lt;/span&gt;，火狐执行顺序正常，但compositionend会响应两次。这就导致谷歌浏览器中输入汉字不会响应input事件。当然也可以在compositionend事件中再执行一次response事件，这样的问题是在火狐浏览器中会多执行一次response，显然不是最优方案。&lt;/p&gt;
&lt;p&gt;　　经过试验，发现&lt;span&gt;keyup和compositionend事件执行顺序在各大浏览器都保持一致&lt;/span&gt;，于是我们改成如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$('input'&lt;span&gt;).on({
    keyup : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){        
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flag =&lt;span&gt; e.target.isNeedPrevent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag)  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;     
        response() 
    },
    compositionstart : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.isNeedPrevent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ;
    },
    compositionend : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.isNeedPrevent &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
        
    }
})
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; response(){
        $(&lt;/span&gt;'div').append('&amp;lt;p&amp;gt;事 件触发&amp;lt;/p&amp;gt;'&lt;span&gt;)
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样在各个浏览器基本保持一致了（兼容compositionstart的浏览器）。但是keyup有一个问题，比如通过&lt;span&gt;鼠标复制粘贴的时候并不相应keyup事件&lt;/span&gt;，所以上面的事情我们还需要再优化下，&lt;span&gt;keyup相应按键事件，input响应除了keyup之外的变化事件&lt;/span&gt;。代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$('input'&lt;span&gt;).on({
    keyup : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){        
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flag =&lt;span&gt; e.target.isNeedPrevent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag)  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;     
        response() ;
        e.target.keyEvent &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt; ;
        
    },
    keydown : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.keyEvent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ; 
    },
    input : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;e.target.keyEvent){
            response()
        }        
    },
    compositionstart : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.isNeedPrevent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ;
    },
    compositionend : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
        e.target.isNeedPrevent &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        
    }
})
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; response(){
        $(&lt;/span&gt;'div').append('&amp;lt;p&amp;gt;事 件触发&amp;lt;/p&amp;gt;'&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从目前需求可以完全实现了。&lt;/p&gt;
&lt;p&gt;在线预览：&lt;/p&gt;


&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events/compositionstart&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 06:27:00 +0000</pubDate>
<dc:creator>走在起点</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mopagunda/p/8343031.html</dc:identifier>
</item>
<item>
<title>Java高并发秒杀系统API之SSM框架集成swagger与AdminLTE - 安与生</title>
<link>http://www.cnblogs.com/anyushengcms/p/8350973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyushengcms/p/8350973.html</guid>
<description>&lt;p&gt;Java高并发秒杀系统API是来源于网上教程的一个Java项目，也是我接触Java的第一个项目。本来是一枚c#码农，公司计划部分业务转java,于是我利用业务时间自学Java才有了本文，本来接触之初听别人说，c#要转java很容易，我也信了，但是真正去学习的时候还是踩了无数个坑，好在朋友有几个做安卓的，向他们讨教了一些经验，但是他们做安卓的和web又是两个方向，于是继续一个人默默采坑避雷之旅，首先上手的是下面这个Java高并发秒杀系统API。&lt;/p&gt;
&lt;p&gt;学习java的初衷一个是公司转行，二是自己也想学学看，增加下技术的厚度，多了解下不同编程语言，不同实现方式。融会贯通，才能打通任督二脉。之前也看过python的东西，但是兴趣不大，Java毕竟生态很好，各种大神很多，每个语言也有不同的优缺点，多了解有利于自身发展。&lt;/p&gt;
&lt;p&gt;关于这个秒杀系统园子已经有几位大神写过了相关的文章，其实本不想献丑的，权且当作学习笔记看吧，重点讲的是在这个系统之上集成swagger和AdminLTE，为什么集成它们呢，因为我已经在c#.net项目里面做过相关的内容，&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/anyushengcms/p/7325126.html&quot;&gt;ABP+AdminLTE+Bootstrap Table权限管理系统一期&lt;/a&gt; ，哈哈，自我营销一下，有兴趣的朋友可以看一下顺便点个赞再走？&lt;br/&gt;本来以为swagger ui和AdminLTE集成会很简单的，但是动手去做的时候发现了很多问题，由于我之前就是抱着先写一个web项目再说的初衷去做的，做完之后确实发现了很多问题，其实最重要的问题就是基础不牢，地动山摇，写完这篇文章之后，我决定要重基础学着来，深度学习一下。包括但不限于像tomcat,servlet,Webservice,MyBatis,Maven,spring,spring boot,spring cloud。&lt;/p&gt;
&lt;h2 id=&quot;上手&quot;&gt;上手&lt;/h2&gt;
&lt;p&gt;废话不多说，开整。关于Java开发环境的配置我就不扯了，网上教程一大堆，说下Maven的配置，首先去官网下载http://maven.apache.org/download.cgi&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-360325ab0bbe2933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-2e561435147e1e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;然后是系统变量的配置&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-3519dde6a488e11e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;Path配置&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-187ac08d0a7487af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后win+R快捷键cmd进入dos窗口，输入命令，mvn -v（注意中间有个空格），回车运行后可以看见maven版本maven home表示安装成功&lt;/p&gt;
&lt;h2 id=&quot;maven-自动生成项目&quot;&gt;Maven 自动生成项目&lt;/h2&gt;
&lt;p&gt;最后在命令行中输入以下命令：mvn archetype:generate -DgroupId=cn.codingxiaxw.seckill -DartifactId=seckill -Dpackage=cn.codingxiaxw.seckill -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp&lt;br/&gt;注意下图中的两个回车，开始我就等了好久没有反应，查看项目没有，&lt;br/&gt;这里的回车大概意思是默认DgroupId和DartifactId。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-990351fc60574785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f9a14e825f05ec2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;然后打开上面命令行中的地址，看到如下文件内容说明项目生成成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-dcbbe28c7aa118fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;IDEA打开并不全项目结构如下。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-98028c4e52b9808f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来配置tomcat.&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f4e2138bb907dbe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-74430c0bd9bf6d6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好了打开 localhost:8080就能看到相关效果，这里要注意一个大坑，特别的初入Java朋友，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-d9a96d8cfb80d724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老是报无效标记的错误。网上找了大圈都不符合我的错误。最后我下载了jdk1.8版本就解决了，问题就是idea 和jdk 9.0在项目中出现冲突了。问题解决了我也没有去深究，估计还有其他问题。当时各种问题排除了，代码检查了N遍，万万没想到是jdk的错误。&lt;/p&gt;
&lt;h2 id=&quot;pom.xml&quot;&gt;pom.xml&lt;/h2&gt;
&lt;p&gt;然后就是配置pom.xml,代码很长我就不贴出来了，直接去我的github pom.xml看吧：&lt;a href=&quot;https://github.com/Jimmey-Jiang/seckill/blob/master/seckill/pom.xml%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8C%85%E5%90%AB%E4%BA%86%E5%90%8E%E9%9D%A2%E8%A6%81%E8%AF%B4%E7%9A%84swaggerui&quot; class=&quot;uri&quot;&gt;https://github.com/Jimmey-Jiang/seckill/blob/master/seckill/pom.xml，这里包含了后面要说的swaggerui&lt;/a&gt; 的引入。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-43b73bee87cd3f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础业务编写&quot;&gt;基础业务编写&lt;/h3&gt;
&lt;p&gt;接下来就是跟着教程一步一步的写。包括dto，entity,dao,service,web,控制器，视图，test测试类，jsp的编写。具体我就不说了，&lt;a href=&quot;https://github.com/Jimmey-Jiang/seckill&quot;&gt;去我的github上clone下来打开看看就明白了&lt;/a&gt;，&lt;a href=&quot;https://www.imooc.com/learn/587&quot;&gt;或者去看教程吧&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-86391852e6f9ee33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;初步效果&quot;&gt;初步效果&lt;/h3&gt;
&lt;p&gt;编写完效果如下。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-02f301bbc04e24a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-ba175da3c44ad112.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其他的代码教程上有，最后重点讲一下swagger的集成。&lt;br/&gt;首先当然是去&lt;a href=&quot;https://github.com/swagger-api/swagger-ui/tree/v2.1.5&quot;&gt;下载swagger&lt;/a&gt;,然后引入项目,然后修改index.html里面的url为http://localhost:8080/api-docs。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f7db05b285ac524f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pom引入jar包。Swagger获取api后是以json形式返回数据给Swagger ui，这里需要引入jackson的相关包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;!--swagger--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.mangofactory&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;swagger-springmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.4.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.4.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.4.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建config包，然后新建SwaggerConfig配置类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package org.seckill.config;

/**
 * Created by jiangcy on 2018/1/23.
 */

import com.mangofactory.swagger.configuration.SpringSwaggerConfig;
import com.mangofactory.swagger.models.dto.ApiInfo;
import com.mangofactory.swagger.plugin.EnableSwagger;
import com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

@Configuration
@EnableSwagger
@EnableWebMvc
public class SwaggerConfig {
    private SpringSwaggerConfig springSwaggerConfig;
    /**
     * Required to autowire SpringSwaggerConfig
     */
    @Autowired
    public void setSpringSwaggerConfig(SpringSwaggerConfig springSwaggerConfig)
    {
        this.springSwaggerConfig = springSwaggerConfig;
    }
    /**
     * Every SwaggerSpringMvcPlugin bean is picked up by the swagger-mvc
     * framework - allowing for multiple swagger groups i.e. same code base
     * multiple swagger resource listings.
     */
    @Bean
    public SwaggerSpringMvcPlugin customImplementation()
    {
        return new SwaggerSpringMvcPlugin(this.springSwaggerConfig)
                .apiInfo(apiInfo())
                .includePatterns(&quot;.*?&quot;);

    }

    private ApiInfo apiInfo()
    {
        ApiInfo apiInfo = new ApiInfo(
                &quot;Swagger测试&quot;,
                &quot;测试查询用户&quot;,
                &quot;开发者: Changxin L&quot;,
                &quot;348686686@gmail.com&quot;,
                &quot;MIT License&quot;,
                &quot;/LICENSE&quot;);
        return apiInfo;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在配置类里面配置一下静态资源的映射路径。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-c75fc959ede58430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;!-- 将 springSwaggerConfig加载到spring容器 --&amp;gt;
    &amp;lt;bean     class=&quot;com.mangofactory.swagger.configuration.SpringSwaggerConfig&quot; /&amp;gt;
    &amp;lt;!-- 将自定义的swagger配置类加载到spring容器 --&amp;gt;
    &amp;lt;bean class=&quot;org.seckill.config.SwaggerConfig&quot; /&amp;gt;
    
    &amp;lt;mvc:resources mapping=&quot;/swagger/**&quot; location=&quot;/WEB-INF/swagger/&quot;/&amp;gt;

    &amp;lt;!-- 定义无需Controller的url&amp;lt;-&amp;gt;view直接映射 --&amp;gt;
    &amp;lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;../WEB-INF/swagger/index&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;swagger-效果&quot;&gt;swagger 效果&lt;/h2&gt;
&lt;p&gt;如果上述操作准确无误的话，那么你将会看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-178fd2305d098e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;adminlte-以其他&quot;&gt;AdminLTE 以其他&lt;/h2&gt;
&lt;p&gt;AdminLTE 引入就更简单了，不需要jar包，只需要引入静态资源就可以了。&lt;br/&gt;所以就不做累述了，需要的可以clone项目来看下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f925613b36fcc8e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-cf64aebf4ee63e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-a7c29f66d238e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-6bb4938b1389cf66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-5c3f753299db7aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-8a89654d17dd521c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;github&quot;&gt;github&lt;/h2&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/Jimmey-Jiang/seckill&quot; class=&quot;uri&quot;&gt;https://github.com/Jimmey-Jiang/seckill&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 06:08:00 +0000</pubDate>
<dc:creator>安与生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyushengcms/p/8350973.html</dc:identifier>
</item>
<item>
<title>Core Animation 文档翻译（第三篇） - 开机按钮</title>
<link>http://www.cnblogs.com/zhouyubo/p/8324847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouyubo/p/8324847.html</guid>
<description>&lt;p&gt;&lt;span&gt;Core Animation 文档翻译（第三篇） &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;设置&lt;/span&gt;&lt;span&gt;Layer&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我们使用核心动画时，Layer对象是一切的核心。Layers 管理我们APP的可视化content，Layer也提供了content样式及content可视化的外观的调整选项。尽管iOSAPP自动支持Layer，但是OS XAPP必须明确开启Layer的使用才能利用这些相关的性能特点。一旦开启Layer的使用，我们需要去理解如何配置和操作Layers才能得到想要的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为APP开启核心动画的支持&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在iOS APP里，核心动画是一直支持的并且每个view 都关联一个Layer（这种view被称为layer-backed view）。在OSX APP中，必须手动开启核心动画的支持，关联QuartzCore framework。（iOS APP必须关联这个framework仅当使用核心动画接口时候）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启Layer的支持后，创建layer-backed view是其功能之一，这种View，系统将会负责为其创建Layer对象并保持那个Layer的更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;调整和View关联的Layer&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layer-backed view 默认创建一个CALayer类的实例，大多数情况下我们不需要其他样式的Layer对象。然而，核心动画提供了其他的Layer类，各个Layer类都具有特殊的功能。选择对应的Layer类有助于我们提高性能，或者有助于以一种更简单的方式显示特殊样式的content。例如CATiledLayer类为高效的展示大图而优化设计的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;改变Uiview的Layer类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们能够改变iOS View 的Layer类别通过重写layerClass方式并一个不同的类。许多iOS Views创建一个CALayer对象并使用该对象作为content的存储。对于许多我们自己的Views，默认的layer类别就是一个不错的选择。但是在某些特定的场景别的Layer类是更合适的。例如，我们可能想要去改变Layer类在一下场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·我们的View绘制content通过使用Metal 或者OpenGL ES，此时我们需要使用CAMetalLayer 或者CAEAGLLayer 对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·当有特定的Layer类提供更好的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·我们想要利用某些特定的核心动画Layer类别。例如粒子发射或者粒子复制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改变View的Layer类的方式是很简明的；就像2-1所示一样，我们需要做的只是重写LayerClass方法并且返回我们想要使用的类对象在展示之前View将会先调用layerClass方法，并使用它返回的类对象创建一个Layer对象，一旦创建后，该view的layer对象讲不可更换。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
+&lt;span&gt; (Class) layerClass {
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [CAMetalLayer &lt;span&gt;class&lt;/span&gt;&lt;span&gt;];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相应的Layer类别的列表，和如何使用它们，参见 &lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW25&quot; data-renderer-version=&quot;1&quot;&gt;Different Layer Classes Provide Specialized Behaviors&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span class=&quot;content_text&quot;&gt;各种Layer类提供对应的特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;content_text&quot;&gt;核心动画定义了许多标准的Layer类，每一个都具有特定的用途。CALayer是根类，它定义的特性其他所有的Layer都必须支持，CALayer也是默认的类别。当然，我们也可以使用2-1表中的Layer类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;content_text&quot;&gt;&lt;span class=&quot;caption_number&quot;&gt;Table 2-1  &lt;code&gt;CALayer&lt;/code&gt; subclasses and their uses&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;tableholder&quot;&gt;
&lt;table class=&quot;graybox&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;&lt;tbody readability=&quot;13.365448504983&quot;&gt;&lt;tr&gt;&lt;th class=&quot;TableHeading_TableRow_TableCell&quot; scope=&quot;col&quot;&gt;
&lt;p&gt;Class&lt;/p&gt;
&lt;/th&gt;
&lt;th class=&quot;TableHeading_TableRow_TableCell&quot; scope=&quot;col&quot;&gt;
&lt;p&gt;Usage&lt;/p&gt;
&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.6283185840708&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/caemitterlayer&quot; target=&quot;_self&quot;&gt;CAEmitterLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;实现核心动画中粒子发射系统，发射器Layer控制粒子的生成和他们的原点。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.9767441860465&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/cagradientlayer&quot; target=&quot;_self&quot;&gt;CAGradientLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;用来画颜色的渐变，以便于用渐变的颜色填充layer上面的形状（一般指绘制的图形）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.6504854368932&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/cametallayer&quot; target=&quot;_self&quot;&gt;CAMetalLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;用于设置和渲染可绘制的纹理（用于渲染layer 的content通过使用Metal）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.7478260869565&quot;&gt;&lt;td scope=&quot;row&quot; readability=&quot;0.2&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/caeagllayer&quot; target=&quot;_self&quot;&gt;CAEAGLLayer&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/caopengllayer&quot; target=&quot;_self&quot;&gt;CAOpenGLLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;用于设置后端存储和渲染layer 的content的上下文（OpenGL ES或者OpenGL ）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.0158227848101&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/careplicatorlayer&quot; target=&quot;_self&quot;&gt;CAReplicatorLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;当想要自动拷贝一个或多个子layer时，复制器创建副本，并使用我们指定的属性改变外观或者副本的属性。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.5411764705882&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/cascrolllayer&quot; target=&quot;_self&quot;&gt;CAScrollLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;用于管理一个由许多子layer复合而成的可滚动的区域。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.2820823244552&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/cashapelayer&quot; target=&quot;_self&quot;&gt;CAShapeLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;用于画一个三维或者二位的贝塞尔曲线。这种layer在绘制基于path形状方面是有利的，因为他们总会创建出一个完善的path；而我们将path绘制到某个layer的后台存储的，看起来将会有瑕疵当缩放的时候。然而，这个完善的性能牵涉到在主线程渲染该形状并缓存这个结果。（个人觉得他应该是保存的矢量图）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.5&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/catextlayer&quot; target=&quot;_self&quot;&gt;CATextLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;用于渲染文本中普通的或者属性字符串。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.0263157894737&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/catiledlayer&quot; target=&quot;_self&quot;&gt;CATiledLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;用于管理能够被分割成许多小块并单独渲染的大图，并支持缩小和放大content.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.5596330275229&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/catransformlayer&quot; target=&quot;_self&quot;&gt;CATransformLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;用于渲染真实的3D layer 图层（而不是其他layer类别所展现的平面图层）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.3076923076923&quot;&gt;&lt;td scope=&quot;row&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartz/qccompositionlayer&quot; target=&quot;_self&quot;&gt;QCCompositionLayer&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;用于渲染一个Quartz Composer 合成品 (OS X only)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;为Layer提供contents&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layers是管理（由APP提供）content的数据对象。一个Layer的content由包含要被展现的可视化数据的bitmap所组成。我们可以通过以下三种方式提供bitmap：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·直接将一个image对象关联到Layer对象的content属性上。（对于很少或者不会改变的Layer content而言，这是最好的方式。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·为Layer关联一个代理并让这个代理绘制Layer的content。（对于可能定期或者偶尔改变的Layer content，或者要通过某个对象提供contnent，例如view，这是最好的方式。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·定义一个Layer的子类并且重写他的绘制方法以便提供Layer的contents。（如果我们不得不创建一个Layer的子类，或者如果我们想要去改变Layer基础的绘制行为，这将是最合适的方法。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们单独创建Layer对象时，也是唯一我们需要考虑怎么为Layer提供content的时候，如果我们的APP只包含layer-backed view,我们不必考虑前面提到的如何提供Layer content的方法。Layer-backed views将会尽可能的以最有效的方式为他们关联的Layer提供contents。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;将一个image作为Layer的content&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为一个Layer仅仅是一个管理bitmap image的容器，所以我们直接为Layer的contnent属性关联一个image。将一个图片关联到Layer是很便捷的，并且能让我们轻松的指定一个图片显示到屏幕上，Layer使用我们直接提供大的Image，并且将不会创建那个图片的副本。当我们的APP在多个地方使用同一个图片，这个方式可以节约内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们关联到Layer的图片必须是一个CGImageRef类型。（在OSX v10.6和之后，我们也可以关联NSImage对象。）当关联某个图片的时候，记住要提供和设备的分辨率相匹配的图片。对于Retina屏幕的设备而言，我们需要调整图片的contentsScale属性，更多关于为Layer提供高分辨率contnet可以参见 &lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/SettingUpLayerObjects/SettingUpLayerObjects.html#//apple_ref/doc/uid/TP40004514-CH13-SW6&quot; data-renderer-version=&quot;1&quot;&gt;Working with High-Resolution Images&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;通过代理为Layer提供content&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们的Layer需要动态改变，当需要改变的时候，我们可以使用代理对象来提供或者更新content，在显示的时候，Layer通过调用代理的方法来提供所需要的content。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·如果代理实现了&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097261-displaylayer&quot; target=&quot;_self&quot;&gt;displayLayer:&lt;/a&gt;方法，那么该方法的实现体需要为创建一个bitmap并将该bitmap关联到Layer的content属性中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·如果代理实现了 &lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw&quot; target=&quot;_self&quot;&gt;drawLayer:inContext:&lt;/a&gt;方法，核心动画将会创建bitmap,以及创建用于绘制bitmap的图形context，并调用这个代理方法填充bitmap，此代理方法需要做的就是将所需内容绘制到图形context中。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代理对象必须实现displayLayer: 或者drawLayer:incontext:方法，如果代理同时实现了这两个方法，那么代理仅仅只会执行displayLayer:方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们的APP需要加载或者创建要显示的bitmap的时候，重写displayLayer:方法是最合适的方法。代码清单2-3展示了displayLayer:代理方法的简单实现过程，在这个例子中，代理对象使用一个协助对象来加载所需要的image。代理方法选择显示哪个image取决于它自身的状态变量，这个变量在例子中就是这得自定义的属性displayYesImage。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;Listing 2-3  Setting the layer contents directly&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;- (void)displayLayer:(CALayer *)theLayer {
    // Check the value of some state property
    if (self.displayYesImage) {
        // Display the Yes image
        theLayer.contents = [someHelperObject loadStateYesImage];
    }
    else {
        // Display the No image
        theLayer.contents = [someHelperObject loadStateNoImage];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果我们没有预先渲染bitmap，或者也没有供创建bitmaps的协助对象，那我们需要通过drawLayer:incontext：方法实现动态绘制content。代码清单2-4展示了drawLayer:incontext:方法的实现。在这个例子中，代理使用设定的宽度和渲染颜色绘制了一个简单的曲线path。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;Listing 2-4  Drawing the contents of a layer&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)drawLayer:(CALayer *&lt;span&gt;)theLayer inContext:(CGContextRef)theContext {
    CGMutablePathRef thePath &lt;/span&gt;=&lt;span&gt; CGPathCreateMutable();
 
    CGPathMoveToPoint(thePath,NULL,&lt;/span&gt;&lt;span&gt;15.0f&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;&lt;span&gt;.f);
    CGPathAddCurveToPoint(thePath,
                          NULL,
                          &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;.f,&lt;span&gt;250.0f&lt;/span&gt;&lt;span&gt;,
                          &lt;/span&gt;&lt;span&gt;295.0f&lt;/span&gt;,&lt;span&gt;250.0f&lt;/span&gt;&lt;span&gt;,
                          &lt;/span&gt;&lt;span&gt;295.0f&lt;/span&gt;,&lt;span&gt;15.0f&lt;/span&gt;&lt;span&gt;);
 
    CGContextBeginPath(theContext);
    CGContextAddPath(theContext, thePath);
 
    CGContextSetLineWidth(theContext, &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    CGContextStrokePath(theContext);
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Release the path&lt;/span&gt;
&lt;span&gt;    CFRelease(thePath);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对于需要自定义content的layer-backed views而言，我们仍然需要充写view的方法来实现绘制。一个Layer-backed view将他的Layer的代理关联给他本身，并实现了所需的代理方法，而且我们也不需要手动改变这个配置，不过，我们需要实现这个layer-backed view的drawRect:方法来绘制我们的content。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;通过子类提供Layer 的content&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果我们需要实现一个自定义的Layer，我们可以重写Layer的绘制方法做各种各样的绘制。不同于Layer对象自身生成自定义的content，layer需要管理这个用于显示的content（这句话应该是指的是相对于指定image提供content的方式）。例如，CATiledLayer类管理一个大的image的原理是：通过讲image分隔成许多小的可以单独管理和绘制的片段，由于这个Layer有关于在何时需要渲染那一个片段的信息，他直接管理了整个绘制行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当自定义子类的时候，我们需要实现下面两种绘制content的方式之一：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·重写子类的display方法，并直接在该方法中设置contents属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·重写子类的drawInContext:方法并且使用他在该图形context中进行绘制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择重写那种方法取决于我们需要控制绘制过程的程度。display方法是对于更新Layer的content的完全控制，因此重写该方法将使我们完全控制绘制的过程。重写display方法也意味着我们需要创建CGImageRef并将其关联到content属性。如果我们仅仅想要绘制content（或者让我们的layer管理绘制操作），我们可以重写drawInContext:方法，并让Layer创建后备存储。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;对我们提供的content进行调整&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当将一个image关联到Layer的content属性时候，Layer的contentGravity属性决定了那个图片将被如何调整为了适应当前的bounds。默认的如果一个图片是比当前的bounds更大或者更小的，Layer对象就会缩放这个图片以便适应可用的空间，如果Layerbounds的宽高比是不同于image的宽高比，这将会引起图片显示效果不完全，我们可以使用contentsGravity属性来确保content以最好的方式展现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可供使用的contentsGravity类型被分为两大种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·基于position的重力常量，使我们可以在无缩放的情况下，从bounds的某个边或者角铺展image。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　·基于缩放的重力常量，使我们可以以某几种方式之一伸缩image，有些选项可以维持宽高比，有些将不维持image的原有宽高比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2-1展示了基于点的重力设置对image的影响。除了&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/kcagravitycenter&quot; target=&quot;_self&quot;&gt;kCAGravityCenter&lt;/a&gt;常量的使用，其他的常量将会以image bounds的某个边或者角来铺展image。kCAGravityCenter常量将image从中心开始铺展。这类常量不会引起图片的伸缩，因此image会按照原来的尺寸进行渲染。如果image是大于Layer的bounds，这将会导致image一部分被裁减掉，如果image的尺寸是小于Layer的bounds，如果设置了layer的背景色，空缺的部分将会显示Layer的背景色。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 2-1  Position-based gravity constants for layers&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180124002204912-1187243614.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图2-2展示了基于缩放的重力常量如何影响image显示的。如果image的尺寸和Layer的bounds不一致，所有的这些常量将会缩放image。这些常量的不同之处在于如何调整这些图片原来的宽高比，其中有些模式是保持原来的宽高比，还有一些将会改变原来的宽高比。默认情况下Layer的contentsGravity属性是被设置为&lt;code&gt;&lt;a class=&quot;urlLink&quot; href=&quot;https://developer.apple.com/documentation/quartzcore/kcagravityresize&quot; target=&quot;_self&quot;&gt;kCAGravityResize&lt;/a&gt; 常量，这是该类型中唯一不保持图片原有宽高比的图片。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span class=&quot;caption_number&quot;&gt;Figure 2-2  Scaling-based gravity constants for layers&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180124003021615-3138327.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;如何使用高分辨率的Images&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layers本身并不知道所在设备屏幕分辨率。Layer仅仅存储指向bitmap的指针并使用所给定的可利用的像素按照尽可能好的方式展现。如果我们将一个Image关联到一个Layer的content属性，我们必须通过设置Layer的contentScale属性告诉核心动画Image的分辨率。ContentScale属性的默认值是1.0，这只适用于那些将要显示到标准分辨率屏幕的Image，如果我们的Image想要显示到Retina屏幕上，那么我们就必须设置这个属性为2.0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果我们直接关联一个bitmap到Layer，那么我们就需要设置contentScale的属性。为了适配屏幕的分辨率和被View管理的content，UIKit 和AppKit框架中 layer-backed view会自动设置Layer的缩放因子。例如，在OSX中，如果我们关联一个NSImage对象到Layer的contnet属性，AppKit将会查找标准和更高分辨率的Image，如果都有，那么AppKit将会使用正确的分辨率的image来设置contentScal的属性&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;调整Layer的可视化风格和展示样式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Layer对象可以创建可视化的配件来增添Layer的主要contents，例如边框和背景色。这些可视化的配件不需要我们自己做任何的渲染工作，因此在某些情况下就可以使用Layer作为单独的整体。所有需要我们做的仅仅是设置Layer的属性，Layer将会处理所需的绘制工作，当然也包含任何动画。对于可视化配件是如何影响Layer显示的说明可以参见 &lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/LayerStyleProperties/LayerStyleProperties.html#//apple_ref/doc/uid/TP40004514-CH10-SW1&quot; data-renderer-version=&quot;1&quot;&gt;Layer Style Property Animations&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span class=&quot;content_text&quot;&gt;Layer有他们自己的背景和边框&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;content_text&quot;&gt;除了他的基于image的content之外，一个Layer可以显示填充的背景和填充的边框。背景色是在Layer的content后面渲染的，边框是在image的content的上面渲染的，就像图2-3所示。如果Layer包含子Layer，他们也出现在边框的下面。由于背景色是放置在image的后面的，image的透明的部分将会显示背景色。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;content_text&quot;&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 2-3  Adding a border and background to a layer&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;content_text&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180124233419803-663052279.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;298&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;代码清单2-5显示设置Layer的背景色和边框所需要的代码，所有这些属性都是可动画的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
myLayer.backgroundColor =&lt;span&gt; [NSColor greenColor].CGColor;
myLayer.borderColor &lt;/span&gt;=&lt;span&gt; [NSColor blackColor].CGColor;
myLayer.borderWidth &lt;/span&gt;= &lt;span&gt;3.0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：我们可以使用任何颜色作为Layer的背景色，包括带有透明分量的颜色或者使用样品image。当使用样品image的时候，要注意Core Graphics 处理图片的渲染，以及在此处理图片渲染的过程中将使用标准坐标系统，标准坐标系统和iOS中默认的坐标系统是不同的。在iOS上默认情况下，图片渲染是上下颠倒的，除非我们调整坐标系统。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果我们设置Layer的背景色为不透明的颜色，那么我们应该讲Layer的opaque属性设置为YES，这么做将会提升性能当合成该Layer到屏幕上显示时候，并消除了layer 作为辅助存储时候管理的透明通道。如果Layer有非0的圆角，我们就不必将该Layer标记为不透明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;Layer支持圆角&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过添加corner radius，我们可以为Layer创建圆角效应。corner radius是一个可视化配件，它可以遮盖Layer的四角让下面的content显示出来。就像图2-4显示的。它涉及到透明遮罩的应用，corner radius不影响image的Layer中的content属性，除非设置masksToBounds属性为YES。然而，corner radiu 一直影响Layer的背景色和边框的绘制。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 2-4  A corner radius on a layer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180124235551725-223424862.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;350&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;为了将corner radius应用到Layer，我们需要为Layer的cornerRadius属性指定一个值。圆角的指定单位是points，并且显示的时候，它将会预先应用到Layer的四个角。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;Layer支持内建阴影&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CALayer 类包含几个为配置阴影效应的属性。阴影会通过让它看起来像是漂浮在content下面的方式来为Layer添加深度。这是另外一种可视化的配件，当APP需要的时候可以使用。对于Layer而言我们可以控制阴影的颜色，相对于content的位置，不透明度，和形状。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Layer阴影的不透明度默认被设置为0，这将会有效的隐藏阴影。改变一个透明度为非零的值，将会引起核心动画绘制阴影。阴影默认是被直接放置在Layer的下面的，为了能够看到阴影，我们也需要调整阴影的偏移量。有个很重要的事情需要记住，我们为阴影指定的偏移量是基于Layer的本地坐标系统的，也就是说在iOS和OSX 上面是不同的。如图2-5展示了一个偏向右下的阴影，在iOS中，需要指定一个正数在Y轴分量上，但是在OSX 上就需要指定为负值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;caption_number&quot;&gt;Figure 2-5  Applying a shadow to a layer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/764024/201801/764024-20180125001319397-544400452.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当为Layer添加阴影的时候，阴影就是Layer的content的一部分，但是实际上阴影有可能超出Layer的边界，如果开启Layer的maskToBounds属性那么阴影的效应将会在Layer的边界处被裁剪，这将会产生一个奇怪的现象，那就是在Layer的内部的阴影是显示的，但是在Layer的边界外部的阴影缺看不到。如果我们想要显示完整的阴影并且还想使用bounds masking，我们就应该使用两个Layer而不是一个，将mask应用到包含content的Layer上，然后将这个Layer嵌入到第二个Layer上，第二个Layer的尺寸和第一个的尺寸一样，第二个Layer上设定阴影效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多关于如何Layer上如使用阴影可参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/LayerStyleProperties/LayerStyleProperties.html#//apple_ref/doc/uid/TP40004514-CH10-SW18&quot; data-renderer-version=&quot;1&quot;&gt;Shadow Properties&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;为Layer添加自定义属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CAAnimation 和CALayer 类延伸了KVC以便支持自定义属性。我们可以其使用这个特性为Layer添加数据，然后通过自定义的属性获取该数据。我们甚至可以关联actions到自定义的属性中，进而达到当修改这个属性的时候，对应的动画将会被执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为更多的信息关于如何使用和设置自定义属性，可以参见 &lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW3&quot; data-renderer-version=&quot;1&quot;&gt;Key-Value Coding Compliant Container Classes&lt;/a&gt;。为更多的信息关于添加actions到Layer对象，可以参见 &lt;span class=&quot;content_text&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html#//apple_ref/doc/uid/TP40004514-CH7-SW1&quot; data-renderer-version=&quot;1&quot;&gt;Changing a Layer’s Default Behavior&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;打印Layer-backed View的内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在打印期间，Layer 会重绘他们的contents为了适配打印环境。核心动画正常情况下依靠缓存的bitmap当渲染到屏幕上的时候，然而他将会重绘制content当打印的时候。尤其，layer-backed view使用drawRect:方法提供Layer 的content，当打印的时候，核心动画将再次调用drawRect：来生成需要打印的Layer的content。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 25 Jan 2018 05:40:00 +0000</pubDate>
<dc:creator>开机按钮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouyubo/p/8324847.html</dc:identifier>
</item>
<item>
<title>[谨记]记线上事故并分析原因 - 资深Tester_王豆豆</title>
<link>http://www.cnblogs.com/evangline/p/8350825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evangline/p/8350825.html</guid>
<description>&lt;p&gt;昨天下午大神把组内几十号人召集在一起开Online bug分析大会，主要是针对近期线上事故从事故原因和解决方案两个维度来分析&lt;/p&gt;
&lt;p&gt;对金融软件来说，每一次的线上事故都有可能给公司带来重大的损失，少扣了用户的钱，为公司带来资金方面的亏损；多扣了用户的钱，则为带来不必要的合约或法律纠纷，故测试金融软件不比其他行业的软件，后者线上bug大多不会直接引起资金方面损失，最多就是用户体验不好，功能没有实现，导致用户量的流失。&lt;/p&gt;
&lt;p&gt;对金融软件来说没有小bug，一旦出现bug那就是重大的bug，必须引起高度重视。&lt;/p&gt;
&lt;p&gt;俗话说”人非圣贤，孰能无过“，软件是由人编写的，所以再所难免都会有问题，而我们所要做就是尽量避免出现问题，或者是避免出现重复的问题。&lt;/p&gt;
&lt;p&gt;对于软件测试人员来说分析线上BUG是非常好的一个措施，这样可以检测到测试人员在测试过程中哪些地方考虑不周，或没有考虑到，从而可以提醒测试人员下次思考的范围扩大，尽可能地完全覆盖测试范围。&lt;/p&gt;
&lt;p&gt;从分析结果的角度出发，线上bug大多都是开发人员和测试人员麻痹大意所导致的，并不是不可避免的。 &lt;/p&gt;
&lt;p&gt;经过分析得出线上的bug出现的原因基本有以下几类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.开发人员使用java框架错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.开发人员上线时合并代码不仔细，导致代码有遗漏&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.测试人员回归测试流程不全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.多系统一起上线，缺少联调或者联调不全&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;01 &lt;strong&gt;开发人员使用java框架错误&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这个问题已经出现了两次，在8月份就出现过一次，原因就是&lt;strong&gt;开发人在使用多线程时，将多例使用成单例，导致系统在高并发进出现了串数据的现象，导致系统在处理时放错款，将A的钱放到B的账户中去了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然使用单例能节省资源，降低系统的占用率，但这种情况并不合适目前的系统。&lt;/p&gt;
&lt;p&gt;而此中情况在测试过程中并不一定能测试出来，这种出现的机率不定，必须在数据高并发时才有可能出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：技术问题，将单例修改成多例。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;02 &lt;strong&gt;开发人员上线时合并代码有遗漏&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;开发人员上线时删除了master中的某行代码，引起有个变量没有定义，导致上线之后某功能失效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发人员将git分支上的代码合并到master时，master提示某一行代码没有，开发人员就将分支上的代码删除再合并到master，等将代码上线之后，导致某个功能失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案1：开发人员将代码合并到master时，先将master上的代码拉到一个新分支上，然后再将要合并的代码合到新分支上，最终将新分支上的代码合并到master上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案2：开发人员建立良好的习惯，在开发某个项目时，每天（固定频率）都将master上的代码合并到自己代码的分支上&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;03 &lt;strong&gt;测试人员回归测试不全==漏测&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;说是回归测试不全，其实就是相当于一定程度上的漏测，漏测应该是软件测试人员尽量避免，一般漏测是因为测试人员思考不全，导致某个方面没有测试到。&lt;/p&gt;
&lt;p&gt;这次线上bug分析有以下几个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回归测试时，验证某个流程，但只验证到任务创建，就没有执行任务，上线后，该任务创建后执行会报错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未测试幂等性，上线后，导致两次返回的结果不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发修改某一个bug，回归测试未回归以前的流程，导致上线后，原来正常的流程执行不通过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.回归测试时，主流程必须回归，并且有完整的回归步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.一个业务流程测试必须跑完一个完整流程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.测试过程中一定要细致，不能遗漏重要的点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;软件中的bug不可能完全测试出来，但最不应该出现的就是原本是正确的流程或功能，经过版本改动，在后期又出现，但测试人员再次测试时竟然没有发现，像这种情况是软件测试人员最应该避免的，所以回归测试很重要，不仅要回归主要流程，还需要回归修改bug相关的代码部分。&lt;/p&gt;
&lt;p&gt;解决回归测试流程测试不全最好的解决方案就是引入自动化，就目前我们的系统不够成熟，改动太多，业务流程或需求都不稳定，所以自动化测试还未正式引入。&lt;/p&gt;
&lt;h3&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibMKy8HUJP5mLM8dibFyIWkAo5WJ2p6ZqmIZQsDn0icu6TNGaG3Iqf6mYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt;04 &lt;strong&gt;多系统一起上线，缺少联调或联调不全&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为联调出现问题也不再是一次二次了，为什么联调会出现问题呢？&lt;/p&gt;
&lt;p&gt;公司业务是由有多个系统组成的，同时还需要调用其他公司业务接口，测试人员在测试时调用相关系统接口时模拟返回或回调，基本都是使用的mock，mock返回的值并不是真的从相应系统的返回值，所以如果联调测试时没有把握好，就非常容易出现问题。&lt;/p&gt;

&lt;p&gt;在测试过程中联调就非常重要，但由于联调测试人员的放松，对联调内容的遗漏，导致业务上线之后：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.调用某查询任务，对方会一直返回处理中，导致流程卡住。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.A系统回调B系统失败，原因是编码方式不一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.某系统功能失败后，调用查询接口报错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.调用某系统，应返回code=1，结果返回code=0，导致业务处理错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上问题都是由于系统之间的调用或回调导致的线上bug。&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在联调之前先将自己系统中本次项目所有用例测试完全。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.编写联调用例，并且与多方测试人员沟通，确保联调用例能全面覆盖业务流程和任务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.在联调时，确保所有业务流程是全部走通，且返回的值正确。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFxq0S8A2pXpJvtCzOCL9YJKqN6BniaNhZ1WibiayLlwqsibiaxnumEYgrh85dStFPJAJVziaLX4BsRgS0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;
&lt;p&gt;联调测试与平时的功能测试重点和关注点都不同：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.联调测试保证业务流程是通的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.联调测试时要检查其他系统返回来的数据是否正确?检查相同数据在各个系统存的值是否相同？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.检查推送的报文mapping与其他系统接口文档中的mapping是否一致（映射）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此次线上BUG分析再次验证程序中的bug就是人为的，避免这些情况就需要开发人员在开发过程中多注意，培养良好的编程习惯，而测试人员在测试过程中需要将测试范围考虑完全，尽量避免遗漏测试点，对于不清楚的点，不管是开发还是测试人员，都应该拿出来讨论，切忌闭门造车，不懂装懂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;大家可以一起来说说你们线上发生了哪些重大事故？让你开始引以为戒了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎关注王豆豆的微信公众号：资深Tester(zishentester)，了解更多的好文，和王豆豆一起成长。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 05:33:00 +0000</pubDate>
<dc:creator>资深Tester_王豆豆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evangline/p/8350825.html</dc:identifier>
</item>
<item>
<title>设计模式之策略模式在地铁票价系统中的应用 - 阿子</title>
<link>http://www.cnblogs.com/yayazi/p/8350679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yayazi/p/8350679.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;设计模式是面向对象编程的一个非常精彩的部分。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性，它能帮助我们将应用组织成容易了解，容易维护，具有弹性的架构。本文通过一个简单的案例来讲述策略模式在地铁票价系统中的应用。&lt;/p&gt;
&lt;h2 id=&quot;案例描述&quot;&gt;案例描述&lt;/h2&gt;
&lt;p&gt;乘客从一个车站乘坐地铁到另一个车站，他/她需要购买一张票。铁路部门对于票价有一些特别的票价规定：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;按照市物价主管部门批复的轨道交通网络票价体系，即：轨道交通实行按里程计价的多级票价，0~6公里3元，6公里之后每10公里增加1元;票价计算采用最短路径法，即：当两个站点之间有超过1条换乘路径时，选取里程最短的一条路径作为两站间票价计算依据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;案例分析&quot;&gt;案例分析&lt;/h2&gt;
&lt;p&gt;让我们考虑有20个站点：1s，2s，3s......20s，并且乘客在不同的场景下乘坐地铁。为了更清晰的讲述问题，我们在原有定价标准上虚拟了一些应用场景。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果乘客A乘坐的里程小于6公里，那么他将需要支付3元车票费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果乘客B乘坐的里程大于6公里，他将需要额外支付超出部分的车票费用，计费标准为6公里之后每10公里增加1元。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果乘客C是VIP客户，那么他将在原计费标准上享受9折优惠。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果后续有一些额外收费或额外优惠，在以上计费基础上再进行调整。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;这个问题可以通过使用“策略设计模式”来解决。因为不同类型的票价策略可以基于不同的规则来应用。 以下是票价策略的不同类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本票价规则战略&lt;/li&gt;
&lt;li&gt;VIP票价规则策略&lt;/li&gt;
&lt;li&gt;额外的票价规则策略&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每张票价规则策略将分别写入票价计算算法，这些算法不会相互干扰。 新的票价规则可以添加和写入新的票价规则策略。这种模式也将遵循“对扩展开放、对修改关闭”的理念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖关系图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/4yrVtyG.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;类图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/iKagQ4Z.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IFareStrategy接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个接口定义了票价计算的常用策略，实现一个类可以实现基于上下文的票价算法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using TrainFair.Models;    
namespace TrainFair.FareCalculator  
{  
    public interface IFareStrategy {  
        float GetFare(IFareRule ruleValues, float basicFare);  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FareConstants类&lt;/strong&gt;&lt;br/&gt;FareConstants定义了计费的规则，包括起步价，超出里程递增价及VIP折扣价。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace TrainFair.Constants
{
    public class FareConstants {
        public const float BasicFare = 3.0F;
        public const float OnStationFare = 1.0F;
        public const float VIPDiscount = 0.1F;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StationRuleFareCalculator类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;StationRuleFareCalculator类根据行驶的车站里程和问题陈述部分定义的一些规则集来计算车费。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System;  
using TrainFair.Models;  
  
namespace TrainFair.FareCalculator  
{  
    public class StationRuleFareCalculator : IFareStrategy  
    {  
        public float GetFare(IFareRule ruleValues, float basicFare) {  

            var stationFareRuleModel = ruleValues as StationFareRuleModel;  
             if (stationFareRuleModel == null || stationFareRuleModel.StationDistance &amp;lt;= 0.0f)
                return 0;
            
            if (stationFareRuleModel.StationDistance &amp;lt; 6)
                return basicFare;

            int restChargingStations = (int)Math.Ceiling((stationFareRuleModel.StationDistance - 6.0f)/10.0f);
            var totalFare = basicFare + restChargingStations * stationFareRuleModel.IncrementalPrice;           

            return totalFare;
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;VIPRuleFareCalculator类&lt;/strong&gt;&lt;br/&gt;这个类实现的是VIP的票价算法。如果乘客是VIP身份，那么他/她将得到享受特殊的优惠。这个类实现了这个算法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using TrainFair.Models;  
  
namespace TrainFair.FareCalculator  
{  
     public class VIPRuleFareCalculator : IFareStrategy
    {
        public float GetFare(IFareRule ruleValues, float basicFare) {
            var vipFareRuleModel = ruleValues as VIPFareRuleModel;
            if (vipFareRuleModel == null)
                return 0;
           
            var totalFare = basicFare - (basicFare * vipFareRuleModel.Discount);
            return totalFare;
        }
    }
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;OtherRuleFareCalculator类&lt;/strong&gt;&lt;br/&gt;这个类实现的是其他额外的费用或优惠票价的算法。一些额外的价格将被添加到总费用中。额外的价格可以是附加收费（正值），也可以是额外折扣（负值）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using TrainFair.Models;  
  
namespace TrainFair.FareCalculator  
{  
    public class OtherRuleFareCalculator : IFareStrategy
    {
        public float GetFare(IFareRule ruleValues, float basicFare) {
            var otherFareRuleModel = ruleValues as OtherFareRuleModel;
            if (otherFareRuleModel == null)
                return basicFare;

            float totalFare = basicFare + otherFareRuleModel.AdditionalFare;
            return totalFare;
        }
    }
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;FareRuleCalculatorContext类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using TrainFair.Models;  
  
namespace TrainFair.FareCalculator  
{  
    public class FareCalculatorContext {  
  
        private readonly IFareStrategy _fareStrategy;  
        public FareCalculatorContext(IFareStrategy fareStrategy) {  
            this._fareStrategy = fareStrategy;  
        }  
  
        public float GetFareDetails(IFareRule fareRules, float basicFare)  
        {  
            return _fareStrategy.GetFare(fareRules, basicFare);  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码结构里有一些基于车站票价，VIP票价，额外票价等情况的model类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IFareRule接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是基本票价规则模型接口，每个模型类都实现它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace TrainFair.Models  
{  
    public interface IFareRule  
    {  
        int FareRuleId { get; set; }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StationFareRuleModel类&lt;/strong&gt;&lt;br/&gt;这个类定义的是车站票价规则的基本属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace TrainFair.Models  
{  
    public class StationFareRuleModel : IFareRule  
    {  
        public int FareRuleId { get; set; }

        public int  StationsCounts { get; set; }

        public float IncrementalPrice { get; set; }

        public float StationDistance { get; set; }  
    }  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;VIPFareRuleModel类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类定义了VIP折扣的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace TrainFair.Models  
{  
    public class VIPFareRuleModel : IFareRule  
    {  
        public int FareRuleId { get; set; }       

        public float Discount { get; set; }
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;OtherFareRuleModel类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类定义其他额外收费的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace TrainFair.Models  
{  
    public class OtherFareRuleModel : IFareRule  
    {  
        public int FareRuleId { get; set; }  
  
        public string OtherFareName { get; set; }  
  
        public float AdditionalFare { get; set; }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型的属性可以根据未来的需求进行增强和调整，并可以灵活应用在算法类中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是控制台输出：&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/lIXYFnR.jpg&quot;/&gt;&lt;br/&gt; &lt;br/&gt;本文结尾附上了程序代码。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;车站基础票价、VIP票价、额外票价等不同类型的票价计算规则是不同的，所有的算法都被分解到不同的类中，以便能够在运行时选择不同的算法。策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。策略模式使得算法或逻辑可以在不影响到客户端的情况下发生变化。说到策略模式就不得不提及OCP(Open Closed Principle) 开闭原则，即对扩展开放，对修改关闭。策略模式的出现很好地诠释了开闭原则，有效地减少了分支语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序代码&lt;/strong&gt;：&lt;a href=&quot;https://github.com/daivven/TrainFair&quot;&gt;https://github.com/daivven/TrainFair&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 25 Jan 2018 04:56:00 +0000</pubDate>
<dc:creator>阿子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yayazi/p/8350679.html</dc:identifier>
</item>
<item>
<title>JavaScript八张思维导图 - 小小程序猿（^_^）</title>
<link>http://www.cnblogs.com/lidgblogs/p/8350276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lidgblogs/p/8350276.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342564.html&quot; target=&quot;_blank&quot;&gt;JS基本概念&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342654.html&quot; target=&quot;_blank&quot;&gt;JS操作符&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342658.html&quot; target=&quot;_blank&quot;&gt;JS基本语句&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342677.html&quot; target=&quot;_blank&quot;&gt;JS数组用法&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342681.html&quot; target=&quot;_blank&quot;&gt;Date用法&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342667.html&quot; target=&quot;_blank&quot;&gt;JS字符串用法&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342689.html&quot; target=&quot;_blank&quot;&gt;JS编程风格&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342691.html&quot; target=&quot;_blank&quot;&gt;JS编程实践&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;不知不觉做前端已经五年多了，无论是从最初的jQuery还是现在火热的Angular，Vue，React等前端框架，甚至是nodejs等服务端的兴起，归根到底，我始终觉着一切的核心还是&lt;strong&gt;JavaScript&lt;/strong&gt;。于是最近就有了一个想法，想要梳理一下这些年学习以及使用JS的心得。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本系列文章主要是针对JS的相关知识点做一个类似提纲似的提炼，一来可以作为今后温故知新的参照；二来也是希望能够帮助大家更加系统清晰的理解JS这门语言。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本系列文章主要参照了Nicholas C. Zakas 的两本著作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《JavaScript高级程序设计（第3版）》及《编写可维护的JavaScript》&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342564.html&quot; target=&quot;_blank&quot;&gt;JS基本概念&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125105946600-807277281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342654.html&quot; target=&quot;_blank&quot;&gt;JS操作符&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110035053-1062793248.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342658.html&quot; target=&quot;_blank&quot;&gt;JS基本语句&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110103225-2075947909.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342677.html&quot; target=&quot;_blank&quot;&gt;JS数组用法&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110123365-732430445.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342681.html&quot; target=&quot;_blank&quot;&gt;Date用法&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110149084-1391215200.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342667.html&quot; target=&quot;_blank&quot;&gt;JS字符串用法&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110220459-1298862204.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342689.html&quot; target=&quot;_blank&quot;&gt;JS编程风格&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110245897-473277034.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342691.html&quot; target=&quot;_blank&quot;&gt;JS编程实践&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lidgblogs/p/8342564.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690443/201801/690443-20180125110306569-173187469.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 25 Jan 2018 04:45:00 +0000</pubDate>
<dc:creator>小小程序猿（^_^）</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lidgblogs/p/8350276.html</dc:identifier>
</item>
<item>
<title>谈谈大学实习这一年。 - 会读bug的小蚂蚁</title>
<link>http://www.cnblogs.com/ant-killer/p/8350632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ant-killer/p/8350632.html</guid>
<description>&lt;p&gt;　　2016年8月份，我刚刚大学毕业，怀着对未来的憧憬，步入了这个色彩斑斓的社会。说实话，大专学历找工作确实不容易，每次在前台登记的时候看着一大排的本科研究生，羞于提笔写下大专二字，辗转一个月，没有找到合适的工作，有些心急，有些焦躁，有些不安，然而人一旦自己乱了阵脚，就是万丈深渊的开始。在我踏入北京市苏州街亿方大厦的第一步开始，就是万丈深渊的第一步，面试我的人是一个销售，课程销售（后来才知道她的身份），她随便问了一个问题，然后告诉我，现在可以安排你入职，但是我们有入职培训，是有偿的，培训的费用是从你入职以后的工资里按月扣除。我思索了一下，答应了。&lt;/p&gt;
&lt;p&gt;　　那个销售，随手抽出来两张表格，具体内容已经忘记了，就是一些简单的基本信息，然后让我拍了两张手持表格的照片，就这么略显简陋的信息，在51帮学的平台上给我办理了两万一千八百元的贷款，当时对这些并不了解，她说这个款项，是按月从工资里扣除的。就这样，暂时的现在这里安顿了下来。就这样，这个噩梦开始了。&lt;/p&gt;
&lt;p&gt;　　所谓的入职培训持续了几周，越想越感觉事情有点不对劲，第一个月，某某公司给了2000元的酬劳，每天教一些简单的div+css，这些我高中就已经玩剩下的东西。慢慢的我开始浮躁起来，我认为自己在浪费时间，后悔了，我去联系51帮学的平台，要求退款，退出这个所谓的入职培训。51帮学的平台回答说，钱已经到了某某公司的账户，需要去跟公司交涉，才能退款。我找到了公司当时给我办理手续的销售，几经交涉，她答应我结束入职培训，直接安排面试机会，但是不保证成功。现在回想一下，当时应该直接打110找警察蜀黍，不然也不会落得现在这个下场。&lt;/p&gt;
&lt;p&gt; 　　我是学计算机专业的，大学里就已经有过几个小一些的上线项目，却安排我去做了一个文员，被那笔贷款压得不得不赶紧找个工作，来偿还这笔费用，事情到了这里原本应该已经结束，月薪5500+提成几个月就可以还完了。但是你永远不知道明天和意外，哪儿个会先来。&lt;/p&gt;
&lt;p&gt;　　贷款还了一半的时候，心思有些活络过来，不满足于现状，高中三年，大学三年，学了六年的编程，岂是说放下就能放下的？programmer？（要不说年轻人就是年轻，做事从来不考虑后果，19岁的小屁孩懂个屁啊）毅然决然的选择了裸辞。计划回家一个月，慢慢的捡捡丢下的枝枝蔓蔓，回来继续找开发类的工作。&lt;/p&gt;
&lt;p&gt;　　一个月的时间，眨眼间就过去了，当自己满怀信心再次来的北京时，面对的是冰冷的现实。&lt;/p&gt;
&lt;p&gt;　　有一句话，男人最无奈的事情就是在你无能为力的年纪遇上了想守护终生的人。&lt;/p&gt;
&lt;p&gt;　　咬着牙，拿出了几千块的积蓄在北京和大学女友租了一间房子，然后自己开始慢慢找工作，结果发现，高不成低不就，大公司招收实习生普遍学历要求较高，小公司学历要求较低，但是要求项目经验，希望人一来就能创造收益。眼看着找不到工作，积蓄已经捉襟见肘，51帮学也到了还款日期。第一次迫切的体验到了一分钱难倒英雄汉这种话的含义，更何况我不是什么英雄，我只是一个普通人。&lt;/p&gt;
&lt;p&gt;　　人，在有些时候确实是一个可怕的动物，它会为了达到目的，不择手段。  至少，现在我就是这样。&lt;/p&gt;
&lt;p&gt;　　我在上班的时候注册了百度钱包，额度是3万6.一方面为了生存，一方面为了面子，我开始了自己的借贷生涯，（后来才明白，这就是传说中的网贷）。后来的时候发现网贷的人都有一个特性，那就是 我认为自己能掌控的住自己，我认为我能还的起。&lt;/p&gt;
&lt;p&gt;　　回想起一句话，就怕你碌碌无为，还安慰自己平凡可贵，何为平凡？&lt;/p&gt;
&lt;p&gt;　　每次借钱的时候都安慰自己，等自己找到工作以后，按月还了就好了。（从来没考虑过，如果没有找到工作呢？如果没有控制住自己呢？）有句俗话说的好，由俭入奢易，从奢入简难。三万六的额度很快让自己挥霍一空。以至于自己再次借钱的时候，看着借贷剩余金额零的时候，自己都有些发懵。钱呢？  钱都去哪儿了啊？ 短短三个月。消费了近四万元。这让自己怎么还啊。&lt;/p&gt;
&lt;p&gt;　　前前后后借贷了十几笔，看着账单自己心里默默发苦，嘴角扦着一抹弧度，不知是苦涩还是悔恨。  事情发生了总要解决，我开始从网上浏览各种借贷信息，打算以贷养贷，殊不知这是一条不归路，由于之前借贷了十几笔，导致征信被查次数过多，没有一家借贷公司会借给我，缺乏常识不了解，原以为自己没有逾期，借钱应该很容易，没成想信誉根本不是这么计算的。眼看着还款日期到来，心情又称沉重了一些。&lt;/p&gt;
&lt;p&gt;　　每天晚上开始失眠，不敢抬头去看女友的眼睛，即便是行走在路上，也会觉得别人看自己的眼神奇奇怪怪的。慢慢的心里压力越来越大，开始去浏览一些论坛，“借了网贷还不起，想上岸怎么办，”有些人说可以借高利贷给我，我不敢。我怕我更还不起。有些人说，可以给我办几张信用卡下来，先养着，但是酬劳是信用卡额度的十分之一。我也没有接受。终于有一天还是被女友发现了自己不对劲，一番逼问之下，我把事情和盘托出，我甚至都已经做好了，她会离开我的准备，自己最后人财两空，还背了一屁股的债务。&lt;/p&gt;
&lt;p&gt;　　她说，“我能借到9000块钱，你拿去先还上吧。&quot;，我眼神闪烁了一下，思绪万千。然后故作欢笑的说：”没事儿，就这点小事儿还压不倒我，相信我，我能解决。“（不管怎么样，哪怕违约，也不能让这个女孩儿，体验到我这种欠债的感觉，感觉欠下了整个世界。）&lt;/p&gt;
&lt;p&gt;　　如果说这世界上真的有一种贷款，可以不用还，没有利息，那只有一种，那就是欠下的父母的债。事情最终还是被父母知道了。跟想象中的一样，我被骂得狗血淋头，最后父亲问我，知道为什么骂你嘛？   我说：因为我没有赚到钱分担家务，还欠下了这一大笔钱。实在不孝顺。 父亲说，你年轻，不怪你，就当为你的经验不足买单，我骂的是你眼里还有没有这个家，有没有这个爹，出了事儿为什么不跟家里说！（眼神里不知道什么时候布满了水雾，不知道是我的还是父亲的，整个人就像活在了悔恨里一样。）&lt;/p&gt;
&lt;p&gt;　　最终家里帮我还了这笔贷款，我从这场龙卷风的风眼里脱离了出来，是家人把我拖出来的，每每闭上双眼，脑海里全是悔意，子女欠父母的下辈子也还不完。&lt;/p&gt;
&lt;p&gt;　　事情远远没有结束，也不会这样结束，未来的时光还很长，我二十岁。谨以余生敬时光。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jan 2018 04:05:00 +0000</pubDate>
<dc:creator>会读bug的小蚂蚁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ant-killer/p/8350632.html</dc:identifier>
</item>
</channel>
</rss>