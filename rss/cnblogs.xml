<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解.NET Core的基元: deps.json, runtimeconfig.json, dll文件 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9704702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9704702.html</guid>
<description>&lt;blockquote readability=&quot;1.8461538461538&quot;&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://natemcmaster.com/blog/2017/12/21/netcore-primitives/&quot;&gt;Deep-dive into .NET Core primitives: deps.json, runtimeconfig.json, and dll's&lt;/a&gt;&lt;br/&gt;作者： &lt;a href=&quot;https://natemcmaster.com/profile/&quot;&gt;Nate McMaster&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C#的编译器可以将cs文件转换为dll文件, 即程序集文件。程序集文件是一个便携的可执行格式文件, 借助.NET Core,它可以运行在Windows, MacOS和Linux系统中。&lt;/p&gt;
&lt;p&gt;在Windows系统中, .NET Core的编译器文件csc.dll存放在以下目录中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\Program Files\dotnet\sdk\[.NET Core 版本号]\Roslyn\bincore&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;笔者使用了2.1.400版本，所以编译器存放目录是C:\Program Files\dotnet\sdk\2.1.400\Roslyn\bincore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;.NET Core编译器文件&lt;code&gt;csc.dll&lt;/code&gt;也是一个.NET Core应用程序，所以你可以使用&lt;code&gt;dotnet&lt;/code&gt;命令直接执行编译器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;dotnet C:\Program Files\dotnet\sdk\2.1.400\Roslyn\bincore\csc.dll --help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们尝试手动编译一个cs文件。&lt;br/&gt;首先我们先创建一个&lt;code&gt;Program.cs&lt;/code&gt;文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Program.cs */
class Program
{
    static void Main(string[] args)
        =&amp;gt; System.Console.WriteLine(&quot;Hello World!&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们使用命令行命令将其编译&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;dotnet &quot;C:\Program Files\dotnet\sdk\2.1.400\Roslyn\bincore\csc.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Runtime.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Console.dll&quot; 
-out:Program.dll 
Program.cs&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参数说明&quot;&gt;参数说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;C:\Program Files\dotnet\sdk\2.1.400\Roslyn\bincore\csc.dll&quot;&lt;/code&gt;是编译器所在的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-reference&lt;/code&gt;参数表示编译中需要引用的dll, 该参数可以指定多个dll , 例子中我们引用了System.Runtime.dll和System.Console.dll&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-out&lt;/code&gt;参数表示编译生成的dll路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Program.cs&lt;/code&gt;表示编译的源文件地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Program.cs&lt;/code&gt;编译成功, &lt;code&gt;Program.dll&lt;/code&gt;生成完毕。&lt;/p&gt;

&lt;p&gt;对于.NET Core应用程序来说&lt;code&gt;runtimeconfig.json&lt;/code&gt;是不可或缺的。它是用来配置运行时的。&lt;/p&gt;
&lt;p&gt;如果缺少了这个文件，运行dll文件的时候会产生以下异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;dotnet Program.dll
A fatal error was encountered. The library 'hostpolicy.dll' required to execute the application was not found in '........'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这句话的意思是.NET Core缺少指定组件来运行程序。&lt;br/&gt;为了解决这个问题，我们可以添加一个&lt;code&gt;Program.runtimeconfig.json&lt;/code&gt;, 其内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;runtimeOptions&quot;: {
    &quot;framework&quot;: {
      &quot;name&quot;: &quot;Microsoft.NETCore.App&quot;,
      &quot;version&quot;: &quot;2.1.2&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的配置dotnet命令将使用&lt;code&gt;Microsoft.NETCore.App&lt;/code&gt;作为共享框架(Shared Framework)。当dotnet命令运行的时候，它会去runtimeconfig.json中读取版本号，然后去&lt;code&gt;C:\Program Files\dotnet\shared\[库名]\[版本号]&lt;/code&gt;目录下，搜索对应的dll文件&lt;/p&gt;
&lt;p&gt;现在我们重新运行上面的命令，结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;dotnet Program.dll
Hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hello World被正确输出了。&lt;/p&gt;

&lt;p&gt;包(Package)是.NET中共享代码的一种方式。在.NET中，包的格式是nupkg, nupkg文件是一个ZIP压缩文件, 里面包含了.NET程序集和一个包含元数据的xml文件&lt;br/&gt;。&lt;/p&gt;
&lt;p&gt;在.NET中，最著名的包是JSON.NET, 又称Newtonsoft.Json.它提供了一个JSON序列化和反序列化的API。我们可以从NuGet.org中下载最新版本11.0.2的nupkg文件，并解压放置在我们当前的代码目录的packages\Newtownsoft.Json\11.0.2子目录下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201809/65831-20180926161508745-1455424249.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了演示如何手动导入包来编译项目, 我们修改&lt;code&gt;Program.cs&lt;/code&gt;, 输出一个序列化之后的对象, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
      =&amp;gt; System.Console.WriteLine(
          Newtonsoft.Json.JsonConvert.SerializeObject(new { greeting = &quot;Hello World!&quot; }));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们使用如下命令，编译&lt;code&gt;Program.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;dotnet &quot;C:\Program Files\dotnet\sdk\2.1.400\Roslyn\bincore\csc.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Runtime.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Console.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Collections.dll&quot; 
-reference:.\packages\Newtonsoft.Json\11.0.2\lib\netstandard1.3\Newtonsoft.Json.dll 
-out:Program.dll 
Program.cs&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;这里为什么要引入&lt;code&gt;System.Collections.dll&lt;/code&gt;呢?&lt;br/&gt;原因是我们在代码中使用了匿名类型&lt;code&gt;new { greeting = &quot;Hello World!&quot; }&lt;/code&gt;, 对于匿名类型， C#编译器会为其生成一个&lt;code&gt;.Equals&lt;/code&gt;的方法, 这个方法调用了定义在&lt;code&gt;System.Collections.dll&lt;/code&gt;中 的&lt;code&gt;System.Collections.Generic.EqualityComparer&lt;/code&gt;方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译成功，但是会出现一些警告(Warning)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Program.cs(4,35): warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.0.20.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by 'Newtonsoft.Json' matches identity 'System.Runtime, Version=4.2.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着.Newtonsoft.Json的作者创建&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;时，是使用4.0.20.0的&lt;code&gt;System.Runtime&lt;/code&gt;程序集, 但是系统当前使用的&lt;code&gt;System.Runtime&lt;/code&gt;程序集是4.2.0.0版本的。编译器警告你4.0.20.0和4.2.0.0版本可以有很大的差异。不过幸运的是，这些差异都是向后兼容的(all backwards comptible), 所以&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;可以正常工作。如果想去除这个警告，我们可以使用&lt;code&gt;-nowarn:CS1701&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;dotnet &quot;C:\Program Files\dotnet\sdk\2.1.400\Roslyn\bincore\csc.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Runtime.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Console.dll&quot; 
-reference:&quot;C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.netcore.app\2.1.0\ref\netcoreapp2.1\System.Collections.dll&quot; 
-reference:.\packages\Newtonsoft.Json\11.0.2\lib\netstandard1.3\Newtonsoft.Json.dll 
-nowarn:CS1701 
-out:Program.dll 
Program.cs&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在上一步中，我们编译了一个引用了&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;的.NET Core程序，在引用&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;之前，代码可以正常运行，但是引用&lt;code&gt;Newtownsoft.Json.dll&lt;/code&gt;之后，程序运行失败。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt; dotnet Program.dll
Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'Newtonsoft.Json, Version=10.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed'. The system cannot find the file specified.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.NET是一个动态链接的运行时。编译器会为&lt;code&gt;Program.dll&lt;/code&gt;程序集添加&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;的引用，但是不会复制它的代码。.NET Core运行时期望在&lt;code&gt;Program.dll&lt;/code&gt;运行的时候，动态查找并加载一个&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;文件。这一点对于&lt;code&gt;System.Runtime.dll&lt;/code&gt;, &lt;code&gt;System.Console.dll&lt;/code&gt;以及其他&lt;code&gt;System.*&lt;/code&gt;的程序集也是一样。&lt;/p&gt;
&lt;p&gt;.NET Core可以配置查找&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;文件的目录范围，这里我们先简单的将&lt;code&gt;Newtownsoft.Json.dll&lt;/code&gt;拷贝到与&lt;code&gt;Program.dll&lt;/code&gt;相同的目录中, 然后重新运行&lt;code&gt;Program.dll&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;copy .\packages\Newtonsoft.Json\11.0.2\lib\netstandard1.3\Newtonsoft.Json.dll Newtonsoft.Json.dll
C:\test&amp;gt;dotnet Program.dll
{&quot;greeting&quot;:&quot;Hello World!&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们预期的结果出现了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：这里不需要拷贝System.Runtime.dll和System.Console.dll, 原因是他们存在于Microsoft.NETCore.App共享框架中，我们已经在runtimeconfig.json中配置过了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正如上一节所说的.NET Core可以配置查找动态链接程序集的位置。&lt;br/&gt;这些位置包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序根目录（这个不需要配置）&lt;/li&gt;
&lt;li&gt;包缓存目录&lt;/li&gt;
&lt;li&gt;优化过的的包缓存或者运行时包商店&lt;/li&gt;
&lt;li&gt;服务索引&lt;/li&gt;
&lt;li&gt;共享框架（配置在runtimeocnfig.json中）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;deps.json&lt;/code&gt;是一个记录.NET Core中依赖清单的文件。它可以用来配置动态链接的程序集。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deps.json&lt;/code&gt;文件中定义了动态链接的依赖列表。通常这个文件在Visual Studio中是自动生成，而且在生产环境中也会非常的大。但是它确实是一个纯文本文件，所以我们可以使用任何编辑器编写它。&lt;/p&gt;
&lt;p&gt;下面我们手动添加一个&lt;code&gt;Program.deps.json&lt;/code&gt;, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;runtimeTarget&quot;: {
    &quot;name&quot;: &quot;.NETCoreApp,Version=v2.1&quot;
  },
  &quot;targets&quot;: {
    &quot;.NETCoreApp,Version=v2.1&quot;: {
      &quot;Newtonsoft.Json/11.0.2&quot;: {
        &quot;runtime&quot;: {
          &quot;lib/netstandard1.3/Newtonsoft.Json.dll&quot;: {}
        }
      }
    }
  },
  &quot;libraries&quot;: {
    &quot;Newtonsoft.Json/11.0.2&quot;: {
      &quot;type&quot;: &quot;package&quot;,
      &quot;serviceable&quot;: false,
      &quot;sha512&quot;: &quot;&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们删除之前拷贝过来的&lt;code&gt;Newtonsoft.Json.dll&lt;/code&gt;, 然后重新运行&lt;code&gt;Program.dll&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt;del Newtonsoft.Json.dll
C:\test&amp;gt;dotnet Program.dll
Error:
  An assembly specified in the application dependencies manifest (Program.deps.json) was not found:
    package: 'Newtonsoft.Json', version: '11.0.2'
    path: 'lib/netstandard1.3/Newtonsoft.Json.dll'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，尽管我们添加了&lt;code&gt;deps.json&lt;/code&gt;, .NET Core依然需要一些其他的信息来探测&lt;code&gt;deps.json&lt;/code&gt;中定义的动态程序集。&lt;br/&gt;这里有3种方式来设置，你可以选中一行任意一种方式设置搜索动态链接库的目录路径，修改之后，&lt;code&gt;{&quot;greeting&quot;:&quot;Hello World!&quot;}&lt;/code&gt;就会正常输出出来。&lt;/p&gt;
&lt;h2 id=&quot;runtimeconfig.dev.json&quot;&gt;*.runtimeconfig.dev.json&lt;/h2&gt;
&lt;p&gt;这种一种方式是最佳的实现方式.我们可以添加一个&lt;code&gt;Program.runtimeconfig.dev.json&lt;/code&gt;,并在其中添加动态链接搜索目录字段&lt;code&gt;additionalProbingPaths&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
   &quot;runtimeOptions&quot;: {
     &quot;additionalProbingPaths&quot;: [
       &quot;/Users/nmcmaster/code/packages/&quot;
     ]
   }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注解：这里的配置类似于Transformed Config, 如果指定当前的环境是dev,它就会读取Program.runtimeconfig.json, 并将Program.runtimeconfig.dev.json的内容覆盖进去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;命令行&quot;&gt;命令行&lt;/h2&gt;
&lt;p&gt;我们还是可以使用&lt;code&gt;dotnet exec&lt;/code&gt;命令并指定&lt;code&gt;--additionalprobingpath&lt;/code&gt;参数来配置检索的目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:\test&amp;gt; dotnet exec --additionalprobingpath ./packages/ Program.dll&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;runtimeconfig.json-1&quot;&gt;*.runtimeconfig.json&lt;/h2&gt;
&lt;p&gt;当然你也可以直接在&lt;code&gt;*.runtimeconfig.json&lt;/code&gt;中添加&lt;code&gt;additionalProbingPaths&lt;/code&gt;字段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; {
   &quot;runtimeOptions&quot;: {
     &quot;framework&quot;: {
       &quot;name&quot;: &quot;Microsoft.NETCore.App&quot;,
       &quot;version&quot;: &quot;2.1.2&quot;
     },
     &quot;additionalProbingPaths&quot;: [
       &quot;./packages/&quot;
     ]
   }
 }
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/lwqlun/netcore_primitive_1.zip&quot;&gt;本篇源代码&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 26 Sep 2018 23:00:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文链接：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9704702.html</dc:identifier>
</item>
<item>
<title>Netty URL路由方案探讨 - morethink</title>
<link>http://www.cnblogs.com/morethink/p/9710918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morethink/p/9710918.html</guid>
<description>&lt;p&gt;最近在用Netty做开发，需要提供一个http web server，供调用方调用。采用Netty本身提供的&lt;code&gt;HttpServerCodec&lt;/code&gt; handler进行Http协议的解析，但是需要自己提供路由。&lt;/p&gt;
&lt;p&gt;最开始是通过对Http method及uri 采用多层if else 嵌套判断的方法路由到真正的controller类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String uri = request.uri();
HttpMethod method = request.method();
if (method == HttpMethod.POST) {
    if (uri.startsWith(&quot;/login&quot;)) {
        //url参数解析，调用controller的方法
    } else if (uri.startsWith(&quot;/logout&quot;)) {
        //同上
    }
} else if (method == HttpMethod.GET) {
    if (uri.startsWith(&quot;/&quot;)) {

    } else if (uri.startsWith(&quot;/status&quot;)) {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在只需提供&lt;code&gt;login&lt;/code&gt;及&lt;code&gt;logout&lt;/code&gt;API时，代码可以完成功能，可是随着API的数量越来越多，需要支持的方法及uri越来越多，&lt;code&gt;else if&lt;/code&gt; 越来越多，代码越来越复杂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/time-for-change.jpg&quot; title=&quot;是时候考虑重构了&quot; alt=&quot;time-for-change&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在阿里开发手册中也提到过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/e1a6f2bd638f0baf5aba0d7a63e77230.png&quot; title=&quot;重构多层else if&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此首先考虑采用状态设计模式及策略设计模式重构。&lt;/p&gt;

&lt;h2 id=&quot;状态模式的角色&quot;&gt;状态模式的角色：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;state状态&lt;br/&gt;表示状态，定义了根据不同状态进行不同处理的接口，该接口是那些处理内容依赖于状态的方法集合，对应实例的state类&lt;/li&gt;
&lt;li&gt;具体的状态&lt;br/&gt;实现了state接口，对应daystate和nightstate&lt;/li&gt;
&lt;li&gt;context&lt;br/&gt;context持有当前状态的具体状态的实例，此外，他还定义了供外部调用者使用的状态模式的接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们知道每个http请求都是由method及uri来唯一标识的，所谓路由就是通过这个唯一标识定位到controller类的中的某个方法。&lt;/p&gt;
&lt;p&gt;因此把HttpLabel作为状态&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
public class HttpLabel {
    private String uri;
    private HttpMethod method;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;状态接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Route {
    /**
     * 路由
     *
     * @param request
     * @return
     */
    GeneralResponse call(FullHttpRequest request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为每个状态添加状态实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void route() {
    //单例controller类
    final DemoController demoController = DemoController.getInstance();
    Map&amp;lt;HttpLabel, Route&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(new HttpLabel(&quot;/login&quot;, HttpMethod.POST), demoController::login);
    map.put(new HttpLabel(&quot;/logout&quot;, HttpMethod.POST), demoController::login);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接到请求，判断状态，调用不同接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServerHandler extends SimpleChannelInboundHandler&amp;lt;FullHttpRequest&amp;gt; {
    @Override
    public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {
        String uri = request.uri();
        GeneralResponse generalResponse;
        if (uri.contains(&quot;?&quot;)) {
            uri = uri.substring(0, uri.indexOf(&quot;?&quot;));
        }
        Route route = map.get(new HttpLabel(uri, request.method()));
        if (route != null) {
            ResponseUtil.response(ctx, request, route.call(request));
        } else {
            generalResponse = new GeneralResponse(HttpResponseStatus.BAD_REQUEST, &quot;请检查你的请求方法及url&quot;, null);
            ResponseUtil.response(ctx, request, generalResponse);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用状态设计模式重构代码，在增加url时只需要网map里面put一个值就行了。&lt;/p&gt;

&lt;p&gt;后来看了 &lt;a href=&quot;https://yuerblog.cc/2018/03/08/java-router-with-annotation/&quot;&gt;JAVA反射+运行时注解实现URL路由&lt;/a&gt; 发现反射+注解的方式很优雅，代码也不复杂。&lt;/p&gt;
&lt;p&gt;下面介绍Netty使用反射实现URL路由。&lt;/p&gt;
&lt;p&gt;路由注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestMapping {
    /**
     * 路由的uri
     *
     * @return
     */
    String uri();

    /**
     * 路由的方法
     *
     * @return
     */
    String method();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扫描classpath下带有&lt;code&gt;@RequestMapping&lt;/code&gt;注解的方法，将这个方法放进一个路由Map：&lt;code&gt;Map&amp;lt;HttpLabel, Action&amp;lt;GeneralResponse&amp;gt;&amp;gt; httpRouterAction&lt;/code&gt;，key为上面提到过的Http唯一标识 &lt;code&gt;HttpLabel&lt;/code&gt;，value为通过反射调用的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class HttpRouter extends ClassLoader {

    private Map&amp;lt;HttpLabel, Action&amp;lt;GeneralResponse&amp;gt;&amp;gt; httpRouterAction = new HashMap&amp;lt;&amp;gt;();

    private String classpath = this.getClass().getResource(&quot;&quot;).getPath();

    private Map&amp;lt;String, Object&amp;gt; controllerBeans = new HashMap&amp;lt;&amp;gt;();

    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String name) throws ClassNotFoundException {
        String path = classpath + name.replaceAll(&quot;\\.&quot;, &quot;/&quot;);
        byte[] bytes;
        try (InputStream ins = new FileInputStream(path)) {
            try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {
                byte[] buffer = new byte[1024 * 5];
                int b = 0;
                while ((b = ins.read(buffer)) != -1) {
                    out.write(buffer, 0, b);
                }
                bytes = out.toByteArray();
            }
        } catch (Exception e) {
            throw new ClassNotFoundException();
        }
        return defineClass(name, bytes, 0, bytes.length);
    }

    public void addRouter(String controllerClass) {
        try {
            Class&amp;lt;?&amp;gt; cls = loadClass(controllerClass);
            Method[] methods = cls.getDeclaredMethods();
            for (Method invokeMethod : methods) {
                Annotation[] annotations = invokeMethod.getAnnotations();
                for (Annotation annotation : annotations) {
                    if (annotation.annotationType() == RequestMapping.class) {
                        RequestMapping requestMapping = (RequestMapping) annotation;
                        String uri = requestMapping.uri();
                        String httpMethod = requestMapping.method().toUpperCase();
                        // 保存Bean单例
                        if (!controllerBeans.containsKey(cls.getName())) {
                            controllerBeans.put(cls.getName(), cls.newInstance());
                        }
                        Action action = new Action(controllerBeans.get(cls.getName()), invokeMethod);
                        //如果需要FullHttpRequest，就注入FullHttpRequest对象
                        Class[] params = invokeMethod.getParameterTypes();
                        if (params.length == 1 &amp;amp;&amp;amp; params[0] == FullHttpRequest.class) {
                            action.setInjectionFullhttprequest(true);
                        }
                        // 保存映射关系
                        httpRouterAction.put(new HttpLabel(uri, new HttpMethod(httpMethod)), action);
                    }
                }
            }
        } catch (Exception e) {
            log.warn(&quot;{}&quot;, e);
        }
    }

    public Action getRoute(HttpLabel httpLabel) {
        return httpRouterAction.get(httpLabel);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过反射调用&lt;code&gt;controller&lt;/code&gt; 类中的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@RequiredArgsConstructor
@Slf4j
public class Action&amp;lt;T&amp;gt; {
    @NonNull
    private Object object;
    @NonNull
    private Method method;

    private boolean injectionFullhttprequest;

    public T call(Object... args) {
        try {
            return (T) method.invoke(object, args);
        } catch (IllegalAccessException | InvocationTargetException e) {
            log.warn(&quot;{}&quot;, e);
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ServerHandler.java&lt;/code&gt;处理如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; //根据不同的请求API做不同的处理(路由分发)
Action&amp;lt;GeneralResponse&amp;gt; action = httpRouter.getRoute(new HttpLabel(uri, request.method()));
if (action != null) {
    if (action.isInjectionFullhttprequest()) {
        ResponseUtil.response(ctx, request, action.call(request));
    } else {
        ResponseUtil.response(ctx, request, action.call());
    }
} else {
    //错误处理
    generalResponse = new GeneralResponse(HttpResponseStatus.BAD_REQUEST, &quot;请检查你的请求方法及url&quot;, null);
    ResponseUtil.response(ctx, request, generalResponse);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;br/&gt;&lt;img src=&quot;https://images.morethink.cn/5166aac96c36b6fca7645a5aca07f630.png&quot; title=&quot;测试结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整代码在 https://github.com/morethink/Netty-Route&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 16:21:00 +0000</pubDate>
<dc:creator>morethink</dc:creator>
<og:description>最近在用Netty做开发，需要提供一个http web server，供调用方调用。采用Netty本身提供的 handler进行Http协议的解析，但是需要自己提供路由。 最开始是通过对Http me</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morethink/p/9710918.html</dc:identifier>
</item>
<item>
<title>[编译] 6、开源两个简单且有用的安卓APP命令行开发工具和nRF51822命令行开发工具 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9710859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9710859.html</guid>
<description>&lt;p&gt;星期四, 27. 九月 2018 12:00上午 - BEAUTIFULZZZZ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;一前言&quot;&gt;一、前言&lt;/h4&gt;
&lt;p&gt;前几天给大家介绍了如何手动搭建安卓APP命令行开发环境和nRF51822命令行开发环境，中秋这几天我把上面篇文章的操作流程全部做成了shell脚本，使得可以让其他人简单运行下脚本、就能够直接建立绿色开发环境，岂不美哉？&lt;/p&gt;

&lt;h4 id=&quot;二nrf_linux_tool开源项目介绍&quot;&gt;二、nrf_linux_tool开源项目介绍&lt;/h4&gt;
&lt;p&gt;2.1）项目简介&lt;/p&gt;
&lt;p&gt;The project provides a nRF51 APP command-line development environment based on Linux system.&lt;/p&gt;
&lt;p&gt;You can directly write、build、install APP(HEX/BIN) without using IDE.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone git@github.com:nbtool/nrf_linux_tool.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.2）如何使用&lt;/p&gt;
&lt;p&gt;If it is the first time to compile, It is recommended to run goto tool directly, and then run the './run.sh tool' to download gcc、SDK、build-tools etc.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ./tool
./run.sh tool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Build the project(for example:app_nrf51_hids_keyboard):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ./app/app_nrf51_hids_keyboard/build
make clean
make all&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Install the APP:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make erase
make flash_flash_softdevice
make flash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.3）DEMO介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;app_nrf51_peri_blinky &amp;gt; 简单工程，主要用nRF51的GPIO外设控制一个LED闪烁；&lt;/li&gt;
&lt;li&gt;app_nrf51_ble_hrs &amp;gt; BLE工程，心律计，BLE DEMO级工程，展示心律、电池电量等特征；&lt;/li&gt;
&lt;li&gt;app_nrf51_hids_mouse &amp;gt; BLE工程，蓝牙鼠标DEMO级工程，了解HID；&lt;/li&gt;
&lt;li&gt;app_nrf51_hids_keyboard &amp;gt; BLE工程，蓝牙键盘DEMO级工程，按动按键给上位机发送hello；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.4）工程结构介绍&lt;/p&gt;
&lt;p&gt;未运行run.sh构建环境前的目录结构：（可见，当前app层只有4个简单的DEMO，tool里面只有一个run.sh脚本）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  nrf_linux_tool git:(master) tree -L 2
.
├── app
│   ├── app_nrf51_ble_hrs
│   ├── app_nrf51_hids_keyboard
│   ├── app_nrf51_hids_mouse
│   └── app_nrf51_peri_blinky
├── README.md
└── tool
    └── run.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建之后的目录结构：（比未构建多了一个sdk/nRF5_SDK_12.3.0_d7731ad、gcc-arm编译器、和nRF5x命令行工具）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  nrf_linux_tool git:(master) tree -L 2
.
├── app
│   ├── app_nrf51_ble_hrs
│   ├── app_nrf51_hids_keyboard
│   ├── app_nrf51_hids_mouse
│   └── app_nrf51_peri_blinky
├── README.md
├── sdk
│   └── nRF5_SDK_12.3.0_d7731ad
└── tool
    ├── gcc-arm-none-eabi-5_4-2016q3
    ├── nRF5x-Command-Line-Tools_9_7_3
    └── run.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;之所以将SDK和GCC等工具通过构建产生，是为了减少git仓库的大小！&lt;/p&gt;
&lt;p&gt;2.5）run.sh构建脚本介绍&lt;/p&gt;
&lt;p&gt;run.sh脚本比较长，其最核心的在于tool函数，在该函数内是分别判断GCC、nRF5_Command_Lind、nRF5_SDK是否存在，如果不存在则下载：（以下载安装nRF5x command line tool为例）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;&amp;gt; install nRF5x command line tool ...&quot;
if [ ! -d $NRF5X_COMMAND_LINE_PATH ]; then 
    pack=nRF5x-Command-Line-Tools_9_7_3_Linux-x86_64.tar
    wget  -O $pack $NRF5X_COMMAND_LINE_LINK
    mkdir $NRF5X_COMMAND_LINE_PATH
    tar -xvf $pack -C $NRF5X_COMMAND_LINE_PATH
    rm -rf $pack 
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特殊的，在博客&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/9614787.html&quot;&gt;《编译4》&lt;/a&gt;中介绍：SDK安装好之后需要更新&lt;code&gt;/components/toolchain/gcc/Makefile.posix&lt;/code&gt;，这里我们也用脚本实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;&amp;gt; update the *.posix file, when the project root is changed ...&quot;
t_arm_gcc_path=`pwd`/gcc-arm-none-eabi-5_4-2016q3
posix_file=$NRF5_SDK_12_3_0_PATH&quot;/components/toolchain/gcc/Makefile.posix&quot;
echo &quot;GNU_INSTALL_ROOT := $t_arm_gcc_path&quot; &amp;gt; $posix_file
echo &quot;GNU_VERSION := 5.4.1&quot; &amp;gt;&amp;gt; $posix_file
echo &quot;GNU_PREFIX := arm-none-eabi&quot; &amp;gt;&amp;gt; $posix_file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这里GNU_INSTALL_ROOT采用的是绝对路径，因此一旦整个工程的根目录发生变化，需要运行./run.sh tool更新posix文件。&lt;/p&gt;
&lt;p&gt;2.6）典例DEMO介绍&lt;/p&gt;
&lt;p&gt;BLE工程太过复杂，我们还是看看闪灯工程吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  app_nrf51_peri_blinky git:(master) tree
.
├── build
│   ├── blinky_gcc_nrf51.ld
│   ├── Makefile
│   ├── objects.mk
│   ├── sdk_config.h
│   └── sources.mk
└── main.c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中main.c是唯一一个APP层代码文件，build目录下是一个简单的makefile框架，用来编译、烧写、擦除程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &quot;nrf_delay.h&quot;
#include &quot;boards.h&quot;

/**
 * @brief Function for application main entry.
 */
int main(void)
{
    /* Configure board. */
    bsp_board_leds_init();

    /* Toggle LEDs. */
    while (true)
    {
    for (int i = 0; i &amp;lt; LEDS_NUMBER; i++)
    {
        bsp_board_led_invert(i);
        nrf_delay_ms(500);
    }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;APP中的4个DEMO是从SDK的example中移植上来的，改动比较小，后续会把更多DEMO移到APP里，并写博客介绍~&lt;/p&gt;

&lt;h4 id=&quot;三android_app_linux_tool开源项目介绍&quot;&gt;三、android_app_linux_tool开源项目介绍&lt;/h4&gt;
&lt;p&gt;3.1）项目简介&lt;/p&gt;
&lt;p&gt;The project provides a Android APP command-line development environment based on Linux system.&lt;/p&gt;
&lt;p&gt;You can directly write、build、install Android APP without using IDE.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone git@github.com:nbtool/android_app_linux_tool.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.2）如何使用&lt;/p&gt;
&lt;p&gt;Enter the root directory of an example (for example: HelloAndroid).&lt;/p&gt;
&lt;p&gt;If it is the first time to compile, It is recommended to run make tool to download platform、SDK、build-tools etc.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ./example/HelloAndroid
make tool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Build the project:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Install the APP:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make program&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.3）DEMO介绍&lt;/p&gt;
&lt;p&gt;第一个是hello world；第二个是蓝牙scan周边设备的信号强度；第三个是几年前做的一款小游戏：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180926/flygame.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.4）工程结构介绍&lt;/p&gt;
&lt;p&gt;类似上一个开源项目，未构建前只有DEMO：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  android_app_linux_tool git:(master) tree -L 3
.
├── example
│   ├── BluetoothScan
│   │   ├── run.sh
│   │   └── ...
│   ├── FlyGame  ...
│   └── HelloAndroid ...
└── readme.md&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建之后多了安卓SDK：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  android_app_linux_tool git:(master) tree -L 3
.
├── example
│   ├── BluetoothScan
│   │   ├── run.sh
│   │   └── ...
│   ├── FlyGame  ...
│   └── HelloAndroid ...
├── readme.md
└── tool
    └── android-sdk
    ├── build-tools
    ├── licenses
    ├── platforms
    ├── platform-tools
    └── tools&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;安卓工程里的run.sh不是放在tool中，而是放在每个DEMO里面，因为每个DEMO所依赖的SDK和build工具的版本可能不一样！&lt;/p&gt;
&lt;p&gt;3.5）run.sh构建脚本介绍&lt;/p&gt;
&lt;p&gt;和上一个类似，tool函数用来下载相关SDK、编译工具、plantform-tool等，同时这里也把编译build、烧写program、和清除clean也集成进run.sh中了。真正用的时候是通过makefile调用run.sh实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid git:(master) cat makefile 
tool:
    ./run.sh tool
clean:
    ./run.sh clean
build:
    ./run.sh build
program:
    ./run.sh program
all:
    ./run.sh all&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.6）典例DEMO介绍&lt;/p&gt;
&lt;p&gt;以Hello World为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid git:(master) tree
.
├── AndroidManifest.xml
├── bin
├── libs
├── makefile
├── mykey.keystore
├── obj
├── res
│   ├── layout
│   │   └── activity_main.xml
│   └── values
│       └── strings.xml
├── run.sh
└── src
    └── com
    └── example
        └── helloandroid
            └── MainActivity.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;麻雀虽小、五脏俱全，该工程包含一个MainActivity.java文件、两个资源文件、一个Manifest.xml文件，最终生成的apk会存放到bin文件中。&lt;/p&gt;
&lt;p&gt;同样的，今后我还会在Example中增加更多DEMO，并在博客中进行介绍。同时，也欢迎其他人来贡献DEMO ～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nbtool/nrf_linux_tool&quot;&gt;[1].nrf_linux_tool项目GITHUB地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/nbtool/android_app_linux_tool&quot;&gt;[2].android_app_linux_tool项目GITHUB地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/9614787.html&quot;&gt;[3].在Linux下搭建nRF51822的开发烧写环境&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/9672376.html&quot;&gt;[4].在Linux下搭建安卓APP的开发烧写环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 26 Sep 2018 16:07:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>星期四, 27. 九月 2018 12:00上午 BEAUTIFULZZZZ ![][ bar] 一、前言 前几天给大家介绍了如何手动搭建安卓APP命令行开发环境和nRF51822命令行开发环境，中秋</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9710859.html</dc:identifier>
</item>
<item>
<title>WebApiClient的SteeltoeOSS.Discovery扩展 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/9710778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/9710778.html</guid>
<description>&lt;h3 id=&quot;背景&quot;&gt;1 背景&lt;/h3&gt;
&lt;p&gt;从园子里看到一些朋友在某些项目开发中，选择的架构是spring cloud搭建底层微服务框架，dotnet core来编写业务逻辑，&lt;a href=&quot;https://github.com/SteeltoeOSS/Discovery&quot;&gt;SteeltoeOSS.Discovery&lt;/a&gt;是dotnet和spingcloud的桥梁，为dotnet提供服务注册和服务发现相关功能。在阅读朋友们文章的时候，我发现相关代码里的一些HttpClient相关问题，同时对dotnet寄居于spingcloud下由于没有Feign而产生的那些丑陋的http请求代码进行思考。本文将围绕原生的HttpClient的创建与释放的正确姿势和使用&lt;a href=&quot;https://github.com/dotnetcore/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;让dotnet也有媲美Feign的服务客户端两个面展开。&lt;/p&gt;
&lt;h3 id=&quot;正确使用httpclient&quot;&gt;2 正确使用HttpClient&lt;/h3&gt;
&lt;h4 id=&quot;httpclient的创建和释放&quot;&gt;2.1 HttpClient的创建和释放&lt;/h4&gt;
&lt;p&gt;HttpClient有三个构造函数，最终都是调用到public HttpClient(HttpMessageHandler handler, bool disposeHandler)这个函数，HttpClient除了其handler参数之外，本身没有使用到需要Dispose的资源，其实现的IDispose也是为了Dispose掉handler参数而已。&lt;/p&gt;
&lt;p&gt;HttpMessageHandler是一个抽象类，目前主要的HttpMessageHandler具体类型有HttpClientHanlder、SocketsHttpHandler和WebRequestHandler，但HttpClientHanlder在dotnet core2.1下是对和SocketsHttpHandler的包装实现。除了这些主要HttpMessageHandler，还有一个抽象的DelegatingHandler类型，用于实现请求管道，影响请求前后的数据逻辑。HttpClient的默认构造器，使用了HttpClientHanlder类型，同时disposeHandler为true，这时如果对HttpClient实例Dispose了，其内部的HttpClientHanlder自然也被Dispose了，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确的创建和释放HttpClient例子&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认构造器&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var httpClient = new HttpClient();
...你的代码...
httpClient.Dispose();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;HttpClient控制HttpMessageHandler&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var handler = new HttpClientHandler();
var httpClient = new HttpClient(handler, true);
...你的代码...
httpClient.Dispose();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;HttpClient不控制外部HttpMessageHandler&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var handler = 从外部来的HttpMessageHandler;
var httpClient = new HttpClient(handler, false);
...你的代码...

// 这里调用httpClient.Dispose()是无效的
// handler的生命周期应该由它的创建者来维护
// 如果这里Dispose掉handler，其它使用了这个handler的HttpClient实例受影响&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不正确的创建和释放HttpClient的例子&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HttpMessageHandler被创建了，但没有释放&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly DiscoveryHttpClientHandler _handler;
private const string ProductUrl = &quot;http://product/api/values&quot;;

public ValuesController(IDiscoveryClient client, ILoggerFactory logFactory)
{
    _handler = new DiscoveryHttpClientHandler(client);
}

[HttpGet(&quot;product&quot;)]
public async Task&amp;lt;string&amp;gt; GoProductAsync()
{
    var client = new HttpClient(_handler, false);
    return await client.GetStringAsync(ProductUrl);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;httpclient的生命周期&quot;&gt;2.2 HttpClient的生命周期&lt;/h4&gt;
&lt;p&gt;HttpClient在设计之初，是非常适合使用单例模式的，也就是在应用域中，只维护一份HttpClient的实例就够了，因为它天生支持向不同域名同时多个并发请求。但单例的HttpClient没有遵守DNS 生存时间 (TTL) 设置，如果其HttpClientHandler第一次请求到www.baidu.com指向的ip为123.123.123.123，中途这个域名解析到的ip变化了，但HttpClient并不会自动应用这些变化。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;asp.net core&lt;/code&gt;里，微软创建一个&lt;a href=&quot;https://github.com/aspnet/HttpClientFactory&quot;&gt;HttpClientFactory&lt;/a&gt;项目，用于提供HttpClient的创建和生命周期自动管理，完美解决到底选择单例还是每个请求创建和释放HttpClient这个左右难为的问题。所以在&lt;code&gt;asp.net core&lt;/code&gt;项目开发中，请别再写手动new HttpClient了，所有HttpClient的实例，都要由HttpClientFactory来创建，所有的外部HttpMessageHandler，也应该配置到HttpClientFactory，让它与HttpClient关联起来。&lt;/p&gt;
&lt;p&gt;HttpClientFactory有三种使用方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Using HttpClientFactory Directly&lt;/li&gt;
&lt;li&gt;Named Clients&lt;/li&gt;
&lt;li&gt;Typed Clients&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体的使用，可以查看&lt;a href=&quot;http://www.talkingdotnet.com/3-ways-to-use-httpclientfactory-in-asp-net-core-2-1/&quot;&gt;3 ways to use HTTPClientFactory in ASP.NET Core 2.1&lt;/a&gt;这篇好文。&lt;/p&gt;
&lt;h3 id=&quot;寄居下也有feign&quot;&gt;3 寄居下也有Feign&lt;/h3&gt;
&lt;p&gt;虽然已经讲解了怎么new一个HttpClient，怎么利用HttpClientFactory，但如果要寄居在spingcloud下，你还是得为请求一个服务接口编写大量的代码，这在java的Feign前面如同马车见到宝马。如果能利用&lt;a href=&quot;https://github.com/dotnetcore/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;这把利剑，结合HttpClientFactory与DiscoveryHttpClientHandler，你也能变成宝马。将这三者有机结合起来的项目，叫&lt;a href=&quot;https://github.com/xljiulang/WebApiClient.Extensions&quot;&gt;WebApiClient.Extensions.DiscoveryClient&lt;/a&gt;，它是WebApiClient的SteeltoeOSS.Discovery扩展项目，使用非常简单。&lt;/p&gt;
&lt;h4 id=&quot;nuget引用&quot;&gt;3.1 Nuget引用&lt;/h4&gt;
&lt;p&gt;PM&amp;gt; &lt;code&gt;install-package WebApiClient.Extensions.DiscoveryClient&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;声明微服务的webapiclient调用接口&quot;&gt;3.2 声明微服务的WebApiClient调用接口&lt;/h4&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpHost(&quot;http://NET-API&quot;)]
public interface INetApi : IHttpApi
{
    [HttpGet(&quot;api/values&quot;)]
    ITask&amp;lt;string[]&amp;gt; GetValuesAsync();

    [HttpGet(&quot;api/values/{id}&quot;)]
    ITask&amp;lt;string&amp;gt; GetValuesAsync(int id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;startup相关配置&quot;&gt;3.3 Startup相关配置&lt;/h4&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddDiscoveryClient(Configuration);
    services.AddDiscoveryTypedClient&amp;lt;INetApi&amp;gt;();
    ...
}


// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    ...
    app.UseDiscoveryClient();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;controller&quot;&gt;3.4 Controller&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class HomeController : Controller
{
    public async Task&amp;lt;string&amp;gt; Index([FromServices]INetApi netApi, int id = 0)
    {
        var values = await netApi.GetValuesAsync();
        var value = await netApi.GetValuesAsync(id);
        return &quot;ok&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束语&quot;&gt;4. 结束语&lt;/h3&gt;
&lt;p&gt;本博主对HttpClient有着比较深入的了解，一直在维护WebApiClient项目，期间走过许许多多的“坑”，如果你有遇到HttpClient的相关问题，欢迎一起讨论解决。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:34:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<og:description>1 背景 从园子里看到一些朋友在某些项目开发中，选择的架构是spring cloud搭建底层微服务框架，dotnet core来编写业务逻辑，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/9710778.html</dc:identifier>
</item>
<item>
<title>微信扫码支付功能（1）---通过谷歌二维码工具生成付款码 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9708534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9708534.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、微信网站扫码支付介绍&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、扫码支付文档&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;   微信开发官方文档:&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  有关微信支付的流程图微信官方已经说的很清楚了，这里也无需其它解释。这边采用微信支付扫码模式二（不依赖商户平台设置回调url），所以在生成二维码之前&lt;/p&gt;
&lt;p&gt;要先调用微信统一下单支付接口，获得code_url，再通过谷歌二维码工具将code_url生成二维码图片。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    2、名称理解&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在微信扫码支付功能开发之前，首先要获得微信认证而得到的一些信息如下：&lt;/p&gt;
&lt;p&gt;开发者账户信息&lt;/p&gt;
&lt;p&gt;公众号 &lt;span&gt;appid&lt;/span&gt;: wx0pi2m4x6we76140w&lt;/p&gt;
&lt;p&gt;公众号 &lt;span&gt;appsecret&lt;/span&gt;: x82552d8w0y1i161lp9o7821s5d7osry&lt;/p&gt;
&lt;p&gt;商户号 &lt;span&gt;mer_id&lt;/span&gt;: 5731202714&lt;/p&gt;
&lt;p&gt;支付    &lt;span&gt;key&lt;/span&gt;: PL9wT9n9Ljav4zSN66J0bmzT1Yl54429&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;3、和微信支付交互方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1)、post方式提交&lt;/p&gt;
&lt;p&gt;  (2)、xml格式的协议&lt;/p&gt;
&lt;p&gt;  (3)、签名算法MD5&lt;/p&gt;
&lt;p&gt;  (4)、接口交易单位为 分&lt;/p&gt;
&lt;p&gt;  (5)、交易类型：JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付&lt;/p&gt;
&lt;p&gt;  (6)、商户订单号规则：&lt;/p&gt;
&lt;p&gt;      商户支付的订单号由商户自定义生成，仅支持使用字母、数字、中划线-、下划线_、竖线|、星号*这些英文半角字符的组合，请勿使用汉字或全角等特殊字符，&lt;/p&gt;
&lt;p&gt;微信支付要求商户订单号保持唯一性&lt;/p&gt;
&lt;p&gt;   (7)、安全规范：&lt;/p&gt;
&lt;p&gt;    签名算法：&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    校验工具：&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=20_1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   (8)、采用微信支付扫码模式二（不依赖商户平台设置回调url）&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、实战开发&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;   1、点击购买商品调用接口&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;接口需要接收&lt;span&gt;购买商品ID，用户ID&lt;/span&gt;,返回的就是二维码图片供用户扫码支付。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;/api/v1/order&quot;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; VideoOrderService videoOrderService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用户点击购买下单接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&quot;buy&quot;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; saveOrder(@RequestParam(value = &quot;video_id&quot;,required = &lt;span&gt;true&lt;/span&gt;)&lt;span&gt;int&lt;/span&gt;&lt;span&gt; videoId,
                              HttpServletRequest request,
                              HttpServletResponse response) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 实际开发需要获取用户id和用户当前ip，这里临时写死的配置
         * String ip = IpUtils.getIpAddr(request);
         * int userId = request.getAttribute(&quot;user_id&quot;);
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; userId = 1&lt;span&gt;;
        String ip &lt;/span&gt;= &quot;120.25.1.43&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、根据用户id和商品id生成订单&lt;/span&gt;
        VideoOrderDto videoOrderDto = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VideoOrderDto();
        videoOrderDto.setUserId(userId);
        videoOrderDto.setVideoId(videoId);
        videoOrderDto.setIp(ip);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、保存订单同时返回codeUrl&lt;/span&gt;
        String codeUrl =&lt;span&gt; videoOrderService.save(videoOrderDto);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(codeUrl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  NullPointerException();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、通过google工具生成二维码供用户扫码支付&lt;/span&gt;
         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、1生成二维码配置&lt;/span&gt;
            Map&amp;lt;EncodeHintType,Object&amp;gt; hints =  &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、2设置纠错等级&lt;/span&gt;
&lt;span&gt;            hints.put(EncodeHintType.ERROR_CORRECTION,ErrorCorrectionLevel.L);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、3编码类型&lt;/span&gt;
            hints.put(EncodeHintType.CHARACTER_SET,&quot;UTF-8&quot;&lt;span&gt;);

            BitMatrix bitMatrix &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MultiFormatWriter().encode(codeUrl,BarcodeFormat.QR_CODE,400,400&lt;span&gt;,hints);
            OutputStream out &lt;/span&gt;=&lt;span&gt;  response.getOutputStream();

            MatrixToImageWriter.writeToStream(bitMatrix,&lt;/span&gt;&quot;png&quot;&lt;span&gt;,out);

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;  2、进入VideoOrderService具体业务实现类&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;该类的主要业务逻辑是：&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（1）通过商品ID查询是否有该商品信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;（2）通过用户ID查询是否存在该用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （3）如果上面两步没有问题，则生成用户订单信息保存到数据库中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @Transactional(propagation &lt;/span&gt;=&lt;span&gt; Propagation.REQUIRED)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String save(VideoOrderDto videoOrderDto) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、查找商品信息（这里商品指的是视频课程）&lt;/span&gt;
        Video video =&lt;span&gt;  videoMapper.findById(videoOrderDto.getVideoId());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、查找用户信息&lt;/span&gt;
        User user =&lt;span&gt; userMapper.findByid(videoOrderDto.getUserId());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、生成订单，插入数据库&lt;/span&gt;
        VideoOrder videoOrder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; VideoOrder();
        videoOrder.setTotalFee(video.getPrice());
        videoOrder.setVideoImg(video.getCoverImg());
        videoOrder.setVideoTitle(video.getTitle());
        videoOrder.setCreateTime(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        videoOrder.setVideoId(video.getId());
        videoOrder.setState(&lt;/span&gt;0&lt;span&gt;);
        videoOrder.setUserId(user.getId());
        videoOrder.setHeadImg(user.getHeadImg());
        videoOrder.setNickname(user.getName());
        videoOrder.setDel(&lt;/span&gt;0&lt;span&gt;);
        videoOrder.setIp(videoOrderDto.getIp());
        videoOrder.setOutTradeNo(CommonUtils.generateUUID());

        videoOrderMapper.insert(videoOrder);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、获取codeurl&lt;/span&gt;
        String codeUrl =&lt;span&gt; unifiedOrder(videoOrder);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; codeUrl;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;     3、回调微信统一下单接口,获取codeurl方法主要逻辑&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;微信官方统一下单接口文档说明: &lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;(1)  根据接口需求添加所需参数:比如appid,mch_id,body等等......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）sign签名获取：具体获取规则官方已经说明: &lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&quot; target=&quot;_blank&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=4_3&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  (3) 通过工具类将map集合转为xml格式字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）回调微信统一下单接口，接口地址：https://api.mch.weixin.qq.com/pay/unifiedorder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（&lt;span&gt;5）如果上一步成功（成功标志返回SUSSCUSS),则将返回成功的xml格式再通过工具类转为map&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）通过key=code_url,获取value字符串，这也是最终生成二维码的字符串。code_url格式大致为:weixin://wxpay/s/An4baqw&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来只要将code_url值变成二维码就可以供用户扫码付款了。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    4、测试&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  调用http://localhost:8081/api/v1/order/buy?video_id=1接口&lt;/p&gt;
&lt;p&gt;  成功返回二维码：code_url有效期是两个小时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180926230511616-1787872663.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;346&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 微信扫码之后：看到具体信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180926230810010-81258548.png&quot; alt=&quot;&quot; width=&quot;212&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看数据库该商品信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201809/1090617-20180926230947569-189443587.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;39&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;github源码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;github: &lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://github.com/yudiandemingzi/wechatpay&quot; target=&quot;_blank&quot;&gt;https://github.com/yudiandemingzi/wechatpay&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天一亮，又是崭新的起点，又是未知的征程（上校16）&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 26 Sep 2018 15:15:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>生成付款二维码 一、微信网站扫码支付介绍 1、扫码支付文档 微信开发官方文档:https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9708534.html</dc:identifier>
</item>
<item>
<title>适配iPhoneX、iPhoneXs、iPhoneXs Max、iPhoneXr 屏幕尺寸及安全区域 - 布袋</title>
<link>http://www.cnblogs.com/apiapia/p/9710703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apiapia/p/9710703.html</guid>
<description>&lt;p class=&quot;line&quot; data-line=&quot;0&quot;&gt;此篇文章是对上一篇文章（&lt;a href=&quot;http://www.ifiero.com/index.php/archives/611&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://www.ifiero.com/index.php/archives/611&lt;/a&gt;）的进一步补充，主要说明如何适配Apple的最新三款手机iPhoneXs、iPhoneXs Max及iPhoneXr !!!&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-13f9263bca17b7f4?imageMogr2/auto-orient/strip&quot; alt=&quot;未适配前:Ball球超过屏幕的上下方&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-13f9263bca17b7f4?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未适配前:Ball球超过屏幕的上下方&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-db4b19b91127eaf5?imageMogr2/auto-orient/strip&quot; alt=&quot;适配后:Ball球就在屏幕的可视范围内运动了&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-db4b19b91127eaf5?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配后:Ball球就在屏幕的可视范围内运动了&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;7&quot;&gt;回顾：为何要把场景中的所有图片, 都按照屏幕大小为 2048 * 1536 来绘制。 也就是说, 我们的背景图的大小是 2048 * 1536, 其他图片也是依照这个比例来绘制。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;9&quot;&gt;为什么这样做呢?&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;11&quot;&gt;我们知道 2048 * 1536 是iPad Retina 的分辨率。也是我们需要适配的设备里面分辨率最高的。 所以我们在游戏中都选择了这个大小，让它来兼容分辨率低的设备。 2048 * 1536 在iPad Retina上是完美显示的。 那在其他设备上呢? 先用 AspectFill来进行缩放，并应用相应的屏幕辨率高宽比值Ratio， 来适配各个不同的iPhone尺寸。AspectFill缩放的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if &lt;span class=&quot;hljs-keyword&quot;&gt;let scene = GameScene(fileNamed: &lt;span class=&quot;hljs-string&quot;&gt;&quot;GameScene&quot;) {
                scene.size = CGSize(width: &lt;span class=&quot;hljs-number&quot;&gt;2048, &lt;span class=&quot;hljs-attr&quot;&gt;height: &lt;span class=&quot;hljs-number&quot;&gt;1536)
                scene.scaleMode = .aspectFill &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;了解了用 AspectFill来进行缩放，那么我们现在就来看看iPhoneX的屏幕尺寸分辨率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-93d1b3b3fe1641ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;以iPhoneX的分辨率为例,SafeArea为安全区域&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-93d1b3b3fe1641ac.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以iPhoneX的分辨率为例,SafeArea为安全区域&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;24&quot;&gt;iPhoneX的屏幕尺寸分辨率(上图中 高度812 = 2436缩小1/3)：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备&lt;/th&gt;
&lt;th&gt;屏幕尺寸分辨率&lt;/th&gt;
&lt;th&gt;图片存放对应的位置&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (1倍 @1x)&lt;/td&gt;
&lt;td&gt;375×812&lt;/td&gt;
&lt;td&gt;@1x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (2倍 @2x)&lt;/td&gt;
&lt;td&gt;750×1624&lt;/td&gt;
&lt;td&gt;@2x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1125×2436&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;iPhoneX/iPhoneXs/iPhoneXs Max/iPhoneXr的屏幕尺寸分辨率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-ad90df3c75fbff74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;iPhoneX系列的分辨率&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-ad90df3c75fbff74.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iPhoneX系列的分辨率&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;35&quot;&gt;iPhoneX系列的屏幕分辨率：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备&lt;/th&gt;
&lt;th&gt;屏幕分辨率&lt;/th&gt;
&lt;th&gt;图片存放的位置&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iPhoneX (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1125×2436&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneXs (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1125×2436&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneXs Max (3倍 @3x)&lt;/td&gt;
&lt;td&gt;1242×2688&lt;/td&gt;
&lt;td&gt;@3x&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhoneXr (2倍 @2x)&lt;/td&gt;
&lt;td&gt;828×1792&lt;/td&gt;
&lt;td&gt;@2x&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;根据以上iPhoneX系列的屏幕分辨率，得出高宽比Ratio都为2.16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-8d694e58713d1afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;各款iPhone的屏幕分辨比率&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-8d694e58713d1afc.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各款iPhone的屏幕分辨比率&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;47&quot;&gt;橙色整体区域表示我们场景的真实大小, 用 AspectFill来进行缩放后，scene.scaleMode = .aspectFill，黑色线框内的区域表示场景展示在设备上的真实大小（即屏幕可视范围）。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;49&quot;&gt;iPad Retina：橙色区域和黑色线框内的区域是完美吻合的,也就是说在设备上能完整显示。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;51&quot;&gt;iPhone6/7/8/Plus：黑色线框内的区域是2048 * 1152，这边要注意的是，超出黑色框的内容看不见，设计游戏时，尽量不要把精灵的Position位置放在位于不可见的区域。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;53&quot;&gt;iPhoneX：黑色线框内的区域是2048 * 948(兰色为安全区域)，其中948高度=2048 / 2.16(高宽比)。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;55&quot;&gt;不同尺寸的iPhone的屏幕尺寸比例及屏幕高宽比值&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设备&lt;/th&gt;
&lt;th&gt;屏幕比例&lt;/th&gt;
&lt;th&gt;屏幕高宽比值&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;iPad Retina&lt;/td&gt;
&lt;td&gt;4 / 3&lt;/td&gt;
&lt;td&gt;1.33&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone 6/7/8&lt;/td&gt;
&lt;td&gt;16 / 9&lt;/td&gt;
&lt;td&gt;1.77&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone 6/7/8 Plus&lt;/td&gt;
&lt;td&gt;16 / 9&lt;/td&gt;
&lt;td&gt;1.77&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;iPhone X/Xs/Xr/Xs Max&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;td&gt;2.16&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;line&quot; data-line=&quot;63&quot;&gt;再者我们主要是适配SpriteKit游戏开发，因为不需要计算Navigation导航栏的高度，也不需要TabBar状态栏的高度，只需要计算可视区域（屏幕可视范围），还有，注意要把需要交互的元素放在安全区域SafeArea，而不要放在危险区域 Danger Area就行了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可视区域（屏幕可视范围）= 安全区域 Safe Area + 危险区域 Danger Area&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;line&quot; data-line=&quot;67&quot;&gt;了解了原理后，我们就开始来编写代码吧。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;69&quot;&gt;1.extension拓展UIDevice,判断设备是iPhone或者iPhoneX系列或iPad&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt;import &lt;span class=&quot;hljs-built_in&quot;&gt;UIKit
import SpriteKit

&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;line&quot; data-line=&quot;98&quot;&gt;2.检测是哪种设备&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;line&quot; data-line=&quot;113&quot;&gt;3.画出安全区域&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt; // MARK: - 安全区域即用户交互的区域，非可视区域 (iPhoneX的安全区域 &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt; 可视区域)
    &lt;span class=&quot;hljs-attr&quot;&gt;func &lt;span class=&quot;hljs-attr&quot;&gt;drawSafeArea(&lt;span class=&quot;hljs-attr&quot;&gt;size:CGSize,&lt;span class=&quot;hljs-attr&quot;&gt;ratio:CGFloat){
        
        &lt;span class=&quot;hljs-attr&quot;&gt;playableHeight  = &lt;span class=&quot;hljs-string&quot;&gt;size.width / &lt;span class=&quot;hljs-attr&quot;&gt;ratio
        &lt;span class=&quot;hljs-attr&quot;&gt;playableMargin = &lt;span class=&quot;hljs-string&quot;&gt;(size.height &lt;span class=&quot;hljs-attr&quot;&gt;- &lt;span class=&quot;hljs-attr&quot;&gt;playableHeight ) / &lt;span class=&quot;hljs-attr&quot;&gt;2.0   /// &lt;span class=&quot;hljs-attr&quot;&gt;P70
        
        &lt;span class=&quot;hljs-attr&quot;&gt;let &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetLeft   =  &lt;span class=&quot;hljs-string&quot;&gt;AREA_INSET_WIDTH_LEFT * &lt;span class=&quot;hljs-attr&quot;&gt;ratio
        &lt;span class=&quot;hljs-attr&quot;&gt;let &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetRight  =  &lt;span class=&quot;hljs-string&quot;&gt;size.width &lt;span class=&quot;hljs-attr&quot;&gt;- &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetLeft &lt;span class=&quot;hljs-attr&quot;&gt;- &lt;span class=&quot;hljs-attr&quot;&gt;AREA_INSET_WIDTH_RIGHT * &lt;span class=&quot;hljs-attr&quot;&gt;ratio
        
        &lt;span class=&quot;hljs-attr&quot;&gt;playableRect = &lt;span class=&quot;hljs-string&quot;&gt;CGRect(x: &lt;span class=&quot;hljs-attr&quot;&gt;safeInsetLeft, &lt;span class=&quot;hljs-attr&quot;&gt;y: &lt;span class=&quot;hljs-attr&quot;&gt;playableMargin, &lt;span class=&quot;hljs-attr&quot;&gt;width:safeInsetRight, &lt;span class=&quot;hljs-attr&quot;&gt;height:  &lt;span class=&quot;hljs-attr&quot;&gt;playableHeight)  /// 注意 &lt;span class=&quot;hljs-attr&quot;&gt;scene的&lt;span class=&quot;hljs-attr&quot;&gt;anchorPoint(&lt;span class=&quot;hljs-attr&quot;&gt;0,&lt;span class=&quot;hljs-attr&quot;&gt;0)原点的位置;
        &lt;span class=&quot;hljs-attr&quot;&gt;let &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame = &lt;span class=&quot;hljs-string&quot;&gt;SKShapeNode(rect: &lt;span class=&quot;hljs-attr&quot;&gt;playableRect)
        &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame.zPosition = &lt;span class=&quot;hljs-string&quot;&gt;2
        &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame.strokeColor = &lt;span class=&quot;hljs-string&quot;&gt;SKColor.green
        &lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame.lineWidth = &lt;span class=&quot;hljs-string&quot;&gt;6.0
        &lt;span class=&quot;hljs-attr&quot;&gt;addChild(&lt;span class=&quot;hljs-attr&quot;&gt;shapeFrame)
        
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p class=&quot;line&quot; data-line=&quot;133&quot;&gt;4.画出可视区域并赋于可视区域的边届物理特性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样子Ball球就只在可视区域内（屏幕可视范围）运动了。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3896436-27aefc7a764a64b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;适配iPhoneXs Max&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/3896436-27aefc7a764a64b3.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配iPhoneXs Max&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;line&quot; data-line=&quot;166&quot;&gt;重要的一点就是要了解屏幕尺寸和安全区域的不同，通俗点讲就是，屏幕可视范围可以放任何元素，但所有的用户交互行为都要放在安全区域内(兰色框内)。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;168&quot;&gt;即可视区域（屏幕可视范围）= 安全区域 Safe Area + 危险区域 Danger Area&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;168&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;170&quot;&gt;源码传送门： &lt;a href=&quot;https://github.com/apiapia/BreakOutGameVansVTutorial&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/apiapia/BreakOutGameVansVTutorial&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;170&quot;&gt;更多游戏教学：http://www.iFIERO.com&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:14:00 +0000</pubDate>
<dc:creator>布袋</dc:creator>
<og:description>适配Apple的最新三款手机iPhoneXs、iPhoneXs Max及iPhoneXr。2048 * 1536 是iPad Retina 的分辨率。也是我们需要适配的设备里面分辨率最高的。 所以我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apiapia/p/9710703.html</dc:identifier>
</item>
<item>
<title>Java SpringBoot集成RabbitMq实战和总结 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/9710698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/9710698.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;在公司里一直在用RabbitMQ，由于api已经封装的很简单，关于RabbitMQ本身还有封装的实现没有了解，最近在看RabbitMQ实战这本书，结合网上的一些例子和spring文档，实现了RabbitMQ和spring的集成，对着自己平时的疑惑做了一些总结。&lt;br/&gt;关于RabbitMQ基础不在详细讲解(本文不适合RabbitMq零基础)，&lt;a href=&quot;https://book.douban.com/subject/26649178/&quot;&gt;RabbitMQ实战&lt;/a&gt;的1,2,4三章讲的非常不错。因为书中讲的都是Python和Php的例子，所以自己结合SpringBoot文档和&lt;a href=&quot;https://blog.csdn.net/u013256816&quot;&gt;朱小厮的博客&lt;/a&gt;做了一些总结，写了一些Springboot的&lt;a href=&quot;https://github.com/chenfangzhi123/javainaction/tree/master/rabbit-mq-spring-boot&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;交换器队列绑定的声明&quot;&gt;交换器、队列、绑定的声明&lt;/h2&gt;
&lt;p&gt;SpringAMQP项目对RabbitMQ做了很好的封装，可以很方便的手动声明队列，交换器，绑定。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 队列
     * @return
     */
    @Bean
    @Qualifier(RabbitMQConstant.PROGRAMMATICALLY_QUEUE)
    Queue queue() {
        return new Queue(RabbitMQConstant.PROGRAMMATICALLY_QUEUE, false, false, true);
    }

    /**
     * 交换器
     * @return
     */
    @Bean
    @Qualifier(RabbitMQConstant.PROGRAMMATICALLY_EXCHANGE)
    TopicExchange exchange() {
        return new TopicExchange(RabbitMQConstant.PROGRAMMATICALLY_EXCHANGE, false, true);
    }
    /**
     * 声明绑定关系
     * @return
     */
    @Bean
    Binding binding(@Qualifier(RabbitMQConstant.PROGRAMMATICALLY_EXCHANGE) TopicExchange exchange,
                    @Qualifier(RabbitMQConstant.PROGRAMMATICALLY_QUEUE) Queue queue) {
        return BindingBuilder.bind(queue).to(exchange).with(RabbitMQConstant.PROGRAMMATICALLY_KEY);
    }

    /**
     * 声明简单的消费者，接收到的都是原始的{@link Message}
     *
     * @param connectionFactory
     *
     * @return
     */
    @Bean
    SimpleMessageListenerContainer simpleContainer(ConnectionFactory connectionFactory) {
        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.setMessageListener(message -&amp;gt; log.info(&quot;simple receiver,message:{}&quot;, message));
        container.setQueueNames(RabbitMQConstant.PROGRAMMATICALLY_QUEUE);
        return container;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;消费者和生产者都可以声明，交换器这种一般经常创建，可以手动创建。需要注意对于没有路由到队列的消息会被丢弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是Spring的话还需要声明连接：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    ConnectionFactory connectionFactory(@Value(&quot;${spring.rabbitmq.port}&quot;) int port,
                                        @Value(&quot;${spring.rabbitmq.host}&quot;) String host,
                                        @Value(&quot;${spring.rabbitmq.username}&quot;) String userName,
                                        @Value(&quot;${spring.rabbitmq.password}&quot;) String password,
                                        @Value(&quot;${spring.rabbitmq.publisher-confirms}&quot;) boolean isConfirm,
                                        @Value(&quot;${spring.rabbitmq.virtual-host}&quot;) String vhost) {
        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();
        connectionFactory.setHost(host);
        connectionFactory.setVirtualHost(vhost);
        connectionFactory.setPort(port);
        connectionFactory.setUsername(userName);
        connectionFactory.setPassword(password);
        connectionFactory.setPublisherConfirms(isConfirm);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在配置类使用&lt;code&gt;@EnableRabbit&lt;/code&gt;的情况下，也可以基于注解进行声明，在Bean的方法上加上&lt;code&gt;@RabbitListener&lt;/code&gt;，如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 可以直接通过注解声明交换器、绑定、队列。但是如果声明的和rabbitMq中已经存在的不一致的话
     * 会报错便于测试，我这里都是不使用持久化，没有消费者之后自动删除
     * {@link RabbitListener}是可以重复的。并且声明队列绑定的key也可以有多个.
     *
     * @param headers
     * @param msg
     */
    @RabbitListener(
        bindings = @QueueBinding(
            exchange = @Exchange(value = RabbitMQConstant.DEFAULT_EXCHANGE, type = ExchangeTypes.TOPIC,
                durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
            value = @Queue(value = RabbitMQConstant.DEFAULT_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
                autoDelete = RabbitMQConstant.true_CONSTANT),
            key = DKEY
        ),
        //手动指明消费者的监听容器，默认Spring为自动生成一个SimpleMessageListenerContainer
        containerFactory = &quot;container&quot;,
        //指定消费者的线程数量,一个线程会打开一个Channel，一个队列上的消息只会被消费一次（不考虑消息重新入队列的情况）,下面的表示至少开启5个线程，最多10个。线程的数目需要根据你的任务来决定，如果是计算密集型，线程的数目就应该少一些
        concurrency = &quot;5-10&quot;
    )
    public void process(@Headers Map&amp;lt;String, Object&amp;gt; headers, @Payload ExampleEvent msg) {
        log.info(&quot;basic consumer receive message:{headers = [&quot; + headers + &quot;], msg = [&quot; + msg + &quot;]}&quot;);
    }

    /**
     * {@link Queue#ignoreDeclarationExceptions}声明队列会忽略错误不声明队列，这个消费者仍然是可用的
     *
     * @param headers
     * @param msg
     */
    @RabbitListener(queuesToDeclare = @Queue(value = RabbitMQConstant.DEFAULT_QUEUE, ignoreDeclarationExceptions = RabbitMQConstant.true_CONSTANT))
    public void process2(@Headers Map&amp;lt;String, Object&amp;gt; headers, @Payload ExampleEvent msg) {
        log.info(&quot;basic2 consumer receive message:{headers = [&quot; + headers + &quot;], msg = [&quot; + msg + &quot;]}&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于消息序列化&quot;&gt;关于消息序列化&lt;/h2&gt;
&lt;p&gt;这个比较简单,默认采用了Java序列化，我们一般使用的Json格式，所以配置了Jackson，根据自己的情况来，直接贴代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    MessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;同一个队列多消费类型&quot;&gt;同一个队列多消费类型&lt;/h2&gt;
&lt;p&gt;如果是同一个队列多个消费类型那么就需要针对每种类型提供一个消费方法，否则找不到匹配的方法会报错，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
@RabbitListener(
    bindings = @QueueBinding(
        exchange = @Exchange(value = RabbitMQConstant.MULTIPART_HANDLE_EXCHANGE, type = ExchangeTypes.TOPIC,
            durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
        value = @Queue(value = RabbitMQConstant.MULTIPART_HANDLE_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
            autoDelete = RabbitMQConstant.true_CONSTANT),
        key = RabbitMQConstant.MULTIPART_HANDLE_KEY
    )
)
@Profile(SpringConstant.MULTIPART_PROFILE)
public class MultipartConsumer {

    /**
     * RabbitHandler用于有多个方法时但是参数类型不能一样，否则会报错
     *
     * @param msg
     */
    @RabbitHandler
    public void process(ExampleEvent msg) {
        log.info(&quot;param:{msg = [&quot; + msg + &quot;]} info:&quot;);
    }

    @RabbitHandler
    public void processMessage2(ExampleEvent2 msg) {
        log.info(&quot;param:{msg2 = [&quot; + msg + &quot;]} info:&quot;);
    }

    /**
     * 下面的多个消费者，消费的类型不一样没事，不会被调用，但是如果缺了相应消息的处理Handler则会报错
     *
     * @param msg
     */
    @RabbitHandler
    public void processMessage3(ExampleEvent3 msg) {
        log.info(&quot;param:{msg3 = [&quot; + msg + &quot;]} info:&quot;);
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注解将消息和消息头注入消费者方法&quot;&gt;注解将消息和消息头注入消费者方法&lt;/h2&gt;
&lt;p&gt;在上面也看到了&lt;code&gt;@Payload&lt;/code&gt;等注解用于注入消息。这些注解有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Header 注入消息头的单个属性&lt;/li&gt;
&lt;li&gt;@Payload 注入消息体到一个JavaBean中&lt;/li&gt;
&lt;li&gt;@Headers 注入所有消息头到一个Map中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有一点主要注意，如果是&lt;code&gt;com.rabbitmq.client.Channel&lt;/code&gt;,&lt;code&gt;org.springframework.amqp.core.Message&lt;/code&gt;和&lt;code&gt;org.springframework.messaging.Message&lt;/code&gt;这些类型，可以不加注解，直接可以注入。&lt;br/&gt;如果不是这些类型，那么不加注解的参数将会被当做消息体。不能多于一个消息体。如下方法ExampleEvent就是默认的消息体：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void process2(@Headers Map&amp;lt;String, Object&amp;gt; headers,ExampleEvent msg);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于消费者确认&quot;&gt;关于消费者确认&lt;/h2&gt;
&lt;p&gt;RabbitMq消费者可以选择手动和自动确认两种模式，如果是自动，消息已到达队列，RabbitMq对无脑的将消息抛给消费者，一旦发送成功，他会认为消费者已经成功接收，在RabbitMq内部就把消息给删除了。另外一种就是手动模式，手动模式需要消费者对每条消息进行确认(也可以批量确认)，RabbitMq发送完消息之后，会进入到一个待确认(unacked)的队列，如下图红框部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262010_450.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果消费者发送了ack，RabbitMq将会把这条消息从待确认中删除。如果是nack并且指明不要重新入队列，那么该消息也会删除。但是如果是nack且指明了重新入队列那么这条消息将会入队列，然后重新发送给消费者，被重新投递的消息消息头amqp_redelivered属性会被设置成true，客户端可以依靠这点来判断消息是否被确认,可以好好利用这一点，如果每次都重新回队列会导致同一消息不停的被发送和拒绝。消费者在确认消息之前和RabbitMq失去了连接那么消息也会被重新投递。所以手动确认模式很大程度上提高可靠性。自动模式的消息可以提高吞吐量。&lt;/p&gt;
&lt;p&gt;spring手动确认消息需要将&lt;code&gt;SimpleRabbitListenerContainerFactory&lt;/code&gt;设置为手动模式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        simpleRabbitListenerContainerFactory.setAcknowledgeMode(AcknowledgeMode.MANUAL);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手动确认的消费者代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SneakyThrows
    @RabbitListener(bindings = @QueueBinding(
        exchange = @Exchange(value = RabbitMQConstant.CONFIRM_EXCHANGE, type = ExchangeTypes.TOPIC,
            durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
        value = @Queue(value = RabbitMQConstant.CONFIRM_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
            autoDelete = RabbitMQConstant.true_CONSTANT),
        key = RabbitMQConstant.CONFIRM_KEY),
        containerFactory = &quot;containerWithConfirm&quot;)
    public void process(ExampleEvent msg, Channel channel, @Header(name = &quot;amqp_deliveryTag&quot;) long deliveryTag,
                        @Header(&quot;amqp_redelivered&quot;) boolean redelivered, @Headers Map&amp;lt;String, String&amp;gt; head) {
        try {
            log.info(&quot;ConsumerWithConfirm receive message:{},header:{}&quot;, msg, head);
            channel.basicAck(deliveryTag, false);
        } catch (Exception e) {
            log.error(&quot;consume confirm error!&quot;, e);
            //这一步千万不要忘记，不会会导致消息未确认，消息到达连接的qos之后便不能再接收新消息
            //一般重试肯定的有次数，这里简单的根据是否已经重发过来来决定重发。第二个参数表示是否重新分发
            channel.basicReject(deliveryTag, !redelivered);
            //这个方法我知道的是比上面多一个批量确认的参数
            // channel.basicNack(deliveryTag, false,!redelivered);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于spring的AcknowledgeMode需要说明，他一共有三种模式：NONE,MANUAL,AUTO,默认是AUTO模式。这比RabbitMq原生多了一种。这一点很容易混淆，这里的NONE对应其实就是RabbitMq的自动确认，MANUAL是手动。而AUTO其实也是手动模式，只不过是Spring的一层封装，他根据你方法执行的结果自动帮你发送ack和nack。如果方法未抛出异常，则发送ack。如果方法抛出异常，并且不是&lt;code&gt;AmqpRejectAndDontRequeueException&lt;/code&gt;则发送nack，并且重新入队列。如果抛出异常时&lt;code&gt;AmqpRejectAndDontRequeueException&lt;/code&gt;则发送nack不会重新入队列。我有一个例子专门测试NONE，见&lt;code&gt;CunsumerWithNoneTest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还有一点需要注意的是消费者有一个参数prefetch，它表示的是一个Channel(也就是SimpleMessageListenerContainer的一个线程)预取的消息数量，这个参数只会在手动确认的消费者才生效。可以客户端利用这个参数来提高性能和做流量控制。如果prefetch设置的是10,当这个Channel上unacked的消息数量到达10条时，RabbitMq便不会在向你发送消息，客户端如果处理的慢，便可以延迟确认在方法消息的接收。至于提高性能就非常容易理解，因为这个是批量获取消息，如果客户端处理的很快便不用一个一个去等着去新的消息。SpringAMQP2.0开始默认是250,这个参数应该已经足够了。注意之前的版本默认值是1所以有必要重新设置一下值。当然这个值也不能设置的太大，RabbitMq是通过round robin这个策略来做负载均衡的，如果设置的太大会导致消息不多时一下子积压到一台消费者，不能很好的均衡负载。另外如果消息数据量很大也应该适当减小这个值，这个值过大会导致客户端内存占用问题。如果你用到了事务的话也需要考虑这个值的影响，因为事务的用处不大，所以我也没做过多的深究。&lt;/p&gt;
&lt;h2 id=&quot;关于发送者确认模式&quot;&gt;关于发送者确认模式&lt;/h2&gt;
&lt;p&gt;考虑这样一个场景：你发送了一个消息给RabbitMq，RabbitMq接收了但是存入磁盘之前服务器就挂了，消息也就丢了。为了保证消息的投递有两种解决方案，最保险的就是事务（和DB的事务没有太大的可比性）， 但是因为事务会极大的降低性能，会导致生产者和RabbitMq之间产生同步(等待确认)，这也违背了我们使用RabbitMq的初衷。所以一般很少采用，这就引入第二种方案：发送者确认模式。&lt;/p&gt;
&lt;p&gt;发送者确认模式是指发送方发送的消息都带有一个id，RabbitMq会将消息持久化到磁盘之后通知生产者消息已经成功投递，如果因为RabbitMq内部的错误会发送ack。注意这里的发送者和RabbitMq之间是异步的，所以相较于事务机制性能大大提高。其实很多操作都是不能保证绝对的百分之一百的成功，哪怕采用了事务也是如此，可靠性和性能很多时候需要做一些取舍，想很多互联网公司吹嘘的5个9，6个9也是一样的道理。如果不是重要的消息性能计数器，完全可以不采用发送者确认模式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里有一点我当时纠结了很久，我一直以为发送者确认模式的回调是客户端的ack触发的，这里是大大的误解！发送者确认模式和消费者没有一点关系，消费者确认也和发送者没有一点关系，两者都是在和RabbitMq打交道，发送者不会管消费者有没有收到，只要消息到了RabbitMq并且已经持久化便会通知生产者，这个ack是RabbitMq本身发出的，和消费者无关&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送者确认模式需要将Channel设置成Confirm模式，这样才会收到通知。Spring中需要将连接设置成Confirm模式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;connectionFactory.setPublisherConfirms(isConfirm);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在RabbitTemplate中设置确认的回调,correlationData是消息的id，如下（只是简单打印下）:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // 设置RabbitTemplate每次发送消息都会回调这个方法
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause)
            -&amp;gt; log.info(&quot;confirm callback id:{},ack:{},cause:{}&quot;, correlationData, ack, cause));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送时需要给出唯一的标识(&lt;code&gt;CorrelationData&lt;/code&gt;):&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    rabbitTemplateWithConfirm.convertAndSend(RabbitMQConstant.DEFAULT_EXCHANGE, RabbitMQConstant.DEFAULT_KEY,
                new ExampleEvent(i, &quot;confirm message id:&quot; + i),
                new CorrelationData(Integer.toString(i)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一个参数需要说下：mandatory。这个参数为true表示如果发送消息到了RabbitMq，没有对应该消息的队列。那么会将消息返回给生产者，此时仍然会发送ack确认消息。&lt;/p&gt;
&lt;p&gt;设置RabbitTemplate的回调如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey)
            -&amp;gt; log.info(&quot;return callback message：{},code:{},text:{}&quot;, message, replyCode, replyText));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外如果是RabbitMq内部的错误，不会调用该方法。所以如果消息特别重要，对于未确认的消息，生产者应该在内存用保存着，在确认时候根据返回的id删除该消息。如果是nack可以将该消息记录专门的日志或者转发到相应处理的逻辑进行后续补偿。RabbitTemplate也可以配置RetryTemplate，发送失败时直接进行重试，具体还是要结合业务。&lt;/p&gt;
&lt;p&gt;最后关于发送者确认需要提的是spring，因为spring默认的Bean是单例的，所以针对不同的确认方案(其实有不同的确认方案是比较合理的，很多消息不需要确认，有些需要确认)需要配置不同的bean.&lt;/p&gt;
&lt;h2 id=&quot;消费消息死信队列和retrytemplate&quot;&gt;消费消息、死信队列和RetryTemplate&lt;/h2&gt;
&lt;p&gt;上面也提到了如果消费者抛出异常时默认的处理逻辑。另外我们还可以给消费者配置RetryTemplate，如果是采用SpringBoot的话，可以在application.yml配置中配置如下：&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring:
  rabbitmq:
    listener:
       retry:
    #    重试次数
          max-attempts: 3
        #   开启重试机制
          enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，如果消费者失败的话会进行重试，默认是3次。&lt;em&gt;注意这里的重试机制RabbitMq是为感知的&lt;/em&gt;！到达3次之后会抛出异常调用&lt;code&gt;MessageRecoverer&lt;/code&gt;。默认的实现为RejectAndDontRequeueRecoverer，也就是打印异常，发送nack，不会重新入队列。&lt;br/&gt;我想既然配置了重试机制消息肯定是很重要的，消息肯定不能丢，仅仅是日志可能会因为日志滚动丢失而且信息不明显，所以我们要讲消息保存下来。可以有如下这些方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用RepublishMessageRecoverer这个MessageRecoverer会发送发送消息到指定队列&lt;/li&gt;
&lt;li&gt;给队列绑定死信队列，因为默认的RepublishMessageRecoverer会发送nack并且requeue为false。这样抛出一场是这种方式和上面的结果一样都是转发到了另外一个队列。详见DeadLetterConsumer&lt;/li&gt;
&lt;li&gt;注册自己实现的MessageRecoverer&lt;/li&gt;
&lt;li&gt;给MessageListenerContainer设置RecoveryCallback&lt;/li&gt;
&lt;li&gt;对于方法手动捕获异常，进行处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我比较推荐前两种。这里说下死信队列，死信队列其实就是普通的队列，只不过一个队列声明的时候指定的属性，会将死信转发到该交换器中。声明死信队列方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @RabbitListener(
        bindings = @QueueBinding(
            exchange = @Exchange(value = RabbitMQConstant.DEFAULT_EXCHANGE, type = ExchangeTypes.TOPIC,
                durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
            value = @Queue(value = RabbitMQConstant.DEFAULT_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
                autoDelete = RabbitMQConstant.true_CONSTANT, arguments = {
                @Argument(name = RabbitMQConstant.DEAD_LETTER_EXCHANGE, value = RabbitMQConstant.DEAD_EXCHANGE),
                @Argument(name = RabbitMQConstant.DEAD_LETTER_KEY, value = RabbitMQConstant.DEAD_KEY)
            }),
            key = RabbitMQConstant.DEFAULT_KEY
        ))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也就只是在声明的时候多加了两个参数x-dead-letter-exchange和x-dead-letter-routing-key。这里一开始踩了一个坑，因为&lt;code&gt;@QueueBinding&lt;/code&gt;注解中也有arguments属性，我一开始将参数声明到&lt;code&gt;@QueueBinding&lt;/code&gt;中，导致一直没绑定成功。如果绑定成功可以在控制台看到queue的Featrues有DLX(死信队列交换器)和DLK(死信队列绑定)。如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262129_364.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013256816/article/details/54933065&quot;&gt;关于消息进入死信的规则&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息被拒绝(basic.reject/basic.nack)并且requeue=false&lt;/li&gt;
&lt;li&gt;消息TTL过期&lt;/li&gt;
&lt;li&gt;队列达到最大长度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们用到的就是第一种。&lt;/p&gt;
&lt;h2 id=&quot;rpc模式的消息不常用&quot;&gt;RPC模式的消息（不常用）&lt;/h2&gt;
&lt;p&gt;本来生产者和消费者是没有耦合的，但是可以通过一些属性产生耦合。在早期版本中，如果一个生产者想要收到消费者的回复，实现方案是生产者在消息头中加入reply-to属性也就是队列(一般是私有，排他，用完即销毁)的名字，然后在这个队列上进行监听，消费者将回复发送到这个队列中。RabbitMq3.3之后有了改进，就是不用没有都去创建一个临时队列，这样很耗费性能，可以采用drect-to模式，省去了每次创建队列的性能损耗，但是还是要创建一次队列。现在Spring默认的就是这个模式。RabbitTemplate中有一系列的&lt;code&gt;sendAndReceiveXX&lt;/code&gt;方法。默认等待5秒，超时返回null。用&lt;br/&gt;法和不带返回的差不多。&lt;/p&gt;
&lt;p&gt;消费者的方法通过返回值直接返回消息(下面的方法是有返回值的)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public String receive(@Headers Map&amp;lt;String, Object&amp;gt; headers, @Payload ExampleEvent msg) {
        log.info(&quot;reply to consumer param:{headers = [&quot; + headers + &quot;], msg = [&quot; + msg + &quot;]} info:&quot;);
        return REPLY;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的提一下最后一个注解&lt;code&gt;@SendTo&lt;/code&gt;,用在消费方法上，指明返回值的目的地，默认不用的话就是返回给发送者，可以通过这个注解改变这种行为。如下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @RabbitListener(
        bindings = @QueueBinding(
            exchange = @Exchange(value = RabbitMQConstant.REPLY_EXCHANGE, type = ExchangeTypes.TOPIC,
                durable = RabbitMQConstant.FALSE_CONSTANT, autoDelete = RabbitMQConstant.true_CONSTANT),
            value = @Queue(value = RabbitMQConstant.REPLY_QUEUE, durable = RabbitMQConstant.FALSE_CONSTANT,
                autoDelete = RabbitMQConstant.true_CONSTANT),
            key = RabbitMQConstant.REPLY_KEY
        )
    )
    @SendTo(&quot;queue.reply.s&quot;)
    public ExampleEvent log(ExampleEvent event) {
        log.info(&quot;log receive message:O{}&quot;, event);
        return new ExampleEvent(1, &quot;log result&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就是会将消息直接发送到默认交换器，并且以queue.reply.s作为路由键。@SendTo的格式为exchange/routingKey用法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;foo/bar： 指定的交换器和key&lt;/li&gt;
&lt;li&gt;foo/： 指定的交换器，key为空&lt;/li&gt;
&lt;li&gt;bar或者/bar： 到空交换器&lt;/li&gt;
&lt;li&gt;/或者空：空的交换器和空的key&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里还需要提一下，因为默认所有的队列都会绑定到空交换器，并且以队列名字作为Routekey， 所以SendTo里面可以直接填写队列名字机会发送到相应的队列.如日志队列。因为RPC模式不常用，专业的东西做专业的事，就像我们一般不用Redis来做消息队列一样(虽然他也可以实现)，一般公司都有特定的技术栈，肯定有更合适的RPC通信框架。当然如果要跨语言的集成这个方案也是一种不错的方案，可以继续考虑采用异步发送&lt;code&gt;AsyncRabbitTemplate&lt;/code&gt;来降低延迟等优化方案!&lt;/p&gt;
&lt;h2 id=&quot;关于消费模型&quot;&gt;关于消费模型&lt;/h2&gt;
&lt;p&gt;RabbitMQ底层的消费模型有两种Push和Pull。我在网上查阅资料的时候发现有很多教程采用了pull这种模式。RabbitMq实战和&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u013256816/article/details/62890189&quot;&gt;RabbitMQ之Consumer消费模式（Push &amp;amp; Pull）&lt;/a&gt;都指出这种模式性能低，会影响消息的吞吐量，增加不必要的IO，所以除非有特殊的业务需求，不要采用这种方案。Spring的封装就是采用了push的方案。&lt;/p&gt;
&lt;h2 id=&quot;关于rabbitmq客户端的线程模型&quot;&gt;关于RabbitMq客户端的线程模型&lt;/h2&gt;
&lt;p&gt;这里讲的是消费者的，生产者没什么好讲的。先看消息流转图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262319_900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中椭圆表示线程，矩形是队列。消息到达AMQP的连接线程，然后分发到client线程池，随后分发到监听器。注意除了监听器的线程，其他都是在&lt;code&gt;com.rabbitmq.client.impl.AMQConnection&lt;/code&gt;中创建的线程，我们对线程池做一些修改。连接线程名字不能修改就是AMQP Connection打头。心跳线程可以设置setConnectionThreadFactory来设置名字。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    connectionFactory.setConnectionThreadFactory(new ThreadFactory() {
            public final AtomicInteger id = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, MessageFormat.format(&quot;amqp-heart-{0}&quot;, id.getAndIncrement()));
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;client线程池见：&lt;code&gt;com.rabbitmq.client.impl.ConsumerWorkService&lt;/code&gt;构造方法。Executors.newFixedThreadPool(DEFAULT_NUM_THREADS, threadFactory)。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   final ExecutorService executorService = Executors.newFixedThreadPool(5, new ThreadFactory() {
            public final AtomicInteger id = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, MessageFormat.format(&quot;amqp-client-{0}&quot;, id.getAndIncrement()));
            }
        });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;listener的线程设置如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        simpleRabbitListenerContainerFactory.setTaskExecutor(new SimpleAsyncTaskExecutor&quot;amqp-consumer-&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：SimpleAsyncTaskExecutor每次执行一个任务都会新建一个线程，对于生命周期很短的任务不要使用这个线程池(如client线程池的任务)， 这里的消费者线程生命周期直到SimpleMessageListenerContainer停止所以没有适合这个场景&lt;/p&gt;
&lt;p&gt;修改过之后的线程如下：&lt;br/&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262308_811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息投递过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在AMQConnection中开启连接线程，该线程用于处理和RabbitMq的通信：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public void startMainLoop() {
        MainLoop loop = new MainLoop();
        final String name = &quot;AMQP Connection &quot; + getHostAddress() + &quot;:&quot; + getPort();
        mainLoopThread = Environment.newThread(threadFactory, loop, name);
        mainLoopThread.start();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;AMQConnection.heartbeatExecutor是心跳线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;AMQConnection.consumerWorkServiceExecutor则是用来处理事件的线程池，AMQConnection线程收到消息投递到这里。&lt;br/&gt;分发逻辑详见com.rabbitmq.client.impl.ChannelN#processAsync-&amp;gt;com.rabbitmq.client.impl.ConsumerDispatcher#handleDelivery-&amp;gt;投递到线程池.&lt;/li&gt;
&lt;li&gt;线程池中继续将消息投递到org.springframework.amqp.rabbit.listener.BlockingQueueConsumer#queue中&lt;/li&gt;
&lt;li&gt;consumer线程进行最终消息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的是默认的消费者监听器。SpringAMQP 2.0引入了一个新的监听器实现&lt;code&gt;DirectMessageListenerContainer&lt;/code&gt;。这个实现最大的变化在于消费者的处理逻辑不是在自己的线程池中执行而是直接在client线程池中处理，这样最明显的是省去了线程的上下文切换的开销，而且设计上也变得更为直观。所以如果采用这个监听器需要覆盖默认的线程池加大Connection的线程池。采用这个监听器只需要设置&lt;code&gt;@RabbitListener&lt;/code&gt;的containerFactory属性。声明方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Bean
    DirectRabbitListenerContainerFactory directRabbitListenerContainerFactory(ConnectionFactory connectionFactory) {
        final DirectRabbitListenerContainerFactory directRabbitListenerContainerFactory = new DirectRabbitListenerContainerFactory();
        directRabbitListenerContainerFactory.setConsumersPerQueue(Runtime.getRuntime().availableProcessors());
        directRabbitListenerContainerFactory.setConnectionFactory(connectionFactory);
        directRabbitListenerContainerFactory.setMessageConverter(new Jackson2JsonMessageConverter());
        directRabbitListenerContainerFactory.setConsumersPerQueue(10);
        return directRabbitListenerContainerFactory;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时的消息流转图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809262319_841.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一些关于监听器的例子和Springboot配置我放在了源码里，这里不再讲述。&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:13:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 在公司里一直在用RabbitMQ，由于api已经封装的很简单，关于RabbitMQ本身还有封装的实现没有了解，最近在看RabbitMQ实战这本书，结合网上的一些例子和spring文档，实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/9710698.html</dc:identifier>
</item>
<item>
<title>工作一年多的感慨与总结（一） - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9710680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9710680.html</guid>
<description>&lt;h2&gt;前言　&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;博文断更了一月左右，期间是由于跳槽、离职、租房等等各种事耽误了，今天本来想写些技术的东西，但是突然觉得：从2017毕业到现在至始至终没有分享或记录过自己的一些心情杂事，都是些技术博文。&lt;/p&gt;
&lt;p&gt;其实，早就想分享下自己这一年的收获，或多或少做些回忆，同时鞭策自己以后更加努力，好了，啰啰嗦嗦写了很多“流水账”，有点乱，希望能谅解！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;hr/&gt;
&lt;h2&gt;2017/7-2017/9  找工作面试感慨&lt;/h2&gt;
&lt;p&gt;　　不像大多数应届毕业生，参加校招之后进入比较理想的公司。在2017/7月25号因为一些变故放弃了一个比较稳定的工作，重新收拾心情回到家自学（基本都是刷面试笔试题）了15天，8月10号左右来到KM，当时身无分文借住 于一位好友租房中，&lt;span&gt;&lt;strong&gt;找工作方面：笔试-&amp;gt;面试-&amp;gt;刷题-&amp;gt;总结，心情则是这样的：期待-&amp;gt;啥玩意！？工资3k！？？-&amp;gt;自我怀疑，啥我咋这都不会，我大学学了啥-&amp;gt;啥！！看我不错，让我做一年实习生，转不转正到时候看我表现-&amp;gt;啥？你知道我们公司最重要的是什么吗？是感恩，是狼性文化-&amp;gt;没事的，先养活自己要紧同时学技术！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;由于走的是社招，虽然没有特意表明应届生的身份，但是仍然每次都会被贴上“应届生”的身份，总是被告之“我是来学习，不是来工作的”&lt;/strong&gt;&lt;/span&gt;。前前后后10多家公司，里面有太多心酸，比如被HR催面试，结果花了很多钱打车到人家公司楼下面试，被突然告之老板出差下个月再说等，当然这并不是说这样的公司很多，可能是我运气有点背，当时也急于找工作稳定下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，找到一个当地算是零售/饮食行业算是不错的公司，从事“企业信息化”相关的开发，最主要的是提供住宿！提供住宿！提供住宿！ （所以我是不会提工资的）第二天早晨6点起床，一个人背上自己的行李，拖着重重的行李箱步行到公司大巴上车处，当时已是快下午1点，随后坐公司大巴来到荒无人烟的公司总部大楼前，收拾好心情入职报道！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2017/9-2018/9 一年职场感慨&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;　一切看似算时顺利吧，但入职这一年期间发生了很多让我震惊的事情：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（1）开发团队=我自己&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　之前面试的时候说到：除了我一个开发人员以外，还有个高级开发。算是我未见面的师傅，结果后来才发现是早就已经提了离职，等人来入职后才离职的，我算是来填坑的吗？？？？(黑人问号.gif)，果然后面一天人家就来办正式离职了，一堆文件交接给我就走了!&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（2）开发技术面试官虽是开发经理，但已10多年不编程。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　也就是我的顶头上司就是开发经理，他下手也就只有我一个初级开发工程师！面试的时候说是有啥开发的问题都可以找他，后来发现却只是管理项目，并不是参与编程，也不是很懂编程，停留在07/08年开发水平与知识，但是数据库方面确实很牛逼，值得我学习！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（3）信息部门刚成立两年，据说公司两年前还在用手工录单（电商方面单子）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　这让我深刻体会到一个当代企业建立并完善信息化的重要性，据说我们部门成立后，引进了CRM、WMS等系统之后，至少提升了公司50%的营销量，然而正如部门老大所说：往往引入信息化在以销售为主的公司是一下子看不到成绩的，需要强硬的数据才能展示，所以emmm.......部门当然没有收到很好的重视，但大家似乎都知道这个道理仍然努力着！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　（4）第一次觉得跟人沟通这么难&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　当时接受一个外包人员写的系统（系统各种烂就不说了，从按计划2018/2验收到2018/7bug才解决完，勉强验收），需要跟工厂里工人师傅与外包人员对接，单纯的我以为都是我们都是底层人员，肯定很好沟通的。结果写个文档错别字让我看不懂，每次都需要修改错别字，之后却被骂之：你以为你是老师吗？很牛逼嘛，改我写的错别字！当然，我还会常常在群里“劝架（这个师傅脾气很暴躁，经常撕外包开发的兄弟，两人经常在有领导的群里开撕）”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　最好笑的是一会我是这个师傅的兄弟（常常替他解围，跟外包人员沟通），一会我是叛徒（有点可笑呢，说我替外包人员说话），一会就开始问候我妈了（当时我已经做好辞职的打算了，跑到工厂里必须要跟他打一架），但是被比我晚两个月份入职的高级开发，也就是我师傅拦住了，跟我说了好多。最后算是平静下来了（这后面当然还有更搞笑的，哈哈哈，之后觉得有趣的朋友可以评论，我有时间再写），哦对了，这时的高级开发算是在初入职场的贵人吧，之后会写到他给我一些感慨，还有我从他身上学到一些东西！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;当然，并不是奇葩震惊的事居多，这一年时间内我也会学会了很多，也要感谢很多当时离职没有当面说谢谢的人！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;----------------------------------------------------------------------分割线（今天先暂时写到这吧，有时间再写下一篇）------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 15:07:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 博文断更了一月左右，期间是由于跳槽、离职、租房等等各种事耽误了，今天本来想写些技术的东西，但是突然觉得：从2017毕业到现在至始至终没有分享或记录过自己的一些心情杂事，都是些技术博文。 其实，早</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9710680.html</dc:identifier>
</item>
<item>
<title>Emit动态代理.NetCore迁移之旅 - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/9710406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/9710406.html</guid>
<description>&lt;h2&gt;【前言】&lt;/h2&gt;
&lt;p&gt;　　前面我们介绍了Aop 从静态代理到动态代理：&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/9657451.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/7tiny/p/9657451.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;我们在.NetFramework平台下使用微软提供的Emit技术实现了动态代理类的生成。但是.NetCore作为微软.Net平台的春天，如果类库光支持.NetFramework，那么未免有种没有跟上时代步伐的感觉，那么，我们就赶紧在.NetCore平台也实现一套吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　本想着新建一个.NetStandard项目，代码复制过来就直接能用的，没想到：&lt;span&gt;一路坎坷...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;【开始迁移】&lt;/h2&gt;
&lt;p&gt;　　为了达到类库跨平台的目的，我们新建一个.NetStandard类库，选择什么版本呢？&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926212815737-61449034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了兼容目前很多老旧的项目，我们看到 .NetStandard1.2最低支持.Net Framwork 4.5。为了保持兼容性，先建一个.Net Standard 1.2版本的类库。&lt;/p&gt;
&lt;p&gt;　　代码复制过来，坑如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213845059-881628957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　1.Attribute的获取方法不支持&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213044200-2087751086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　2.Reflection 反射 GetMethods方法不支持，BindingFlags不支持（版本太低，Api没有全部实现）&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213200704-1190760844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213223846-904620648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;万般无奈之下，舍弃了兼容性，保证了代码的迁移。最终将我们的.Net Standard 项目升级到了Api比较完善的2.0版本。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　3..Net Standard/Core平台将以往的系统类库做了精简，曾经在System命名空间下的很多代码已经迁移到了单独的Nuget包中。&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213545854-707583515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果我们要使用Emit这个特性的话，我们需要引用Nuget  &lt;strong&gt;System.Reflection.Emit&lt;/strong&gt;，所有的Emit特性代码都包含在这个组件中。&lt;/p&gt;
&lt;p&gt; 　　...&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213749338-150720012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;一整鼓捣之后，为什么还有代码在报红字...&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214111014-1931839065.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926213955036-1142715205.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　4.旧版不兼容（有的方法已被直接移除）&lt;/h4&gt;
&lt;p&gt;　　这几个方法经过尝试，发现引用/更新程序集是解决不了的。上微软官方文档，居然发现这几个方法已经打上了过期标签。那么替代的方法呢？微软的官方文档里面并没有说明。最终通过一顿搜索，在stackoverflow了解到了.NetCore下的替代方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214520168-1279478109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214535357-748246812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以前的Domain（应用程序域）定义程序集的方法已经迁移到了AssemblyBuilderAccess（程序集访问）类中，虽然这个归类更加合理了，但是一言不合就不兼容是不有点让人吐槽啊...&lt;/p&gt;
&lt;h4&gt;　　5.程序集不支持输出到目录&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214816951-2012829595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　.NetCore 平台已经不支持直接输出到目录，仅仅可以在内存中Run。&lt;/p&gt;
&lt;h4&gt;　　6.typeBuilder类中的CreateType()方法消失&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926214920802-83892555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　CreateType()方法已经被直接移除掉了，官方解释是统一使用他的子类。这个答案最终通过搜索引擎在GitHub上找到了&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/2222&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/coreclr/issues/2222&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　上面的链接是GitHub中 dotnet/coreclr 微软官方项目中的Issue&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926215329839-558157888.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;708&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在其中可以看到我们遇到的很多坑在这里都有解释说明，而且表明了最新的使用方案：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926215510816-1702516838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　于是乎，就用Type的子类TypeInfo类了呗，CreateTypeInfo()&lt;/p&gt;
&lt;h2&gt;【终于不报错了】&lt;/h2&gt;
&lt;p&gt;　　在解决完毕所有的迁移兼容问题后，我们还是上次文章中的所有单元测试流程。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180926215928927-1167675497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　单元测试没有问题，我们本次的 .NetCore 平台代码迁移终于完成。&lt;/p&gt;
&lt;h2&gt;【总结】&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Emit动态代理.NetStandard2.0 最低支持意味着支持.Net Core2.0/.Net Framework 4.6.1以上；&lt;/li&gt;
&lt;li&gt;微软在Api的迁移中，对部分代码进行了重新的归类，但是很多地方对旧版本不兼容我，切没有替换的官方文档；&lt;/li&gt;
&lt;li&gt;.Net Core 平台对系统类库进行了精简，移除了不必要的很多类库，需要使用的时候，通过对应的Nuget进行引用，但是没看到官方清单；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　最终结果是迁移完毕，新的项目命名为 SevenTiny.Bantina.Aop 吧，也算一个基础组件&lt;/p&gt;
&lt;p&gt;　　项目地址：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/sevenTiny/SevenTiny.Bantina&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/sevenTiny/SevenTiny.Bantina&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果想直接引用Nuget使用的，已经构建好了，Nuget包搜索 &lt;strong&gt;SevenTiny.Bantina.Aop&lt;/strong&gt; 即可；&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 26 Sep 2018 14:18:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 前面我们介绍了Aop 从静态代理到动态代理：https://www.cnblogs.com/7tiny/p/9657451.html 我们在.NetFramework平台下使用微软提供的Em</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/7tiny/p/9710406.html</dc:identifier>
</item>
<item>
<title>MUI框架-09-MUI 与后台数据交互 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9709957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9709957.html</guid>
<description>&lt;h2 id=&quot;mui框架-09-mui-与后台数据交互&quot;&gt;MUI框架-09-MUI 与后台数据交互&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本篇介绍使用 art-template 和原生 MUI 的数据交互 mui.ajax 来实现&lt;/li&gt;
&lt;li&gt;我们大家都知道，想要数据交互就要有数据，每次当我们发送请求，我们要清楚，怎么发，发给谁，返回的数据是什么内容，格式&lt;/li&gt;
&lt;li&gt;先放一张图，给大家学习的动力：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180926212056996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; width=&quot;400px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;然后今天呢，介绍的是调用 API，API 是什么呢，就是一个接口，比如知乎日报的API ，我们可以通过这个 API 获取到知乎上最新的消息，并且是 json 格式，我们就不用再去找数据了，其他类型 API 还有 百度语音识别，就是百度给我们一个接口，我们可以想这个接口发送 语音，然后返回给我们识别的结果，我们就没必要就了解具体是怎么识别的&lt;/li&gt;
&lt;li&gt;【注意】：我这里收集了大量的 API ，赠送给大家:&lt;/li&gt;
&lt;li&gt;链接地址：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/82855787&quot;&gt;中国国内 - 可用API合集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;api-分析&quot;&gt;API 分析&lt;/h3&gt;
&lt;h3 id=&quot;ajax&quot;&gt;Ajax&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://dev.dcloud.net.cn/mui/ajax/&quot;&gt;MUI Ajax 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;参数呢，大家自己在官网看就可以，下面开始实战&lt;/li&gt;
&lt;li&gt;这里我们先一起看一下，官网给出的代码示例：如下为通过post方式向某服务器发送鉴权登录的代码片段：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mui.ajax('http://server-name/login.php',{
    data:{
        username:'username',
        password:'password'
    },
    dataType:'json',//服务器返回json格式数据
    type:'post',//HTTP请求类型
    timeout:10000,//超时时间设置为10秒；
    headers:{'Content-Type':'application/json'},                  
    success:function(data){
        //服务器返回响应，根据响应结果，分析是否登录成功；
        ...
    },
    error:function(xhr,type,errorThrown){
        //异常处理；
        console.log(type);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面这段代码就是说，ajax请求，设置一个目标地址，逗号，大括号后面是传入的参数信息&lt;/li&gt;
&lt;li&gt;大家记住一句话 大括号开始 大括号结束就是 json 格式&lt;/li&gt;
&lt;li&gt;然后我们就根据这个做一个实例，准备呢，大家请先根据这篇创建一个简单的页面：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/details/82846484&quot;&gt;MUI框架-08-窗口管理-创建子页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;然后打开我们的自己建的 html 目录下的那个子页面 html文件&lt;/li&gt;
&lt;li&gt;我们用下面代码替换 init() 的 script 标签，具体步骤写在注释：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            mui.init()

            //plusReady，用来定义加载dom后的操作
            mui.plusReady(function() {
                
                //发起 ajax请求，地址使用知乎日报 api 
                mui.ajax('https://news-at.zhihu.com/api/4/theme/11', {
                    /* data 是参数，我们这里不需要，我们只是从 api获取数据
                    data: {
                        username: 'username',
                        password: 'password'
                    },
                    */
                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //我们现在控制台打印一下请求结果
                        console.log(data)
                
                        //然后获取json数据中的具体值
                        console.log(data.stories[0].title)
                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });

            })
        &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;把返回的-json-数据放在页面--&quot;&gt;把返回的 json 数据放在页面 -&lt;/h3&gt;
&lt;h3 id=&quot;使用-art-template---javascript-模板引擎&quot;&gt;使用 art-template - JavaScript 模板引擎&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script src=&quot;../js/template-web.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后我们看一下 art-template 官网&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180926204446395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; width=&quot;500px&quot;/&gt;&lt;/li&gt;
&lt;li&gt;也就是说们要使用这个 art-template，语句使用就要放在 这种 script 标签里，做对数据的渲染&lt;/li&gt;
&lt;li&gt;第一步：把页面上 ul 标签里的内容都删掉，给ul 标签加一个id为zhihu截图：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;ul class=&quot;mui-table-view&quot; id=&quot;zhihu&quot;&amp;gt;&amp;lt;/ul&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第2步把页面里 init 函数的那个 script 标签删掉，步骤，写在注释里了，粘贴下面这段代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 引入template-web.js --&amp;gt;
        &amp;lt;script src=&quot;../js/template-web.js&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;!-- 使用&amp;lt;script id=&quot;list&quot; type=&quot;text/html&quot;&amp;gt; 拼接 html --&amp;gt;
        &amp;lt;script id=&quot;list&quot; type=&quot;text/html&quot;&amp;gt;
                &amp;lt;!-- 循环语法 --&amp;gt;
                {{each stories as list}}
                &amp;lt;li class=&quot;mui-table-view-cell mui-media&quot;&amp;gt;
                    &amp;lt;a href=&quot;javascript:;&quot;&amp;gt;
                        &amp;lt;img class=&quot;mui-media-object mui-pull-left&quot; src=&quot;{{list.images[0]}}&quot;&amp;gt;
                        &amp;lt;div class=&quot;mui-media-body&quot;&amp;gt;
                            &amp;lt;!-- 获取 title --&amp;gt;
                            {{list.title}}
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/a&amp;gt;
                &amp;lt;/li&amp;gt;
                {{/each}}
            &amp;lt;/script&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            mui.init()

            //plusReady，用来定义加载dom后的操作
            mui.plusReady(function() {
                
                //发起 ajax请求，地址使用知乎日报 api 
                mui.ajax('https://news-at.zhihu.com/api/4/theme/11', {
                    /* data 是参数，我们这里不需要，我们只是从 api获取数据
                    data: {
                        username: 'username',
                        password: 'password'
                    },
                    */
                    dataType: 'json', //服务器返回json格式数据
                    type: 'get', //HTTP请求类型
                    timeout: 10000, //超时时间设置为10秒；
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    success: function(data) {
                        //服务器返回响应，根据响应结果，分析是否登录成功；
                        
                        //我们现在控制台打印一下请求结果
                        console.log(data)
                        
                        //然后获取json数据中的具体值
                        //console.log(data.stories[0].title)
                        
                        //list 对应上面的 id，就是得到 拼接的 html
                        var html = template('list', data);
                        //把得到的 html 放到id为 zhihu 的 ul 标签里
                        document.getElementById(&quot;zhihu&quot;).innerHTML = html;
                        console.log(html);

                    },
                    error: function(xhr, type, errorThrown) {
                        //异常处理；
                        console.log(type);
                    }
                });

            })
        &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;真机运行&quot;&gt;真机运行&lt;/h3&gt;
&lt;h3 id=&quot;更多文章链接mui-框架&quot;&gt;更多文章链接：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/category/8079041&quot;&gt;MUI 框架&lt;/a&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;本笔记不允许任何个人和组织转载&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 26 Sep 2018 13:47:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>MUI框架 09 MUI 与后台数据交互 本篇介绍使用 art template 和原生 MUI 的数据交互 mui.ajax 来实现 我们大家都知道，想要数据交互就要有数据，每次当我们发送请求，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9709957.html</dc:identifier>
</item>
</channel>
</rss>