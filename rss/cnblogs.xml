<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WebGL 3D 电信机架实战之数据绑定 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8620358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8620358.html</guid>
<description>&lt;p&gt;在前端中，视图层和数据层需要进行单向或者双向数据绑定，大家都已经不陌生了，有时候 2D 做的比较顺了之后，就会想要挑战一下 3D，不然总觉得痒痒的。这个 3D 机架的 Demo 我觉得非常有代表性，首先，3D 机架用途非常广，尤其是在电信行业，就算不是机架，在比如工业方面 3D 模型以及数据绑定的应用也是非常广泛的，毕竟现在工业物联网已经是大趋势了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322163108826-1186413826.gif&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面动图中，闪烁灯是在不断变化的，由于需要显示的效果美观一点，也实际一点，我截的图还是比较完整的，但是这个闪烁的部分有点看不清楚（cnblog 中放太明显的外链容易被移出首页啊！！！等会再发！）。&lt;/p&gt;

&lt;p&gt; 虽然上面 gif 图中显示的一个是 2D 的一个是 3D 的，但是构建的步骤以及需要的内容是一样的，所以本文只针对 3D 的模型进行代码实现。&lt;/p&gt;
&lt;h2&gt;场景搭建&lt;/h2&gt;
&lt;p&gt;搭建一个 3D 场景是非常快速的，只需要三行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt; ht.DataModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个数据容器 数据容器也可以通过 g3d.getDataModel() 获取&lt;/span&gt;
g3d = &lt;span&gt;new&lt;/span&gt; ht.graph3d.Graph3dView(dm);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个 3D 场景，将数据容器作为参数传递进去，这样数据容器中的内容就可以显示在 3D 场景中了&lt;/span&gt;
g3d.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 3D 场景添加到 body 体中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3D 机架模型构建&lt;/h2&gt;
&lt;p&gt;虽然可以叫设计师直接给我一个 obj 格式的模型，但是我觉得这个比较简答，还是不要麻烦人家了。。。首先是创建一个六面体，模型上面的贴图是我以前用的一个 json 格式的文件，用来作为这个六面体的正面贴图，这些部分都是写在 json 文件里面的，我先截取一小部分的 json 内容，然后用 js 代码复现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;c&quot;: &quot;ht.Node&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个 ht.Node 类型的元素&lt;/span&gt;
  &quot;i&quot;: 1277,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;
  &quot;p&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 set/get 来设置/获取的元素的部分。如 setPosition/getPosition&lt;/span&gt;
    &quot;tag&quot;: &quot;service&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置元素标签 用来作为唯一标识&lt;/span&gt;
    &quot;image&quot;: &quot;symbols/机柜.json&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点图片&lt;/span&gt;
    &quot;rotationX&quot;: 1.5708,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点 X 轴旋转角度&lt;/span&gt;
    &quot;position&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点位置&lt;/span&gt;
      &quot;x&quot;: 0&lt;span&gt;,
      &lt;/span&gt;&quot;y&quot;: 225&lt;span&gt;
    },
    &lt;/span&gt;&quot;anchor&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点锚点&lt;/span&gt;
      &quot;x&quot;: 0.5&lt;span&gt;,
      &lt;/span&gt;&quot;y&quot;: 0.54&lt;span&gt;
    },
    &lt;/span&gt;&quot;anchorElevation&quot;: 1, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点 y 轴锚点&lt;/span&gt;
    &quot;width&quot;: 507,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点宽度&lt;/span&gt;
    &quot;height&quot;: 980, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点长度&lt;/span&gt;
    &quot;tall&quot;: 450, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点高度&lt;/span&gt;
    &quot;elevation&quot;: 451 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制Node图元中心位置所在3D坐标系的y轴位置&lt;/span&gt;
&lt;span&gt;  },
  &lt;/span&gt;&quot;s&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图元的 style 样式，HT 预定义的一些样式属性，通过 node.s('all.color') 获取和设置节点的样式&lt;/span&gt;
    &quot;all.color&quot;: &quot;#DDDDDD&quot;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点六面颜色&lt;/span&gt;
    &quot;top.image&quot;: &quot;symbols/机柜.json&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点顶部图片&lt;/span&gt;
    &quot;front.visible&quot;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点正面是否可见&lt;/span&gt;
    &quot;back.visible&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;left.visible&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;right.visible&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;bottom.visible&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这部分的 json 内容大体上就是创建了一个 ht.Node 节点，然后对这个节点设置了一些属性，包括节点坐标，节点的大小，以及一些 style 样式设置。&lt;/p&gt;
&lt;p&gt;那么，如何用代码来创建这样一个节点呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; ht.Node();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个 ht.Node 类型的节点&lt;/span&gt;
node.setTag('service'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的标签&lt;/span&gt;
node.setImage('symbols/机柜.json'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点图片&lt;/span&gt;
node.setRotationX(Math.PI/2);//设置节点x轴旋转
node.setPosition(0, 225);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点位置&lt;/span&gt;
node.setAnchor(0.5, 0.54);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点锚点&lt;/span&gt;
node.setAnchorElevation(1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点y轴方向的锚点&lt;/span&gt;
&lt;span&gt;
node.setWidth(&lt;/span&gt;507);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的宽度&lt;/span&gt;
node.setHeight(980);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的长度&lt;/span&gt;
node.Tall(450);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点的高度&lt;/span&gt;
node.setElevation(451);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制Node图元中心位置所在3D坐标系的y轴位置&lt;/span&gt;
&lt;span&gt;
node.s({ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点样式&lt;/span&gt;
    'all.color': '#ddd', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;六面颜色&lt;/span&gt;
    'top.image': 'symbols/机柜.json'， &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点顶部图片&lt;/span&gt;
    'front.visible': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点正面可见&lt;/span&gt;
    'back.visible': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;'left.visible': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;'right.visible': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;'bottom.visible': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实整个 json 就是由多个这种类型的图元组合而成的。我们来拆析一下，整个 3D 机架实际上是由十个图元组合而成的，第一个是整体的 3D 机柜（也就是我们上面 json 内容中创建的部分），剩下的九个都是需要动态变化闪烁灯的设备，也就是我红框框起来的部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322165055033-333399961.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这些设备的创建方式跟上面的 3D 机架是类似的，只不过对应的节点尺寸小点，贴图不一样，坐标不一样罢了。但是下面的这九个节点的贴图似乎有点不一样？上面有闪烁的灯，并且不止一盏！怎么动态获取他们呢？&lt;/p&gt;
&lt;h2&gt;矢量--数据绑定&lt;/h2&gt;
&lt;p&gt;不得不说到矢量这个概念。&lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_graphics&quot;&gt;矢量&lt;/a&gt;在 HT for Web 中是矢量图形的简称，常见的 png 和 jpg 这类的栅格位图， 通过存储每个像素的颜色信息来描述图形，这种方式的图片在拉伸放大或缩小时会出现图形模糊，线条变粗出现锯齿等问题。 而矢量图片通过点、线和多边形来描述图形，因此在无限放大和缩小图片的情况下依然能保持一致的精确度。&lt;/p&gt;
&lt;p&gt;这些有点都是次要的，最重要的是这个矢量可以进行数据绑定（这个数据绑定是绑定到节点中的），而且绑定方式非常容易！&lt;/p&gt;
&lt;p&gt;矢量采用 json 格式描述，使用方式和普通的栅格位图一致，通过 node.setImage('hightopo.json') 或者 node.setIcon('hightopo.json') 等设置到数据模型中。&lt;/p&gt;
&lt;p&gt;矢量 json 描述必需包含 width、height 和 comps 参数信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;width 矢量图形的宽度&lt;/li&gt;
&lt;li&gt;height 矢量图形的高度&lt;/li&gt;
&lt;li&gt;comps 矢量图形的组件 Array 数组，每个数组对象为一个独立的组件类型，数组的顺序为组件绘制先后顺序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于这张图绘制的还是比较复杂的，所以我就将设置了数据绑定的矩形部分的矢量绘制代码粘贴出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51.833492822967&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;width&quot;: 48, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个矢量图标必备的宽度 矢量详细内容请参考 &lt;a href=&quot;http://hightopo.com/guide/guide/core/vector/ht-vector-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 矢量手册&lt;/a&gt;&lt;/span&gt;
    &quot;height&quot;: 262,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个矢量图标必备的高度&lt;/span&gt;
    &quot;comps&quot;: [&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个矢量图标必备的 Array 数组组件&lt;/span&gt;
        {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组组件中的第一个元素&lt;/span&gt;
            &quot;type&quot;: &quot;rect&quot;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类型为矩形&lt;/span&gt;
            &quot;background&quot;: {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置矩形背景色&lt;/span&gt;
                &quot;func&quot;: &quot;attr@rectBg1&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HT 用一个带func属性的对象替换以前的参数值 这里就是进行数据绑定的地方&lt;/span&gt;
                &quot;value&quot;: &quot;rgb(255,0,0)&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果 func 值为 undefined 或者 null 时，采用这个值&lt;/span&gt;
&lt;span&gt;            },
            &lt;/span&gt;&quot;shadow&quot;: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置“阴影”&lt;/span&gt;
            &quot;shadowColor&quot;: { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;“阴影”颜色&lt;/span&gt;
                &quot;func&quot;: &quot;attr@shadowColor1&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这边将“阴影”也进行了数据绑定，为的是能够实现灯“发光”的效果&lt;/span&gt;
                &quot;value&quot;: &quot;rgba(255,0,0,0.35)&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置备选值&lt;/span&gt;
&lt;span&gt;            },
            &lt;/span&gt;&quot;shadowOffsetX&quot;: 0, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置阴影横轴偏移量&lt;/span&gt;
            &quot;shadowOffsetY&quot;: 0,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置阴影纵轴偏移量&lt;/span&gt;
            &quot;rect&quot;: [&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该组件的宽高以及坐标&lt;/span&gt;
                4.38544,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x 轴坐标&lt;/span&gt;
                23.52679,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y 轴坐标&lt;/span&gt;
               14.46481, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;width 组件宽度&lt;/span&gt;
               6.1554&lt;span&gt;//&lt;/span&gt;&lt;span&gt;height 组件高度&lt;/span&gt;
&lt;span&gt;           ]
       }
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为一个矢量图形中有 5 个“闪烁灯”，所以我添加了 5 个组件，也就是在 comps 参数里面添加了五个元素，绑定的数据不同，为了省事，我将绑定的数据名都设置为“rectBg”后面加一个数字，这些数字依次递增。&lt;/p&gt;
&lt;p&gt;我们就是将这样一张矢量图设置为节点的 front.image 作为节点正面显示图的：node.s('front.image', 'symbols/内部设备2.json')。&lt;/p&gt;
&lt;h2&gt;JSON 反序列化&lt;/h2&gt;
&lt;p&gt;会不会有人好奇 json 文件里面的内容是如何转换成 3D 模型的？&lt;/p&gt;
&lt;p&gt;说实在的，步骤依然很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ht.Default.xhrLoad('scene/service3d.json', &lt;span&gt;function&lt;/span&gt;(text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xhrLoad 函数是一个异步加载文件的函数&lt;/span&gt;
    dm.deserialize(text);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反序列化数据容器，解析用于生成对应的Data对象并添加到数据容器 这里相当于把 json 文件中生成的 ht.Node 节点反序列化到数据容器中，这样数据容器中就有这个节点了&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 xhrLoad 函数是一个异步加载函数，所以如果 dm 数据容器反序列化未完成就直接调用了其中的节点，那么会造成数据获取不到的结果，所以一般来说我是将一些逻辑代码写在这个函数内部，或者给逻辑代码设置 timeout 错开时间差。&lt;/p&gt;
&lt;p&gt;首先，由于数据都是存储在 dm 数据容器中的（通过 dm.add(node) 添加的），所以我们要获取数据除了可以通过 id、tag 等独立的方式，还可以通过遍历数据容器来获取多个元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; infos =&lt;span&gt; [
    { shadowColor: &lt;/span&gt;'shadowColor1', background: 'rectBg1'&lt;span&gt; },
    { shadowColor: &lt;/span&gt;'shadowColor2', background: 'rectBg2'&lt;span&gt; },
    { shadowColor: &lt;/span&gt;'shadowColor3', background: 'rectBg3'&lt;span&gt; },
    { shadowColor: &lt;/span&gt;'shadowColor4', background: 'rectBg4'&lt;span&gt; },
    { shadowColor: &lt;/span&gt;'shadowColor5', background: 'rectBg5'&lt;span&gt; }
];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len = infos.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数组中的长度&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; datas = dm.toDatas(&lt;span&gt;function&lt;/span&gt;(d) { &lt;span&gt;return&lt;/span&gt; d.getDisplayName() === 'device'; });&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以过滤函数构建新的元素集合并返回（ht.List 数组类型）&lt;/span&gt;
setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    datas.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; info = infos[Math.floor(Math.random() *&lt;span&gt; len)];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; shadowName =&lt;span&gt; info.shadowColor;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bgName =&lt;span&gt; info.background;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.a(shadowName) === 'rgba(255, 0, 0, 0.35)') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若节点业务属性“阴影”颜色为红色，则设置为绿色&lt;/span&gt;
            data.a(shadowName, 'rgba(0, 255, 0, 0.35)'&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若节点业务属性“阴影”颜色为绿色，则设置为红色&lt;/span&gt;
            data.a(shadowName, 'rgba(255, 0, 0, 0.35)'&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.a(bgName) === 'rgb(255, 0, 0)') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若节点业务属性背景颜色为红色，则设置为绿色&lt;/span&gt;
            data.a(bgName, 'rgb(0, 255, 0)'&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若节点业务属性背景颜色为绿色，则设置为红色&lt;/span&gt;
            data.a(bgName, 'rgb(255, 0, 0)'&lt;span&gt;);
        }
    });
}, &lt;/span&gt;1000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整体来说这个 Demo 还是比较有价值的，一是快速实现了 3D 机柜模型，二是对模型上的元素进行了数据绑定。只是想让你们知道，清晰的图片绘制没有那么难~ 3D 的世界没有那么难~ 数据绑定也没有那么难！我希望也能让您发现这并不是件难事。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 23:12:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8620358.html</dc:identifier>
</item>
<item>
<title>在 Scale Up 中使用 Health Check - 每天5分钟玩转 Docker 容器技术（145） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8621305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8621305.html</guid>
<description>&lt;p&gt;&lt;span&gt;对于多副本应用，当执行 Scale Up 操作时，新副本会作为 backend 被添加到 Service 的负责均衡中，与已有副本一起处理客户的请求。考虑到应用启动通常都需要一个准备阶段，比如加载缓存数据，连接数据库等，从容器启动到正真能够提供服务是需要一段时间的。我们可以通过 Readiness 探测判断容器是否就绪，避免将请求发送到还没有 ready 的 backend。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是示例应用的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180322065712030-1119078440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;重点关注 &lt;/span&gt;&lt;code&gt;&lt;span&gt;readinessProbe&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 部分。这里我们使用了不同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;exec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的另一种探测方法 -- &lt;/span&gt;&lt;code&gt;&lt;span&gt;httpGet&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。Kubernetes 对于该方法探测成功的判断条件是 http 请求的返回代码在 200-400 之间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;schema&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定协议，支持 &lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（默认值）和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;HTTPS&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;path&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定访问路径。&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;port&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定端口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面配置的作用是：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;容器启动 10 秒之后开始探测。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;http://[container_ip]:8080/healthy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 返回代码不是 200-400，表示容器没有就绪，不接收 Service &lt;/span&gt;&lt;code&gt;&lt;span&gt;web-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的请求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;每隔 5 秒再探测一次。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;直到返回代码为 200-400，表明容器已经就绪，然后将其加入到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;web-svc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的负责均衡中，开始处理客户请求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;探测会继续以 5 秒的间隔执行，如果连续发生 3 次失败，容器又会从负载均衡中移除，直到下次探测成功重新加入。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;对于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;http://[container_ip]:8080/healthy&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，应用则可以实现自己的判断逻辑，比如检查所依赖的数据库是否就绪，示例代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180322065723738-88046613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① 定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/healthy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的处理函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 连接数据库并执行测试 SQL。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 测试成功，正常返回，代码 200。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ 测试失败，返回错误代码 503。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑤ 在 8080 端口监听。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于生产环境中重要的应用都建议配置 Health Check，保证处理客户请求的容器都是准备就绪的 Service backend。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是 Health Check 在 Scale Up 中的应用，下一节我们讨论在 Rolling Update 中如果应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 22:37:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8621305.html</dc:identifier>
</item>
<item>
<title>记录一则enq: TX - row lock contention的分析过程 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/8628184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/8628184.html</guid>
<description>&lt;p&gt;&lt;strong&gt;故障描述：&lt;/strong&gt;与客户沟通，初步确认故障范围大概是在上午的8:30-10:30之间，反应故障现象是Tomcat的连接数满导致应用无法连接，数据库alert中无明显报错，需要协助排查原因。&lt;/p&gt;

&lt;p&gt;为了便于后续分析，我向客户索要了从昨天下午13:00到今天18:00的awrdump，导入到自己的实验环境进行分析。&lt;/p&gt;
&lt;p&gt;生产环境导出awrdump：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@?/rdbms/admin/awrextr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试环境导入awrdump：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SYS@jyzhao1 &amp;gt;select * from dba_directories;
SYS@jyzhao1 &amp;gt;create directory jy as '/home/oracle/awrdump'; 
SYS@jyzhao1 &amp;gt;select * from dba_directories;
SYS@jyzhao1 &amp;gt;!mkdir -p /home/oracle/awrdump

SYS@jyzhao1 &amp;gt;@?/rdbms/admin/awrload
省略部分输出..
... Dropping AWR_STAGE user

End of AWR Load&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建m_ash表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--create table 
create table m_ash20180322 as select * from dba_hist_active_sess_history where dbid=&amp;amp;dbid;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入生产库对应的dbid，完成创建分析表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select to_char(sample_time, 'yyyy-mm-dd hh24:mi'), count(1)
  FROM m_ash20180322
 group by to_char(sample_time, 'yyyy-mm-dd hh24:mi')
 order by 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据生成的数据生成折线图如下：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_enq_rlc1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以从图中明确故障时刻，即在10:00、12:30、14:10这三个时刻会话都明显上升（积压），看来客户的反馈时间点并没有包含所有异常时刻。&lt;/p&gt;
&lt;p&gt;另外，引用下maclean的诊断脚本，可以看到核心意思差不多，只是进一步将instance_number区分开细化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--验证导出的ASH时间范围:
select
 t.dbid, t.instance_number, min(sample_time), max(sample_time), count(*) session_count
  from m_ash20180322 t
 group by t.dbid, t.instance_number
 order by dbid, instance_number;
 
--确认问题发生的精确时间范围:
 select 
 dbid, instance_number, sample_id, sample_time, count(*) session_count
  from m_ash20180322 t
 group by dbid, instance_number, sample_id, sample_time
 order by dbid, instance_number, sample_time;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;确定每个采样点的top n event，下面也是参考maclean的脚本。&lt;br/&gt;比如我这里以2018-03-22 09:59:00 - 2018-03-22 10:00:00为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select t.dbid,
       t.sample_id,
       t.sample_time,
       t.instance_number,
       t.event,
       t.session_state,
       t.c session_count
  from (select t.*,
               rank() over(partition by dbid, instance_number, sample_time order by c desc) r
          from (select /*+ parallel 8 */
                 t.*,
                 count(*) over(partition by dbid, instance_number, sample_time, event) c,
                 row_number() over(partition by dbid, instance_number, sample_time, event order by 1) r1
                  from dba_hist_active_sess_history t
                where sample_time &amp;gt;
                    to_timestamp('2018-03-22 09:59:00',
                                 'yyyy-mm-dd hh24:mi:ss')
                and sample_time &amp;lt;
                    to_timestamp('2018-03-22 10:00:00',
                                 'yyyy-mm-dd hh24:mi:ss')
                ) t
         where r1 = 1) t
 where r &amp;lt; 3
 order by dbid, instance_number, sample_time, r;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_enq_rlc3_1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他异常时刻，输入对应的变量值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select t.dbid,
       t.sample_id,
       t.sample_time,
       t.instance_number,
       t.event,
       t.session_state,
       t.c session_count
  from (select t.*,
               rank() over(partition by dbid, instance_number, sample_time order by c desc) r
          from (select /*+ parallel 8 */
                 t.*,
                 count(*) over(partition by dbid, instance_number, sample_time, event) c,
                 row_number() over(partition by dbid, instance_number, sample_time, event order by 1) r1
                  from dba_hist_active_sess_history t
                where sample_time &amp;gt;
                    to_timestamp('&amp;amp;begin_sample_time',
                                 'yyyy-mm-dd hh24:mi:ss')
                and sample_time &amp;lt;
                    to_timestamp('&amp;amp;end_sample_time',
                                 'yyyy-mm-dd hh24:mi:ss')
                ) t
         where r1 = 1) t
 where r &amp;lt; 3
 order by dbid, instance_number, sample_time, r;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2018-03-22 12:29:00&lt;br/&gt;2018-03-22 12:30:00&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_enq_rlc3_2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2018-03-22 14:09:00&lt;br/&gt;2018-03-22 14:10:00&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_enq_rlc3_3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上，3个连接数堆积的异常时刻TOP event都是 “enq: TX - row lock contention”。&lt;/p&gt;

&lt;p&gt;使用maclean的脚本，观察每个采样点的等待链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 
 level                     lv,
 connect_by_isleaf         isleaf,
 connect_by_iscycle        iscycle,
 t.dbid,
 t.sample_id,
 t.sample_time,
 t.instance_number,
 t.session_id,
 t.sql_id,
 t.session_type,
 t.event,
 t.session_state,
 t.blocking_inst_id,
 t.blocking_session,
 t.blocking_session_status
  from m_ash20180322 t
where sample_time &amp;gt;
    to_timestamp('2018-03-22 09:59:00',
                 'yyyy-mm-dd hh24:mi:ss')
and sample_time &amp;lt;
    to_timestamp('2018-03-22 10:00:00',
                 'yyyy-mm-dd hh24:mi:ss')
 start with blocking_session is not null
connect by nocycle
 prior dbid = dbid
       and prior sample_time = sample_time
          /*and ((prior sample_time) - sample_time between interval '-1'
          second and interval '1' second)*/
       and prior blocking_inst_id = instance_number
       and prior blocking_session = session_id
       and prior blocking_session_serial# = session_serial#
 order siblings by dbid, sample_time;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_enq_rlc4_1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进一步筛选，将isleaf=1的叶（top holder）找出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--基于上一步的原理来找出每个采样点的最终top holder:
 select t.lv,
       t.iscycle,
       t.dbid,
       t.sample_id,
       t.sample_time,
       t.instance_number,
       t.session_id,
       t.sql_id,
       t.session_type,
       t.event,
       t.seq#,
       t.session_state,
       t.blocking_inst_id,
       t.blocking_session,
       t.blocking_session_status,
       t.c blocking_session_count
  from (select t.*,
               row_number() over(partition by dbid, instance_number, sample_time order by c desc) r
          from (select t.*,
                       count(*) over(partition by dbid, instance_number, sample_time, session_id) c,
                       row_number() over(partition by dbid, instance_number, sample_time, session_id order by 1) r1
                  from (select /*+ parallel 8 */
                         level              lv,
                         connect_by_isleaf  isleaf,
                         connect_by_iscycle iscycle,
                         t.*
                          from m_ash20180322 t
                        where sample_time &amp;gt;
                            to_timestamp('2018-03-22 09:59:00',
                                         'yyyy-mm-dd hh24:mi:ss')
                        and sample_time &amp;lt;
                            to_timestamp('2018-03-22 10:00:00',
                                         'yyyy-mm-dd hh24:mi:ss')
                         start with blocking_session is not null
                        connect by nocycle
                         prior dbid = dbid
                               and prior sample_time = sample_time
                                  /*and ((prior sample_time) - sample_time between interval '-1'
                                  second and interval '1' second)*/
                               and prior blocking_inst_id = instance_number
                               and prior blocking_session = session_id
                               and prior
                                    blocking_session_serial# = session_serial#) t
                 where t.isleaf = 1) t
         where r1 = 1) t
 where r &amp;lt; 3
 order by dbid, sample_time, r;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/jyzhao/846011/o_enq_rlc4_2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对其他异常时段进行分析：&lt;br/&gt;2018-03-22 12:29:00&lt;br/&gt;2018-03-22 12:30:00&lt;/p&gt;
&lt;p&gt;2018-03-22 14:09:00&lt;br/&gt;2018-03-22 14:10:00&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- top holder: DIY sample_time
 select t.lv,
       t.iscycle,
       t.dbid,
       t.sample_id,
       t.sample_time,
       t.instance_number,
       t.session_id,
       t.sql_id,
       t.session_type,
       t.event,
       t.seq#,
       t.session_state,
       t.blocking_inst_id,
       t.blocking_session,
       t.blocking_session_status,
       t.c blocking_session_count
  from (select t.*,
               row_number() over(partition by dbid, instance_number, sample_time order by c desc) r
          from (select t.*,
                       count(*) over(partition by dbid, instance_number, sample_time, session_id) c,
                       row_number() over(partition by dbid, instance_number, sample_time, session_id order by 1) r1
                  from (select /*+ parallel 8 */
                         level              lv,
                         connect_by_isleaf  isleaf,
                         connect_by_iscycle iscycle,
                         t.*
                          from m_ash20180322 t
                        where sample_time &amp;gt;
                            to_timestamp('&amp;amp;begin_sample_time',
                                         'yyyy-mm-dd hh24:mi:ss')
                        and sample_time &amp;lt;
                            to_timestamp('&amp;amp;end_sample_time',
                                         'yyyy-mm-dd hh24:mi:ss')
                         start with blocking_session is not null
                        connect by nocycle
                         prior dbid = dbid
                               and prior sample_time = sample_time
                                  /*and ((prior sample_time) - sample_time between interval '-1'
                                  second and interval '1' second)*/
                               and prior blocking_inst_id = instance_number
                               and prior blocking_session = session_id
                               and prior
                                    blocking_session_serial# = session_serial#) t
                 where t.isleaf = 1) t
         where r1 = 1) t
 where r &amp;lt; 3
 order by dbid, sample_time, r;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现所有的异常时刻最终阻塞都是实例1的sid为3548的session，不再赘述。&lt;/p&gt;

&lt;p&gt;从第四步可以看到，top holder都是实例1，会话3548.&lt;br/&gt;比如可以看到实例1的481会话被实例2的6377会话阻塞，然后实例2的6377会话又被实例1的3548会话阻塞。&lt;br/&gt;通过sql_id可以查询到sql文本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from dba_hist_sqltext where sql_id = '&amp;amp;sql_id';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到实例1的3548会话当前正在执行的SQL只是一个查询语句，当前会话状态是ON CPU，所以推测该会话之前有DML的事物未提交导致阻塞。&lt;br/&gt;去查询该会话的DML操作时，也有update和insert操作，但是update操作已经无法找到对应SQL文本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select t.event, t.*
  from m_ash20180322 t
 where instance_number = 1
   and session_id = 3548
   and t.sql_opname &amp;lt;&amp;gt; 'SELECT';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实从ash也可以看到关于3548阻塞的信息，甚至从addm的建议中也会有类似建议：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   Rationale
      The session with ID 3548 and serial number 8795 in instance number 1 was
      the blocking session responsible for 52% of this recommendation's
      benefit.
   Rationale
      The session with ID 6377 and serial number 30023 in instance number 2
      was the blocking session responsible for 47% of this recommendation's
      benefit.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只不过我们从底层查询，可以看到6377实际也是被3548阻塞，找到最终阻塞者。&lt;/p&gt;
&lt;p&gt;btw，从导入的awrdump中，除了可以取awr外，同样可以支持取awrsqrpi和addmrpti以及ashrpti，非常方便：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SYS@jyzhao1 &amp;gt;@?/rdbms/admin/awrrpti
SYS@jyzhao1 &amp;gt;@?/rdbms/admin/awrsqrpi
SYS@jyzhao1 &amp;gt;@?/rdbms/admin/ashrpti
SYS@jyzhao1 &amp;gt;@?/rdbms/admin/addmrpti&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Thu, 22 Mar 2018 20:18:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/8628184.html</dc:identifier>
</item>
<item>
<title>大话高可用 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8495148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8495148.html</guid>
<description>&lt;p&gt;　　今天老大跟我讨论说，没有看到过一篇够全面体系的高可用的文章。谈到高可用，基本都是以偏概全的文章。今晚抽空想了一下这个问题。&lt;/p&gt;
&lt;p&gt;　　高可用我另一个更资深老大其实总结的很全面了：别人死我们不死，自己不作死，不被队友搞死。&lt;/p&gt;

&lt;p&gt;　　然后就是怎么别人死我们不死：最好就是别人的东西和我们没关系，就是去依赖。如果实在有依赖呢，那就尽量弱依赖。弱依赖有需要被依赖方的返回结果和不依赖返回结果两种。需要结果就要请求后回调，不需要就直接异步化。另外要做好超时和重试、蓄洪、限流、熔断、降级。如果只能强依赖呢，人家死了，那就我们报错，但是我们不死。这也需要设置合理超时和重试、蓄洪、限流、熔断、降级。人家又复活了，我们也要立即恢复。&lt;/p&gt;
&lt;p&gt;　　基于对依赖的策略总结如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180310163646411-164104605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　依赖策略里涉及到容灾的问题。容灾需要解决两个方面的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180310165505994-2110433482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里就怎样快速失败和安全失败举一个例子。java.util包的容器的迭代器，在每次迭代的时候，其内部实现都会去判断modCount变量是否为expectedModCount的值。是的话就继续遍历，否则就抛出异常，终止遍历。这是一个快速失败的典型例子。&lt;/p&gt;
&lt;p&gt;　　而采用安全失败机制的集合容器，在遍历时不时直接在集合内容上访问的，而是先复制原有集合内容，然后在拷贝的集合上进行遍历。所以再遍历过程中对元集合所作的修改并不能被迭代器检测到，不会触发异常。但是这时遍历对原集合的修改是不感知的。&lt;/p&gt;
&lt;p&gt;　　快速恢复有些策略。最简单的比如心跳检测、事件监听等。&lt;/p&gt;
&lt;p&gt;　　安全恢复一般主要是在恢复前对系统或数据先做一些检查、数据还原等。&lt;/p&gt;
&lt;p&gt; 　　有依赖的时候要尽量弱化依赖，除了理清业务逻辑之外，技术手段上可以采用异步化和旁路来解决。&lt;/p&gt;

&lt;p&gt;　　再考虑怎么自己不作死。自己不作死，就是要考虑两个关键字：一个作，一个死。&lt;/p&gt;
&lt;p&gt;　　作就是：改出问题？那就要不出问题：规范流程、做好测试、做好演练和压测。不当小白鼠，只用成熟的技术。职责单一化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180316011942952-92740570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　死就是：要考虑单个接口挂了咋办？单个接口挂了现场返回错误，同时不扩大影响，用其他服务补数据。单个节点挂了咋办？用集群。一个机房挂了咋办？多机房。一个地区的网断了咋办？多地区。后面几个合起来叫做异地多活。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180316012003804-1385351402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;涉及到集群和跨区，就要考虑策略问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180316012140092-1722522955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;策略的问题非常难解决，所以业界做异地多活的非常少。拿阿里巴巴来说，他们的异地多活经历了3个阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180316012236631-674257876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　最后考虑怎么不被队友搞死。&lt;/p&gt;
&lt;p&gt;　　别人死我们不死和不被队友搞死的区别在于，队友和我们需要有明确的业务边界，搞清楚哪些是我们负责的，然后就是保证别人死我们不死。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201803/1112728-20180316012345403-846305307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结与思考：&lt;/p&gt;
&lt;p&gt;　　一个失败的leader是自己很牛，却没能带出来牛人。&lt;/p&gt;
&lt;p&gt;跑题时间：&lt;/p&gt;
&lt;p&gt;炊烟&lt;/p&gt;
&lt;p&gt;　　小时候总爱无故的停下来发呆。有时候是风，想感受风，风的声音、风的力道、风的气息，就这样傻傻的呆站着半天，直到已经走了离我很远的小玩伴们大声在前面叫我。有时候是一座房子，总觉得梦里或者很久很久以前见到过、住过，好熟悉的感觉。而炊烟，是一种心境。袅袅升起的炊烟们，大家觉得自己在毫无规律的完成自己的宿命。而这宿命是由风、由引力、由相互间的碰撞、由炉灶中生的火势，早早已经决定好。大规律是那么一致，各自的曲线又那么不同。努力的想挣脱自己的命运，却又被命运狠狠的捉弄。不是心静的人是看不懂炊烟的。&lt;/p&gt;
&lt;p&gt;小巷&lt;/p&gt;
&lt;p&gt;　　总是会被看上去神秘的小去处吸引，一条蜿蜒的小路、一片树林，一扇断墙，最逃不过的吸引力是古朴的小巷。总能感觉到他们蕴藏的故事和哀怨。每次想到自己在日本新宿时特别想进去的那条“思い出の町”，就想起给别人带来的危险。当时是一群同事一起去的，我好想进去看看，但是被他们叫住，说不知道里面有什么，出了危险怎么办，我只好作罢。然而想来从那以后我也从来没断过把自己置于危险的境地。我终究不会甘于岁月静好，偏爱波澜起伏的人生。这是命运，逃也逃不掉。&lt;/p&gt;
&lt;p&gt;峡谷&lt;/p&gt;
&lt;p&gt;　　现在看电影电视剧到底谁爱上了谁，终究与我无关，爱情之于我仿佛是桌面的落灰，遥远而轻浅。我更关心的是里面的兄弟之情、亲子之情，这些是更永恒纯粹的。那年我回家小姨家，每天睡醒了就去峡谷里的小溪边坐着，看着日光、山涧、青草、山花。后来弟弟给我写信我才知道，这时候他总是在山上，远远的看着我的背影。记得他带我寻访住在山间的书法家，告诉我将来他也要归隐过这样的日子。跟别人，更多的是“欲诉无人能懂”，而血脉之间，无需言语，看到对方就找到了自己。&lt;/p&gt;

&lt;p&gt;　　我喜欢的风景从来都不是特意去某个地方，而是做某件事情过程中的路过。中午出去买水果时伸手接住的雪花、出差到达的另一个国度、坐火车转车干脆订个酒店在附近看到的冰灯…… 也许有一天，你会陪我一起看彼此眼中的风景　　　　&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 20:06:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8495148.html</dc:identifier>
</item>
<item>
<title>Unity的常用API - 张三疯_1998</title>
<link>http://www.cnblogs.com/zhh19981104/p/8628150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhh19981104/p/8628150.html</guid>
<description>&lt;p&gt;&lt;span&gt;1、Event Function:事件函数&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;Reset() &lt;span&gt;:被附加脚本时、在游戏物体的组件上按Reset时会触发该事件函数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Start() &lt;span&gt;:在游戏初始化时会执行一次&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Update() &lt;span&gt;:每一帧都会运行这个方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FixedUpdate(): &lt;span&gt;会在指定帧调用该方法多少次&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LateUpdate(): &lt;span&gt;晚于Update的运行顺序，但是FPS和Update是一样的&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Awake() Start() &lt;span&gt;: 都是在游戏物体初始化运行一次，但是Awake的运行顺序高于Start的，并且只要脚本中存在Awake方法，则无论是否挂载了该脚本都会执行该方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnEnable()&lt;span&gt;: 当将物体的SetActive设置为true时就会自动调用调用该方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnDestory()&lt;span&gt;: 当关闭游戏则会调用该方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;2、Time时间类函数：&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;Time.time &lt;span&gt;表示从游戏开发到现在的时间，会随着游戏的暂停而停止计算。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.timeSinceLevelLoad &lt;span&gt;表示从当前Scene开始到目前为止的时间，也会随着暂停操作而停止。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.deltaTime &lt;span&gt;表示从上一帧到当前帧时间，以秒为单位。【一般用来控制角色、动画的运动】&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.fixedTime &lt;span&gt;表示以秒计游戏开始的时间，固定时间以定期间隔更新（相当于fixedDeltaTime）直到达到time属性。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.fixedDeltaTime &lt;span&gt;表示以秒计间隔，在物理和其他固定帧率进行更新，在Edit-&amp;gt;ProjectSettings-&amp;gt;Time的Fixed Timestep可以自行设置。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.SmoothDeltaTime &lt;span&gt;表示一个平稳的deltaTime，根据前 N帧的时间加权平均的值。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.timeScale &lt;span&gt;时间缩放，默认值为1，若设置&amp;lt;1，表示时间减慢，若设置&amp;gt;1,表示时间加快，可以用来加速和减速游戏，回放等、非常有用。如果游戏中控制运动的都是使用了Time.deltatime的话，则可以通过设置Time.timeScale=0来暂停其运动等。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.frameCount &lt;span&gt;总帧数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.realtimeSinceStartup &lt;span&gt;表示自游戏开始后的总时间，即使暂停也会不断的增加。【一般用作性能测试】&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.captureFramerate &lt;span&gt;表示设置每秒的帧率，然后不考虑真实时间。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.unscaledDeltaTime &lt;span&gt;以秒计算，完成最后一帧的时间 不考虑timescale时候与deltaTime相同，若timescale被设置，则无效。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Time.unscaledTime &lt;span&gt;从游戏开始到现在所用的时间 不考虑timescale时候与time相同，若timescale被设置，则无效。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;3、GameObject类：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【1】、创建游戏物体的三种方法：&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;通过其构造器来创建 &lt;span&gt;GameObject go=new GameObejct(&quot;游戏物体名&quot;); //一般是用来创建空的游戏来存放其他东西的。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Instantiate &lt;span&gt;GameObject.Instantiate(prefab) //根据Prefab或者是另外一个游戏物体来创建（克隆Colon），可以实例粒子、等其他的游戏物体，很是常用的&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;CreattePrimitive &lt;span&gt;GameObject.CreatePrimitive(PrimitiveType.**) //&lt;span&gt;创建原始的游戏物体，基本的几何体&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;【2】、 为游戏物体添加组件&lt;span&gt;， &lt;span&gt;其中组件可以是我们自己自定义的脚本GameObject.AddComponent&amp;lt;组件名&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【3】、属性、变量：&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;GameObject.activeInHierarchy 游戏物体是否处于激活状态，与父类有关，父类被取消激活，则子类也是取消激活的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GameObject.activeSelf 自身的激活状态，与父类无关，只与自身有关。【控制组件的激活与取消激活则使用.enable=false/true】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GameObject.tag 游戏物体的tag标签，具体的由程序员自定义设置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GameObject.SetActive(false/true) 通过参数的控制来设置其游戏物体的激活状态，true为激活状态，反之为取消激活状态。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;【4】、UnityEngine.Object中的共有方法与变量&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;name: 名字，调用该变量，则无论是通过GameObject还是Component都是返回游戏物体的名字&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Destroy() :删除游戏物体，但是不会立马在unity中删除，而是会先进行回收，等确定没对象使用的时候，在进行删除&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DontDestroyOnLoad() : 当加载新的场景的时候，不删除这个场景中的某个游戏物体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FindObjectType&amp;lt;&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FindObjectsType&amp;lt;&amp;gt; : t通过类型来进行查找，是进行全局的查找，则就是在整个场景中进行查找&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FindGameObjectWithTag :如果查到的是多个，则只返回查找到的第一个&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FindGameObejctsWithTag 返回查找到的游戏物体集合&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;【5】、消息的发送&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;BroadcastMessage() 广播发送消息，则该物体上对应的方法会被调用，同时这个游戏物体上的子物体上对应的方法也会被调用的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SendMessage() 发送消息，只会对这个游戏物体中脚本上的方法发送消息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SendMessageUpwards() 广播发送消息，但是和BroadcastMessage()是相反的，在调用自身的方法时也会向上传递，调用其父类的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;【6】、游戏组件的查找&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;Cube cube = target.GetComponent&amp;lt;Cube&amp;gt;(); 返回一个对应的组件，如果有多个，则只返回第一个&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Cube[]cc= target.GetComponents&amp;lt;Cube&amp;gt;(); 返回该游戏物体上所有符合条件的组件，返回一个组件数组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Cube[] xx = target.GetComponentsInChildren&amp;lt;Cube&amp;gt;(); 返回该游戏物体上的对应组件，同时返回该游戏物体的子类上对应的组件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Cube[] yy = target.GetComponentsInParent&amp;lt;Cube&amp;gt;(); 返回该游戏物体上的对应组件，同时返回该游戏物体的父类上对应的组件&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;4、MonoBehaviours的类：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【1】、继承的变量成员&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;enabled: 返回该组件是否被激活或者是被禁用，可以通过该变量来进行设置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;isActiveAndEnabled: 只能返回该组件是否激活的标志位，不能设置该变量，为只读的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;tag :该组件所对应的游戏物体的标签&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;name :该组件所对应的游戏物体的名字&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;【2】、Invoke等方法、变量：&lt;span&gt;将添加要调用的方法添加到等待队列中，然后等待用户设定的时间后，进行队列中的方法调用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;Invoke(&quot;方法1&quot;，float time): 在等待time的时间后调用方法1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;bool i= IsInvoking(&quot;方法1&quot;) 返回bool值，如果方法被添加到队列中，但没有被运行则返回true,如果经过一段时间后该方法被调用了则会返回false;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InvokeRepeating(&quot;方法1&quot;,time,number): 等待time时间后，会重复开始运行方法1，每秒钟运行number次。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;CancelInvoke（） 会暂停通过Involve/InvokeRepeating的运行，但是一般来说CancelInvoke会和InvokeRepeating组合调用。参数由自己设定&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span&gt;扩充： &lt;span&gt;在脚本的类前添加[ExecuteInEditMode]：则该脚本不用按游戏运行按钮就会开始编译，只限在编辑模式里面&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在脚本的共有变量前添加[HideInInspector]:则该共有变量不会在Inspector面板进行显示&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、Coroutines:协程：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、定义协程：IEnumerator 方法名()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;yield return 0/null ;&lt;/p&gt;
&lt;p&gt;yield return new WaitForSeconds(1.0f); //等待一定时间在运行下面的代码&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、开启协程：StartCoroutines(方法名());&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说明：协程开启会继续执行下面代码，不会等协程方法运行完再执行接下来的方法&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、开启与关闭协程时，StartCoriutine(参数)、StopCoroutine(参数) 其中的参数要互相对应，如果传递的是方法名，则两个方法中的参数就要是方法名，如果是IEnumerator的返回值，则其中两个方法发的参数就要是IEnumerator的返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、 private IEnumerator coroutine;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;coroutine = WaitAndPrint();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StartCoroutine(coroutine);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StopCoroutine(coroutine);&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、StartCoroutine(&quot;WaitAndPrint&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StopCoroutine(&quot;WaitAndPrint&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、StopAllCoroutines() 停止所有的协程，不管你是怎么调用的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、OnMousexx鼠标触发事件： &lt;span&gt;如果是通过Collider进行触发检测的话，则要在设置中打开允许进行射线检测。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;OnMouseDown(): 当鼠标按下的时候触发，按一次触发一次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnMouseDrag(): 当鼠标按住不放的时候一直触发，是每一帧进行触发&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnMouseUp(): 当鼠标抬起的时候触发，只执行一次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnMouseEnter(): 当鼠标进入的时候触发，进入一次触发一次&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnMousetOver(): 当鼠标在触发物体的上面时，则一直触发&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnMouseExit(): 当鼠标移出的时候触发&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;OnMouseUpAsButton() 相当于是按钮的功能，当鼠标在同一个游戏物体上按下抬起的时候才会触发，按下与抬起不在同一个游戏上的话则不会进行触发。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;7、Mathf类：所有的成员均为静态的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.Abs() 返回绝对值的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.Ceil() 向上取整的，10.1---&amp;gt;11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.Clamp(value,min,max) 如果value的值在min--max之间的话就返回value,但是如果value的值小于min,则返回min,如果value的值大于max,则返回max，一般是用在控制角色血量，当玩家的血量减少的时候，不会出现出现低于0和大于100的情况 hp= Mathf.Clamp(hp,0,100);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.ClosePowerOfTwo(value): 取得离value的2次方最近的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathg.DeltaAngke: 取得两个角度之间的最小夹角&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.Floor 向下取整&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.Pow(i,j) 取得i的j次方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.MoveToWards() 一般用来做移动控制，是匀速的运动，加速度固定的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.Lerp() 差值运算，一般是用来控制动画、运动，越往后运行的越慢的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mathf.PingPong(t,maxValue) 类似乒乓球的来回运动，起始 值是0，通过t变量来控制值由0向maxValue移动，当t大于maxValue的时候又向0进行移动，然后就这样的来回往复运动，一般t变量用时间Time.deltatime来进行控制的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、Input输入类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetKey() 按键一直按着时触发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetKeyDown 按键被按下那一刻进行触发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetKeyUp 按键被按下后抬起时触发&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;GetMouseButton(0/1/2) 1:左键 2:右键 3:中键 鼠标一直按着时触发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetMouseButtonDown() 鼠标按下那一刻触发、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetMouseButtonUp() 鼠标抬起的那一刻时触发&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;GetButtonDown()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetButton()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetButtonUp() 这三个的参数是用户自定义的虚拟按键进行触发，其他的和上面的一样&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;GetAxis(&quot;虚拟轴名&quot;) 通过按下的虚拟轴来返回-1~1之间的值，开始值是0，然后向-1/1进行渐渐的变化，有一定的加速度。一般用来控制运动的，比如是赛车的加速运动等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetAxisRaw() 其他的和GetAxis差不多，就是少了渐变效果，返回值只有 0 1 -1三个&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;anyKeyDown 当任何按键被按下（包括鼠标按键）时返回true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;anyKey 当任何按键被按着（包括鼠标）时返回true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mousePosition 返回鼠标在屏幕上的像素坐标，【屏幕坐标】z轴衡为0的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;9、Vector2；二维向量&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;magnitude: 返回向量的长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;normalized； 返回这个向量长度为1的矢量，不管这个向量多长，也是返回1的矢量，只是返回值，不对原向量的值产生影响&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Normalize() 无参数的，也是向量化，但是调用该方法会改变原向量值，使其的值被向量化 了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ClampMagnitude() ;将一个向量限制在参数中指定的长度之间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MoveToWards() 用来做匀速的运动，由一个位置向另一个位置进行移动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sqrMagnitude 对求向量的的长度时不进行开平方根运算了，减少性能的损耗，一般是用来比较两个向量的长度大小的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其他的参考API文档即可，较为简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩充：向量是结构体，为值类型，修改其中的变量的时候要整体进行修改，不能单独的进行单个变量的赋值修改&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;10、Vector3：三维变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cross() 插乘运算【左手法则】，通过两个向量来获得另一个向量的方向，然后进行相关的判断&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Project() 投影运算&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Reflect() 反射运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Slerp() 按照角度进行插值，与lerp的按照位置信息进行插值的，一般用在炮台的旋转，使旋转的更加平滑&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;11、Random随机数类：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;InitState（）： 通过参数指定的种子，然后再调用Range()产生随机数的时候会依据种子来进行生成，则每一次运行所生成的随机数都是一样的，是伪随机数。一般要生成的随机数不同，可以设置参数为System.DataTime.Now.Ticks：通过时间戳来完成&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;insideUnitFCircle :在单位为1的园内随机生成一个位置信息，如果要在更大的圆中生成，则可以在后面*圆的半径信息。一般用来控制随机生成敌人的位置信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;insideUnitSphere: 在单位为1的球内随机生成一个位置信息，如果要在更大的球中生成，则可以在后面*圆的半径信息。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;12、四元数 Quaternion:&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;欧拉角【eylarAngles】与面板中的值对应和四元数【rotation】之间是可以进行转换的，一般欧拉角是用来让用户可以直观的看到的，而四元数是用来控制内部的运算 的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.eulerAngles 将四元数转变为欧拉角&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Euler() 将欧拉角转变为四元数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.LookRotation() 让玩家通过设置四元数来进行望向敌人的旋转，将向量方向转变为四元数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Vector3 temp = enemy.position - player.position; &lt;span&gt;//获得两个位置信息之间的变量，是主角望向敌人，所以要设置向量的方向是指向敌人的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;enemp.y = 0; //如果不想主角在望向他的时候出现低头的情况，也就是y轴的值出现了变化了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;player.rotation= Quaternion.LookRotation(temp);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;slerp() 在做朝向的旋转的时候，不建议使用lerp，而是建议使用slerp,使其的旋转朝向更为平滑，更加的自然&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Quaternion target= Quaternion.LookRotation(temp);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;player.rotation = Quaternion.Slerp(player.rotation, target, Time.deltaTime); //插值的缓慢旋转&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;13、Rigidbody：刚体组件，控制角色的移动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.position: 可以通过刚体来控制运动，在控制运动方面，使用rigibody.positon比transform.porition计算要快的多，相关的物理计算也是在刚体中计算好了，但是不建议使用这个方法来持续的控制物体的运动，不平滑，控制一两次的时候还可以使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MovePosition() 对position的优化，其中利用了插值运算，一般持续运动的则使用这个方法，不出现卡顿的现象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;,rotation:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MoveRotation 用来控制刚体的旋转的，一般不建议使用rotation,比较耗性能，建议使用MoveRotation(),然后配合Quaternion,slerp()进行使用，使其更加的平滑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AddForce() 为刚体添加力，一般可以用在赛车游戏中，当进行短时的加速则可以给以限定时间的AddForce方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;14、Camera；相机组件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当相机的标签是main cream时，可以通过Camer.main来进行主相机cream组件的查找射线，用来检测鼠标在屏幕上的位置信息，以及触碰到什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ray ray = cameraMain.ScreenPointToRay(Input.mousePosition); //获得相机到鼠标之间的射线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RaycastHit hit; //用来存放射线检测到的游戏物体的信息的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bool temp = Physics.Raycast(ray, out hit); //进行射线检测&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;15、Application&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SreeamingAcsets: 该文件下的资源不会被压缩，导入是什么类型还是什么类型，【主要是音频、视频资源】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;dataPath: 工程文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;streamingAssetsPath: 可以通过文件流来进行读取的文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;persistenDataPath :可以实例的文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tempporaryCachePath :临时的文件路径&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;.CapturScreenshot(&quot;游戏截图&quot;) 用来截图的，字符串为截图fileName&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Application.identifier 标识名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.companyName 公司名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;productName 产品名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;instalMode 安装包名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isEditor 是否在编辑器模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isFocused 是否在焦点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isMoliePlatform 是否是移动平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isPlaying&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isWebPlayer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;platform 编辑器的平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;unityVersion unity版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;version 项目文件版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;runInBackground 是否可以在后台运行&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;UnityEditor.EditorApplication.isPlaying=false; //在编辑器模式下推出编辑状态&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;16、SceneManager场景类&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;SceneManager.LoadScene() 加载下一个场景，一般是用在另一个场景不是太大的情况下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SceneManager.LoadSceneAsync() 异步加载下一个场景，返回AsyncOperation类型，里面包含了加载的信息，加载的进度条等等。可以让用户缓解等待加载场景的时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sceneCount 获得当前加载的场景个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sceneCountInBuildSettings 在Build面板中加载的场景个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetActiveScene() 获取已经加载的当前场景的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GetSceneAt(index) 加载index索引的场景&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当加载新的场景的时候会触发下面的事件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;activeSceneChanged 当有新场景被加载的时候就会调用这个事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sceneLoaded 当有新场景加载完成的时候就会触发这个事件&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;扩充：&lt;span&gt;事件的注册时通过加方法来进行注册的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SceneManger.activeSceneChanged+=OnAcitiveScenenChanged;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;17、射线检测：一般射线检测要在射线检测的范围内，并且被检测物体要有Collider&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Ray ray=new Ray(起点，方向);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PaycastHit hit; //hit中存放的是射线检测的碰撞信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bool temp=Physics.Raycast(ray,out hit); //具体的重载方法边用边查&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Ray ray = new Ray(this.transform.position + transform.forward, transform.forward); //创建射线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RaycastHit hit; //存储射线检测到的游戏物体信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if(Physics.Raycast(ray,out hit)) //通过返回值来判断射线是否检测到相关的物体了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Debug.Log(hit.collider.gameObject.name);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩充：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Raycast；检测的是射线碰撞到的第一个物体，不具有穿透性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RaycastAll：返回的是RaycastHit数组，具有穿透性，可以返回检测到的多个游戏物体&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;18、代码监听触发事件：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&amp;lt;Button&amp;gt;().onClick.AddListener(方法名)； //当触发button组件，则会触发指定的方法名的方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过实现接口来注册监听事件： using UnityEgine.EventSystems; 导入命名空间&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;IPointerDownHandler 鼠标按下的事件，具体的接口参考手册&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Raycast Target: 如果取消勾选则不做事件监听了，则无法实现检测了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;19、www类，下载 是用来在网络中下载资源的，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;public string url = &quot;http://img.taopic.com/uploads/allimg/120727/201995-120HG1030762.jpg&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IEnumerator Start()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WWW www = new WWW(url);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yield return www;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Renderer renderer = this.GetComponent&amp;lt;Renderer&amp;gt;();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;renderer.material.mainTexture = www.texture;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;20、Touches触摸事件：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Input.touches: 返回放在屏幕上的手指信息，返回数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Touch touch1=Input.touches[0];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;touch1.position;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TouchPhase pahse=touch1.phase phase 是用来返回手指的状态的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;21、Debug.DrawRay(ray.oridin,ray.direction) 绘制射线，第一个参数是原点，第二个是方向&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;22、CharacterController角色控制器&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.SimpleMove(【vector3】) 简单移动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.isGrounded 判断是否到地面上，bool值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.Move() 与simpleMove的区别是要*Time.deltatime、而且simpleMove会使用自带的重力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OnCOntrollerColliderHit(ControllerCollidrHit hit) 当有碰撞到其他的碰撞器的时候会触发这个事件函数【hit保存碰撞到的物体信息】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;23、Mesh的设置：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;material mesh指定人是什么样子的，material指定人的肤色是什么样子的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;24、API变更：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;弃用：Application.LoadLevel();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的：SceneManager.LoadScene(); 加载新的场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;弃用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新的：Scene scene=SceneManager.GetActiveScene(); //获得当前活动场景的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SceneManger.LoadScene(scene.buildIndex) //重新加载当前场景&lt;/p&gt;

&lt;p&gt;OnLevelWasLoaded() 当场景被加载的时候调用，被弃用了&lt;/p&gt;
&lt;p&gt;改成事件了：sceenLoaded&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　&lt;span&gt;【具体的对照官方文档查看即可】&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 17:28:00 +0000</pubDate>
<dc:creator>张三疯_1998</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhh19981104/p/8628150.html</dc:identifier>
</item>
<item>
<title>通过Beego将之前实现的短url项目实现 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8627928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8627928.html</guid>
<description>&lt;p&gt;正好通过这个小例子对之前了解的beego框架的基本内容进行一个简单的应用&lt;/p&gt;
&lt;p&gt;实现的完整代码地址：&lt;a href=&quot;https://github.com/pythonsite/go_simple_code/tree/master/beego_short_url&quot;&gt;https://github.com/pythonsite/go_simple_code/tree/master/beego_short_url&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据库没有什么变化，还是和之前一样，主要是把处理逻辑放到beego中就可以了&lt;/p&gt;
&lt;p&gt;代码的主要目录为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;localhost:beego_short_url zhaofan$ tree
.
├── beego_short_url
├── conf
│   └── app.conf
├── controllers
│   ├── default.go
│   └── short_url.go
├── main.go
├── models
│   └── data.go
├── routers
│   └── router.go
├── static
│   ├── css
│   ├── img
│   └── js
│       └── reload.min.js
├── tests
│   └── default_test.go
└── views
    └── index.tpl

&lt;/span&gt;10 directories, 10 files
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于长短url相互转换的的请求和返回定义的struct在models下的data中，代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package models


type Long2ShortRequest struct {
    OriginUrl string `json:&lt;/span&gt;&quot;origin_url&quot;&lt;span&gt;`
}

type ResponseHeader struct {
    Code &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; `json:&quot;code&quot;&lt;span&gt;`
    Message string `json:&lt;/span&gt;&quot;message&quot;&lt;span&gt;`
}

type Long2ShortResponse struct {
    ResponseHeader
    ShortUrl string `json:&lt;/span&gt;&quot;short_url&quot;&lt;span&gt;`
}

type Short2LongRequest struct {
    ShortUrl string `json:&lt;/span&gt;&quot;short_url&quot;&lt;span&gt;`
}

type Short2LongResponse struct {
    ResponseHeader
    OriginUrl string `json:&lt;/span&gt;&quot;origin_url&quot;&lt;span&gt;`
}

type ShortUrl struct {
    ShortUrl string `json:&lt;/span&gt;&quot;short_url&quot; db:&quot;short_url&quot;&lt;span&gt;`
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而将原来在logic中的处理逻辑都放到了controllers中的short_url文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package controllers

import (
    &lt;/span&gt;&quot;github.com/astaxie/beego&quot;
    &quot;beego_short_url/models&quot;
    &quot;encoding/json&quot;
    &quot;database/sql&quot;
    &quot;crypto/md5&quot;
    &quot;github.com/jmoiron/sqlx&quot;
    &quot;fmt&quot;&lt;span&gt;
    _ &lt;/span&gt;&quot;github.com/go-sql-driver/mysql&quot;&lt;span&gt;
)

var (
    Db &lt;/span&gt;*&lt;span&gt;sqlx.DB
)

func InitDb()(err error){
    Db, err &lt;/span&gt;= sqlx.Open(&quot;mysql&quot;,beego.AppConfig.String(&quot;Db::dsn&quot;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;connect to mysql failed:&quot;&lt;span&gt;,err)
        return
    }
    return
}

type ShortUrl struct {
    Id int64 `db:&lt;/span&gt;&quot;id&quot;&lt;span&gt;`
    ShortUrl string `db:&lt;/span&gt;&quot;short_url&quot;&lt;span&gt;`
    OriginUrl string `db:&lt;/span&gt;&quot;origin_url&quot;&lt;span&gt;`
    HashCode string `db:&lt;/span&gt;&quot;hash_code&quot;&lt;span&gt;`
}

type ShortUrlController struct {
    beego.Controller
}


func (c &lt;/span&gt;*&lt;span&gt;ShortUrlController) Jump() {
    shortUrl :&lt;/span&gt;= c.GetString(&quot;shorturl&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(shortUrl) == 0&lt;span&gt;{
        return
    }
    var req models.Short2LongRequest
    var resp &lt;/span&gt;*models.Short2LongResponse = &amp;amp;&lt;span&gt;models.Short2LongResponse{}

    defer func(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err := recover();err !=&lt;span&gt; nil{
            beego.Error(&lt;/span&gt;&quot;panic err:&quot;&lt;span&gt;,err)
            &lt;/span&gt;//resp.Code = 500
            //resp.Message = &quot;server busy&quot;
            //c.Data[&quot;json&quot;] =&lt;span&gt; resp
            &lt;/span&gt;//&lt;span&gt;c.ServeJSON()
            return
        }
    }()
    req.ShortUrl &lt;/span&gt;=&lt;span&gt; shortUrl
    resp,err :&lt;/span&gt;= Short2Long(&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;short2Long failed error:&quot;&lt;span&gt;,err)
        return
    }

    beego.Info(&lt;/span&gt;&quot;origin url:%s short url:%s&quot;&lt;span&gt;,resp.OriginUrl,shortUrl)
    c.Redirect(resp.OriginUrl,&lt;/span&gt;301&lt;span&gt;)
}

func (c &lt;/span&gt;*&lt;span&gt;ShortUrlController) ShortUrlList() {
    limit,err :&lt;/span&gt;= c.GetInt(&quot;limit&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Warn(&lt;/span&gt;&quot;not have limit params use default 10&quot;&lt;span&gt;)
        limit &lt;/span&gt;= 10&lt;span&gt;
    }
    data,err :&lt;/span&gt;=&lt;span&gt; GetLastShortUrl(limit)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;from db get url list error:&quot;&lt;span&gt;,err)

    }

    for i,v:&lt;/span&gt;=&lt;span&gt; range data{
        v.ShortUrl &lt;/span&gt;= fmt.Sprintf(&quot;/jump/?shorturl=%s&quot;&lt;span&gt;,v.ShortUrl)
        data[i] &lt;/span&gt;=&lt;span&gt; v
    }

    c.Data[&lt;/span&gt;&quot;url_list&quot;] =&lt;span&gt; data
    c.TplName &lt;/span&gt;= &quot;index.tpl&quot;&lt;span&gt;
}

func(c &lt;/span&gt;*&lt;span&gt;ShortUrlController) Long2Short(){
    var req models.Long2ShortRequest
    var resp &lt;/span&gt;*models.Long2ShortResponse = &amp;amp;&lt;span&gt;models.Long2ShortResponse{}

    defer func(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err := recover();err !=&lt;span&gt; nil{
            beego.Error(&lt;/span&gt;&quot;panic err:&quot;&lt;span&gt;,err)
            resp.Code &lt;/span&gt;= 500&lt;span&gt;
            resp.Message &lt;/span&gt;= &quot;server busy&quot;&lt;span&gt;
            c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
            c.ServeJSON()
            return
        }
    }()


    err :&lt;/span&gt;= json.Unmarshal(c.Ctx.Input.RequestBody,&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;unmarshal failed,err:&quot;&lt;span&gt;,err)
        resp.Code &lt;/span&gt;= 1001&lt;span&gt;
        resp.Message &lt;/span&gt;= &quot;json unmarshal failed&quot;&lt;span&gt;
        c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
        c.ServeJSON()
        return
    }
    resp,err &lt;/span&gt;= Long2Short(&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;long2short failed,err:&quot;&lt;span&gt;,err)
        resp.Code &lt;/span&gt;= 1002&lt;span&gt;
        resp.Message &lt;/span&gt;= &quot;long2short failed&quot;&lt;span&gt;
        c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
        c.ServeJSON()
        return
    }
    c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
    c.ServeJSON()



}

func(c &lt;/span&gt;*&lt;span&gt;ShortUrlController) Short2Long(){
    var req models.Short2LongRequest
    var resp &lt;/span&gt;*models.Short2LongResponse = &amp;amp;&lt;span&gt;models.Short2LongResponse{}

    defer func(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err := recover();err !=&lt;span&gt; nil{
            beego.Error(&lt;/span&gt;&quot;panic err:&quot;&lt;span&gt;,err)
            resp.Code &lt;/span&gt;= 500&lt;span&gt;
            resp.Message &lt;/span&gt;= &quot;server busy&quot;&lt;span&gt;
            c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
            c.ServeJSON()
            return
        }
    }()


    err :&lt;/span&gt;= json.Unmarshal(c.Ctx.Input.RequestBody,&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;unmarshal failed,err:&quot;&lt;span&gt;,err)
        resp.Code &lt;/span&gt;= 1001&lt;span&gt;
        resp.Message &lt;/span&gt;= &quot;json unmarshal failed&quot;&lt;span&gt;
        c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
        c.ServeJSON()
        return
    }
    resp,err &lt;/span&gt;= Short2Long(&amp;amp;&lt;span&gt;req)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        beego.Error(&lt;/span&gt;&quot;Short2Long failed,err:&quot;&lt;span&gt;,err)
        resp.Code &lt;/span&gt;= 1002&lt;span&gt;
        resp.Message &lt;/span&gt;= &quot;long2short failed&quot;&lt;span&gt;
        c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
        c.ServeJSON()
        return
    }
    c.Data[&lt;/span&gt;&quot;json&quot;] =&lt;span&gt; resp
    c.ServeJSON()
}



func Long2Short(req &lt;/span&gt;*models.Long2ShortRequest) (response *&lt;span&gt;models.Long2ShortResponse, err error) {
    response &lt;/span&gt;= &amp;amp;&lt;span&gt;models.Long2ShortResponse{}
    urlMd5 :&lt;/span&gt;= fmt.Sprintf(&quot;%x&quot;,md5.Sum([]&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(req.OriginUrl)))
    var &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; ShortUrl
    err &lt;/span&gt;= Db.Get(&amp;amp;&lt;span&gt;short&lt;/span&gt;,&quot;select id,short_url,origin_url,hash_code from short_url where hash_code=?&quot;&lt;span&gt;,urlMd5)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err ==&lt;span&gt; sql.ErrNoRows{
        err &lt;/span&gt;=&lt;span&gt; nil
        &lt;/span&gt;//&lt;span&gt; 数据库中没有记录，重新生成一个新的短url
        shortUrl,errRet :&lt;/span&gt;=&lt;span&gt; generateShortUrl(req,urlMd5)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; errRet !=&lt;span&gt; nil{
            err &lt;/span&gt;=&lt;span&gt; errRet
            return
        }
        response.ShortUrl &lt;/span&gt;=&lt;span&gt; shortUrl
        return
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        return
    }
    response.ShortUrl &lt;/span&gt;= &lt;span&gt;short&lt;/span&gt;&lt;span&gt;.ShortUrl
    return
}

func generateShortUrl(req &lt;/span&gt;*&lt;span&gt;models.Long2ShortRequest,hashcode string)(shortUrl string,err error){
    result,err :&lt;/span&gt;= Db.Exec(&quot;insert INTO short_url(origin_url,hash_code)VALUES (?,?)&quot;&lt;span&gt;,req.OriginUrl,hashcode)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        return
    }
    &lt;/span&gt;// 0-9a-zA-&lt;span&gt;Z 六十二进制
    insertId,_:&lt;/span&gt;=&lt;span&gt; result.LastInsertId()
    shortUrl &lt;/span&gt;=&lt;span&gt; transTo62(insertId)
    _,err &lt;/span&gt;= Db.Exec(&quot;update short_url set short_url=? where id=?&quot;&lt;span&gt;,shortUrl,insertId)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        fmt.Println(err)
        return
    }
    return
}

&lt;/span&gt;// 将十进制转换为62进制   0-9a-zA-&lt;span&gt;Z 六十二进制
func transTo62(id int64)string{
    &lt;/span&gt;// 1 -- &amp;gt; 1
    // 10-- &amp;gt;&lt;span&gt; a
    &lt;/span&gt;// 61-- &amp;gt;&lt;span&gt; Z
    charset :&lt;/span&gt;= &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&lt;span&gt;
    var shortUrl []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
    for{
        var result &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
        number :&lt;/span&gt;= id % 62&lt;span&gt;
        result &lt;/span&gt;=&lt;span&gt; charset[number]
        var tmp []&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;
        tmp &lt;/span&gt;=&lt;span&gt; append(tmp,result)
        shortUrl &lt;/span&gt;=&lt;span&gt; append(tmp,shortUrl...)
        id &lt;/span&gt;= id / 62
        &lt;span&gt;if&lt;/span&gt; id == 0&lt;span&gt;{
            break
        }
    }
    fmt.Println(string(shortUrl))
    return string(shortUrl)
}


func Short2Long(req &lt;/span&gt;*models.Short2LongRequest) (response *&lt;span&gt;models.Short2LongResponse, err error) {
    response &lt;/span&gt;= &amp;amp;&lt;span&gt;models.Short2LongResponse{}
    var &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; ShortUrl
    err &lt;/span&gt;= Db.Get(&amp;amp;&lt;span&gt;short&lt;/span&gt;,&quot;select id,short_url,origin_url,hash_code from short_url where short_url=?&quot;&lt;span&gt;,req.ShortUrl)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err ==&lt;span&gt; sql.ErrNoRows{
        response.Code &lt;/span&gt;= 404&lt;span&gt;
        return
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil{
        response.Code &lt;/span&gt;= 500&lt;span&gt;
        return
    }
    response.OriginUrl &lt;/span&gt;= &lt;span&gt;short&lt;/span&gt;&lt;span&gt;.OriginUrl
    return
}


func GetLastShortUrl(limit &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;)(result []*&lt;span&gt;models.ShortUrl,err error){
    err &lt;/span&gt;= Db.Select(&amp;amp;result,&quot;select short_url from short_url ORDER BY id DESC  limit ? &quot;&lt;span&gt;,limit)
    return
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里添加了一些之前没有的功能：&lt;br/&gt;获取数据库所有的short url 并且显示在页面上了，不过这里非常丑，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180323002208255-1022907955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过点击相应的连接就会跳转到长url的页面&lt;br/&gt;也可以通过模拟发送post请求来查看转换的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180323002354328-562120148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201803/997599-20180323002228338-938090288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 16:23:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8627928.html</dc:identifier>
</item>
<item>
<title>在js中实现新窗口打开页面 - xdxxdx</title>
<link>http://www.cnblogs.com/roy-blog/p/8627895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roy-blog/p/8627895.html</guid>
<description>&lt;p&gt;我们都知道可以在html代码中使用&amp;lt;a href=&quot;xxxx&quot; target=&quot;_blank&quot;&amp;gt;&amp;lt;/a&amp;gt;这种方式来打开一个新的窗口打开一个页面，但是有很多时候，我们需要在某段js代码中去打开一个新的窗口实现页面跳转。有如下几种方法来实现这个功能。&lt;/p&gt;
&lt;p&gt;1.Window.open()方法，比如如下代码，将打开baidu首页。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这个方法是有问题的，那就是有些浏览器会拦截。所以我们需要第二种方法，也是本文主要介绍的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.模拟form表单提交来打开一个新的页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的主要思路就是动态构建一个隐藏的form表单，将其target设为“_blank”,然后在动态构建起表单参数，最后手动触发起click事件。&lt;/p&gt;
&lt;p&gt;举个例子，我们要在一段js代码中打开http://www.baidu.com?a=1这个链接。我们可以用如下的代码来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js代码&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; form='&amp;lt;form action=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot; id=&quot;windowOpen&quot; style=&quot;display:none&quot;&amp;gt;'&lt;span&gt;;
form&lt;/span&gt;+='&amp;lt;input name=&quot;a&quot; value=1 /&amp;gt;'&lt;span&gt;;
form&lt;/span&gt;+='&amp;lt;/form&amp;gt;'&lt;span&gt;;
$(&lt;/span&gt;'body'&lt;span&gt;).append(form);
$(&lt;/span&gt;'#windowOpen'&lt;span&gt;).submit();
$(&lt;/span&gt;'#windowOpen').remove();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，我们可以将上述代码封装成一个函数，函数传入两个参数，一个是url，另外一个是参数param,其中param是一个js对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; open_page(url, param) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; form = '&amp;lt;form action=&quot;' + url + '&quot;  target=&quot;_blank&quot;  id=&quot;windowOpen&quot; style=&quot;display:none&quot;&amp;gt;'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; param) {
            form &lt;/span&gt;+= '&amp;lt;input name=&quot;' + key + '&quot; value=&quot;' + param[key] + '&quot;/&amp;gt;'&lt;span&gt;;
        }
        form &lt;/span&gt;+= '&amp;lt;/form&amp;gt;'&lt;span&gt;;
        $(&lt;/span&gt;'body'&lt;span&gt;).append(form);
        $(&lt;/span&gt;'#windowOpen'&lt;span&gt;).submit();
        $(&lt;/span&gt;'#windowOpen'&lt;span&gt;).remove();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们就可以这样来调用函数了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; url='https://www.baidu.com'&lt;span&gt;；
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param={a:1&lt;span&gt;};
open_page(url,param);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;甚至，我们可以将它封装成一个插件，以后我们就可以直接调用这个插件了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟form表单提交打开新的页面&lt;/span&gt;
&lt;span&gt;$.extend({
    open_page: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(url, param) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; form = '&amp;lt;form action=&quot;' + url + '&quot;  target=&quot;_blank&quot;  id=&quot;windowOpen&quot; style=&quot;display:none&quot;&amp;gt;'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; param) {
            form &lt;/span&gt;+= '&amp;lt;input name=&quot;' + key + '&quot; value=&quot;' + param[key] + '&quot;/&amp;gt;'&lt;span&gt;;
        }
        form &lt;/span&gt;+= '&amp;lt;/form&amp;gt;'&lt;span&gt;;
        $(&lt;/span&gt;'body'&lt;span&gt;).append(form);
        $(&lt;/span&gt;'#windowOpen'&lt;span&gt;).submit();
        $(&lt;/span&gt;'#windowOpen'&lt;span&gt;).remove();
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; url='https://www.baidu.com'&lt;span&gt;；
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param={a:1&lt;span&gt;};
$.open_page(url,param);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 22 Mar 2018 16:14:00 +0000</pubDate>
<dc:creator>xdxxdx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roy-blog/p/8627895.html</dc:identifier>
</item>
<item>
<title>基于 Hexo + GitHub Pages 搭建个人博客（一） - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8627873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8627873.html</guid>
<description>&lt;h2 id=&quot;前言我的博客写作之路&quot;&gt;前言：我的博客写作之路&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;15 年刚上大学，第一次接触公众号，就萌生了创建一个公众号写点东西，但最终不了了之。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;很快到了 16 年，开始接触网上各大博客网站，接触最多的当属 CSDN，萌生了注册一个博客，写一点自己在学习上遇到的问题，分享一些自己的解决办法，但最终还是不了了之。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;16 年暑假，自媒体横行在全国各地，自己眼里似乎看到很多机会有似乎异常模糊。一个偶然的机会让我意识到必须开始弄个博客写点东西了，当时的想法是，先注册个头条号，16年下半年开学再弄博客写东西，这种事情不着急，时间一天天过，但这两件事最终都没做，不了了之。&lt;/li&gt;
&lt;li&gt;时间一分一秒地到了17年，上半年这种注册博客，写博客的心态依然萦绕耳边，但并没有什么实际行动。&lt;/li&gt;
&lt;li&gt;终于到了17年6月份左右，去了一个地方回来后，我手忙脚乱，立刻在网上的平台注册了一个博客，而后开始写自己学习上的东西。而后有急忙地注册了一个微信公众号，第一次开始使用键盘记录自己的学生和生活，而我拖延了2年半的博客与写作之路，也就从此开始。&lt;/li&gt;
&lt;li&gt;网上的某博客平台广告很多，开始时我无从适应，不知道如何排版，加之打字速度与龟速相差不大，夸张点说就是，写一篇几百字的文章要一两个小时，开不知道自己写了什么东西，但也第一次知道了写作的收获如此之大，具体可以说上个三天三夜，这里略。&lt;/li&gt;
&lt;li&gt;慢慢地开始有了搭建一个属于自己的个人博客，于是急功近利，浅藏辄止各种编程语言，最终无功而返，一事无成。&lt;/li&gt;
&lt;li&gt;带着那门基础不扎实的 Java 语言，开始学习框架，搭建博客，尽管各种异常报错，乱码问题，还有点想放弃，却又不甘，因此目前也还在学习。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;慢慢开始了 WordPress ，cnblogs ，简书，掘金等五花八门的信息筛选之中，最终还是选择了搭建一个 Hexo + GitHub Pages 的博客框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基于-hexo-github-page-搭建个人博客&quot;&gt;基于 Hexo + GitHub Page 搭建个人博客&lt;/h2&gt;
&lt;h3 id=&quot;一搭建前准备&quot;&gt;一、搭建前准备&lt;/h3&gt;
&lt;p&gt;1、安装 Git：Git 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。&lt;/p&gt;
&lt;p&gt;（1）下载 Git：&lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;官网下载地址&lt;/a&gt; （各大系统版本都有 Git，这里以 Windows 版本为例）&lt;/p&gt;
&lt;p&gt;（2）双击下载的 Git 安装包开始安装&lt;br/&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）一直点 Next，继续安装&lt;br/&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​（4）点击 Install ，完成安装&lt;br/&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​（5）打开 cmd 命令窗口，执行以下命令，结果显示 Git 版本，安装成功&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git --version&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​（6）、推荐两个学习 Git 的网站：&lt;/p&gt;
&lt;p&gt;2、安装 Node.js：是一个基于 Chrome V8 引擎的 JavaScript 运行环境，轻量高效，Node.js 的包管理器 npm 是全球最大的开源库生态系统。&lt;/p&gt;
&lt;p&gt;（1）下载 Node.js：&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;官网下载地址&lt;/a&gt; （各大系统版本都有，这里以 Windows 为例）&lt;/p&gt;
&lt;p&gt;（2）双击下载的 Node.js 安装包开始安装&lt;br/&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）一直点 Next ，选择安装路径，继续安装&lt;br/&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​（4）点击 Install ，完成安装&lt;br/&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​（5）打开 cmd 命令窗口，执行以下命令，显示 Node.js 版本，安装成功&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/10.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二搭建-hexo-博客&quot;&gt;二、搭建 Hexo 博客&lt;/h3&gt;
&lt;p&gt;1、安装 Hexo，在电脑中新建一个 compassblog 文件夹存放自己的博客，在文件夹内右键点击 Git Bash 进入命令窗口，执行以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install -g hexo-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：&lt;br/&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/11.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、初始化 Hexo，得到 hexo 文件夹，用于存放 Hexo 博客所有的文件，包括下面会讲到的主题文件，Git Bash 窗口执行以下代码：（无特别提示，以下代码基本都在 Git Bash 命令窗口执行）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo init hexo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：&lt;br/&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/12.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、配置 Hexo，进入 hexo 文件夹安装依赖，部署形成的文件，分别执行以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd hexo
npm install
hexo generate&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：&lt;br/&gt;​&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/13.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、启动服务器：执行以下代码，可以看到服务器端口号是 4000&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：按 Ctrl + C 可以停止服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/14.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、打开浏览器，地址栏输入http://localhost:4000/ ，结果如下图，可以看到，初始化的 Hexo 博客搭建成功，可以访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/15.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三将初始化的-hexo-博客部署到-github-pages&quot;&gt;三、将初始化的 Hexo 博客部署到 GitHub Pages&lt;/h3&gt;
&lt;p&gt;1、注册一个 Github 帐号，新建一个仓库，仓库名为：compassblog.github.io ，如下图所示：（由于我的仓库已经创建，所以会显示仓库已经存在，并且这个仓库的名称必须严格按照 username.github.io 的格式来命名）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/16.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、进入已经建好的仓库，点击 settings ，找到 GitHub Pages 选项，点击 Choose a theme 选择一个主题，然后点击 select theme 选择主题，如下图所示：（到这一步其实已经可以在地址栏访问自己选择的主题了，选择主题这一步其实可以忽略，但我觉得 GitHub 提供的主题还是蛮酷的，所以就附上这一步吧）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/17.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、配置 Git 个人信息：在 compassblog 目录打开一个 Git Bash 窗口，输入下面的命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git config --global user.name &quot; GitHub 用户名 &quot;
git config --global user.email &quot; GitHub 邮箱 &quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如我的是如下图这样输入：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、生成 SSH KEY，其实就是生成一个公钥和密钥，因为 GitHub 需要一个密钥才能与本地相连接。执行以下命令，并连续按 3 次回车生成密钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen -t rsa -C &quot; 邮箱地址 &quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我电脑是如下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、SSH KEY 生成之后会默认保存在 C:/Users/电脑名用户名/.ssh 目录中，打开这个目录，打开 id_rsa.pub 文件，复制全部内容，即复制密钥。&lt;/p&gt;
&lt;p&gt;6、打开 GitHub ，依次点击 头像--&amp;gt;Settings--&amp;gt;SSH and GPG keys--&amp;gt;New SSH key，将复制的密钥粘贴到 key 输入框，最后点击 Add Key ，SSH KEY 配置成功，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/20.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、修改 hexo 文件夹下的 _config.yml 全局配置文件，修改 deploy 属性代码，将本地 hexo 项目托管到 GitHub 上，如下图所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;deploy:
  type: git     #部署的类型
  repository: git@github.com:compassblog/compassblog.github.io.git # 仓库地址
  branch: master        #分支名称
  message: hexo deploy  #提交信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/21.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/22.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8、执行下面的命令，安装 hexo-deployer-git 插件，快速把代码托管到 GitHub 上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install hexo-deployer-git --sava&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/23.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、执行下面的代码命令，将 hexo 项目托管到 GitHub 上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo clean &amp;amp;&amp;amp; hexo generate &amp;amp;&amp;amp; hexo deploy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：hexo generate 可缩写为 hexo g ， hexo deploy 可缩写为 hexo d&lt;/p&gt;
&lt;p&gt;结果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/24.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、浏览器地址栏输入 &lt;a href=&quot;https://username.github.io/&quot; class=&quot;uri&quot;&gt;https://username.github.io/&lt;/a&gt; 访问，可以看到博客已经部署到 GitHub 上，正常访问，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/03/21/25.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后写几句&quot;&gt;最后写几句&lt;/h2&gt;
&lt;p&gt;我本来想一次把这个基于 Hexo + GitHub Pages 搭建个人博客流程发布在一篇文章上面发布出来的，但实在是太长了，很难一篇文章写完。关于博客如何更换主题，如何进行个性更换，具体的配置等等很多的配置，后面找时间再持续的发布出来，欢迎关注，Thanks 。&lt;/p&gt;
&lt;h2 id=&quot;扫描二维码关注微信公众号了解更多&quot;&gt;扫描二维码关注微信公众号，了解更多&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/about/wechat-qcode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 16:09:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8627873.html</dc:identifier>
</item>
<item>
<title>python函数式编程之生成器 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/8627853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/8627853.html</guid>
<description>&lt;p&gt;在前面的学习过程中，我们知道，迭代器有两个好处：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;一是不依赖索引的统一的迭代方法
二是惰性计算，节省内存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是迭代器也有自己的显著的缺点，那就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不如按照索引取值方便 
一次性，只能向后取值，不能向前取值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们还需要学习另外一种对象，那已经&lt;code&gt;生成器&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是生成器&quot;&gt;1.什么是生成器&lt;/h3&gt;
&lt;p&gt;如果一个函数体内部包含yield关键字，该函数就是生成器函数，执行该函数就得到一个生成器对象&lt;/p&gt;
&lt;h3 id=&quot;得到生成器&quot;&gt;2.得到生成器&lt;/h3&gt;
&lt;p&gt;先来看下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield
    print(&quot;second...&quot;)
    yield
    print(&quot;third...&quot;)

g=foo()
print(g)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上面生成器的定义：&lt;code&gt;函数体内部包含yield关键字，则该函数就是生成器函数&lt;/code&gt;，则上面的函数执行结果就是一个生成器对象&lt;/p&gt;
&lt;p&gt;执行上面的代码，查看程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;generator object foo at 0x0000000001DF2BF8&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出：&lt;code&gt;上面的函数执行的结果g就是一个生成器对象，上面的函数foo就是一个生成器函数&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成器的内置方法&quot;&gt;3.生成器的内置方法&lt;/h3&gt;
&lt;p&gt;修改上面的代码,调用dir方法查看生成器中包含的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield
    print(&quot;second...&quot;)
    yield
    print(&quot;third...&quot;)

g=foo()
print(dir(g))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印生成器内部的方法，可以看到打印的结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这些结果中，可以看到有&lt;code&gt;__iter__方法&lt;/code&gt;和&lt;code&gt;__next__方法&lt;/code&gt;，由此可以判断出&lt;code&gt;生成器的本质就是迭代器&lt;/code&gt;&lt;br/&gt;，&lt;code&gt;生成器是迭代器的一种&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;判断生成器是否是迭代器&quot;&gt;4.判断生成器是否是迭代器&lt;/h3&gt;
&lt;p&gt;修改上面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield
    print(&quot;second...&quot;)
    yield
    print(&quot;third...&quot;)

g=foo()

from collections import Iterable

print(isinstance(g,Iterable))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的两个例子都可以证明：&lt;code&gt;生成器的本质是迭代器，生成器就是迭代器的一种&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;生成器的-__iter__方法和__next__方法&quot;&gt;5.生成器的 &lt;code&gt;__iter__方法&lt;/code&gt;和&lt;code&gt;__next__方法&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;既然生成器的本质是迭代器，那么调用生成器的 &lt;code&gt;__iter__方法&lt;/code&gt;和&lt;code&gt;__next__方法&lt;/code&gt;，得到的结果会是什么呢&lt;/p&gt;
&lt;p&gt;修改上面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield
    print(&quot;second...&quot;)
    yield
    print(&quot;third...&quot;)

g=foo()

print(g)
print(g.__iter__())
g.__next__()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;generator object foo at 0x0000000001DF2BF8&amp;gt;
&amp;lt;generator object foo at 0x0000000001DF2BF8&amp;gt;
first...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的程序的执行结果可以看出：&lt;code&gt;直接打印生成器g和调用生成器g.__iter__方法，得到的结果都是生成器对象g 在内存中的地址&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;g.__next__&lt;/code&gt;方法，实际上就是从生成器g中取出一个值，执行一次&lt;code&gt;g.__next__&lt;/code&gt;方法，触发一次生成器的取值操作，这个过程在上面的代码中表现为foo函数的向下执行过程&lt;/p&gt;
&lt;p&gt;从上面的程序的执行结果中可以看到，只执行了foo函数的第一个print函数，并没有执行第二个和第三个print函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;通常对函数来说，函数开始执行以后直到return语句，函数才会停止执行&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里执行一次&lt;code&gt;g.__next__&lt;/code&gt;方法，foo函数中执行了一行代码，遇到yield就停止了，在这里yield好像起到了return的作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;实际上，yield关键字的功能之一就是起到返回的作用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的程序执行遇到yield，本次&lt;code&gt;g.__next__&lt;/code&gt;方法执行完毕。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在函数的执行过程中，如果函数的return语句有返回值，则函数的执行完成就得到return语句的返回值，
如果return没有定义返回值或者函数中没有定义return语句，则函数的执行结果默认为None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改上面的代码，打印&lt;code&gt;__next__&lt;/code&gt;方法的执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield
    print(&quot;second...&quot;)
    yield
    print(&quot;third...&quot;)

g=foo()

print(g.__next__())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;first...
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，调用&lt;code&gt;__next__&lt;/code&gt;方法时，yield后没接任何参数时，&lt;code&gt;yield默认的返回值也是None&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;yield后面接返回值&quot;&gt;6.yield后面接返回值&lt;/h3&gt;
&lt;p&gt;那如果在yield关键字后接一个返回值，程序执行结果会是怎么样的呢&lt;br/&gt;修改上面的代码，在yield关键字后接一个返回值,看程序的执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield 1
    print(&quot;second...&quot;)
    yield 2
    print(&quot;third...&quot;)

g=foo()
print(g.__next__())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;first...
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的程序的执行结果可以看出，yield会把其后面接的数返回，作为&lt;code&gt;__next__&lt;/code&gt;方法的执行结果&lt;/p&gt;
&lt;h3 id=&quot;yield与return的不同点&quot;&gt;7.yield与return的不同点&lt;/h3&gt;
&lt;p&gt;在函数中，不管一个函数中定义了多少个return语句，函数在执行到第一个return语句的时候就会中止，其后面的语句将不会被继续执行&lt;/p&gt;
&lt;p&gt;而对于yield来说，每调用一次&lt;code&gt;__next__&lt;/code&gt;方法，程序会从开始向下执行，直到遇到yield语句，程序暂停，等到第二次调用&lt;code&gt;__next__&lt;/code&gt;方法，程序会从上次暂停的地方继续向下执行，直到遇到下一个yield或者程序执行完成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在上面的例子里，是使用yield把函数foo变成一个生成器，执行foo函数时，并不会立即执行foo函数，而是先得到生成器g,当调用一次`g.__next__`方法时，函数foo开始向下执行，遇到yield时，程序暂停，当下一次调用`g.__next__`方法时，函数foo继续从上一次暂停的地方开始向下执行，直到遇到yield暂停&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成器的stopiteration&quot;&gt;8.生成器的StopIteration&lt;/h3&gt;
&lt;p&gt;修改程序，多次调用&lt;code&gt;__next__&lt;/code&gt;方法，查看程序的执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield
    print(&quot;second...&quot;)
    yield
    print(&quot;third...&quot;)

g=foo()

print(g)
print(g.__iter__())
g.__next__()
print('*'*30)
g.__next__()
print('#'*30)
g.__next__()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;generator object foo at 0x0000000001DF2BF8&amp;gt;
&amp;lt;generator object foo at 0x0000000001DF2BF8&amp;gt;
first...
******************************
second...
##############################
third...
Traceback (most recent call last):
  File &quot;E:/py_code/test.py&quot;, line 28, in &amp;lt;module&amp;gt;
    g.__next__()
StopIteration&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面程序的执行结果可以看出，每调用一次生成器的&lt;code&gt;__next__&lt;/code&gt;方法，会得到一个返回值，就相当于从迭代器中取一个值。&lt;/p&gt;
&lt;p&gt;如果程序在执行过程中，没有得到返回值，这就说明迭代器的最后一个值已经被遍历完成了，所以此时再调用&lt;code&gt;__next__&lt;/code&gt;方法，程序就会抛出异常&lt;/p&gt;
&lt;h3 id=&quot;生成器的for循环遍历&quot;&gt;9.生成器的for循环遍历&lt;/h3&gt;
&lt;p&gt;在前面的学习中已经知道，&lt;code&gt;生成器本质上就是一个迭代器&lt;/code&gt;。既然是迭代器，那么当然可以使用for循环来遍历生成器&lt;/p&gt;
&lt;p&gt;修改上面的例子，使用for循环来遍历生成器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def foo():
    print(&quot;first...&quot;)
    yield 1
    print(&quot;second...&quot;)
    yield 2
    print(&quot;third...&quot;)

g=foo()

for i in g:
    print(i)
    print(&quot;*&quot;*30)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看程序的执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;first...
1
******************************
second...
2
******************************
third...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子里,每执行一次for循环，就相当于是执行一次&lt;code&gt;g.__next__&lt;/code&gt;方法，yield会返回其后所接的数字，所以for循环前两次的执行结果都是print函数和yield后接的数字&lt;/p&gt;
&lt;p&gt;for循环执行到第三次的时候，执行完print函数，程序会抛出&lt;code&gt;StopIteration&lt;/code&gt;异常，但是&lt;code&gt;StopIteration&lt;/code&gt;的异常会被for循环捕捉到，所以for循环执行第三次只执行了print语句&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;10.总结：&lt;/h3&gt;
&lt;p&gt;yield关键字的功能:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;与return的功能类似，都可以返回值，但不一样的地方在于一个函数中可以多次调用yield来返回值
为函数封装好了`__iter__方法`和`__next__方法`，把函数的执行结果变成了迭代器
`遵循迭代器的取值方式(obj.__next__())`,触发的函数的执行，函数暂停与再继续都由yield保存&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;示例使用yield模拟linux中的命令tail--f-grep-error-grep-404&quot;&gt;11.示例：使用yield模拟linux中的命令：tail -f | grep 'error' | grep '404'&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import time

def tail(file_path, encoding='utf-8'):
    with open(file_path, encoding=encoding) as f:
        f.seek(0, 2)
        while True:
            line = f.readline()
            if line:
                yield line
            else:
                time.sleep(0.5)

def grep(lines, pattern):
    for line in lines:
        if pattern in line:
            yield line

g1 = tail('a.txt')
g2 = grep(g1, 'error')
g3 = grep(g2, '404')

for i in g3:
    print(i)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 22 Mar 2018 16:02:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/8627853.html</dc:identifier>
</item>
<item>
<title>Ubuntu16.04 中 Vscode 如何断点调试C语言程序 - feiffy</title>
<link>http://www.cnblogs.com/feifeifanye/p/8627812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifeifanye/p/8627812.html</guid>
<description>&lt;p&gt;个人博客链接：&lt;a href=&quot;https://feiffy.cc/Visual_Studio_Code#Ubuntu16.04_.E4.B8.AD_Vscode_.E5.A6.82.E4.BD.95.E6.96.AD.E7.82.B9.E8.B0.83.E8.AF.95C.E8.AF.AD.E8.A8.80.E7.A8.8B.E5.BA.8F&quot; target=&quot;_blank&quot;&gt;Ubuntu16.04 中 Vscode 如何断点调试C语言程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;问题：环境是 Ubuntu16.04，如何使用 Vscode 断点调试C语言程序。&lt;/p&gt;
&lt;p&gt;写代码没有调试环境是不能忍受的，所以折腾了一下，最后成功了。折腾的过程是这样的：&lt;/p&gt;
&lt;p&gt;1、 首先安装 C/C++ 扩展，直接搜索第一个就是，或者点此 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt; 查看其帮助文档进行安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/941616/201803/941616-20180322235147305-1226662142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、然后打开当前项目目录，左边点调试选项，点击添加配置，生成了一个launch.json文件，其内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
    {
        &quot;name&quot;: &quot;(gdb) Launch&quot;,
        &quot;type&quot;: &quot;cppdbg&quot;,
        &quot;request&quot;: &quot;launch&quot;,
        &quot;program&quot;: &quot;${workspaceFolder}/LearnC/bin/a.out&quot;,
        &quot;args&quot;: [],
        &quot;stopAtEntry&quot;: false,
        &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
        &quot;environment&quot;: [],
        &quot;externalConsole&quot;: true,
        &quot;MIMode&quot;: &quot;gdb&quot;,
        &quot;setupCommands&quot;: [
            {
                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                &quot;ignoreFailures&quot;: true
            }
        ]
    }]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有内容都是默认生成的配置，我只是修改了&quot;program&quot;这一行，指定为编译后的可执行文件。这样，调试的时候默认调试这个文件。&lt;/p&gt;
&lt;p&gt;相关操作截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/941616/201803/941616-20180322235209941-1032228715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择 add configuration&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/941616/201803/941616-20180322235218706-2139769976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择 C++(GDB/LLDB)&lt;/p&gt;
&lt;p&gt;3、编辑代码，完成后，首先要编译，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ gcc -g -o /path/LearnC/bin/a.out [[SOURCE_FILE]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个路径指定生成后的文件，一定要是之前program参数指定的文件路径，SOURCE_FILE表示C语言文件路径。&lt;/p&gt;
&lt;p&gt;4、然后打开调试，我的快捷键是F5，打开之后，就能直接运行到断点处了，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/941616/201803/941616-20180322235235577-1941679507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 15:53:00 +0000</pubDate>
<dc:creator>feiffy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feifeifanye/p/8627812.html</dc:identifier>
</item>
</channel>
</rss>